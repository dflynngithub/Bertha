      PROGRAM BERTHA
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         BBBBBBB  EEEEEEEE RRRRRRR TTTTTTTT HH    HH    AA            C
C         BB    BB EE       RR    RR   TT    HH    HH   AAAA           C
C         BB    BB EE       RR    RR   TT    HH    HH  AA  AA          C
C         BBBBBBB  EEEEEE   RR    RR   TT    HHHHHHHH AA    AA         C
C         BB    BB EE       RRRRRRR    TT    HH    HH AAAAAAAA         C
C         BB    BB EE       RR    RR   TT    HH    HH AA    AA         C
C         BBBBBBB  EEEEEEEE RR    RR   TT    HH    HH AA    AA         C
C                                                                      C
C                 (THE PROGRAM FORMERLY KNOWN AS...)                   C
C                                                                      C
C      SSSSSS  WW        WW IIII RRRRRRR  LL      EEEEEEEE SSSSSS      C
C     SS    SS WW        WW  II  RR    RR LL      EE      SS    SS     C
C     SS       WW   WW   WW  II  RR    RR LL      EE      SS           C
C      SSSSSS  WW  WWWW  WW  II  RR    RR LL      EEEEEE   SSSSSS      C
C           SS WW WW  WW WW  II  RRRRRRR  LL      EE            SS     C
C     SS    SS WWWW    WWWW  II  RR    RR LL      EE      SS    SS     C
C      SSSSSS  WW        WW IIII RR    RR LLLLLLL EEEEEEEE SSSSSS      C
C                                                                      C
C ******************************************************************** C
C                                                                      C
C  *   *   *   *   RRRRRRR   SSSSSS  PPPPPPP TTTTTTTT   *   *   *   *  C
C    *   *   *     RR    RR SS    SS PP    PP   TT        *   *   *    C
C  *   *   *   *   RR    RR SS       PP    PP   TT      *   *   *   *  C
C    *   *   *     RR    RR  SSSSSS  PP    PP   TT        *   *   *    C
C  *   *   *   *   RRRRRRR        SS PPPPPPP    TT      *   *   *   *  C
C    *   *   *     RR    RR SS    SS PP         TT        *   *   *    C
C  *   *   *   *   RR    RR  SSSSSS  PP         TT      *   *   *   *  C
C                                                                      C
C ******************************************************************** C
C                                                                      C
C        A RELATIVISTIC MOLECULAR ELECTRONIC STRUCTURE PROGRAM         C
C            BASED ON THE ANALYTIC FINITE BASIS SET METHOD.            C
C                                                                      C
C                 H.M.QUINEY, H.SKAANE (OXFORD, 1997)                  C
C                       D. FLYNN (UNIMELB, 2020)                       C
C                                                                      C
C -------------------------------------------------------------------- C
C                          HAMILTONIANS (HMLT)                         C
C                          -------------------                         C
C ▶ 'NORL' NON-RELATIVISTIC HAMILTONIAN (PAULI EQUATION).              C
C ▶ 'BARE' BARE NUCLEUS DIRAC HAMILTONIAN (NO ELECTRON INTERACTION).   C
C ▶ 'DHFR' DIRAC-COULOMB HAMILTONIAN.                                  C
C ▶ 'DHFP' DIRAC-COULOMB HAMILTONIAN (+1ST ORDER BREIT AND QED).       C
C ▶ 'DHFB' DIRAC-COULOMB-BREIT HAMILTONIAN.                            C
C ▶ 'DHFQ' DIRAC-COULOMB-BREIT HAMILTONIAN WITH LEADING-ORDER QED.     C
C -------------------------------------------------------------------- C
C                   CALCULATION TREE OPTIONS (TREE)                    C
C                   -------------------------------                    C
C  HFSCF: HARTREE-FOCK SCF CALCULATION.                                C
C  MBPTN: NTH-ORDER MANY-BODY DIAGRAMMATIC PERTURBATION THEORY.        C
C  MCSCF: MULTI-CONFIGURATIONAL SCF CALCULATION.                       C
C  EXPVL: CALCULATION OF MOLECULAR EXPECTATION VALUES.                 C
C  PLOTS: VISUALS (ELECTROMAGNETIC FIELDS, POTENTIALS, FORM FACTORS).  C
C -------------------------------------------------------------------- C
C                          TABLE OF CONTENTS                           C
C                          -----------------                           C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C   [4] ATOMIC HARTREE-FOCK: AVERAGE OF CONFIG. ATOMIC SCF.            C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTRE HARTREE-FOCK SCF.          C
C   [7] MULTI-CONFIG: MANY-CENTRE MULTICONFIG. SCF CALCULATIONS.       C
C   [8] MBPTN: CORRELATION ENERGY CALCULATION ROUTINES.                C
C   [9] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C  [10] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C  [11] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C  [12] EQ-COEFFS: BASIS FUNCTION OVERLAP SPIN-STRUCTURE FACTORS.      C
C  [13] GQ-COEFFS: ANALYTIC DERIVS OF OVERLAP SPIN-STRUCTURE FACTORS.  C
C  [14] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/TCPU/TBEG,TNUC,TATM,TSCF,TMPT,TPRP,TPLT,TTOT
C
C     READ DATA FROM USER-SPECIFIED INPUT FILE
      CALL CARDIN
C
C     THIS IS EXPLICITLY AN MBPT PROGRAM
      IF(TREE.NE.'EXPVL') RETURN
C
C     OPEN FILE FOR TERMINAL RECORD
      OPEN(UNIT=7,FILE=TRIM(OUTFL)//'_property.out',STATUS='UNKNOWN')
C
C     PRINT SUMMARY OF INPUT DATA
      CALL INPUT
C
C     PRINT MEMORY ALLOCATION SUMMARY
      CALL MEMORY
C
C     INTER-ATOMIC ANGLES AND NUCLEAR REPULSION ENERGY
      CALL NUCGEOM
C
C     NUCLEAR POTENTIALS
      CALL CPU_TIME(T0)
      CALL NUCCOUL
      CALL NUCVCPL
      CALL CPU_TIME(TNUC)
      TNUC = TNUC-T0
C
C     FOCK MATRIX SYMMETRY TYPE INDICES
      CALL FOCKIND
C
C     CARTESIAN EXPANSION INDICES FOR BASIS FUNCTION OVERLAP PAIRS
      CALL CARTIND
C
C     REORDER THE SAVED WAVEFUNCTION FILE
      CALL WVFSORT
C
C     ONE-BODY HAMILTONIAN INTERACTIONS FROM A CONVERGED SOLUTION
      CALL CPU_TIME(T0)
      CALL PT1BODY
      CALL CPU_TIME(TPRP)
      TPRP = TPRP-T0
C
C     PRINT SUMMARY OF OUTPUT DATA
      CALL OUTPUT
C
C     CLOSE FILE FOR TERMINAL RECORD
      CLOSE(UNIT=7)
C
C     SUCCESSFUL EXIT
      END PROGRAM
C
C
C**********************************************************************C
C ==================================================================== C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] CARDIN: READ MOLECULAR DATA FROM A USER-SPECIFIED FILE.        C
C   [B] INPUT: WRITE A SUMMARY OF DATA INPUT OPTIONS TO TERMINAL.      C
C   [C] MEMORY: WRITE A SUMMARY OF MEMORY REQUIREMENTS OF BIG ARRAYS.  C
C   [D] OUTPUT: WRITE A SUMMARY OF TOTAL CALCULATION STATS/DATA.       C
C   [E] PHYSPRM: PHYSICAL CONSTANTS, TRANSCENDENTALS AND ELEMENT NAMES.C
C   [F] GAMGEN: LIST OF GAMMA FUNCTIONS FOR INT AND HALF-INT ARGS.     C
C   [G] FACTRL: LIST OF FACTORIALS AND DOUBLE FACTORIALS.              C
C**********************************************************************C
C
C
      SUBROUTINE CARDIN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            CCCCCC     AA    RRRRRRR  DDDDDDD IIII NN    NN           C
C           CC    CC   AAAA   RR    RR DD    DD II  NNN   NN           C
C           CC        AA  AA  RR    RR DD    DD II  NNNN  NN           C
C           CC       AA    AA RR    RR DD    DD II  NN NN NN           C
C           CC       AAAAAAAA RRRRRRR  DD    DD II  NN  NNNN           C
C           CC    CC AA    AA RR    RR DD    DD II  NN   NNN           C
C            CCCCCC  AA    AA RR    RR DDDDDDD IIII NN    NN           C
C                                                                      C
C                          INPUT ROUTINE FOR                           C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  CARDIN READS AND PREPARES DATA FROM A USER-SPECIFIED INPUT FILE.    C
C  THIS IS ALSO WHERE ATOMIC ELEMENT NAMES AND CV ARE SPECIFIED.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C     INCLUDE 'omp_lib.h'
C
      LOGICAL FILETHERE
C
      CHARACTER*1  DUMLIN
      CHARACTER*5  NMDL
      CHARACTER*6  CNFG
      CHARACTER*7  HMINT(50),PTYPE(10)
      CHARACTER*9  BTYP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FILL/NCNF(MCT,0:MEL,MKP+1),NLVL(MCT,0:MEL),CNFG(MCT)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/PLOT/NPTYPE,PTYPE
      COMMON/PT1B/NHMINT,HMINT
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     GENERATE SOME MATHEMATICAL LISTS
      CALL FACTRL
      CALL GAMGEN
C
C     MANUAL CHOICES
      EQFILE = .TRUE.
      OPENMP = .FALSE.
C
C**********************************************************************C
C     MOLECULE NAME AND CALCULATION TYPE                               C
C**********************************************************************C
C
C     MOLECULE OUTPUT STRING
      READ(5, *) DUMLIN
      READ(5, *) MOLCL
C
C     CALCULATION TREE: HFSCF, MBPTN, MCSCF, EXPVL, PLOTS
      READ(5, *) DUMLIN
      READ(5, *) TREE
      TREE = 'EXPVL'
C
C     CALCULATION TREE CHECK -- IF UNKNOWN, EXIT.
      IF(TREE.NE.'HFSCF'.AND.TREE.NE.'MBPTN'.AND.TREE.NE.'MCSCF'.AND.
     &   TREE.NE.'EXPVL'.AND.TREE.NE.'PLOTS') THEN
        WRITE(6, *) 'In CARDIN: invalid calculation tree. ',TREE
        WRITE(7, *) 'In CARDIN: invalid calculation tree. ',TREE
        STOP
      ENDIF
C
C     HAMILTONIAN: NORL, BARE, DHFR, DHFP, DHFB OR DHFQ
10    FORMAT(A4)
      READ(5, *) DUMLIN
      READ(5,10) HMLT
      HMLT = 'DHFR'
C
C     HAMILTONIAN CHECK -- IF UNKNOWN, EXIT.
      IF(HMLT.NE.'NORL'.AND.HMLT.NE.'BARE'.AND.HMLT.NE.'DHFR'.AND.
     &   HMLT.NE.'DHFP'.AND.HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
        WRITE(6, *) 'In CARDIN: unknown HMLT value. HMLT = ',HMLT
        WRITE(7, *) 'In CARDIN: unknown HMLT value. HMLT = ',HMLT
        STOP
      ENDIF
C
C     WAVE FUNCTION FILE NAME
      WFNFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'.wfn'
C
C     OUTPUT FILE NAME
      OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_'//TREE
C
C     CONTINUING CALCULATION: READ-IN (TRUE), NEW START (FALSE)
      READ(5, *) DUMLIN
      READ(5, *) READIN
C
C**********************************************************************C
C     ATOMIC CENTRES AND BASIS FUNCTIONS                               C
C**********************************************************************C
C
C     NUMBER OF ATOMIC CENTRES
      READ(5, *) DUMLIN
      READ(5, *) NCNT
C
C     CHECK THAT NCNT CAN BE SUPPORTED BY SYSTEM PARAMETERS
      IF(NCNT.GT.MCT) THEN
        WRITE(6, *) 'In CARDIN: number of centres exceeds MCT.',MCT
        WRITE(7, *) 'In CARDIN: number of centres exceeds MCT.',MCT
        STOP
      ENDIF
C
C     INITIALISE MAXIMUM LQN AND DIMENSION COUNTERS
      LBIG = 0
      NDIM = 0
C
C     LOOP OVER ATOMIC CENTRES
      DO IZ=1,NCNT
C
C       CARTESIAN COORDINATES OF THIS CENTRE
        READ(5, *) DUMLIN
        READ(5, *) DUMLIN
        READ(5, *) (BXYZ(J,IZ),J=1,3)
C
C       NUCLEUS: MODEL, CHARGE, MASS
        READ(5, *) DUMLIN
        READ(5, *) NMDL(IZ),ZNUC(IZ),ANUC(IZ)
C
C       CHECK THAT NUCLEAR MODEL IS ALLOWED
        IF(NMDL(IZ).NE.'POINT'.AND.NMDL(IZ).NE.'GAUSS'.AND.
     &     NMDL(IZ).NE.'FERMI'.AND.NMDL(IZ).NE.'UNIFM') THEN
          WRITE(6, *) 'In CARDIN: illegal nuclear model.',NMDL(IZ)
          WRITE(7, *) 'In CARDIN: illegal nuclear model.',NMDL(IZ)
          STOP
        ENDIF
C
C       ATOMIC BASIS: TYPE AND LMAX
        READ(5, *) DUMLIN
        READ(5, *) BTYP,LMAX
C
C       CHECK THAT BASIS TYPE IS ALLOWED
        IF(BTYP.NE.'OPTIMISED'.AND.BTYP.NE.'GEOMETRIC'
     &                        .AND.BTYP.NE.'EVENTEMPR') THEN
          WRITE(6, *) 'In CARDIN: illegal basis type.',BTYP
          WRITE(7, *) 'In CARDIN: illegal basis type.',BTYP
          STOP
        ENDIF
C
C       NUMBER OF KAPPA VALUES FOR THIS ATOM
        NKAP(IZ) = 2*LMAX+1
C
C       CHECK THAT LMAX CAN BE SUPPORTED BY SYSTEM PARAMETERS
        IF(2*LMAX+1.GT.MKP) THEN
          WRITE(6, *) 'In CARDIN: LMAX runs outside MKP storage.'
          WRITE(7, *) 'In CARDIN: LMAX runs outside MKP storage.'
          STOP
        ENDIF
C
C       ELECTRON CONFIGURATION CHOICE AND NUCLEAR ELECTRONIC CHARGE
        READ(5, *) DUMLIN
        READ(5, *) CNFG(IZ),IQNC(IZ)
C
C       CHECK THAT CNFG IS ALLOWED
        IF(CNFG(IZ).NE.'AUFBAU'.AND.CNFG(IZ).NE.'MANUAL') THEN
          WRITE(6, *) 'In CARDIN: illegal CNFG option.',CNFG(IZ)
          WRITE(7, *) 'In CARDIN: illegal CNFG option.',CNFG(IZ)
          STOP
        ENDIF
C
C       IF FILLING IS MANUAL, IMPORT ATOMIC ELECTRON CONFIGURATION
        IF(CNFG(IZ).EQ.'MANUAL') THEN
          READ(5, *) DUMLIN
          DO L=0,LMAX
            READ(5, *) NLVL(IZ,L),(NCNF(IZ,L,N),N=1,NLVL(IZ,L))
          ENDDO
        ENDIF
C
C       UPDATE OVERALL MAXIMUM OCCURRING LQN
        IF(LMAX.GT.LBIG) LBIG = LMAX
C
C       OPTIMISED EXPONENTS FROM A RECORDED LIST
        IF(BTYP.EQ.'OPTIMISED') THEN
C
C         TITLE FILLER
          READ(5, *) DUMLIN
C
C         READ IN THE OPTIMISED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX
C
C           READ NUMBER OF BASIS FUNCTIONS
            READ(5, *) NFNC(LQN,IZ)
C
C           CHECK THAT THIS CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN,IZ).GT.MBS) THEN
              NOOPS = NFNC(LQN,IZ)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
C           READ BASIS EXPONENTS FROM A LIST
            DO IBAS=1,NFNC(LQN,IZ)
              READ(5, *) BEXL(IBAS,LQN,IZ)
            ENDDO
C
          ENDDO
C
C       GEOMETRIC BASIS FUNCTIONS
        ELSEIF(BTYP.EQ.'GEOMETRIC') THEN
C
C         TITLE FILLER
          READ(5, *) DUMLIN
C
C         GENERATE THE EVEN TEMPERED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX
C
C           READ GENERATING PARAMETERS A, B AND NFNC
            READ(5, *) ALPH,BETA,NFNC(LQN,IZ)
C
C           GENERATE NFNC BASIS EXPONENTS USING VARIABLE ZETA
            ZETA = ALPH
            DO IBAS=1,NFNC(LQN,IZ)
              BEXL(IBAS,LQN,IZ) = ZETA
              ZETA = ZETA*BETA
            ENDDO
C
C           CHECK THAT NFNC CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN,IZ).GT.MBS) THEN
              NOOPS = NFNC(LQN,IZ)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
          ENDDO
C
C       EVEN-TEMPERED GEOMETRIC BASIS FUNCTIONS
        ELSEIF(BTYP.EQ.'EVENTEMPR') THEN
C
C         TITLE FILLER
          READ(5, *) DUMLIN
C
C         GENERATE THE EVEN TEMPERED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX
C
C           READ GENERATING PARAMETERS A, B, NFNC AND STARTING POINT
            READ(5, *) ALPH,BETA,NFNC(LQN,IZ),N1
C
C           GENERATE NFNC BASIS EXPONENTS USING VARIABLE ZETA
            ZETA = ALPH
            DO IBAS=1,N1-1
              ZETA = ZETA*BETA
            ENDDO
            DO IBAS=1,NFNC(LQN,IZ)
              BEXL(IBAS,LQN,IZ) = ZETA
              ZETA = ZETA*BETA
            ENDDO
C
C           CHECK THAT NFNC CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN,IZ).GT.MBS) THEN
              NOOPS = NFNC(LQN,IZ)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
          ENDDO
C
C       END IF STATEMENT FOR TYPE OF BASIS FUNCTION
        ENDIF
C
C       LOOP OVER ALL LQNS IN THIS CENTRE AND ADD TO FOCK DIMENSION
        DO LQN=0,LMAX
C
C         EXTEND DIMENSION OF FOCK MATRIX
          NDIM = NDIM + 4*(2*LQN+1)*NFNC(LQN,IZ)
C
C         ASSIGN KQN VALUES
          IF(LQN.NE.0) THEN
            KAPA(2*LQN  ,IZ) = LQN
          ENDIF
          KAPA(2*LQN+1,IZ) =-LQN-1
C
        ENDDO
C
C     END LOOP OVER ATOMIC CENTRES
      ENDDO
C
C     TOTAL DIMENSION DEPENDING ON CHOICE OF HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
        NDIM = NDIM/2
        NSKP = 0
      ELSE
        NSKP = NDIM/2
      ENDIF
C
C     CHECK THAT SYSTEM PARAMETERS CAN SUPPORT NDIM
      IF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        WRITE(7, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        STOP
      ENDIF
C
C**********************************************************************C
C     CLOSED/OPEN SHELL DETAILS                                        C
C**********************************************************************C
C
C     NUMBER OF CLOSED- AND OPEN-SHELL ORBITALS AND OPEN SHELL ELECTRONS
      READ(5, *) DUMLIN
      READ(5, *) NCLS,NOPN,NOELEC
C
C     TOTAL NUMBER OF 'OCCUPIED' AND 'VIRTUAL' ORBITALS IN SYSTEM
      NOCC = NCLS+NOPN
      NVRT = NDIM-NSKP-NOCC
C
C     INVALID CHOICE OF NOPN
      IF(NOPN.LT.0) THEN
        WRITE(6, *) 'In CARDIN: invalid value NOPN.',NOPN
        WRITE(7, *) 'In CARDIN: invalid value NOPN.',NOPN
        STOP
      ENDIF
C
C     CLOSED-SHELL MOLECULAR CONFIGURATION
      IF(NOPN.EQ.0) THEN
C
C       LABEL THE CLOSED-SHELL ELECTRON ORBITALS
        DO JCL=1,NCLS
          ICLS(JCL) = JCL
        ENDDO
C
C     OPEN-SHELL MOLECULAR CONFIGURATION
      ELSEIF(NOPN.GT.0) THEN
C
C       FRACTIONAL OCCUPANCY OF THE OPEN-SHELL ORBITALS
        FOPN = DFLOAT(NOELEC)/DFLOAT(NOPN)
C
C       SYMMETRY-ADAPTED CONFIGURATION OF OPEN-SHELL ORBITALS
        READ(5, *) DUMLIN
        READ(5, *) ACFF,BCFF,(IOPN(M),M=1,NOPN)
C
C       LABEL THE CLOSED-SHELL ELECTRON ORBITALS
        JCL = 1
        JOP = 1
        DO JCOUNT=1,NOCC
C
C         APPLY LABEL TO EACH ORBITAL
          IF(JCOUNT.NE.IOPN(JOP)) THEN
            ICLS(JCL) = JCOUNT
            JCL = JCL + 1
          ELSE
            JOP = JOP + 1
          ENDIF
C
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     LEVEL SHIFTING AND INTEGRAL INCLUSION STARTING POINT             C
C**********************************************************************C
C
C     LEVEL SHIFT PARAMETER FOR EACH INTEGRAL STAGE (SKAANE 4.4.3)
      READ(5, *) DUMLIN
      READ(5, *) (SHLEV(N),N=1,3)
C
C     STARTING STAGE OF INTEGRAL INCLUSION LEVEL (1-3)
      READ(5, *) DUMLIN
      READ(5, *) ILEV
C
C     CHECK FOR INVALID CHOICE OF ILEV
      IF(ILEV.LT.1.AND.ILEV.GT.4) THEN
        WRITE(6, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        WRITE(7, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        STOP
      ENDIF
C
C     REASONS TO CHANGE THE INTEGRAL INCLUSION LEVEL (STAGE)
      IF(HMLT.EQ.'NORL') THEN
        ILEV = 1
      ENDIF
C
      IF(NCNT.EQ.1.OR.READIN) THEN
        ILEV = 3
      ENDIF
C
C     IMPLEMENT THE STARTING SHIFT FACTOR
      IF(ILEV.GE.1.AND.ILEV.LE.3) THEN
        SHLV = SHLEV(ILEV)
      ELSEIF(ILEV.EQ.4) THEN
        SHLV = 0.0D0
      ENDIF
C
C**********************************************************************C
C     NON-HF CALCULATION DETAILS                                       C
C**********************************************************************C
C
C     EXPECTATION VALUE CALCULATIONS: ORTHGNL,MAGDIPL ETC
      IF(TREE.EQ.'EXPVL') THEN
C
C       READ NUMBER OF EXPECTATION VALUES
        READ(5, *) DUMLIN
        READ(5, *) NHMINT
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NHMINT.LT.1.OR.NHMINT.GT.50) THEN
          WRITE(6, *) 'In CARDIN: invalid number of expectation values.'
          WRITE(7, *) 'In CARDIN: invalid number of expectation values.'
          STOP
        ENDIF
C
C       READ IN EACH INTERACTION HAMILTONIAN
        DO N=1,NHMINT
          READ(5, *) HMINT(N)
        ENDDO
C
      ENDIF
C
C     DATA PLOTTING: AMPLITUDES, EM FIELDS AND POTENTIALS
      IF(TREE.EQ.'PLOTS') THEN
C
C       READ NUMBER OF PLOT TYPES
        READ(5, *) DUMLIN
        READ(5, *) NPTYPE
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NPTYPE.LT.1.OR.NPTYPE.GT.10) THEN
          WRITE(6, *) 'In CARDIN: invalid number of plot types.'
          WRITE(7, *) 'In CARDIN: invalid number of plot types.'
          STOP
        ENDIF
C
C       READ IN EACH PLOT TYPE
        DO N=1,NPTYPE
          READ(5, *) PTYPE(N)
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     READ IN ANY EXTERNAL DATA FILES                                  C
C**********************************************************************C
C
C     READ IN A WAVE FUNCTION FILE IF PROMPTED
C      IF(READIN) THEN
        INQUIRE(FILE=WFNFL,EXIST=FILETHERE)
        IF(FILETHERE) THEN
          OPEN(UNIT=8,FILE=WFNFL,STATUS='UNKNOWN')
          REWIND(UNIT=8)
          DO I=1,NDIM
            READ(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
          ENDDO
          CLOSE(UNIT=8)
        ELSE
          READIN = .FALSE.
        ENDIF
C      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE INPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               IIII NN    NN PPPPPPP  UU    UU TTTTTTTT               C
C                II  NNN   NN PP    PP UU    UU    TT                  C
C                II  NNNN  NN PP    PP UU    UU    TT                  C
C                II  NN NN NN PP    PP UU    UU    TT                  C
C                II  NN  NNNN PPPPPPP  UU    UU    TT                  C
C                II  NN   NNN PP       UU    UU    TT                  C
C               IIII NN    NN PP        UUUUUU     TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  INPUT PRINTS MOLECULAR DATA INPUT OPTIONS TO THE TERMINAL.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/TCPU/TCPUS(8)
      COMMON/TMMD/TMMDS(9)
      COMMON/TSCF/TSCFS(37)
C
C     INITIALISE TIME COUNTERS
      DO NT=1,8
        TCPUS(NT) = 0.0D0
      ENDDO
C
      DO NT=1,37
        TSCFS(NT) = 0.0D0
      ENDDO
C
      DO NT=1,9
        TMMDS(NT) = 0.0D0
      ENDDO
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',30),'BERTHA-RSPT'
      WRITE(7, *) REPEAT(' ',30),'BERTHA-RSPT'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',29),'Input summary'
      WRITE(7, *) REPEAT(' ',29),'Input summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     PRINT THE HAMILTONIAN OPTION
      WRITE(6, *) 'Hamiltonian type:',REPEAT(' ',51),HMLT
      WRITE(7, *) 'Hamiltonian type:',REPEAT(' ',51),HMLT
C
C     PRINT INPUT FILE NAME
      LF = LEN(TRIM(MOLCL))
      WRITE(6, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
      WRITE(7, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
C
C     CONFIRM SOLUTION SPACE DIMENSION OR EXIT
      IF(NDIM.LE.MDM) THEN
        WRITE(6, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
        WRITE(7, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
      ELSEIF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        WRITE(7, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        STOP
      ENDIF
C
C     NEW START OR READ IN HFSCF EXPANSION COEFFICIENTS
      IF(READIN) THEN
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
      ELSE
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
      ENDIF
C
C     EQ-COEFFICIENT CALCULATION
      IF(EQFILE) THEN
        WRITE(6, *) 'Eq-coefficients:',REPEAT(' ',44),'Save to file'
        WRITE(7, *) 'Eq-coefficients:',REPEAT(' ',44),'Save to file'
      ELSE
        WRITE(6, *) 'Eq-coefficients:',REPEAT(' ',48),'By batch'
        WRITE(7, *) 'Eq-coefficients:',REPEAT(' ',48),'By batch'
      ENDIF
C
C     OPENMP PARALLEL OPTION
      IF(OPENMP) THEN
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(6, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),NPRCSR
        WRITE(7, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),NPRCSR
      ELSE
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
      ENDIF
C
C     SECTION FOR FILE NAMES
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     PRINT FILE OUTPUT NAMES
      LN = LEN(TRIM(OUTFL))
      WRITE(6, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
      WRITE(7, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
C
C     RECORD TIME AT BEGINNING OF CALCULATION
      CALL CPU_TIME(TCPUS(1))
      CALL TIMENOW(STAMP)
      WRITE(6, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
      WRITE(7, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
C
C     SECTION FOR PHYSICAL PARAMETERS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     PRINT SPEED OF LIGHT
20    FORMAT(1X,A,43X,F14.10)
      WRITE(6,20) 'Speed of light:',CV
      WRITE(7,20) 'Speed of light:',CV
C
C     END OF INPUT SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE MEMORY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RRRRRRR  YY    YY      C
C     MMM     MMM EE       MMM     MMM OO    OO RR    RR YY    YY      C
C     MMMM   MMMM EE       MMMM   MMMM OO    OO RR    RR  YY  YY       C
C     MM MM MM MM EEEEEE   MM MM MM MM OO    OO RR    RR   YYYY        C
C     MM  MMM  MM EE       MM  MMM  MM OO    OO RRRRRRR     YY         C
C     MM   M   MM EE       MM   M   MM OO    OO RR    RR    YY         C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RR    RR    YY         C
C                                                                      C
C -------------------------------------------------------------------- C
C  MEMORY SUMMARISES THE SIZE AND MEMORY REQUIREMENTS OF BIG ARRAYS.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      INTEGER*16 NCMEM,NDMEM,NEMEM,NMMEM,NRMEM,NTMEM
      INTEGER*16 NHMEM
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
C
C     TITLE FOR MEMORY SUMMARY
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',24),'Stack memory allocation'
      WRITE(7, *) REPEAT(' ',24),'Stack memory allocation'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     APPROXIMATE THE MEMORY STORAGE ALLOCATION
      NCMEM = 2*SIZE(COEF)
      NDMEM = 2*SIZE(DENC) + 2*SIZE(DENO) + 2*SIZE(DENT)
      NEMEM = SIZE(E0LLFL) + SIZE(E0SSFL) + SIZE(EILSFL) + SIZE(EISLFL)
      NHMEM = 20*MFL
      NMMEM = 2*SIZE(FOCK) + 2*SIZE(OVLP) + 2*SIZE(HNUC) + 2*SIZE(HKIN)
     &      + 2*SIZE(GDIR) + 2*SIZE(GXCH) + 2*SIZE(BDIR) + 2*SIZE(BXCH)
     &      + 2*SIZE(VANM) + 2*SIZE(VSLF) + 2*SIZE(VUEH) + 2*SIZE(VWKR)
     &      + 2*SIZE(VKSB) + 2*SIZE(QDIR) + 2*SIZE(QXCH) + 2*SIZE(QDIR)
     &      + 2*SIZE(QXCH) + 2*SIZE(WDIR) + 2*SIZE(WXCH) + 2*SIZE(CPLE)
      NTMEM = NCMEM + NDMEM + NEMEM + NHMEM + NMMEM
C
C     SIZES (IN GIGABYTES)
      SCMEM = DFLOAT(NCMEM)*8.0D-9
      SDMEM = DFLOAT(NDMEM)*8.0D-9
      SEMEM = DFLOAT(NEMEM)*8.0D-9
      SHMEM = DFLOAT(NHMEM)*8.0D-9
      SMMEM = DFLOAT(NMMEM)*8.0D-9
      STMEM = DFLOAT(NTMEM)*8.0D-9
C
20    FORMAT(1X,A,4X,A,19X,A,9X,A)
21    FORMAT(1X,A,6X,A,5X,I12,9X,F9.5)
      WRITE(6,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(7,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(7,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(6,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(7,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(6,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(7,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(6,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(7,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(6,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(7,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) '    ','Total                      ',NTMEM,STMEM
      WRITE(7,21) '    ','Total                      ',NTMEM,STMEM
C
C     END OF MEMORY SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE OUTPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  UU    UU TTTTTTTT PPPPPPP  UU    UU TTTTTTTT        C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PPPPPPP  UU    UU    TT           C
C         OO    OO UU    UU    TT    PP       UU    UU    TT           C
C          OOOOOO   UUUUUU     TT    PP        UUUUUU     TT           C
C                                                                      C
C                      EXIT SUMMARY ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  OUTPUT PRINTS A SUMMARY OF TOTAL CALCULATION DATA TO TERMINAL.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
C
      COMMON/TCPU/TBEG,TNUC,TATM,TSCF,TMPT,TPRP,TPLT,TTOT
C
C     OVERALL CALCULATION TIME
      CALL CPU_TIME(TTOT)
      TTOT = TTOT-TBEG
C
C     PRINT TABLE OF DATA
20    FORMAT(1X,A,26X,A)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',28),'CPU time summary'
      WRITE(7, *) REPEAT(' ',28),'CPU time summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) 'Nuclear fitting:              ',HMS(TNUC)
      WRITE(7,20) 'Nuclear fitting:              ',HMS(TNUC)
      WRITE(6,20) 'Property calculation:         ',HMS(TPRP)
      WRITE(7,20) 'Property calculation:         ',HMS(TPRP)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(7,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     RECORD TIME AT BERTHA EXIT
      CALL TIMENOW(STAMP)
C
C     SUCCESSFUL EXIT MESSAGE
30    FORMAT(1X,A,21(' '),A)
      WRITE(6, *)
      WRITE(7, *)
      WRITE(6,30) 'Successful BERTHA-RSPT exit at:',STAMP
      WRITE(7,30) 'Successful BERTHA-RSPT exit at:',STAMP
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      RETURN
      END
C
C
      SUBROUTINE WVFSORT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   WW        WW VV    VV FFFFFFFF SSSSSS   OOOOOO  RRRRRRR TTTTTTTT   C
C   WW        WW VV    VV FF      SS    SS OO    OO RR    RR   TT      C
C   WW   WW   WW VV    VV FF      SS       OO    OO RR    RR   TT      C
C   WW  WWWW  WW VV    VV FFFFFF   SSSSSS  OO    OO RR    RR   TT      C
C   WW WW  WW WW  VV  VV  FF            SS OO    OO RRRRRRR    TT      C
C   WWWW    WWWW   VVVV   FF      SS    SS OO    OO RR    RR   TT      C
C   WW        WW    VV    FF       SSSSSS   OOOOOO  RR    RR   TT      C
C                                                                      C
C -------------------------------------------------------------------- C
C  WVFSORT SORTS THE SAVED WAVEFUNCTION FILE BY ORBITAL ENERGY.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*40 WFNFLSORT
C
      COMPLEX*16 COEF(MDM,MDM),CTMP
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/TCPU/TBEG,TNUC,TATM,TSCF,TMPT,TPRP,TPLT,TTOT
C
C     LOOP OVER LIST OF ENERGY STATES
      DO N=1,NDIM
C
C       ENERGY FOR THIS STATE
        EN = EIGN(N)
C
C       DOES ANY OTHER STATE HAVE A LOWER ENERGY?
        MSWAP = N
        ESWAP = EN
        DO M=N+1,NDIM
          IF(EIGN(M).LT.ESWAP) THEN
            ESWAP = EIGN(M)
            MSWAP = M
          ENDIF
        ENDDO
C
C       SWAP THE ENERGIES AND COEFFICIENT LIST
        EIGN(N)     = ESWAP
        EIGN(MSWAP) = EN
        DO J=1,NDIM
          CTMP = COEF(J,N)
          COEF(J,N    ) = COEF(J,MSWAP)
          COEF(J,MSWAP) = CTMP
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      BLOCK DATA PHYSPRM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  PPPPPPP  HH    HH YY    YY  SSSSSS  PPPPPPP  RRRRRRR  MM       MM   C
C  PP    PP HH    HH YY    YY SS    SS PP    PP RR    RR MMM     MMM   C
C  PP    PP HH    HH YY    YY SS       PP    PP RR    RR MMMM   MMMM   C
C  PP    PP HHHHHHHH  YY  YY   SSSSSS  PP    PP RR    RR MM MM MM MM   C
C  PPPPPPP  HH    HH   YYYY         SS PPPPPPP  RRRRRRR  MM  MMM  MM   C
C  PP       HH    HH    YY    SS    SS PP       RR    RR MM   M   MM   C
C  PP       HH    HH    YY     SSSSSS  PP       RR    RR MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  BLOCK DATA FOR PHYSICAL CONSTANTS, CALCULATED TRANSCENDENTALS AND   C
C  PERIODIC TABLE ELEMENT NAMES.                                       C
C**********************************************************************C
C
      CHARACTER*2 ELMT(120)
C
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     PERIODIC TABLE ELEMENT NAMES
      DATA ELMT/'H' ,'He','Li','Be','B' ,'C' ,'N' ,'O' ,'F' ,'Ne',
     &          'Na','Mg','Al','Si','P' ,'S' ,'Cl','Ar','K' ,'Ca',
     &          'Sc','Ti','V' ,'Cr','Mn','Fe','Co','Ni','Cu','Zn',
     &          'Ga','Ge','As','Se','Br','Kr','Rb','Sr','Y' ,'Zr',
     &          'Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
     &          'Sb','Te','I' ,'Xe','Cs','Ba','La','Ce','Pr','Nd',
     &          'Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
     &          'Lu','Hf','Ta','W' ,'Re','Os','Ir','Pt','Au','Hg',
     &          'Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th',
     &          'Pa','U' ,'Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
     &          'Md','No','Lr','Rf','Db','Sg','Bh','Hs','Mt','Ds',
     &          'Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og','Ue','Un'/
C
C     PI AND ROOTS
      DATA PI,PI12,PI32,PI52/3.1415926535897932D0,1.7724538509055160D0,
     &                       5.5683279968317078D0,1.7493418327624863D1/
C
C     NATURAL LOGARITHM DATA
      DATA PILG,TWLG,THLG/1.1447298858494002D0,0.6931471805599453D0,
     &                                         1.0986122886681097D0/
C
C     NATURAL CONSTANTS
      DATA EULR/0.5772156649015329D0/
C
C     OTHER ROOTS
      DATA TW12/1.4142135623730950D0/
C
C     SPEED OF LIGHT (CODATA 2018 MEASUREMENT - UNCERTAINTY 0.000000021)
      DATA CV/137.035999084D0/
C
C     SPEED OF LIGHT (CODATA 2010 MEASUREMENT)
c     DATA CV/137.0359990D0/
C
C     SPEED OF LIGHT (CODATA 1999 MEASUREMENT)
C     DATA CV/137.03599976D0/
C
C     SPEED OF LIGHT (USED IN HAAKON'S THESIS)
c     DATA CV/137.0359898D0/
C
C     RELATIVE ELECTRON, MUON AND TAUON MASSES (ATOMIC UNITS)
      DATA EMSS,UMSS,TMSS/1.0000D0,206.7683D0,3477.1429D0/
C
C     RATIO OF PROTON MASS TO ELECTRON MASS AND PROTON RADIUS (IN fm)
      DATA PMSS,PRAD/1836.153D0,0.842D0/
C
C     COMPTON WAVELENGTH (1.0D0/CV)
      DATA CMPW/7.297353064D-3/
C
C     FREE ELECTRON G-FACTOR
      DATA GFREE/2.0023193043622D0/
C
C     FERMI COUPLING CONSTANT (IN eV^-2)
C     DATA GFRMI/1.1663787D-23/
C
C     FERMI COUPLING CONSTANT (IN au -- USED IN HAAKON'S THESIS)
C     DATA GFRMI/2.22D-14/
C
C     FERMI COUPLING CONSTANT (IN au)
      DATA GFRMI/2.22255D-14/
C
C     WEINBERG MIXING ANGLE SIN(θ_W)^2
      DATA WEIN/0.23120D0/
C
C     CONVERSION FACTORS: HARTREE TO HZ, HARTREE TO eV, HARTREE TO cm^-1
      DATA CHZ,CEV,CCM/6.579684D+15,2.7211332663D+01,2.1947422215D+05/
C
C     CONVERSION FACTORS: BOHR RADIUS TO FM OR ÅNGSTROM
      DATA CFM,CNG/5.29177211D+4,5.29177211D-1/
C
C     CONVERSION FACTOR: ELECTRON CHARGE ÅNGSTROM TO DEBYE (eÅ -> D)
      DATA CDB/2.54174623D+0/
C
C     http://www.fileformat.info/info/unicode/font/gnu_unifont/grid.htm
C     https://coolsymbol.com/
C     WRITE(6, *) 'αβγδεζηθικλμνξοπρϱςστυφχψω'
C     WRITE(6, *) 'ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ  ΣΤΥΦΧΨΩ'
C     WRITE(6, *) 'ⅈℵℎℏℓℒℋℛℐℜℑℕℙℚℝℤℂ℘' 
C     WRITE(6, *) '×·∕−±∓≠∞—–…≪≫≤≥'
C     WRITE(6, *) '⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘'
C     WRITE(6, *) 'π∞Σ√∛'∜∫∬∭∮∯∰∀∂∃∄∅∆∇∈∉∋∌∎∏∐∑'
C     WRITE(6, *) '∗∝∠∡∢∧∨∩∪∴∵∶∷∼∽∿⊕⊖⊗⊘⊙⊚⊛⊜⊝␢Å'
C     WRITE(6, *) '‗‘’‚‛“”„‟•‣❛❜❝❞¿'
C     WRITE(6, *) '✓✔✗✘☓√☑☐☒☼❄❆♤♠♧♣♡♥♢♦'
C     WRITE(6, *) '¢$€£¥®™☎⌨✁✂✎✏✐§☛'
C     WRITE(6, *) '↕↖↗↘↙↚↛↥↦↧↰↱↲↳↴↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇠⇡⇢⏎▶➔➘➙➚➛➜➞↵⇑⇓'
C     WRITE(6, *) '★☆✡✦✧✩✪✰✢✣✤✥✱✲✳✴✵✶✷✸✹✺✻✼✽✾✿❀❁❂❃❇❈❉❊❋❄❆❅≛'
C     WRITE(6, *) 'äÄéÉ'
C
      END
C
C
      SUBROUTINE GAMGEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG     AA    MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C       GG    GG   AAAA   MMM     MMM GG    GG EE       NNN   NN       C
C       GG        AA  AA  MMMM   MMMM GG       EE       NNNN  NN       C
C       GG       AA    AA MM MM MM MM GG       EEEEEE   NN NN NN       C
C       GG   GGG AAAAAAAA MM  MMM  MM GG   GGG EE       NN  NNNN       C
C       GG    GG AA    AA MM   M   MM GG    GG EE       NN   NNN       C
C        GGGGGG  AA    AA MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMGEN EVALUATES INTEGER/HALF-INTEGER GAMMA VALUES AND THEIR LOGS.  C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ GAMLOG(N) = DLOG(GAMMA(N/2))                                      C
C  ▶ GAMHLF(N) = GAMMA(N/2)                                            C
C**********************************************************************C
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     STARTING VALUES
      GAMLOG(1) = PILG*0.5D0
      GAMLOG(2) = 0.0D0
      GAMHLF(1) = PI12
      GAMHLF(2) = 1.0D0
C
C     SEED VALUES FOR INCREMENT
      F1 = 0.5D0
      F2 = 1.0D0
C
C     FILL TABLE VALUES
      DO N=4,300,2
        GAMLOG(N-1) = GAMLOG(N-3)+DLOG(F1)
        GAMLOG(N  ) = GAMLOG(N-2)+DLOG(F2)
        GAMHLF(N-1) = GAMHLF(N-3)*F1
        GAMHLF(N  ) = GAMHLF(N-2)*F2
        F1 = F1+1.0D0
        F2 = F2+1.0D0
      ENDDO
C
      RETURN
      END
C
C
       SUBROUTINE FACTRL
       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         FFFFFFFF   AA     CCCCCC TTTTTTTT RRRRRRR  LL                C
C         FF        AAAA   CC    CC   TT    RR    RR LL                C
C         FF       AA  AA  CC         TT    RR    RR LL                C
C         FFFFFF  AA    AA CC         TT    RR    RR LL                C
C         FF      AAAAAAAA CC         TT    RRRRRRR  LL                C
C         FF      AA    AA CC    CC   TT    RR    RR LL                C
C         FF      AA    AA  CCCCCC    TT    RR    RR LLLLLLLL          C
C                                                                      C
C -------------------------------------------------------------------- C
C  FACTRL GENERATES A SET OF N! AND N!! AS REAL NUMBERS.               C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ RFACT - REGULAR FACTORIALS, RFACT(N) = N!                         C
C  ▶ SFACT - SEMI-FACTORIALS,    SFACT(N) = N!!                        C
C**********************************************************************C
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
      RFACT(0) = 1.0D0
      RFACT(1) = 1.0D0
      SFACT(0) = 1.0D0
      SFACT(1) = 1.0D0
      DO I=2,80
        RNUMBER  = DFLOAT(I)
        RFACT(I) = RNUMBER*RFACT(I-1)
        SFACT(I) = RNUMBER*SFACT(I-2)
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] NUCCOUL: NUCLEAR CHARGE DISTRIBUTION DETAILS.                  C
C   [C] POLYLOG: THE POLYLOGARITHM OF NEGATIVE EXPONENTIAL ARGUMENT.   C
C   [D] NUCGEOM: BOND DISTANCES AND NUCLEAR REPULSION ENERGY.          C
C   [E] FOCKIND: CALCULATE ADDRESSES OF FOCK MATRIX FOR BASIS QN'S.    C
C   [F] CARTIND: GENERATES INDICES FOR EQ-COEFFS AND R-INTEGRALS.      C
C   [G] AUFBAU: DETERMINES GROUND STATE ATOMIC ELECTRON CONFIG.        C
C   [I] SPECTRM: MOLECULAR SPECTRUM W/ EIGENVALUES AND TERM SYMBOLS.   C
C   [J] LLAB: GIVES THE CHARACTER CORRESPONDING TO LQN VALUE LQN.      C
C   [K] ROTATE: PERFORM TWO EULER ROTATIONS ON ALL ATOMIC CENTRES.     C
C   [L] MMPROD: PRODUCT OF TWO SQUARE ARRAYS OF DOUBLES.               C
C   [M] MVPROD: PRODUCT OF A SQUARE MATRIX AND VECTOR OF DOUBLES.      C
C   [N] HMS: RETURNS A QUOTED TIME IN SECONDS AS 'MIN-SEC'.            C
C   [O] MS: RETURNS A QUOTED TIME IN SECONDS AS 'HR-MIN-SEC'.          C
C   [P] TIMENOW: RETURNS A DATE STRING FOR THE CPU TIME.               C
C**********************************************************************C
C
C
      SUBROUTINE NUCCOUL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   CCCCCC   OOOOOO  UU    UU LL          C
C    NNN   NN UU    UU CC    CC CC    CC OO    OO UU    UU LL          C
C    NNNN  NN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN NN NN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN  NNNN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN   NNN UU    UU CC    CC CC    CC OO    OO UU    UU LL          C
C    NN    NN  UUUUUU   CCCCCC   CCCCCC   OOOOOO   UUUUUU  LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCCOUL CONTROLS THE CHARGE POTENTIALS THAT APPLY TO EACH NUCLEAR   C
C  CENTRE, GIVEN A RANGE OF NUCLEAR CHARGE MODELS AND QED OPTIONS.     C
C -------------------------------------------------------------------- C
C  THIS VERSION OF THE ROUTINE READS IN RESULTS FROM BERTHA-NUCLEAR.   C
C -------------------------------------------------------------------- C
C  ▶ NCOUL = 0 (POINT), NCOUL = 1 (GAUSS), NCOUL > 1 (FERMI).          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL FILETHERE
      CHARACTER*2 ELMT(120)
      CHARACTER*5 NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL,NUCFL
C
      DIMENSION RSQ(MCT),NCOUL(MCT)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
C
C     GAUSSIAN FITTING FOR ALL NUCLEI
      DO IZ=1,NCNT
C
C       NUCLEAR RADIUS
        IF(INT(ZNUC(IZ)).EQ.1) THEN
C         PROTON HAS A VERY SMALL RADIUS (IN FM)
          RFM = PRAD
        ELSEIF(ZNUC(IZ).GT.1.0D0.AND.ZNUC(IZ).LT.90.0D0) THEN
C         EMPIRICAL FORMULA FOR NUCLEAR RMS RADIUS IF Z < 90 (IN FM)
          RFM = 0.836D0*(ANUC(IZ)**(1.0D0/3.0D0)) + 0.57D0
C         RFM = 1.20D0*(ANUC(IZ)**(1.0D0/3.0D0))
        ELSE
C         EMPIRICAL FORMULA FOR NUCLEAR RMS RADIUS IF Z > 90 (IN FM)
          RFM = 0.770D0*(ANUC(IZ)**(1.0D0/3.0D0)) + 0.98D0
        ENDIF
C
C       CONVERT RESULT TO ATOMIC UNITS
        RNUC(IZ) = RFM/CFM
C
C       GAUSSIAN MODEL
        NNUC(IZ)   = 0
        FNUC(IZ,0) = 1.0D0
        XNUC(IZ,0) = 1.5D0/(RNUC(IZ)*RNUC(IZ))
C
C       FERMI MODEL
        TFMI(IZ) = 2.30D0/CFM
        AFMI(IZ) = 0.25D0*TFMI(IZ)/THLG
C
      ENDDO
C
C     NUCLEUS FILE NAME
      NUCFL = 'output/'//TRIM(MOLCL)//'_nuclear.dat'
C
C     TRY TO READ THE FILE IN
      INQUIRE(FILE=TRIM(NUCFL),EXIST=FILETHERE)
C
C     READ IN AN EXISTING FILE
      IF(FILETHERE) THEN
        OPEN(UNIT=8,FILE=TRIM(NUCFL),STATUS='UNKNOWN')
C
C         LOOP OVER NUCLEAR CENTERS
          DO IZ=1,NCNT
C
C           NUMBER OF FITTING FUNCTIONS AND RMS RADIUS
            READ(8, *) NNUC(IZ),RNUC(IZ)
C
C           AMPLITUDES AND PARAMETERS FOR EACH NUCLEAR FITTING FUNCTION
            DO IFT=0,NNUC(IZ)
              READ(8, *) FNUC(IZ,IFT),XNUC(IZ,IFT)
            ENDDO
C
C          LOCK OUT ACCESS TO FUNCTIONS FOR GAUSSIAN NUCLEUS
           IF(NMDL(IZ).EQ.'GAUSS') THEN
             NNUC(IZ) = 0
           ENDIF
C
C         FERMI MODEL PARAMETERS
          TFMI(IZ) = 2.30D0/CFM
          AFMI(IZ) = 0.25D0*TFMI(IZ)/THLG
C
          ENDDO
C
C       CLOSE DATA FILE
        CLOSE(UNIT=8)
C
C     CANNOT OPEN A FILE SO ASSUME GAUSSIAN
      ELSE
C
C       ALERT THE USER THAT THE NUCLEAR FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCCOUL: could not find nuclear data.'
        WRITE(7, *) 'In NUCCOUL: could not find nuclear data.'
C
C       ALERT THE USER THAT NUCLEI ARE GAUSSIAN NOW
21      FORMAT(26X,A)
22      FORMAT(1X,A,2X,'|',3X,A,4X,A,5X,A,1X,'|',1X,A,3X,A,3X,A)
23      FORMAT(1X,I2,' (',A,')',1X,'|',5X,I3,4X,F8.4,5X,F6.4,1X,'|',
     &                                             4X,I2,7X,A,2X,F10.8)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,21) 'Nuclear charge summary'
        WRITE(7,21) 'Nuclear charge summary'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,22) 'Centre','Z (e)','A (m_p+)','R (fm)',
     &              'N_fit','Potential','R-squared'
        WRITE(7,22) 'Centre','Z (e)','A (m_p+)','R (fm)',
     &              'N_fit','Potential','R-squared'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        DO IZ=1,NCNT
          IZNC = INT(ZNUC(IZ))
          WRITE(6,23) IZ,ELMT(IZNC),IZNC,ANUC(IZ),RNUC(IZ)*CFM,NNUC(IZ),
     &                                                 NMDL(IZ),RSQ(IZ)
          WRITE(7,23) IZ,ELMT(IZNC),IZNC,ANUC(IZ),RNUC(IZ)*CFM,NNUC(IZ),
     &                                                 NMDL(IZ),RSQ(IZ)
        ENDDO
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE NUCVCPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC  VV    VV  CCCCCC  PPPPPPP  LL          C
C    NNN   NN UU    UU CC    CC VV    VV CC    CC PP    PP LL          C
C    NNNN  NN UU    UU CC       VV    VV CC       PP    PP LL          C
C    NN NN NN UU    UU CC       VV    VV CC       PP    PP LL          C
C    NN  NNNN UU    UU CC        VV  VV  CC       PPPPPPP  LL          C
C    NN   NNN UU    UU CC    CC   VVVV   CC    CC PP       LL          C
C    NN    NN  UUUUUU   CCCCCC     VV     CCCCCC  PP       LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCVCPL CONTROLS THE VACUUM POLARISATION POTENTIALS FOR ALL ATOMIC  C
C  CENTRES, GIVEN A RANGE OF NUCLEAR CHARGE MODELS AND QED OPTIONS.    C
C -------------------------------------------------------------------- C
C  THIS VERSION OF THE ROUTINE READS IN RESULTS FROM BERTHA-NUCLEAR.   C
C -------------------------------------------------------------------- C
C  ▶ NFT > 26 (FOR WHICHEVER NUCLEAR CHARGE MODEL.)                    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL FILETHERE
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*60 VACFL
C
      COMMON/BUEE/RUEE(MCT,3),FUEE(MCT,MFT),XUEE(MCT,MFT),NUEE(MCT)
      COMMON/BUEU/RUEU(MCT,3),FUEU(MCT,MFT),XUEU(MCT,MFT),NUEU(MCT)
      COMMON/BUEP/RUEP(MCT,3),FUEP(MCT,MFT),XUEP(MCT,MFT),NUEP(MCT)
      COMMON/BWKR/RWKR(MCT,3),FWKR(MCT,MFT),XWKR(MCT,MFT),NWKR(MCT)
      COMMON/BKSB/RKSB(MCT,3),FKSB(MCT,MFT),XKSB(MCT,MFT),NKSB(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/QUEE/RE(0:NRAD),VE(MCT,0:NRAD),R0E,RME,RIE,NLE,NEE
      COMMON/QUEU/RU(0:NRAD),VU(MCT,0:NRAD),R0U,RMU,RIU,NLU,NEU
      COMMON/QUEP/RP(0:NRAD),VP(MCT,0:NRAD),R0P,RMP,RIP,NLP,NEP
      COMMON/QWKR/RW(0:NRAD),VW(MCT,0:NRAD),R0W,RMW,RIW,NLZ,NEW
      COMMON/QKSB/RK(0:NRAD),VK(MCT,0:NRAD),R0K,RMK,RIK,NLK,NEK
C
C     EARLY EXIT IF VACPOL MEAN FIELDS AREN'T NEEDED
      IF(HMLT.NE.'DHFQ'.AND.HMLT.NE.'DHFP') RETURN
C
C**********************************************************************C
C     ORDER (α/π) (Zα) : UEHLING POTENTIAL (e+e-)                      C
C**********************************************************************C
C
C     UEHLING FITTING SET
      VACFL = 'output/'//TRIM(MOLCL)//'_vpuee.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          DO IZ=1,NCNT
            READ(8, *) NUEE(IZ)
            DO IFT=1,NUEE(IZ)
              READ(8, *) FUEE(IZ,IFT),XUEE(IZ,IFT)
            ENDDO
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE UEHLING FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Uehling (e+e-) data.'
        WRITE(7, *) 'In NUCVCPL: could not find Uehling (e+e-) data.'
        DO IZ=1,NCNT
          NUEE(IZ) = 0
        ENDDO
C
      ENDIF
C
C     UEHLING RADIAL GRID DATA
      VACFL = 'output/'//TRIM(MOLCL)//'_vpuee_grid.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          READ(8, *) R0E,REU,RIE,NLE,NEE
          DO N=0,NRAD
            READ(8, *) RE(N),(VE(IZ,N),IZ=1,NCNT)
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE UEH GRID FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find UEH (e+e-) grid data.'
        WRITE(7, *) 'In NUCVCPL: could not find UEH (e+e-) grid data.'
        DO N=0,NRAD
          RE(N) = 0.0D0
          DO IZ=1,NCNT
            VE(IZ,N) = 0.0D0
          ENDDO
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     ORDER (α/π) (Zα) : UEHLING POTENTIAL (μ+μ-)                      C
C**********************************************************************C
C
C     UEHLING FITTING SET
      VACFL = 'output/'//TRIM(MOLCL)//'_vpueu.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          DO IZ=1,NCNT
            READ(8, *) NUEU(IZ)
            DO IFT=1,NUEU(IZ)
              READ(8, *) FUEU(IZ,IFT),XUEU(IZ,IFT)
            ENDDO
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE UEHLING FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Uehling (μ+μ-) data.'
        WRITE(7, *) 'In NUCVCPL: could not find Uehling (μ+μ-) data.'
        DO IZ=1,NCNT
          NUEU(IZ) = 0
        ENDDO
C
      ENDIF
C
C     UEHLING RADIAL GRID DATA
      VACFL = 'output/'//TRIM(MOLCL)//'_vpueu_grid.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          READ(8, *) R0U,RMU,RIU,NLU,NEU
          DO N=0,NRAD
            READ(8, *) RU(N),(VU(IZ,N),IZ=1,NCNT)
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE UEH GRID FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find UEH (μ+μ-) grid data.'
        WRITE(7, *) 'In NUCVCPL: could not find UEH (μ+μ-) grid data.'
        DO N=0,NRAD
          RU(N) = 0.0D0
          DO IZ=1,NCNT
            VP(IZ,N) = 0.0D0
          ENDDO
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     ORDER (α/π) (Zα) : UEHLING POTENTIAL (π+π-)                      C
C**********************************************************************C
C
C     UEHLING FITTING SET
      VACFL = 'output/'//TRIM(MOLCL)//'_vpuep.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          DO IZ=1,NCNT
            READ(8, *) NUEP(IZ)
            DO IFT=1,NUEP(IZ)
              READ(8, *) FUEP(IZ,IFT),XUEP(IZ,IFT)
            ENDDO
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE UEHLING FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Uehling (π+π-) data.'
        WRITE(7, *) 'In NUCVCPL: could not find Uehling (π+π-) data.'
        DO IZ=1,NCNT
          NUEP(IZ) = 0
        ENDDO
C
      ENDIF
C
C     UEHLING RADIAL GRID DATA
      VACFL = 'output/'//TRIM(MOLCL)//'_vpuep_grid.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          READ(8, *) R0P,RMP,RIP,NLP,NEP
          DO N=0,NRAD
            READ(8, *) RP(N),(VU(IZ,N),IZ=1,NCNT)
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE UEH GRID FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find UEH (π+π-) grid data.'
        WRITE(7, *) 'In NUCVCPL: could not find UEH (π+π-) grid data.'
        DO N=0,NRAD
          RP(N) = 0.0D0
          DO IZ=1,NCNT
            VU(IZ,N) = 0.0D0
          ENDDO
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     ORDER (α/π) (Zα)³: WICHMANN-KROLL POTENTIAL                      C
C**********************************************************************C
C
C     WICHMANN-KROLL FITTING SET
      VACFL = 'output/'//TRIM(MOLCL)//'_vpwkr.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          DO IZ=1,NCNT
            READ(8, *) NWKR(IZ)
            DO IFT=1,NWKR(IZ)
              READ(8, *) FWKR(IZ,IFT),XWKR(IZ,IFT)
            ENDDO
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE WICHMANN-KROLL FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Wichmann-Kroll data.'
        WRITE(7, *) 'In NUCVCPL: could not find Wichmann-Kroll data.'
        DO IZ=1,NCNT
          NWKR(IZ) = 0
        ENDDO
C
      ENDIF
C
C     WICHMANN-KROLL RADIAL GRID DATA
      VACFL = 'output/'//TRIM(MOLCL)//'_vpwkr_grid.dat'
C
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          READ(8, *) R0W,RMW,RIW,NLZ,NEW
          DO N=0,NRAD
            READ(8, *) RW(N),(VW(IZ,N),IZ=1,NCNT)
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE WKR GRID FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find WKR grid data.'
        WRITE(7, *) 'In NUCVCPL: could not find WKR grid data.'
        DO N=0,NRAD
          RW(N) = 0.0D0
          DO IZ=1,NCNT
            VW(IZ,N) = 0.0D0
          ENDDO
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     ORDER (α/π)²(Zα) : KÄLLÉN-SABRY POTENTIAL                        C
C**********************************************************************C
C
C     KÄLLÉN-SABRY FITTING SET
      VACFL = 'output/'//TRIM(MOLCL)//'_vpksb.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          DO IZ=1,NCNT
            READ(8, *) NKSB(IZ)
            DO IFT=1,NKSB(IZ)
              READ(8, *) FKSB(IZ,IFT),XKSB(IZ,IFT)
            ENDDO
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE KÄLLÉN-SABRY FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find Källén-Sabry data.'
        WRITE(7, *) 'In NUCVCPL: could not find Källén-Sabry data.'
        DO IZ=1,NCNT
          NKSB(IZ) = 0
        ENDDO
C
      ENDIF
C
C     KÄLLÉN-SABRY RADIAL GRID DATA
      VACFL = 'output/'//TRIM(MOLCL)//'_vpksb_grid.dat'
      INQUIRE(FILE=TRIM(VACFL),EXIST=FILETHERE)
C
      IF(FILETHERE) THEN
C
C       READ FITTING DATA IN FROM AN EXISTING FILE
        OPEN(UNIT=8,FILE=TRIM(VACFL),STATUS='UNKNOWN')
          READ(8, *) R0K,RMK,RIK,NLK,NEK
          DO N=0,NRAD
            READ(8, *) RK(N),(VK(IZ,N),IZ=1,NCNT)
          ENDDO
        CLOSE(UNIT=8)
C
      ELSE
C
C       ALERT THE USER THAT THE KSB GRID FILE COULD NOT BE FOUND
        WRITE(6, *) 'In NUCVCPL: could not find KSB grid data.'
        WRITE(7, *) 'In NUCVCPL: could not find KSB grid data.'
        DO N=0,NRAD
          RK(N) = 0.0D0
          DO IZ=1,NCNT
            VK(IZ,N) = 0.0D0
          ENDDO
        ENDDO
C
      ENDIF
C
C     NUMBER OF DATA POINTS IN UNIFORMLY-SPACED AND EXPONENTIAL REGION
      NLIN = NRAD/10 - MOD(NRAD/10,10)
      NEXP = NRAD-NLIN
C
C     GENERATE RADIAL GRID (LINEAR FROM FEMTOMETERS, EXPONENTIAL IN AU)
      RORI =  0.0D0/CFM
      RMID = 10.0D0/CFM
      RMAX =  0.5D0
C
      HL = (RMID-RORI)/DFLOAT(NLIN)
      HE = DLOG(RMAX/RMID)/DFLOAT(NEXP)
C
      RETURN
      END
C
C
      FUNCTION RHONUC(MODEL,IZ,R)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        RRRRRRR  HH    HH  OOOOOO  NN    NN UU    UU  CCCCCC          C
C        RR    RR HH    HH OO    OO NNN   NN UU    UU CC    CC         C
C        RR    RR HH    HH OO    OO NNNN  NN UU    UU CC               C
C        RR    RR HHHHHHHH OO    OO NN NN NN UU    UU CC               C
C        RRRRRRR  HH    HH OO    OO NN  NNNN UU    UU CC               C
C        RR    RR HH    HH OO    OO NN   NNN UU    UU CC    CC         C
C        RR    RR HH    HH  OOOOOO  NN    NN  UUUUUU   CCCCCC          C
C                                                                      C
C -------------------------------------------------------------------- C
C  RHONUC EVALUATES THE VALUE OF THE NORMALISED NUCLEAR CHARGE DENSITY C
C  FOR NUCLEUS IZ AT RADIUS R, BASED ON A NUCLEAR CHARGE MODEL.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL,MODEL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     RADIUS MUST BE NON-NEGATIVE
      IF(R.LT.0.0D0) THEN
        WRITE(6, *) 'In RHONUC: radius R must be non-negative. R = ',R
        WRITE(7, *) 'In RHONUC: radius R must be non-negative. R = ',R
        STOP
      ENDIF
C
C     REASONS TO USE GAUSSIAN NUCLEAR CHARGE MODEL
      EPS = DSQRT(1.4D0)*PI*0.25D0*TFMI(IZ)/THLG
      IF(EPS.GT.RNUC(IZ)) THEN
C
C       NORMALISATION FACTOR
        XI = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        YN = XI*DSQRT(XI)/PI32
        RHONUC = YN*DEXP(-R*R*XI)
        RETURN
C
      ENDIF
C
C     GAUSSIAN NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'GAUSS') THEN
C
C       NORMALISATION FACTOR
        ZT = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        YN = ZT*DSQRT(ZT)/(PI*PI12)
        RHONUC = YN*DEXP(-R*R*ZT)
C      
      ENDIF
C
C     FERMI NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'FERMI') THEN
C
        A  = AFMI(IZ)
        C = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &    - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
        C = DSQRT(C)
        U  = A/C
        C3 = C*C*C
C
C       NORMALISATION CONSTANT
        Y1 = 1.0D0
        Y2 = PI*PI*U*U
        Y3 =-6.0D0*U*U*U*POLYLOG(3,-1.0D0/U)
        YN = 1.0D0/(Y1+Y2+Y3)
        YN = 3.0D0*YN/(4.0D0*PI*C3)
C
C       EXACT FERMI DENSITY FORMULA
        PR = 1.0D0 + DEXP((R-C)/A)
        RHONUC = YN/PR
C
      ENDIF
C
C     HOMOGENEOUS BALL MODEL
      IF(MODEL.EQ.'UNIFM') THEN
C
        B = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
        IF(R.LE.B) THEN
          RHONUC = 0.75D0/(PI*B*B*B)
        ELSE
          RHONUC = 0.00D0
        ENDIF
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ERNUC(MODEL,IZ,R)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             EEEEEEEE RRRRRRR  NN    NN UU    UU  CCCCCC              C
C             EE       RR    RR NNN   NN UU    UU CC    CC             C
C             EE       RR    RR NNNN  NN UU    UU CC                   C
C             EEEEEE   RR    RR NN NN NN UU    UU CC                   C
C             EE       RRRRRRR  NN  NNNN UU    UU CC                   C
C             EE       RR    RR NN   NNN UU    UU CC    CC             C
C             EEEEEEEE RR    RR NN    NN  UUUUUU   CCCCCC              C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERNUC EVALUATES THE VALUE OF THE NORMALISED NUCLEAR ELECTRIC FIELD  C
C  (RADIAL COMPONENT) AT RADIUS R, BASED ON A NUCLEAR CHARGE MODEL.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL,MODEL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     RADIUS MUST BE NON-NEGATIVE
      IF(R.LT.0.0D0) THEN
        WRITE(6, *) 'In ERNUC: radius R must be non-negative. R = ',R
        WRITE(7, *) 'In ERNUC: radius R must be non-negative. R = ',R
        STOP
      ENDIF
C
C     REASONS TO USE GAUSSIAN NUCLEAR CHARGE MODEL
      EPS = DSQRT(1.4D0)*PI*0.25D0*TFMI(IZ)/THLG
      IF(EPS.GT.RNUC(IZ)) THEN
C
        XI = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        IF(R.LT.0.2D0*RNUC(IZ)) THEN
          X1 = DSQRT(XI)*R
          X3 = XI*R*R*X1
          X5 = XI*R*R*X3
          X7 = XI*R*R*X5
          X9 = XI*R*R*X7
          ERNUC = 4.0D0*X1/3.0D0 - 4.0D0*X3/5.0D0 + 2.0D0*X5/7.0D0
     &          - 2.0D0*X7/27.0D0 + X9/66.0D0
          ERNUC = XI*ERNUC/PI12
        ELSE
          X1 = DSQRT(XI)*R
          ERNUC =-2.0D0*X1*DEXP(-X1*X1)/PI12 + DERF(X1)
          ERNUC = ERNUC/(R*R)
        ENDIF
        RETURN
C
      ENDIF
C
C     GAUSSIAN NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'GAUSS') THEN
C
        XI = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        IF(R.LT.0.2D0*RNUC(IZ)) THEN
          X1 = DSQRT(XI)*R
          X3 = XI*R*R*X1
          X5 = XI*R*R*X3
          X7 = XI*R*R*X5
          X9 = XI*R*R*X7
          ERNUC = 4.0D0*X1/3.0D0 - 4.0D0*X3/5.0D0 + 2.0D0*X5/7.0D0
     &          - 2.0D0*X7/27.0D0 + X9/66.0D0
          ERNUC = XI*ERNUC/PI12
        ELSE
          X1 = DSQRT(XI)*R
          ERNUC =-2.0D0*X1*DEXP(-X1*X1)/PI12 + DERF(X1)
          ERNUC = ERNUC/(R*R)
        ENDIF
C      
      ENDIF
C
C     FERMI NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'FERMI') THEN
C
        A = AFMI(IZ)
        C = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &    - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
        C = DSQRT(C)
        U = A/C
C
C       NORMALISATION CONSTANT
        Y1 = 1.0D0
        Y2 = PI*PI*U*U
        Y3 =-6.0D0*U*U*U*POLYLOG(3,-1.0D0/U)
        YN = 1.0D0/(Y1+Y2+Y3)
C
C       ELECTRIC FIELD BY EXPANSION
        IF(R.LT.0.2D0*C) THEN
          ERNUC =-YN*R/(C*C*C)
        ELSEIF(R.LT.C) THEN
          E1 =-R*R*R/(C*C*C)
          E3 = 6.0D0*U*U*U*POLYLOG(3,-C/A)
          E4 =-6.0D0*U*U*U*POLYLOG(3,(R-C)/A)
          E5 =-3.0D0*U*R*R*POLYLOG(1,(R-C)/A)/(C*C)
          E6 = 6.0D0*U*U*R*POLYLOG(2,(R-C)/A)/C
          ERNUC = YN*(E1+   E3+E4+E5+E6)/(R*R)
        ELSE
          E1 =-1.0D0
          E2 =-(PI*U)**2
          E3 = 6.0D0*U*U*U*POLYLOG(3,-C/A)
          E4 =-6.0D0*U*U*U*POLYLOG(3,(C-R)/A)
          E5 =-3.0D0*U*R*R*POLYLOG(1,(C-R)/A)/(C*C)
          E6 =-6.0D0*U*U*R*POLYLOG(2,(C-R)/A)/C
          ERNUC = YN*(E1+E2+E3+E4+E5+E6)/(R*R)
        ENDIF
C
      ENDIF
C
C     HOMOGENEOUS BALL MODEL
      IF(MODEL.EQ.'UNIFM') THEN
C
        B = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
        IF(R.LE.B) THEN
          RN3   = RNUC(IZ)*RNUC(IZ)*RNUC(IZ)
          ERNUC = R/(B*B*B)
        ELSE
          ERNUC = 1.0D0/(R*R)
        ENDIF
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ERNUCDNS(MODEL,IZ,R)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    EEEEEEEE RRRRRRR  NN    NN  CCCCCC  DDDDDDD  NN    NN  SSSSSS     C
C    EE       RR    RR NNN   NN CC    CC DD    DD NNN   NN SS    SS    C
C    EE       RR    RR NNNN  NN CC       DD    DD NNNN  NN SS          C
C    EEEEEE   RR    RR NN NN NN CC       DD    DD NN NN NN  SSSSSS     C
C    EE       RRRRRRR  NN  NNNN CC       DD    DD NN  NNNN       SS    C
C    EE       RR    RR NN   NNN CC    CC DD    DD NN   NNN SS    SS    C
C    EEEEEEEE RR    RR NN    NN  CCCCCC  DDDDDDD  NN    NN  SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERNUCDNS EVALUATES THE VALUE OF THE NORMALISED NUCLEAR E_R FIELD    C
C  AT RADIUS R, MULTIPLIED BY R**2, BASED ON A NUCLEAR CHARGE MODEL.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL,MODEL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     RADIUS MUST BE NON-NEGATIVE
      IF(R.LT.0.0D0) THEN
        WRITE(6, *) 'In ERNUCDNS: radius R must be non-negative. R = ',R
        WRITE(7, *) 'In ERNUCDNS: radius R must be non-negative. R = ',R
        STOP
      ENDIF
C
C     POINT-LINE NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'POINT') THEN
        ERNUCDNS = 1.0D0
      ENDIF
C
C     GAUSSIAN NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'GAUSS') THEN
        XI = 3.0D0/(2.0D0*RNUC(IZ)*RNUC(IZ))
        X1 = DSQRT(XI)*R
        ERNUCDNS =-2.0D0*X1*DEXP(-X1*X1)/PI12 + DERF(X1)
      ENDIF
C
C     FERMI NUCLEAR CHARGE MODEL
      IF(MODEL.EQ.'FERMI') THEN
C
        A = AFMI(IZ)
        C = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &    - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
        C = DSQRT(C)
        U = A/C
C
C       NORMALISATION CONSTANT
        Y1 = 1.0D0
        Y2 = PI*PI*U*U
        Y3 =-6.0D0*U*U*U*POLYLOG(3,-1.0D0/U)
        YN = 1.0D0/(Y1+Y2+Y3)
C
C       ELECTRIC FIELD BY EXPANSION
        IF(R.LT.C) THEN
          E1 =-R*R*R/(C*C*C)
          E3 = 6.0D0*U*U*U*POLYLOG(3,-C/A)
          E4 =-6.0D0*U*U*U*POLYLOG(3,(R-C)/A)
          E5 =-3.0D0*U*R*R*POLYLOG(1,(R-C)/A)/(C*C)
          E6 = 6.0D0*U*U*R*POLYLOG(2,(R-C)/A)/C
          ERNUCDNS = YN*(E1+   E3+E4+E5+E6)
        ELSE
          E1 =-1.0D0
          E2 =-(PI*U)**2
          E3 = 6.0D0*U*U*U*POLYLOG(3,-C/A)
          E4 =-6.0D0*U*U*U*POLYLOG(3,(C-R)/A)
          E5 =-3.0D0*U*R*R*POLYLOG(1,(C-R)/A)/(C*C)
          E6 =-6.0D0*U*U*R*POLYLOG(2,(C-R)/A)/C
          ERNUCDNS = YN*(E1+E2+E3+E4+E5+E6)
        ENDIF
C
      ENDIF
C
C     HOMOGENEOUS BALL MODEL
      IF(MODEL.EQ.'UNIFM') THEN
        B = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
        IF(R.LE.B) THEN
          RN3   = RNUC(IZ)*RNUC(IZ)*RNUC(IZ)
          ERNUCDNS = R*R*R/(B*B*B)
        ELSE
          ERNUCDNS = 1.0D0
        ENDIF
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION POLYLOG(K,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP   OOOOOO  LL      YY    YY LL       OOOOOO   GGGGGG      C
C     PP    PP OO    OO LL      YY    YY LL      OO    OO GG    GG     C
C     PP    PP OO    OO LL      YY    YY LL      OO    OO GG           C
C     PP    PP OO    OO LL       YY  YY  LL      OO    OO GG           C
C     PPPPPPP  OO    OO LL        YYYY   LL      OO    OO GG   GGG     C
C     PP       OO    OO LL         YY    LL      OO    OO GG    GG     C
C     PP        OOOOOO  LLLLLLLL   YY    LLLLLLLL OOOOOO   GGGGGG      C
C                                                                      C
C -------------------------------------------------------------------- C
C  POLYLOG EVALUATES THE POLYLOGARITHM FUNCTION OF ORDER K AND         C
C  ARGUMENT -DEXP(X) USING A TRUNCATED SERIES EXPANSION OF LENGTH NTR. C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
C     TRUNCATION OPTION SHOULD BE GREATER THAN 1
      IF(NTR.LE.1) THEN
        WRITE(6, *) 'In POLYLOG: series trunction too low. NTR = ',NTR
        WRITE(7, *) 'In POLYLOG: series trunction too low. NTR = ',NTR
        STOP
      ENDIF
C
C     ARGUMENT X MUST BE NEGATIVE
      IF(X.GT.0.0D0) THEN
        WRITE(6, *) 'In POLYLOG: argument X must be negative. X = ',X
        WRITE(7, *) 'In POLYLOG: argument X must be negative. X = ',X
        STOP
      ENDIF
C
C     INITIAL VALUES
      PHS = 1.0D0
      VAL = 0.0D0
      DO N=1,NTR
        PHS =-PHS
        RNK = DFLOAT(N)**K
        VAL = VAL + PHS*DEXP(X*N)/RNK
      ENDDO
C
C     VALUE OF POLYLOG
      POLYLOG = VAL
C
      RETURN
      END
C
C
      FUNCTION CLEBSCH(LQN,MQN,NSGN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     CCCCCC  LL       EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C    CC       LL       EE       BB    BB SS       CC       HH    HH    C
C    CC       LL       EEEEEE   BBBBBBB   SSSSSS  CC       HHHHHHHH    C
C    CC       LL       EE       BB    BB       SS CC       HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C     CCCCCC  LLLLLLLL EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLEBSCH DETERMINES A CLEBSCH-GORDAN COEFFICIENT FOR LQN, MQN AND    C
C  NSGN -- THESE ARE THE COEFFICIENTS IN FRONT OF THE SPIN-ANGULAR     C
C  FUNCTIONS FOR A GIVEN COMPONENT TYPE.                               C
C**********************************************************************C
C
      T1 = 2.0D0*LQN + 1.0D0 + MQN*NSGN
      T2 = 4.0D0*LQN + 2.0D0
C
      CLEBSCH = DSQRT(T1/T2)
C
      RETURN
      END
C
C
      SUBROUTINE NUCGEOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  NN    NN UU    UU  CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C  NNN   NN UU    UU CC    CC GG    GG EE       OO    OO MMM     MMM   C
C  NNNN  NN UU    UU CC       GG       EE       OO    OO MMMM   MMMM   C
C  NN NN NN UU    UU CC       GG       EEEEEE   OO    OO MM MM MM MM   C
C  NN  NNNN UU    UU CC       GG   GGG EE       OO    OO MM  MMM  MM   C
C  NN   NNN UU    UU CC    CC GG    GG EE       OO    OO MM   M   MM   C
C  NN    NN  UUUUUU   CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCGEOM TRANSLATES AND ROTATES A MOLECULE IN A WAY THAT IS BEST     C
C  SUITED TO EFFICIENT COMPUTATION, IDENTIFIES MOLECULAR SHAPE AND     C
C  BOND DISTANCES, AND CALCULATES NUCLEAR REPULSION ENERGY.            C
C -------------------------------------------------------------------- C
C  ▶ THE TSYM PACKAGE (WERNER 1996) CAN BE DIRECTLY IMPLEMENTED HERE - C
C    IT PERFORMS POINT GROUP SYMMETRY ANALYSIS. THIS ALLOWS A BLOCK    C
C    STRUCTURE ACCORDING TO IRREPS FOR THE HAMILTONIAN MATRIX (FASTER).C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL TRANSFORM
C
      CHARACTER*2 ELMT(120),ELA,ELB,ELC
      CHARACTER*4 UCHR
      CHARACTER*5 NMDL
      CHARACTER*8 SPCES
C
      DIMENSION XYZ(3,MCT),DIST(MCT),CENT(3),IZAD(MCT,3)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EANM,ESLF,EUEH,
     &            EWKR,EKSB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
C
C     CHOICE OF UNITS -- 1 FOR AU, 2 FOR ÅNGSTROM
      IUNIT = 1
C
      IF(IUNIT.EQ.1) THEN
        UCHR = '(a0)'
        CFCT = 1.0D0
      ELSEIF(IUNIT.EQ.2) THEN
        UCHR = '(Å)'
        CFCT = CNG
      ENDIF
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',19),'NUCLEAR COORDINATES AND POTENTIALS'
      WRITE(7, *) REPEAT(' ',19),'NUCLEAR COORDINATES AND POTENTIALS'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     LOGICAL OPTION TO DISABLE ROTATION/TRANSLATION
      TRANSFORM = .TRUE.
C
      IF(.NOT.TRANSFORM) GOTO 500
C
C**********************************************************************C
C     IDENTIFY LARGEST ATOMIC CENTRES                                  C
C**********************************************************************C
C
C     IDENTIFY THE THREE LARGEST NUCLEAR CHARGES
      LZ1 = 0
      LZ2 = 0
      LZ3 = 0
      DO N=1,NCNT
        IZ = INT(ZNUC(N))
        IF(IZ.GT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = LZ1
          LZ1 = IZ
        ELSEIF(IZ.GT.LZ2.AND.IZ.LT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = IZ
        ELSEIF(IZ.GT.LZ3.AND.IZ.LT.LZ2) THEN
          LZ3 = IZ
        ENDIF
      ENDDO
C
C     COUNT CENTRES WITH TOP THREE NUCLEAR CHARGES
      NZ1 = 0
      NZ2 = 0
      NZ3 = 0
      DO N=1,NCNT
        IZ = INT(ZNUC(N))
        IF(IZ.EQ.LZ1) THEN
          NZ1 = NZ1 + 1
          IZAD(NZ1,1) = N
        ELSEIF(IZ.EQ.LZ2) THEN
          NZ2 = NZ2 + 1
          IZAD(NZ2,2) = N
        ELSEIF(IZ.EQ.LZ3) THEN
          NZ3 = NZ3 + 1
          IZAD(NZ3,3) = N
        ENDIF
      ENDDO
C
C     DESIGNATE SPECIES OF MOLECULE
      IF(NZ2.EQ.0) THEN
        SPCES = 'HOMONUC.'
      ELSE
        SPCES = 'HTRONUC.'
      ENDIF
C
C**********************************************************************C
C     TRANSLATION: ORIGIN COINCIDES WITH CENTRE OF ALL HEAVY ATOMS     C
C**********************************************************************C
C
C     CALCULATE CENTRE OF ALL CHARGES LZ1
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ1
          CENT(I) = CENT(I) + BXYZ(I,IZAD(N,1))
        ENDDO
        CENT(I) = CENT(I)/NZ1
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     TRANSLATE MOLECULE BY CENT(I) AND CALCULATE DISTANCE TO ORIGIN
      DO N=1,NCNT
        DO I=1,3
          XYZ(I,N) = BXYZ(I,N) - CENT(I)
        ENDDO
        DIST(N) = DSQRT(XYZ(1,N)**2 + XYZ(2,N)**2 + XYZ(3,N)**2)
      ENDDO
C
C     ALERT THE USER IF TRANSLATION WAS SUBSTANTIAL
      IF(DCNT.GT.1.0D-4) THEN
        WRITE(6, *) 'In NUCGEOM: molecule has been translated.'
        WRITE(7, *) 'In NUCGEOM: molecule has been translated.'
      ENDIF
C
C     ONE-CENTRE (MUST BE ATOMIC)
      IF(NCNT.EQ.1) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'ATOMIC'
C
C       NO ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     FIRST ROTATION: FIX ON A ROTATION CENTRE AND ROTATE TO Z-AXIS.   C
C**********************************************************************C
C
C     IF AN LZ1 CENTRE IS ON Z-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(3,N))
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 200
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTRE THAT DOES NOT LIE ON ORIGIN
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        IF(DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 35
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTRE ALREADY ON
C     THE Z-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ2.
C
C     VECTOR CENTRE OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ2 IS ON Z-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DABS(CENT(3))
      IF(DABS(X).LT.1.0D-4.AND.DCNT.GT.1.0D-4) THEN
        GOTO 200
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON ORIGIN, FIX ON AN LZ2 NOT ON THE ORIGIN
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          IF(DIST(N).GT.1.0D-4) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 35
          ENDIF
        ENDDO
      ENDIF
C
C     LZ1 AND LZ2 ALWAYS SUFFICIENT TO DEFINE A Z ORIENTATION
C
C     SKIP POINT (ROTATION CENTRE HAS BEEN IDENTIFIED)
35    CONTINUE
C
C     CALCULATE FIRST ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
C     BETA  IS ROTATION ANGLE FROM (X,Z) TO (0,Z')
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      BETA  = DACOS(CENT(3)/DCNT)
      CALL ROTATE(XYZ,NCNT,ALPHA,BETA)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Z-AXIS ROTATION NECESSARY
200   CONTINUE
C
C     TWO-CENTRE (MUST BE DIATOMIC)
      IF(NCNT.EQ.2) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'DIATOM'
C
C       NO FURTHER ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     SECOND ROTATION: FIX ON A ROTATION CENTRE AND ROTATE TO Y-AXIS.  C
C**********************************************************************C
C
C     CHECK WHETHER MOLECULE IS LINEAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2 + XYZ(2,N)**2
        IF(TEST.GT.1.0D-6) GOTO 40
      ENDDO
      SHAPE = 'LINEAR'
      GOTO 300
40    CONTINUE
C
C     IF AN LZ1 CENTRE IS ON YZ-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DSQRT(XYZ(2,N)**2 + XYZ(3,N)**2)
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 300
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTRE THAT DOES NOT LIE ON ORIGIN OR Z-AXIS
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(2,N))
        IF(DABS(X).GT.1.0D-4.AND.DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 50
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTRE ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ2.
C
C     IF THERE ARE NO LZ2 CENTRES, SKIP ROTATION
      IF(NZ2.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTRE OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ2 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTRE OF LZ2 IS NOT ON Y-AXIS, MAKE IT THE CENTRE
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ2 CENTRE ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ3.
C
C     IF THERE ARE NO LZ3 CENTRES, SKIP ROTATION
      IF(NZ3.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTRE OF ALL LZ3
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ3
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ3
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ3 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTRE OF LZ3 IS NOT ON Y-AXIS, MAKE IT THE CENTRE
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTRE OF LZ3 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTRE OF LZ3 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     SKIP POINT (ROTATION CENTRE HAS BEEN IDENTIFIED)
50    CONTINUE

C     CALCULATE ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      CALL ROTATE(XYZ,NCNT,ALPHA,0.0D0)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Y-AXIS ROTATION NECESSARY
300   CONTINUE
C
C     IF MOLECULE ALREADY HAS LABEL, SKIP
      IF(SHAPE.EQ.'ATOMIC') GOTO 400
      IF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') GOTO 400
C
C     CHECK WHETHER MOLECULE IS PLANAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2
        IF(TEST.GT.1.0D-6) GOTO 60
      ENDDO
      SHAPE = 'PLANAR'
60    CONTINUE
C
C     NO MOLECULAR SYMMETRY
      SHAPE = 'NOSYMM'
C
400   CONTINUE
C
C     TRANSFER ALL TEMPORARY COORDINATES TO THE COMMON ARRAY
      DO N=1,NCNT
        DO I=1,3
          BXYZ(I,N) = XYZ(I,N)
        ENDDO
      ENDDO
C
C     ROTATION/TRANSLATION SKIP
500   CONTINUE
C
C**********************************************************************C
C     MOLECULAR GEOMETRY, BOND DISTANCES AND NUCLEAR REPULSION ENERGY  C
C**********************************************************************C
C
C     ATOMIC COORDINATES
20    FORMAT(11X,A,1X,A)
21    FORMAT(1X,A,12X,A,14X,A,14X,A)
22    FORMAT(1X,I2,' (',A,') ',6X,F16.10,5X,F16.10,5X,F16.10)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) '  Molecular geometry A: Cartesian coordinates',UCHR
      WRITE(7,20) '  Molecular geometry A: Cartesian coordinates',UCHR
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,21) 'Centre','x-coord','y-coord','z-coord'
      WRITE(7,21) 'Centre','x-coord','y-coord','z-coord'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IZ=1,NCNT
        ELA = ELMT(INT(ZNUC(IZ)))
        WRITE(6,22) IZ,ELA,(CFCT*BXYZ(IX,IZ),IX=1,3)
        WRITE(7,22) IZ,ELA,(CFCT*BXYZ(IX,IZ),IX=1,3)
      ENDDO
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     BOND ANGLES AND DISTANCES
30    FORMAT(21X,A)
31    FORMAT(1X,A,6X,A,1X,A,11X,A,12X,A)
32    FORMAT(1X,A,2X,A,7X,F14.6)
33    FORMAT(40X,A,2X,A,2X,A,9X,F14.6)
      IF(NCNT.EQ.1) THEN
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
      ELSEIF(NCNT.GT.1) THEN
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'Molecular geometry B: R-matrix'
        WRITE(7,30) 'Molecular geometry B: R-matrix'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,31) 'C1  C2','Bond length',UCHR,'C1  C2  C3',
     &                                                    'Angle (deg)'
        WRITE(7,31) 'C1  C2','Bond length',UCHR,'C1  C2  C3',
     &                                                    'Angle (deg)'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
C
        ICNT = 1
        DO JCNT=2,NCNT
          ELA = ELMT(INT(ZNUC(ICNT)))
          ELB = ELMT(INT(ZNUC(JCNT)))
          R1X = BXYZ(1,JCNT) - BXYZ(1,ICNT)
          R1Y = BXYZ(2,JCNT) - BXYZ(2,ICNT)
          R1Z = BXYZ(3,JCNT) - BXYZ(3,ICNT)
          D1  = DSQRT(R1X*R1X + R1Y*R1Y + R1Z*R1Z)
          WRITE(6,32) ELA,ELB,CFCT*D1
          WRITE(7,32) ELA,ELB,CFCT*D1
C
          DO KCNT=2,JCNT-1
            ELA = ELMT(INT(ZNUC(ICNT)))
            ELB = ELMT(INT(ZNUC(JCNT)))
            ELC = ELMT(INT(ZNUC(KCNT)))
            R2X = BXYZ(1,KCNT) - BXYZ(1,ICNT)
            R2Y = BXYZ(2,KCNT) - BXYZ(2,ICNT)
            R2Z = BXYZ(3,KCNT) - BXYZ(3,ICNT)
            D2  = DSQRT(R2X*R2X + R2Y*R2Y + R2Z*R2Z)
            SP  = (R1X*R2X + R1Y*R2Y + R1Z*R2Z)
            D12 = D1*D2
            DEG = 180.0D0/PI
            ANG = DEG*DACOS(SP/D12)
            WRITE(6,33) ELB,ELA,ELC,ANG
            WRITE(7,33) ELB,ELA,ELC,ANG
          ENDDO
          IF(JCNT.NE.NCNT) THEN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
          ENDIF
        ENDDO
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
        DO ICNT=1,NCNT
          DO JCNT=1,ICNT-1
            SEP  = DSQRT((BXYZ(1,ICNT) - BXYZ(1,JCNT))**2
     #                  +(BXYZ(2,ICNT) - BXYZ(2,JCNT))**2
     #                  +(BXYZ(3,ICNT) - BXYZ(3,JCNT))**2)
            EPNT = ZNUC(ICNT)*ZNUC(JCNT)/SEP
C
CC          TODO: MAKE SURE THIS IS RIGHT -- UPDATED WITH FERMI CHARGE
CC          THIS CODE INCLUDES GAUSSIAN CHARGE STRUCTURE EFFECTS,
CC          BUT CORRECTIONS EXCEED DOUBLE FLOAT ACCURACY LIMITS...
C           EERF = 0.0D0
C           DO IFT=1,NNUC(ICNT)
C             DO JFT=1,NNUC(JCNT)
C               EPRD = XNUC(ICNT,IFT)*XNUC(JCNT,JFT)
C               ESUM = XNUC(ICNT,IFT)+XNUC(JCNT,JFT)
C               EGAU = DSQRT(EPRD/ESUM)*SEP
C               EERF = EERF + FNUC(ICNT,IFT)*FNUC(JCNT,JFT)*DERF(EGAU)
C             ENDDO
C           ENDDO
C           ESEP = EPNT*EERF
C
            ESEP = EPNT
            ENUC = ENUC + ESEP

          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FOCKIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       FFFFFFFF OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C       FF      OO    OO CC    CC KK   KK   II  NNN   NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NNNN  NN DD    DD      C
C       FFFFFF  OO    OO CC       KKKKK     II  NN NN NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NN  NNNN DD    DD      C
C       FF      OO    OO CC    CC KK   KK   II  NN   NNN DD    DD      C
C       FF       OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  FOCKIND ASSIGNS INDICES FOR FOCK MATRIX BLOCKS DEPENDING ON BASIS   C
C  NUMBERS IZ, KQN AND MQN QUANTUM NUMBERS OF EACH BASIS FUNCTION.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
C
C     QUANTUM NUMBER LABELS
      ILST = 0
      DO IZ=1,NCNT
        DO IMV=0,MEL
          MQN = 2*IMV+1
C
C         LABEL MQN<0 BLOCKS
          DO KA=1,NKAP(IZ)
            KQN = KAPA(KA,IZ)
            LQN = LVAL(KQN)
            NBAS  = NFNC(LQN,IZ)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LRGE(IZ,KA,MQN) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = IZ
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) =-MQN
              ENDDO
              ILST = ILST+NBAS
            ENDIF
          ENDDO
C
C         LABEL MQN>0 BLOCKS
          DO KA=1,NKAP(IZ)
            KQN = KAPA(KA,IZ)
            LQN = LVAL(KQN)
            NBAS  = NFNC(LQN,IZ)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LRGE(IZ,KA,MQN+1) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = IZ
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) = MQN
              ENDDO
              ILST = ILST + NBAS
            ENDIF
          ENDDO

        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE CARTIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        CCCCCC     AA    RRRRRRR TTTTTTTT IIII NN    NN DDDDDDD       C
C       CC    CC   AAAA   RR    RR   TT     II  NNN   NN DD    DD      C
C       CC        AA  AA  RR    RR   TT     II  NNNN  NN DD    DD      C
C       CC       AA    AA RR    RR   TT     II  NN NN NN DD    DD      C
C       CC       AAAAAAAA RRRRRRR    TT     II  NN  NNNN DD    DD      C
C       CC    CC AA    AA RR    RR   TT     II  NN   NNN DD    DD      C
C        CCCCCC  AA    AA RR    RR   TT    IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  CARTIND GENERATES INDICES FOR EQ-COEFFICIENTS AND R-INTEGRALS.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     LOOP OVER ALL (A,B,C) SO THAT A+B+C=LAM AND APPLY ORDERED ADDRESS
C     (USE T, U AND V AS INTERMEDIATE COUNTERS RESPECTIVELY)
      N = 0
      DO LAM=0,ML4
        DO IT=0,LAM
          DO IU=0,LAM
            DO IV=0,LAM
C
C             TEST WHETER A+B+C=LAM
              IF(IT+IU+IV.NE.LAM) GOTO 10
C
C             UPDATE ADDRESS
              N = N+1
C
C             CARTESIAN INDICES (A,B,C) AND LAM VALUE FOR THIS ADDRESS
              IA(N) = IT
              IB(N) = IU
              IC(N) = IV
              ILAM(N) = LAM
C
C             GLOBAL ADDRESS FOR THIS (A,B,C) INDEX
              IABC(IT,IU,IV) = N
C
C             SKIP POINT FOR (A,B,C) THAT DO NOT ADD TO LAM
10            CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE AUFBAU(IZNC,IQNC,NORB,NOCC,LMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            AA    UU    UU FFFFFFF BBBBBBB     AA    UU    UU         C
C           AAAA   UU    UU FF      BB    BB   AAAA   UU    UU         C
C          AA  AA  UU    UU FF      BB    BB  AA  AA  UU    UU         C
C         AA    AA UU    UU FFFFF   BBBBBBB  AA    AA UU    UU         C
C         AAAAAAAA UU    UU FF      BB    BB AAAAAAAA UU    UU         C
C         AA    AA UU    UU FF      BB    BB AA    AA UU    UU         C
C         AA    AA  UUUUUU  FF      BBBBBBB  AA    AA  UUUUUU          C
C                                                                      C
C -------------------------------------------------------------------- C
C  AUFBAU DETERMINES THE GROUND STATE ELECTRONIC CONFIGURATION OF AN   C
C  ATOM WITH IQNC ELECTRONS. LIMITS ON # ELECTRONS IN THE ATOM:        C
C -------------------------------------------------------------------- C
C  LMAX |  0    1    2    3    4    5 |   OR IN GENERAL FOR LMAX,      C
C  NMAX |  4   20   56  120  220  364 |   NMAX = (2L+2)(2L+3)(2L+4)/6. C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ LMAX IS THE HIGHEST LQN REQUIRED TO DESCRIBE THE GROUND STATE     C
C  ▶ NOCC SAVES THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS      C
C  ▶ NORB SAVES THE NUMBER OF ELECTRONS IN OF TYPE LQN IN SHELL N      C
C  PARAMETERS:                                                         C
C  ▶ IORD STORES THE LQN OF ORBITALS IN ORDER OF HYDROGENIC ENERGY     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION NORB(0:MEL,MKP+1),NOCC(0:MEL),IORD((MEL+1)*(MEL+2))
C
C     INITIALISE THE OCCUPIED NQN SHELL COUNTER FOR EACH LQN
      DO LQN=0,MEL
        NOCC(LQN) = 0
      ENDDO
C
C     RECORD LQNS AS THEY APPEAR IN A FULL AUFBAU COUNT UP TO LMAX
      ICT = 0
C
C     EACH LQN AS THE HIGHEST
      DO LHIGH=0,MEL
C
C       GET TWO DIAGONAL STRIKES FOR THIS LHIGH
        DO MDIAG=1,2
C
C         GO BACKWARDS FROM THIS LQN DOWN TO ZERO AND RECORD LQN
          DO LQN=LHIGH,0,-1
            ICT = ICT + 1
            IORD(ICT) = LQN
          ENDDO
C
        ENDDO
C
      ENDDO
C
C     INITIALISE THE MAX LQN COUNTER
      LMAX = 0
C
C     INITIALISE THE NUMBER OF ELECTRONS LEFT TO FILL ORBITALS WITH
      ILEFT = IQNC
C
C     INITIALISE LOOP OVER ORBITALS
      DO M=1,(MEL+1)*(MEL+2)
C
C       EXIT IF THERE ARE NO ELECTRONS LEFT TO COUNT
        IF(ILEFT.EQ.0) GOTO 20
C
C       THE LQN OF THIS ORBITAL IS STORED IN IORD
        LQN = IORD(M)
C
C       UPDATE THE MAX LQN COUNTER IF NECESSARY
        IF(LQN.GT.LMAX) THEN
          LMAX = LQN
        ENDIF
C
C       ADD TO THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS
        NOCC(LQN) = NOCC(LQN)+1
C
C       DETERMINE NO. OF ELECTRONS REQ'D TO FULLY OCCUPY THIS SUBSHELL
        IFULL = 4*LQN + 2
C
C       BEGIN IF STATEMENT TO DETERMINE THE SUBSHELL OCCUPATION
        IF(ILEFT.GT.IFULL) THEN
C
C         IF THERE ARE MORE ELECTRONS LEFT THAN IFULL, FILL THE SUBSHELL
          NORB(LQN,NOCC(LQN)) = IFULL
          ILEFT = ILEFT-IFULL
C
        ELSE
C
C         OTHERWISE, LEAVE ALL REMAINING ELECTRONS IN THIS NSHELL
          NORB(LQN,NOCC(LQN)) = ILEFT
          GOTO 20
C
C       END THE NSHELL IF STATEMENT
        ENDIF
C
C     END LOOP OVER ATOMIC ORBITALS
      ENDDO
20    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE SPECTRM(IBND,IVIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  PPPPPPP  EEEEEEEE  CCCCCC TTTTTTTT RRRRRRR  MM       MM   C
C   SS    SS PP    PP EE       CC    CC   TT    RR    RR MMM     MMM   C
C   SS       PP    PP EE       CC         TT    RR    RR MMMM   MMMM   C
C    SSSSSS  PP    PP EEEEEE   CC         TT    RR    RR MM MM MM MM   C
C         SS PPPPPPP  EE       CC         TT    RRRRRRR  MM  MMM  MM   C
C   SS    SS PP       EE       CC    CC   TT    RR    RR MM   M   MM   C
C    SSSSSS  PP       EEEEEEEE  CCCCCC    TT    RR    RR MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPECTRM SUMMARISES THE ENERGY LEVELS OF AN SCF ITERATION, USING     C
C  ATOMIC TERM SYMBOLS, ATOMIC CENTRES AND FRACTIONAL POPULATIONS.     C
C  IT ALSO APPLIES SYMMETRY LABELS TO EACH STATE AND SORTS MQN M'FOLDS.C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IBND - NUMBER OF BOUND ORBITALS TO INCLUDE.                       C
C  ▶ IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE.                     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*1 CHL,LLAB
      CHARACTER*5 NMDL
      CHARACTER*2 ELMT(120),ELA
C
      DIMENSION FRAC(MDM,MCT,MKP,MKP+1),NPR(MCT,MKP,MKP+1)
      DIMENSION ICNLST(MDM),KQNLST(MDM),MQNLST(MDM),NQNLST(MDM),
     &          POPLST(MDM)
C
      COMPLEX*16 CTEMP,ROT1,ROT2
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/SPEC/KQNLST,MQNLST,NQNLST
C
C     RE-CALCULATE OVERLAP FOR NEW CALCULATION RUN
      CALL OVRLP
      EQFILE = .FALSE.
C
C     SENSITIVITY TOLERANCE PARAMETER
      EPS = 1.0D-16
C
C     INITIALISE COUNTER ARRAYS
      DO IZ=1,NCNT
        DO IKAP=1,NKAP(IZ)
          IKQN = KAPA(IKAP,IZ)
          IF(IKQN.LT.0) THEN
            ILQN =-IKQN-1
          ELSE
            ILQN = IKQN
          ENDIF
          NMV = 2*IABS(IKQN)
          DO IMV=1,NMV
            DO IOCC=1,IBND+IVIR
              FRAC(IOCC,IZ,IKAP,IMV) = 0.0D0
            ENDDO
            NPR(IZ,IKAP,IMV) = ILQN
          ENDDO
        ENDDO
      ENDDO
C
C     INTERNAL ROTATION BETWEEN PAIRS OF STATES
      DO IPAIR=1,NDIM-NSKP,2
C
C       SKIP NEGATIVE ENERGY SPECTRUM
        MPAIR = IPAIR+NSKP
C
C       TEMPORARY LARGE VALUE
        RLRG = 10.0D+10
C
C       INITIAL INCREMENTAL RADIAN (SWEEP OVER ALL POSSIBLE ANGLES)
        RINC = PI/180.0D0
C
C       SEARCH FOR STARTING POINT BY SWEEPING ANGLES 0 <= φ < PI
        DO NPHI=0,179
C
C         CALCULATE ROTATION ANGLE AND COS/SIN TRANSFORMATIONS
          PHI  = RINC*DFLOAT(NPHI)
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
            ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
            OLAP = OLAP + CDABS(ROT1)*CDABS(ROT2)
          ENDDO
C
C         FIND PHI WHICH RESULTS IN SMALLEST SUM OF PRODUCTS
          IF(OLAP.LT.RLRG) THEN
            PHI0 = PHI
            RLRG = OLAP
          ENDIF
        ENDDO
C
C       NEW STARTING ROTATION ANGLE BASED ON THE ABOVE SEARCH
        PHI  = PHI0 - RINC
        SOLD = 1.0D+11
C
C       SWEEP THROUGH INCREMENTAL ANGLES AND SEARCH AGAIN
        DO NPHI=1,4000
          PHI  = PHI + RINC
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
            ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
            OLAP = OLAP + ABS(CONJG(ROT1)*(ROT2))
          ENDDO
C
C         IF THE NEW VALUE IS BELOW A TOLERANCE, FINISH.
          IF(DABS(OLAP-SOLD).LT.EPS) GOTO 1
C
C         IF SUM OF COEFFICIENT PRODUCTS IS BIGGER THAN COUNTER, REFINE.
          IF(OLAP.GT.SOLD) THEN
            RINC =-RINC/10.0D0
          ENDIF
C
C         DECREASE COUNTER VALUE
          SOLD = OLAP
C
        ENDDO
1       CONTINUE
C
C       PERFORM THE ACTUAL ROTATION USING THE BEST SOLUTION PHI
        CPHI = DCOS(PHI)
        SPHI = DSIN(PHI)
        DO I=1,NDIM
C
          ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
          ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
C
          COEF(I,MPAIR  ) = ROT1
          COEF(I,MPAIR+1) = ROT2
C
        ENDDO
C
      ENDDO
C
C     CALCULATE FRACTIONAL OCCUPATION FOR EACH SOLUTION VECTOR
C
C     LOOP OVER OCCUPIED ORBITALS
      DO IOCC=1,IBND+IVIR
C
C       IGNORE NEGATIVE SPECTRUM
        MOCC = IOCC+NSKP
C
C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
        DO I=1,NDIM-NSKP
          IS = I+NSKP
          ICNT = LABICN(I)
          IKQN = LABKQN(I)
          IMQN = LABMQN(I)
          IF(IKQN.LT.0) THEN
            IKAP =-2*IKQN-1
          ELSE
            IKAP = 2*IKQN
          ENDIF
          IF(IMQN.LT.0) THEN
            IMV = IABS(IMQN)
          ELSE
            IMV = IMQN+1
          ENDIF
C
          DO J=1,NDIM-NSKP
            JS = J+NSKP
            JCNT = LABICN(J)
            JKQN = LABKQN(J)
            JMQN = LABMQN(J)
C
C           LARGE AND SMALL CONTRIBUTIONS
            TMP = DREAL(DCONJG(COEF(I ,MOCC))*COEF(J ,MOCC)*OVLP(I ,J ))
     &          + DREAL(DCONJG(COEF(IS,MOCC))*COEF(JS,MOCC)*OVLP(IS,JS))
C
C           DECIDE WHERE TO PUT CONTRIBUTION
            IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
              FRAC(IOCC,ICNT,IKAP,IMV) = FRAC(IOCC,ICNT,IKAP,IMV) + TMP
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     IDENTIFY CONVENTIONAL DIRAC QUANTUM NUMBERS BASED ON FRAC.
C
C     LOOP OVER POSITIVE ENERGY SPECTRUM IN PAIRS
      DO IOCC=1,NDIM-NSKP
C
C       SEARCH FOR HIGHEST POPULATED ATOMIC STATE
        PLTN = 0.0D0
        DO ICNT=1,NCNT
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            NMV  = 2*IABS(IKQN)
            DO IMV=1,NMV
              IF(FRAC(IOCC,ICNT,IKAP,IMV).GT.PLTN) THEN
                PLTN = FRAC(IOCC,ICNT,IKAP,IMV)
                KCNT = ICNT
                KKQN = IKQN
                KKAP = IKAP
                KMV  = IMV
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        NPR(KCNT,KKAP,KMV) = NPR(KCNT,KKAP,KMV)+1
C
C       APPLY DIRAC LABELS ACCORDING TO HIGHEST POPULATED STATE
        NQNLST(IOCC) = NPR(KCNT,KKAP,KMV)
        ICNLST(IOCC) = KCNT
        KQNLST(IOCC) = KKQN
        POPLST(IOCC) = FRAC(IOCC,KCNT,KKAP,KMV)
        IF(MOD(KMV,2).EQ.1) THEN
          MQNLST(IOCC) =-KMV
        ELSE
          MQNLST(IOCC) = KMV-1
        ENDIF
C
C     END LOOP OVER ORBITALS
      ENDDO
C
C     SORTING: ORGANISE POSITIVE-ENERGY SOLUTIONS IN MQN PAIRS
C
      IF(NCNT.EQ.1) THEN
C
C       LOOP OVER ALL STATES
        DO IOCC=1,NDIM-NSKP
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MOCC = IOCC+NSKP
C
C         IDENTIFY KQN OF STATE
          IKQN = KQNLST(IOCC)
C
C         FOR THIS KQN VALUE, SEARCH NEXT 2*|KQN| ENTRIES AND ORDER
C
        ENDDO
C
      ELSEIF(NCNT.GT.1) THEN
C
C       LOOP OVER PAIRS OF STATES
        DO IPAIR=1,NDIM-NSKP,2
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MPAIR = IPAIR+NSKP
C
C         NO NEED TO SWAP IF MQN OF THE FIRST STATE IS NEGATIVE
          IF(MQNLST(IPAIR).LT.0) GOTO 100
C
C         SWAP EIGENVALUES, EXPANSION COEFFICIENTS AND MQN VALUES
          ETEMP         = EIGN(MPAIR+1)
          EIGN(MPAIR+1) = EIGN(MPAIR  )
          EIGN(MPAIR  ) = ETEMP
C
          DO I=1,NDIM
            CTEMP           = COEF(I,MPAIR+1)
            COEF(I,MPAIR+1) = COEF(I,MPAIR  )
            COEF(I,MPAIR  ) = CTEMP
          ENDDO
C
          MTEMP           = MQNLST(IPAIR+1)
          MQNLST(IPAIR+1) = MQNLST(IPAIR  )
          MQNLST(IPAIR  ) = MTEMP
C
          PTEMP           = POPLST(IPAIR+1)
          POPLST(IPAIR+1) = POPLST(IPAIR  )
          POPLST(IPAIR  ) = PTEMP
C
C         SKIP POINT FOR ALREADY-SORTED PAIRS
100       CONTINUE
C
        ENDDO
C
      ENDIF
C
C     PRINT TITLE TO TERMINAL/FILE
20    FORMAT(1X,'Orb.',2X,'Centre',4X,'Term sym.',3X,'m_j',14X,
     &                                    'Energy (au)',6X,'Population')
21    FORMAT(1X,I3,2X,I2,' (',A,')',4X,I2,A,'_',I1,'/2',4X,I2,'/2',3X,
     &                                                  F22.12,6X,F10.8)
C
      WRITE(6,20)
      WRITE(7,20)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     SUMMARISE RESULTS
      DO IOCC=1,IBND+IVIR
C
        MOCC = IOCC+NSKP
C
        ICNT = ICNLST(IOCC)
        INQN = NQNLST(IOCC)
        IKQN = KQNLST(IOCC)
        IMQN = MQNLST(IOCC)
        ELA  = ELMT(INT(ZNUC(ICNT)))
        IF(IKQN.LT.0) THEN
          ILQN =-IKQN-1
        ELSE
          ILQN = IKQN
        ENDIF
        CHL  = LLAB(ILQN)
        IJQN = 2*IABS(IKQN)-1

        IF(IOCC.LE.IBND) THEN
          PLTN = POPLST(IOCC)
        ELSE
          PLTN = 0.0D0
        ENDIF
C
        IF(HMLT.EQ.'NORL') THEN
          PLTN = 0.5D0*PLTN
        ENDIF
C
C       OUTPUT TO TERMINAL
        WRITE(6,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGN(MOCC),PLTN
        WRITE(7,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGN(MOCC),PLTN
        IF(IOCC.EQ.IBND.AND.IVIR.NE.0) THEN
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF
C
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ROTATE(XYZ,NCNT,ALPHA,BETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          RRRRRRR   OOOOOO TTTTTTTT   AA   TTTTTTTT EEEEEEEE          C
C          RR    RR OO    OO   TT     AAAA     TT    EE                C
C          RR    RR OO    OO   TT    AA  AA    TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EEEEEE            C
C          RRRRRRR  OO    OO   TT   AAAAAAAA   TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EE                C
C          RR    RR  OOOOOO    TT   AA    AA   TT    EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ROTATE PERFORMS TWO ROTATIONS ON ALL ATOMIC CENTRES, FIRST SO THAT  C
C  Y DOES NOT CHANGE, AND THEN SO THAT Z DOES NOT CHANGE.              C
C**********************************************************************C
C
      DIMENSION XYZ(3,NCNT),V(3),W(3)
      DIMENSION AR(3,3),BR(3,3),RR(3,3)
C
C     INITIALISE MATRICES
      DO I=1,3
        DO J=1,3
          AR(I,J) = 0.0D0
          BR(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     FIX ALL VALUES OF Z AND ROTATE BY ALPHA
      AR(3,3) = 1.0D0
      AR(1,1) = DCOS(ALPHA)
      AR(2,2) = DCOS(ALPHA)
      AR(1,2) = DSIN(ALPHA)
      AR(2,1) =-DSIN(ALPHA)
C
C     FIX ALL VALUES OF Y AND ROTATE BY BETA
      BR(2,2) = 1.0D0
      BR(1,1) = DCOS(BETA)
      BR(3,3) = DCOS(BETA)
      BR(3,1) = DSIN(BETA)
      BR(1,3) =-DSIN(BETA)
C
C     EVALUATE OVERALL ROTATION MATRIX
      CALL MMPROD(BR,AR,RR,3)
C
C     ROTATE ALL VECTORS IN XYZ
      DO N=1,NCNT
        DO I=1,3
          V(I) = XYZ(I,N)
        ENDDO
        CALL MVPROD(RR,V,W,3)
        DO I=1,3
          XYZ(I,N) = W(I)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MMPROD(A,B,X,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM MM       MM PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD       C
C     MMM     MMM MMM     MMM PP    PP RR    RR OO    OO DD    DD      C
C     MMMM   MMMM MMMM   MMMM PP    PP RR    RR OO    OO DD    DD      C
C     MM MM MM MM MM MM MM MM PP    PP RR    RR OO    OO DD    DD      C
C     MM  MMM  MM MM  MMM  MM PPPPPPP  RRRRRRR  OO    OO DD    DD      C
C     MM   M   MM MM   M   MM PP       RR    RR OO    OO DD    DD      C
C     MM       MM MM       MM PP       RR    RR  OOOOOO  DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  MMPROD CALCULATES THE PRODUCT OF TWO SQUARE, DOUBLE-PRECISION       C
C  MATRIX ARRAYS OF DIMENSION N, AND OUTPUTS THE RESULT INTO X.        C
C**********************************************************************C
C
      DIMENSION A(N,N),B(N,N),X(N,N)
C
C     INITIALISE X MATRIX
      DO I=1,N
        DO J=1,N
          X(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          DO K=1,N
            X(I,J) = X(I,J) + A(I,K)*B(K,J)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MVPROD(A,V,W,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       MM       MM VV    VV PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD        C
C       MMM     MMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MMMM   MMMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM MM MM MM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM  MMM  MM  VV  VV  PPPPPPP  RRRRRRR  OO    OO DD    DD       C
C       MM   M   MM   VVVV   PP       RR    RR OO    OO DD    DD       C
C       MM       MM    VV    PP       RR    RR  OOOOOO  DDDDDDD        C
C                                                                      C
C -------------------------------------------------------------------- C
C  MVPROD CALCULATES THE PRODUCT OF A SQUARE MATRIX OF DIMENSION N     C
C  AND A VECTOR OF DIMENSION N, AND OUTPUTS THE RESULT INTO W.         C
C**********************************************************************C
C
      DIMENSION A(N,N),V(N),W(N)
C
C     INITIALISE W MATRIX
      DO I=1,N
        W(I) = 0.0D0
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          W(I) = W(I) + A(I,J)*V(J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION MS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          MM       MM  SSSSSS                         C
C                          MMM     MMM SS    SS                        C
C                          MMMM   MMMM SS                              C
C                          MM MM MM MM  SSSSSS                         C
C                          MM  MMM  MM       SS                        C
C                          MM   M   MM SS    SS                        C
C                          MM       MM  SSSSSS                         C
C                                                                      C
C -------------------------------------------------------------------- C
C   MS RETURNS A QUOTED TIME IN SECONDS USING 'MIN-SEC' FORMAT.        C
C**********************************************************************C
      CHARACTER*4 MINUTES
      CHARACTER*7 SECONDS
      CHARACTER*11 MS
C
C     INITIALISE COUNTERS
      NMIN = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PRINT THE MINUTE
      IF(NMIN.EQ.0) THEN
        WRITE(MINUTES,'(A)') '    '
      ELSE
        WRITE(MINUTES,'(I3,A)') NMIN,'m'
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F4.2,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F4.2,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(MS,'(A,A)') MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      FUNCTION HMS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                     HH    HH MM       MM  SSSSSS                     C
C                     HH    HH MMM     MMM SS    SS                    C
C                     HH    HH MMMM   MMMM SS                          C
C                     HHHHHHHH MM MM MM MM  SSSSSS                     C
C                     HH    HH MM  MMM  MM       SS                    C
C                     HH    HH MM   M   MM SS    SS                    C
C                     HH    HH MM       MM  SSSSSS                     C
C                                                                      C
C -------------------------------------------------------------------- C
C   HMS RETURNS A QUOTED TIME IN SECONDS USING 'HR-MIN-SEC' FORMAT.    C
C**********************************************************************C
      CHARACTER*4 HOURS,MINUTES
      CHARACTER*8 SECONDS
      CHARACTER*16 HMS
C
C     INITIALISE COUNTERS
      NMIN = 0
      NHRS = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0 <= NMIN < 60
      DO WHILE (NMIN.GE.60)
        NMIN = NMIN - 60
        NHRS = NHRS + 1
      ENDDO
C
C     PRINT THE HOUR
      IF(NHRS.EQ.0) THEN
        WRITE(HOURS,'(A)') '    '
      ELSE
        WRITE(HOURS,'(I3,A)') NHRS,'h'
      ENDIF
C
C     PRINT THE MINUTE
      IF(NHRS.EQ.0) THEN
        IF(NMIN.EQ.0) THEN
          WRITE(MINUTES,'(1X,A)') '   '
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ELSEIF(NHRS.NE.0) THEN
        IF(NMIN.LT.10) THEN
          WRITE(MINUTES,'(1X,I1,I1,A)') 0,NMIN,'m'
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F5.3,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F5.3,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(HMS,'(A,A,A)') HOURS//MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      SUBROUTINE TIMENOW(STAMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  TTTTTTTT IIII MM       MM EEEEEEEE NN    NN  OOOOOO  WW        WW   C
C     TT     II  MMM     MMM EE       NNN   NN OO    OO WW        WW   C
C     TT     II  MMMM   MMMM EE       NNNN  NN OO    OO WW   WW   WW   C
C     TT     II  MM MM MM MM EEEEEE   NN NN NN OO    OO WW  WWWW  WW   C
C     TT     II  MM  MMM  MM EE       NN  NNNN OO    OO WW WW  WW WW   C
C     TT     II  MM   M   MM EE       NN   NNN OO    OO WWWW    WWWW   C
C     TT    IIII MM       MM EEEEEEEE NN    NN  OOOOOO  WW        WW   C
C                                                                      C
C -------------------------------------------------------------------- C
C  TIMENOW CREATES A DATE STRING SPECIFYING CPU TIME WHEN CALLED.      C
C**********************************************************************C
      CHARACTER*5  ZONE
      CHARACTER*8  DATE
      CHARACTER*10 TIME
      CHARACTER*20 STAMP
C
      DIMENSION IVL(8)
C
C     CALL TIME AND DATE ROUTINE
      CALL DATE_AND_TIME(DATE,TIME,ZONE,IVL)
C
C     PRINT THE DAY
      IF(IVL(3).LT.10) THEN
        WRITE(STAMP,'(1X,I1,I1,A)') 0,IVL(3),'/'
      ELSE
        WRITE(STAMP,'(1X,I2,A)') IVL(3),'/'
      ENDIF
C
C     PRINT THE MONTH
      IF(IVL(2).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(2),'/'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(2),'/'
      ENDIF
C
C     PRINT THE YEAR
      WRITE(STAMP,'(A,I4)') TRIM(STAMP),IVL(1)
C
C     PRINT THE HOUR
      IF(IVL(5).LT.10) THEN
        WRITE(STAMP,'(A,A,I1,I1,A)') TRIM(STAMP),' ',0,IVL(5),':'
      ELSE
        WRITE(STAMP,'(A,A,I2,A)') TRIM(STAMP),' ',IVL(5),':'
      ENDIF
C
C     PRINT THE MINUTE
      IF(IVL(6).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(6),':'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(6),':'
      ENDIF
C
C     PRINT THE SECOND
      IF(IVL(7).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1)') TRIM(STAMP),0,IVL(7)
      ELSE
        WRITE(STAMP,'(A,I2)') TRIM(STAMP),IVL(7)
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE PROGRSS(I,N,TBEG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    PPPPPPP  RRRRRRR   OOOOOO   GGGGGG  RRRRRRR   SSSSSS   SSSSSS     C
C    PP    PP RR    RR OO    OO GG    GG RR    RR SS    SS SS    SS    C
C    PP    PP RR    RR OO    OO GG       RR    RR SS       SS          C
C    PP    PP RR    RR OO    OO GG       RR    RR  SSSSSS   SSSSSS     C
C    PPPPPPP  RRRRRRR  OO    OO GG   GGG RRRRRRR        SS       SS    C
C    PP       RR    RR OO    OO GG    GG RR    RR SS    SS SS    SS    C
C    PP       RR    RR  OOOOOO   GGGGGG  RR    RR  SSSSSS   SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  PROGRSS TRACKS HOW MUCH WORK HAS BEEN DONE AND EXPECTED COMPLETION. C
C  REQUIRES NUMBER OF PROCESSES HAVE BEEN FINISHED, HOW MANY ARE TO    C
C  BE DONE IN TOTAL, AND START TIME OF JOB AS A WHOLE.                 C
C**********************************************************************C
C
      CHARACTER*16 HMS
C
      INTEGER*16 I,N
C
C     COMPLETION RATIO
      RAT = DFLOAT(I)/DFLOAT(N)
C
C     TIME NOW
      CALL CPU_TIME(TNOW)
C
C     DIFFERENCE BETWEEN TIME NOW AND START TIME
      TDIF = TNOW-TBEG
C
C     PROJECTED TOTAL COMPLETION TIME
      TTOT = (TNOW-TBEG)/RAT
C
C     PROJECTED END TIME
      TEND = TBEG + TTOT
C
C     EXPECTED TIME LEFT
      TLFT = TTOT-TNOW+TBEG
C
C     FOR COMPLETION MARKERS
10    FORMAT('Completion: ',F8.4,' %',8X,'Time left: ',1X,A)
      WRITE(6,10) 100.0D0*RAT,HMS(TLFT)
      WRITE(7,10) 100.0D0*RAT,HMS(TLFT)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [B] DENSTY: GENERATES CLOSED- AND OPEN-SHELL MOLECULAR DENSITY.    C
C   [D] ENERGIES: USE DENSITY MATRIX TO CALCULATE ENERGY TERMS.        C
C**********************************************************************C
C
C
      SUBROUTINE DENSTY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS TTTTTTTT YY    YY         C
C         DD    DD EE       NNN   NN SS    SS   TT    YY    YY         C
C         DD    DD EE       NNNN  NN SS         TT     YY  YY          C
C         DD    DD EEEEEE   NN NN NN  SSSSSS    TT      YYYY           C
C         DD    DD EE       NN  NNNN       SS   TT       YY            C
C         DD    DD EE       NN   NNN SS    SS   TT       YY            C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS    TT       YY            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSTY GENERATES DENSITY MATRICES FROM THE EXPANSION COEFFS COEF.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
c
      COMPLEX*16 SUM
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     MAKE CLOSED-SHELL DENSITY AND EMPTY OPEN-SHELL DENSITY (RSCF 81)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NCLS
            ICL = ICLS(IOCC)
            SUM = SUM +      DCONJG(COEF(I,ICL+NSKP))*COEF(J,ICL+NSKP)
          ENDDO
          DENC(I,J) = SUM
          DENT(I,J) = DENC(I,J)
          DENO(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
      IF(NOPN.EQ.0) GOTO 100
C
C     MAKE THE OPEN-SHELL DENSITY (RSCF 82)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NOPN
            IOP = IOPN(IOCC)
            SUM = SUM + FOPN*DCONJG(COEF(I,IOP+NSKP))*COEF(J,IOP+NSKP)
          ENDDO
          DENO(I,J) = SUM
          DENT(I,J) = DENT(I,J)+DENO(I,J)
        ENDDO
      ENDDO
C
100   CONTINUE
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTRE SCF CALCULATIONS.          C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] HFSCF: MAIN ROUTINE FOR MOLECULAR HARTREE-FOCK SCF PROCEDURE.  C
C   [B] OVRLP: CONSTRUCTS THE ONE-ELECTRON OVERLAP MATRIX.             C
C   [F] COULOMB: CONSTRUCTS ALL MULTI-CENTRE COULOMB SCF ELEMENTS.     C
C   [G] ERI: GENERATES A BLOCK OF ELECTRON REPULSION INTEGRALS.        C
C   [J] BII: GENERATES A BLOCK OF BREIT INTERACTION INTEGRALS.         C
C   [N] NCART: RETURNS THE CARTESIAN INDEX FROM A LOOP INDEX.          C
C   [O] NCNTRS: RETURNS NUMBER OF UNIQUE NUCLEAR CENTRES FROM INPUT.   C
C   [P] ZPROJ: RETURNS A METRIC FOR Z-AXIS DEVIATION OF SOME COORDS.   C
C   [Q] KLAB: RETURNS THE CONVENTIONAL DIRAC SYMMETRY TYPE STRING.     C
C   [R] MLAB: RETURNS THE CONVENTIONAL DIRAC MAGNETIC STATE STRING.    C
C**********************************************************************C
C
C
      SUBROUTINE OVRLP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              OOOOOO  VV    VV RRRRRRR  LL      PPPPPPP               C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO  VV  VV  RRRRRRR  LL      PPPPPPP               C
C             OO    OO   VVVV   RR    RR LL      PP                    C
C              OOOOOO     VV    RR    RR LLLLLLL PP                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  OVRLP CONSTRUCTS A MOLECULAR BASIS FUNCTION OVERLAP MATRIX.         C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION RC(MB2,MRC),EXL(MBS,4),XYZ(3,4)
      DIMENSION KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VANM(MDM,MDM),
     &           VSLF(MDM,MDM),VUEH(MDM,MDM),VWKR(MDM,MDM),
     &           VKSB(MDM,MDM),QDIR(MDM,MDM),QXCH(MDM,MDM),
     &           WDIR(MDM,MDM),WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VANM,VSLF,
     &            VUEH,VWKR,VKSB,QDIR,QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRW,TBC1,TBC2,TBMC,
     &            TSMX,TUMX,THMX,TAMX,TC1T,TC2T,TCVT,TB1T,TB2T,TACC,
     &            TEIG,TSCR,TTOT,TC1S,TC2S,TB1S,TB2S
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          OVLP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS=+1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-PHS*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = PHS*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC OVERLAP CALCULATIONS COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 500
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS=+1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-PHS*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = PHS*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF THE OVERLAP MATRIX FOR THIS BLOCK OF   C
C     BASIS FUNCTIONS -- NOW OVERLAY THE RESULTS INTO OVLP.            C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC OVERLAP MATRIX COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 600
C
C     SS BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ERI(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                        EEEEEEEE RRRRRRR  IIII                        C
C                        EE       RR    RR  II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEE   RR    RR  II                         C
C                        EE       RRRRRRR   II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEEEE RR    RR IIII                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ XYZ  - FULL SET OF CARTESIAN BASIS CENTRES.                       C
C  ▶ KQN  - FULL SET OF RELATIVISTIC LABELS.                           C
C  ▶ MQN  - FULL SET OF MAGNETIC QUANTUM NUMBERS (MAGNITUDE).          C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  ▶ EXL  - FULL LISTS OF EXPONENTS IN THE BLOCK.                      C
C  ▶ IBAS - 1ST BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ JBAS - 2ND BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ ITN  - COMPONENT OVERLAP (T,T') FOR CD. ITN(I) = {LL,LS,SL,SS}.   C
C  OUTPUT:                                                             C
C  ▶ RR   - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL L0CASE
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MEQ),IABR21(MEQ),IABI11(MEQ),IABI21(MEQ)
      DIMENSION ICDR11(MEQ),ICDR21(MEQ),ICDI11(MEQ),ICDI21(MEQ)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ),ECD11(MB2,MEQ),
     &           EAB21(MB2,MEQ),ECD21(MB2,MEQ)
C
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(4),SHLV,ILEV
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRW,TBC1,TBC2,TBMC,
     &            TSMX,TUMX,THMX,TAMX,TC1T,TC2T,TCVT,TB1T,TB2T,TACC,
     &            TEIG,TSCR,TTOT,TC1S,TC2S,TB1S,TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA SENS/1.0D-10/
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.1.AND.ITN(IT).NE.4) THEN
          WRITE(6, *) 'In ERI: illegal component overlaps in ITN.'
          WRITE(7, *) 'In ERI: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      DO N=1,4
        LQN(N) = LVAL(KQN(N))
      ENDDO
C
C     SPECIAL CASE FOR S-TYPE OVERLAPS (ONLY EVER NEEDED ONCE)
      IF(LQN(1)+LQN(2)+LQN(3)+LQN(4).EQ.0) THEN
        L0CASE = .TRUE.
      ELSE
        L0CASE = .FALSE.
      ENDIF
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTORS FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     MCMURCHIE-DAVIDSON MAXINUM ORDER FOR EQ(AB)-COEFFICIENTS
      IF(ITN(1).EQ.1) THEN
        LAMAB = LQN(1)+LQN(2)
      ELSEIF(ITN(1).EQ.4) THEN
        LAMAB = LQN(1)+LQN(2)+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ(CD)-COEFFICIENTS
      IF(ITN(2).EQ.1) THEN
        LAMCD = LQN(3)+LQN(4)
      ELSEIF(ITN(2).EQ.4) THEN
        LAMCD = LQN(3)+LQN(4)+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR CONTRACTED R-INTEGRAL BATCH
      LAMABCD = LAMAB+LAMCD
C
C     MAXIMUM LAMBDA ORDER FOR RCTTFL SAVED LIST (ONLY IF MCNT.GT.2)
      IF(.NOT.RCFILE.OR.HMLT.EQ.'NORL') THEN
        LAMABCDFL = LAMABCD
      ELSEIF(RCFILE.AND.HMLT.NE.'NORL') THEN
        IF(ILEV.EQ.1) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)
        ELSEIF(ILEV.EQ.2) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+2
        ELSEIF(ILEV.EQ.3) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+4
        ENDIF
      ENDIF
C
C     UTILISE EXPANSION SUBSET (WHEN RCFILE.EQ.FALSE)
      IF((ITN(1)+ITN(2))/3.EQ.ILEV) THEN
        ISKIP = 0
      ELSE
        ISKIP = 1
      ENDIF
C
C     PAIR AND GROUP EQ-COEFFICIENT LIST AND R-INTEGRAL BATCH LENGTHS
      NTUVAB     = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD     = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD   = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
      NTUVABCDFL = (LAMABCDFL+1)*(LAMABCDFL+2)*(LAMABCDFL+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
      IF(EQFILE) THEN
C
C       OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
        IF(ITN(1).EQ.1) THEN
          DO ITUV=1,NTUVAB
            IAD = IABLL + (ITUV-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
              EAB21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
            ENDDO
          ENDDO
        ELSEIF(ITN(1).EQ.4) THEN
          DO ITUV=1,NTUVAB
            IAD = IABSS + (ITUV-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
              EAB21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
            ENDDO
          ENDDO
        ENDIF
C
      ELSE
C
C       OPTION 2: CALCULATE FROM SCRATCH
        IF(ITN(1).EQ.1) THEN
          CALL EQLLMK(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ELSEIF(ITN(1).EQ.4) THEN
          CALL EQSSMK(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ENDIF
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.1) THEN
        TELL = TELL+TDM2-TDM1
      ELSEIF(ITN(1).EQ.4) THEN
        TESS = TESS+TDM2-TDM1
      ENDIF
C
C     SCREENING: TEST E(AB| -) COLUMNS OF CARTESIAN INDEX (T ,U ,V )
      DO IAB=1,NTUVAB
C
C       Re{E(AB|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          ERAB11 = DREAL(EAB11(M,IAB))
          SUM = SUM + DABS(ERAB11)
          IF(SUM.GT.SENS) THEN
            IABR11(IAB) = 1
            GOTO 101
          ENDIF
        ENDDO
        IABR11(IAB) = 0
101     CONTINUE
C
C       Im{E(AB|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          EIAB11 = DIMAG(EAB11(M,IAB))
          SUM = SUM + DABS(EIAB11)
          IF(SUM.GT.SENS) THEN
            IABI11(IAB) = 1
            GOTO 102
          ENDIF
        ENDDO
        IABI11(IAB) = 0
102     CONTINUE
C
C       Re{E(AB|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          ERAB21 = DREAL(EAB21(M,IAB))
          SUM = SUM + DABS(ERAB21)
          IF(SUM.GT.SENS) THEN
            IABR21(IAB) = 1
            GOTO 103
          ENDIF
        ENDDO
        IABR21(IAB) = 0
103     CONTINUE
C
C       Im{E(AB|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          EIAB21 = DIMAG(EAB21(M,IAB))
          SUM = SUM + DABS(EIAB21)
          IF(SUM.GT.SENS) THEN
            IABI21(IAB) = 1
            GOTO 104
          ENDIF
        ENDDO
        IABI21(IAB) = 0
104     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(EQFILE) THEN
        IF(ITN(2).EQ.1) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDLL + (ITUV-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ITUV)))
            DO M=1,MAXCD
              ECD11(M,ITUV) = Z*DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
              ECD21(M,ITUV) = Z*DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
            ENDDO
          ENDDO
        ELSEIF(ITN(2).EQ.4) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDSS + (ITUV-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ITUV)))
            DO M=1,MAXCD
              ECD11(M,ITUV) = Z*DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
              ECD21(M,ITUV) = Z*DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
            ENDDO
          ENDDO
        ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      ELSE
        IF(ITN(2).EQ.1) THEN
          CALL EQLLMK(ECD11,ECD21,EXL,XY Z,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ELSEIF(ITN(2).EQ.4) THEN
          CALL EQSSMK(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(2).EQ.1) THEN
        TELL = TELL+TDM2-TDM1
      ELSEIF(ITN(2).EQ.4) THEN
        TESS = TESS+TDM2-TDM1
      ENDIF
C
C     SCREENING: TEST E(CD| -) COLUMNS OF CARTESIAN INDEX (T',U',V')
      DO ICD=1,NTUVCD
C
C       Re{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          ERCD11 = DREAL(ECD11(M,ICD))
          SUM = SUM + DABS(ERCD11)
          IF(SUM.GT.SENS) THEN
            ICDR11(ICD) = 1
            GOTO 201
          ENDIF
        ENDDO
        ICDR11(ICD) = 0
201     CONTINUE
C
C       Im{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          EICD11 = DIMAG(ECD11(M,ICD))
          SUM = SUM + DABS(EICD11)
          IF(SUM.GT.SENS) THEN
            ICDI11(ICD) = 1
            GOTO 202
          ENDIF
        ENDDO
        ICDI11(ICD) = 0
202     CONTINUE
C
C       Re{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          ERCD21 = DREAL(ECD21(M,ICD))
          SUM = SUM + DABS(ERCD21)
          IF(SUM.GT.SENS) THEN
            ICDR21(ICD) = 1
            GOTO 203
          ENDIF
        ENDDO
        ICDR21(ICD) = 0
203     CONTINUE
C
C       Im{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          EICD21 = DIMAG(ECD21(M,ICD))
          SUM = SUM + DABS(EICD21)
          IF(SUM.GT.SENS) THEN
            ICDI21(ICD) = 1
            GOTO 204
          ENDIF
        ENDDO
        ICDI21(ICD) = 0
204     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL CPU_TIME(T2)
      TCEC = TCEC+T2-T1
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) INTEGRALS IF PROMPTED            C
C**********************************************************************C
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     SKIP IF A HIGHER LEVEL OF THIS BATCH EXISTS IN RC
      IF(.NOT.RCFILE.AND.ISKIP.EQ.0) GOTO 300
C
C     SKIP IF A HIGHER LEVEL OF THIS BATCH EXISTS IN RC
      IF(L0CASE.AND.ISKIP.EQ.0) GOTO 300
C
C     SKIP IF INTEGRAL BATCH EXISTS IN FILE
      IF(RCFILE.AND.IRIJ(IBAS,JBAS).EQ.0) GOTO 300
C
      CALL CPU_TIME(T1)
C
C     GAUSSIAN OVERLAP CENTRE
      PX = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(RCFILE.AND.L0CASE.AND.ISCR(M).EQ.0) GOTO 301
          IF(.NOT.RCFILE.AND.ISCR(M).EQ.0) GOTO 301
          N   = N+1
          EKL = EXL(KBAS,3)+EXL(LBAS,4)
          QX  = (XYZ(1,3)*EXL(KBAS,3)+XYZ(1,4)*EXL(LBAS,4))/EKL
          QY  = (XYZ(2,3)*EXL(KBAS,3)+XYZ(2,4)*EXL(LBAS,4))/EKL
          QZ  = (XYZ(3,3)*EXL(KBAS,3)+XYZ(3,4)*EXL(LBAS,4))/EKL
          PQ(N,1) = QX-PX
          PQ(N,2) = QY-PY
          PQ(N,3) = QZ-PZ
          APH(N)  = EIJ*EKL/(EIJ+EKL)
301       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH SIZE AND EXPANSION LENGTH DEPENDS ON MODE
      IF(RCFILE.AND..NOT.L0CASE) THEN
        MBCH = MAXCD
        MLAM = LAMABCDFL
        MNTV = NTUVABCDFL
      ELSE
        MBCH = MAXN
        MLAM = LAMABCD
        MNTV = NTUVABCD
      ENDIF
C
C     GENERATE R-INTEGRALS
      CALL RMAKE(RC,PQ,APH,MBCH,MLAM)
C
C     SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
      DO INTV=1,MNTV
C
C       SUM OF RC(AB|CD) MAGNITUDES
        SUM = 0.0D0
        DO N=1,MBCH
          SUM = SUM + DABS(RC(N,INTV))
          IF(SUM.GT.SENS) THEN
            IRC(INTV) = 1
            GOTO 302
          ENDIF
        ENDDO
        IRC(INTV) = 0
302     CONTINUE
C
      ENDDO
C
      CALL CPU_TIME(T2)
      TCRM = TCRM+T2-T1
C
C     CONTINUE ONLY IF INTEGRALS ARE TO BE SAVED TO LARGE FILE
      IF(L0CASE) GOTO 300
      IF(.NOT.RCFILE) GOTO 300
C
      CALL CPU_TIME(T3)
C
C     TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
      IF(20*MFL.LT.IJ*MAXCD*NTUVABCDFL) THEN
C       OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
        WRITE(6, *) 'In ERI: RCTT words exceed allocated limit.'
        WRITE(7, *) 'In ERI: RCTT words exceed allocated limit.'
        GOTO 300
      ELSE
C       DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
        IRIJ(IBAS,JBAS) = 0
      ENDIF
C
C     STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
      IADRTT = (IJ-1)*MAXCD*NTUVABCDFL
C
C     COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
      DO IABCDFL=1,NTUVABCDFL
        IAD = IADRTT + MAXCD*(IABCDFL-1)
        DO M=1,MAXCD
          RCTTFL(IAD+M) = RC(M,IABCDFL)
        ENDDO
      ENDDO
C
C     STARTING ADDRESS FOR THIS BATCH OF SCREENING FLAGS
      IADSCR = (IJ-1)*NTUVABCDFL
C
C     COPY SCREENING MARKERS TO A SAVED LIST
      DO IABCDFL=1,NTUVABCDFL
        IRCTTFL(IADSCR+IABCDFL) = IRC(IABCDFL)
      ENDDO
C
      CALL CPU_TIME(T4)
      TCRW = TCRW+T4-T3
C
300   CONTINUE
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.1.AND.ITN(2).EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITN(1).EQ.4.AND.ITN(2).EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ELSE
        TRLS = TRLS+TDM2-TDM1
      ENDIF
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     TIME AT START OF FIRST CONTRACTION
      CALL CPU_TIME(T1)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) PASSES SCREENING CONDITION
        IABALL = IABR11(IAB)+IABI11(IAB)+IABR21(IAB)+IABI21(IAB)
        IF(IABALL.EQ.0) GOTO 401
C
C       CALCULATE DIRECTLY FROM SMALL RC(AB|CD) LOCAL ARRAY
        IF(.NOT.RCFILE.OR.L0CASE) THEN
C
C         LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
          DO ICD=1,NTUVCD
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),
     &                                    IC(IAB)+IC(ICD))
C
C           SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
            IF(IRC(IRABCD).EQ.0) GOTO 402
C
C           SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
            ICDALL = ICDR11(ICD)+ICDI11(ICD)+ICDR21(ICD)+ICDI21(ICD)
            IF(ICDALL.EQ.0) GOTO 402
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR11(IAB).EQ.0) GOTO 411
            IF(ISYM.EQ.2.AND.IABR11(IAB).EQ.0) GOTO 411
            IF(ICDR11(ICD).EQ.1) THEN
              DO N=1,MAXN
                GABR11(N,IAB) = GABR11(N,IAB)
     &                         + DREAL(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
              ENDDO
            ENDIF
411         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI11(IAB).EQ.0) GOTO 412
            IF(ISYM.EQ.2.AND.IABI11(IAB).EQ.0) GOTO 412
            IF(ICDI11(ICD).EQ.1) THEN
              DO N=1,MAXN
                GABI11(N,IAB) = GABI11(N,IAB)
     &                         + DIMAG(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
              ENDDO
            ENDIF
412         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR21(IAB).EQ.0) GOTO 413
            IF(ISYM.EQ.2.AND.IABR21(IAB).EQ.0) GOTO 413
            IF(ICDR21(ICD).EQ.1) THEN
              DO N=1,MAXN
                GABR21(N,IAB) = GABR21(N,IAB)
     &                         + DREAL(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
              ENDDO
            ENDIF
413         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI21(IAB).EQ.0) GOTO 414
            IF(ISYM.EQ.2.AND.IABI21(IAB).EQ.0) GOTO 414
            IF(ICDI21(ICD).EQ.1) THEN
              DO N=1,MAXN
                GABI21(N,IAB) = GABI21(N,IAB)
     &                         + DIMAG(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
              ENDDO
            ENDIF
414         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) SCREENING
402         CONTINUE
C
C         END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
          ENDDO
C
C       CALCULATE DIRECTLY FROM LARGE RC(AB|CD) SCRATCH ARRAY
        ELSE
C
C         LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
          DO ICD=1,NTUVCD
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),
     &                                    IC(IAB)+IC(ICD))
C
C           STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
            IAD = (IJ-1)*MAXCD*NTUVABCDFL + MAXCD*(IRABCD-1)
C
C           SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
            IF(IRCTTFL((IJ-1)*NTUVABCDFL+IRABCD).EQ.0) GOTO 432
C
C           SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
            ICDALL = ICDR11(ICD)+ICDI11(ICD)+ICDR21(ICD)+ICDI21(ICD)
            IF(ICDALL.EQ.0) GOTO 432
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR11(IAB).EQ.0) GOTO 421
            IF(ISYM.EQ.2.AND.IABR11(IAB).EQ.0) GOTO 421
            IF(ICDR11(ICD).EQ.1) THEN
              DO N=1,MAXN
                GABR11(N,IAB) = GABR11(N,IAB)
     &                  + DREAL(ECD11(IMAP(N),ICD))*RCTTFL(IAD+IMAP(N))
              ENDDO
            ENDIF
421         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI11(IAB).EQ.0) GOTO 422
            IF(ISYM.EQ.2.AND.IABI11(IAB).EQ.0) GOTO 422
            IF(ICDI11(ICD).EQ.1) THEN
              DO N=1,MAXN
                GABI11(N,IAB) = GABI11(N,IAB)
     &                  + DIMAG(ECD11(IMAP(N),ICD))*RCTTFL(IAD+IMAP(N))
              ENDDO
            ENDIF
422         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR21(IAB).EQ.0) GOTO 423
            IF(ISYM.EQ.2.AND.IABR21(IAB).EQ.0) GOTO 423
            IF(ICDR21(ICD).EQ.1) THEN
              DO N=1,MAXN
                GABR21(N,IAB) = GABR21(N,IAB)
     &                  + DREAL(ECD21(IMAP(N),ICD))*RCTTFL(IAD+IMAP(N))
              ENDDO
            ENDIF
423         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI21(IAB).EQ.0) GOTO 424
            IF(ISYM.EQ.2.AND.IABI21(IAB).EQ.0) GOTO 424
            IF(ICDI21(ICD).EQ.1) THEN
              DO N=1,MAXN
                GABI21(N,IAB) = GABI21(N,IAB)
     &                  + DIMAG(ECD21(IMAP(N),ICD))*RCTTFL(IAD+IMAP(N))
              ENDDO
            ENDIF
424         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) SCREENING
432         CONTINUE
C
C         END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
          ENDDO
C
        ENDIF
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION
      CALL CPU_TIME(T2)
      TCC1 = TCC1+T2-T1
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB = ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD = ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 1) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 4) = PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,16) = PABCD*DCONJG(RR(N, 1))
        RR(N,13) = PABCD*DCONJG(RR(N, 4))
      ENDDO
C
      IF(ISYM.EQ.1) GOTO 501
      IF(ISYM.EQ.2) GOTO 501
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 3) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 2) =-PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,14) =-PABCD*DCONJG(RR(N, 3))
        RR(N,15) =-PABCD*DCONJG(RR(N, 2))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 9) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 8) =-PABCD*DCONJG(RR(N, 9))
        RR(N, 5) =-PABCD*DCONJG(RR(N,12))
      ENDDO
C
501   CONTINUE
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) =-PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 6) = PABCD*DCONJG(RR(N,11))
        RR(N, 7) = PABCD*DCONJG(RR(N,10))
      ENDDO
C
C     TIME AT END OF SECOND CONTRACTION
      CALL CPU_TIME(T3)
      TCC2 = TCC2+T3-T2
C
C**********************************************************************C
C     COULOMB INTEGRAL BATCH NOW FULLY CONSTRUCTED                     C
C**********************************************************************C
C
C     CALCULATE THE R-INTEGRAL NORMALISATION FACTOR
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.1) THEN
            EKL = EXL(KBAS,3)+EXL(LBAS,4)
            EMX = DSQRT(EIJ+EKL)*EIJ*EKL
            PRE(M) = 2.0D0*PI52/EMX
          ENDIF
        ENDDO
      ENDDO
C
C     INCLUDE THE R-INTEGRAL NORMALISATION FACTOR
      DO N=1,MAXN
        DO ITG=1,16
          RR(N,ITG) = PRE(IMAP(N))*RR(N,ITG)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BII(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN,BGAUNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          BBBBBBB IIII IIII                           C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB  II   II                            C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB IIII IIII                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ XYZ    - FULL SET OF CARTESIAN BASIS CENTRES.                     C
C  ▶ KQN    - FULL SET OF RELATIVISTIC LABELS.                         C
C  ▶ MQN    - FULL SET OF MAGNETIC QUANTUM NUMBERS (MAGNITUDE).        C
C  ▶ NBAS   - FULL SET OF EXPONENT LIST LENGTHS.                       C
C  ▶ EXL    - FULL LISTS OF EXPONENTS IN THE BLOCK.                    C
C  ▶ IBAS   - 1ST BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).       C
C  ▶ JBAS   - 2ND BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).       C
C  ▶ ITN    - COMPONENT OVERLAP COMBINATION.                           C
C  ▶ BGAUNT - GAUNT INTERACTION OVERRIDE OPTION.                       C
C  OUTPUT:                                                             C
C  ▶ RR     - BII'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      LOGICAL L0CASE,BGAUNT
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),T(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MEQ,3),IABI11(MEQ,3),IABR21(MEQ,3),IABI21(MEQ,3)
      DIMENSION ICDR11(MEQ,3),ICDI11(MEQ,3),ICDR21(MEQ,3),ICDI21(MEQ,3)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
      DIMENSION IDX(3),JDX(3)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ,3),EAB21(MB2,MEQ,3),
     &           ECD11(MB2,MEQ,3),ECD21(MB2,MEQ,3)
C
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRW,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRW,TBC1,TBC2,TBMC,
     &            TSMX,TUMX,THMX,TAMX,TC1T,TC2T,TCVT,TB1T,TB2T,TACC,
     &            TEIG,TSCR,TTOT,TC1S,TC2S,TB1S,TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA SENS/1.0D-10/
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.2.AND.ITN(IT).NE.3) THEN
          WRITE(6, *) 'In BII: illegal component overlaps in ITN.'
          WRITE(7, *) 'In BII: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      DO N=1,4
        LQN(N) = LVAL(KQN(N))
      ENDDO
C
C     SPECIAL CASE FOR S-TYPE OVERLAPS (ONLY EVER NEEDED ONCE)
      IF(LQN(1)+LQN(2)+LQN(3)+LQN(4).EQ.0) THEN
        L0CASE = .TRUE.
      ELSE
        L0CASE = .FALSE.
      ENDIF
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC') THEN
        ISYM = 2
      ELSEIF(SHAPE.EQ.'DIATOM'.OR.SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTOR FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR EQ-COEFFICIENTS
      LAMAB = LQN(1)+LQN(2)+1
      LAMCD = LQN(3)+LQN(4)+1
C
C     MCMURCHIE-DAVIDSON MAXIMUM ORDER FOR CONTRACTED R-INTEGRAL BATCH
      IF(BGAUNT) THEN
C       GAUNT INTEGRALS ONLY
        LAMABCD = LAMAB+LAMCD
      ELSE
C       FULL BREIT INTERACTION
        LAMABCD = LAMAB+LAMCD+2
      ENDIF
C
C     MCMURCHIE-DAVIDSON EQ-COEFFICIENT AND R-INTEGRAL LIST LENGTHS
      NTUVAB   = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD   = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
      IF(EQFILE) THEN
C
C       OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
        IF(ITN(1).EQ.2) THEN
          DO ITUV=1,NTUVAB
            IAD = IABLS + (ITUV-1)*MAXAB
            DO M=1,MAXAB
            EAB11(M,ITUV,1) = DCMPLX(EILSFL(IAD+M, 1),EILSFL(IAD+M, 2))
            EAB21(M,ITUV,1) = DCMPLX(EILSFL(IAD+M, 3),EILSFL(IAD+M, 4))
            EAB11(M,ITUV,2) = DCMPLX(EILSFL(IAD+M, 5),EILSFL(IAD+M, 6))
            EAB21(M,ITUV,2) = DCMPLX(EILSFL(IAD+M, 7),EILSFL(IAD+M, 8))
            EAB11(M,ITUV,3) = DCMPLX(EILSFL(IAD+M, 9),EILSFL(IAD+M,10))
            EAB21(M,ITUV,3) = DCMPLX(EILSFL(IAD+M,11),EILSFL(IAD+M,12))
            ENDDO
          ENDDO
        ELSEIF(ITN(1).EQ.3) THEN
          DO ITUV=1,NTUVAB
            IAD = IABSL + (ITUV-1)*MAXAB
            DO M=1,MAXAB
            EAB11(M,ITUV,1) = DCMPLX(EISLFL(IAD+M, 1),EISLFL(IAD+M, 2))
            EAB21(M,ITUV,1) = DCMPLX(EISLFL(IAD+M, 3),EISLFL(IAD+M, 4))
            EAB11(M,ITUV,2) = DCMPLX(EISLFL(IAD+M, 5),EISLFL(IAD+M, 6))
            EAB21(M,ITUV,2) = DCMPLX(EISLFL(IAD+M, 7),EISLFL(IAD+M, 8))
            EAB11(M,ITUV,3) = DCMPLX(EISLFL(IAD+M, 9),EISLFL(IAD+M,10))
            EAB21(M,ITUV,3) = DCMPLX(EISLFL(IAD+M,11),EISLFL(IAD+M,12))
            ENDDO
          ENDDO
        ENDIF
C
      ELSE
C
C       OPTION 2: CALCULATE FROM SCRATCH
        IF(ITN(1).EQ.2) THEN
          CALL EILSB3(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2)
        ELSEIF(ITN(1).EQ.3) THEN
          CALL EISLB3(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2)
        ENDIF
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.2) THEN
        TELS = TELS+TDM2-TDM1
      ELSEIF(ITN(1).EQ.3) THEN
        TESL = TESL+TDM2-TDM1
      ENDIF
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH IAB
      DO ICMP=1,3
        DO IAB=1,NTUVAB
C
C         Re{E(AB|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            ER = DREAL(EAB11(M,IAB,ICMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              IABR11(IAB,ICMP) = 1
              GOTO 101
            ENDIF
          ENDDO
          IABR11(IAB,ICMP) = 0
101       CONTINUE
C
C         Im{E(AB|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            EI = DIMAG(EAB11(M,IAB,ICMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              IABI11(IAB,ICMP) = 1
              GOTO 102
            ENDIF
          ENDDO
          IABI11(IAB,ICMP) = 0
102       CONTINUE
C
C         Re{E(AB|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            ER = DREAL(EAB21(M,IAB,ICMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              IABR21(IAB,ICMP) = 1
              GOTO 103
            ENDIF
          ENDDO
          IABR21(IAB,ICMP) = 0
103       CONTINUE
C
C         Im{E(AB|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            EI = DIMAG(EAB21(M,IAB,ICMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              IABI21(IAB,ICMP) = 1
              GOTO 104
            ENDIF
          ENDDO
          IABI21(IAB,ICMP) = 0
104       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(EQFILE) THEN
        IF(ITN(2).EQ.2) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDLS + (ITUV-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ITUV)))
            DO M=1,MAXCD
            ECD11(M,ITUV,1)=Z*DCMPLX(EILSFL(IAD+M, 1),EILSFL(IAD+M, 2))
            ECD21(M,ITUV,1)=Z*DCMPLX(EILSFL(IAD+M, 3),EILSFL(IAD+M, 4))
            ECD11(M,ITUV,2)=Z*DCMPLX(EILSFL(IAD+M, 5),EILSFL(IAD+M, 6))
            ECD21(M,ITUV,2)=Z*DCMPLX(EILSFL(IAD+M, 7),EILSFL(IAD+M, 8))
            ECD11(M,ITUV,3)=Z*DCMPLX(EILSFL(IAD+M, 9),EILSFL(IAD+M,10))
            ECD21(M,ITUV,3)=Z*DCMPLX(EILSFL(IAD+M,11),EILSFL(IAD+M,12))
            ENDDO
          ENDDO
        ELSEIF(ITN(2).EQ.3) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDSL + (ITUV-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ITUV)))
            DO M=1,MAXCD
            ECD11(M,ITUV,1)=Z*DCMPLX(EISLFL(IAD+M, 1),EISLFL(IAD+M, 2))
            ECD21(M,ITUV,1)=Z*DCMPLX(EISLFL(IAD+M, 3),EISLFL(IAD+M, 4))
            ECD11(M,ITUV,2)=Z*DCMPLX(EISLFL(IAD+M, 5),EISLFL(IAD+M, 6))
            ECD21(M,ITUV,2)=Z*DCMPLX(EISLFL(IAD+M, 7),EISLFL(IAD+M, 8))
            ECD11(M,ITUV,3)=Z*DCMPLX(EISLFL(IAD+M, 9),EISLFL(IAD+M,10))
            ECD21(M,ITUV,3)=Z*DCMPLX(EISLFL(IAD+M,11),EISLFL(IAD+M,12))
            ENDDO
          ENDDO
        ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      ELSE
        IF(ITN(2).EQ.2) THEN
          CALL EILSB3(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4)
        ELSEIF(ITN(2).EQ.3) THEN
          CALL EISLB3(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(2).EQ.2) THEN
        TELS = TELS+TDM2-TDM1
      ELSEIF(ITN(2).EQ.3) THEN
        TESL = TESL+TDM2-TDM1
      ENDIF
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH ICD
      DO JCMP=1,3
        DO ICD=1,NTUVCD
C
C         Re{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            ER = DREAL(ECD11(M,ICD,JCMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              ICDR11(ICD,JCMP) = 1
              GOTO 201
            ENDIF
          ENDDO
          ICDR11(ICD,JCMP) = 0
201       CONTINUE
C
C         Im{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            EI = DIMAG(ECD11(M,ICD,JCMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              ICDI11(ICD,JCMP) = 1
              GOTO 202
            ENDIF
          ENDDO
          ICDI11(ICD,JCMP) = 0
202       CONTINUE
C
C         Re{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            ER = DREAL(ECD21(M,ICD,JCMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              ICDR21(ICD,JCMP) = 1
              GOTO 203
            ENDIF
          ENDDO
          ICDR21(ICD,JCMP) = 0
203       CONTINUE
C
C         Im{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            EI = DIMAG(ECD21(M,ICD,JCMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              ICDI21(ICD,JCMP) = 1
              GOTO 204
            ENDIF
          ENDDO
          ICDI21(ICD,JCMP) = 0
204       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL ASKED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL CPU_TIME(T2)
      TBEC = TBEC+T2-T1
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) INTEGRALS IF PROMPTED            C
C**********************************************************************C
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     GAUSSIAN OVERLAP CENTRE
      PX = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M   = M+1
          EKL = EXL(KBAS,3)+EXL(LBAS,4)
          QX  = (XYZ(1,3)*EXL(KBAS,3)+XYZ(1,4)*EXL(LBAS,4))/EKL
          QY  = (XYZ(2,3)*EXL(KBAS,3)+XYZ(2,4)*EXL(LBAS,4))/EKL
          QZ  = (XYZ(3,3)*EXL(KBAS,3)+XYZ(3,4)*EXL(LBAS,4))/EKL
          PQ(M,1) = QX-PX
          PQ(M,2) = QY-PY
          PQ(M,3) = QZ-PZ
          APH(M)  = EIJ*EKL/(EIJ+EKL)
        ENDDO
      ENDDO
C
C     SKIP IF INTEGRAL BATCH EXISTS IN FILE
      IF(RCFILE.AND.IRIJ(IBAS,JBAS).EQ.0) GOTO 300
C
      CALL CPU_TIME(T1)
C
C     BATCH SIZE AND EXPANSION LENGTH DEPENDS ON MODE
      IF(RCFILE.AND..NOT.L0CASE) THEN
        MBCH = MAXCD
      ELSE
        MBCH = MAXN
      ENDIF
C
C     SHORTEN RMAKE DATA IF POSSIBLE
      IF(ITOG.NE.0) THEN
        IF(.NOT.RCFILE.OR.L0CASE) THEN
          DO N=1,MAXN
            PQ(N,1) = PQ(IMAP(N),1)
            PQ(N,2) = PQ(IMAP(N),2)
            PQ(N,3) = PQ(IMAP(N),3)
            APH(N)  = APH(IMAP(N))
          ENDDO
        ENDIF
      ENDIF
C
C     GENERATE R-INTEGRALS
      CALL RMAKE(RC,PQ,APH,MBCH,LAMABCD)
C
C     SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
      DO IABCD=1,NTUVABCD
C
C       SUM OF RC(AB|CD) MAGNITUDES
        SUM = 0.0D0
        DO N=1,MBCH
          SUM = SUM + DABS(RC(N,IABCD))
          IF(SUM.GT.SENS) THEN
            IRC(IABCD) = 1
            GOTO 301
          ENDIF
        ENDDO
        IRC(IABCD) = 0
301     CONTINUE
C
      ENDDO
C
      CALL CPU_TIME(T2)
      TBRM = TBRM+T2-T1
C
C     CONTINUE ONLY IF INTEGRALS ARE TO BE SAVED TO LARGE FILE
      IF(.NOT.RCFILE.OR.L0CASE) GOTO 300
C
      CALL CPU_TIME(T3)
C
C     TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
      IF(20*MFL.LT.IJ*MAXCD*NTUVABCD) THEN
C       OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
        WRITE(6, *) 'In BII: RCTT words exceed allocated limit.'
        WRITE(7, *) 'In BII: RCTT words exceed allocated limit.'
        GOTO 300
      ELSE
C       DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
        IRIJ(IBAS,JBAS) = 0
      ENDIF
C
C     STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
      IADRTT = (IJ-1)*MAXCD*NTUVABCD
C
C     COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
      DO IABCD=1,NTUVABCD
        IAD = IADRTT + MAXCD*(IABCD-1)
        DO M=1,MAXCD
          RCTTFL(IAD+M) = RC(M,IABCD)
        ENDDO
      ENDDO
C
C     STARTING ADDRESS FOR SCREENING FLAGS
      IADSCR = (IJ-1)*NTUVABCD
C
C     COPY SCREENING MARKERS TO A SAVED LIST
      DO IABCD=1,NTUVABCD
        IRCTTFL(IADSCR+IABCD) = IRC(IABCD)
      ENDDO
C
      CALL CPU_TIME(T4)
      TBRW = TBRW+T4-T3
C
300   CONTINUE
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL CPU_TIME(TDM2)
      TRBR = TRBR+TDM2-TDM1
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     LOOP OVER CARTESIAN INDEX ICMP FOR CENTRE AB (USE INDEX 6000)
      DO 6000 ICMP=1,3
C
C     TIME AT START OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T1I)
C
C     CARTESIAN INDEX ICMP AS A VECTOR, IDX
      CALL NCART(IDX,ICMP)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) PASSES SCREENING CONDITION
        IABALL = IABR11(IAB,ICMP)+IABI11(IAB,ICMP)+IABR21(IAB,ICMP)
     &                                            +IABI21(IAB,ICMP)
        IF(IABALL.EQ.0) GOTO 401
C
C >>>>> GAUNT INTERACTION
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO ICD=1,NTUVCD
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),IC(IAB)+IC(ICD))
C
C         CALCULATE DIRECTLY FROM RC(AB|CD) LOCAL ARRAY
          IF(.NOT.RCFILE.OR.L0CASE) THEN
C
C           SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
            IF(IRC(IRABCD).EQ.0) GOTO 402
C
C           SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
            ICDALL = ICDR11(ICD,ICMP)+ICDI11(ICD,ICMP)+ICDR21(ICD,ICMP)
     &                                                +ICDI21(ICD,ICMP)
            IF(ICDALL.EQ.0) GOTO 402
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 411
            IF(ISYM.EQ.2.AND.IABR11(IAB,ICMP).EQ.0) GOTO 411
            IF(ICDR11(ICD,ICMP).EQ.1) THEN
              DO N=1,MAXN
                GABR11(N,IAB) = GABR11(N,IAB)
     &                    + DREAL(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
              ENDDO
            ENDIF
411         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 412
            IF(ISYM.EQ.2.AND.IABI11(IAB,ICMP).EQ.0) GOTO 412
            IF(ICDI11(ICD,ICMP).EQ.1) THEN
              DO N=1,MAXN
                GABI11(N,IAB) = GABI11(N,IAB)
     &                    + DIMAG(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
              ENDDO
            ENDIF
412         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 413
            IF(ISYM.EQ.2.AND.IABR21(IAB,ICMP).EQ.0) GOTO 413
            IF(ICDR21(ICD,ICMP).EQ.1) THEN
              DO N=1,MAXN
                GABR21(N,IAB) = GABR21(N,IAB)
     &                    + DREAL(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
              ENDDO
            ENDIF
413         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 414
            IF(ISYM.EQ.2.AND.IABI21(IAB,ICMP).EQ.0) GOTO 414
            IF(ICDI21(ICD,ICMP).EQ.1) THEN
              DO N=1,MAXN
                GABI21(N,IAB) = GABI21(N,IAB)
     &                    + DIMAG(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
              ENDDO
            ENDIF
414         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) AND E(CD) SCREENING
402         CONTINUE
C
          ELSE
C
C           STARTING ADDRESS FOR THIS BATCH OF SAVED R(AB|CD) INTEGRALS
            IAD = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IRABCD-1)
C
C           SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
            IF(IRCTTFL((IJ-1)*NTUVABCD+IRABCD).EQ.0) GOTO 462
C
C           SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
            ICDALL = ICDR11(ICD,ICMP)+ICDI11(ICD,ICMP)+ICDR21(ICD,ICMP)
     &                                                +ICDI21(ICD,ICMP)
            IF(ICDALL.EQ.0) GOTO 462
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 451
            IF(ISYM.EQ.2.AND.IABR11(IAB,ICMP).EQ.0) GOTO 451
            IF(ICDR11(ICD,ICMP).EQ.1) THEN
              DO N=1,MAXN
                GABR11(N,IAB) = GABR11(N,IAB)
     &             + DREAL(ECD11(IMAP(N),ICD,ICMP))*RCTTFL(IAD+IMAP(N))
              ENDDO
            ENDIF
451         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 452
            IF(ISYM.EQ.2.AND.IABI11(IAB,ICMP).EQ.0) GOTO 452
            IF(ICDI11(ICD,ICMP).EQ.1) THEN
              DO N=1,MAXN
                GABI11(N,IAB) = GABI11(N,IAB)
     &             + DIMAG(ECD11(IMAP(N),ICD,ICMP))*RCTTFL(IAD+IMAP(N))
              ENDDO
            ENDIF
452         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 453
            IF(ISYM.EQ.2.AND.IABR21(IAB,ICMP).EQ.0) GOTO 453
            IF(ICDR21(ICD,ICMP).EQ.1) THEN
              DO N=1,MAXN
                GABR21(N,IAB) = GABR21(N,IAB)
     &             + DREAL(ECD21(IMAP(N),ICD,ICMP))*RCTTFL(IAD+IMAP(N))
              ENDDO
            ENDIF
453         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 454
            IF(ISYM.EQ.2.AND.IABI21(IAB,ICMP).EQ.0) GOTO 454
            IF(ICDI21(ICD,ICMP).EQ.1) THEN
              DO N=1,MAXN
                GABI21(N,IAB) = GABI21(N,IAB)
     &             + DIMAG(ECD21(IMAP(N),ICD,ICMP))*RCTTFL(IAD+IMAP(N))
              ENDDO
            ENDIF
454         CONTINUE
C
C           SKIP POINT FOR RC(AB|CD) AND E(CD) SCREENING
462         CONTINUE
C
          ENDIF
C
C >>>>>   GAUGE TERM (REQUIRES ADDITIONAL CARTESIAN SUM Q')
          IF(BGAUNT) GOTO 480
C
C         LOOP OVER CARTESIAN INDEX JCMP FOR CENTRE CD
          DO JCMP=1,3
C
C           SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
            IF(ICDR11(ICD,JCMP)+ICDI11(ICD,JCMP)
     &                    +ICDR21(ICD,JCMP)+ICDI21(ICD,JCMP).EQ.0) THEN
              GOTO 403
            ENDIF
C
C           CARTESIAN INDEX JCMP AS A VECTOR, JDX
            CALL NCART(JDX,JCMP)
C
C           NEW ADDRESS DEPENDING ON JCMP CARTESIAN INDEX
            IF(JCMP.EQ.1) THEN
              RTP = DFLOAT(IA(IAB)+IA(ICD))
            ELSEIF(JCMP.EQ.2) THEN
              RTP = DFLOAT(IB(IAB)+IB(ICD))
            ELSEIF(JCMP.EQ.3) THEN
              RTP = DFLOAT(IC(IAB)+IC(ICD))
            ENDIF
C
C           FIRST CONTRIBUTION ADDRESS
            I1 = IA(IAB)+IA(ICD)+IDX(1)+JDX(1)
            J1 = IB(IAB)+IB(ICD)+IDX(2)+JDX(2)
            K1 = IC(IAB)+IC(ICD)+IDX(3)+JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR1 = IABC(I1,J1,K1)
C
C           SECOND CONTRIBUTION ADDRESS
            I2 = IA(IAB)+IA(ICD)+IDX(1)
            J2 = IB(IAB)+IB(ICD)+IDX(2)
            K2 = IC(IAB)+IC(ICD)+IDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR2 = IABC(I2,J2,K2)
C
C           THIRD CONTRIBUTION ADDRESS
            I3 = IA(IAB)+IA(ICD)+IDX(1)-JDX(1)
            J3 = IB(IAB)+IB(ICD)+IDX(2)-JDX(2)
            K3 = IC(IAB)+IC(ICD)+IDX(3)-JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
              IADR3 = IABC(I3,J3,K3)
            ELSE
              IADR3 = 0
            ENDIF
C
C           CALCULATE DIRECTLY FROM RC(AB|CD) LOCAL ARRAY
            IF(.NOT.RCFILE.OR.L0CASE) THEN
C
C             SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
              IF(IADR3.NE.0) THEN
                IF(IRC(IADR1)+IRC(IADR2)+IRC(IADR3).EQ.0) GOTO 403
              ELSE
                IF(IRC(IADR1)+IRC(IADR2).EQ.0) GOTO 403
              ENDIF
C
C             PRE-FACTORS FOR THE UPCOMING CONTRACTION
              DO N=1,MAXN
                T1 = RC(N,IADR1)*0.5D0/APH(N)
                T2 = RC(N,IADR2)*PQ(N,JCMP)
                IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
                  T3 = RC(N,IADR3)*RTP
                ELSE
                  T3 = 0.0D0
                ENDIF
                T(N) = T1-T2+T3
              ENDDO
C
            ELSE
C
C             SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
              IA1 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR1-1)
              IA2 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR2-1)
              IA3 = (IJ-1)*MAXCD*NTUVABCD + MAXCD*(IADR3-1)
              IF(IADR3.NE.0) THEN
                IF(IA1+IA2+IA3.EQ.0) GOTO 403
              ELSE
                IF(IA1+IA2.EQ.0) GOTO 403
              ENDIF
C
C             PRE-FACTORS FOR THE UPCOMING CONTRACTION
              DO N=1,MAXN
                T1 = RCTTFL(IA1+IMAP(N))*0.5D0/APH(IMAP(N))
                T2 = RCTTFL(IA2+IMAP(N))*PQ(IMAP(N),JCMP)
                IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
                  T3 = RCTTFL(IA3+IMAP(N))*RTP
                ELSE
                  T3 = 0.0D0
                ENDIF
                T(N) = T1-T2+T3
              ENDDO
C
            ENDIF
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 415
            IF(ISYM.EQ.2.AND.IABR11(IAB,ICMP).EQ.0) GOTO 415
            IF(ICDR11(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABR11(N,IAB) = GABR11(N,IAB)
     &                            - DREAL(ECD11(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
415         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 416
            IF(ISYM.EQ.2.AND.IABI11(IAB,ICMP).EQ.0) GOTO 416
            IF(ICDI11(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABI11(N,IAB) = GABI11(N,IAB)
     &                            - DIMAG(ECD11(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
416         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 417
            IF(ISYM.EQ.2.AND.IABR21(IAB,ICMP).EQ.0) GOTO 417
            IF(ICDR21(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABR21(N,IAB) = GABR21(N,IAB)
     &                            - DREAL(ECD21(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
417         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 418
            IF(ISYM.EQ.2.AND.IABI21(IAB,ICMP).EQ.0) GOTO 418
            IF(ICDI21(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABI21(N,IAB) = GABI21(N,IAB)
     &                            - DIMAG(ECD21(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
418         CONTINUE
C
C           SKIP POINT FOR E(CD) SCREENING
403         CONTINUE
C
C           END LOOP OVER CARTESIAN INDEX JCMP FOR CENTRE CD
            ENDDO
C
C           SKIP POINT FOR GAUNT INTERACTION ONLY
480         CONTINUE
C
C         END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
          ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T1F)
      TBC1 = TBC1+T1F-T1I
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB =-ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD =-ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,1 ) = RR(N,1 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,4 ) = RR(N,4 ) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
      IF(ISYM.EQ.1) GOTO 501
      IF(ISYM.EQ.2) GOTO 501
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,3 ) = RR(N,3 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,2 ) = RR(N,2 ) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,9 ) = RR(N,9 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = RR(N,12) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
501   CONTINUE
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) = RR(N,11) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) = RR(N,10) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     TIME AT END OF SECOND CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T2F)
      TBC2 = TBC2+T2F-T1F
C
C     END LOOP OVER CARTESIAN INDICES {IX,IY,IZ}
6000  CONTINUE
C
C     HALF OF THE RR ARRAY CAN BE GENERATED WITH PHASE RELATIONS
      DO N=1,MAXN
        RR(N,16) = PABCD*DCONJG(RR(N,1 ))
        RR(N,13) = PABCD*DCONJG(RR(N,4 ))
        RR(N,14) =-PABCD*DCONJG(RR(N,3 ))
        RR(N,15) =-PABCD*DCONJG(RR(N,2 ))
        RR(N,8 ) =-PABCD*DCONJG(RR(N,9 ))
        RR(N,5 ) =-PABCD*DCONJG(RR(N,12))
        RR(N,6 ) = PABCD*DCONJG(RR(N,11))
        RR(N,7 ) = PABCD*DCONJG(RR(N,10))
      ENDDO     
C
C**********************************************************************C
C     BREIT INTEGRAL BATCH NOW FULLY CONSTRUCTED                       C
C**********************************************************************C
C
C     CALCULATE THE R-INTEGRAL NORMALISATION FACTOR
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.1) THEN
            EKL = EXL(KBAS,3)+EXL(LBAS,4)
            EMX = DSQRT(EIJ+EKL)*EIJ*EKL
            PRE(M) = 2.0D0*PI52/EMX
          ENDIF
        ENDDO
      ENDDO
C
C     INCLUDE THE OUTSIDE FACTOR OF (-1/2) AND MOVE TO FULL ARRAY
      DO N=1,MAXN
        DO ITG=1,16
          RR(N,ITG) =-0.5D0*PRE(IMAP(N))*RR(N,ITG)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE NCART(IVECT,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             NN    NN  CCCCCC     AA    RRRRRRR TTTTTTTT              C
C             NNN   NN CC    CC   AAAA   RR    RR   TT                 C
C             NNNN  NN CC        AA  AA  RR    RR   TT                 C
C             NN NN NN CC       AA    AA RR    RR   TT                 C
C             NN  NNNN CC       AAAAAAAA RRRRRRR    TT                 C
C             NN   NNN CC    CC AA    AA RR    RR   TT                 C
C             NN    NN  CCCCCC  AA    AA RR    RR   TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCART RETURNS THE CARTESIAN INDEX FROM THE INDEX VALUE IND.         C
C**********************************************************************C
C
      DIMENSION IVECT(3)
C
      IF(IND.EQ.1) THEN
        IVECT(1) = 1
        IVECT(2) = 0
        IVECT(3) = 0
      ELSEIF(IND.EQ.2) THEN
        IVECT(1) = 0
        IVECT(2) = 1
        IVECT(3) = 0
      ELSEIF(IND.EQ.3) THEN
        IVECT(1) = 0
        IVECT(2) = 0
        IVECT(3) = 1
      ELSE
        WRITE(6, *) 'In NCART: supplied index not valid',IND
        WRITE(7, *) 'In NCART: supplied index not valid',IND
        RETURN
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        NN    NN  CCCCCC  NN    NN TTTTTTTT RRRRRRR   SSSSSS          C
C        NNN   NN CC    CC NNN   NN    TT    RR    RR SS    SS         C
C        NNNN  NN CC       NNNN  NN    TT    RR    RR SS               C
C        NN NN NN CC       NN NN NN    TT    RR    RR  SSSSSS          C
C        NN  NNNN CC       NN  NNNN    TT    RRRRRRR        SS         C
C        NN   NNN CC    CC NN   NNN    TT    RR    RR SS    SS         C
C        NN    NN  CCCCCC  NN    NN    TT    RR    RR  SSSSSS          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCNTRS RETURNS NUMBER OF UNIQUE NUCLEAR CENTRES FROM INPUT VALUES.  C
C**********************************************************************C
C
C     STORE ICNTA IN FIRST PLACE
      NCNTRS = 1
C
C     CHECK ICNTB AGAINST STORED VALUES
      IF(ICNTB.NE.ICNTA) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTC AGAINST STORED VALUES
      IF(ICNTC.NE.ICNTA.AND.ICNTC.NE.ICNTB) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTD AGAINST STORED VALUES
      IF(ICNTD.NE.ICNTA.AND.ICNTD.NE.ICNTB.AND.ICNTD.NE.ICNTC) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ZPROJ(XYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            ZZZZZZZZ PPPPPPP  RRRRRRR   OOOOOO     JJJJJJ             C
C                 ZZ  PP    PP RR    RR OO    OO       JJ              C
C                ZZ   PP    PP RR    RR OO    OO       JJ              C
C               ZZ    PP    PP RR    RR OO    OO       JJ              C
C              ZZ     PPPPPPP  RRRRRRR  OO    OO       JJ              C
C             ZZ      PP       RR    RR OO    OO JJ    JJ              C
C            ZZZZZZZZ PP       RR    RR  OOOOOO   JJJJJJ               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZPROJ RETURNS THE SUM OF ABSOLUTE DIFFERENCES BETWEEN X AND Y       C
C  LOCATIONS OF FOUR SUPPLIED COORDINATES.                             C
C**********************************************************************C
C
       DIMENSION XYZ(3,4)
C
       ZPROJ = 0.0D0
C
       DO IX=1,2
         DO M=1,3
           DO N=M+1,4
             ZPROJ = ZPROJ + DABS(XYZ(IX,M)-XYZ(IX,N))
           ENDDO
         ENDDO
       ENDDO
C
       RETURN
       END
C
C
      FUNCTION LVAL(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                  LL      VV    VV    AA    LL                        C
C                  LL      VV    VV   AAAA   LL                        C
C                  LL      VV    VV  AA  AA  LL                        C
C                  LL      VV    VV AA    AA LL                        C
C                  LL       VV  VV  AAAAAAAA LL                        C
C                  LL        VVVV   AA    AA LL                        C
C                  LLLLLLLL   VV    AA    AA LLLLLLLL                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  LVAL RETURNS THE LQN FROM A KQN VALUE.                              C
C**********************************************************************C
C
      IF(KQN.LT.0) THEN
        LVAL =-KQN-1
      ELSE
        LVAL = KQN
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION LLAB(LQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 LL       LL          AA    BBBBBBB                   C
C                 LL       LL         AAAA   BB    BB                  C
C                 LL       LL        AA  AA  BB    BB                  C
C                 LL       LL       AA    AA BBBBBBB                   C
C                 LL       LL       AAAAAAAA BB    BB                  C
C                 LL       LL       AA    AA BB    BB                  C
C                 LLLLLLLL LLLLLLLL AA    AA BBBBBBB                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  LLAB RETURNS THE CONVENTIONAL ATOMIC ORBITAL TYPE LABEL FOR THE     C
C  NON-RELATIVISTIC QUANTUM NUMBER LQN OF LENGTH 1.                    C
C**********************************************************************C
C
      CHARACTER*1 LLAB
C
      IF(LQN.EQ.0) THEN
        LLAB = 's'
      ELSEIF(LQN.EQ.1) THEN
        LLAB = 'p'
      ELSEIF(LQN.EQ.2) THEN
        LLAB = 'd'
      ELSEIF(LQN.EQ.3) THEN
        LLAB = 'f'
      ELSEIF(LQN.EQ.4) THEN
        LLAB = 'g'
      ELSEIF(LQN.EQ.5) THEN
        LLAB = 'h'
      ELSEIF(LQN.EQ.6) THEN
        LLAB = 'i'
      ELSEIF(LQN.EQ.7) THEN
        LLAB = 'j'
      ELSEIF(LQN.EQ.8) THEN
        LLAB = 'k'
      ELSEIF(LQN.EQ.9) THEN
        LLAB = 'l'
      ELSEIF(LQN.EQ.10) THEN
        LLAB = 'm'
      ELSEIF(LQN.EQ.11) THEN
        LLAB = 'n'
      ELSEIF(LQN.EQ.12) THEN
        LLAB = 'o'
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION KLAB(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 KK    KK LL          AA    BBBBBBB                   C
C                 KK   KK  LL         AAAA   BB    BB                  C
C                 KK  KK   LL        AA  AA  BB    BB                  C
C                 KKKKK    LL       AA    AA BBBBBBB                   C
C                 KK  KK   LL       AAAAAAAA BB    BB                  C
C                 KK   KK  LL       AA    AA BB    BB                  C
C                 KK    KK LLLLLLLL AA    AA BBBBBBB                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLAB RETURNS THE CONVENTIONAL SYMMETRY TYPE LABEL FOR DIRAC         C
C  ORBITAL TYPE KQN AS A STRING OF LENGTH 2.                           C
C**********************************************************************C
C
      CHARACTER*1 LLAB,CHS
      CHARACTER*2 KLAB
C
      LQN = LVAL(KQN)
C
      IF(KQN.EQ.-1) THEN
        CHS = ' '
      ELSEIF(KQN.LT.0) THEN
        CHS = '-'
      ELSE
        CHS = '+'
      ENDIF
C
C     STITCH TOGETHER THE LQN TITLE AND THE PARITY LABEL
      WRITE(KLAB,'(A,A)') LLAB(LQN),CHS
C
      RETURN
      END
C
C
      FUNCTION MLAB(MQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                MM       MM LL          AA    BBBBBBB                 C
C                MMM     MMM LL         AAAA   BB    BB                C
C                MMMM   MMMM LL        AA  AA  BB    BB                C
C                MM MM MM MM LL       AA    AA BBBBBBB                 C
C                MM  MMM  MM LL       AAAAAAAA BB    BB                C
C                MM   M   MM LL       AA    AA BB    BB                C
C                MM       MM LLLLLLLL AA    AA BBBBBBB                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  MLAB RETURNS THE CONVENTIONAL SYMMETRY TYPE LABEL FOR DIRAC         C
C  MAGNETIC NUMBER MQN AS A STRING OF LENGTH 5.                        C
C**********************************************************************C
C
       CHARACTER*1 CHS
       CHARACTER*5 MLAB
C
       IF(MOD(MQN,2).EQ.0) THEN
         CHS = '+'
       ELSE
         CHS = '-'
       ENDIF
C
C      ODD INTEGER FOR NUMERATOR
       MAG = MQN-MOD(MQN+1,2)
C
C      STITCH TOGETHER THE MQN TITLE
       IF(MAG.LT.10) THEN
         WRITE(MLAB,'(A,I1,A)') CHS,MAG,'/2 '
       ELSE
         WRITE(MLAB,'(A,I2,A)') CHS,MAG,'/2'
       ENDIF
C
       RETURN
       END
C
C
C**********************************************************************C
C ==================================================================== C
C   [4] ATOMIC HARTREE-FOCK: SINGLE-CENTRE SCF CALCULATIONS.           C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] ERFINT0: INTEGRAL OVER A GAUSSIAN AND ERROR FUNCTION.          C
C   [N] GAMLWR: LOWER INCOMPLETE GAMMA FUNCTION gamma(A,X).            C
C**********************************************************************C
C
C
      FUNCTION ERFINT0(L,EIJ,ZTA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE RRRRRRR  FFFFFFFF IIII NN    NN TTTTTTTT 000000        C
C      EE       RR    RR FF        II  NNN   NN    TT   00   000       C
C      EE       RR    RR FF        II  NNNN  NN    TT   00  0000       C
C      EEEEEE   RR    RR FFFFFF    II  NN NN NN    TT   00 00 00       C
C      EE       RRRRRRR  FF        II  NN  NNNN    TT   0000  00       C
C      EE       RR    RR FF        II  NN   NNN    TT   000   00       C
C      EEEEEEEE RR    RR FF       IIII NN    NN    TT    000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERFINT0 CALCULATES THE VALUE OF AN INTEGRAL OVER A GAUSSIAN WITH    C
C  EXPONENT EIJ, AN ERROR FUNCTION WITH NUCLEAR WIDTH PARAMETER ZTA    C
C  AND AN ODD POLYNOMIAL ORDER, 2L+1. SUPPORTS UP TO RELATIVISTIC L=9. C
C                           ∞                                          C
C          ERFINT(L,λ,ζ) = ∫ r^2L+1 exp(-λ r^2) erf(√ζ r) dr.          C
C                           0                                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
C     ROUTINE ONLY ALLOWS NON-NEGATIVE INTEGER L
      IF(L.LT.0) THEN
        WRITE(6, *) 'In ERFINT0: order L must be positive. L = ',L
        WRITE(7, *) 'In ERFINT0: order L must be positive. L = ',L
        STOP
      ENDIF
C
C     FACTORS NEEDED FOR ALL PARAMETERS L
      X   = EIJ/ZTA
      X5  = X*X*X*X*X
      T0  = ZTA+EIJ
      RAT = ZTA/T0
      TRM = 0.5D0*DSQRT(ZTA)/EIJ/DSQRT(T0)
      DO I=1,L
        TRM = 0.5D0*TRM*RAT/EIJ
      ENDDO
C
      IF(L.EQ.0) THEN
        TRM = TRM
      ELSEIF(L.EQ.1) THEN
        VA  = 2.0D0 + 3.0D0*X
        TRM = TRM*VA
      ELSEIF(L.EQ.2) THEN
        VA  = 8.0D0 + 20.0D0*X + 15.0D0*X*X
        TRM = TRM*VA
      ELSEIF(L.EQ.3) THEN
        VA  = 16.0D0 + 56.0D0*X + 70.0D0*X*X + 35.0D0*X*X*X
        TRM = 3.0D0*TRM*VA
      ELSEIF(L.EQ.4) THEN
        VA  = 128.0D0 + 576.0D0*X + 1008.0D0*X*X + 840.0D0*X*X*X
        VB  = 315.0D0*X*X*X*X
        TRM = 3.0D0*TRM*(VA+VB)
      ELSEIF(L.EQ.5) THEN
        VA  = 256.0D0 + 1408.0D0*X + 3168.0D0*X*X + 3696.0D0*X*X*X
        VB  = 2310.0D0*X*X*X*X + 693.0D0*X*X*X*X*X
        TRM = 15.0D0*TRM*(VA+VB)
      ELSEIF(L.EQ.6) THEN
        VA  = 1024.0D0 + 6656.0D0*X + 18304.0D0*X*X
        VB  = 27456.0D0*X*X*X + 24024.0D0*X*X*X*X
        VC  = 12012.0D0*X5 + 3003.0D0*X5*X
        TRM = 45.0D0*TRM*(VA+VB+VC)
      ELSEIF(L.EQ.7) THEN
        VA  = 2048.0D0 + 15360.0D0*X + 49920.0D0*X*X
        VB  = 91520.0D0*X*X*X+ 102960.0D0*X*X*X*X + 72072.0D0*X5
        VC  = 30030.0D0*X5*X + 6435.0D0*X5*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC)
      ELSEIF(L.EQ.8) THEN
        VA  = 32768.0D0 + 278528.0D0*X + 1044480.0D0*X*X
        VB  = 2263040.0D0*X*X*X + 3111680.0D0*X*X*X*X
        VC  = 2800512.0D0*X5 + 1633632.0D0*X5*X + 583440.0D0*X5*X*X
        VD  = 109395.0D0*X5*X*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(L.EQ.9) THEN
        VA  = 65536.0D0 + 6222592.0D0*X + 2646016.0D0*X*X
        VB  = 6615040.0D0*X*X*X + 10749440.0D0*X*X*X*X
        VC  = 11824384.0D0*X5 + 8868288.0D0*X5*X + 4434144.0D0*X5*X*X
        VD  = 1385670.0D0*X5*X*X*X + 230945.0D0*X5*X*X*X*X
        TRM = 2835.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(L.EQ.10) THEN
        VA  = 262144.0D0 + 2752512.0D0*X + 13074432.0D0*X*X
        VB  = 37044224.0D0*X*X*X + 69457920.0D0*X*X*X*X
        VC  = 90295296.0D0*X5 + 82770688.0D0*X5*X
        VD  = 53209728.0D0*X5*X*X + 23279256.0D0*X5*X*X*X
        VE  = 6466460.0D0*X5*X*X*X*X + 969969.0D0*X5*X5
        TRM = 14175.0D0*TRM*(VA+VB+VC+VD+VE)
      ELSE
        WRITE(6, *) 'In ERFINT0: order L too large. L = ',L
        WRITE(7, *) 'In ERFINT0: order L too large. L = ',L
      ENDIF
C
C     TRANSFER DATA TO ERFINT0
      ERFINT0 = TRM
C
      RETURN
      END
C
C
      FUNCTION GAMUPR(L,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG     AA    MM       MM UU    UU PPPPPPP  RRRRRRR        C
C       GG    GG   AAAA   MMM     MMM UU    UU PP    PP RR    RR       C
C       GG        AA  AA  MMMM   MMMM UU    UU PP    PP RR    RR       C
C       GG       AA    AA MM MM MM MM UU    UU PP    PP RR    RR       C
C       GG   GGG AAAAAAAA MM  MMM  MM UU    UU PPPPPPP  RRRRRRR        C
C       GG    GG AA    AA MM   M   MM UU    UU PP       RR    RR       C
C        GGGGGG  AA    AA MM       MM  UUUUUU  PP       RR    RR       C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMUPR RETURNS THE UPPER INCOMPLETE GAMMA FUNCTION FOR INTEGER OR   C
C  HALF-INTEGER ARGUMENTS. INPUT L IS TWICE THE ACTUAL ARGUMENT.       C
C  SOLUTIONS ARE FINITE AND ALGEBRAIC -- NO APPROXIMATIONS NEEDED.     C
C  NECESSARY -- AN ALGEBRAIC SOLUTION HAS BEEN DEDUCED.                C
C                                                                      C
C                GAMUPR(ℓ,x) = Γ(ℓ/2,x) with ℓ>0 and x>0.              C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PIM(L)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     ROUTINE ONLY ALLOWS PARAMETERS L>0
      IF(L.LT.1) THEN
        WRITE(6, *) 'In GAMUPR: order L must be at least 1. L = ',L
        WRITE(7, *) 'In GAMUPR: order L must be at least 1. L = ',L
        STOP
      ENDIF
C
C     INTEGER ARGUMENTS L
      IF(MOD(L,2).EQ.0) THEN
C
C       EXPONENTIAL FACTOR
        FC1 = DEXP(-X)
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-2)/2
          POLY = POLY + XPOW*RFACT((L-2)/2)/RFACT(I)
          XPOW = XPOW*X
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMUPR = FC1*POLY
C
      ELSE
C
C       FACTORS REQUIRED FOR ALL ORDERS
        X12 = DSQRT(X)
        FC1 = PI12*(1.0D0-DERF(X12))
        FC2 = DEXP(-X)*X12
C
C       POCHHAMMER SYMBOL
        P32 = 1.0D0
        DO K=0,(L-3)/2
          P32 = P32*(0.5D0+DFLOAT(K))
        ENDDO
C
C       FACTOR FOR EACH POWER TERM
        LST = (L-1)/2
        IF(LST.GT.0) THEN
          PSD = 1.0D0
          DO I=1,LST
            PIM(I) = PSD
            PSD    = 0.5D0*PSD*DFLOAT(L-2*I)
          ENDDO
        ENDIF
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-3)/2
C
          POLY = POLY + XPOW*PIM(LST-I)
          XPOW = XPOW*X
C
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMUPR = P32*FC1 + POLY*FC2
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION GAMLWR(L,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      GGGGGG     AA    MM       MM LL       WW        WW RRRRRRR      C
C     GG    GG   AAAA   MMM     MMM LL       WW        WW RR    RR     C
C     GG        AA  AA  MMMM   MMMM LL       WW   WW   WW RR    RR     C
C     GG       AA    AA MM MM MM MM LL       WW  WWWW  WW RR    RR     C
C     GG   GGG AAAAAAAA MM  MMM  MM LL       WW WW  WW WW RRRRRRR      C
C     GG    GG AA    AA MM   M   MM LL       WWWW    WWWW RR    RR     C
C      GGGGGG  AA    AA MM       MM LLLLLLLL WW        WW RR    RR     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMLWR RETURNS THE LOWER INCOMPLETE GAMMA FUNCTION FOR INTEGER OR   C
C  HALF-INTEGER ARGUMENTS. INPUT L IS TWICE THE ACTUAL ARGUMENT.       C
C  SOLUTIONS ARE FINITE AND ALGEBRAIC -- NO APPROXIMATIONS NEEDED.     C
C                                                                      C
C                GAMLWR(ℓ,x) = γ(ℓ/2,x) with ℓ>0 and x>0.              C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PIM(L)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     ROUTINE ONLY ALLOWS PARAMETERS L>0
      IF(L.LT.1) THEN
        WRITE(6, *) 'In GAMLWR: order L must be at least 1. L = ',L
        WRITE(7, *) 'In GAMLWR: order L must be at least 1. L = ',L
        STOP
      ENDIF
C
C     INTEGER ARGUMENTS L
      IF(MOD(L,2).EQ.0) THEN
C
C       EXPONENTIAL FACTOR
        FC1 = DEXP(-X)
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-2)/2
          POLY = POLY + XPOW*RFACT((L-2)/2)/RFACT(I)
          XPOW = XPOW*X
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMLWR = RFACT((L-2)/2) - FC1*POLY
C
      ELSE
C
C       FACTORS REQUIRED FOR ALL ORDERS
        X12 = DSQRT(X)
        FC1 = PI12*DERF(X12)
        FC2 = DEXP(-X)*X12
C
C       POCHHAMMER SYMBOL
        P32 = 1.0D0
        DO K=0,(L-3)/2
          P32 = P32*(0.5D0+DFLOAT(K))
        ENDDO
C
C       FACTOR FOR EACH POWER TERM
        LST = (L-1)/2
        IF(LST.GT.0) THEN
          PSD = 1.0D0
          DO I=1,LST
            PIM(I) = PSD
            PSD    = 0.5D0*PSD*DFLOAT(L-2*I)
          ENDDO
        ENDIF
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-3)/2
C
          POLY = POLY + XPOW*PIM(LST-I)
          XPOW = XPOW*X
C
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMLWR = P32*FC1 - POLY*FC2
C
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [6] ONE-CENTRE ROUTINES: ATOMIC INTEGRALS FOR MOLECULAR PURPOSES.  C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [E] SYM3J: EVALUATES A WIGNER 3J-SYMBOL.                           C
C**********************************************************************C
C
C
      FUNCTION SYM3J(JA,L,JB,MA,M,MB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            SSSSSS  YY    YY MM       MM  333333      JJJJJ           C
C           SS    SS YY    YY MMM     MMM 33    33       JJ            C
C           SS       YY    YY MMMM   MMMM       33       JJ            C
C            SSSSSS   YY  YY  MM MM MM MM    3333        JJ            C
C                 SS   YYYY   MM  MMM  MM       33       JJ            C
C           SS    SS    YY    MM   M   MM  33   33 JJ    JJ            C
C            SSSSSS     YY    MM       MM   33333   JJJJJJ             C
C                                                                      C
C -------------------------------------------------------------------- C
C  SYM3J EVALUATES A WIGNER 3-J SYMBOL,               / j  L  j'\      C
C  WHERE j=JA/2, j'=JB/2, m=MA/2 AND m'=MB/2,         \ m  M  m'/      C
C  BUT L AND M ARE THE ACTUAL VALUES. (BRINK AND SATCHLER {2.34}.)     C
C**********************************************************************C
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(IABS(M).GT.L) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(2*M+MA+MB.NE.0) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(IABS(MA).GT.JA.OR.IABS(MB).GT.JB) THEN
        SYM3J = 0.0D0
        RETURN
      ENDIF
C
C     OVERALL PHASE FACTOR (CONVERSION FROM CG-COEFF TO 3J-SYMBOL)
      IPS = (JA-MB)/2 - L
      PHS = DFLOAT((-1)**(IPS))
C
C     SYMMETRIC FACTOR INVOLVING VERTICAL PAIRS (j,m), (L,M), (j',m')
      SM1 = RFACT((JA+MA)/2)
      SM2 = RFACT((JA-MA)/2)
      SM3 = RFACT((JB-MB)/2)
      SM4 = RFACT((JB+MB)/2)
      SM5 = RFACT(  L +M   )
      SM6 = RFACT(  L -M   )
      SYM = DSQRT(SM1*SM2*SM3*SM4*SM5*SM6)
C
C     TRIANGULAR FACTOR, DELTA (j, L, j')
      TR1 = RFACT((JA-JB)/2+L  )
      TR2 = RFACT((JA+JB)/2-L  )
      TR3 = RFACT((JB-JA)/2+L  )
      TR4 = RFACT((JA+JB)/2+L+1)
      TRP = DSQRT(TR1*TR2*TR3/TR4)
C
C     LIMITS IN THE SUM OVER TENSOR ORDERS NU
      NUI = MAX0(L-(JB+MA)/2,M+(JA-JB)/2,  0)
      NUF = MIN0(  (JA-MA)/2,L+(JA-JB)/2,L+M)
C
C     SUM OVER ALLOWED TENSOR ORDERS NU
      XNU = 0.0D0
      DO NU=NUI,NUF
C
C       PHASE TERM FROM TENSOR ORDER
        PTN = DFLOAT((-1)**NU)
C
C       FACTORS INVOLVING TENSOR ORDER
        RD1 = RFACT((JA-MA)/2    -NU)
        RD2 = RFACT((JB+MA)/2-L  +NU)
        RD3 = RFACT((JB-JA)/2  -M+NU)
        RD4 = RFACT((JA-JB)/2+L  -NU)
        RD5 = RFACT(          L+M-NU)
        RD6 = RFACT(              NU)
        RDP = RD1*RD2*RD3*RD4*RD5*RD6
C
C       ADD THIS CONTRIBUTION TO THE 3J-SYMBOL
        XNU = XNU + PTN/RDP
C
      ENDDO
C
C     3-J SYMBOL IS A PRODUCT OF PHASE, SYMMETRIC FACTOR, TRIANGULAR
C     FACTOR AND THE SUM OVER ALLOWED NU TERMS
      SYM3J = PHS*TRP*SYM*XNU
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [9] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] PT1BODY: MAIN ROUTINE FOR MOLECULAR EXPECTATION VALUES.        C
C   [B] PROPRTY: MOLECULAR EXPECTATION VALUE FROM DENSITY MATRIX.      C
C   [C] RSPT1: SET OF 1ST ORDER MOLECULAR MATRIX ELEMENTS AND E(2).    C
C   [D] DIAGRMTC: SET OF GOLDSTONE DIAGRAM CONTRIBUTIONS FOR ORBITAL.  C
C -------------------------------------------------------------------- C
C   [A] ATOMPOP: PROJECT SOLUTION ONTO ATOMIC DIRAC BASIS.             C
C   [B] MULLIKN: MULLIKEN POPULATION ANALYSIS ON CONVERGED SOLUTION.   C
C   [C] ORTHGNL: ORBITAL ORTHOGONALITY ANALYSIS.                       C
C   [D] RELKNTC: RELATIVISTIC KINETIC ENERGY ANALYSIS.                 C
C   [E] SPINPRJ: SPIN-PROJECTION ANALYSIS FOR EACH SPINOR.             C
C   [F] ELCDIPL: PERMANENT ELECTRIC DIPOLE MOMENT ANALYSIS.            C
C   [G] ELCQDPL: PERMANENT ELECTRIC QUADRUPOLE MOMENT ANALYSIS.        C
C   [H] MAGDIPL: PERMANENT MAGNETIC DIPOLE MOMENT ANALYSIS.            C
C   [I] MAGQDPL: PERMANENT MAGNETIC QUADRUPOLE MOMENT ANALYSIS.        C
C   [J] STRKEFF: STARK EFFECT ANALYSIS, GIVEN ELECTRIC FIELD E.        C
C   [K] ZMANEFF: ZEEMAN EFFECT ANALYSIS, GIVEN MAGNETIC FIELD B.       C
C   [L] HYPFINE: HYPERFINE INTERACTION ANALYSIS, GIVEN NUCLEAR MOMENT. C
C   [M] NMRSHLD: MAGNETIC SHIELDING TENSOR FOR A CENTRE IN A MOLECULE. C
C   [N] GTENSOR: ELECTRONIC G-FACTOR FOR A MOLECULE.                   C
C   [O] EEDMSML: ATOM-CENTRED PT-ODD EDM OPERATOR (WITH E-FIELD).      C
C   [P] EEDMEFF: ONE-BODY EFFECTIVE PT-ODD EDM OPERATOR.               C
C   [Q] ENHANFC: MOLECULAR EEDM ENHANCEMENT FACTOR CALCULATION.        C
C   [R] SCLPTEN: SCALAR PT-ODD ELECTRON-NUCLEAR INTERACTION ANALYSIS.  C
C   [S] VECPTEN: VECTOR PT-ODD ELECTRON-NUCLEAR INTERACTION ANALYSIS.  C
C   [T] NUCMAGQ: NUCLEAR MAGNETIC QUADRUPOLE INTERACTION ANALYSIS.     C
C   [U] PVIOLTN: P-ODD EFFECTIVE OPERATOR ANALYSIS.                    C
C   [V] BETADCY: CORRECTIONS DUE TO THE NUCLEAR DECAY OF A CENTRE.     C
C   [W] NUCOLAP: GAUSSIAN NUCLEAR OVERLAP WITH ELECTRON CHARGE DENSITY.C
C   [X] NUCGRAD: GRADIENT OF ELECTRONIC DENSITY ACROSS NUCLEUS.        C
C -------------------------------------------------------------------- C
C   [A] COREPOL: APPLY CORE-POLARISATION CORRECTION TO AN OPERATOR.    C
C -------------------------------------------------------------------- C
C   [A] COREINT: COULOMB INTEGRAL MATRIX ELEMENTS FOR USE IN COREPOL.  C
C   [B] VMOMNT0: ZEROTH MOMENT INTEGRALS OVER σ_Q AND TT'.             C
C   [C] VMOMNT1: FIRST MOMENT INTEGRALS OVER σ_Q, TT' AND IX.          C
C   [D] VMOMNT2: SECOND MOMENT INTEGRALS OVER σ_Q, TT', IX AND JX.     C
C   [E] VMNPOLE: FIELD MONOPOLE INTEGRALS OVER σ_Q AND TT'.            C
C   [F] VDIPOLE: FIELD DIPOLE INTEGRALS OVER σ_Q, TT' AND IX.          C
C   [G] VSETGTN: MODIFIED FIELD DIPOLE INTEGRALS FOR GTENSOR ROUTINE.  C
C   [H] VQDPOLE: FIELD QUADRUPOLE INT'S OVER σ_Q, TT', IX AND IX'.     C
C   [I] VNCATRC: NUCLEAR ATTRACTION INTEGRALS.                         C
C   [J] VPTNCD1: FIRST DERIVATIVE OF POINT NUCLEAR INTEGRALS.          C
C   [K] VPTNCD2: SECOND DERIVATIVE OF POINT NUCLEAR INTEGRALS.         C
C   [L] VNCOLAP: NUCLEAR CHARGE INTEGRALS OVER σ_Q, TT' AND IZ.        C
C   [M] VNCGRAD: NUCLEAR CHARGE GRADIENT INTEGRALS OVER σ_Q, TT', IZ.  C
C   [N] VKNETIC: RELATIVISTIC KINETIC OVERLAP INTEGRALS.               C
C   [O] VLPLACE: NON-RELATIVISTIC KINETIC INTEGRALS.                   C
C   [P] VPLNWAV: PLANE WAVE MATRIX ELEMENT INTEGRALS FOR WAVE VECTOR K.C
C**********************************************************************C
C
C
      SUBROUTINE PT1BODY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       PPPPPPP TTTTTTTT 11  BBBBBBB   OOOOOO  DDDDDDD  YY    YY       C
C       PP    PP   TT   111  BB    BB OO    OO DD    DD YY    YY       C
C       PP    PP   TT    11  BB    BB OO    OO DD    DD  YY  YY        C
C       PP    PP   TT    11  BBBBBBB  OO    OO DD    DD   YYYY         C
C       PPPPPPP    TT    11  BB    BB OO    OO DD    DD    YY          C
C       PP         TT    11  BB    BB OO    OO DD    DD    YY          C
C       PP         TT   1111 BBBBBBB   OOOOOO  DDDDDDD     YY          C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  PT1BODY CALCULATES MATRIX ELEMENTS AND ENERGY CORRECTIONS GIVEN A   C
C  HARTREE-FOCK CALCULATION AND SET OF COEFFICIENTS AND ENERGIES.      C
C -------------------------------------------------------------------- C
C  EQSAVE ONLY GENERATES ELL0, ESS0 AND MAYBE ELSI, AND IN GENERAL     C
C  THESE CALCULATIONS REQUIRE ETT'Q, SO GENERATE AS NEEDED INSTEAD.    C
C -------------------------------------------------------------------- C
C  BASIS OVERLAP MATRIX ELEMENTS AVAILABLE:                            C
C ▶(μ,T|σ_Q|ν,T')          - VMOMNT0(VIJ,IQ)      - ZEROTH MOMENT      C
C ▶(μ,T|σ_Q.x|ν,T')        - VMOMNT1(VIJ,IQ,IX)   - FIRST MOMENT       C
C ▶(μ,T|σ_Q.x.x'|ν,T')     - VMOMNT2(VIJ,IQ,IX,JX)- SECOND MOMENT      C
C ▶(μ,T|σ_Q.x/r^3|ν,T')    - VMNPOLE(VIJ,IQ,IX)   - FIELD MONOPOLE     C
C ▶(μ,T|σ_Q.x.y/r^3|ν,T')  - VDIPOLE(VIJ,IQ,IX'S) - FIELD DIPOLE       C
C ▶(μ,T|σ_Q.x.y.z/r^3|ν,T')- VQDPOLE(VIJ,IQ,IX'S) - FIELD QUADRUPOLE   C
C ▶(μ,T|σ_Q.V(nuc)|ν,T')   - VNCATRC(VIJ)         - NUCLEAR ATTRACTION C
C ▶(μ,T|σ_Q.∇x/r|ν,T')     - VPTNCD1(VIJ,IQ,IX)   - POINT NUCLEAR D1   C
C ▶(μ,T|σ_Q.∇x.∇y/r|ν,T')  - VPTNCD2(VIJ,IQ,IX,JX)- POINT NUCLEAR D2   C
C ▶(μ,T|σ_Q.ϱ(nuc)|ν,T')   - VNCOLAP(VIJ)         - NUCLEAR OVERLAP    C
C ▶∇(μ,T|σ_Q.ϱ(nuc)|ν,T')  - VNCGRAD(VIJ)         - GRADIENT NUC OVLP  C
C ▶(μ,T|σ_Q.p|ν,T')        - VKNETIC(VIJ)         - REL'VISTIC KINETIC C
C ▶(μ,T|σ_Q.∇^2|ν,T')      - VLPLACE(VIJ)         - NON-REL KINETIC    C
C ▶(μ,T|exp(ik.x)|ν,T')    - VPLNWAV(VIJ)         - PLANE WAVE         C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*7  HMINT(50)
      CHARACTER*16 HMS
C
      DIMENSION XYZEVAL(3),EFIELD(3),BFIELD(3),GAUGE(3),NEUT(MCT)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/PT1B/NHMINT,HMINT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TPRP/EMTY
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     EQ-COEFF AND R-INT TIME INITIALISATION
      TELL = 0.0D0
      TESS = 0.0D0
      TELS = 0.0D0
      TESL = 0.0D0
      TRLL = 0.0D0
      TRSS = 0.0D0
      TRLS = 0.0D0
      TRSL = 0.0D0
C
C     SPECIAL CASE FOR COREPOL: GENERATE FULL SET OF EQTT'
      DO N=1,NHMINT
        IF(EQFILE.AND.HMINT(N).EQ.'COREPOL') THEN
          CALL EQSAVE
        ENDIF
      ENDDO
C
C     IF READING IN PREVIOUS SOLUTION, CALCULATE MOLECULAR DENSITY
      WRITE(6, *) 'Spectrum generated by Hartree-Fock solution:'
      WRITE(7, *) 'Spectrum generated by Hartree-Fock solution:'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C     CALL SPECTRM(NOCC,NSKP-NOCC)
C     CALL SPECTRM(NOCC,2)
      CALL DENSTY
C
C     LOOP OVER ALL REQUESTED INTERACTION HAMILTONIANS
      DO N=1,NHMINT

C       PRINT A TITLE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) 'One-body H_{int} = ',HMINT(N)
        WRITE(7, *) 'One-body H_{int} = ',HMINT(N)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
!         IF(HMINT(N).EQ.'ATOMPOP') THEN
! C         NUMBER OF VIRTUAL ORBITALS TO INCLUDE IN LIST
!           IVIR = 2
!           CALL ATOMPOP(IVIR)
!         ELSEIF(HMINT(N).EQ.'MULLIKN') THEN
! C         NUMBER OF VIRTUAL ORBITALS TO INCLUDE IN LIST
!           IVIR = 0
!           ICKM = 3
! C          CALL MULLIKN(NOCC,IVIR,ICKM)
!           CALL MULLIKN(NOCC,IVIR,1)
!           CALL MULLIKN(NOCC,IVIR,2)
!           CALL MULLIKN(NOCC,IVIR,3)
      !   ELSEIF(HMINT(N).EQ.'ORTHGNL') THEN
c        IF(HMINT(N).EQ.'ORTHGNL') THEN
c          CALL ORTHGNL
!         ELSEIF(HMINT(N).EQ.'RELKNTC') THEN
!           CALL RELKNTC
!         ELSEIF(HMINT(N).EQ.'LORBANG') THEN
!           CALL LORBANG
!         ELSEIF(HMINT(N).EQ.'SPINPRJ') THEN
!           CALL SPINPRJ
!         ELSEIF(HMINT(N).EQ.'ELCDIPL') THEN
!           CALL ELCDIPL
!         ELSEIF(HMINT(N).EQ.'ELCQDPL') THEN
!           CALL ELCQDPL
!         ELSEIF(HMINT(N).EQ.'MAGDIPL') THEN
!           CALL MAGDIPL
!         ELSEIF(HMINT(N).EQ.'MAGQDPL') THEN
!           CALL MAGQDPL
!         ELSEIF(HMINT(N).EQ.'STRKEFF') THEN
! C         UNIFORM ELECTRIC FIELD VECTOR
!           EFIELD(1) = 0.0D0
!           EFIELD(2) = 0.0D0
!           EFIELD(3) = 1.0D0
! C         GAUGE ORIGIN
!           GAUGE(1) = 0.0D0
!           GAUGE(2) = 0.0D0
!           GAUGE(3) = 0.0D0
!           CALL STRKEFF(EFIELD,GAUGE)
!         ELSEIF(HMINT(N).EQ.'ZMANEFF') THEN
! C         UNIFORM MAGNETIC FIELD VECTOR
!           BFIELD(1) = 0.0D0
!           BFIELD(2) = 0.0D0
!           BFIELD(3) = 1.0D0
! C         GAUGE ORIGIN
!           GAUGE(1) = 0.0D0
!           GAUGE(2) = 0.0D0
!           GAUGE(3) = 0.0D0
!           CALL ZMANEFF(BFIELD,GAUGE)
!         ELSEIF(HMINT(N).EQ.'HYPFINE') THEN
! C         CENTRE WITH NUCLEAR MAGENTIC MOMENT, 2*I AND DIPOLE MOMENT MU
!           IZ   = 1
!           ISPN = 1
!           RNMU = 0.49367
!           CALL HYPFINE(IZ,RNMU,ISPN)
! C         IV = 79
! C         CALL COREPOLHYP(IV,IZ,RNMU,ISPN)
!         ELSEIF(HMINT(N).EQ.'NMRSHLD') THEN
! C         GAUGE ORIGIN
!           IZ       = 1
!           GAUGE(1) = 0.0D0
!           GAUGE(2) = 0.0D0
!           GAUGE(3) = 0.0D0
!           CALL NMRSHLD(IZ,GAUGE)
!         ELSEIF(HMINT(N).EQ.'GTENSOR') THEN
!           GAUGE(1) = 0.0D0
!           GAUGE(2) = 0.0D0
!           GAUGE(3) = 0.0D0
!           CALL GTENSOR(GAUGE)
!         ELSEIF(HMINT(N).EQ.'EEDMSML') THEN
! C         NUCLEAR CENTRE WHOSE ELECTRIC FIELD IS TO BE INTEGRATED OVER
!           IZ   = 1
!           IOCC = 79
!           CALL EEDMSML(IZ,IOCC)
!         ELSEIF(HMINT(N).EQ.'EEDMEFF') THEN
!           IOCC = 79
!           CALL EEDMEFF(IOCC)
!         ELSEIF(HMINT(N).EQ.'ENHANFC') THEN
! C         NUMBER OF ORBITALS FROM VIRTUAL SPECTRUM (IN ORDER) TO INCLUDE
!           IOCC = 11
!           CALL ENHANFC(IOCC)
!         ELSEIF(HMINT(N).EQ.'SCLPTEN') THEN
!           IZ   = 1
!           IOCC = 79
!           CALL SCLPTEN(IZ,IOCC)
!         ELSEIF(HMINT(N).EQ.'VECPTEN') THEN
! C         NUCLEAR CENTRE WHOSE CURRENT DIST. IS TO BE INTEGRATED OVER
!           IZ   = 1
!           ISPN = 1
!           IOCC = 79
!           CALL VECPTEN(IZ,IOCC,ISPN)
!         ELSEIF(HMINT(N).EQ.'NUCMAGQ') THEN
! C         NUCLEAR CENTRE CONTAINING A VALENCE PROTON
!           IZ   = 1
!           ISPN = 5
!           LPRT = 0
!           IOCC = 79
!           CALL NUCMAGQ(IZ,ISPN,LPRT,IOCC)
!         ELSEIF(HMINT(N).EQ.'PVIOLTN') THEN
! C         SPECIFY NUMBER OF NEUTRONS IN EACH ATOMIC CENTRE UP TO NCNT
! c          NEUT(1) = 6
! c          NEUT(2) = 45
! c          NEUT(3) = 18
! c          NEUT(4) = 10
! c          NEUT(5) = 0
!           CALL PVIOLTN(NEUT)
!         ELSEIF(HMINT(N).EQ.'BETADCY') THEN
! C         CENTRE UNDERGOING DECAY AND EMITTED CHARGE
!           IZ   = 1
!           ZDCY = 2.0D0
!           CALL BETADCY(IZ,ZDCY)
!         ELSEIF(HMINT(N).EQ.'NUCOLAP') THEN
! C         CENTRE WHOSE DENSITY OVERLAP IS DESIRED
!           IZ = 1
!           CALL NUCOLAP(IZ)
c        ELSEIF(HMINT(N).EQ.'NUCGRD0') THEN
cC         CENTRE WHOSE DENSITY GRADIENT IS DESIRED
c          IZ = 1
c          CALL NUCGRAD0(IZ)
c        ELSEIF(HMINT(N).EQ.'NUCGRD1') THEN
cC         CENTRE WHOSE DENSITY GRADIENT IS DESIRED
c          IZ = 1
c          CALL NUCGRAD1(IZ)
c        ELSEIF(HMINT(N).EQ.'NUCGRD2') THEN
cC         CENTRE WHOSE DENSITY GRADIENT IS DESIRED
c          IZ = 1
c          CALL NUCGRAD2(IZ)
        IF(HMINT(N).EQ.'NUCGRAD') THEN
C         CENTRE WHOSE DENSITY GRADIENT IS DESIRED
          IZ = 1
c         CALL NUCGRAD(IZ)
          CALL NUCGRADquad(IZ)
        ELSEIF(HMINT(N).EQ.'NUCSCHF') THEN
C         CENTRE WHOSE DENSITY GRADIENT IS DESIRED
          IZ = 1
C         GAUGE ORIGIN
          GAUGE(1) = 0.0D0
          GAUGE(2) = 0.0D0
          GAUGE(3) = 0.0D0
          gmin =-1.0d-3
          gmax = 1.0d-3
          wdth = gmax-gmin
C          do i=0,500
C            gauge(3) = gmin + wdth*dfloat(i)/500.0d0
C            gauge(3) = gauge(3)/cfm
CC           write(*,*) i,gauge(3),gauge(3)*cfm
C            CALL NUCSCHF(IZ,GAUGE)
C          enddo
          CALL NUCSCHFquad(IZ)
C        ELSEIF(HMINT(N).EQ.'MAGEFF1') THEN
cC         CENTRE WHOSE MAGNETIC NUCLEAR EFFECT IS DESIRED
c          IZ = 1
c          CALL MAGEFF1(IZ)
c        ELSEIF(HMINT(N).EQ.'MAGEFFP') THEN
cC         CENTRE WHOSE MAGNETIC NUCLEAR EFFECT IS DESIRED
c          IZ = 1
c          CALL MAGEFFP(IZ)
c        ELSEIF(HMINT(N).EQ.'MGNTEDM') THEN
cC         CENTRE WHOSE MAGNETIC NUCLEAR EFFECT IS DESIRED
c          IZ = 1
c          CALL MGNTEDM(IZ)
c        ELSEIF(HMINT(N).EQ.'WKNEUTJ') THEN
cC         CENTRE WHOSE WEAK NEUTRAL CURRENT INTERACTION IS DESIRED
c          IZ = 1
c          CALL WKNEUTJ(IZ)
c        ELSEIF(HMINT(N).EQ.'NUCFRCE') THEN
cC         CENTRE WHOSE TOTAL APPLIED FORCE IS REQUIRED
c          IZ = 1
cC         FORCE-VECTOR DIRECTION OF INTEREST (EASIER TO WRITE RESULTS)
c          IX = 3
c          CALL NUCFRCE(IZ,IX)
c!         ELSEIF(HMINT(N).EQ.'UEHFRCE') THEN
c! C         CENTRE WHOSE UEHLING APPLIED FORCE IS REQUIRED
c!           IZ = 1
c! C         FORCE-VECTOR DIRECTION OF INTEREST (EASIER TO WRITE RESULTS)
c!           IX = 3
c!           CALL UEHFRCE(IZ,IX)
c        ELSEIF(HMINT(N).EQ.'ELECFLD') THEN
cC         LOCATION OF FIELD POINT (GLOBAL CARTESIAN COORDINATES)
c          XYZEVAL(1) = 0.0D0
c          XYZEVAL(2) = 0.0D0
c          XYZEVAL(3) = 0.0D0
cC         E-FIELD DIRECTION OF INTEREST (EASIER TO WRITE RESULTS)
c          IX = 3
c          CALL ELECFLD(XYZEVAL,IX)
c        ELSEIF(TRIM(HMINT(N)).EQ.'PVACPOL') THEN
cC         TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON)
c          IWRT = 1
c          DO IZ=1,NCNT
c            CALL PVACPOL(IZ,IWRT,'UEH')
c          ENDDO
c        ELSEIF(TRIM(HMINT(N)).EQ.'NUCSIZE') THEN
cC         TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON)
c          IWRT = 1
c          IZ   = 1
c          ANEW = 400.0D0
c          DO IZ=1,NCNT
c            CALL NUCSIZE(IZ,IWRT,ANEW)
c          ENDDO
!         ELSEIF(TRIM(HMINT(N)).EQ.'PANOMLS') THEN
! C         TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON)
!           IWRT = 0
!           CALL PANOMLS(IWRT)
!         ELSEIF(TRIM(HMINT(N)).EQ.'PSLFLWB') THEN
! C         TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON)
!           IWRT = 0
!           CALL PSLFLWB(IWRT)
!         ELSEIF(TRIM(HMINT(N)).EQ.'PSLFHIF') THEN
! C         TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON)
!           IWRT = 0
!           CALL PSLFHIF(IWRT)
!         ELSEIF(TRIM(HMINT(N)).EQ.'PSLFLWA') THEN
! C         TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON)
!           IWRT = 0
!           CALL PSLFLWA(IWRT)
!         ELSEIF(TRIM(HMINT(N)).EQ.'OVERLAP') THEN
!           IOCC = 1
!           CALL OVERLAP(IOCC)
!         ELSEIF(HMINT(N).EQ.'COREPOL') THEN
!           IV = 11
!           CALL COREPOL(IV)
        ELSE
          WRITE(6, *) 'In PT1BODY: this operator is not available.'
          WRITE(7, *) 'In PT1BODY: this operator is not available.'
        ENDIF
C
C     END LOOP OVER INTERACTION HAMILTONIANS
      ENDDO
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TPRP)
      TPRP = TPRP-TDUM
C
20    FORMAT(1X,A,37X,A)
      WRITE(6, *) 
      WRITE(7, *) 
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(TELL.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in EMAKE (LL):',HMS(TELL)
        WRITE(7,20) 'Time in EMAKE (LL):',HMS(TELL)
      ENDIF
      IF(TELS.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in EMAKE (LS):',HMS(TELS)
        WRITE(7,20) 'Time in EMAKE (LS):',HMS(TELS)
      ENDIF
      IF(TESL.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in EMAKE (SL):',HMS(TESL)
        WRITE(7,20) 'Time in EMAKE (SL):',HMS(TESL)
      ENDIF
      IF(TESS.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in EMAKE (SS):',HMS(TESS)
        WRITE(7,20) 'Time in EMAKE (SS):',HMS(TESS)
      ENDIF
      IF(TRLL.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in RMAKE (LL):',HMS(TRLL)
        WRITE(7,20) 'Time in RMAKE (LL):',HMS(TRLL)
      ENDIF
      IF(TRLS.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in RMAKE (LS):',HMS(TRLS)
        WRITE(7,20) 'Time in RMAKE (LS):',HMS(TRLS)
      ENDIF
      IF(TRSL.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in RMAKE (SL):',HMS(TRSL)
        WRITE(7,20) 'Time in RMAKE (SL):',HMS(TRSL)
      ENDIF
      IF(TRSS.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in RMAKE (SS):',HMS(TRSS)
        WRITE(7,20) 'Time in RMAKE (SS):',HMS(TRSS)
      ENDIF
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE PROPRTY(E1,BLL,BLS,BSL,BSS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP  RRRRRRR   OOOOOO  PPPPPPP  RRRRRRR TTTTTTTT YY    YY    C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT    YY    YY    C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT     YY  YY     C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT      YYYY      C
C     PPPPPPP  RRRRRRR  OO    OO PPPPPPP  RRRRRRR    TT       YY       C
C     PP       RR    RR OO    OO PP       RR    RR   TT       YY       C
C     PP       RR    RR  OOOOOO  PP       RR    RR   TT       YY       C
C                                                                      C
C -------------------------------------------------------------------- C
C  PROPRTY CALCULATES A MOLECULAR EXPECTATION VALUE OVER THE DENSITY   C
C  MATRIX AND BASIS PAIR INTEGRALS IN THE B MATRICES.                  C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ E1: COMPLEX-VALUED MOLECULAR EXPECTATION VALUE RESULTS FOR EACH   C
C        COMPONENT TYPE OVERLAP ITT, WITH ITT=5 FOR TOTAL VALUE.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMPLEX*16 E1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 BLL(MDM,MDM),BSS(MDM,MDM),BLS(MDM,MDM),BSL(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
C
C     INITIALISE COUNTER ARRAYS FOR BASIS OVERLAP CONTRIBUTIONS
      DO ITT=1,4
        E1(ITT) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     MULTIPLY MATRIX ELEMENTS BY ELECTRON DENSITY MATRIX
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          E1(1) = E1(1) + BLL(I,J)*DENT(I     ,J     )
          IF(HMLT.EQ.'NORL') GOTO 100
          E1(2) = E1(2) + BLS(I,J)*DENT(I     ,J+NSKP)
          E1(3) = E1(3) + BSL(I,J)*DENT(I+NSKP,J     )
          E1(4) = E1(4) + BSS(I,J)*DENT(I+NSKP,J+NSKP)
100       CONTINUE
        ENDDO
      ENDDO
C
C     MOLECULAR EXPECTATION VALUE
      E1(5) = E1(1)+E1(2)+E1(3)+E1(4)
C
      RETURN
      END
C
C
      SUBROUTINE RSPT1(V1,BLL,BLS,BSL,BSS,NORD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                RRRRRRR   SSSSSS  PPPPPPP TTTTTTTT 11                 C
C                RR    RR SS    SS PP    PP   TT   111                 C
C                RR    RR SS       PP    PP   TT    11                 C
C                RR    RR  SSSSSS  PP    PP   TT    11                 C
C                RRRRRRR        SS PPPPPPP    TT    11                 C
C                RR    RR SS    SS PP         TT    11                 C
C                RR    RR  SSSSSS  PP         TT   1111                C
C                                                                      C
C -------------------------------------------------------------------- C
C  RSPT1 ASSEMBLES AN ARRAY OF MOLECULAR MATRIX ELEMENTS FROM BASIS    C
C  FUNCTION OVERLAPS IN BTT BY FIRST-ORDER RAYLEIGH-SCHRODINGER P.T.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ BTT  - ARRAY OF COMPONENT OVERLAPS FOR INTEGRALS OVER BASIS FNS.  C
C  ▶ NORD - MAXIMUM ORDER IN PERTURBATIVE EXPANSION TO FOLLOW.         C
C  OUTPUT:                                                             C
C  ▶ V1   - ARRAY OF MATRIX ELEMENTS FOR ZERO-ORDER SOLUTION.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMPLEX*16 SUMLL,SUMSS,SUMLS,SUMSL
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 ALL(MDM,MDM),ASS(MDM,MDM),ALS(MDM,MDM),ASL(MDM,MDM)
      COMPLEX*16 BLL(MDM,MDM),BSS(MDM,MDM),BLS(MDM,MDM),BSL(MDM,MDM)
      COMPLEX*16 V1(MDM,MDM,5)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGC/COEF
C
C     INITIALISE STORAGE BINS
      DO IOCC=1,NDIM
        DO JOCC=1,NDIM
          DO N=1,5
            V1(IOCC,JOCC,N) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER ORBITALS IOCC
      DO IOCC=1,NDIM
C
C       NUMBER OF ORBITALS TO CONSIDER DEPENDS ON NORD
        IF(NORD.LE.2.AND.IOCC.LE.NSKP) GOTO 100
        IF(NORD.LE.2.AND.IOCC.GT.NSKP+NOCC) GOTO 100
C
C         LOOP OVER FOCK ADDRESSES IN BLOCK B
          DO IB=1,NDIM-NSKP
C
C           SMALL-COMPONENT OFFSET
            MB = IB+NSKP
C
C           INITIALISE THE CONTRACTION COUNTER
            ALL(IB,IOCC) = DCMPLX(0.0D0,0.0D0)
            ALS(IB,IOCC) = DCMPLX(0.0D0,0.0D0)
            ASL(IB,IOCC) = DCMPLX(0.0D0,0.0D0)
            ASS(IB,IOCC) = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER FOCK ADDRESSES IN BLOCK A
            DO IA=1,NDIM-NSKP
C
C             SMALL-COMPONENT OFFSET
              MA = IA+NSKP
C
C             CONTRACTION: (IA|IB) -> (IOCC|IB)
C
C             LARGE AND SMALL CONTRIBUTIONS
              ALL(IB,IOCC) = ALL(IB,IOCC)
     &                               + DCONJG(COEF(IA,IOCC))*BLL(IA,IB)
              IF(HMLT.EQ.'NORL') GOTO 10
              ALS(IB,IOCC) = ALS(IB,IOCC)
     &                               + DCONJG(COEF(IA,IOCC))*BLS(IA,IB)
              ASL(IB,IOCC) = ASL(IB,IOCC)
     &                               + DCONJG(COEF(MA,IOCC))*BSL(IA,IB)
              ASS(IB,IOCC) = ASS(IB,IOCC)
     &                               + DCONJG(COEF(MA,IOCC))*BSS(IA,IB)
10            CONTINUE
C
            ENDDO
C           WE NOW HAVE (IOCC|IB)
C
          ENDDO
C
C         LOOP OVER ORBITALS JOCC
          DO JOCC=1,NDIM
C
C           NUMBER OF ORBITALS TO CONSIDER DEPENDS ON NORD
            IF(NORD.EQ.1.AND.JOCC.NE.IOCC) GOTO 150
C
C           LOOP OVER FOCK ADDRESSES IN BLOCK B
            DO IB=1,NDIM-NSKP
C
C             SMALL-COMPONENT OFFSET
              MB = IB+NSKP
C
C             CONTRACTION: (IOCC|IB) -> (IOCC|JOCC)
C
C             LARGE AND SMALL CONTRIBUTIONS
              V1(IOCC,JOCC,1) = V1(IOCC,JOCC,1)
     &                                     + COEF(IB,JOCC)*ALL(IB,IOCC)
              V1(IOCC,JOCC,2) = V1(IOCC,JOCC,2)
     &                                     + COEF(MB,JOCC)*ALS(IB,IOCC)
              V1(IOCC,JOCC,3) = V1(IOCC,JOCC,3)
     &                                     + COEF(IB,JOCC)*ASL(IB,IOCC)
              V1(IOCC,JOCC,4) = V1(IOCC,JOCC,4)
     &                                     + COEF(MB,JOCC)*ASS(IB,IOCC)
C
            ENDDO
C
C           TOTAL ENERGY
            V1(IOCC,JOCC,5) = V1(IOCC,JOCC,1) + V1(IOCC,JOCC,2)
     &                      + V1(IOCC,JOCC,3) + V1(IOCC,JOCC,4)
C
150         CONTINUE
C
          ENDDO
C
100     CONTINUE
C
      ENDDO
C
C     HANDLE VANISHING MATRIX ELEMENTS
      TOL = 1.0D-14
      DO IOCC=1,NDIM
        DO JOCC=1,NDIM
          DO N=1,5
            TMP1 = DREAL(V1(IOCC,JOCC,N))
            TMP2 = DIMAG(V1(IOCC,JOCC,N))
            IF(DABS(TMP1).LT.TOL) THEN
              TMP1 = 0.0D0
            ENDIF
            IF(DABS(TMP2).LT.TOL) THEN
              TMP2 = 0.0D0
            ENDIF
            V1(IOCC,JOCC,N) = DCMPLX(TMP1,TMP2)
          ENDDO
        ENDDO
      ENDDO

C
      RETURN
      END
C
C
      SUBROUTINE DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,IOCC,IWRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C DDDDDDD IIII    AA     GGGGGG  RRRRRRR  MM       MM TTTTTTTT CCCCCC  C
C DD    DD II    AAAA   GG    GG RR    RR MMM     MMM    TT   CC    CC C
C DD    DD II   AA  AA  GG       RR    RR MMMM   MMMM    TT   CC       C
C DD    DD II  AA    AA GG       RR    RR MM MM MM MM    TT   CC       C
C DD    DD II  AAAAAAAA GG   GGG RRRRRRR  MM  MMM  MM    TT   CC       C
C DD    DD II  AA    AA GG    GG RR    RR MM   M   MM    TT   CC    CC C
C DDDDDDD IIII AA    AA  GGGGGG  RR    RR MM       MM    TT    CCCCCC  C
C                                                                      C
C -------------------------------------------------------------------- C
C  DIAGRMTC CALCULATES ALL GOLDSTONE DIAGRAMS UP TO ORDER NORD ARISING C
C  FROM INTERACTION MATRIX V1 FOR AN OCCUPIED STATE IOCC, SEPARATING   C
C  RESULTS INTO POSITIVE/NEGATIVE ENERGY SPECTRUM CONTRIBUTIONS.       C
C -------------------------------------------------------------------- C
C  TODO: THIS DOES NOT COMPLEX CONJUGATE AT ALL AND COMPLEX GOES       C
C        TO DOUBLE. PROBABLY WON'T AFFECT ANYTHING BUT CHECK ANYWAY.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ V1   - ARRAY OF ALL MATRIX ELEMENTS BETWEEN SOLUTION STATES.      C
C  ▶ NORD - MAXIMUM ORDER TO BE CALCULATED IN PERTURBATIVE EXPANSION.  C
C  ▶ IOCC - SOLUTION STATE OF INTEREST.                                C
C  ▶ IWRT - PARAMETER THAT DETERMINES WHETHER TO WRITE RESULTS.        C
C  OUTPUT:                                                             C
C  ▶ EPOS - POSITIVE-ENERGY SPECTRUM COMPONENT OF GOLDSTONE DIAGRAMS.  C
C  ▶ ENEG - PART OF GOLDSTONE DIAGRAMS THAT INVOLVE NEGATIVE CONTRIB'N.C
C  ▶ ETOT - TOTAL GOLDSTONE DIAGRAM EXPECTATION VALUE -- SEE THE END   C
C           OF THIS SUBROUTINE FOR IDENTIFICATION OF DIAGRAMS (0:21).  C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 V1(MDM,MDM,5)
      COMPLEX*16 V2,V3P,V3H,V4PP,V4PH,V4HH,V4RR,V5PPP,V5PPH,V5C,V5PHH,
     &           V5A,V5B,V5D,V5HHH,V5E
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGE/E0(MDM)
C
C     SENSITIVITY TOLERANCE PARAMETER
      EPS = 1.0D-10
C
C     INITIALISE ENERGY COUNTERS
      DO I=0,21
        EPOS(I) = 0.0D0
        ENEG(I) = 0.0D0
        ETOT(I) = 0.0D0
      ENDDO
C
C**********************************************************************C
C     E^(0) ZERO-ORDER CORRECTION                                      C
C**********************************************************************C
C
C     PERTURBATION ENERGY E^(0) -- DIRECTLY FROM EIGENVALUE PROBLEM
      ETOT(0) = E0(IOCC)
      EPOS(0) = E0(IOCC)
C
      IF(NORD.EQ.0) GOTO 100
C
C**********************************************************************C
C     E^(1) FIRST-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     PERTURBATION ENERGY E^(1) -- DIAGONAL ELEMENTS OF V1
      ETOT(1) = DREAL(V1(IOCC,IOCC,5))
      EPOS(1) = DREAL(V1(IOCC,IOCC,5))
C
      IF(NORD.EQ.1) GOTO 100
C
C**********************************************************************C
C     E^(2) SECOND-ORDER CORRECTION                                    C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 102
        IF(DABS(E0(IOCC)-E0(JOCC)).LT.EPS) GOTO 102
C
C       E^(2) SECOND-ORDER TOTAL
        V2 = V1(IOCC,JOCC,5)*DCONJG(V1(IOCC,JOCC,5))
        E2 = E0(IOCC)-E0(JOCC)
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(2) = ETOT(2) + DREAL(V2)/E2
C
        IF(JOCC.GT.NSKP) THEN
          EPOS(2) = EPOS(2) + DREAL(V2)/E2
        ENDIF
C
102     CONTINUE
C
      ENDDO
C
      IF(NORD.EQ.2) GOTO 100
C
C**********************************************************************C
C     E^(3) THIRD-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 103
        IF(DABS(E0(IOCC)-E0(JOCC)).LT.EPS) GOTO 103
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 203
          IF(DABS(E0(IOCC)-E0(KOCC)).LT.EPS) GOTO 203
C
C         E^(3) [P] THIRD-ORDER PAIR TERM
          V3P = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,IOCC,5)
          E3P = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(3) = ETOT(3) + DREAL(V3P)/E3P
C
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(3) = EPOS(3) + DREAL(V3P)/E3P
          ENDIF
C
203       CONTINUE
C          
        ENDDO
C       
C       E^(3) [H] THIRD-ORDER HOLE TERM
        V3H = (V1(IOCC,JOCC,5)**2)
        E3H = (E0(IOCC)-E0(JOCC))**2
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(4) = ETOT(4) - ETOT(1)*DREAL(V3H)/E3H
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(4) = EPOS(4) - EPOS(1)*DREAL(V3H)/E3H
        ENDIF
C
103     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(3)
      ETOT(5) = ETOT(3)+ETOT(4)
      EPOS(5) = EPOS(3)+EPOS(4)
C
      IF(NORD.EQ.3) GOTO 100
C
C**********************************************************************C
C     E^(4) FOURTH-ORDER CORRECTION                                    C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 104
        IF(DABS(E0(IOCC)-E0(JOCC)).LT.EPS) GOTO 104
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 204
          IF(DABS(E0(IOCC)-E0(KOCC)).LT.EPS) GOTO 204
C
C         LOOP OVER STATES
          DO LOCC=1,NDIM
C
C           SELF-ENERGIES NOT INCLUDED
            IF(IOCC.EQ.LOCC) GOTO 304
            IF(DABS(E0(IOCC)-E0(LOCC)).LT.EPS) GOTO 304
C
C           E^(4) [PP] FOURTH-ORDER PAIR-PAIR TERM
            V4PP = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,LOCC,5)
     &                                            *V1(LOCC,IOCC,5)
            E4PP = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &                                *(E0(IOCC)-E0(LOCC))
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(6) = ETOT(6) + DREAL(V4PP)/E4PP
C
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(6) = EPOS(6) + DREAL(V4PP)/E4PP
            ENDIF
C
304         CONTINUE
C
          ENDDO
C
C         E^(4) [PH] FOURTH-ORDER PAIR-HOLE TERM
          V4PH = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,IOCC,5)
          E4PH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(7) = ETOT(7) - 2.0D0*ETOT(1)*DREAL(V4PH)/E4PH
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(7) = EPOS(7) - 2.0D0*EPOS(1)*DREAL(V4PH)/E4PH
          ENDIF
C
204       CONTINUE
C          
        ENDDO
C       
C       E^(4) [HH] FOURTH-ORDER HOLE-HOLE TERM
        V4HH = V1(IOCC,JOCC,5)*V1(JOCC,IOCC,5)
        E4HH = (E0(IOCC)-E0(JOCC))**3
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(8) = ETOT(8) + (ETOT(1)**2)*DREAL(V4HH)/E4HH
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(8) = EPOS(8) + (EPOS(1)**2)*DREAL(V4HH)/E4HH
        ENDIF
C       
C       E^(4) [R1+R2] FOURTH-ORDER RESOLVANT-RESOLVANT TERM
        V4RR = V1(IOCC,JOCC,5)**2
        E4RR = (E0(IOCC)-E0(JOCC))**2
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(9) = ETOT(9) - ETOT(2)*DREAL(V4RR)/E4RR
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(9) = EPOS(9) - EPOS(2)*DREAL(V4RR)/E4RR
        ENDIF
C
104     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(4)
      ETOT(10) = ETOT(6)+ETOT(7)+ETOT(8)+ETOT(9)
      EPOS(10) = EPOS(6)+EPOS(7)+EPOS(8)+EPOS(9)
C
      IF(NORD.EQ.4) GOTO 100
C
C**********************************************************************C
C     E^(5) FIFTH-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 105
        IF(DABS(E0(IOCC)-E0(JOCC)).LT.EPS) GOTO 105
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 205
          IF(DABS(E0(IOCC)-E0(KOCC)).LT.EPS) GOTO 205
C
C         LOOP OVER STATES
          DO LOCC=1,NDIM
C
C           SELF-ENERGIES NOT INCLUDED
            IF(IOCC.EQ.LOCC) GOTO 305
            IF(DABS(E0(IOCC)-E0(LOCC)).LT.EPS) GOTO 305
C
C           LOOP OVER STATES
            DO MOCC=1,NDIM
C
C             SELF-ENERGIES NOT INCLUDED
              IF(IOCC.EQ.MOCC) GOTO 405
              IF(DABS(E0(IOCC)-E0(MOCC)).LT.EPS) GOTO 405
C
C             E^(5) [PPP] FIFTH-ORDER PAIR-PAIR-PAIR TERM
              V5PPP = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,LOCC,5)
     &                               *V1(LOCC,MOCC,5)*V1(MOCC,IOCC,5)
              E5PPP = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &               *(E0(IOCC)-E0(LOCC))*(E0(IOCC)-E0(MOCC))
C
C             CONTRIBUTIONS TO ENERGY TERM
              ETOT(11) = ETOT(11) + DREAL(V5PPP)/E5PPP
C
              IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP
     &                                        .AND.MOCC.GT.NSKP) THEN
                EPOS(11) = EPOS(11) + DREAL(V5PPP)/E5PPP
              ENDIF
C
405           CONTINUE
C
            ENDDO
C
C           E^(5) [PPH] FIFTH-ORDER PAIR-PAIR-HOLE TERM
            V5PPH = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,LOCC,5)
     &                                             *V1(LOCC,IOCC,5)
            E5PPH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(LOCC))
     &                                 *(E0(IOCC)-E0(JOCC))**2
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(12) = ETOT(12) - 3.0D0*ETOT(1)*DREAL(V5PPH)/E5PPH
C          
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(12) = EPOS(12) - 3.0D0*EPOS(1)*DREAL(V5PPH)/E5PPH
            ENDIF
C
C           E^(5) [??C] FIFTH-ORDER TERM
            V5C = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,LOCC,5)
     &                                          *(V1(LOCC,IOCC,5)**2)
            E5C = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &                               *(E0(IOCC)-E0(LOCC))**2
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(17) = ETOT(17) - DREAL(V5C)/E5C
C          
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(17) = EPOS(17) - DREAL(V5C)/E5C
            ENDIF
C
305         CONTINUE
C
          ENDDO
C
C         E^(5) [PHH] FIFTH-ORDER PAIR-HOLE-HOLE TERM
          V5PHH = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,IOCC,5)
          E5PHH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**3
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(13) = ETOT(13) + 2.0D0*(ETOT(1)**2)*DREAL(V5PHH)/E5PHH
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(13) = EPOS(13) + 2.0D0*(EPOS(1)**2)*DREAL(V5PHH)/E5PHH
          ENDIF
C       
C         E^(5) [??A] FIFTH-ORDER FIRST EXCHANGE TERM
          V5A = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,IOCC,5)
          E5A = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(15) = ETOT(15) - 2.0D0*ETOT(2)*DREAL(V5A)/E5A
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(15) = EPOS(15) - 2.0D0*EPOS(2)*DREAL(V5A)/E5A
          ENDIF
C       
C         E^(5) [??B] FIFTH-ORDER SECOND EXCHANGE TERM
          V5B = V1(IOCC,JOCC,5)*V1(JOCC,KOCC,5)*V1(KOCC,IOCC,5)
          E5B = ((E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC)))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(16) = ETOT(16) + (ETOT(1)**2)*DREAL(V5B)/E5B
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(16) = EPOS(16) + (EPOS(1)**2)*DREAL(V5B)/E5B
          ENDIF
C       
C         E^(5) [??D] FIFTH-ORDER TERM
          V5D = (V1(IOCC,JOCC,5)*V1(KOCC,IOCC,5))**2
          E5D = ((E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC)))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(18) = ETOT(18) - 2.0D0*ETOT(1)*DREAL(V5D)/E5D
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(18) = EPOS(18) - 2.0D0*EPOS(1)*DREAL(V5D)/E5D
          ENDIF
C
205       CONTINUE
C          
        ENDDO
C       
C       E^(5) [HHH] FIFTH-ORDER HOLE-HOLE-HOLE TERM
        V5HHH = V1(IOCC,JOCC,5)**2
        E5HHH = (E0(IOCC)-E0(JOCC))**4
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(14) = ETOT(14) - (ETOT(1)**3)*DREAL(V5HHH)/E5HHH
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(14) = EPOS(14) - (EPOS(1)**3)*DREAL(V5HHH)/E5HHH
        ENDIF
C       
C       E^(5) [??E] FIFTH-ORDER TERM
        V5E = V1(IOCC,JOCC,5)**2
        E5E = (E0(IOCC)-E0(JOCC))**3
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(19) = ETOT(19) - 4.0D0*ETOT(1)*ETOT(2)*DREAL(V5E)/E5E
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(19) = EPOS(19) - 4.0D0*EPOS(1)*EPOS(2)*DREAL(V5E)/E5E
        ENDIF
C
105     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(5)
      ETOT(20) = ETOT(11)+ETOT(12)+ETOT(13)+ETOT(14)+ETOT(15)
     &                   +ETOT(16)+ETOT(17)+ETOT(18)+ETOT(19)
      EPOS(20) = EPOS(11)+EPOS(12)+EPOS(13)+EPOS(14)+EPOS(15)
     &                   +EPOS(16)+EPOS(17)+EPOS(18)+EPOS(19)
C
      IF(NORD.EQ.5) GOTO 100
C
C**********************************************************************C
C     END OF CORRECTION CALCULATION                                    C
C**********************************************************************C
C
100   CONTINUE
C
C     ADD TOTAL ENERGIES TO THE FINAL ENTRY
      EPOS(21) = EPOS(0)+EPOS(1)+EPOS(2)+EPOS(5)+EPOS(10)+EPOS(20)
      ETOT(21) = ETOT(0)+ETOT(1)+ETOT(2)+ETOT(5)+ETOT(10)+ETOT(20)
C
C     NEGATIVE-ENERGY CONTRIBUTIONS ARE SIMPLY A DIFFERENCE
      DO I=0,21
        ENEG(I) = ETOT(I)-EPOS(I)
      ENDDO
C
C**********************************************************************C
C     WRITE RESULTS                                                    C
C**********************************************************************C
C
      IF(IWRT.EQ.0) GOTO 70
C
41    FORMAT(1X,A,15X,A,14X,A,14X,A)
42    FORMAT(1X,A,3X,F18.12,2X,F18.12,2X,F18.12)
      WRITE(6,41) 'E^(N)     |','E[pos]','E[neg]','E[tot]'
      WRITE(7,41) 'E^(N)     |','E[pos]','E[neg]','E[tot]'
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      WRITE(7,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      IF(NORD.LT.1) GOTO 50
      WRITE(6,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      WRITE(7,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      IF(NORD.LT.2) GOTO 50
      WRITE(6,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      WRITE(7,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      IF(NORD.LT.3) GOTO 50
      WRITE(6,42) 'E^(3)[P]  |',EPOS( 3),ENEG( 3),ETOT( 3)
      WRITE(7,42) 'E^(3)[P]  |',EPOS( 3),ENEG( 3),ETOT( 3)
      WRITE(6,42) 'E^(3)[H]  |',EPOS( 4),ENEG( 4),ETOT( 4)
      WRITE(7,42) 'E^(3)[H]  |',EPOS( 4),ENEG( 4),ETOT( 4)
      IF(NORD.LT.4) GOTO 50
      WRITE(6,42) 'E^(4)[PP] |',EPOS( 6),ENEG( 6),ETOT( 6)
      WRITE(7,42) 'E^(4)[PP] |',EPOS( 6),ENEG( 6),ETOT( 6)
      WRITE(6,42) 'E^(4)[PH] |',EPOS( 7),ENEG( 7),ETOT( 7)
      WRITE(7,42) 'E^(4)[PH] |',EPOS( 7),ENEG( 7),ETOT( 7)
      WRITE(6,42) 'E^(4)[HH] |',EPOS( 8),ENEG( 8),ETOT( 8)
      WRITE(7,42) 'E^(4)[HH] |',EPOS( 8),ENEG( 8),ETOT( 8)
      WRITE(6,42) 'E^(4)[RR] |',EPOS( 9),ENEG( 9),ETOT( 9)
      WRITE(7,42) 'E^(4)[RR] |',EPOS( 9),ENEG( 9),ETOT( 9)
      IF(NORD.LT.5) GOTO 50
      WRITE(6,42) 'E^(5)[PPP]|',EPOS(11),ENEG(11),ETOT(11)
      WRITE(7,42) 'E^(5)[PPP]|',EPOS(11),ENEG(11),ETOT(11)
      WRITE(6,42) 'E^(5)[PPH]|',EPOS(12),ENEG(12),ETOT(12)
      WRITE(7,42) 'E^(5)[PPH]|',EPOS(12),ENEG(12),ETOT(12)
      WRITE(6,42) 'E^(5)[PHH]|',EPOS(13),ENEG(13),ETOT(13)
      WRITE(7,42) 'E^(5)[PHH]|',EPOS(13),ENEG(13),ETOT(13)
      WRITE(6,42) 'E^(5)[HHH]|',EPOS(14),ENEG(14),ETOT(14)
      WRITE(7,42) 'E^(5)[HHH]|',EPOS(14),ENEG(14),ETOT(14)
      WRITE(6,42) 'E^(5)[??A]|',EPOS(15),ENEG(15),ETOT(15)
      WRITE(7,42) 'E^(5)[??A]|',EPOS(15),ENEG(15),ETOT(15)
      WRITE(6,42) 'E^(5)[??B]|',EPOS(16),ENEG(16),ETOT(16)
      WRITE(7,42) 'E^(5)[??B]|',EPOS(16),ENEG(16),ETOT(16)
      WRITE(6,42) 'E^(5)[??C]|',EPOS(17),ENEG(17),ETOT(17)
      WRITE(7,42) 'E^(5)[??C]|',EPOS(17),ENEG(17),ETOT(17)
      WRITE(6,42) 'E^(5)[??D]|',EPOS(18),ENEG(18),ETOT(18)
      WRITE(7,42) 'E^(5)[??D]|',EPOS(18),ENEG(18),ETOT(18)
      WRITE(6,42) 'E^(5)[??E]|',EPOS(19),ENEG(19),ETOT(19)
      WRITE(7,42) 'E^(5)[??E]|',EPOS(19),ENEG(19),ETOT(19)
50    CONTINUE
C
C     THE 'ORDER-BY-ORDER SUM' ISN'T REALLY NEEDED IF NORD<4
C     CAN COMMENT OUT THE NEXT LINE IF YOU LIKE!
      IF(NORD.LT.4) GOTO 60
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      WRITE(7,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      IF(NORD.LT.1) GOTO 60
      WRITE(6,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      WRITE(7,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      IF(NORD.LT.2) GOTO 60
      WRITE(6,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      WRITE(7,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      IF(NORD.LT.3) GOTO 60
      WRITE(6,42) 'E^(3)     |',EPOS( 5),ENEG( 5),ETOT( 5)
      WRITE(7,42) 'E^(3)     |',EPOS( 5),ENEG( 5),ETOT( 5)
      IF(NORD.LT.4) GOTO 60
      WRITE(6,42) 'E^(4)     |',EPOS(10),ENEG(10),ETOT(10)
      WRITE(7,42) 'E^(4)     |',EPOS(10),ENEG(10),ETOT(10)
      IF(NORD.LT.5) GOTO 60
      WRITE(6,42) 'E^(5)     |',EPOS(20),ENEG(20),ETOT(20)
      WRITE(7,42) 'E^(5)     |',EPOS(20),ENEG(20),ETOT(20)
60    CONTINUE
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'Energy    |',EPOS(21),ENEG(21),ETOT(21)
      WRITE(7,42) 'Energy    |',EPOS(21),ENEG(21),ETOT(21)
C
70    CONTINUE
C
      RETURN
      END
! C
! C
!       SUBROUTINE ATOMPOP(IVIR)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      AA   TTTTTTTT OOOOOO  MM       MM PPPPPPP   OOOOOO  PPPPPPP     C
! C     AAAA     TT   OO    OO MMM     MMM PP    PP OO    OO PP    PP    C
! C    AA  AA    TT   OO    OO MMMM   MMMM PP    PP OO    OO PP    PP    C
! C   AA    AA   TT   OO    OO MM MM MM MM PP    PP OO    OO PP    PP    C
! C   AAAAAAAA   TT   OO    OO MM  MMM  MM PPPPPPP  OO    OO PPPPPPP     C
! C   AA    AA   TT   OO    OO MM   M   MM PP       OO    OO PP          C
! C   AA    AA   TT    OOOOOO  MM       MM PP        OOOOOO  PP          C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  ATOMPOP PROJECTS ALL OCCUPIED (AND SOME VIRTUAL) LCAO EXPANSIONS    C
! C  INTO THE BASIS OF DIRAC ORBITALS ABOUT EACH ATOMIC CENTRE. THIS     C
! C  INVOLVES POSITIVE CONTRIBUTIONS ABOUT EACH CENTRE, AND AN ACCOUNT   C
! C  OF 'POLARIZATION' TERMS THAT ARE TWO-CENTRE IN ORIGIN.              C
! C -------------------------------------------------------------------- C
! C  NOTE THAT INDIVIDUAL RESULTS CAN BE GREATER THAN UNITY, BECAUSE     C
! C  POLARISATION CONTRIBUTIONS CAN BE NEGATIVE.                         C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE IN LIST.             C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*2 ELMT(120),ELA
!       CHARACTER*5 NMDL
! C
!       DIMENSION FRC(MDM,MCT,MKP,(MKP+1)/2,3)
!       DIMENSION BRD(MDM,3),TOT(MDM,3),RHO(MCT,3)
! C
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/EIGC/COEF
!       COMMON/MDLV/ELMT
!       COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
! C
! C     INITIALISE COUNTER MATRICES
!       DO IOCC=1,NOCC+IVIR
!         DO IZ=1,NCNT
!           DO IKAP=1,NKAP(IZ)
!             IKQN = KAPA(IKAP,IZ)
!             NMV  = IABS(IKQN)
!             DO IMV=1,NMV
!               DO IT=1,3
!                 FRC(IOCC,IZ,IKAP,IMV,IT) = 0.0D0
!               ENDDO
!             ENDDO
!           ENDDO
!         ENDDO
!         DO IT=1,3
!           BRD(IOCC,IT) = 0.0D0
!           TOT(IOCC,IT) = 0.0D0
!         ENDDO
!       ENDDO
!       DO IZ=1,NCNT
!         DO IT=1,3
!           RHO(IZ,IT) = 0.0D0
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRICES (ZEROTH MOMENT)
!       CALL VMOMNT0(OLAPLL,1,0,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT0(OLAPSS,4,0,1,2)
!       ENDIF
! C
! C     LOOP OVER OCCUPIED ORBITALS
!       DO IOCC=1,NOCC+IVIR
! C
! C       IGNORE NEGATIVE SPECTRUM
!         MOCC = IOCC+NSKP
! C
! C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
!         DO I=1,NDIM-NSKP
!           K    = I+NSKP
!           ICNT = LABICN(I)
!           IKQN = LABKQN(I)
!           IMQN = IABS(LABMQN(I))
!           IF(IKQN.LT.0) THEN
!             IKAP =-2*IKQN-1
!           ELSE
!             IKAP = 2*IKQN
!           ENDIF
!           IMV = (IMQN+1)/2
!           DO J=1,NDIM-NSKP
!             L    = J+NSKP
!             JCNT = LABICN(J)
!             JKQN = LABKQN(J)
!             JMQN = IABS(LABMQN(J))
! C
! C           LARGE AND SMALL CONTRIBUTIONS
!             EL = DREAL(DCONJG(COEF(I,MOCC))*COEF(J,MOCC)*OLAPLL(I,J))
!             IF(HMLT.NE.'NORL') THEN
!               ES = DREAL(DCONJG(COEF(K,MOCC))*COEF(L,MOCC)*OLAPSS(I,J))
!             ELSE
!               ES = 0.0D0
!             ENDIF
! C
! C           UPDATE CHARGE ON CENTRE ICNT (OCCUPIED ORBITALS ONLY)
!             IF(IOCC.LE.NOCC) THEN
!               RHO(ICNT,1) = RHO(ICNT,1) + EL
!               RHO(ICNT,2) = RHO(ICNT,2) + ES
!               RHO(ICNT,3) = RHO(ICNT,3) + EL + ES
!             ENDIF

! C           DECIDE WHERE TO PUT CONTRIBUTION
!             IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
!               FRC(IOCC,ICNT,IKAP,IMV,1) = FRC(IOCC,ICNT,IKAP,IMV,1)+EL
!               FRC(IOCC,ICNT,IKAP,IMV,2) = FRC(IOCC,ICNT,IKAP,IMV,2)+ES
!               FRC(IOCC,ICNT,IKAP,IMV,3) = FRC(IOCC,ICNT,IKAP,IMV,1)
!      &                                  + FRC(IOCC,ICNT,IKAP,IMV,2)
!             ELSE
!               BRD(IOCC,1) = BRD(IOCC,1) + EL
!               BRD(IOCC,2) = BRD(IOCC,2) + ES
!               BRD(IOCC,3) = BRD(IOCC,3) + EL + ES
!             ENDIF
! C
!           ENDDO
! C
!         ENDDO
! C
! C       TOTAL OCCUPANCIES
!         DO ICNT=1,NCNT
!           DO IKAP=1,NKAP(ICNT)
!             IKQN = KAPA(IKAP,ICNT)
!             NMV  = IABS(IKQN)
!             DO IMV=1,NMV
!               TOT(IOCC,1) = TOT(IOCC,1) + FRC(IOCC,ICNT,IKAP,IMV,1)
!               TOT(IOCC,2) = TOT(IOCC,2) + FRC(IOCC,ICNT,IKAP,IMV,2)
!               TOT(IOCC,3) = TOT(IOCC,3) + FRC(IOCC,ICNT,IKAP,IMV,3)
!             ENDDO
!           ENDDO
!         ENDDO
!         TOT(IOCC,1) = TOT(IOCC,1) + BRD(IOCC,1)
!         TOT(IOCC,2) = TOT(IOCC,2) + BRD(IOCC,2)
!         TOT(IOCC,3) = TOT(IOCC,3) + BRD(IOCC,3)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     RESULTS: CHARGES ON EACH CENTRE
! 20    FORMAT(1X,'Total charge on centre ',I2,' = ',F15.10)
! 21    FORMAT(1X,'Total charge on molecule  = ',F15.10)
!       WRITE(6, *) 'Mulliken population analysis:'
!       WRITE(7, *) 'Mulliken population analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       SUM = 0.0D0
!       DO ICNT=1,NCNT
!         WRITE(6,20) ICNT,ZNUC(ICNT)-RHO(ICNT,3)
!         WRITE(7,20) ICNT,ZNUC(ICNT)-RHO(ICNT,3)
!         SUM = SUM + ZNUC(ICNT)-RHO(ICNT,3)
!       ENDDO
!       WRITE(6,21) SUM
!       WRITE(7,21) SUM
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     RESULTS: DIRAC BASIS DECOMPOSITION FOR EACH ORBITAL
! 22    FORMAT(' Orb.',2X,'Cent.',2X,'KQN',3X,'|MQN|',10X,
!      &                                   'Q(L)',13X,'Q(S)',11X,'Q(TOT)')
! 23    FORMAT(1X,I3,2X,I2,'(',A,')',3X,I2,3X,I2,'/2',4X,F11.8,6X,
!      &                                                   F11.8,6X,F11.8)
! 24    FORMAT(1X,I3,3X,I2,'(',A,')',2X,I2,3X,I2,'/2',4X,F11.8,6X,
!      &                                                   F11.8,6X,F11.8)
! 25    FORMAT(1X,I3,3X,A ,15X,F11.8,6X,F11.8,6X,F11.8)
!       WRITE(6, *) ' '
!       WRITE(7, *) ' '
!       WRITE(6,22)
!       WRITE(7,22)
!       DO IOCC=1,NOCC+IVIR
!         WRITE(6, *) REPEAT('-',72)
!         WRITE(7, *) REPEAT('-',72)
!         IF(IOCC.EQ.NOCC+1) THEN
!           WRITE(6, *) 'Virtual orbitals (not actually occupied):'
!           WRITE(7, *) 'Virtual orbitals (not actually occupied):'
!           WRITE(6, *) REPEAT('-',72)
!           WRITE(7, *) REPEAT('-',72)
!         ENDIF
!         DO ICNT=1,NCNT
!           ELA = ELMT(INT(ZNUC(ICNT)))
!           DO IKAP=1,NKAP(ICNT)
!             IKQN = KAPA(IKAP,ICNT)
!             NMV  = IABS(IKQN)
!             DO IMV=1,NMV
!               IF(FRC(IOCC,ICNT,IKAP,IMV,3).GT.1.0D-9) THEN
!                 IF(NCNT.LT.10) THEN
!                   WRITE(6,23) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
!      &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
!                   WRITE(7,23) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
!      &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
!                 ELSE
!                   WRITE(6,24) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
!      &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
!                   WRITE(7,24) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
!      &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
!                 ENDIF
!               ENDIF
!             ENDDO
!           ENDDO
!         ENDDO
!         WRITE(6,25) IOCC,'Polar.',(BRD(IOCC,IT),IT=1,3)
!         WRITE(7,25) IOCC,'Polar.',(BRD(IOCC,IT),IT=1,3)
!         WRITE(6, *) REPEAT('-',72)
!         WRITE(7, *) REPEAT('-',72)
!         WRITE(6,25) IOCC,'Total ',(TOT(IOCC,IT),IT=1,3)
!         WRITE(7,25) IOCC,'Total ',(TOT(IOCC,IT),IT=1,3)
!       ENDDO
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE MULLIKN(NUMO,NUMV,ICKM)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     MM       MM UU    UU LL       LL       IIII KK    KK NN    NN    C
! C     MMM     MMM UU    UU LL       LL        II  KK   KK  NNN   NN    C
! C     MMMM   MMMM UU    UU LL       LL        II  KK  KK   NNNN  NN    C
! C     MM MM MM MM UU    UU LL       LL        II  KKKKK    NN NN NN    C
! C     MM  MMM  MM UU    UU LL       LL        II  KK  KK   NN  NNNN    C
! C     MM   M   MM UU    UU LL       LL        II  KK   KK  NN   NNN    C
! C     MM       MM  UUUUUU  LLLLLLLL LLLLLLLL IIII KK    KK NN    NN    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  MULLIKN CALCULATES A MULLIKEN POPULATION ANALYSIS ON A DIATOMIC     C
! C  SYSTEM, AS DESCRIBED IN:                                            C
! C  (*) J.Chem.Phys., 23: 1833, 1841, 2338, 2343 (1955).                C
! C  (*) J.Chem.Phys., 36: 3428 (1962).                                  C
! C -------------------------------------------------------------------- C
! C  FOUR LEVELS OF SUMMARY ARE PRINTED TO THE TERMINAL:                 C
! C   ▶ OVERLAP DECOMPOSITION (BY ORBITAL AND FOR WHOLE MOLECULE).       C
! C   ▶ GROSS CHARGES (BY ORBITAL AND FOR WHOLE MOLECULE).               C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ NUMO - NUMBER OF OCCUPIED ORBITALS TO ACCOUNT FOR (USUALLY NOCC)  C
! C  ▶ NUMV - NUMBER OF VIRTUAL ORBITALS (CHOOSE ZERO OR A SMALL NUMBER) C
! C  ▶ ICKM - 1 FOR (CKM), 2 FOR (CK), 3 FOR (C).                        C
! C -------------------------------------------------------------------- C
! C TODO: CAN REPLACE "OVRLAP" WITH ANY OTHER TYPE OF MATRIX ELEMENT     C
! C       TO GET A DECOMPOSITION OF CONTRIBUTIONS.                       C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*2  ELMT(120),KLAB
!       CHARACTER*3  IORB
!       CHARACTER*5  NMDL,MLAB
!       CHARACTER*14 CEKM1,CEKM2
! C
!       DIMENSION IKM(-MEL:MEL,-MKP:MKP)
!       DIMENSION CKMOVP(MCT,ML2*ML2/2,MCT,ML2*ML2/2,NUMO+NUMV,3),
!      &          CKMOVPSUM(MCT,ML2*ML2/2,MCT,ML2*ML2/2,3)
!       DIMENSION BLC(NUMO+NUMV,3),BLCSUM(3)
!       DIMENSION CKMGRS(MCT,ML2*ML2/2,NUMO+NUMV,4)
!       DIMENSION CKMGRSSUM(MCT,ML2*ML2/2,4)
!       DIMENSION TOT(NUMO+NUMV,4),TOTSUM(4)
! C
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/EIGC/COEF
!       COMMON/MDLV/ELMT
!       COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
! C
!       DATA EPS/1.0D-6/
! C
! C     IDENTIFY CENTRE WITH LARGEST KQN
!       IBIG = 0
!       LBIG = 0
!       DO IZ=1,NCNT
!         MLQN = (NKAP(IZ)-1)/2
!         IF(MLQN.GT.LBIG) THEN
!           IBIG = IZ
!           LBIG = MLQN
!         ENDIF
!       ENDDO
! C
! C     KQN AND MQN COMBINATION MAPPED TO A LIST
!       ICK = 0
!       DO IKAP=1,NKAP(IBIG)
!         IKQN = KAPA(IKAP,IBIG)
!         DO IMAG=1,2*IABS(IKQN)
!           ICK = ICK+1
!           IF(MOD(IMAG,2).EQ.1) THEN
!             IMQN =-IMAG
!           ELSE
!             IMQN = IMAG-1
!           ENDIF
!           IKM(IKQN,IMQN) = ICK
!         ENDDO
!       ENDDO
! C
! C     INITIALISE ALL OVERLAP CHARGE COUNTERS AND TOTALS
!       DO IT=1,3
!         BLCSUM(IT) = 0.0D0
!         DO IOCC=1,NUMO+NUMV
!           BLC(IOCC,IT) = 0.0D0
!         ENDDO
!         DO ICNT=1,NCNT
!           ICK = 0
!           DO IKAP=1,NKAP(ICNT)
!             IKQN = KAPA(IKAP,ICNT)
!             DO IMAG=1,2*IABS(IKQN)
!               ICK = ICK+1
!               DO JCNT=1,NCNT
!                 JCK = 0
!                 DO JKAP=1,NKAP(JCNT)
!                   JKQN = KAPA(JKAP,JCNT)
!                   DO JMAG=1,2*IABS(JKQN)
!                     JCK = JCK+1
!                     CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT) = 0.0D0
!                     DO IOCC=1,NUMO+NUMV
!                       CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT) = 0.0D0
!                     ENDDO
!                   ENDDO
!                 ENDDO
!               ENDDO
!             ENDDO
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     INITIALISE ALL GROSS CHARGE COUNTERS AND TOTALS
!       DO IP=1,4
!         TOTSUM(IP) = 0.0D0
!         DO IOCC=1,NUMO+NUMV
!           TOT(IOCC,IP) = 0.0D0
!         ENDDO
!         DO IZ=1,NCNT
!           ICK = 0
!           DO IKAP=1,NKAP(IZ)
!             IKQN = KAPA(IKAP,IZ)
!             DO IMAG=1,2*IABS(IKQN)
!               ICK = ICK+1
!               CKMGRSSUM(IZ,ICK,IP) = 0.0D0
!               DO IOCC=1,NUMO+NUMV
!                 CKMGRS(IZ,ICK,IOCC,IP) = 0.0D0
!               ENDDO
!             ENDDO
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRICES (ZEROTH MOMENT)
!       CALL VMOMNT0(OLAPLL,1,0,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT0(OLAPSS,4,0,1,2)
!       ENDIF
! C
! C     LOOP OVER OCCUPIED AND VIRTUAL ORBITALS
!       DO IOCC=1,NUMO+NUMV
! C
! C       FOCK ADDRESS FOR THIS CENTRE
!         IAD = IOCC+NSKP
! C
! C       NET SPINOR CHARGES: LOOP OVER ALL BASIS FUNCTIONS
!         DO I=1,NDIM-NSKP
!           DO J=1,NDIM-NSKP
! C
! C           SMALL-COMPONENT ADDRESSES
!             K = I+NSKP
!             L = J+NSKP
! C
! C           LARGE-COMPONENT ELECTRON DENSITY
!             VL = DREAL(DCONJG(COEF(I,IAD))*COEF(J,IAD)*OLAPLL(I,J))
! C
! C           SMALL-COMPONENT ELECTRON DENSITY
!             IF(HMLT.NE.'NORL') THEN
!               VS = DREAL(DCONJG(COEF(K,IAD))*COEF(L,IAD)*OLAPSS(I,J))
!             ELSE
!               VS = 0.0D0
!             ENDIF
! C
! C           IDENTIFY ATOMIC LABELS
!             ICNT = LABICN(I)
!             JCNT = LABICN(J)
!             IKQN = LABKQN(I)
!             JKQN = LABKQN(J)
!             IMQN = LABMQN(I)
!             JMQN = LABMQN(J)
! C
! C           FOCK ADDRESSES
!             ICK = IKM(IKQN,IMQN)
!             JCK = IKM(JKQN,JMQN)
! C
! C           UPDATE ORBITAL OVERLAP CHARGE CONTRIBUTIONS
!             CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,1) 
!      &                       = CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,1) + VL
!             CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,2)
!      &                       = CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,2) + VS
!             CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,3)
!      &                       = CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,3) + VL+VS
! C
! C           UPDATE ORBITAL GROSS CHARGE CONTRIBUTIONS
!             IF(ICNT.EQ.JCNT.AND.ICK.EQ.JCK) THEN
!               CKMGRS(ICNT,ICK,IOCC,1) = CKMGRS(ICNT,ICK,IOCC,1) + VL+VS
!             ELSEIF(ICNT.EQ.JCNT.AND.ICK.NE.JCK) THEN
!               CKMGRS(ICNT,ICK,IOCC,2) = CKMGRS(ICNT,ICK,IOCC,2) + VL+VS
!             ELSE
!               CKMGRS(ICNT,ICK,IOCC,3) = CKMGRS(ICNT,ICK,IOCC,3) + VL+VS
!             ENDIF
!             CKMGRS(ICNT,ICK,IOCC,4) = CKMGRS(ICNT,ICK,IOCC,4) + VL+VS
! C
! C           UPDATE MOLECULAR OVERLAP CHARGE CONTRIBUTIONS
!             IF(IOCC.LE.NUMO) THEN
!               CKMOVPSUM(ICNT,ICK,JCNT,JCK,1)
!      &                         = CKMOVPSUM(ICNT,ICK,JCNT,JCK,1) + VL
!               CKMOVPSUM(ICNT,ICK,JCNT,JCK,2)
!      &                         = CKMOVPSUM(ICNT,ICK,JCNT,JCK,2) + VS
!               CKMOVPSUM(ICNT,ICK,JCNT,JCK,3)
!      &                         = CKMOVPSUM(ICNT,ICK,JCNT,JCK,3) + VL+VS
!             ENDIF
! C
! C           UPDATE MOLECULAR GROSS CHARGE CONTRIBUTIONS
!             IF(IOCC.LE.NUMO) THEN
!               IF(ICNT.EQ.JCNT.AND.ICK.EQ.JCK) THEN
!                 CKMGRSSUM(ICNT,ICK,1) = CKMGRSSUM(ICNT,ICK,1) + VL+VS
!               ELSEIF(ICNT.EQ.JCNT.AND.ICK.NE.JCK) THEN
!                 CKMGRSSUM(ICNT,ICK,2) = CKMGRSSUM(ICNT,ICK,2) + VL+VS
!               ELSE
!                 CKMGRSSUM(ICNT,ICK,3) = CKMGRSSUM(ICNT,ICK,3) + VL+VS
!               ENDIF
!               CKMGRSSUM(ICNT,ICK,4) = CKMGRSSUM(ICNT,ICK,4) + VL+VS
!             ENDIF
! C
! C         END LOOP OVER FOCK ADDRESSES
!           ENDDO
!         ENDDO
! C
! C       LOOP OVER ORBITAL TYPES
!         DO ICNT=1,NCNT
!           ICK = 0
!           DO IKAP=1,NKAP(ICNT)
!             IKQN = KAPA(IKAP,ICNT)
!             DO IMAG=1,2*IABS(IKQN)
!               ICK = ICK+1
! C
! C             UPDATE GROSS COUNTERS
!               DO IP=1,4
!                 TOT(IOCC,IP) = TOT(IOCC,IP) + CKMGRS(ICNT,ICK,IOCC,IP)
!                 TOTSUM(IP)   = TOTSUM(IP)   + CKMGRS(ICNT,ICK,IOCC,IP)
!               ENDDO
! C
! C             LOOP OVER OVERLAP SET OF ORBITAL TYPES
!               DO JCNT=1,NCNT
!                 JCK = 0
!                 DO JKAP=1,NKAP(JCNT)
!                   JKQN = KAPA(JKAP,JCNT)
!                   DO JMAG=1,2*IABS(JKQN)
!                     JCK = JCK+1
! C
! C                   UPDATE BLOCK COUNTERS
!                     DO IT=1,3
!                       BLC(IOCC,IT) = BLC(IOCC,IT)
!      &                             + CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT)
!                       BLCSUM(IT) = BLCSUM(IT)
!      &                             + CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT)
!                     ENDDO
! C                    
!                   ENDDO
!                 ENDDO
!               ENDDO
! C
!             ENDDO
!           ENDDO
!         ENDDO
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     CONCATENATE NET RESULTS INTO MORE GENERAL GROUPS: CKM -> CK
!       IF(ICKM.EQ.1) GOTO 60
! C
! C     LOOP OVER CKM TYPES
!       DO ICNT=1,NCNT
!         ICK = 0
!         DO IKAP=1,NKAP(ICNT)
!           ICM  = ICK
!           IKQN = KAPA(IKAP,ICNT)
!           DO IMAG=1,2*IABS(IKQN)
!             ICK = ICK+1
! C
! C           INCREASE ICM
!             IF(IMAG.EQ.1) THEN
!               ICM = ICM+1
!               GOTO 51
!             ENDIF
! C
! C           PLACE ALL CONTRIBUTIONS INTO THE FIRST IMAG ENTRY
!             DO IP=1,4
!               DO IOCC=1,NUMO+NUMV
!                 CKMGRS(ICNT,ICM,IOCC,IP) = CKMGRS(ICNT,ICM,IOCC,IP)
!      &                                   + CKMGRS(ICNT,ICK,IOCC,IP)
!               ENDDO
!               CKMGRSSUM(ICNT,ICM,IP) = CKMGRSSUM(ICNT,ICM,IP)
!      &                               + CKMGRSSUM(ICNT,ICK,IP)
!             ENDDO
! C
! 51          CONTINUE
! C
! C           LOOP OVER C'K'M' TYPES
!             DO JCNT=1,NCNT
!               JCK = 0
!               DO JKAP=1,NKAP(JCNT)
!                 JCM  = JCK
!                 JKQN = KAPA(JKAP,JCNT)
!                 DO JMAG=1,2*IABS(JKQN)
!                   JCK = JCK+1
! C
! C                 INCREASE JCM
!                   IF(JMAG.EQ.1) THEN
!                     JCM = JCM+1
!                     IF(IMAG.EQ.1) GOTO 52
!                   ENDIF
! C
! C                 PLACE ALL CONTRIBUTIONS INTO THE FIRST IMAG,JMAG ENTRY
!                   DO IT=1,3
!                     DO IOCC=1,NUMO+NUMV
!                       CKMOVP(ICNT,ICM,JCNT,JCM,IOCC,IT)
!      &                              = CKMOVP(ICNT,ICM,JCNT,JCM,IOCC,IT)
!      &                              + CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT)
!                     ENDDO
!                     CKMOVPSUM(ICNT,ICM,JCNT,JCM,IT)
!      &                                = CKMOVPSUM(ICNT,ICM,JCNT,JCM,IT)
!      &                                + CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT)
!                   ENDDO
! C
! 52                CONTINUE
!                 ENDDO
!               ENDDO
!             ENDDO
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     CONCATENATE NET RESULTS INTO MORE GENERAL GROUPS: CK -> C
!       IF(ICKM.EQ.2) GOTO 60
! C
! C     LOOP OVER CKM TYPES
!       DO ICNT=1,NCNT
!         ICK = 0
!         DO IKAP=1,NKAP(ICNT)
!           IKQN = KAPA(IKAP,ICNT)
!           DO IMAG=1,2*IABS(IKQN)
!             ICK = ICK+1
! C
! C           SKIP FIRST KAPPA CASE AND ALL BUT ONE IMAG
!             IF(IKAP.EQ.1) GOTO 55
!             IF(IMAG.NE.1) GOTO 55
! C
! C           PLACE ALL CONTRIBUTIONS INTO THE FIRST IMAG ENTRY
!             DO IP=1,4
!               DO IOCC=1,NUMO+NUMV
!                 CKMGRS(ICNT,1,IOCC,IP) = CKMGRS(ICNT,1,IOCC,IP)
!      &                                 + CKMGRS(ICNT,ICK,IOCC,IP)
!               ENDDO
!               CKMGRSSUM(ICNT,1,IP) = CKMGRSSUM(ICNT,1,IP)
!      &                             + CKMGRSSUM(ICNT,ICK,IP)
!             ENDDO
! C
! 55          CONTINUE
! C
! C           LOOP OVER C'K'M' TYPES
!             DO JCNT=1,NCNT
!               JCK = 0
!               DO JKAP=1,NKAP(JCNT)
!                 JKQN = KAPA(JKAP,JCNT)
!                 DO JMAG=1,2*IABS(JKQN)
!                   JCK = JCK+1
! C
! C                 SKIP FIRST KAPPA CASES AND ALL BUT ONE IMAG
!                   IF(IKAP.EQ.1.AND.JKAP.EQ.1) GOTO 56
!                   IF(IMAG.NE.1.OR.JMAG.NE.1) GOTO 56
! C
! C                 PLACE ALL CONTRIBUTIONS INTO THE FIRST IMAG,JMAG ENTRY
!                   DO IT=1,3
!                     DO IOCC=1,NUMO+NUMV
!                       CKMOVP(ICNT,1,JCNT,1,IOCC,IT)
!      &                              = CKMOVP(ICNT,1,JCNT,1,IOCC,IT)
!      &                              + CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT)
!                     ENDDO
!                     CKMOVPSUM(ICNT,1,JCNT,1,IT)
!      &                                = CKMOVPSUM(ICNT,1,JCNT,1,IT)
!      &                                + CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT)
!                   ENDDO
! C
! 56                CONTINUE
!                 ENDDO
!               ENDDO
!             ENDDO
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! 60    CONTINUE
! C
! C     FINAL LIST:
! C     WARN USER ABOUT CHARGE TOLERANCE PARAMETER
!       WRITE(6,'(A,ES10.4)') ' Charge contributions above EPS = ',EPS
!       WRITE(7,'(A,ES10.4)') ' Charge contributions above EPS = ',EPS
! C
! C**********************************************************************C
! C     OVERLAP DECOMPOSITION BY ORBITAL                                 C
! C**********************************************************************C
! C
!       WRITE(6,'(/1X,A)') 'Overlap decomposition by orbital'
!       WRITE(7,'(/1X,A)') 'Overlap decomposition by orbital'
!       WRITE(6,'(1X,72("=")/A,7X,A,8X,A,6X,A/1X,72("="))')
!      & ' Orb| C1 E1 κ1  m1  | C2 E2 κ2  m2  |','Q_LL','Q_SS |','Q_net'
!       WRITE(7,'(1X,72("=")/A,7X,A,8X,A,6X,A/1X,72("="))')
!      & ' Orb| C1 E1 κ1  m1  | C2 E2 κ2  m2  |','Q_LL','Q_SS |','Q_net'
! C
! C     LOOP OVER ALL ORBITALS
!       DO IOCC=1,NUMO+NUMV
! C
! C       SPECIAL SEPARATOR FOR VIRTUAL SPINORS
!         IF(IOCC.EQ.NUMO+1) THEN
!           WRITE(6,'(/1X,72("*")/28X,A/1X,72("*"))') 'Virtual spinors'
!           WRITE(7,'(/1X,72("*")/28X,A/1X,72("*"))') 'Virtual spinors'
!         ENDIF
! C
! C       LOOP OVER CENTRES AND KAPPAS
!         WRITE(IORB,'(I3)') IOCC
!         ICR = 0
!         DO ICNT=1,NCNT
!           ICS = 0
!           ICK = 0
!           DO IKAP=1,NKAP(ICNT)
!             ICT = 0
!             IKQN = KAPA(IKAP,ICNT)
!             DO IMAG=1,2*IABS(IKQN)
! C
! C             UPDATE (KQN,MQN) COUNTER
!               ICK = ICK+1
! C
! C             SKIP DEPENDING ON DECOMPOSITION TYPE
!               IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 71
!               IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 71
! C
! C             SKIP NEGLIGIBLE ENTRIES
!               X = CKMOVP(ICNT,ICK,ICNT,ICK,IOCC,3)
!               IF(DABS(X).GT.EPS) THEN
! C
! C               UPDATE COUNTERS
!                 ICR = ICR+1
!                 ICS = ICS+1
!                 ICT = ICT+1
! C
! C               WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
!                 IF(ICS.EQ.1) THEN
!                   WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
!      &             ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
!                 ELSEIF(ICT.EQ.1) THEN
!                   WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
!                 ELSE
!                   WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
!                 ENDIF
!                 WRITE(CEKM2,'(A)') ''
! C
! C               CROP CEKM IF ICKM IS 2 OR 3 
!                 IF(ICKM.EQ.2) THEN
!                   WRITE(CEKM1,'(A)') CEKM1(1:8)
!                   WRITE(CEKM2,'(A)') CEKM2(1:8)
!                 ELSEIF(ICKM.EQ.3) THEN
!                   WRITE(CEKM1,'(A)') CEKM1(1:6)
!                   WRITE(CEKM2,'(A)') CEKM2(1:6)
!                 ENDIF
! C
! C               PRINT TO TERMINAL
!                 WRITE(6,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
!      &                           IORB//'| '//CEKM1//'|'//CEKM2//' |',
!      &                      (CKMOVP(ICNT,ICK,ICNT,ICK,IOCC,IT),IT=1,3)
!                 WRITE(7,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
!      &                           IORB//'| '//CEKM1//'|'//CEKM2//' |',
!      &                      (CKMOVP(ICNT,ICK,ICNT,ICK,IOCC,IT),IT=1,3)
! C
! C               IORB NOT NEEDED ANY MORE
!                 IORB = '   '
! C
!               ENDIF
! C
! 71            CONTINUE
! C
!             ENDDO
!           ENDDO
!         ENDDO
! C
! C       START COUNTER AND LOOP OVER CENTRES AND KAPPA PAIRS
!         ICR = 0
!         DO ICNT=1,NCNT
!           ICS = 0
!           ICK = 0
!           DO IKAP=1,NKAP(ICNT)
!             ICT  = 0
!             IKQN = KAPA(IKAP,ICNT)
!             DO IMAG=1,2*IABS(IKQN)
! C
! C             UPDATE (IKQN,IMQN) COUNTER
!               ICK = ICK+1
! C
! C             SKIP DEPENDING ON DECOMPOSITION TYPE
!               IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 72
!               IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 72
! C
!               JCS = 0
!               JCK = 0
!               DO JKAP=1,NKAP(ICNT)
!                 JCT  = 0
!                 JKQN = KAPA(JKAP,ICNT)
!                 DO JMAG=1,2*IABS(JKQN)
! C
! C                 UPDATE (JKQN,JMQN) COUNTER
!                   JCK = JCK+1
! C
!                   IF(IKAP.EQ.JKAP.AND.IMAG.EQ.JMAG) GOTO 73
! C
! C                 SKIP DEPENDING ON DECOMPOSITION TYPE
!                   IF(ICKM.GE.2.AND.JMAG.NE.1) GOTO 73
!                   IF(ICKM.EQ.3.AND.JKAP.NE.1) GOTO 73
! C
! C                 SKIP NEGLIGIBLE OR NON-ALLOWED ENTRIES
!                   X = CKMOVP(ICNT,ICK,ICNT,JCK,IOCC,3)
!                   IF(DABS(X).GT.EPS) THEN
! C
! C                   UPDATE COUNTERS
!                     ICR = ICR+1
!                     ICS = ICS+1
!                     ICT = ICT+1
!                     JCS = JCS+1
!                     JCT = JCT+1
! C
! C                   SEPARATOR
!                     IF(ICR.EQ.1) THEN
!                       WRITE(6, *) REPEAT('-',72)
!                       WRITE(7, *) REPEAT('-',72)
!                     ENDIF
! C
! C                   WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
!                     IF(ICS.EQ.1) THEN
!                       WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
!                     ELSEIF(ICT.EQ.1) THEN
!                       WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
!                     ELSEIF(JCS.EQ.1) THEN
!                       WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
!                     ELSEIF(JCT.EQ.1) THEN
!                       WRITE(CEKM1,'(A)') 
!                     ENDIF
! C
!                     IF(JCT.EQ.1) THEN
!                       WRITE(CEKM2,'(6X,A,1X,A)') KLAB(JKQN),MLAB(JMAG)
!                     ELSE
!                       WRITE(CEKM2,'(9X,A)') MLAB(JMAG)
!                     ENDIF
! C
! C                   CROP CEKM IF ICKM IS 2 OR 3 
!                     IF(ICKM.EQ.2) THEN
!                       WRITE(CEKM1,'(A)') CEKM1(1:8)
!                       WRITE(CEKM2,'(A)') CEKM2(1:8)
!                     ELSEIF(ICKM.EQ.3) THEN
!                       WRITE(CEKM1,'(A)') CEKM1(1:6)
!                       WRITE(CEKM2,'(A)') CEKM2(1:6)
!                     ENDIF
! C
! C                   PRINT TO TERMINAL
!                     WRITE(6,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
!      &                             IORB//'| '//CEKM1//'|'//CEKM2//' |',
!      &                       (CKMOVP(ICNT,ICK,ICNT,JCK,IOCC,IT),IT=1,3)
!                     WRITE(7,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
!      &                             IORB//'| '//CEKM1//'|'//CEKM2//' |',
!      &                       (CKMOVP(ICNT,ICK,ICNT,JCK,IOCC,IT),IT=1,3)
! C
!                   ENDIF
! C
! 73                CONTINUE
! C
!                 ENDDO
!               ENDDO
! C
! 72            CONTINUE
! C
!             ENDDO            
!           ENDDO
!         ENDDO
! C
! C       LOOP OVER CENTRES AND KAPPAS
!         ICR = 0
!         DO ICNT=1,NCNT
!           ICS = 0
!           ICK = 0
!           DO IKAP=1,NKAP(ICNT)
!             ICT = 0
!             IKQN = KAPA(IKAP,ICNT)
!             DO IMAG=1,2*IABS(IKQN)
! C
! C             UPDATE (IKQN,IMQN) COUNTER
!               ICK = ICK+1
! C
! C             SKIP DEPENDING ON DECOMPOSITION TYPE
!               IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 74
!               IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 74
! C
!               JCR = 0
!               DO JCNT=1,NCNT
!                 IF(ICNT.EQ.JCNT) GOTO 100
!                 JCS = 0
!                 JCK = 0
!                 DO JKAP=1,NKAP(JCNT)
!                   JCT = 0
!                   JKQN = KAPA(JKAP,JCNT)
!                   DO JMAG=1,2*IABS(JKQN)
! C
! C                   UPDATE (JKQN,JMQN) COUNTER
!                     JCK = JCK+1
! C
! C                   SKIP DEPENDING ON DECOMPOSITION TYPE
!                     IF(ICKM.GE.2.AND.JMAG.NE.1) GOTO 75
!                     IF(ICKM.EQ.3.AND.JKAP.NE.1) GOTO 75
! C
! C                   SKIP NEGLIGIBLE ENTRIES
!                     X = CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,3)
!                     IF(DABS(X).GT.EPS) THEN
! C
! C                     UPDATE COUNTERS
!                       ICR = ICR+1
!                       ICS = ICS+1
!                       ICT = ICT+1
!                       JCR = JCR+1
!                       JCS = JCS+1
!                       JCT = JCT+1
                      
!                       IF(ICR.EQ.1) THEN
!                         WRITE(6, *) REPEAT('-',72)
!                         WRITE(7, *) REPEAT('-',72)
!                       ENDIF
! C
! C                     WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
!                       IF(ICS.EQ.1) THEN
!                         WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
!                       ELSEIF(ICT.EQ.1) THEN
!                         WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
!                       ELSEIF(JCR.EQ.1) THEN
!                         WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
!                       ELSE
!                         WRITE(CEKM1,'(A)') 
!                       ENDIF

!                       IF(JCS.EQ.1) THEN
!                         WRITE(CEKM2,'(I2,1X,A,1X,A,1X,A)') JCNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(JCNT)))),KLAB(JKQN),MLAB(JMAG)
!                       ELSEIF(JCT.EQ.1) THEN
!                         WRITE(CEKM2,'(6X,A,1X,A)') KLAB(JKQN),MLAB(JMAG)
!                       ELSE
!                         WRITE(CEKM2,'(9X,A)') MLAB(JMAG)
!                       ENDIF
! C
! C                     CROP CEKM IF ICKM IS 2 OR 3 
!                       IF(ICKM.EQ.2) THEN
!                         WRITE(CEKM1,'(A)') CEKM1(1:8)
!                         WRITE(CEKM2,'(A)') CEKM2(1:8)
!                       ELSEIF(ICKM.EQ.3) THEN
!                         WRITE(CEKM1,'(A)') CEKM1(1:6)
!                         WRITE(CEKM2,'(A)') CEKM2(1:6)
!                       ENDIF
! C
! C                     PRINT TO TERMINAL
!                       WRITE(6,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
!      &                             IORB//'| '//CEKM1//'| '//CEKM2//'|',
!      &                       (CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT),IT=1,3)
!                       WRITE(7,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
!      &                             IORB//'| '//CEKM1//'| '//CEKM2//'|',
!      &                       (CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT),IT=1,3)
! C
!                     ENDIF
! C
! 75                  CONTINUE
! C
!                   ENDDO
!                 ENDDO
! 100             CONTINUE
!               ENDDO
! C
! 74            CONTINUE
! C
!             ENDDO
!           ENDDO
!         ENDDO
! C
! C       QUOTE TOTAL FOR THIS ORBITAL
!         WRITE(6,'(1X,72("-")/1X,I3,A,25X,A,2(F11.8,1X),"|",F11.8/1X,A)') 
!      &          IOCC,'| Total','|',(BLC(IOCC,IT),IT=1,3),REPEAT('=',72)
!         WRITE(7,'(1X,72("-")/1X,I3,A,25X,A,2(F11.8,1X),"|",F11.8/1X,A)') 
!      &          IOCC,'| Total','|',(BLC(IOCC,IT),IT=1,3),REPEAT('=',72)
! C
! C     END LOOP OVER LISTED ORBITALS
!       ENDDO
! C
! C**********************************************************************C
! C     GROSS CHARGE BY ORBITAL                                          C
! C**********************************************************************C
! C
!       WRITE(6,'(/1X,A)') 'Gross charges by orbital'
!       WRITE(7,'(/1X,A)') 'Gross charges by orbital'
!       WRITE(6,'(1X,72("=")/1X,A,3X,A,2X,A,7X,A,6X,A,8X,A/1X,72("="))')
!      &  'Orb.|  C  E κ   m','|','Dirac orb.','Hybrid','Bonding','Gross'
!       WRITE(7,'(1X,72("=")/1X,A,3X,A,2X,A,7X,A,6X,A,8X,A/1X,72("="))')
!      &  'Orb.|  C  E κ   m','|','Dirac orb.','Hybrid','Bonding','Gross'
! C
! C     LOOP OVER ALL ORBITALS
!       DO IOCC=1,NUMO+NUMV
! C
! C       STRING TITLE FOR THIS IOCC
!         WRITE(IORB,'(I3)') IOCC
! C
! C       LOOP OVER CENTRES AND KAPPAS
!         DO ICNT=1,NCNT
!           ICR = 0
!           ICK = 0
!           DO IKAP=1,NKAP(ICNT)
!             ICS  = 0
!             IKQN = KAPA(IKAP,ICNT)
!             DO IMAG=1,2*IABS(IKQN)
!               ICT = 0
! C
! C             UPDATE (IKQN,IMQN) COUNTER
!               ICK = ICK+1
! C
! C             SKIP DEPENDING ON DECOMPOSITION TYPE
!               IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 76
!               IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 76
! C
! C             SKIP NEGLIGIBLE ENTRIES
!               IF(DABS(CKMGRS(ICNT,ICK,IOCC,4)).GT.EPS) THEN
! C
! C               UPDATE COUNTERS
!                 ICR = ICR+1
!                 ICS = ICS+1
!                 ICT = ICT+1
! C
! C               WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
!                 IF(ICR.EQ.1) THEN
!                   WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
!                 ELSEIF(ICS.EQ.1) THEN
!                   WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
!                 ELSEIF(ICT.EQ.1) THEN
!                   WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
!                 ELSE
!                   WRITE(CEKM1,'(A)') 
!                 ENDIF
! C
! C               CROP CEKM IF ICKM IS 2 OR 3 
!                 IF(ICKM.EQ.2) THEN
!                   WRITE(CEKM1,'(A)') CEKM1(1:8)
!                 ELSEIF(ICKM.EQ.3) THEN
!                   WRITE(CEKM1,'(A)') CEKM1(1:6)
!                 ENDIF
! C
! C               PRINT TO TERMINAL
!                 WRITE(6,'(1X,A,"|",F12.8,3(F13.8))') 
!      &             IORB//' | '//CEKM1,(CKMGRS(ICNT,ICK,IOCC,IP),IP=1,4)
!                 WRITE(7,'(1X,A,"|",F12.8,3(F13.8))') 
!      &             IORB//' | '//CEKM1,(CKMGRS(ICNT,ICK,IOCC,IP),IP=1,4)
! C
! C               NO LONGER NEED IORB LABEL
!                 WRITE(IORB,'(A)')
! C
!               ENDIF
! C
! 76            CONTINUE
! C
!             ENDDO
!           ENDDO
!         ENDDO
! C
! C       QUOTE TOTAL FOR THIS ORBITAL
!         WRITE(6,'(1X,72("-")/1X,I3,A,9X,A,F12.8,3(F13.8)/1X,72("="))')
!      &                        IOCC,' | Total','|',(TOT(IOCC,IP),IP=1,4)
!         WRITE(7,'(1X,72("-")/1X,I3,A,9X,A,F12.8,3(F13.8)/1X,72("="))')
!      &                        IOCC,' | Total','|',(TOT(IOCC,IP),IP=1,4)
! C
! C     END LOOP OVER ALL ORBITALS
!       ENDDO
! C
! C**********************************************************************C
! C     OVERLAP DECOMPOSITION FOR WHOLE SYSTEM                           C
! C**********************************************************************C
! C
!       WRITE(6,'(/1X,A)') 'Overlap decomposition for molecule'
!       WRITE(7,'(/1X,A)') 'Overlap decomposition for molecule'
!       WRITE(6,'(1X,75("=")/4X,A,8X,A,9X,A,7X,A/1X,75("="))')
!      &     '| C1 E1 κ1  m1  | C2 E2 κ2  m2  |','Q_LL','Q_SS |','Q_net'
!       WRITE(7,'(1X,75("=")/4X,A,8X,A,9X,A,7X,A/1X,75("="))')
!      &     '| C1 E1 κ1  m1  | C2 E2 κ2  m2  |','Q_LL','Q_SS |','Q_net'
! C
! C     LOOP OVER CENTRES AND KAPPAS
!       ICR = 0
!       DO ICNT=1,NCNT
!         ICS = 0
!         ICK = 0
!         DO IKAP=1,NKAP(ICNT)
!           ICT = 0
!           IKQN = KAPA(IKAP,ICNT)
!           DO IMAG=1,2*IABS(IKQN)
! C
! C           UPDATE (KQN,MQN) COUNTER
!             ICK = ICK+1
! C
! C           SKIP DEPENDING ON DECOMPOSITION TYPE
!             IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 77
!             IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 77
! C
! C           SKIP NEGLIGIBLE ENTRIES
!             X = CKMOVPSUM(ICNT,ICK,ICNT,ICK,3)
!             IF(DABS(X).GT.EPS) THEN
! C
! C             UPDATE COUNTERS
!               ICR = ICR+1
!               ICS = ICS+1
!               ICT = ICT+1
! C
! C             WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
!               IF(ICS.EQ.1) THEN
!                 WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
!               ELSEIF(ICT.EQ.1) THEN
!                 WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
!               ELSE
!                 WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
!               ENDIF
!               WRITE(CEKM2,'(A)') ''
! C
! C             CROP CEKM IF ICKM IS 2 OR 3 
!               IF(ICKM.EQ.2) THEN
!                 WRITE(CEKM1,'(A)') CEKM1(1:8)
!               ELSEIF(ICKM.EQ.3) THEN
!                 WRITE(CEKM1,'(A)') CEKM1(1:6)
!               ENDIF
! C
! C             PRINT TO TERMINAL
!               WRITE(6,'(4X,A,F12.8,1X,F12.8," |",F12.8)')
!      &                                   '| '//CEKM1//'|'//CEKM2//' |',
!      &                         (CKMOVPSUM(ICNT,ICK,ICNT,ICK,IT),IT=1,3)
!               WRITE(7,'(4X,A,F12.8,1X,F12.8," |",F12.8)')
!      &                                   '| '//CEKM1//'|'//CEKM2//' |',
!      &                         (CKMOVPSUM(ICNT,ICK,ICNT,ICK,IT),IT=1,3)
! C
!             ENDIF
! C
! 77          CONTINUE
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     START COUNTER AND LOOP OVER CENTRES AND KAPPA PAIRS
!       ICR = 0
!       DO ICNT=1,NCNT
!         ICS = 0
!         ICK = 0
!         DO IKAP=1,NKAP(ICNT)
!           ICT  = 0
!           IKQN = KAPA(IKAP,ICNT)
!           DO IMAG=1,2*IABS(IKQN)
! C
! C           UPDATE (IKQN,IMQN) COUNTER
!             ICK = ICK+1
! C
! C           SKIP DEPENDING ON DECOMPOSITION TYPE
!             IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 78
!             IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 78
! C
!             JCS = 0
!             JCK = 0
!             DO JKAP=1,NKAP(ICNT)
!               JCT  = 0
!               JKQN = KAPA(JKAP,ICNT)
!               DO JMAG=1,2*IABS(JKQN)
! C
! C               UPDATE (JKQN,JMQN) COUNTER
!                 JCK = JCK+1
! C
!                 IF(IKAP.EQ.JKAP.AND.IMAG.EQ.JMAG) GOTO 79
! C
! C               SKIP DEPENDING ON DECOMPOSITION TYPE
!                 IF(ICKM.GE.2.AND.JMAG.NE.1) GOTO 79
!                 IF(ICKM.EQ.3.AND.JKAP.NE.1) GOTO 79
! C
! C               SKIP NEGLIGIBLE OR NON-ALLOWED ENTRIES
!                 X = CKMOVPSUM(ICNT,ICK,ICNT,JCK,3)
!                 IF(DABS(X).GT.EPS) THEN
! C
! C                 UPDATE COUNTERS
!                   ICR = ICR+1
!                   ICS = ICS+1
!                   ICT = ICT+1
!                   JCS = JCS+1
!                   JCT = JCT+1
! C
! C                 SEPARATOR
!                   IF(ICR.EQ.1) THEN
!                     WRITE(6, *) REPEAT('-',75)
!                     WRITE(7, *) REPEAT('-',75)
!                   ENDIF
! C
! C                 WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
!                   IF(ICS.EQ.1) THEN
!                     WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
!                   ELSEIF(ICT.EQ.1) THEN
!                     WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
!                   ELSEIF(JCS.EQ.1) THEN
!                     WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
!                   ELSEIF(JCT.EQ.1) THEN
!                     WRITE(CEKM1,'(A)') 
!                   ENDIF
! C
!                   IF(JCT.EQ.1) THEN
!                     WRITE(CEKM2,'(6X,A,1X,A)') KLAB(JKQN),MLAB(JMAG)
!                   ELSE
!                     WRITE(CEKM2,'(9X,A)') MLAB(JMAG)
!                   ENDIF
! C
! C                 CROP CEKM IF ICKM IS 2 OR 3 
!                   IF(ICKM.EQ.2) THEN
!                     WRITE(CEKM1,'(A)') CEKM1(1:8)
!                     WRITE(CEKM2,'(A)') CEKM2(1:8)
!                   ELSEIF(ICKM.EQ.3) THEN
!                     WRITE(CEKM1,'(A)') CEKM1(1:6)
!                     WRITE(CEKM2,'(A)') CEKM2(1:6)
!                   ENDIF
! C
! C                 PRINT TO TERMINAL
!                   WRITE(6,'(4X,A,F12.8,1X,F12.8," |",F12.8)')
!      &                                   '| '//CEKM1//'|'//CEKM2//' |',
!      &                         (CKMOVPSUM(ICNT,ICK,ICNT,JCK,IT),IT=1,3)
!                   WRITE(7,'(4X,A,F12.8,1X,F12.8," |",F12.8)')
!      &                                   '| '//CEKM1//'|'//CEKM2//' |',
!      &                         (CKMOVPSUM(ICNT,ICK,ICNT,JCK,IT),IT=1,3)
! C
!                 ENDIF
! C
! 79              CONTINUE
! C
!               ENDDO
!             ENDDO
! C
! 78          CONTINUE
! C
!           ENDDO            
!         ENDDO
!       ENDDO
! C
! C     LOOP OVER CENTRES AND KAPPAS
!       ICR = 0
!       DO ICNT=1,NCNT
!         ICS = 0
!         ICK = 0
!         DO IKAP=1,NKAP(ICNT)
!           ICT = 0
!           IKQN = KAPA(IKAP,ICNT)
!           DO IMAG=1,2*IABS(IKQN)
! C
! C           UPDATE (IKQN,IMQN) COUNTER
!             ICK = ICK+1
! C
! C           SKIP DEPENDING ON DECOMPOSITION TYPE
!             IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 80
!             IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 80
! C
!             JCR = 0
!             DO JCNT=1,NCNT
!               IF(ICNT.EQ.JCNT) GOTO 101
!               JCS = 0
!               JCK = 0
!               DO JKAP=1,NKAP(JCNT)
!                 JCT = 0
!                 JKQN = KAPA(JKAP,JCNT)
!                 DO JMAG=1,2*IABS(JKQN)
! C
! C                 UPDATE (JKQN,JMQN) COUNTER
!                   JCK = JCK+1
! C
! C                 SKIP DEPENDING ON DECOMPOSITION TYPE
!                   IF(ICKM.GE.2.AND.JMAG.NE.1) GOTO 81
!                   IF(ICKM.EQ.3.AND.JKAP.NE.1) GOTO 81
! C
! C                 SKIP NEGLIGIBLE ENTRIES
!                   X = CKMOVPSUM(ICNT,ICK,JCNT,JCK,3)
!                   IF(DABS(X).GT.EPS) THEN
! C
! C                   UPDATE COUNTERS
!                     ICR = ICR+1
!                     ICS = ICS+1
!                     ICT = ICT+1
!                     JCR = JCR+1
!                     JCS = JCS+1
!                     JCT = JCT+1
                      
!                     IF(ICR.EQ.1) THEN
!                       WRITE(6, *) REPEAT('-',75)
!                       WRITE(7, *) REPEAT('-',75)
!                     ENDIF
! C
! C                   WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
!                     IF(ICS.EQ.1) THEN
!                       WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
!                     ELSEIF(ICT.EQ.1) THEN
!                       WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
!                     ELSEIF(JCR.EQ.1) THEN
!                       WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
!                     ELSE
!                       WRITE(CEKM1,'(A)') 
!                     ENDIF

!                     IF(JCS.EQ.1) THEN
!                       WRITE(CEKM2,'(I2,1X,A,1X,A,1X,A)') JCNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(JCNT)))),KLAB(JKQN),MLAB(JMAG)
!                     ELSEIF(JCT.EQ.1) THEN
!                       WRITE(CEKM2,'(6X,A,1X,A)') KLAB(JKQN),MLAB(JMAG)
!                     ELSE
!                       WRITE(CEKM2,'(9X,A)') MLAB(JMAG)
!                     ENDIF
! C
! C                   CROP CEKM IF ICKM IS 2 OR 3 
!                     IF(ICKM.EQ.2) THEN
!                       WRITE(CEKM1,'(A)') CEKM1(1:8)
!                       WRITE(CEKM2,'(A)') CEKM2(1:8)
!                     ELSEIF(ICKM.EQ.3) THEN
!                       WRITE(CEKM1,'(A)') CEKM1(1:6)
!                       WRITE(CEKM2,'(A)') CEKM2(1:6)
!                     ENDIF
! C
! C                   PRINT TO TERMINAL
!                     WRITE(6,'(4X,A,F12.8,1X,F12.8," |",F12.8)')
!      &                                   '| '//CEKM1//'| '//CEKM2//'|',
!      &                         (CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT),IT=1,3)
!                     WRITE(7,'(4X,A,F12.8,1X,F12.8," |",F12.8)')
!      &                                   '| '//CEKM1//'| '//CEKM2//'|',
!      &                         (CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT),IT=1,3)
! C
!                   ENDIF
! C
! 81                CONTINUE
! C
!                 ENDDO
!               ENDDO
! 101           CONTINUE
!             ENDDO
! C
! 80          CONTINUE
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     QUOTE TOTAL FOR THIS ORBITAL
!       WRITE(6,'(1X,75("-")/4X,A,25X,A,2(F12.8,1X),"|",F12.8/1X,A)') 
!      &                 '| Total','|',(BLCSUM(IT),IT=1,3),REPEAT('=',75)
!       WRITE(7,'(1X,75("-")/4X,A,25X,A,2(F12.8,1X),"|",F12.8/1X,A)') 
!      &                 '| Total','|',(BLCSUM(IT),IT=1,3),REPEAT('=',75)
! C
! C**********************************************************************C
! C     GROSS CHARGE FOR MOLECULE                                        C
! C**********************************************************************C
! C
!       WRITE(6,'(/1X,A)') 'Gross charges by orbital'
!       WRITE(7,'(/1X,A)') 'Gross charges by orbital'
!       WRITE(6,'(1X,72("=")/5X,A,3X,A,2X,A,7X,A,6X,A,8X,A/1X,72("="))')
!      &      '|  C  E κ   m','|','Dirac orb.','Hybrid','Bonding','Gross'
!       WRITE(7,'(1X,72("=")/5X,A,3X,A,2X,A,7X,A,6X,A,8X,A/1X,72("="))')
!      &      '|  C  E κ   m','|','Dirac orb.','Hybrid','Bonding','Gross'
! C
! C     LOOP OVER CENTRES AND KAPPAS
!       DO ICNT=1,NCNT
!         ICR = 0
!         ICK = 0
!         DO IKAP=1,NKAP(ICNT)
!           ICS  = 0
!           IKQN = KAPA(IKAP,ICNT)
!           DO IMAG=1,2*IABS(IKQN)
!             ICT = 0
! C
! C           UPDATE (IKQN,IMQN) COUNTER
!             ICK = ICK+1
! C
! C           SKIP DEPENDING ON DECOMPOSITION TYPE
!             IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 82
!             IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 82
! C
! C           SKIP NEGLIGIBLE ENTRIES
!             IF(DABS(CKMGRSSUM(ICNT,ICK,4)).GT.EPS) THEN
! C
! C             UPDATE COUNTERS
!               ICR = ICR+1
!               ICS = ICS+1
!               ICT = ICT+1
! C
! C             WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
!               IF(ICR.EQ.1) THEN
!                 WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
!      &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
!               ELSEIF(ICS.EQ.1) THEN
!                 WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
!               ELSEIF(ICT.EQ.1) THEN
!                 WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
!               ELSE
!                 WRITE(CEKM1,'(A)') 
!               ENDIF
! C
! C             CROP CEKM IF ICKM IS 2 OR 3 
!               IF(ICKM.EQ.2) THEN
!                 WRITE(CEKM1,'(A)') CEKM1(1:8)
!               ELSEIF(ICKM.EQ.3) THEN
!                 WRITE(CEKM1,'(A)') CEKM1(1:6)
!               ENDIF
! C
! C             PRINT TO TERMINAL
!               WRITE(6,'(5X,A,"|",F12.8,3(F13.8))') 
!      &                      '| '//CEKM1,(CKMGRSSUM(ICNT,ICK,IP),IP=1,4)
!               WRITE(7,'(5X,A,"|",F12.8,3(F13.8))') 
!      &                      '| '//CEKM1,(CKMGRSSUM(ICNT,ICK,IP),IP=1,4)
! C
!             ENDIF
! C
! 82          CONTINUE
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     QUOTE TOTAL FOR THIS ORBITAL
!       WRITE(6,'(1X,72("-")/5X,A,9X,A,F12.8,3(F13.8)/1X,72("=")/)')
!      &                                '| Total','|',(TOTSUM(IP),IP=1,4)
!       WRITE(7,'(1X,72("-")/5X,A,9X,A,F12.8,3(F13.8)/1X,72("=")/)')
!      &                                '| Total','|',(TOTSUM(IP),IP=1,4)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE ORTHGNL
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     OOOOOO  RRRRRRR TTTTTTTT HH    HH  GGGGGG  NN    NN LL           C
! C    OO    OO RR    RR   TT    HH    HH GG    GG NNN   NN LL           C
! C    OO    OO RR    RR   TT    HH    HH GG       NNNN  NN LL           C
! C    OO    OO RR    RR   TT    HHHHHHHH GG       NN NN NN LL           C
! C    OO    OO RRRRRRR    TT    HH    HH GG   GGG NN  NNNN LL           C
! C    OO    OO RR    RR   TT    HH    HH GG    GG NN   NNN LL           C
! C     OOOOOO  RR    RR   TT    HH    HH  GGGGGG  NN    NN LLLLLLLL     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  ORTHGNL PERFORMS A MOLECULAR ORTHOGONALITY ANALYSIS.                C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 E1(5)
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VMOMNT0(OLAPLL,1,0,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT0(OLAPSS,4,0,1,2)
!       ENDIF
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Direct overlap analysis:'
!       WRITE(7, *) 'Direct overlap analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(1X,A,F15.10)
!       WRITE(6,20) 'Occupation number = ',DREAL(E1(5))
!       WRITE(7,20) 'Occupation number = ',DREAL(E1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCMNPL_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCMNPL_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
!           CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! C     MAXIMUM PERTURBATIVE ORDER
!       NORD = 1
! C
! 40    FORMAT(1X,A,I3)
!       WRITE(6,40) 'Goldstone diagram values for IOCC = ',IOCC
!       WRITE(7,40) 'Goldstone diagram values for IOCC = ',IOCC
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO V1
!       CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE RELKNTC
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    RRRRRRR  EEEEEEEE LL       KK    KK NN    NN TTTTTTTT CCCCCC      C
! C    RR    RR EE       LL       KK   KK  NNN   NN    TT   CC    CC     C
! C    RR    RR EE       LL       KK  KK   NNNN  NN    TT   CC           C
! C    RR    RR EEEEEE   LL       KKKKK    NN NN NN    TT   CC           C
! C    RRRRRRR  EE       LL       KK  KK   NN  NNNN    TT   CC           C
! C    RR    RR EE       LL       KK   KK  NN   NNN    TT   CC    CC     C
! C    RR    RR EEEEEEEE LLLLLLLL KK    KK NN    NN    TT    CCCCCC      C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  RELKNTC CALCULATES THE EXPECATION VALUE FOR RELATIVISTIC KINETIC    C
! C  ENERGY (CARTESIAN REDUCTION), USING THE MOMENTUM OPERATOR DIRECTLY. C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 VX1(MDM,MDM,5),VY1(MDM,MDM,5),VZ1(MDM,MDM,5),
!      &           EMPTY(MDM,MDM)
!       COMPLEX*16 PLSX(MDM,MDM),PLSY(MDM,MDM),PLSZ(MDM,MDM),
!      &           PSLX(MDM,MDM),PSLY(MDM,MDM),PSLZ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In RELKNTC: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In RELKNTC: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE RAW MATRIX ELEMENTS σ_IX.∇_IX (FIRST DERIV)
!       CALL VMOM0DV(PLSX,2,1,1,1,2)
!       CALL VMOM0DV(PLSY,2,2,2,1,2)
!       CALL VMOM0DV(PLSZ,2,3,3,1,2)
! C
!       CALL VMOM0DV(PSLX,3,1,1,1,2)
!       CALL VMOM0DV(PSLY,3,2,2,1,2)
!       CALL VMOM0DV(PSLZ,3,3,3,1,2)
! C
! C     CONSTRUCT KINETIC MATRIX ELEMENTS (p -> -ⅈℏ∇)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         KINETIC BLOCK LS
!           PLSX(I,J) =-CONE*CV*PLSX(I,J)
!           PLSY(I,J) =-CONE*CV*PLSY(I,J)
!           PLSZ(I,J) =-CONE*CV*PLSZ(I,J)
! C
! C         KINETIC BLOCK SL
!           PSLX(I,J) =-CONE*CV*PSLX(I,J)
!           PSLY(I,J) =-CONE*CV*PSLY(I,J)
!           PSLZ(I,J) =-CONE*CV*PSLZ(I,J)
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Relativistic kinetic energy operator analysis:'
!       WRITE(7, *) 'Relativistic kinetic energy operator analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(EX1,EMPTY,PLSX,PSLX,EMPTY)
!       CALL PROPRTY(EY1,EMPTY,PLSY,PSLY,EMPTY)
!       CALL PROPRTY(EZ1,EMPTY,PLSZ,PSLZ,EMPTY)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(' <α.p> components = (',F16.10,',',F16.10,',',F16.10,')')
!       WRITE(6,20) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! 30    FORMAT(1X,A,7X,A,8X,A,8X,A,13X,A)
! 31    FORMAT(1X,I3,1X,F16.10,1X,F16.10,1X,F16.10,1X,'|',F16.10)
! 32    FORMAT(1X,'tot',1X,F16.10,1X,F16.10,1X,F16.10,1X,'|',F16.10)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','<α_x.p_x>','<α_y.p_y>','<α_z.p_z>','<α.p>'
!       WRITE(7,30) 'Orb.','<α_x.p_x>','<α_y.p_y>','<α_z.p_z>','<α.p>'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(VX1,EMPTY,PLSX,PSLX,EMPTY,1)
!       CALL RSPT1(VY1,EMPTY,PLSY,PSLY,EMPTY,1)
!       CALL RSPT1(VZ1,EMPTY,PLSZ,PSLZ,EMPTY,1)
! C
! C     COUNTER FOR TOTAL EXPECTATION VALUE      
!       APN = 0.0D0
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       DO IOCC=1,NOCC
! C
! C       WRITE RESULTS TO FILE
!         APX = DREAL(VX1(IOCC+NSKP,IOCC+NSKP,5))
!         APY = DREAL(VY1(IOCC+NSKP,IOCC+NSKP,5))
!         APZ = DREAL(VZ1(IOCC+NSKP,IOCC+NSKP,5))
!         APT = APX+APY+APZ
!         APN = APN + APT
!         WRITE(6,31) IOCC,APX,APY,APZ,APT
!         WRITE(7,31) IOCC,APX,APY,APZ,APT
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     REPEAT TOTAL VALUES
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5)),APN
!       WRITE(7,32) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5)),APN
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE LORBANG
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    LL       OOOOOO  RRRRRRR  BBBBBBB     AA    NN    NN  GGGGGG      C
! C    LL      OO    OO RR    RR BB    BB   AAAA   NNN   NN GG    GG     C
! C    LL      OO    OO RR    RR BB    BB  AA  AA  NNNN  NN GG           C
! C    LL      OO    OO RR    RR BBBBBBB  AA    AA NN NN NN GG           C
! C    LL      OO    OO RRRRRRR  BB    BB AAAAAAAA NN  NNNN GG   GGG     C
! C    LL      OO    OO RR    RR BB    BB AA    AA NN   NNN GG    GG     C
! C    LLLLLLLL OOOOOO  RR    RR BBBBBBB  AA    AA NN    NN  GGGGGG      C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  LORBANG CALCULATES THE ORBITAL ANGULAR MOMENTUM EXPECATION VALUE    C
! C  (CARTESIAN REDUCTION), USING THE MOMENTUM OPERATOR DIRECTLY.        C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION ORIG(3)
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 VX1(MDM,MDM,5),VY1(MDM,MDM,5),VZ1(MDM,MDM,5),
!      &           EMPTY(MDM,MDM)
!       COMPLEX*16 DLLXY(MDM,MDM),DLLXZ(MDM,MDM),DLLYX(MDM,MDM),
!      &           DLLYZ(MDM,MDM),DLLZX(MDM,MDM),DLLZY(MDM,MDM)
!       COMPLEX*16 DSSXY(MDM,MDM),DSSXZ(MDM,MDM),DSSYX(MDM,MDM),
!      &           DSSYZ(MDM,MDM),DSSZX(MDM,MDM),DSSZY(MDM,MDM)
!       COMPLEX*16 VLLX(MDM,MDM),VLLY(MDM,MDM),VLLZ(MDM,MDM),
!      &           VSSX(MDM,MDM),VSSY(MDM,MDM),VSSZ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     DEFINE ORIGIN VECTOR
!       DO IX=1,3
!         ORIG(IX) = 0.0D0
!       ENDDO
! C
! C     GENERATE RAW MATRIX ELEMENTS σ_0.(R_IX).∇_JX (1ST MOMENT DERIV)
!       CALL VMOM1DV(DLLYX,ORIG,1,0,2,1,1,2)
!       CALL VMOM1DV(DLLZX,ORIG,1,0,3,1,1,2)
!       CALL VMOM1DV(DLLXY,ORIG,1,0,1,2,1,2)
!       CALL VMOM1DV(DLLZY,ORIG,1,0,3,2,1,2)
!       CALL VMOM1DV(DLLXZ,ORIG,1,0,1,3,1,2)
!       CALL VMOM1DV(DLLYZ,ORIG,1,0,2,3,1,2)
! C
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOM1DV(DSSYX,ORIG,4,0,2,1,1,2)
!         CALL VMOM1DV(DSSZX,ORIG,4,0,3,1,1,2)
!         CALL VMOM1DV(DSSXY,ORIG,4,0,1,2,1,2)
!         CALL VMOM1DV(DSSZY,ORIG,4,0,3,2,1,2)
!         CALL VMOM1DV(DSSXZ,ORIG,4,0,1,3,1,2)
!         CALL VMOM1DV(DSSYZ,ORIG,4,0,2,3,1,2)
!       ENDIF
! C
! C     CONSTRUCT ORBITAL ANGULAR MOMENTUM MATRIX ELEMENTS (p -> -ⅈℏ∇)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         ORBITAL ANGULAR MOMENTUM BLOCK LL
!           VLLX(I,J) =-CONE*(DLLYZ(I,J)-DLLZY(I,J))
!           VLLY(I,J) =-CONE*(DLLZX(I,J)-DLLXZ(I,J))
!           VLLZ(I,J) =-CONE*(DLLXY(I,J)-DLLYX(I,J))
! C
! C         ORBITAL ANGULAR MOMENTUM BLOCK SS
!           IF(HMLT.NE.'NORL') THEN
!             VSSX(I,J) =-CONE*(DSSYZ(I,J)-DSSZY(I,J))
!             VSSY(I,J) =-CONE*(DSSZX(I,J)-DSSXZ(I,J))
!             VSSZ(I,J) =-CONE*(DSSXY(I,J)-DSSYX(I,J))
!           ENDIF
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Orbital angular momentum operator analysis:'
!       WRITE(7, *) 'Orbital angular momentum operator analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(EX1,VLLX,EMPTY,EMPTY,VSSX)
!       CALL PROPRTY(EY1,VLLY,EMPTY,EMPTY,VSSY)
!       CALL PROPRTY(EZ1,VLLZ,EMPTY,EMPTY,VSSZ)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(' <ℓ> components = (',F17.10,',',F17.10,',',F17.10,')')
!       WRITE(6,20) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! 30    FORMAT(1X,A,11X,A,12X,A,12X,A,' | ',8X,A)
! 31    FORMAT(1X,I3,1X,F16.10,1X,F16.10,1X,F16.10,1X,'|',F16.10)
! 32    FORMAT(1X,'tot',1X,F16.10,1X,F16.10,1X,F16.10,1X,'|',F16.10)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','<ℓ_x>','<ℓ_y>','<ℓ_z>','|<ℓ^2>|'
!       WRITE(7,30) 'Orb.','<ℓ_x>','<ℓ_y>','<ℓ_z>','|<ℓ^2>|'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(VX1,VLLX,EMPTY,EMPTY,VSSX,1)
!       CALL RSPT1(VY1,VLLY,EMPTY,EMPTY,VSSY,1)
!       CALL RSPT1(VZ1,VLLZ,EMPTY,EMPTY,VSSZ,1)
! C
! C     COUNTER FOR TOTAL EXPECTATION VALUE      
!       APN = 0.0D0
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       DO IOCC=1,NOCC
! C
! C       WRITE RESULTS TO FILE
!         APX = DREAL(VX1(IOCC+NSKP,IOCC+NSKP,5))
!         APY = DREAL(VY1(IOCC+NSKP,IOCC+NSKP,5))
!         APZ = DREAL(VZ1(IOCC+NSKP,IOCC+NSKP,5))
!         APT = APX+APY+APZ
!         APN = APN + APT
!         WRITE(6,31) IOCC,APX,APY,APZ,APT
!         WRITE(7,31) IOCC,APX,APY,APZ,APT
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     REPEAT TOTAL VALUES
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5)),APN
!       WRITE(7,32) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5)),APN
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE SPINPRJ
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C       SSSSSS  PPPPPPP IIII NN    NN PPPPPPP  RRRRRRR      JJJJJ      C
! C      SS    SS PP    PP II  NNN   NN PP    PP RR    RR       JJ       C
! C      SS       PP    PP II  NNNN  NN PP    PP RR    RR       JJ       C
! C       SSSSSS  PP    PP II  NN NN NN PP    PP RR    RR       JJ       C
! C            SS PPPPPPP  II  NN  NNNN PPPPPPP  RRRRRRR        JJ       C
! C      SS    SS PP       II  NN   NNN PP       RR    RR JJ    JJ       C
! C       SSSSSS  PP      IIII NN    NN PP       RR    RR  JJJJJJ        C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  SPINPRJ PERFORMS A SPIN-PROJECTION ANALYSIS.                        C
! C -------------------------------------------------------------------- C
! C  TODO: FOR DIATOMIC MOLECULES, Y-COMPONENT LESS RELIABLE THAN X.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       COMPLEX*16 CONE,SUMX,SUMY,SUMZ
!       COMPLEX*16 VX(MDM),VY(MDM),VZ(MDM)
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 PRJXLL(MDM,MDM),PRJXSS(MDM,MDM),
!      &           PRJYLL(MDM,MDM),PRJYSS(MDM,MDM),
!      &           PRJZLL(MDM,MDM),PRJZSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/EIGC/COEF
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C**********************************************************************C
! C     PREPARE MATRIX ELEMENT INTEGRALS                                 C
! C**********************************************************************C
! C
! C     GENERATE DIRECT SPIN PROJECTION MATRICES (ZEROTH MOMENT)
!       CALL VMOMNT0(PRJXLL,1,1,1,2)
!       CALL VMOMNT0(PRJYLL,1,2,1,2)
!       CALL VMOMNT0(PRJZLL,1,3,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT0(PRJXSS,4,1,1,2)
!         CALL VMOMNT0(PRJYSS,4,2,1,2)
!         CALL VMOMNT0(PRJZSS,4,3,1,2)
!       ENDIF
! C
! C**********************************************************************C
! C     COMPUTE EXPECTATION VALUES MANUALLY BECAUSE SPIN EIGENFUNCTIONS  C
! C     ARE NOT THE SAME AS SPATIAL EIGENFUNCTIONS -- NEED LINEAR COMBO. C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Spin projection analysis'
!       WRITE(7, *) 'Spin projection analysis'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! 29    FORMAT(1X,A,I3,A)
! 30    FORMAT(1X,A,2X,3(14X,'E^(',I1,')',A))
! 31    FORMAT(1X,I3,' Re:',F21.9,F22.9,F22.9)
! 32    FORMAT(4X,' Im:',F21.9,F22.9,F22.9)
!       WRITE(6,29) 'Expectation value for each orbital IOCC:'
!       WRITE(7,29) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
!       WRITE(7,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C     LOOP OVER ORBITALS
!       DO IOCC=NSKP+1,NSKP+NOCC+2
! C
! C       SOLUTIONS MUST COUPLE IN KRAMER PAIRS
!         IF(MOD(IOCC,2).EQ.0) THEN
!           NP =-1
!         ELSE
!           NP = 1
!         ENDIF
! C
! C       INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
!         SUMX = DCMPLX(0.0D0,0.0D0)
!         SUMY = DCMPLX(0.0D0,0.0D0)
!         SUMZ = DCMPLX(0.0D0,0.0D0)
! C
! C       LOOP OVER FOCK MATRIX ADDRESSES
!         DO I=1,NDIM-NSKP
!           DO J=1,NDIM-NSKP
! C
! C           LARGE CONTRIBUTIONS
!             SUMX = SUMX+DCONJG(COEF(I,IOCC))*COEF(J,IOCC+NP)*PRJXLL(I,J)
!             SUMY = SUMY+DCONJG(COEF(I,IOCC))*COEF(J,IOCC+NP)*PRJYLL(I,J)
!             SUMZ = SUMZ+DCONJG(COEF(I,IOCC))*COEF(J,IOCC   )*PRJZLL(I,J)
! C
! C           SMALL CONTRIBUTIONS
!             IF(HMLT.EQ.'NORL') GOTO 100
! C
!             K = I+NSKP
!             L = J+NSKP
! C
!             SUMX = SUMX+DCONJG(COEF(K,IOCC))*COEF(L,IOCC+NP)*PRJXSS(I,J)
!             SUMY = SUMY+DCONJG(COEF(K,IOCC))*COEF(L,IOCC+NP)*PRJYSS(I,J)
!             SUMZ = SUMZ+DCONJG(COEF(K,IOCC))*COEF(L,IOCC   )*PRJZSS(I,J)
! C
! 100         CONTINUE
! C
!           ENDDO
!         ENDDO
! C
! C       SAVE SUM
!         VX(IOCC) = SUMX
!         VY(IOCC) =-SUMY*CONE
!         VZ(IOCC) = SUMZ
! C
!       ENDDO
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_SPINPRJ_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=NSKP+1,NSKP+NOCC+2
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
!      &                          DABS(DREAL(VY(IOCC))),
!      &                          DABS(DREAL(VZ(IOCC)))
!           WRITE(7,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
!      &                          DABS(DREAL(VY(IOCC))),
!      &                          DABS(DREAL(VZ(IOCC)))
!           WRITE(8,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
!      &                          DABS(DREAL(VY(IOCC))),
!      &                          DABS(DREAL(VZ(IOCC)))
! C
!           WRITE(6,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
!      &                                      DABS(DIMAG(VZ(IOCC)))
!           WRITE(7,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
!      &                                      DABS(DIMAG(VZ(IOCC)))
!           WRITE(8,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
!      &                                      DABS(DIMAG(VZ(IOCC)))
! C
! C         SEPARATOR FOR VIRTUAL SPECTRUM
!           IF(IOCC.EQ.NSKP+NOCC) THEN
!             WRITE(6, *) REPEAT('=',72)
!             WRITE(7, *) REPEAT('=',72)
!             WRITE(8, *) REPEAT('=',72)
!           ELSEIF(IOCC.LT.NSKP+NOCC+2) THEN
!             WRITE(6, *) REPEAT('-',72)
!             WRITE(7, *) REPEAT('-',72)
!             WRITE(8, *) REPEAT('-',72)
!           ENDIF
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE ELCDIPL
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C       EEEEEEEE LL       CCCCCC  DDDDDDD IIII PPPPPPP  LL             C
! C       EE       LL      CC    CC DD    DD II  PP    PP LL             C
! C       EE       LL      CC       DD    DD II  PP    PP LL             C
! C       EEEEEE   LL      CC       DD    DD II  PP    PP LL             C
! C       EE       LL      CC       DD    DD II  PPPPPPP  LL             C
! C       EE       LL      CC    CC DD    DD II  PP       LL             C
! C       EEEEEEEE LLLLLLLL CCCCCC  DDDDDDD IIII PP       LLLLLLLL       C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  ELCDIPL CALCULATES THE PERMANENT ELECTRIC DIPOLE MOMENT OF THE      C
! C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION ZCNT(3),ECNT(3),QCNT(3),ORIG(3)
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 SUMLL,SUMSS
!       COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
!       COMPLEX*16 VX1(MDM,MDM,5),VY1(MDM,MDM,5),VZ1(MDM,MDM,5)
!       COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
!      &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM),
!      &           EMPTY(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/DENS/DENC,DENO,DENT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     DEFINE ORIGIN VECTOR
!       DO IX=1,3
!         ORIG(IX) = 0.0D0
!       ENDDO
! C
! C**********************************************************************C
! C     CENTRE OF CHARGE COORDINATES                                     C
! C**********************************************************************C
! C
! C     NET NUCLEAR CHARGE
!       ZTOT = 0.0D0
!       DO IZ=1,NCNT
!         ZTOT = ZTOT + ZNUC(IZ)
!       ENDDO
! C
! C     CENTRE OF NUCLEAR CHARGE
!       DO IX=1,3
!         ZCNT(IX) = 0.0D0
!         DO IZ=1,NCNT
!           ZCNT(IX) = ZCNT(IX) + ZNUC(IZ)*BXYZ(IX,IZ)
!         ENDDO
!         ZCNT(IX) = ZCNT(IX)/ZTOT
!       ENDDO
! C
! C     FIRST MOMENT INTEGRALS: X DIRECTION
!       CALL VMOMNT1(DXLL,ORIG,1,0,1,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT1(DXSS,ORIG,4,0,1,1,2)
!       ENDIF
! C
! C     CENTRE OF ELECRON MASS: X DIRECTION
!       SUMLL = DCMPLX(0.0D0,0.0D0)
!       SUMSS = DCMPLX(0.0D0,0.0D0)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           SUMLL = SUMLL + DXLL(I,J)*DENT(I,J)
!           IF(HMLT.NE.'NORL') THEN
!             K = I+NSKP
!             L = J+NSKP
!             SUMSS = SUMSS + DXSS(I,J)*DENT(K,L)
!           ENDIF
!         ENDDO
!       ENDDO
!       ECNT(1) = DREAL(SUMLL+SUMSS)/DFLOAT(NOCC)
! C
! C     FIRST MOMENT INTEGRALS: Y DIRECTION
!       CALL VMOMNT1(DYLL,ORIG,1,0,2,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT1(DYSS,ORIG,4,0,2,1,2)
!       ENDIF
! C
! C     CENTRE OF ELECRON MASS: Y DIRECTION
!       SUMLL = DCMPLX(0.0D0,0.0D0)
!       SUMSS = DCMPLX(0.0D0,0.0D0)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           SUMLL = SUMLL + DYLL(I,J)*DENT(I,J)
!           IF(HMLT.NE.'NORL') THEN
!             K = I+NSKP
!             L = J+NSKP
!             SUMSS = SUMSS + DYSS(I,J)*DENT(K,L)
!           ENDIF
!         ENDDO
!       ENDDO
!       ECNT(2) = DREAL(SUMLL+SUMSS)/DFLOAT(NOCC)
! C
! C     FIRST MOMENT INTEGRALS: Z DIRECTION
!       CALL VMOMNT1(DZLL,ORIG,1,0,3,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT1(DZSS,ORIG,4,0,3,1,2)
!       ENDIF
! C
! C     CENTRE OF ELECRON MASS: Z DIRECTION
!       SUMLL = DCMPLX(0.0D0,0.0D0)
!       SUMSS = DCMPLX(0.0D0,0.0D0)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           SUMLL = SUMLL + DZLL(I,J)*DENT(I,J)
!           IF(HMLT.NE.'NORL') THEN
!             K = I+NSKP
!             L = J+NSKP
!             SUMSS = SUMSS + DZSS(I,J)*DENT(K,L)
!           ENDIF
!         ENDDO
!       ENDDO
!       ECNT(3) = DREAL(SUMLL+SUMSS)/DFLOAT(NOCC)
! C
! C     MOLECULAR CENTRE OF CHARGE (<X>,<Y>,<Z>)
!       QTOT = ZTOT+DFLOAT(NOCC)
!       DO IX=1,3
!         QCNT(IX) = (ZTOT*ZCNT(IX) + NOCC*ECNT(IX))/QTOT
!       ENDDO
! C
! C     PRINT CENTRE OF NUCLEAR CHARGE TO TERMINAL
!       WRITE(6, *) 'Centre of nuclear/electron/total mass:'
!       WRITE(7, *) 'Centre of nuclear/electron/total mass:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! 10    FORMAT(1X,A,' = (',F20.14,',',F20.14,',',F20.14,')')
!       WRITE(6,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
!       WRITE(7,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
!       WRITE(6,10) 'E(IX)',(ECNT(IX),IX=1,3)
!       WRITE(7,10) 'E(IX)',(ECNT(IX),IX=1,3)
!       WRITE(6,10) 'Q(IX)',(QCNT(IX),IX=1,3)
!       WRITE(7,10) 'Q(IX)',(QCNT(IX),IX=1,3)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
!       CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
!       CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
!       CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
! C
!       WRITE(6, *) 'Molecular electric dipole moment (e.a_{0}):'
!       WRITE(7, *) 'Molecular electric dipole moment (e.a_{0}):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! 20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
!       WRITE(6,20) 'd_{e} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) 'd_{e} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
!       WRITE(6, *) 'Molecular electric dipole moment (debye):'
!       WRITE(7, *) 'Molecular electric dipole moment (debye):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
!       DX1R = CDB*DREAL(EX1(5))
!       DY1R = CDB*DREAL(EY1(5))
!       DZ1R = CDB*DREAL(EZ1(5))
! C
!       WRITE(6,20) 'd_{e} = ',DX1R,DY1R,DZ1R
!       WRITE(7,20) 'd_{e} = ',DX1R,DY1R,DZ1R
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
! 31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
! 32    FORMAT(7X,A,1X,F20.14,2X,F20.14,2X,F20.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                            'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                            'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(VX1,DXLL,EMPTY,EMPTY,DXSS,NORD)
!       CALL RSPT1(VY1,DYLL,EMPTY,EMPTY,DYSS,NORD)
!       CALL RSPT1(VZ1,DZLL,EMPTY,EMPTY,DZSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_ELCDIPL_VX.dat',STATUS='UNKNOWN')
!       OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_ELCDIPL_VY.dat',STATUS='UNKNOWN')
!       OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_ELCDIPL_VZ.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(11, *) (VX1(IOCC,JOCC,5),JOCC=1,NDIM)
!           WRITE(12, *) (VY1(IOCC,JOCC,5),JOCC=1,NDIM)
!           WRITE(13, *) (VZ1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=13)
!       CLOSE(UNIT=12)
!       CLOSE(UNIT=11)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCDIPL_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VX1
!           CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VY1
!           CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VZ1
!           CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
      
! C      RETURN
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! C     MAXIMUM PERTURBATIVE ORDER
!       NORD = 4
! C
! 40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
!      &                                                 ' with IX = ',A)
! C
! C     X-COMPONENT
!       WRITE(6,40) IOCC,'X'
!       WRITE(7,40) IOCC,'X'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VX1
!       CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
! C     END X-COMPONENT
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C     Y-COMPONENT
!       WRITE(6,40) IOCC,'Y'
!       WRITE(7,40) IOCC,'Y'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VY1
!       CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
! C     END Y-COMPONENT
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C     Z-COMPONENT
!       WRITE(6,40) IOCC,'Z'
!       WRITE(7,40) IOCC,'Z'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
!       CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
! C     END Z-COMPONENT AND SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE ELCQDPL
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   EEEEEEEE LL       CCCCCC    QQQQQQ    DDDDDDD  PPPPPPP  LL         C
! C   EE       LL      CC    CC  QQ    QQ   DD    DD PP    PP LL         C
! C   EE       LL      CC       QQ      QQ  DD    DD PP    PP LL         C
! C   EEEEEE   LL      CC       QQ      QQ  DD    DD PP    PP LL         C
! C   EE       LL      CC       QQ      QQ  DD    DD PPPPPPP  LL         C
! C   EE       LL      CC    CC  QQ    QQ   DD    DD PP       LL         C
! C   EEEEEEEE LLLLLLLL CCCCCC    QQQQQQ QQ DDDDDDD  PP       LLLLLLLL   C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  ELCQDPL CALCULATES THE PERMANENT ELECTRIC QUADRUPOLE MOMENT OF THE  C
! C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION ZCNT(3),ECNT(3),QCNT(3),ORIG(3)
! C
!       COMPLEX*16 EXX1(5),EYY1(5),EZZ1(5),EXY1(5),EYZ1(5),EXZ1(5)
!       COMPLEX*16 SUMLL,SUMSS
!       COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
!      &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
!       COMPLEX*16 QXXLL(MDM,MDM),QYYLL(MDM,MDM),QZZLL(MDM,MDM),
!      &           QXYLL(MDM,MDM),QYZLL(MDM,MDM),QXZLL(MDM,MDM),
!      &           QXXSS(MDM,MDM),QYYSS(MDM,MDM),QZZSS(MDM,MDM),
!      &           QXYSS(MDM,MDM),QYZSS(MDM,MDM),QXZSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/DENS/DENC,DENO,DENT
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     DEFINE ORIGIN VECTOR
!       DO IX=1,3
!         ORIG(IX) = 0.0D0
!       ENDDO
! C
! C**********************************************************************C
! C     CENTRE OF CHARGE COORDINATES                                     C
! C**********************************************************************C
! C
! C     NET NUCLEAR CHARGE
!       ZTOT = 0.0D0
!       DO IZ=1,NCNT
!         ZTOT = ZTOT + ZNUC(IZ)
!       ENDDO
! C
! C     CENTRE OF NUCLEAR CHARGE
!       DO IX=1,3
!         ZCNT(IX) = 0.0D0
!         DO IZ=1,NCNT
!           ZCNT(IX) = ZCNT(IX) + ZNUC(IZ)*BXYZ(IX,IZ)
!         ENDDO
!         ZCNT(IX) = ZCNT(IX)/ZTOT
!       ENDDO
! C
! C     FIRST MOMENT INTEGRALS: X DIRECTION
!       CALL VMOMNT1(DXLL,ORIG,1,0,1,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT1(DXSS,ORIG,4,0,1,1,2)
!       ENDIF
! C
! C     CENTRE OF ELECRON MASS: X DIRECTION
!       SUMLL = DCMPLX(0.0D0,0.0D0)
!       SUMSS = DCMPLX(0.0D0,0.0D0)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           SUMLL = SUMLL + DXLL(I,J)*DENT(I,J)
!           IF(HMLT.NE.'NORL') THEN
!             K = I+NSKP
!             L = J+NSKP
!             SUMSS = SUMSS + DXSS(I,J)*DENT(K,L)
!           ENDIF
!         ENDDO
!       ENDDO
!       ECNT(1) = DREAL(SUMLL+SUMSS)/DFLOAT(NOCC)
! C
! C     FIRST MOMENT INTEGRALS: Y DIRECTION
!       CALL VMOMNT1(DYLL,ORIG,1,0,2,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT1(DYSS,ORIG,4,0,2,1,2)
!       ENDIF
! C
! C     CENTRE OF ELECRON MASS: Y DIRECTION
!       SUMLL = DCMPLX(0.0D0,0.0D0)
!       SUMSS = DCMPLX(0.0D0,0.0D0)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           SUMLL = SUMLL + DYLL(I,J)*DENT(I,J)
!           IF(HMLT.NE.'NORL') THEN
!             K = I+NSKP
!             L = J+NSKP
!             SUMSS = SUMSS + DYSS(I,J)*DENT(K,L)
!           ENDIF
!         ENDDO
!       ENDDO
!       ECNT(2) = DREAL(SUMLL+SUMSS)/DFLOAT(NOCC)
! C
! C     FIRST MOMENT INTEGRALS: Z DIRECTION
!       CALL VMOMNT1(DZLL,ORIG,1,0,3,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT1(DZSS,ORIG,4,0,3,1,2)
!       ENDIF
! C
! C     CENTRE OF ELECRON MASS: Z DIRECTION
!       SUMLL = DCMPLX(0.0D0,0.0D0)
!       SUMSS = DCMPLX(0.0D0,0.0D0)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           SUMLL = SUMLL + DZLL(I,J)*DENT(I,J)
!           IF(HMLT.NE.'NORL') THEN
!             K = I+NSKP
!             L = J+NSKP
!             SUMSS = SUMSS + DZSS(I,J)*DENT(K,L)
!           ENDIF
!         ENDDO
!       ENDDO
!       ECNT(3) = DREAL(SUMLL+SUMSS)/DFLOAT(NOCC)
! C
! C     MOLECULAR CENTRE OF CHARGE (<X>,<Y>,<Z>)
!       QTOT = ZTOT+DFLOAT(NOCC)
!       DO IX=1,3
!         QCNT(IX) = (ZTOT*ZCNT(IX) + NOCC*ECNT(IX))/QTOT
!       ENDDO
! C
! C     PRINT CENTRE OF NUCLEAR CHARGE TO TERMINAL
!       WRITE(6, *) 'Centre of nuclear/electron/total mass:'
!       WRITE(7, *) 'Centre of nuclear/electron/total mass:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! 10    FORMAT(1X,A,' = (',F20.14,',',F20.14,',',F20.14,')')
!       WRITE(6,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
!       WRITE(7,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
!       WRITE(6,10) 'E(IX)',(ECNT(IX),IX=1,3)
!       WRITE(7,10) 'E(IX)',(ECNT(IX),IX=1,3)
!       WRITE(6,10) 'Q(IX)',(QCNT(IX),IX=1,3)
!       WRITE(7,10) 'Q(IX)',(QCNT(IX),IX=1,3)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! C     GENERATE SECOND MOMENT OVERLAP INTEGRALS (USE ORIG, NOT ZCNT)
!       CALL VMOMNT2(QXXLL,ORIG,ORIG,1,0,1,1,1,2)
!       CALL VMOMNT2(QYYLL,ORIG,ORIG,1,0,2,2,1,2)
!       CALL VMOMNT2(QZZLL,ORIG,ORIG,1,0,3,3,1,2)
!       CALL VMOMNT2(QXYLL,ORIG,ORIG,1,0,1,2,1,2)
!       CALL VMOMNT2(QYZLL,ORIG,ORIG,1,0,2,3,1,2)
!       CALL VMOMNT2(QXZLL,ORIG,ORIG,1,0,1,3,1,2)
! C
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMOMNT2(QXXSS,ORIG,ORIG,4,0,1,1,1,2)
!         CALL VMOMNT2(QYYSS,ORIG,ORIG,4,0,2,2,1,2)
!         CALL VMOMNT2(QZZSS,ORIG,ORIG,4,0,3,3,1,2)
!         CALL VMOMNT2(QXYSS,ORIG,ORIG,4,0,1,2,1,2)
!         CALL VMOMNT2(QYZSS,ORIG,ORIG,4,0,2,3,1,2)
!         CALL VMOMNT2(QXZSS,ORIG,ORIG,4,0,1,3,1,2)
!       ENDIF
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
!       CALL PROPRTY(EXX1,QXXLL,EMPTY,EMPTY,QXXSS)
!       CALL PROPRTY(EYY1,QYYLL,EMPTY,EMPTY,QYYSS)
!       CALL PROPRTY(EZZ1,QZZLL,EMPTY,EMPTY,QZZSS)
!       CALL PROPRTY(EXY1,QXYLL,EMPTY,EMPTY,QXYSS)
!       CALL PROPRTY(EYZ1,QYZLL,EMPTY,EMPTY,QYZSS)
!       CALL PROPRTY(EXZ1,QXZLL,EMPTY,EMPTY,QXZSS)
! C
!       WRITE(6, *) 'Molecular electric quadrupole moment (e.a_{0}):'
!       WRITE(7, *) 'Molecular electric quadrupole moment (e.a_{0}):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! 20    FORMAT(1X,A,' (',F20.14,',',F20.14,',',F20.14,')')
! 21    FORMAT(9X,'(',F20.14,',',F20.14,',',F20.14,')')
!       WRITE(6,20) 'q_{e} =',DREAL(EXX1(5)),DREAL(EXY1(5)),DREAL(EXZ1(5))
!       WRITE(7,20) 'q_{e} =',DREAL(EXX1(5)),DREAL(EXY1(5)),DREAL(EXZ1(5))
!       WRITE(6,21)           DREAL(EXY1(5)),DREAL(EYY1(5)),DREAL(EYZ1(5))
!       WRITE(7,21)           DREAL(EXY1(5)),DREAL(EYY1(5)),DREAL(EYZ1(5))
!       WRITE(6,21)           DREAL(EXZ1(5)),DREAL(EYZ1(5)),DREAL(EZZ1(5))
!       WRITE(7,21)           DREAL(EXZ1(5)),DREAL(EYZ1(5)),DREAL(EZZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE MAGDIPL
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     MM       MM    AA     GGGGGG  DDDDDDD IIII PPPPPPP  LL           C
! C     MMM     MMM   AAAA   GG    GG DD    DD II  PP    PP LL           C
! C     MMMM   MMMM  AA  AA  GG       DD    DD II  PP    PP LL           C
! C     MM MM MM MM AA    AA GG       DD    DD II  PP    PP LL           C
! C     MM  MMM  MM AAAAAAAA GG   GGG DD    DD II  PPPPPPP  LL           C
! C     MM   M   MM AA    AA GG    GG DD    DD II  PP       LL           C
! C     MM       MM AA    AA  GGGGGG  DDDDDDD IIII PP       LLLLLLLL     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  MAGDIPL CALCULATES THE PERMANENT MAGNETIC DIPOLE MOMENT OF THE      C
! C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       DIMENSION ORIG(3)
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
!       COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
!      &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
!      &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
!      &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
!       COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
!      &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 VX1(MDM,MDM,5),VY1(MDM,MDM,5),VZ1(MDM,MDM,5)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/DENS/DENC,DENO,DENT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In MAGDIPL: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In MAGDIPL: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE FIRST MOMENT BASIS OVERLAP INTEGRALS
!       CALL VMOMNT1(DXYLS,ORIG,2,1,2,1,2)
!       CALL VMOMNT1(DXZLS,ORIG,2,1,3,1,2)
!       CALL VMOMNT1(DYXLS,ORIG,2,2,1,1,2)
!       CALL VMOMNT1(DYZLS,ORIG,2,2,3,1,2)
!       CALL VMOMNT1(DZXLS,ORIG,2,3,1,1,2)
!       CALL VMOMNT1(DZYLS,ORIG,2,3,2,1,2)
! C
!       CALL VMOMNT1(DXYSL,ORIG,3,1,2,1,2)
!       CALL VMOMNT1(DXZSL,ORIG,3,1,3,1,2)
!       CALL VMOMNT1(DYXSL,ORIG,3,2,1,1,2)
!       CALL VMOMNT1(DYZSL,ORIG,3,2,3,1,2)
!       CALL VMOMNT1(DZXSL,ORIG,3,3,1,1,2)
!       CALL VMOMNT1(DZYSL,ORIG,3,3,2,1,2)
! C
! C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         COMPONENT OVERLAP LS
!           WXLS(I,J) = 0.5D0*CV*(DZYLS(I,J)-DYZLS(I,J))
!           WYLS(I,J) = 0.5D0*CV*(DXZLS(I,J)-DZXLS(I,J))
!           WZLS(I,J) = 0.5D0*CV*(DYXLS(I,J)-DXYLS(I,J))
! C
! C         COMPONENT OVERLAP SL
!           WXSL(I,J) = 0.5D0*CV*(DZYSL(I,J)-DYZSL(I,J))
!           WYSL(I,J) = 0.5D0*CV*(DXZSL(I,J)-DZXSL(I,J))
!           WZSL(I,J) = 0.5D0*CV*(DYXSL(I,J)-DXYSL(I,J))
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
!       CALL PROPRTY(EX1,EMPTY,WXLS,WXSL,EMPTY)
!       CALL PROPRTY(EY1,EMPTY,WYLS,WYSL,EMPTY)
!       CALL PROPRTY(EZ1,EMPTY,WZLS,WZSL,EMPTY)
! C
!       WRITE(6, *) 'Molecular magnetic dipole moment (e.a_{0}):'
!       WRITE(7, *) 'Molecular magnetic dipole moment (e.a_{0}):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! 20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
!       WRITE(6,20) 'd_{m} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) 'd_{m} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
! 31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
! 32    FORMAT(7X,A,1X,F20.14,2X,F20.14,2X,F20.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                            'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                            'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(VX1,EMPTY,WXLS,WXSL,EMPTY,NORD)
!       CALL RSPT1(VY1,EMPTY,WYLS,WYSL,EMPTY,NORD)
!       CALL RSPT1(VZ1,EMPTY,WZLS,WZSL,EMPTY,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_MAGDIPL_VX.dat',STATUS='UNKNOWN')
!       OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_MAGDIPL_VY.dat',STATUS='UNKNOWN')
!       OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_MAGDIPL_VZ.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(11, *) (VX1(IOCC,JOCC,5),JOCC=1,NDIM)
!           WRITE(12, *) (VY1(IOCC,JOCC,5),JOCC=1,NDIM)
!           WRITE(13, *) (VZ1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=13)
!       CLOSE(UNIT=12)
!       CLOSE(UNIT=11)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MAGDIPL_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VX1
!           CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VY1
!           CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VZ1
!           CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
      
! C      RETURN
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! C     MAXIMUM PERTURBATIVE ORDER
!       NORD = 4
! C
! 40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
!      &                                                 ' with IX = ',A)
! C
! C     X-COMPONENT
!       WRITE(6,40) IOCC,'X'
!       WRITE(7,40) IOCC,'X'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VX1
!       CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
! C     END X-COMPONENT
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C     Y-COMPONENT
!       WRITE(6,40) IOCC,'Y'
!       WRITE(7,40) IOCC,'Y'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VY1
!       CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
! C     END Y-COMPONENT
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C     Z-COMPONENT
!       WRITE(6,40) IOCC,'Z'
!       WRITE(7,40) IOCC,'Z'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
!       CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
! C     END Z-COMPONENT AND SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE MAGQDPL
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C MM       MM    AA     GGGGGG    QQQQQQ    DDDDDDD  PPPPPPP  LL       C
! C MMM     MMM   AAAA   GG    GG  QQ    QQ   DD    DD PP    PP LL       C
! C MMMM   MMMM  AA  AA  GG       QQ      QQ  DD    DD PP    PP LL       C
! C MM MM MM MM AA    AA GG       QQ      QQ  DD    DD PP    PP LL       C
! C MM  MMM  MM AAAAAAAA GG   GGG QQ      QQ  DD    DD PPPPPPP  LL       C
! C MM   M   MM AA    AA GG    GG  QQ    QQ   DD    DD PP       LL       C
! C MM       MM AA    AA  GGGGGG    QQQQQQ QQ DDDDDDD  PP       LLLLLLLL C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  MAGQDPL CALCULATES THE PERMANENT MAGNETIC QUADRUPOLE MOMENT OF THE  C
! C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
! C -------------------------------------------------------------------- C
! C  TODO: THIS IS UNFINISHED, BECAUSE I CAN'T SEEM TO FIND A FORMULA.   C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! c
!       CHARACTER*5 NMDL
! C
!       DIMENSION ORIG(3)
! C
!       COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
!       COMPLEX*16 QXYLS(MDM,MDM),QXZLS(MDM,MDM),QYXLS(MDM,MDM),
!      &           QYZLS(MDM,MDM),QZXLS(MDM,MDM),QZYLS(MDM,MDM),
!      &           QXYSL(MDM,MDM),QXZSL(MDM,MDM),QYXSL(MDM,MDM),
!      &           QYZSL(MDM,MDM),QZXSL(MDM,MDM),QZYSL(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/DENS/DENC,DENO,DENT
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In MAGQDPL: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In MAGQDPL: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     DEFINE ORIGIN VECTOR
!       DO IX=1,3
!         ORIG(IX) = 0.0D0
!       ENDDO
! C
! C     GENERATE SECOND MOMENT OVERELAP INTEGRALS
!       CALL VMOMNT2(QXYLS,ORIG,ORIG,2,1,2,3,1,2)
!       CALL VMOMNT2(QXZLS,ORIG,ORIG,2,1,3,2,1,2)
!       CALL VMOMNT2(QYXLS,ORIG,ORIG,2,2,1,3,1,2)
!       CALL VMOMNT2(QYZLS,ORIG,ORIG,2,2,3,1,1,2)
!       CALL VMOMNT2(QZXLS,ORIG,ORIG,2,3,1,2,1,2)
!       CALL VMOMNT2(QZYLS,ORIG,ORIG,2,3,2,1,1,2)
! C
!       CALL VMOMNT2(QXYSL,ORIG,ORIG,3,1,2,3,1,2)
!       CALL VMOMNT2(QXZSL,ORIG,ORIG,3,1,3,2,1,2)
!       CALL VMOMNT2(QYXSL,ORIG,ORIG,3,2,1,3,1,2)
!       CALL VMOMNT2(QYZSL,ORIG,ORIG,3,2,3,1,1,2)
!       CALL VMOMNT2(QZXSL,ORIG,ORIG,3,3,1,2,1,2)
!       CALL VMOMNT2(QZYSL,ORIG,ORIG,3,3,2,1,1,2)
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
!       WRITE(6, *) 'MAGQDPL is unfinished.'
!       WRITE(7, *) 'MAGQDPL is unfinished.'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE STRKEFF(EFIELD,GAUGE)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      SSSSSS TTTTTTTT RRRRRRR  KK    KK EEEEEEEE FFFFFFFF FFFFFFFF    C
! C     SS    SS   TT    RR    RR KK   KK  EE       FF       FF          C
! C     SS         TT    RR    RR KK  KK   EE       FF       FF          C
! C      SSSSSS    TT    RR    RR KKKKK    EEEEEE   FFFFFF   FFFFFF      C
! C           SS   TT    RRRRRRR  KK  KK   EE       FF       FF          C
! C     SS    SS   TT    RR    RR KK   KK  EE       FF       FF          C
! C      SSSSSS    TT    RR    RR KK    KK EEEEEEEE FF       FF          C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  STRKEFF PERFORMS A STARK EFFECT ANALYSIS, GIVEN APPLIED ELECTRIC    C
! C  FIELD (EX,EY,EZ).                                                   C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ EFIELD - UNIFORM ELECTRIC FIELD VECTOR (EX,EY,EZ).                C
! C  ▶ GAUGE  - GAUGE ORIGIN COORDINATES.                                C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       LOGICAL ORBEXP
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EFIELD(3),GAUGE(3)
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
!       COMPLEX*16 VX1(MDM,MDM,5),VY1(MDM,MDM,5),VZ1(MDM,MDM,5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 D0XLL(MDM,MDM),D0YLL(MDM,MDM),D0ZLL(MDM,MDM),
!      &           D0XSS(MDM,MDM),D0YSS(MDM,MDM),D0ZSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/DENS/DENC,DENO,DENT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! C     MATRIX ELEMENT INTEGRALS
!       CALL VMOMNT1(D0XLL,GAUGE,1,0,1,1,2)
!       CALL VMOMNT1(D0YLL,GAUGE,1,0,2,1,2)
!       CALL VMOMNT1(D0ZLL,GAUGE,1,0,3,1,2)
! C
!       IF(HMLT.EQ.'NORL') THEN
!         CALL VMOMNT1(D0XSS,GAUGE,4,0,1,1,2)
!         CALL VMOMNT1(D0YSS,GAUGE,4,0,2,1,2)
!         CALL VMOMNT1(D0ZSS,GAUGE,4,0,3,1,2)
!       ENDIF
! C
! C     CONSTRUCT ELECTRIC DIPOLE MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         COMPONENT OVERLAP LL
!           D0XLL(I,J) =-EFIELD(1)*D0XLL(I,J)
!           D0YLL(I,J) =-EFIELD(2)*D0YLL(I,J)
!           D0ZLL(I,J) =-EFIELD(3)*D0ZLL(I,J)
! C
! C         COMPONENT OVERLAP SS
!           D0XSS(I,J) =-EFIELD(1)*D0XSS(I,J)
!           D0YSS(I,J) =-EFIELD(2)*D0YSS(I,J)
!           D0ZSS(I,J) =-EFIELD(3)*D0ZSS(I,J)
! C
!         ENDDO
!       ENDDO
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
!       CALL PROPRTY(EX1,D0XLL,EMPTY,EMPTY,D0XSS)
!       CALL PROPRTY(EY1,D0YLL,EMPTY,EMPTY,D0YSS)
!       CALL PROPRTY(EZ1,D0ZLL,EMPTY,EMPTY,D0ZSS)
! C
!       WRITE(6, *) 'Stark effect interaction energy (e.a_{0}):'
!       WRITE(7, *) 'Stark effect interaction energy (e.a_{0}):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! 20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
!       WRITE(6,20) 'E_{S} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) 'E_{S} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
!       ORBEXP = .FALSE.
!       IF(.NOT.ORBEXP) GOTO 400
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 2
! C
! 30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
! 32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                            'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                            'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(VX1,D0XLL,EMPTY,EMPTY,D0XSS,NORD)
!       CALL RSPT1(VY1,D0YLL,EMPTY,EMPTY,D0YSS,NORD)
!       CALL RSPT1(VZ1,D0ZLL,EMPTY,EMPTY,D0ZSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_STRKEFF_VX.dat',STATUS='UNKNOWN')
!       OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_STRKEFF_VY.dat',STATUS='UNKNOWN')
!       OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_STRKEFF_VZ.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(11, *) (VX1(IOCC,JOCC,5),JOCC=1,NDIM)
!           WRITE(12, *) (VY1(IOCC,JOCC,5),JOCC=1,NDIM)
!           WRITE(13, *) (VZ1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=13)
!       CLOSE(UNIT=12)
!       CLOSE(UNIT=11)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_STRKEFF_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VX1
!           CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 400   CONTINUE
! C
!       RETURN
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! C     MAXIMUM PERTURBATIVE ORDER
!       NORD = 2
! C
! 40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
!      &                                                 ' with IX = ',A)
! C
! C     Z-COMPONENT
!       WRITE(6,40) IOCC,'Z'
!       WRITE(7,40) IOCC,'Z'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
!       CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
! C     END Z-COMPONENT AND SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE ZMANEFF(BFIELD,GAUGE)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   ZZZZZZZZ MM       MM    AA    NN    NN EEEEEEEE FFFFFFFF FFFFFFFF  C
! C        ZZ  MMM     MMM   AAAA   NNN   NN EE       FF       FF        C
! C       ZZ   MMMM   MMMM  AA  AA  NNNN  NN EE       FF       FF        C
! C      ZZ    MM MM MM MM AA    AA NN NN NN EEEEEE   FFFFFF   FFFFFF    C
! C     ZZ     MM  MMM  MM AAAAAAAA NN  NNNN EE       FF       FF        C
! C    ZZ      MM   M   MM AA    AA NN   NNN EE       FF       FF        C
! C   ZZZZZZZZ MM       MM AA    AA NN    NN EEEEEEEE FF       FF        C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  ZMANEFF PERFORMS A ZEEMAN EFFECT ANALYSIS, GIVEN APPLIED MAGNETIC   C
! C  FIELD (BX,BY,BZ).                                                   C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ BFIELD - UNIFORM MAGNETIC FIELD VECTOR (BX,BY,BZ).                C
! C  ▶ GAUGE  - GAUGE ORIGIN COORDINATES.                                C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       LOGICAL ORBEXP
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION BFIELD(3),GAUGE(3)
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
!       COMPLEX*16 VX1(MDM,MDM,5),VY1(MDM,MDM,5),VZ1(MDM,MDM,5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
!      &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
!      &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
!      &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
!       COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
!      &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/DENS/DENC,DENO,DENT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In ZMANEFF: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In ZMANEFF: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! C     MATRIX ELEMENT INTEGRALS
!       CALL VMOMNT1(DXYLS,GAUGE,2,1,2,1,2)
!       CALL VMOMNT1(DXZLS,GAUGE,2,1,3,1,2)
!       CALL VMOMNT1(DYXLS,GAUGE,2,2,1,1,2)
!       CALL VMOMNT1(DYZLS,GAUGE,2,2,3,1,2)
!       CALL VMOMNT1(DZXLS,GAUGE,2,3,1,1,2)
!       CALL VMOMNT1(DZYLS,GAUGE,2,3,2,1,2)
! C
!       CALL VMOMNT1(DXYSL,GAUGE,3,1,2,1,2)
!       CALL VMOMNT1(DXZSL,GAUGE,3,1,3,1,2)
!       CALL VMOMNT1(DYXSL,GAUGE,3,2,1,1,2)
!       CALL VMOMNT1(DYZSL,GAUGE,3,2,3,1,2)
!       CALL VMOMNT1(DZXSL,GAUGE,3,3,1,1,2)
!       CALL VMOMNT1(DZYSL,GAUGE,3,3,2,1,2)
! C
! C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         COMPONENT OVERLAP LS
!           WXLS(I,J) =-0.5D0*CV*BFIELD(1)*(DYZLS(I,J)-DZYLS(I,J))
!           WYLS(I,J) =-0.5D0*CV*BFIELD(2)*(DZXLS(I,J)-DXZLS(I,J))
!           WZLS(I,J) =-0.5D0*CV*BFIELD(3)*(DXYLS(I,J)-DYXLS(I,J))
! C
! C         COMPONENT OVERLAP SL
!           WXSL(I,J) =-0.5D0*CV*BFIELD(1)*(DYZSL(I,J)-DZYSL(I,J))
!           WYSL(I,J) =-0.5D0*CV*BFIELD(2)*(DZXSL(I,J)-DXZSL(I,J))
!           WZSL(I,J) =-0.5D0*CV*BFIELD(3)*(DXYSL(I,J)-DYXSL(I,J))
! C
!         ENDDO
!       ENDDO
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
!       CALL PROPRTY(EX1,EMPTY,WXLS,WXSL,EMPTY)
!       CALL PROPRTY(EY1,EMPTY,WYLS,WYSL,EMPTY)
!       CALL PROPRTY(EZ1,EMPTY,WZLS,WZSL,EMPTY)
! C
!       WRITE(6, *) 'Zeeman effect interaction energy (e.a_{0}):'
!       WRITE(7, *) 'Zeeman effect interaction energy (e.a_{0}):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! 20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
!       WRITE(6,20) 'E_{Z} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) 'E_{Z} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
!       ORBEXP = .FALSE.
!       IF(.NOT.ORBEXP) GOTO 400
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 2
! C
! 30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
! 32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                            'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                            'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(VX1,EMPTY,WXLS,WXSL,EMPTY,NORD)
!       CALL RSPT1(VY1,EMPTY,WYLS,WYSL,EMPTY,NORD)
!       CALL RSPT1(VZ1,EMPTY,WZLS,WZSL,EMPTY,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_ZMANEFF_VX.dat',STATUS='UNKNOWN')
!       OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_ZMANEFF_VY.dat',STATUS='UNKNOWN')
!       OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_ZMANEFF_VZ.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(11, *) (VX1(IOCC,JOCC,5),JOCC=1,NDIM)
!           WRITE(12, *) (VY1(IOCC,JOCC,5),JOCC=1,NDIM)
!           WRITE(13, *) (VZ1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=13)
!       CLOSE(UNIT=12)
!       CLOSE(UNIT=11)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ZMANEFF_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VX1
!           CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 400   CONTINUE
! C
!       RETURN
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! C     MAXIMUM PERTURBATIVE ORDER
!       NORD = 1
! C
! 40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
!      &                                                 ' with IX = ',A)
! C
! C     Z-COMPONENT
!       WRITE(6,40) IOCC,'Z'
!       WRITE(7,40) IOCC,'Z'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
!       CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
! C     END Z-COMPONENT AND SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE HYPFINE(IZ,RNMU,ISPN)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      HH    HH YY    YY PPPPPPP  FFFFFFFF IIII NN    NN EEEEEEEE      C
! C      HH    HH YY    YY PP    PP FF        II  NNN   NN EE            C
! C      HH    HH YY    YY PP    PP FF        II  NNNN  NN EE            C
! C      HHHHHHHH  YY  YY  PP    PP FFFFFF    II  NN NN NN EEEEEE        C
! C      HH    HH   YYYY   PPPPPPP  FF        II  NN  NNNN EE            C
! C      HH    HH    YY    PP       FF        II  NN   NNN EE            C
! C      HH    HH    YY    PP       FF       IIII NN    NN EEEEEEEE      C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  HYPFINE DETERMINES THE FIRST-ORDER ENERGY SHIFT ARISING FROM THE    C
! C  MAGNETIC DIPOLE MOMENT OF NUCLEUS IZ, WITH DIPOLE MOMENT STRENGTH   C
! C  RNMU AND NUCLEAR SPIN ISPN. (USE SPIN HAMILTONIAN IN GRANT 11.5.8.) C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ   - THE NUCLEAR CENTRE WITH A MAGNETIC MOMENT.                 C
! C  ▶ RNMU - NUCLEAR MAGNETIC DIPOLE MOMENT MU (NUCLEAR MAGNETON UNITS).C
! C  ▶ ISPN - DOUBLE THE NUCLEAR SPIN OF THE CENTRE.                     C
! C -------------------------------------------------------------------- C
! C LIST OF AVAILABLE NUCLEAR DIPOLE MOMENTS AT FOLLOWING LINK:          C
! C https://www.psi.ch/low-energy-muons/DocumentsEN/nuclear-moments.pdf  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION RNLOC(3)
! C
!       COMPLEX*16 CONE,SUMX,SUMY,SUMZ
!       COMPLEX*16 VX(MDM),VY(MDM),VZ(MDM)
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
!      &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
!      &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
!      &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
!       COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
!      &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/EIGC/COEF
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In HYPFINE: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In HYPFINE: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE OTHER ARRAYS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           DXYLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DXZLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DYXLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DYZLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DZXLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DZYLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DXYSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DXZSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DYXSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DYZSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DZXSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DZYSL(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     LOCATION OF NUCLEUS WITH MAGNETIC MOMENT
!       DO IX=1,3
!         RNLOC(IX) = BXYZ(IX,IZ)
!       ENDDO
! C
! C     PRE-FACTOR FOR MATRIX ELEMENTS
!       RI2 = DFLOAT(ISPN)/2.D0
!       PRE =-CHZ*1.0D-6/(PMSS*CV*RI2)
! C
! C**********************************************************************C
! C     PREPARE MATRIX ELEMENT INTEGRALS                                 C
! C**********************************************************************C
! C
! C     MATRIX ELEMENT INTEGRALS
!       CALL VMNPOLE(DXYLS,RNLOC,2,1,2,1,2)
!       CALL VMNPOLE(DXZLS,RNLOC,2,1,3,1,2)
!       CALL VMNPOLE(DYXLS,RNLOC,2,2,1,1,2)
!       CALL VMNPOLE(DYZLS,RNLOC,2,2,3,1,2)
!       CALL VMNPOLE(DZXLS,RNLOC,2,3,1,1,2)
!       CALL VMNPOLE(DZYLS,RNLOC,2,3,2,1,2)
! C
!       CALL VMNPOLE(DXYSL,RNLOC,3,1,2,1,2)
!       CALL VMNPOLE(DXZSL,RNLOC,3,1,3,1,2)
!       CALL VMNPOLE(DYXSL,RNLOC,3,2,1,1,2)
!       CALL VMNPOLE(DYZSL,RNLOC,3,2,3,1,2)
!       CALL VMNPOLE(DZXSL,RNLOC,3,3,1,1,2)
!       CALL VMNPOLE(DZYSL,RNLOC,3,3,2,1,2)
! C
! C     CONSTRUCT MAGNETIC MOMENT DIPOLE MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         COMPONENT OVERLAP LS
!           WXLS(I,J) = DYZLS(I,J)-DZYLS(I,J)
!           WYLS(I,J) = DZXLS(I,J)-DXZLS(I,J)
!           WZLS(I,J) = DXYLS(I,J)-DYXLS(I,J)
! C
! C         COMPONENT OVERLAP SL
!           WXSL(I,J) = DYZSL(I,J)-DZYSL(I,J)
!           WYSL(I,J) = DZXSL(I,J)-DXZSL(I,J)
!           WZSL(I,J) = DXYSL(I,J)-DYXSL(I,J)
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     COMPUTE EXPECTATION VALUES MANUALLY BECAUSE SPIN EIGENFUNCTIONS  C
! C     ARE NOT THE SAME AS SPATIAL EIGENFUNCTIONS -- NEED LINEAR COMBO. C
! C**********************************************************************C
! C
! 29    FORMAT(1X,A,I3,A)
! 30    FORMAT(1X,A,2X,3(14X,'E^(',I1,')',A))
! 31    FORMAT(1X,I3,' Re:',F21.9,F22.9,F22.9)
! 32    FORMAT(4X,' Im:',F21.9,F22.9,F22.9)
!       WRITE(6,29) 'Expectation value for each orbital IOCC (in MHz):'
!       WRITE(7,29) 'Expectation value for each orbital IOCC (in MHz):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
!       WRITE(7,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C     LOOP OVER ORBITALS
!       DO IOCC=NSKP+1,NSKP+NOCC+2
! C
! C       SOLUTIONS MUST COUPLE IN KRAMER PAIRS
!         IF(MOD(IOCC,2).EQ.0) THEN
!           NP =-1
!         ELSE
!           NP = 1
!         ENDIF
! C
! C       INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
!         SUMX = DCMPLX(0.0D0,0.0D0)
!         SUMY = DCMPLX(0.0D0,0.0D0)
!         SUMZ = DCMPLX(0.0D0,0.0D0)
! C
! C       LOOP OVER FOCK MATRIX ADDRESSES
!         DO I=1,NDIM-NSKP
!           DO J=1,NDIM-NSKP
! C
!             K = I+NSKP
!             L = J+NSKP
! C
! C           LARGE AND SMALL CONTRIBUTIONS
!             SUMX = SUMX + DCONJG(COEF(I,IOCC))*COEF(L,IOCC+NP)*WXLS(I,J)
!      &                  + DCONJG(COEF(K,IOCC))*COEF(J,IOCC+NP)*WXSL(I,J)
!             SUMY = SUMY + DCONJG(COEF(I,IOCC))*COEF(L,IOCC+NP)*WYLS(I,J)
!      &                  + DCONJG(COEF(K,IOCC))*COEF(J,IOCC+NP)*WYSL(I,J)
!             SUMZ = SUMZ + DCONJG(COEF(I,IOCC))*COEF(L,IOCC   )*WZLS(I,J)
!      &                  + DCONJG(COEF(K,IOCC))*COEF(J,IOCC   )*WZSL(I,J)
! C
!           ENDDO
!         ENDDO
! C
! C       SAVE SUM
!         VX(IOCC) = SUMX*PRE*RNMU
!         VY(IOCC) =-SUMY*PRE*RNMU*CONE
!         VZ(IOCC) = SUMZ*PRE*RNMU
! C
!       ENDDO
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_HYPFINE_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=NSKP+1,NSKP+NOCC+2
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
!      &                          DABS(DREAL(VY(IOCC))),
!      &                          DABS(DREAL(VZ(IOCC)))
!           WRITE(7,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
!      &                          DABS(DREAL(VY(IOCC))),
!      &                          DABS(DREAL(VZ(IOCC)))
!           WRITE(8,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
!      &                          DABS(DREAL(VY(IOCC))),
!      &                          DABS(DREAL(VZ(IOCC)))
! C
!           WRITE(6,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
!      &                                      DABS(DIMAG(VZ(IOCC)))
!           WRITE(7,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
!      &                                      DABS(DIMAG(VZ(IOCC)))
!           WRITE(8,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
!      &                                      DABS(DIMAG(VZ(IOCC)))
! C
! C         SEPARATOR FOR VIRTUAL SPECTRUM
!           IF(IOCC.EQ.NSKP+NOCC) THEN
!             WRITE(6, *) REPEAT('=',72)
!             WRITE(7, *) REPEAT('=',72)
!             WRITE(8, *) REPEAT('=',72)
!           ELSEIF(IOCC.LT.NSKP+NOCC+2) THEN
!             WRITE(6, *) REPEAT('-',72)
!             WRITE(7, *) REPEAT('-',72)
!             WRITE(8, *) REPEAT('-',72)
!           ENDIF
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE NMRSHLD(IZ,GAUGE)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C  NN    NN MM       MM RRRRRRR   SSSSSS  HH    HH LL       DDDDDDD    C
! C  NNN   NN MMM     MMM RR    RR SS    SS HH    HH LL       DD    DD   C
! C  NNNN  NN MMMM   MMMM RR    RR SS       HH    HH LL       DD    DD   C
! C  NN NN NN MM MM MM MM RR    RR  SSSSSS  HHHHHHHH LL       DD    DD   C
! C  NN  NNNN MM  MMM  MM RRRRRRR        SS HH    HH LL       DD    DD   C
! C  NN   NNN MM   M   MM RR    RR SS    SS HH    HH LL       DD    DD   C
! C  NN    NN MM       MM RR    RR  SSSSSS  HH    HH LLLLLLLL DDDDDDD    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  NMRSHLD CALCULATES THE NUCLEAR SHIELDING TENSOR FOR ONE NUCLEUS IN  C
! C  A MOLECULE UNDER THE HARTREE-FOCK APPROXIMATION, TO LEADING ORDER.  C
! C  NOTE: SINCE THE S-TENSOR IS A CROSSING TERM IN SECOND ORDER P.T.    C
! C        WITH INTERPRETATIONS FOR THE POSITIVE- AND NEGATIVE-ENERGY    C
! C        UNOCCUPIED SPECTRUM, CALCULATIONS HERE ARE DONE EXPLICITLY.   C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ    - THE NUCLEAR CENTRE WITH A MAGNETIC MOMENT.                C
! C  ▶ GAUGE - GAUGE ORIGIN COORDINATES - TRY BXYZ(IZ) TO START.         C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION GAUGE(3),RNLOC(3)
!       DIMENSION PX(NDIM,NDIM),PY(NDIM,NDIM),PZ(NDIM,NDIM)
!       DIMENSION KQN(2),LQN(2),NBAS(2)
! C
!       COMPLEX*16 CONE,BC,HC
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
!       COMPLEX*16 VYXX(MDM,MDM),VZXX(MDM,MDM),VYXY(MDM,MDM),
!      &           VZXY(MDM,MDM),VYXZ(MDM,MDM),VZXZ(MDM,MDM),
!      &           VXYX(MDM,MDM),VZYX(MDM,MDM),VXYY(MDM,MDM),
!      &           VZYY(MDM,MDM),VXYZ(MDM,MDM),VZYZ(MDM,MDM),
!      &           VXZX(MDM,MDM),VYZX(MDM,MDM),VXZY(MDM,MDM),
!      &           VYZY(MDM,MDM),VXZZ(MDM,MDM),VYZZ(MDM,MDM)
!       COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
!      &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
!      &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
!      &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
!       COMPLEX*16 GTT(MDM,MDM,9)
!       COMPLEX*16 BLS(MDM,MDM,3),BSL(MDM,MDM,3),
!      &           HLS(MDM,MDM,3),HSL(MDM,MDM,3)
!       COMPLEX*16 VB(MDM,MDM,3),VH(MDM,MDM,3)
!       COMPLEX*16 SIG1G(3,3),SIG2N(3,3),SIG2P(3,3),SIGMA(3,3)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/DENS/DENC,DENO,DENT
!       COMMON/EIGC/COEF
!       COMMON/EIGE/EIGN(MDM)
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     LOCATION OF NUCLEUS WITH MAGNETIC MOMENT
!       DO IX=1,3
!         RNLOC(IX) = BXYZ(IX,IZ)
!       ENDDO
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In NMRSHLD: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In NMRSHLD: not possible for this Hamiltonian!'
!       ENDIF
! C
! C**********************************************************************C
! C     GENERATE MATRIX OF BASIS FUNCTION OVERLAP CENTRES PX,PY,PZ       C
! C**********************************************************************C
! C
! C     INITIALISE ELEMENTS
!       DO I=1,NDIM
!         DO J=1,NDIM
!           PX(I,J) = 0.0D0
!           PY(I,J) = 0.0D0
!           PZ(I,J) = 0.0D0
!         ENDDO
!       ENDDO
! C
! C     LOOP OVER CENTRES A AND B
!       DO 1000 ICNTA=1,NCNT
!       DO 1000 ICNTB=1,NCNT
! C
! C     LOOP OVER KQN(A) AND KQN(B) VALUES
!       DO 1000 KA=1,NKAP(ICNTA)
!       DO 1000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCKS A AND B
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       NUMBER OF BASIS EXPONENTS FOR BLOCKS A AND B
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         NBAS(2) = NFNC(LQN(2),ICNTB)
! C
! C     LOOP OVER |MQN(A)| AND |MQN(B)| VALUES
!       DO 1000 MA=1,IABS(KQN(1))
!       DO 1000 MB=1,IABS(KQN(2))
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         SMALL-COMPONENT ADDRESSES
!           KBAS = IBAS+NSKP
!           LBAS = JBAS+NSKP
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX(NA1+IBAS,NB1+LBAS) = BXYZ(1,ICNTA)-BXYZ(1,ICNTB)
!           PX(NA1+IBAS,NB2+LBAS) = BXYZ(1,ICNTA)-BXYZ(1,ICNTB)
!           PX(NA2+IBAS,NB1+LBAS) = BXYZ(1,ICNTA)-BXYZ(1,ICNTB)
!           PX(NA2+IBAS,NB2+LBAS) = BXYZ(1,ICNTA)-BXYZ(1,ICNTB)
!           PY(NA1+IBAS,NB1+LBAS) = BXYZ(2,ICNTA)-BXYZ(2,ICNTB)
!           PY(NA1+IBAS,NB2+LBAS) = BXYZ(2,ICNTA)-BXYZ(2,ICNTB)
!           PY(NA2+IBAS,NB1+LBAS) = BXYZ(2,ICNTA)-BXYZ(2,ICNTB)
!           PY(NA2+IBAS,NB2+LBAS) = BXYZ(2,ICNTA)-BXYZ(2,ICNTB)
!           PZ(NA1+IBAS,NB1+LBAS) = BXYZ(3,ICNTA)-BXYZ(3,ICNTB)
!           PZ(NA1+IBAS,NB2+LBAS) = BXYZ(3,ICNTA)-BXYZ(3,ICNTB)
!           PZ(NA2+IBAS,NB1+LBAS) = BXYZ(3,ICNTA)-BXYZ(3,ICNTB)
!           PZ(NA2+IBAS,NB2+LBAS) = BXYZ(3,ICNTA)-BXYZ(3,ICNTB)
! C
!           PX(NA1+KBAS,NB1+JBAS) = PX(NA1+IBAS,NB1+LBAS)
!           PX(NA1+KBAS,NB2+JBAS) = PX(NA1+IBAS,NB2+LBAS)
!           PX(NA2+KBAS,NB1+JBAS) = PX(NA2+IBAS,NB1+LBAS)
!           PX(NA2+KBAS,NB2+JBAS) = PX(NA2+IBAS,NB2+LBAS)
!           PY(NA1+KBAS,NB1+JBAS) = PY(NA1+IBAS,NB1+LBAS)
!           PY(NA1+KBAS,NB2+JBAS) = PY(NA1+IBAS,NB2+LBAS)
!           PY(NA2+KBAS,NB1+JBAS) = PY(NA2+IBAS,NB1+LBAS)
!           PY(NA2+KBAS,NB2+JBAS) = PY(NA2+IBAS,NB2+LBAS)
!           PZ(NA1+KBAS,NB1+JBAS) = PZ(NA1+IBAS,NB1+LBAS)
!           PZ(NA1+KBAS,NB2+JBAS) = PZ(NA1+IBAS,NB2+LBAS)
!           PZ(NA2+KBAS,NB1+JBAS) = PZ(NA2+IBAS,NB1+LBAS)
!           PZ(NA2+KBAS,NB2+JBAS) = PZ(NA2+IBAS,NB2+LBAS)
! C
!         ENDDO
!       ENDDO
! 1000  CONTINUE
! C
! C**********************************************************************C
! C     PREPARATION OF MATRIX ELEMENTS FOR σ(1)                          C
! C**********************************************************************C
! C
! C     DIPOLE ELECTRIC FIELD MATRIX ELEMENTS
!       CALL VSETGTN(VXYX,VXYY,VXYZ,RNLOC,1,2)
!       CALL VSETGTN(VXZX,VXZY,VXZZ,RNLOC,1,3)
!       CALL VSETGTN(VYXX,VYXY,VYXZ,RNLOC,2,1)
!       CALL VSETGTN(VYZX,VYZY,VYZZ,RNLOC,2,3)
!       CALL VSETGTN(VZXX,VZXY,VZXZ,RNLOC,3,1)
!       CALL VSETGTN(VZYX,VZYY,VZYZ,RNLOC,3,2)
! C
! C     CONSTRUCT `GAUGE-DEPENDENT' MATRIX ELEMENTS
!       DO I=1,NDIM
!         DO J=1,NDIM
!           GTT(I,J,1) = PY(I,J)*(VYZZ(I,J)-VZYZ(I,J))
!      &               - PZ(I,J)*(VYZY(I,J)-VZYY(I,J))
!           GTT(I,J,2) = PY(I,J)*(VZXZ(I,J)-VXZZ(I,J))
!      &               - PZ(I,J)*(VZXY(I,J)-VXZY(I,J))
!           GTT(I,J,3) = PY(I,J)*(VXYZ(I,J)-VYXZ(I,J))
!      &               - PZ(I,J)*(VXYY(I,J)-VYXY(I,J))
!           GTT(I,J,4) = PZ(I,J)*(VYZX(I,J)-VZYX(I,J))
!      &               - PX(I,J)*(VYZZ(I,J)-VZYZ(I,J))
!           GTT(I,J,5) = PZ(I,J)*(VZXX(I,J)-VXZX(I,J))
!      &               - PX(I,J)*(VZXZ(I,J)-VXZZ(I,J))
!           GTT(I,J,6) = PZ(I,J)*(VXYX(I,J)-VYXX(I,J))
!      &               - PX(I,J)*(VXYZ(I,J)-VYXZ(I,J))
!           GTT(I,J,7) = PX(I,J)*(VYZY(I,J)-VZYY(I,J))
!      &               - PY(I,J)*(VYZX(I,J)-VZYX(I,J))
!           GTT(I,J,8) = PX(I,J)*(VZXY(I,J)-VXZY(I,J))
!      &               - PY(I,J)*(VZXX(I,J)-VXZX(I,J))
!           GTT(I,J,9) = PX(I,J)*(VXYY(I,J)-VYXY(I,J))
!      &               - PY(I,J)*(VXYX(I,J)-VYXX(I,J))
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     CALCULATION OF FIRST-ORDER GAUGE TERM, E^(1)_GAUGE.              C
! C**********************************************************************C
! C
! C     INITIALISE σ MATRICES
!       DO IX=1,3
!         DO JX=1,3
!           SIG1G(IX,JX) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     LOOP OVER FOCK MATRIX ADDRESSES AND ADD TO σ(1)
!       DO I=1,NDIM
!         DO J=1,NDIM
!           SIG1G(1,1) = SIG1G(1,1) - CONE*DENT(I,J)*GTT(I,J,1)/CV
!           SIG1G(1,2) = SIG1G(1,2) - CONE*DENT(I,J)*GTT(I,J,2)/CV
!           SIG1G(1,3) = SIG1G(1,3) - CONE*DENT(I,J)*GTT(I,J,3)/CV
!           SIG1G(2,1) = SIG1G(2,1) - CONE*DENT(I,J)*GTT(I,J,4)/CV
!           SIG1G(2,2) = SIG1G(2,2) - CONE*DENT(I,J)*GTT(I,J,5)/CV
!           SIG1G(2,3) = SIG1G(2,3) - CONE*DENT(I,J)*GTT(I,J,6)/CV
!           SIG1G(3,1) = SIG1G(3,1) - CONE*DENT(I,J)*GTT(I,J,7)/CV
!           SIG1G(3,2) = SIG1G(3,2) - CONE*DENT(I,J)*GTT(I,J,8)/CV
!           SIG1G(3,3) = SIG1G(3,3) - CONE*DENT(I,J)*GTT(I,J,9)/CV
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     PREPARATION OF MATRIX ELEMENTS FOR σ(2)                          C
! C**********************************************************************C
! C
! C     FIRST MOMENT MATRIX ELEMENTS
!       CALL VMOMNT1(DXYLS,GAUGE,2,1,2,1,2)
!       CALL VMOMNT1(DXZLS,GAUGE,2,1,3,1,2)
!       CALL VMOMNT1(DYXLS,GAUGE,2,2,1,1,2)
!       CALL VMOMNT1(DYZLS,GAUGE,2,2,3,1,2)
!       CALL VMOMNT1(DZXLS,GAUGE,2,3,1,1,2)
!       CALL VMOMNT1(DZYLS,GAUGE,2,3,2,1,2)
! C
!       CALL VMOMNT1(DXYSL,GAUGE,3,1,2,1,2)
!       CALL VMOMNT1(DXZSL,GAUGE,3,1,3,1,2)
!       CALL VMOMNT1(DYXSL,GAUGE,3,2,1,1,2)
!       CALL VMOMNT1(DYZSL,GAUGE,3,2,3,1,2)
!       CALL VMOMNT1(DZXSL,GAUGE,3,3,1,1,2)
!       CALL VMOMNT1(DZYSL,GAUGE,3,3,2,1,2)
! C
! C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         COMPONENT OVERLAP LS
!           BLS(I,J,1) = DYZLS(I,J)-DZYLS(I,J)
!           BLS(I,J,2) = DZXLS(I,J)-DXZLS(I,J)
!           BLS(I,J,3) = DXYLS(I,J)-DYXLS(I,J)
! C
! C         COMPONENT OVERLAP SL
!           BSL(I,J,1) = DYZSL(I,J)-DZYSL(I,J)
!           BSL(I,J,2) = DZXSL(I,J)-DXZSL(I,J)
!           BSL(I,J,3) = DXYSL(I,J)-DYXSL(I,J)
! C
!         ENDDO
!       ENDDO
! C
! C     ELECTRIC MONOPOLE MOMENT MATRIX ELEMENTS
!       CALL VMNPOLE(DXYLS,RNLOC,2,1,2,1,2)
!       CALL VMNPOLE(DXZLS,RNLOC,2,1,3,1,2)
!       CALL VMNPOLE(DYXLS,RNLOC,2,2,1,1,2)
!       CALL VMNPOLE(DYZLS,RNLOC,2,2,3,1,2)
!       CALL VMNPOLE(DZXLS,RNLOC,2,3,1,1,2)
!       CALL VMNPOLE(DZYLS,RNLOC,2,3,2,1,2)
! C
!       CALL VMNPOLE(DXYSL,RNLOC,3,1,2,1,2)
!       CALL VMNPOLE(DXZSL,RNLOC,3,1,3,1,2)
!       CALL VMNPOLE(DYXSL,RNLOC,3,2,1,1,2)
!       CALL VMNPOLE(DYZSL,RNLOC,3,2,3,1,2)
!       CALL VMNPOLE(DZXSL,RNLOC,3,3,1,1,2)
!       CALL VMNPOLE(DZYSL,RNLOC,3,3,2,1,2)
! C
! C     CONSTRUCT MAGNETIC MOMENT DIPOLE MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         COMPONENT OVERLAP LS
!           HLS(I,J,1) = DYZLS(I,J)-DZYLS(I,J)
!           HLS(I,J,2) = DZXLS(I,J)-DXZLS(I,J)
!           HLS(I,J,3) = DXYLS(I,J)-DYXLS(I,J)
! C
! C         COMPONENT OVERLAP SL
!           HSL(I,J,1) = DYZSL(I,J)-DZYSL(I,J)
!           HSL(I,J,2) = DZXSL(I,J)-DXZSL(I,J)
!           HSL(I,J,3) = DXYSL(I,J)-DYXSL(I,J)
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     FULL LIST OF σ(2) MATRIX ELEMENTS                                C
! C**********************************************************************C
! C
! C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
!       DO IA=1,NDIM
!         DO IK=1,NDIM
! C
! C         MATRIX ELEMENTS REQUIRE (OCC,UNOCC) COMBINATIONS ONLY
!           IF(IA.GT.NSKP.AND.IA.LE.(NSKP+NOCC)) THEN
!             IAOCC = 1
!           ELSE
!             IAOCC = 0
!           ENDIF
!           IF(IK.GT.NSKP.AND.IK.LE.(NSKP+NOCC)) THEN
!             IKOCC = 1
!           ELSE
!             IKOCC = 0
!           ENDIF
! C
!           IF(IAOCC.EQ.IKOCC) GOTO 150
! C
! C         LOOP OVER CARTESIAN INDEX IX
!           DO IX=1,3
! C
! C           INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
!             BC = DCMPLX(0.0D0,0.0D0)
!             HC = DCMPLX(0.0D0,0.0D0)
! C
! C           LOOP OVER FOCK MATRIX ADDRESSES
!             DO I=1,NDIM-NSKP
!               DO J=1,NDIM-NSKP
! C
!                 K = I+NSKP
!                 L = J+NSKP
! C
! C               ACCOUNT ONLY FOR LS AND SL COMPONENT OVERLAPS
!                 BC = BC + DCONJG(COEF(I,IA))*COEF(L,IK)*BLS(I,J,IX)
!      &                  + DCONJG(COEF(K,IA))*COEF(J,IK)*BSL(I,J,IX)
!                 HC = HC + DCONJG(COEF(I,IA))*COEF(L,IK)*HLS(I,J,IX)
!      &                  + DCONJG(COEF(K,IA))*COEF(J,IK)*HSL(I,J,IX)
! C
!               ENDDO
!             ENDDO
! C
! C           SAVE COUNTERS TO MATRICES
!             VB(IA,IK,IX) = BC
!             VH(IA,IK,IX) = HC
! C
!           ENDDO
! C
! 150       CONTINUE
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     CALCULATION OF SECOND-ORDER CROSSING TERM, E^(2)_CROSS.          C
! C**********************************************************************C
! C
! C     INITIALISE σ MATRICES
!       DO IX=1,3
!         DO JX=1,3
!           SIG2P(IX,JX) = DCMPLX(0.0D0,0.0D0)
!           SIG2N(IX,JX) = DCMPLX(0.0D0,0.0D0)
!           SIGMA(IX,JX) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS IA
!       DO IA=NSKP+1,NSKP+NOCC
! C
! C       EIGENVALUE ENERGY FOR THIS ORBITAL
!         EA = EIGN(IA)
! C
! C       POSITIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E+ STATES
!         DO IK=NSKP+NOCC+1,NDIM
! C
! C         ENERGY DIFFERENCE FOR THIS (EA,EK)
!           EAK = EA-EIGN(IK)
! C
! C         LOOP OVER CARTESIAN INDICES IX AND JX
!           DO IX=1,3
!             DO JX=1,3
! C
! C             CONTRIBUTIONS TO EACH PART OF THE S-TENSOR
!               SIG2P(IX,JX) = SIG2P(IX,JX)
!      &                      +        VB(IA,IK,IX)*VH(IK,IA,JX)/EAK
!      &                      + DCONJG(VB(IA,IK,IX)*VH(IK,IA,JX)/EAK)
! C
!             ENDDO
!           ENDDO
! C
! C       END POSITIVE-ENERGY LOOP
!         ENDDO
! C
! C       NEGATIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E- STATES
!         DO IK=1,NSKP
! C
! C         ENERGY DIFFERENCE FOR THIS (EA,EK)
!           EAK = EA-EIGN(IK)
! C
! C         LOOP OVER CARTESIAN INDICES IX AND JX
!           DO IX=1,3
!             DO JX=1,3
! C
! C             CONTRIBUTIONS TO EACH PART OF THE S-TENSOR
!               SIG2N(IX,JX) = SIG2N(IX,JX)
!      &                      +        VB(IA,IK,IX)*VH(IK,IA,JX)/EAK
!      &                      + DCONJG(VB(IA,IK,IX)*VH(IK,IA,JX)/EAK)
! C
!             ENDDO
!           ENDDO
! C
! C       END NEGATIVE-ENERGY LOOP
!         ENDDO
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C**********************************************************************C
! C     SUMMARY OF RESULTS                                               C
! C**********************************************************************C
! C
! C     CONVERT TO NMR TMS REFERENCE FORM (PPM)
!       DO IX=1,3
!         DO JX=1,3
!           SIG1G(IX,JX) = 0.5D0*1.0D6*SIG1G(IX,JX)
!           SIG2P(IX,JX) = 0.5D0*1.0D6*SIG2P(IX,JX)
!           SIG2N(IX,JX) = 0.5D0*1.0D6*SIG2N(IX,JX)
!           SIGMA(IX,JX) = SIG1G(IX,JX) 
!      &                 + SIG2P(IX,JX) + SIG2N(IX,JX)
!         ENDDO
!       ENDDO
! C
! C     SPHERICAL AVERAGE
!       D1G = 0.0D0
!       D2P = 0.0D0
!       D2N = 0.0D0
!       DSG = 0.0D0
!       DO IX=1,3
!         D1G = D1G + DREAL(SIG1G(IX,IX))/3.0D0
!         D2P = D2P + DREAL(SIG2P(IX,IX))/3.0D0
!         D2N = D2N + DREAL(SIG2N(IX,IX))/3.0D0
!         DSG = DSG + DREAL(SIGMA(IX,IX))/3.0D0
!       ENDDO
! C
! 20    FORMAT(17X,'(',F16.10,',',F16.10,',',F16.10,')')
! 21    FORMAT(9X,A,1X,'(',F16.10,',',F16.10,',',F16.10,')')
! C
!       WRITE(6, *) 'Nuclear shielding tensor analysis:'
!       WRITE(7, *) 'Nuclear shielding tensor analysis:'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C     SUMMARISE THE TENSOR ELEMENTS
!       WRITE(6, *) 'Gauge-dependent shielding tensor (ppm au):'
!       WRITE(7, *) 'Gauge-dependent shielding tensor (ppm au):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,20)           (DREAL(SIG1G(1,JX)),JX=1,3)
!       WRITE(7,20)           (DREAL(SIG1G(1,JX)),JX=1,3)
!       WRITE(6,21) ' σ(1) =',(DREAL(SIG1G(2,JX)),JX=1,3)
!       WRITE(7,21) ' σ(1) =',(DREAL(SIG1G(2,JX)),JX=1,3)
!       WRITE(6,20)           (DREAL(SIG1G(3,JX)),JX=1,3)
!       WRITE(7,20)           (DREAL(SIG1G(3,JX)),JX=1,3)
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       WRITE(6, *) 'Paramagnetic shielding tensor (ppm au):'
!       WRITE(7, *) 'Paramagnetic shielding tensor (ppm au):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,20)           (DREAL(SIG2P(1,JX)),JX=1,3)
!       WRITE(7,20)           (DREAL(SIG2P(1,JX)),JX=1,3)
!       WRITE(6,21) 'σ(2+) =',(DREAL(SIG2P(2,JX)),JX=1,3)
!       WRITE(7,21) 'σ(2+) =',(DREAL(SIG2P(2,JX)),JX=1,3)
!       WRITE(6,20)           (DREAL(SIG2P(3,JX)),JX=1,3)
!       WRITE(7,20)           (DREAL(SIG2P(3,JX)),JX=1,3)
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       WRITE(6, *) 'Diamagnetic shielding tensor (ppm au):'
!       WRITE(7, *) 'Diamagnetic shielding tensor (ppm au):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,20)           (DREAL(SIG2N(1,JX)),JX=1,3)
!       WRITE(7,20)           (DREAL(SIG2N(1,JX)),JX=1,3)
!       WRITE(6,21) 'σ(2-) =',(DREAL(SIG2N(2,JX)),JX=1,3)
!       WRITE(7,21) 'σ(2-) =',(DREAL(SIG2N(2,JX)),JX=1,3)
!       WRITE(6,20)           (DREAL(SIG2N(3,JX)),JX=1,3)
!       WRITE(7,20)           (DREAL(SIG2N(3,JX)),JX=1,3)
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       WRITE(6, *) 'Total nuclear magnetic shielding tensor (ppm au):'
!       WRITE(7, *) 'Total nuclear magnetic shielding tensor (ppm au):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,20)           (DREAL(SIGMA(1,JX)),JX=1,3)
!       WRITE(7,20)           (DREAL(SIGMA(1,JX)),JX=1,3)
!       WRITE(6,21) '    σ =',(DREAL(SIGMA(2,JX)),JX=1,3)
!       WRITE(7,21) '    σ =',(DREAL(SIGMA(2,JX)),JX=1,3)
!       WRITE(6,20)           (DREAL(SIGMA(3,JX)),JX=1,3)
!       WRITE(7,20)           (DREAL(SIGMA(3,JX)),JX=1,3)
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 22    FORMAT(8X,'|',6X,A,8X,A,8X,A,2X,'|',7X,A)
! 23    FORMAT(1X,A,'|',F14.8,2X,F14.8,2X,F14.8,2X,'|',1X,F14.8)
!       WRITE(6, *) 'Spherical averages (ppm au):'
!       WRITE(7, *) 'Spherical averages (ppm au):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) 'σ_(xx)  ','σ_(yy)  ','σ_(zz)  ','sig(tot)'
!       WRITE(7,22) 'σ_(xx)  ','σ_(yy)  ','σ_(zz)  ','sig(tot)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,23) 'sig(1 )',(DREAL(SIG1G(IX,IX)),IX=1,3),D1G
!       WRITE(7,23) 'sig(1 )',(DREAL(SIG1G(IX,IX)),IX=1,3),D1G
!       WRITE(6,23) 'sig(2+)',(DREAL(SIG2P(IX,IX)),IX=1,3),D2P
!       WRITE(7,23) 'sig(2+)',(DREAL(SIG2P(IX,IX)),IX=1,3),D2P
!       WRITE(6,23) 'sig(2-)',(DREAL(SIG2N(IX,IX)),IX=1,3),D2N
!       WRITE(7,23) 'sig(2-)',(DREAL(SIG2N(IX,IX)),IX=1,3),D2N
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,23) 'σ  ',(DREAL(SIGMA(IX,IX)),IX=1,3),DSG
!       WRITE(7,23) 'σ  ',(DREAL(SIGMA(IX,IX)),IX=1,3),DSG
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE GTENSOR(GAUGE)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     GGGGGG TTTTTTTT EEEEEEEE NN    NN  SSSSSS   OOOOOO  RRRRRRR      C
! C    GG    GG   TT    EE       NNN   NN SS    SS OO    OO RR    RR     C
! C    GG         TT    EE       NNNN  NN SS       OO    OO RR    RR     C
! C    GG         TT    EEEEEE   NN NN NN  SSSSSS  OO    OO RR    RR     C
! C    GG   GGG   TT    EE       NN  NNNN       SS OO    OO RRRRRRR      C
! C    GG    GG   TT    EE       NN   NNN SS    SS OO    OO RR    RR     C
! C     GGGGGG    TT    EEEEEEEE NN    NN  SSSSSS   OOOOOO  RR    RR     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  GTENSOR CALCULATES THE ELECTRONIC G-TENSOR AND THUS CHARACTERISES   C
! C  THE MAGNETIC MOMENT AND GYROMAGNETIC RATIO FOR A MOLECULAR SYSTEM.  C
! C  (IT IS ESSENTIALLY A PROPORTIONALITY CONSTANT THAT RELATES THE      C
! C  OBSERVED MAGNETIC MOMENTS OF A PARTICLE TO ITS ANGULAR MOMENTUM     C
! C  QUANTUM NUMBER AND A UNIT OF MAGNETIC MOMENT.)                      C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION GAUGE(3)
! C
!       COMPLEX*16 CONE,SUMX,SUMY,SUMZ
!       COMPLEX*16 VX(MDM),VY(MDM),VZ(MDM)
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
!      &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
!      &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
!      &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
!       COMPLEX*16 WX(MDM,MDM),WY(MDM,MDM),WZ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/EIGC/COEF
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     ANOMALOUS MAGNETIC MOMENT OF THE ELECTRON
!       ANOMAG = GFREE-2.0D0
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In GTENSOR: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In GTENSOR: not possible for this Hamiltonian!'
!       ENDIF
! C
! C**********************************************************************C
! C     PREPARE MATRIX ELEMENT INTEGRALS                                 C
! C**********************************************************************C
! C
! C     MATRIX ELEMENT INTEGRALS
!       CALL VMOMNT1(DXYLS,GAUGE,2,1,2,1,2)
!       CALL VMOMNT1(DXZLS,GAUGE,2,1,3,1,2)
!       CALL VMOMNT1(DYXLS,GAUGE,2,2,1,1,2)
!       CALL VMOMNT1(DYZLS,GAUGE,2,2,3,1,2)
!       CALL VMOMNT1(DZXLS,GAUGE,2,3,1,1,2)
!       CALL VMOMNT1(DZYLS,GAUGE,2,3,2,1,2)
! C
!       CALL VMOMNT1(DXYSL,GAUGE,3,1,2,1,2)
!       CALL VMOMNT1(DXZSL,GAUGE,3,1,3,1,2)
!       CALL VMOMNT1(DYXSL,GAUGE,3,2,1,1,2)
!       CALL VMOMNT1(DYZSL,GAUGE,3,2,3,1,2)
!       CALL VMOMNT1(DZXSL,GAUGE,3,3,1,1,2)
!       CALL VMOMNT1(DZYSL,GAUGE,3,3,2,1,2)
! C
! C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         X-DIRECTION
!           WX(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
!           WX(I     ,J+NSKP) = DYZLS(I,J)-DZYLS(I,J)
!           WX(I+NSKP,J     ) = DYZSL(I,J)-DZYSL(I,J)
!           WX(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)
! C
! C         Y-DIRECTION
!           WY(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
!           WY(I     ,J+NSKP) = DZXLS(I,J)-DXZLS(I,J)
!           WY(I+NSKP,J     ) = DZXSL(I,J)-DXZSL(I,J)
!           WY(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)
! C
! C         Z-DIRECTION
!           WZ(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
!           WZ(I     ,J+NSKP) = DXYLS(I,J)-DYXLS(I,J)
!           WZ(I+NSKP,J     ) = DXYSL(I,J)-DYXSL(I,J)
!           WZ(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     COMPUTE EXPECTATION VALUES MANUALLY BECAUSE SPIN EIGENFUNCTIONS  C
! C     ARE NOT THE SAME AS SPATIAL EIGENFUNCTIONS -- NEED LINEAR COMBO. C
! C**********************************************************************C
! C
! 29    FORMAT(1X,A,I3,A)
! 30    FORMAT(1X,A,2X,3(14X,'E^(',I1,')',A))
! 31    FORMAT(1X,I3,' Re:',F21.9,F22.9,F22.9)
! 32    FORMAT(4X,' Im:',F21.9,F22.9,F22.9)
!       WRITE(6,29) 'Expectation value for each orbital IOCC (in MHz):'
!       WRITE(7,29) 'Expectation value for each orbital IOCC (in MHz):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
!       WRITE(7,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C     LOOP OVER ORBITALS
!       DO IOCC=NSKP+1,NSKP+NOCC+2
! C
! C       SOLUTIONS MUST COUPLE IN KRAMER PAIRS
!         IF(MOD(IOCC,2).EQ.0) THEN
!           NP =-1
!         ELSE
!           NP = 1
!         ENDIF
! C
! C       INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
!         SUMX = DCMPLX(0.0D0,0.0D0)
!         SUMY = DCMPLX(0.0D0,0.0D0)
!         SUMZ = DCMPLX(0.0D0,0.0D0)
! C
! C       LOOP OVER FOCK MATRIX ADDRESSES
!         DO I=1,NDIM
!           DO J=1,NDIM
! C
! C           ADDITIONS TO EACH CARTESIAN COMPONENT
!             SUMX = SUMX + DCONJG(COEF(I,IOCC))*COEF(J,IOCC+NP)*WX(I,J)
!             SUMY = SUMY + DCONJG(COEF(I,IOCC))*COEF(J,IOCC+NP)*WY(I,J)
!             SUMZ = SUMZ + DCONJG(COEF(I,IOCC))*COEF(J,IOCC   )*WZ(I,J)
! C
!           ENDDO
!         ENDDO
! C
! C       SAVE SUM
!         VX(IOCC) = SUMX
!         VY(IOCC) =-SUMY*CONE
!         VZ(IOCC) = SUMZ
! C
!       ENDDO
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_GTENSOR_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=NSKP+1,NSKP+NOCC+2
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC-NSKP,2.0D0*CV*DABS(DREAL(VX(IOCC)))+ANOMAG,
!      &                          2.0D0*CV*DABS(DREAL(VY(IOCC)))+ANOMAG,
!      &                          2.0D0*CV*DABS(DREAL(VZ(IOCC)))+ANOMAG
!           WRITE(7,31) IOCC-NSKP,2.0D0*CV*DABS(DREAL(VX(IOCC)))+ANOMAG,
!      &                          2.0D0*CV*DABS(DREAL(VY(IOCC)))+ANOMAG,
!      &                          2.0D0*CV*DABS(DREAL(VZ(IOCC)))+ANOMAG
!           WRITE(8,31) IOCC-NSKP,2.0D0*CV*DABS(DREAL(VX(IOCC)))+ANOMAG,
!      &                          2.0D0*CV*DABS(DREAL(VY(IOCC)))+ANOMAG,
!      &                          2.0D0*CV*DABS(DREAL(VZ(IOCC)))+ANOMAG
! C
!           WRITE(6,32) 2.0D0*CV*DABS(DIMAG(VX(IOCC))),
!      &                2.0D0*CV*DABS(DIMAG(VY(IOCC))),
!      &                2.0D0*CV*DABS(DIMAG(VZ(IOCC)))
!           WRITE(7,32) 2.0D0*CV*DABS(DIMAG(VX(IOCC))),
!      &                2.0D0*CV*DABS(DIMAG(VY(IOCC))),
!      &                2.0D0*CV*DABS(DIMAG(VZ(IOCC)))
!           WRITE(8,32) 2.0D0*CV*DABS(DIMAG(VX(IOCC))),
!      &                2.0D0*CV*DABS(DIMAG(VY(IOCC))),
!      &                2.0D0*CV*DABS(DIMAG(VZ(IOCC)))
! C
! C         SEPARATOR FOR VIRTUAL SPECTRUM
!           IF(IOCC.EQ.NSKP+NOCC) THEN
!             WRITE(6, *) REPEAT('=',72)
!             WRITE(7, *) REPEAT('=',72)
!             WRITE(8, *) REPEAT('=',72)
!           ELSEIF(IOCC.LT.NSKP+NOCC+2) THEN
!             WRITE(6, *) REPEAT('-',72)
!             WRITE(7, *) REPEAT('-',72)
!             WRITE(8, *) REPEAT('-',72)
!           ENDIF
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE EEDMSML(IZ,IOCC)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C EEEEEEEE EEEEEEEE DDDDDDD  MM       MM  SSSSSS  MM       MM LL       C
! C EE       EE       DD    DD MMM     MMM SS    SS MMM     MMM LL       C
! C EE       EE       DD    DD MMMM   MMMM SS       MMMM   MMMM LL       C
! C EEEEEE   EEEEEE   DD    DD MM MM MM MM  SSSSSS  MM MM MM MM LL       C
! C EE       EE       DD    DD MM  MMM  MM       SS MM  MMM  MM LL       C
! C EE       EE       DD    DD MM   M   MM SS    SS MM   M   MM LL       C
! C EEEEEEEE EEEEEEEE DDDDDDD  MM       MM  SSSSSS  MM       MM LLLLLLLL C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  EEDMSML PERFORMS AN ATOM-CENTRED PT-ODD ELECTRON EDM ANALYSIS,      C
! C  USING THE SMALL-SMALL OVERLAP AND ELECTRIC FIELD OPERATOR.          C
! C  THE DIPOLE MOMENT STRENGTH 'DE' HAS BEEN FACTORED AWAY FROM THIS.   C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ   - THE NUCLEAR CENTRE OF INTEREST.                            C
! C  ▶ IOCC - THE ORBITAL OF INTEREST.                                   C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION XYZ(3)
! C
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 EFLDX(MDM,MDM),EFLDY(MDM,MDM),EFLDZ(MDM,MDM)
!       COMPLEX*16 EFLD(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In EEDMSML: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In EEDMSML: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE TEMPORARY STORAGE ARRAYS
!       DO I=1,NDIM
!         DO J=1,NDIM
!           EFLDX(I,J) = DCMPLX(0.0D0,0.0D0)
!           EFLDY(I,J) = DCMPLX(0.0D0,0.0D0)
!           EFLDZ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     ADJUST NUCLEAR CHARGE OF CENTRE IZ
!       DO IX=1,3
!         XYZ(IX) = BXYZ(IX,IZ)
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VMNPOLE(EFLDX,XYZ,4,1,1,1,2)
!       CALL VMNPOLE(EFLDY,XYZ,4,2,2,1,2)
!       CALL VMNPOLE(EFLDZ,XYZ,4,3,3,1,2)
! C
! C     MULTIPLY RESULTS BY APPROPRIATE FACTOR
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EFLD(I,J) = EFLDX(I,J)+EFLDY(I,J)+EFLDZ(I,J)
!           EFLD(I,J) = 2.0D0*ZNUC(IZ)*EFLD(I,J)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,EMPTY,EMPTY,EMPTY,EFLD,NORD)
! C
! C     MATRIX ELEMENT (WITH |DE| FACTORED OUT) IN HARTEE
!       WDAU = ABS(V1(NSKP+IOCC,NSKP+IOCC,5))
! C
! C     MATRIX ELEMENT IN HERTZ
!       WDHZ = WDAU*CHZ
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_EEDMSML_V.dat',STATUS='UNKNOWN')
!       WRITE(11, *) V1(IOCC,IOCC,5)
!       CLOSE(UNIT=11)
! C
! 29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
! 30    FORMAT(24X,ES17.10,1X,A)
!       WRITE(6,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
!       WRITE(7,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
!       WRITE(6,30)                                WDHZ,'Hz'
!       WRITE(7,30)                                WDHZ,'Hz'
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE EEDMEFF(IOCC)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   EEEEEEEE EEEEEEEE DDDDDDD  MM       MM EEEEEEEE FFFFFFFF FFFFFFFF  C
! C   EE       EE       DD    DD MMM     MMM EE       FF       FF        C
! C   EE       EE       DD    DD MMMM   MMMM EE       FF       FF        C
! C   EEEEEE   EEEEEE   DD    DD MM MM MM MM EEEEEE   FFFFFF   FFFFFF    C
! C   EE       EE       DD    DD MM  MMM  MM EE       FF       FF        C
! C   EE       EE       DD    DD MM   M   MM EE       FF       FF        C
! C   EEEEEEEE EEEEEEEE DDDDDDD  MM       MM EEEEEEEE FF       FF        C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  EEDMEFF PERFORMS ONE-BODY EFFECTIVE ELECTRON EDM ANALYSIS.          C
! C  THE DIPOLE MOMENT STRENGTH 'DE' HAS BEEN FACTORED AWAY FROM THIS.   C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IOCC - THE ORBITAL OF INTEREST.                                   C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 PLS(MDM,MDM),PSL(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In EEDMEFF: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In EEDMEFF: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE TEMPORARY STORAGE ARRAYS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           PLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           PSL(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VLPLACE(PLS,2,0,1,2)
!       CALL VLPLACE(PSL,3,0,1,2)
! C
! C     MULTIPLY RESULTS BY APPROPRIATE FACTOR
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           PLS(I,J) =-2.0D0*CV*CONE*PLS(I,J)
!           PSL(I,J) = 2.0D0*CV*CONE*PSL(I,J)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,EMPTY,PLS,PSL,EMPTY,NORD)
! C
! C     MATRIX ELEMENT (WITH |DE| FACTORED OUT) IN HARTEE
!       WDAU = ABS(V1(NSKP+IOCC,NSKP+IOCC,5))
! C
! C     MATRIX ELEMENT IN HERTZ
!       WDHZ = WDAU*CHZ
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_EEDMEFF_V.dat',STATUS='UNKNOWN')
!       WRITE(11, *) V1(IOCC,IOCC,5)
!       CLOSE(UNIT=11)
! C
! 29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
! 30    FORMAT(24X,ES17.10,1X,A)
!       WRITE(6,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
!       WRITE(7,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
!       WRITE(6,30)                                WDHZ,'Hz'
!       WRITE(7,30)                                WDHZ,'Hz'
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE ENHANFC(IOCC)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    EEEEEEEE NN    NN HH    HH    AA    NN    NN FFFFFFFF CCCCCC      C
! C    EE       NNN   NN HH    HH   AAAA   NNN   NN FF      CC    CC     C
! C    EE       NNNN  NN HH    HH  AA  AA  NNNN  NN FF      CC           C
! C    EEEEEE   NN NN NN HHHHHHHH AA    AA NN NN NN FFFFFF  CC           C
! C    EE       NN  NNNN HH    HH AAAAAAAA NN  NNNN FF      CC           C
! C    EE       NN   NNN HH    HH AA    AA NN   NNN FF      CC    CC     C
! C    EEEEEEEE NN    NN HH    HH AA    AA NN    NN FF       CCCCCC      C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  ENHANFC CALCULATES THE ELECTRON EDM ENHANCEMENT FACTOR VALUE        C
! C  AS GIVEN IN (10.10) OF HAAKON SKAANE'S PHD THESIS.                  C
! C -------------------------------------------------------------------- C
! C  ▶ SINCE THE R-VECTOR IS A CROSSING TERM IN SECOND ORDER P.T.,       C
! C    CALCULATIONS HERE ARE DONE EXPLICITLY.                            C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION GAUGE(3)
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 SC,PC
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 VLL0X(MDM,MDM),VLL0Y(MDM,MDM),VLL0Z(MDM,MDM),
!      &           VSS0X(MDM,MDM),VSS0Y(MDM,MDM),VSS0Z(MDM,MDM),
!      &           VLS0(MDM,MDM),VSL0(MDM,MDM)
!       COMPLEX*16 SLL(MDM,MDM,3),SSS(MDM,MDM,3)
!       COMPLEX*16 VS(MDM,MDM,3),VP(MDM,MDM)
!       COMPLEX*16 RNEG(3),RPOS(3),RTOT(3)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/EIGC/COEF
!       COMMON/EIGE/EIGN(MDM)
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In ENHANFC: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In ENHANFC: not possible for this Hamiltonian!'
!       ENDIF
! C
! C**********************************************************************C
! C     PREPARATION OF MATRIX ELEMENTS                                   C
! C**********************************************************************C
! C
! C     DEFINE 'GAUGE' AS THE ORIGIN
!       DO IX=1,3
!         GAUGE(IX) = 0.0D0
!       ENDDO
! C
! C     FIRST MOMENT MATRIX ELEMENTS
!       CALL VMOMNT1(VLL0X,GAUGE,1,0,1,1,2)
!       CALL VMOMNT1(VLL0Y,GAUGE,1,0,2,1,2)
!       CALL VMOMNT1(VLL0Z,GAUGE,1,0,3,1,2)
! C
!       CALL VMOMNT1(VSS0X,GAUGE,4,0,1,1,2)
!       CALL VMOMNT1(VSS0Y,GAUGE,4,0,2,1,2)
!       CALL VMOMNT1(VSS0Z,GAUGE,4,0,3,1,2)
! C
! C     CONSTRUCT STARK SPLITTING MATRIX
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           SLL(I,J,1) = VLL0X(I,J)
!           SLL(I,J,2) = VLL0Y(I,J)
!           SLL(I,J,3) = VLL0Z(I,J)
!           SSS(I,J,1) = VSS0X(I,J)
!           SSS(I,J,2) = VSS0Y(I,J)
!           SSS(I,J,3) = VSS0Z(I,J)
!         ENDDO
!       ENDDO
! C
! C     LAPLACIAN MATRIX ELEMENTS
!       CALL VLPLACE(VLS0,2,0,1,2)
!       CALL VLPLACE(VSL0,3,0,1,2)
! C
! C     CONSTRUCT EFFECTIVE EDM OPERATOR BY MULTIPLICATION
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLS0(I,J) = 2.0D0*CV*CONE*VLS0(I,J)
!           VSL0(I,J) =-2.0D0*CV*CONE*VSL0(I,J)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     FULL LIST OF FIRST-ORDER TERMS                                   C
! C**********************************************************************C
! C
! C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
!       DO IA=1,NDIM
!         DO IK=1,NDIM
! C
! C         MATRIX ELEMENTS REQUIRE (OCC,UNOCC) COMBINATIONS ONLY
!           IF(IA.GT.NSKP.AND.IA.LE.(NSKP+NOCC+IOCC)) THEN
!             IAOCC = 1
!           ELSE
!             IAOCC = 0
!           ENDIF
!           IF(IK.GT.NSKP.AND.IK.LE.(NSKP+NOCC+IOCC)) THEN
!             IKOCC = 1
!           ELSE
!             IKOCC = 0
!           ENDIF
! C
!           IF(IAOCC.EQ.IKOCC) GOTO 150
! C
! C         LOOP OVER CARTESIAN INDEX IX
!           DO IX=1,3
! C
! C           INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
!             SC = DCMPLX(0.0D0,0.0D0)
! C
! C           LOOP OVER FOCK MATRIX ADDRESSES
!             DO I=1,NDIM-NSKP
!               DO J=1,NDIM-NSKP
! C
!                 K = I+NSKP
!                 L = J+NSKP
! C
! C               ACCOUNT ONLY FOR LL AND SS COMPONENT OVERLAPS
!                 SC = SC + DCONJG(COEF(I,IA))*COEF(J,IK)*SLL(I,J,IX)
!      &                  + DCONJG(COEF(K,IA))*COEF(L,IK)*SSS(I,J,IX)
! C
!               ENDDO
!             ENDDO
! C
! C           SAVE COUNTERS TO MATRICES
!             VS(IA,IK,IX) = SC
! C
!           ENDDO
! C
! C         INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
!           PC = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FOCK MATRIX ADDRESSES
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
! C
!               K = I+NSKP
!               L = J+NSKP
! C
! C             ACCOUNT ONLY FOR LS AND SL COMPONENT OVERLAPS
!               PC = PC + DCONJG(COEF(I,IA))*COEF(L,IK)*VLS0(I,J)
!      &                + DCONJG(COEF(K,IA))*COEF(J,IK)*VSL0(I,J)
! C
!             ENDDO
!           ENDDO
! C
! C         SAVE COUNTERS TO MATRICES
!           VP(IA,IK) = PC
! C
! 150       CONTINUE
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     CALCULATION OF SECOND-ORDER CROSSING TERM, E^(2)_CROSS.          C
! C**********************************************************************C
! C
! C     INITIALISE R VECTOR
!       DO IX=1,3
!         RPOS(IX) = DCMPLX(0.0D0,0.0D0)
!         RNEG(IX) = DCMPLX(0.0D0,0.0D0)
!         RTOT(IX) = DCMPLX(0.0D0,0.0D0)
!       ENDDO
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS IA
!       DO IA=NSKP+1,NSKP+NOCC+IOCC
! C
! C       EIGENVALUE ENERGY FOR THIS ORBITAL
!         EA = EIGN(IA)
! C
! C       POSITIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E+ STATES
!         DO IK=NSKP+NOCC+IOCC+1,NDIM
! C
! C         ENERGY DIFFERENCE FOR THIS (EA,EK)
!           EAK = EA-EIGN(IK)
! C
! C         GENENERATE ENERGY CONDITIONAL
!           IF(DABS(EAK).LT.1.0D-3) GOTO 81
! C
! C         LOOP OVER CARTESIAN INDICES IX
!           DO IX=1,3
! C
! C           CONTRIBUTIONS TO EACH PART OF THE CORRECTION
!             RPOS(IX) = RPOS(IX)
!      &                 +        VS(IA,IK,IX)*VP(IK,IA)/EAK
!      &                 + DCONJG(VS(IA,IK,IX)*VP(IK,IA)/EAK)
!           ENDDO
! C
! 81        CONTINUE
! C
! C       END POSITIVE-ENERGY LOOP
!         ENDDO
! C
! C       NEGATIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E- STATES
!         DO IK=1,NSKP
! C
! C         ENERGY DIFFERENCE FOR THIS (EA,EK)
!           EAK = EA-EIGN(IK)
! C
! C         GENENERATE ENERGY CONDITIONAL
!           IF(DABS(EAK).LT.1.0D-3) GOTO 82
! C
! C         LOOP OVER CARTESIAN INDICES IX
!           DO IX=1,3
! C
! C           CONTRIBUTIONS TO EACH PART OF THE CORRECTION
!             RNEG(IX) = RNEG(IX)
!      &                 +        VS(IA,IK,IX)*VP(IK,IA)/EAK
!      &                 + DCONJG(VS(IA,IK,IX)*VP(IK,IA)/EAK)
! C
!           ENDDO
! C
! 82        CONTINUE
! C
! C       END NEGATIVE-ENERGY LOOP
!         ENDDO
! C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     TOTAL CONTRIBUTION
!       DO IX=1,3
!         RTOT(IX) = RPOS(IX) + RNEG(IX)
!       ENDDO
! C
! C     SPHERICAL AVERAGE
!       DPOS = 0.0D0
!       DNEG = 0.0D0
!       DTOT = 0.0D0
!       DO IX=1,3
!         DPOS = DPOS + DREAL(RPOS(IX))**2
!         DNEG = DNEG + DREAL(RNEG(IX))**2
!         DTOT = DTOT + DREAL(RTOT(IX))**2
!       ENDDO
!       DPOS = DSQRT(DPOS)
!       DNEG = DSQRT(DNEG)
!       DTOT = DSQRT(DTOT)
! C
! 22    FORMAT(8X,'|',9X,A,11X,A,11X,A,2X,'|',9X,A)
! 23    FORMAT(1X,A,2X,' |',F14.8,2X,F14.8,2X,F14.8,2X,'|',1X,F14.8)
!       WRITE(6, *) 'eEDM enhancement factor components (au):'
!       WRITE(7, *) 'eEDM enhancement factor components (au):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) 'R_(x)','R_(y)','R_(z)','R(tot)'
!       WRITE(7,22) 'R_(x)','R_(y)','R_(z)','R(tot)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,23) 'R(+)',(DREAL(RPOS(IX)),IX=1,3),DPOS
!       WRITE(7,23) 'R(+)',(DREAL(RPOS(IX)),IX=1,3),DPOS
!       WRITE(6,23) 'R(-)',(DREAL(RNEG(IX)),IX=1,3),DNEG
!       WRITE(7,23) 'R(-)',(DREAL(RNEG(IX)),IX=1,3),DNEG
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,23) 'R(t)',(DREAL(RTOT(IX)),IX=1,3),DTOT
!       WRITE(7,23) 'R(t)',(DREAL(RTOT(IX)),IX=1,3),DTOT
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE SCLPTEN(IZ,IOCC)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      SSSSSS   CCCCCC  LL       PPPPPPP TTTTTTTT EEEEEEEE NN    NN    C
! C     SS    SS CC    CC LL       PP    PP   TT    EE       NNN   NN    C
! C     SS       CC       LL       PP    PP   TT    EE       NNNN  NN    C
! C      SSSSSS  CC       LL       PP    PP   TT    EEEEEE   NN NN NN    C
! C           SS CC       LL       PPPPPPP    TT    EE       NN  NNNN    C
! C     SS    SS CC    CC LL       PP         TT    EE       NN   NNN    C
! C      SSSSSS   CCCCCC  LLLLLLLL PP         TT    EEEEEEEE NN    NN    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  SCLPTEN IS A SCALAR PT-ODD ELECTRON-NUCLEUS INTERACTION ANALYSIS.   C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 VNUCLS(MDM,MDM),VNUCSL(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In SCLPTEN: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In SCLPTEN: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE TEMPORARY STORAGE ARRAYS
!       DO I=1,NDIM
!         DO J=1,NDIM
!           VNUCLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VNUCSL(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     NUCLEAR CHARGE FOR THIS CENTRE
!       ZCNT = ZNUC(IZ)
! C
! C     GENERATE NUCLEAR ATTRACTION OVERLAP INTEGRALS
!       CALL VNCATRC(VNUCLS,ZCNT,IZ,2,0,1,2)
!       CALL VNCATRC(VNUCSL,ZCNT,IZ,3,0,1,2)
! C
! C     MULTIPLY RESULTS BY NUMERICAL FACTORS (NOT GFRMI OR GPT1)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VNUCLS(I,J) = CONE*VNUCLS(I,J)/TW12
!           VNUCSL(I,J) =-CONE*VNUCSL(I,J)/TW12
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,EMPTY,VNUCLS,VNUCSL,EMPTY,NORD)
! C
! C     MATRIX ELEMENT (MULTIPLIED BY GFRMI) IN HARTEE
!       WPAU = ABS(V1(NSKP+IOCC,NSKP+IOCC,5))*GFRMI
! C
! C     MATRIX ELEMENT IN HERTZ
!       WPHZ = WPAU*CHZ
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_SCLPTEN_V.dat',STATUS='UNKNOWN')
!       WRITE(11, *) V1(IOCC,IOCC,5)
!       CLOSE(UNIT=11)
! C
! 29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
! 30    FORMAT(25X,ES17.10,1X,A)
!       WRITE(6,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
!       WRITE(7,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
!       WRITE(6,30)                                 WPHZ,'Hz'
!       WRITE(7,30)                                 WPHZ,'Hz'
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VECPTEN(IZ,IOCC,ISPN)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     VV    VV EEEEEEEE CCCCCC  PPPPPPP TTTTTTTT EEEEEEEE NN    NN     C
! C     VV    VV EE      CC    CC PP    PP   TT    EE       NNN   NN     C
! C     VV    VV EE      CC       PP    PP   TT    EE       NNNN  NN     C
! C     VV    VV EEEEEE  CC       PP    PP   TT    EEEEEE   NN NN NN     C
! C      VV  VV  EE      CC       PPPPPPP    TT    EE       NN  NNNN     C
! C       VVVV   EE      CC    CC PP         TT    EE       NN   NNN     C
! C        VV    EEEEEEEE CCCCCC  PP         TT    EEEEEEEE NN    NN     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VECPTEN GIVES A VECTOR PT-ODD ELECTRON-NUCLEUS INTERACTION ANALYSIS.C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 VXLS(MDM,MDM),VYLS(MDM,MDM),VZLS(MDM,MDM),VLS(MDM,MDM),
!      &           VXSL(MDM,MDM),VYSL(MDM,MDM),VZSL(MDM,MDM),VSL(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In VECPTEN: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In VECPTEN: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE TEMPORARY STORAGE ARRAYS
!       DO I=1,NDIM
!         DO J=1,NDIM
! C
!           VXLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VYLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VZLS(I,J) = DCMPLX(0.0D0,0.0D0)
! C
!           VXSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VYSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VZSL(I,J) = DCMPLX(0.0D0,0.0D0)
! C
!           VLS(I,J)  = DCMPLX(0.0D0,0.0D0)
!           VSL(I,J)  = DCMPLX(0.0D0,0.0D0)
! C
!         ENDDO
!       ENDDO
! C
! C     EFFECTIVE NUCLEAR CHARGE (USING THE NORMALISED DISTRIBUTION HERE)
!       ZCNT = 1.0D0
! C
! C     GENERATE NUCLEAR ATTRACTION OVERLAP INTEGRALS
!       CALL VNCATRC(VXLS,ZCNT,IZ,2,1,1,2)
!       CALL VNCATRC(VYLS,ZCNT,IZ,2,2,1,2)
!       CALL VNCATRC(VZLS,ZCNT,IZ,2,3,1,2)
!       CALL VNCATRC(VXSL,ZCNT,IZ,3,1,1,2)
!       CALL VNCATRC(VYSL,ZCNT,IZ,3,2,1,2)
!       CALL VNCATRC(VZSL,ZCNT,IZ,3,3,1,2)
! C
! C     MULTIPLY RESULTS BY NUMERICAL FACTORS (NOT GFRMI OR GPT1)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
!           VLS(I,J) = VXLS(I,J)+VYLS(I,J)+VZLS(I,J)
!           VSL(I,J) = VXSL(I,J)+VYSL(I,J)+VZSL(I,J)
! C
!           VLS(I,J) = 0.5D0*CONE*VLS(I,J)*DFLOAT(ISPN)/TW12
!           VSL(I,J) =-0.5D0*CONE*VSL(I,J)*DFLOAT(ISPN)/TW12
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,EMPTY,VLS,VSL,EMPTY,NORD)
! C
! C     MATRIX ELEMENT (MULTIPLIED BY GFRMI) IN HARTEE
!       WPAU = ABS(V1(NSKP+IOCC,NSKP+IOCC,5))*GFRMI
! C
! C     MATRIX ELEMENT IN HERTZ
!       WPHZ = WPAU*CHZ
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_VECPTEN_V.dat',STATUS='UNKNOWN')
!       WRITE(11, *) V1(IOCC,IOCC,5)
!       CLOSE(UNIT=11)
! C
! 29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
! 30    FORMAT(25X,ES17.10,1X,A)
!       WRITE(6,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
!       WRITE(7,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
!       WRITE(6,30)                                 WPHZ,'Hz'
!       WRITE(7,30)                                 WPHZ,'Hz'
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE NUCMAGQ(IZ,ISPN,LPRT,IOCC)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C NN    NN UU    UU  CCCCCC  MM       MM    AA     GGGGGG    QQQQQQ    C
! C NNN   NN UU    UU CC    CC MMM     MMM   AAAA   GG    GG  QQ    QQ   C
! C NNNN  NN UU    UU CC       MMMM   MMMM  AA  AA  GG       QQ      QQ  C
! C NN NN NN UU    UU CC       MM MM MM MM AA    AA GG       QQ      QQ  C
! C NN  NNNN UU    UU CC       MM  MMM  MM AAAAAAAA GG   GGG QQ      QQ  C
! C NN   NNN UU    UU CC    CC MM   M   MM AA    AA GG    GG  QQ    QQ   C
! C NN    NN  UUUUUU   CCCCCC  MM       MM AA    AA  GGGGGG    QQQQQQ QQ C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  NUCMAGQ GIVES A NUCLEAR MAGNETIC QUADRUPOLE INTERACTION ANALYSIS    C
! C  AS A SINGLE UNPAIRED PROTON IN A SPHERICAL NUCLEUS INTERACTS WITH   C
! C  THE MAGNETIC FIELD OF ELECTRONS IN THE SYSTEM. THE PROTON HAS MASS  C
! C  PMSS AS WELL AS AN UNKNOWN EDM (PEDM) AND AN ORBITAL NUMBER LPRT,   C
! C  WHILE ITS PARENT NUCLEUS HAS NUCLEAR SPIN ISPN (2*THE ACTUAL VALUE).C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 VXLS(MDM,MDM),VYLS(MDM,MDM),VZLS(MDM,MDM),VLS(MDM,MDM),
!      &           VXSL(MDM,MDM),VYSL(MDM,MDM),VZSL(MDM,MDM),VSL(MDM,MDM)
! C
!       DIMENSION QMT(3,3),VECI(3)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In NUCMAGQ: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In NUCMAGQ: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     ANGULAR QUANTUM NUMBER FOR THE VALENCE PROTON
!       IPOW = (ISPN+1-LPRT)/2
!       KPRT = (-1)**IPOW
!       KPRT = KPRT*(ISPN+1)/2
! C
! C     INTERACTION CONSTANT (NOT INCLUDING PROTON EDM)
!       MNUM = (ISPN-1)*(1-2*KPRT)
!       MDEN = ISPN+2
!       CALM = DFLOAT(MNUM)/(CV*PMSS*DFLOAT(MDEN))
! C
! C     PRE-FACTOR FOR NUCLEAR MAGNETIC QUADRUPOLE MOMENT TENSOR
!       IF(ISPN.NE.1) THEN
!         PRE = 3.0D0*CALM/DFLOAT(ISPN*(ISPN-1))
!       ELSE
!         PRE = 0.0D0
!       ENDIF

!       WRITE(6, *) ISPN,LPRT,KPRT,CALM,PRE
!       WRITE(7, *) ISPN,LPRT,KPRT,CALM,PRE
! C
! C     NUCLEAR SPIN AS A VECTOR
!       VECI(1) = 0.0D0
!       VECI(2) = 0.0D0
!       VECI(3) = 0.5D0*DFLOAT(ISPN)
! C
! C     QUADRUPOLE MOMENT TENSOR
!       DO I=1,3
!         DO J=1,3
!           T1 = VECI(I)*VECI(J)
!           T2 = VECI(J)*VECI(I)
!           IF(I.EQ.J) THEN
!             T3 = DFLOAT(ISPN*(ISPN+2))/6.0D0
!           ELSE
!             T3 = 0.0D0
!           ENDIF
!           QMT(I,J) = T1+T2+T3
!         ENDDO
!       ENDDO
! C
! C     PRINT BARE NUCLEAR QUADRUPOLE MOMENT TENSOR TIJ
!       DO I=1,3
!         WRITE(6, *) (QMT(I,J),J=1,3)
!         WRITE(7, *) (QMT(I,J),J=1,3)
!       ENDDO
! C
!       DO I=1,3
!         DO J=1,3
!           QMT(I,J) = PRE*QMT(I,J)
!         ENDDO
!       ENDDO
      
!       WRITE(6, *) '----'
!       WRITE(7, *) '----'
! C
! C     PRINT NUCLEAR QUADRUPOLE MOMENT TENSOR TIJ
!       DO I=1,3
!         WRITE(6, *) (QMT(I,J),J=1,3)
!         WRITE(7, *) (QMT(I,J),J=1,3)
!       ENDDO

!       STOP
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE TEMPORARY STORAGE ARRAYS
!       DO I=1,NDIM
!         DO J=1,NDIM
! C
!           VXLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VYLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VZLS(I,J) = DCMPLX(0.0D0,0.0D0)
! C
!           VXSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VYSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VZSL(I,J) = DCMPLX(0.0D0,0.0D0)
! C
!           VLS(I,J)  = DCMPLX(0.0D0,0.0D0)
!           VSL(I,J)  = DCMPLX(0.0D0,0.0D0)
! C
!         ENDDO
!       ENDDO
! C
! C     EFFECTIVE NUCLEAR CHARGE (USING THE NORMALISED DISTRIBUTION HERE)
!       ZCNT = 1.0D0
! C
! C     GENERATE NUCLEAR ATTRACTION OVERLAP INTEGRALS
!       CALL VNCATRC(VXLS,ZCNT,IZ,2,1,1,2)
!       CALL VNCATRC(VYLS,ZCNT,IZ,2,2,1,2)
!       CALL VNCATRC(VZLS,ZCNT,IZ,2,3,1,2)
!       CALL VNCATRC(VXSL,ZCNT,IZ,3,1,1,2)
!       CALL VNCATRC(VYSL,ZCNT,IZ,3,2,1,2)
!       CALL VNCATRC(VZSL,ZCNT,IZ,3,3,1,2)
! C
! C     MULTIPLY RESULTS BY NUMERICAL FACTORS (NOT GFRMI OR GPT1)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
!           VLS(I,J) = VXLS(I,J)+VYLS(I,J)+VZLS(I,J)
!           VSL(I,J) = VXSL(I,J)+VYSL(I,J)+VZSL(I,J)
! C
!           VLS(I,J) = 0.5D0*CONE*VLS(I,J)*DFLOAT(ISPN)/TW12
!           VSL(I,J) =-0.5D0*CONE*VSL(I,J)*DFLOAT(ISPN)/TW12
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,EMPTY,VLS,VSL,EMPTY,NORD)
! C
! C     MATRIX ELEMENT (MULTIPLIED BY GFRMI) IN HARTEE
!       WPAU = ABS(V1(NSKP+IOCC,NSKP+IOCC,5))*GFRMI
! C
! C     MATRIX ELEMENT IN HERTZ
!       WPHZ = WPAU*CHZ
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_NUCMAGQ_V.dat',STATUS='UNKNOWN')
!       WRITE(11, *) V1(IOCC,IOCC,5)
!       CLOSE(UNIT=11)
! C
! 29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
! 30    FORMAT(25X,ES17.10,1X,A)
!       WRITE(6,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
!       WRITE(7,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
!       WRITE(6,30)                                 WPHZ,'Hz'
!       WRITE(7,30)                                 WPHZ,'Hz'
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE PVIOLTN(NEUT)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C       PPPPPPP  VV    VV IIII OOOOOO  LL      TTTTTTTT NN    NN       C
! C       PP    PP VV    VV  II OO    OO LL         TT    NNN   NN       C
! C       PP    PP VV    VV  II OO    OO LL         TT    NNNN  NN       C
! C       PP    PP VV    VV  II OO    OO LL         TT    NN NN NN       C
! C       PPPPPPP   VV  VV   II OO    OO LL         TT    NN  NNNN       C
! C       PP         VVVV    II OO    OO LL         TT    NN   NNN       C
! C       PP          VV    IIII OOOOOO  LLLLLLLL   TT    NN    NN       C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  PVIOLTN PERFORMS A P-ODD EFFECTIVE OPERATOR ANALYSIS.               C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ NEUT: LIST OF NEUTRON NUMBERS FOR EACH OF THE NUCLEAR CENTRES.    C
! C -------------------------------------------------------------------- C
! C TODO: THE IMAGINARY COMPONENTS OF EORB DO NOT SUM TO ZERO -- A       C
! C       RELIC OF INTER-ATOMIC MATRIX ELEMENTS AND THE ASSIGNMENT OF    C
! C       PHASE `CONE' TO THE SMALL COMPONENT TO ENSURE REAL ATOM-       C
! C       CENTRED RESULTS. FOR DISCUSSIONS ON THIS, SEE:                 C
! C       Phys. Chem. Chem. Phys., 2011, 13, 864–876                     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*2  ELMT(120)
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       COMPLEX*16 ETOT,ETKR
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 VNUCLS(MDM,MDM),VNUCSL(MDM,MDM)
!       COMPLEX*16 EORB(MCT,MDM)
!       COMPLEX*16 ECNT(MCT),EKRM(MCT),EIOCC(MDM)
! C
!       DIMENSION QWNI(MCT),NEUT(MCT),NUCL(MCT),LF(MCT)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/EIGC/COEF
!       COMMON/EIGE/EIGN(MDM)
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/MDLV/ELMT
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
!       COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In PVIOLTN: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In PVIOLTN: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     INITIALISE MATRICES
!       DO IZ=1,NCNT
!         DO IOCC=1,NOCC
!           EORB(IZ,IOCC) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     PRE-FACTOR
!       PRE = GFRMI*CHZ*0.5D0/TW12
! C
! C     LOOP OVER NUCLEAR CENTRES
!       DO IZ=1,NCNT
! C
! C       NUMBER OF NUCLEONS NUCL AND WEAK NUCLEAR CHARGE QWNI
!         NUCL(IZ) = INT(ZNUC(IZ))+NEUT(IZ)
!         QWNI(IZ) =-DFLOAT(NEUT(IZ))+ZNUC(IZ)*(1.0D0-4.0D0*WEIN)
! C
! C       GENERATE NUCLEAR ATTRACTION OVERLAP INTEGRALS
!         CALL VNCOLAP(VNUCLS,IZ,2,0,1,2)
!         CALL VNCOLAP(VNUCSL,IZ,3,0,1,2)
! C
! C       LOOP OVER DISTINCT OCCUPIED KRAMERS ORBITALS
!         DO IOCC=1,NOCC
! C
! C         OCCUPIED LABEL
!           ISKP = IOCC+NSKP
! C
! C         LOOP OVER FOCK MATRIX ADDRESSES
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
! C
! C             LARGE AND SMALL CONTRIBUTIONS
!               EORB(IZ,IOCC) = EORB(IZ,IOCC)
!      &        + DCONJG(COEF(I     ,ISKP))*COEF(J+NSKP,ISKP)*VNUCLS(I,J)
!      &        + DCONJG(COEF(I+NSKP,ISKP))*COEF(J     ,ISKP)*VNUCSL(I,J)
! C
!             ENDDO
!           ENDDO
! C
!         ENDDO
! C
!       ENDDO
! C
! C     MULTIPLY BY PRE-FACTOR AND WEAK NUCLEAR CHARGE
!       DO IZ=1,NCNT
!         DO IOCC=1,NOCC
!           EORB(IZ,IOCC) = PRE*QWNI(IZ)*EORB(IZ,IOCC)
!         ENDDO
!       ENDDO
! C
! C     TOTAL FOR EACH ELECTRON
!       DO IOCC=1,NOCC
!         EIOCC(IOCC) = DCMPLX(0.0D0,0.0D0)
!         DO IZ=1,NCNT
!           EIOCC(IOCC) = EIOCC(IOCC) + EORB(IZ,IOCC)
!         ENDDO
!       ENDDO
! C
! C     TOTAL FOR EACH NUCLEUS
!       DO IZ=1,NCNT
!         ECNT(IZ) = DCMPLX(0.0D0,0.0D0)
!         DO IOCC=1,NOCC
!           ECNT(IZ) = ECNT(IZ) + EORB(IZ,IOCC)
!         ENDDO
!       ENDDO
! C
! C     KRAMERS TOTAL FOR EACH NUCLEUS
!       DO IZ=1,NCNT
!         EKRM(IZ) = DCMPLX(0.0D0,0.0D0)
!         DO IOCC=1,NOCC,2
!           EKRM(IZ) = EKRM(IZ) + EORB(IZ,IOCC)
!         ENDDO
!       ENDDO
! C
! C     GRAND TOTAL
!       ETOT = DCMPLX(0.0D0,0.0D0)
!       ETKR = DCMPLX(0.0D0,0.0D0)
!       DO IZ=1,NCNT
!         ETOT = ETOT + ECNT(IZ)
!         ETKR = ETKR + EKRM(IZ)
!       ENDDO
! C
! C     LENGTH OF SPACINGS IN RESULTS TABLE
!       LTB = 40+18*NCNT
!       DO IZ=1,NCNT
!         LF(IZ) = 14-LEN(TRIM(ELMT(INT(ZNUC(IZ)))))
!       ENDDO
! C
!       WRITE(6, *) 'P-odd effective operator analysis (given in Hz):'
!       WRITE(7, *) 'P-odd effective operator analysis (given in Hz):'
!       WRITE(6, *) ''
!       WRITE(7, *) ''
!       WRITE(6, *) 'Table of real components ℜ (E):'
!       WRITE(7, *) 'Table of real components ℜ (E):'
!       WRITE(6, *) REPEAT('=',LTB)
!       WRITE(7, *) REPEAT('=',LTB)
! C
! 86    FORMAT(1X,A,3X,A,' |',5(A,I3,' ',A),1X,'|',12X,'Total')
! 87    FORMAT(2X,I3,1X,F14.6,1X,'|',1X,5(F17.6,1X),'|',F17.6)
! 88    FORMAT(1X,A,13X,'|',1X,5(F17.6,1X),'|',F17.6)
! C
!       WRITE(6,86) 'IOCC','  Eigen (au)',
!      & (REPEAT(' ',LF(IZ)),NUCL(IZ),TRIM(ELMT(INT(ZNUC(IZ)))),IZ=1,NCNT)
!       WRITE(7,86) 'IOCC','  Eigen (au)',
!      & (REPEAT(' ',LF(IZ)),NUCL(IZ),TRIM(ELMT(INT(ZNUC(IZ)))),IZ=1,NCNT)
!       WRITE(6, *) REPEAT('-',LTB)
!       WRITE(7, *) REPEAT('-',LTB)
!       DO IOCC=1,NOCC
!         ISKP = IOCC+NSKP
!         WRITE(6,87) IOCC,EIGN(ISKP),(DREAL(EORB(IZ,IOCC)),IZ=1,NCNT),
!      &                                               DREAL(EIOCC(IOCC))
!         WRITE(7,87) IOCC,EIGN(ISKP),(DREAL(EORB(IZ,IOCC)),IZ=1,NCNT),
!      &                                               DREAL(EIOCC(IOCC))
!       ENDDO
!       WRITE(6, *) REPEAT('-',LTB)
!       WRITE(7, *) REPEAT('-',LTB)
!       WRITE(6,88) 'Nucleus',(DREAL(ECNT(IZ)),IZ=1,NCNT),DREAL(ETOT)
!       WRITE(7,88) 'Nucleus',(DREAL(ECNT(IZ)),IZ=1,NCNT),DREAL(ETOT)
!       WRITE(6,88) 'Kramers',(DREAL(EKRM(IZ)),IZ=1,NCNT),DREAL(ETKR)
!       WRITE(7,88) 'Kramers',(DREAL(EKRM(IZ)),IZ=1,NCNT),DREAL(ETKR)
! C
!       WRITE(6, *) REPEAT('=',LTB)
!       WRITE(7, *) REPEAT('=',LTB)
!       WRITE(6, *) ''
!       WRITE(7, *) ''
!       WRITE(6, *) 'Table of imaginary components ℑ (E):'
!       WRITE(7, *) 'Table of imaginary components ℑ (E):'
!       WRITE(6, *) REPEAT('=',LTB)
!       WRITE(7, *) REPEAT('=',LTB)
! C
!       WRITE(6,86) 'IOCC','  Eigen (au)',
!      & (REPEAT(' ',LF(IZ)),NUCL(IZ),TRIM(ELMT(INT(ZNUC(IZ)))),IZ=1,NCNT)
!       WRITE(7,86) 'IOCC','  Eigen (au)',
!      & (REPEAT(' ',LF(IZ)),NUCL(IZ),TRIM(ELMT(INT(ZNUC(IZ)))),IZ=1,NCNT)
!       WRITE(6, *) REPEAT('-',LTB)
!       WRITE(7, *) REPEAT('-',LTB)
!       DO IOCC=1,NOCC
!         ISKP = IOCC+NSKP
!         WRITE(6,87) IOCC,EIGN(ISKP),(DIMAG(EORB(IZ,IOCC)),IZ=1,NCNT),
!      &                                               DIMAG(EIOCC(IOCC))
!         WRITE(7,87) IOCC,EIGN(ISKP),(DIMAG(EORB(IZ,IOCC)),IZ=1,NCNT),
!      &                                               DIMAG(EIOCC(IOCC))
!       ENDDO
!       WRITE(6, *) REPEAT('-',LTB)
!       WRITE(7, *) REPEAT('-',LTB)
!       WRITE(6,88) 'Nucleus',(DIMAG(ECNT(IZ)),IZ=1,NCNT),DIMAG(ETOT)
!       WRITE(7,88) 'Nucleus',(DIMAG(ECNT(IZ)),IZ=1,NCNT),DIMAG(ETOT)
!       WRITE(6,88) 'Kramers',(DIMAG(EKRM(IZ)),IZ=1,NCNT),DIMAG(ETKR)
!       WRITE(7,88) 'Kramers',(DIMAG(EKRM(IZ)),IZ=1,NCNT),DIMAG(ETKR)
! C
!       WRITE(6, *) REPEAT('=',LTB)
!       WRITE(7, *) REPEAT('=',LTB)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE BETADCY(IZ,ZDCY)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     BBBBBBB  EEEEEEEE TTTTTTTT   AA    DDDDDDD   CCCCCC  YY    YY    C
! C     BB    BB EE          TT     AAAA   DD    DD CC    CC YY    YY    C
! C     BB    BB EE          TT    AA  AA  DD    DD CC        YY  YY     C
! C     BBBBBBB  EEEEEE      TT   AA    AA DD    DD CC         YYYY      C
! C     BB    BB EE          TT   AAAAAAAA DD    DD CC          YY       C
! C     BB    BB EE          TT   AA    AA DD    DD CC    CC    YY       C
! C     BBBBBBB  EEEEEEEE    TT   AA    AA DDDDDDD   CCCCCC     YY       C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  BETADCY TAKES THE RADIOACTIVE DECAY PROCESS IN WHICH ATOMIC CENTRE  C
! C  IZ LOSES AN AMOUNT OF CHARGE ZDCY, AND PERFORMS AN ANALYSIS.        C
! C -------------------------------------------------------------------- C
! C  ▶ NUCLEAR RADII REMAIN UNCHANGED IN THIS ANALYSIS.                  C
! C  ▶ RESULTS MAKE MOST SENSE FOR A ONE-ELECTRON PROBLEM.               C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION XYZ(3)
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 E1(5)
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 VNUCLL(MDM,MDM),VNUCSS(MDM,MDM),EMPTY(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     ADJUST NUCLEAR CHARGE OF CENTRE IZ
!       DO IX=1,3
!         XYZ(IX) = BXYZ(IX,IZ)
!       ENDDO
! C
! C     NEW NUCLEAR CHARGE OF DECAYED CENTRE
!       ZNEW = ZNUC(IZ)-ZDCY
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE NUCLEAR ATTRACTION OVERLAP MATRICES
!       CALL VNCATRC(VNUCLL,ZDCY,IZ,1,0,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VNCATRC(VNUCSS,ZDCY,IZ,4,0,1,2)
!       ENDIF
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,VNUCLL,EMPTY,EMPTY,VNUCSS)
! C
!       WRITE(6, *) 'Beta decay analysis:'
!       WRITE(7, *) 'Beta decay analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     WRITE ENERGY DIFFERENCE EXPECTATION VALUE
! 20    FORMAT(1X,A,F15.10)
!       WRITE(6,20) 'Energy difference = ',DREAL(E1(5))
!       WRITE(7,20) 'Energy difference = ',DREAL(E1(5))
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 4
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VNUCLL,EMPTY,EMPTY,VNUCSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_BETADCY_V.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! 40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3)
! C
! C     Z-COMPONENT
!       WRITE(6,40) IOCC
!       WRITE(7,40) IOCC
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
!       CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE NUCOLAP(IZ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    NN    NN UU    UU  CCCCCC   OOOOOO  LL          AA    PPPPPPP     C
! C    NNN   NN UU    UU CC    CC OO    OO LL         AAAA   PP    PP    C
! C    NNNN  NN UU    UU CC       OO    OO LL        AA  AA  PP    PP    C
! C    NN NN NN UU    UU CC       OO    OO LL       AA    AA PP    PP    C
! C    NN  NNNN UU    UU CC       OO    OO LL       AAAAAAAA PPPPPPP     C
! C    NN   NNN UU    UU CC    CC OO    OO LL       AA    AA PP          C
! C    NN    NN  UUUUUU   CCCCCC   OOOOOO  LLLLLLLL AA    AA PP          C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  NUCOLAP CALCULATES THE INTEGRAL OF THE NUCLEAR DENSITY FUNCTION AND C
! C  OCCUPIED ORBITAL DENSITY (GAUSSIAN NUCLEAR MODEL.)                  C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 E1(5)
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VNCOLAP(OLAPLL,IZ,1,0,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VNCOLAP(OLAPSS,IZ,4,0,1,2)
!       ENDIF
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Direct overlap analysis:'
!       WRITE(7, *) 'Direct overlap analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(1X,'Component ',A,' charge density overlap with centre',
!      &                                              I2,' = ',F18.8)
! 21    FORMAT(' Total electron density overlap with centre',
!      &                                           I2,7X,' = ',F18.8)
!       IF(HMLT.EQ.'NORL') GOTO 22
!       WRITE(6,20) '{LL}',IZ,DREAL(E1(1))
!       WRITE(7,20) '{LL}',IZ,DREAL(E1(1))
!       WRITE(6,20) '{LS}',IZ,DREAL(E1(2))
!       WRITE(7,20) '{LS}',IZ,DREAL(E1(2))
!       WRITE(6,20) '{SL}',IZ,DREAL(E1(3))
!       WRITE(7,20) '{SL}',IZ,DREAL(E1(3))
!       WRITE(6,20) '{SS}',IZ,DREAL(E1(4))
!       WRITE(7,20) '{SS}',IZ,DREAL(E1(4))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! 22    CONTINUE
!       WRITE(6,21) IZ,DREAL(E1(5))
!       WRITE(7,21) IZ,DREAL(E1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.8,2X,F21.8,2X,F21.8)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCOLAP_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCOLAP_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
!           CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE NUCGRAD0(IZ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    NN    NN UU    UU  CCCCCC   GGGGGG  RRRRRRR  DDDDDDD   000000     C
! C    NNN   NN UU    UU CC    CC GG    GG RR    RR DD    DD 00   000    C
! C    NNNN  NN UU    UU CC       GG       RR    RR DD    DD 00  0000    C
! C    NN NN NN UU    UU CC       GG       RR    RR DD    DD 00 00 00    C
! C    NN  NNNN UU    UU CC       GG   GGG RRRRRRR  DD    DD 0000  00    C
! C    NN   NNN UU    UU CC    CC GG    GG RR    RR DD    DD 000   00    C
! C    NN    NN  UUUUUU   CCCCCC   GGGGGG  RR    RR DDDDDDD   000000     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  NUCGRAD0 CALCULATES THE INTEGRAL OF A SUPPLIED NUCLEAR DENSITY      C
! C  MODEL AND THE GRADIENT OF THE OCCUPIED ELECTRON DENSITY. (ATOMIC.)  C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
!      &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VNCGRAD0(DZLL,IZ,1,0)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VNCGRAD0(DZSS,IZ,4,0)
!       ENDIF
! C
! C     VALUE OF THE POTENTIAL AT THE ORIGIN
!       V0 =-2.0D0*ZNUC(IZ)*FNUC(IZ,IFT)*DSQRT(XNUC(IZ,IFT))/PI12
!       DO IFT=1,NNUC(IZ)
!         V0 = V0 + ZNUC(IZ)*FNUC(IZ,IFT)
!       ENDDO
! C
! c      do i=1,ndim-nskp
! c        do j=1,ndim-nskp
! c          dzll(i,j) = dzll(i,j)*(v0/(v0-2.0d0*cv*cv)-1.0d0)
! c        enddo
! c      enddo
! C
! C     MULTIPLY ALL RESULTS BY FACTOR -CV*CV/V0
! C      DO I=1,NDIM
! C        DO J=1,NDIM
! C          DXLL(I,J) =-CV*CV*DXLL(I,J)/V0
! C          DYLL(I,J) =-CV*CV*DYLL(I,J)/V0
! C          DZLL(I,J) =-CV*CV*DZLL(I,J)/V0
! C          IF(HMLT.NE.'NORL') THEN
! C            DXSS(I,J) = 0.0D0
! C            DYSS(I,J) = 0.0D0
! C            DZSS(I,J) = 0.0D0
! C          ENDIF
! C        ENDDO
! C      ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Nuclear/electron gradient interaction analysis:'
!       WRITE(7, *) 'Nuclear/electron gradient interaction analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
!       CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
!       CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(1X,'d_',A,5X,' = (',F16.6,',',F16.6,',',F16.6,') au')
!       IF(HMLT.EQ.'NORL') GOTO 23
!       WRITE(6,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
!       WRITE(7,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
!       WRITE(6,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
!       WRITE(7,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! 23    CONTINUE
!       WRITE(6,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,DZLL,EMPTY,EMPTY,DZSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_VZ1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! CC
! CC         DIAGRAMATIC PERTURBATION THEORY ON V1
! C          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! CC
! CC         WRITE RESULTS TO FILE
! C          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE NUCGRAD1(IZ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      NN    NN UU    UU  CCCCCC   GGGGGG  RRRRRRR  DDDDDDD   11       C
! C      NNN   NN UU    UU CC    CC GG    GG RR    RR DD    DD 111       C
! C      NNNN  NN UU    UU CC       GG       RR    RR DD    DD  11       C
! C      NN NN NN UU    UU CC       GG       RR    RR DD    DD  11       C
! C      NN  NNNN UU    UU CC       GG   GGG RRRRRRR  DD    DD  11       C
! C      NN   NNN UU    UU CC    CC GG    GG RR    RR DD    DD  11       C
! C      NN    NN  UUUUUU   CCCCCC   GGGGGG  RR    RR DDDDDDD  1111      C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  NUCGRAD1 CALCULATES THE INTEGRAL OF A SUPPLIED NUCLEAR DENSITY      C
! C  MODEL AND THE GRADIENT OF THE OCCUPIED ELECTRON DENSITY. (ATOMIC.)  C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
!      &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VNCGRAD1(DZLL,IZ,1,0)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VNCGRAD1(DZSS,IZ,4,0)
!       ENDIF
! C
! C     VALUE OF THE POTENTIAL AT THE ORIGIN
!       V0 =-2.0D0*ZNUC(IZ)*FNUC(IZ,IFT)*DSQRT(XNUC(IZ,IFT))/PI12
!       DO IFT=1,NNUC(IZ)
!         V0 = V0 + ZNUC(IZ)*FNUC(IZ,IFT)
!       ENDDO
! C
! c      do i=1,ndim-nskp
! c        do j=1,ndim-nskp
! c          dzll(i,j) = dzll(i,j)*(v0/(v0-2.0d0*cv*cv)-1.0d0)
! c        enddo
! c      enddo
! C
! C     MULTIPLY ALL RESULTS BY FACTOR -CV*CV/V0
! C      DO I=1,NDIM
! C        DO J=1,NDIM
! C          DXLL(I,J) =-CV*CV*DXLL(I,J)/V0
! C          DYLL(I,J) =-CV*CV*DYLL(I,J)/V0
! C          DZLL(I,J) =-CV*CV*DZLL(I,J)/V0
! C          IF(HMLT.NE.'NORL') THEN
! C            DXSS(I,J) = 0.0D0
! C            DYSS(I,J) = 0.0D0
! C            DZSS(I,J) = 0.0D0
! C          ENDIF
! C        ENDDO
! C      ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Nuclear/electron gradient interaction analysis:'
!       WRITE(7, *) 'Nuclear/electron gradient interaction analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
!       CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
!       CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(1X,'d_',A,5X,' = (',F16.6,',',F16.6,',',F16.6,') au')
!       IF(HMLT.EQ.'NORL') GOTO 23
!       WRITE(6,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
!       WRITE(7,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
!       WRITE(6,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
!       WRITE(7,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! 23    CONTINUE
!       WRITE(6,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,DZLL,EMPTY,EMPTY,DZSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_VZ1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
! C          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
! C          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE NUCGRAD2(IZ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    NN    NN UU    UU  CCCCCC   GGGGGG  RRRRRRR  DDDDDDD   222222     C
! C    NNN   NN UU    UU CC    CC GG    GG RR    RR DD    DD 22    22    C
! C    NNNN  NN UU    UU CC       GG       RR    RR DD    DD       22    C
! C    NN NN NN UU    UU CC       GG       RR    RR DD    DD     22      C
! C    NN  NNNN UU    UU CC       GG   GGG RRRRRRR  DD    DD   22        C
! C    NN   NNN UU    UU CC    CC GG    GG RR    RR DD    DD 22          C
! C    NN    NN  UUUUUU   CCCCCC   GGGGGG  RR    RR DDDDDDD  22222222    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  NUCGRAD2 CALCULATES THE INTEGRAL OF A SUPPLIED NUCLEAR DENSITY      C
! C  MODEL AND THE GRADIENT OF THE OCCUPIED ELECTRON DENSITY.            C
! C  USES A MOLECULAR BASIS SET, BUT SAMPLES EXACTLY AT THE NUCLEUS.     C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
!      &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE RAW INTEGRALS
!       CALL VNCGRAD2(DZLL,IZ,1,0,3,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VNCGRAD2(DZSS,IZ,4,0,3,1,2)
!       ENDIF
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Gradient interaction analysis NUCGRAD2:'
!       WRITE(7, *) 'Gradient interaction analysis NUCGRAD2:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
! C     CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
! C     CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
!       CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(1X,'d_',A,5X,' = (',F16.6,',',F16.6,',',F16.6,') au')
!       IF(HMLT.EQ.'NORL') GOTO 23
!       WRITE(6,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
!       WRITE(7,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
!       WRITE(6,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
!       WRITE(7,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! 23    CONTINUE
!       WRITE(6,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,DZLL,EMPTY,EMPTY,DZSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRD2_VZ1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRD2_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
! C          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
! C          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
      SUBROUTINE NUCSCHF(IZ,CLOC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   SSSSSS   CCCCCC  HH    HH FFFFFFFF    C
C    NNN   NN UU    UU CC    CC SS    SS CC    CC HH    HH FF          C
C    NNNN  NN UU    UU CC       SS       CC       HH    HH FF          C
C    NN NN NN UU    UU CC        SSSSSS  CC       HHHHHHHH FFFFFF      C
C    NN  NNNN UU    UU CC             SS CC       HH    HH FF          C
C    NN   NNN UU    UU CC    CC SS    SS CC    CC HH    HH FF          C
C    NN    NN  UUUUUU   CCCCCC   SSSSSS   CCCCCC  HH    HH FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCSCHF CALCULATES THE MOLECULAR SCHIFF INTERACTION WITH A NUCLEAR  C
C  SCHIFF MOMENT, IN THE FORM PROPOSED BY V.V. FLAMBAUM (2002).        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
      DIMENSION CLOC(3)
C
      COMPLEX*16 V1(MDM,MDM,5)
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
c     CALL VNCSCHF(DXLL,CLOC,IZ,1,0,1,1,2)
c     CALL VNCSCHF(DYLL,CLOC,IZ,1,0,2,1,2)
      CALL VNCSCHF(DZLL,CLOC,IZ,1,0,3,1,2)
      IF(HMLT.NE.'NORL') THEN
c       CALL VNCSCHF(DXSS,CLOC,IZ,4,0,1,1,2)
c       CALL VNCSCHF(DYSS,CLOC,IZ,4,0,2,1,2)
        CALL VNCSCHF(DZSS,CLOC,IZ,4,0,3,1,2)
      ENDIF
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
CC
C      WRITE(6, *) 'Nuclear/electron gradient interaction analysis:'
C      WRITE(7, *) 'Nuclear/electron gradient interaction analysis:'
C      WRITE(6, *) REPEAT('-',72)
C      WRITE(7, *) REPEAT('-',72)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
C      CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
C      CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
      CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
      WRITE(6,123) CLOC(3)*CFM,DREAL(EZ1(1)),DREAL(EZ1(4)),DREAL(EZ1(5))
      RETURN
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,'d_',A,2X,' = (',F16.8,',',F16.8,',',F19.8,') au')
      IF(HMLT.EQ.'NORL') GOTO 23
      WRITE(6,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
      WRITE(7,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
      WRITE(6,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
      WRITE(7,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
23    CONTINUE
      WRITE(6,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
123   FORMAT(1X,F16.8,1X,F21.8,1X,F21.8,1X,F21.8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      return
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,DZLL,EMPTY,EMPTY,DZSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_VZ1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
CC         DIAGRAMATIC PERTURBATION THEORY ON V1
C          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
CC
CC         WRITE RESULTS TO FILE
C          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
C          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
C          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
          WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
          WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
c
c
      SUBROUTINE NUCSCHFquad(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   SSSSSS   CCCCCC  HH    HH FFFFFFFF    C
C    NNN   NN UU    UU CC    CC SS    SS CC    CC HH    HH FF          C
C    NNNN  NN UU    UU CC       SS       CC       HH    HH FF          C
C    NN NN NN UU    UU CC        SSSSSS  CC       HHHHHHHH FFFFFF      C
C    NN  NNNN UU    UU CC             SS CC       HH    HH FF          C
C    NN   NNN UU    UU CC    CC SS    SS CC    CC HH    HH FF          C
C    NN    NN  UUUUUU   CCCCCC   SSSSSS   CCCCCC  HH    HH FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCSCHF CALCULATES THE MOLECULAR SCHIFF INTERACTION WITH A NUCLEAR  C
C  SCHIFF MOMENT, IN THE FORM PROPOSED BY V.V. FLAMBAUM (2002).        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 TITLE
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 V1(MDM,MDM,5)
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
      COMPLEX*16 DTT(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
      CALL VNCSCHFquadTEMP(DZLL,IZ,1)
      CALL VNCSCHFquadTEMP(DZSS,IZ,4)
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
c      CALL VNCSCHFquad(DZLL,IZ,1)
c      IF(HMLT.NE.'NORL') THEN
c        CALL VNCSCHFquad(DZSS,IZ,4)
c      ENDIF
C
C     HEAT MAP FOR THE MATRIX
      TITLE = 'NUCSCHF'
      DO I=1,NDIM/2
        DO J=1,NDIM/2
          DTT(I     ,J     ) = DZLL(I,J)
          DTT(I+NSKP,J     ) = DCMPLX(0.0D0,0.0D0)
          DTT(I     ,J+NSKP) = DCMPLX(0.0D0,0.0D0)
          DTT(I+NSKP,J+NSKP) = DZSS(I,J)
        ENDDO
      ENDDO
C     CALL ZGNUMAP(DTT,TITLE,NDIM)
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
      WRITE(6, *) 'Nuclear/electron gradient interaction analysis:'
      WRITE(7, *) 'Nuclear/electron gradient interaction analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
      CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
      CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,'d_',A,5X,' = (',F16.8,',',F16.8,',',F16.8,') au')
      IF(HMLT.EQ.'NORL') GOTO 23
      WRITE(6,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
      WRITE(7,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
      WRITE(6,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
      WRITE(7,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
23    CONTINUE
      WRITE(6,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,DZLL,EMPTY,EMPTY,DZSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_VZ1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
CC         DIAGRAMATIC PERTURBATION THEORY ON V1
C          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
CC
CC         WRITE RESULTS TO FILE
C          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
C          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
C          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
          WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
          WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
!      SUBROUTINE MAGEFF1(IZ)
!      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
!C**********************************************************************C
!C                                                                      C
!C     MM       MM    AA     GGGGGG  EEEEEEEE FFFFFFFF FFFFFFFF 11      C
!C     MMM     MMM   AAAA   GG    GG EE       FF       FF      111      C
!C     MMMM   MMMM  AA  AA  GG       EE       FF       FF       11      C
!C     MM MM MM MM AA    AA GG       EEEEEE   FFFFFF   FFFFFF   11      C
!C     MM  MMM  MM AAAAAAAA GG   GGG EE       FF       FF       11      C
!C     MM   M   MM AA    AA GG    GG EE       FF       FF       11      C
!C     MM       MM AA    AA  GGGGGG  EEEEEEEE FF       FF      1111     C
!C                                                                      C
!C -------------------------------------------------------------------- C
!C  MAGEFF1 CALCULATES THE MAGNETIC EFFECT FOR A LINEAR MOLECULE THAT'S C
!C  ORIENTED ALONG THE Z-DIRECTION, AND ACCOUNTS ONLY FOR ONE-CENTRE.   C
!C -------------------------------------------------------------------- C
!C  INPUT:                                                              C
!C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
!C**********************************************************************C
!      INCLUDE 'parameters.h'
!      INCLUDE 'scfoptions.h'
!C
!      CHARACTER*5  NMDL
!      CHARACTER*40 MOLCL,WFNFL,OUTFL
!C
!      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
!C
!      COMPLEX*16 V1(MDM,MDM,5)
!      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!      COMPLEX*16 EMPTY(MDM,MDM)
!      COMPLEX*16 DXLS(MDM,MDM),DYLS(MDM,MDM),DZLS(MDM,MDM),
!     &           DXSL(MDM,MDM),DYSL(MDM,MDM),DZSL(MDM,MDM)
!C
!      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!      COMMON/FLNM/MOLCL,WFNFL,OUTFL
!      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
!C
!C     INITIALISE DUMMY ARRAY
!      DO I=1,NDIM-NSKP
!        DO J=1,NDIM-NSKP
!          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!        ENDDO
!      ENDDO
!C
!C     OPERATOR STRUCTURE COUPLES L WITH S
!      IF(HMLT.EQ.'NORL') THEN
!        RETURN
!      ENDIF
!C
!C     GENERATE MAGNETIC MOMENT MATRIX
!      CALL VMAGEFF0(DZLS,IZ,2)
!      CALL VMAGEFF0(DZSL,IZ,3)
!C
!C     MULTIPLY ALL RESULTS BY FACTOR 1/SQRT(2.0)
!      DO I=1,NDIM!
!        DO J=1,NDIM
!          DXLS(I,J) = DXLS(I,J)/DSQRT(2.0D0)
!          DYLS(I,J) = DYLS(I,J)/DSQRT(2.0D0)
!          DZLS(I,J) = DZLS(I,J)/DSQRT(2.0D0)
!          DXSL(I,J) = DXSL(I,J)/DSQRT(2.0D0)
!          DYSL(I,J) = DYSL(I,J)/DSQRT(2.0D0)
!          DZSL(I,J) = DZSL(I,J)/DSQRT(2.0D0)
!        ENDDO
!      ENDDO
!C
!C**********************************************************************C
!C     MOLECULAR EXPECTATION VALUE                                      C
!C**********************************************************************C
!C
!      WRITE(6, *) 'Magnetic effect (1-centre) analysis:'
!      WRITE(7, *) 'Magnetic effect (1-centre) analysis:'
!      WRITE(6, *) REPEAT('-',72)
!      WRITE(7, *) REPEAT('-',72)
!C
!C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!      CALL PROPRTY(EX1,EMPTY,DXLS,DXSL,EMPTY)
!      CALL PROPRTY(EY1,EMPTY,DYLS,DYSL,EMPTY)
!      CALL PROPRTY(EZ1,EMPTY,DZLS,DZSL,EMPTY)
!C
!C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
!20    FORMAT(1X,'d_',A,5X,' = (',F16.6,',',F16.6,',',F16.6,') au')
!      IF(HMLT.EQ.'NORL') GOTO 23
!      WRITE(6,20) '{LS} ',DREAL(EX1(2)),DREAL(EY1(2)),DREAL(EZ1(2))
!      WRITE(7,20) '{LS} ',DREAL(EX1(2)),DREAL(EY1(2)),DREAL(EZ1(2))
!      WRITE(6,20) '{SL} ',DREAL(EX1(3)),DREAL(EY1(3)),DREAL(EZ1(3))
!      WRITE(7,20) '{SL} ',DREAL(EX1(3)),DREAL(EY1(3)),DREAL(EZ1(3))
!      WRITE(6, *) REPEAT('-',72)
!      WRITE(7, *) REPEAT('-',72)
!23    CONTINUE
!      WRITE(6,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!      WRITE(7,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!C
!C     END SECTION
!      WRITE(6, *) REPEAT('=',72)
!      WRITE(7, *) REPEAT('=',72)
!C
!C**********************************************************************C
!C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
!C**********************************************************************C
!C
!C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!      NORD = 1
!C
!30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
!31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!      WRITE(6, *) 'Expectation value for each orbital IOCC:'
!      WRITE(7, *) 'Expectation value for each orbital IOCC:'
!      WRITE(6, *) REPEAT('-',72)
!      WRITE(7, *) REPEAT('-',72)
!      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!     &                                       'E^{',NORD,'}[tot]'
!      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!     &                                       'E^{',NORD,'}[tot]'
!      WRITE(6, *) REPEAT('-',72)
!      WRITE(7, *) REPEAT('-',72)
!C
!C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!      CALL RSPT1(V1,EMPTY,DZLS,DZSL,EMPTY,NORD)
!C
!C     PRINT MATRIX ELEMENTS TO FILE
!      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MAGEFF1_VZ1.dat',STATUS='UNKNOWN')
!        DO IOCC=1,NDIM
!          WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!        ENDDO
!      CLOSE(UNIT=8)
!C
!C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!      IF(NORD.EQ.0) THEN
!        NAD = 0
!      ELSEIF(NORD.EQ.1) THEN
!        NAD = 1
!      ELSEIF(NORD.EQ.2) THEN
!        NAD = 2
!      ELSEIF(NORD.EQ.3) THEN
!        NAD = 5
!      ELSEIF(NORD.EQ.4) THEN
!        NAD = 10
!      ELSEIF(NORD.EQ.5) THEN
!        NAD = 20
!      ENDIF
!C
!C     OPEN EXTERNAL FILE
!      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MAGEFF1_EN.dat',STATUS='UNKNOWN')
!C
!C       LOOP OVER ALL OCCUPIED ORBITALS
!        DO IOCC=1,NOCC
!C
!C         DIAGRAMATIC PERTURBATION THEORY ON V1
!          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
!C
!C         WRITE RESULTS TO FILE
!          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!C
!C       END LOOP OVER OCCUPIED ORBITALS
!        ENDDO
!C
!C     CLOSE EXTERNAL FILE
!      CLOSE(UNIT=8)
!C
!C     END SECTION
!      WRITE(6, *) REPEAT('=',72)
!      WRITE(7, *) REPEAT('=',72)
!C
!      RETURN
!      END
! C
! C
!       SUBROUTINE MAGEFFP(IZ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C  MM       MM    AA     GGGGGG  EEEEEEEE FFFFFFFF FFFFFFFF PPPPPPP    C
! C  MMM     MMM   AAAA   GG    GG EE       FF       FF       PP    PP   C
! C  MMMM   MMMM  AA  AA  GG       EE       FF       FF       PP    PP   C
! C  MM MM MM MM AA    AA GG       EEEEEE   FFFFFF   FFFFFF   PP    PP   C
! C  MM  MMM  MM AAAAAAAA GG   GGG EE       FF       FF       PPPPPPP    C
! C  MM   M   MM AA    AA GG    GG EE       FF       FF       PP         C
! C  MM       MM AA    AA  GGGGGG  EEEEEEEE FF       FF       PP         C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  MAGEFFP CALCULATES THE MAGNETIC EFFECT FOR A LINEAR MOLECULE THAT'S C
! C  ORIENTED ALONG THE Z-DIRECTION, AND ACCOUNTS ONLY FOR ONE-CENTRE    C
! C  TERMS, BUT WITH PROJECTION AROUND MULTI-CENTRE CONTRIBUTIONS.       C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
!       CHARACTER*80 TITLE
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 Y,Z
!       COMPLEX*16 EZ1(5),VLS,VSL
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 EMPTY(MDM,MDM)
!       COMPLEX*16 DLS(MDM,MDM),DSL(MDM,MDM)
!       COMPLEX*16 DZLS(MDM,MDM),DZSL(MDM,MDM)
!       COMPLEX*16 AZLS(MDM,MDM),AZSL(MDM,MDM)
!       COMPLEX*16 OLL(MDM,MDM),OSS(MDM,MDM)
!       COMPLEX*16 TLS(MDM,MDM),TSL(MDM,MDM)
!       COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/DENS/DENC,DENO,DENT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
!       COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     OPERATOR STRUCTURE COUPLES L WITH S
!       IF(HMLT.EQ.'NORL') THEN
!         RETURN
!       ENDIF
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VMOMNT0(OLL,1,0,1,2)
!       CALL VMOMNT0(OSS,4,0,1,2)
! C
! C     GENERATE MAGNETIC MOMENT MATRIX
!       CALL VMAGEFF0(DZLS,IZ,2)
!       CALL VMAGEFF0(DZSL,IZ,3)
! C
! C     MULTIPLY ALL RESULTS BY FACTOR 1/SQRT(2.0)
!       DO I=1,NDIM
!         DO J=1,NDIM
!           DZLS(I,J) = DZLS(I,J)/DSQRT(2.0D0)
!           DZSL(I,J) = DZSL(I,J)/DSQRT(2.0D0)
!         ENDDO
!       ENDDO
! C
! CC
! CC     MULTIPLY MATRIX ELEMENTS BY ELECTRON DENSITY MATRIX
! C      DO I=1,NDIM-NSKP
! C        DO J=1,NDIM-NSKP
! C          VLS = DCMPLX(0.0D0,0.0D0)
! C          VSL = DCMPLX(0.0D0,0.0D0)
! C          DO K=1,NDIM-NSKP
! C            VLS = VLS + DZLS(I,K)*DENT(K     ,J+NSKP)
! C            VSL = VSL + DZSL(I,K)*DENT(K+NSKP,J     )
! C          ENDDO
! C          AZLS(I,J) = VLS
! C          AZSL(I,J) = VSL
! C        ENDDO
! C      ENDDO
! C
!       DO I=1,NSKP
!         DO J=1,NSKP
!           DLS(I,J) = DENT(I     ,J+NSKP)
!           DSL(I,J) = DENT(I+NSKP,J     )
!         ENDDO
!       ENDDO
! C
! C     MATRIX ALGEBRA PARAMETERS (MULTIPLIER AND ADDITIVE FACTOR)
!       Y = DCMPLX(1.0D0,0.0D0)
!       Z = DCMPLX(0.0D0,0.0D0)
! C
! C     COMPUTE AZLS = VLS.DLS AND AZSL = VSL.DSL
! C      CALL ZGEMM('N','N',NSKP,NSKP,NSKP,Y,DZLS,MDM,DLS,MDM,Z,AZLS,MDM)
! C      CALL ZGEMM('N','N',NSKP,NSKP,NSKP,Y,DZSL,MDM,DSL,MDM,Z,AZSL,MDM)
! C
! C     COMPUTE DZLS = OLL.VLS.OSS
!       CALL ZGEMM('N','N',NSKP,NSKP,NSKP,Y,OLL,MDM,DZLS,MDM,Z,TLS,MDM)
!       CALL ZGEMM('N','N',NSKP,NSKP,NSKP,Y,TLS,MDM,OSS,MDM,Z,DZLS,MDM)
! C
! C     COMPUTE DZSL = OSS.VSL.OLL
!       CALL ZGEMM('N','N',NSKP,NSKP,NSKP,Y,OSS,MDM,DZSL,MDM,Z,TSL,MDM)
!       CALL ZGEMM('N','N',NSKP,NSKP,NSKP,Y,TSL,MDM,OLL,MDM,Z,DZSL,MDM)
! CC
! CC     TOTAL ENERGY
! C      EZ1(2) = DCMPLX(0.0D0,0.0D0)
! C      EZ1(3) = DCMPLX(0.0D0,0.0D0)
! C      DO I=1,NSKP
! C        DO J=1,NSKP
! C          EZ1(2) = EZ1(2) + DZLS(I,J)
! C          EZ1(3) = EZ1(3) + DZSL(I,J)
! C        ENDDO
! C      ENDDO
! C      WRITE(6, *) EZ1(2),EZ1(3)
! C      WRITE(7, *) EZ1(2),EZ1(3)
! C      STOP
! C
! CC
! CC     PROJECTION MATRICES
! C      DO I=1,NDIM-NSKP
! C        VLS = DCMPLX(0.0D0,0.0D0)
! C        VSL = DCMPLX(0.0D0,0.0D0)
! C        DO J=1,NDIM-NSKP
! C          DO K=1,NDIM-NSKP
! C            VLS = VLS + DZLS(I,K)*OSS(K,J)
! C            VSL = VSL + DZSL(I,K)*OLL(K,J)
! C          ENDDO
! C          TLS(I,J) = VLS
! C          TSL(I,J) = VSL
! C        ENDDO
! C      ENDDO
! CC
! C      DO I=1,NDIM-NSKP
! C        VLS = DCMPLX(0.0D0,0.0D0)
! C        VSL = DCMPLX(0.0D0,0.0D0)
! C        DO J=1,NDIM-NSKP
! C          DO K=1,NDIM-NSKP
! C            VLS = VLS + OLL(I,K)*TLS(K,J)
! C            VSL = VSL + OSS(I,K)*TSL(K,J)
! C          ENDDO
! C          DZLS(I,J) = VLS
! C          DZSL(I,J) = VSL
! C        ENDDO
! C      ENDDO
! C
! C      IGNORE ATOM-CENTRED CONTRIBUTIONS
!        DO I=1,NSKP
!          DO J=1,NSKP
!            IF(LABICN(I).EQ.IZ.AND.LABICN(J).EQ.IZ) THEN
!              DZLS(I,J) = DCMPLX(0.0D0,0.0D0)
!              DZSL(I,J) = DCMPLX(0.0D0,0.0D0)
!            ENDIF
!          ENDDO
!        ENDDO
! C
! C       TITLE = 'DZLS'
! C       CALL ZGNUMAP(DZLS,TITLE,NSKP)
! C       TITLE = 'DZSL'
! C       CALL ZGNUMAP(DZSL,TITLE,NSKP)
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Magnetic effect (1-centre projected) analysis:'
!       WRITE(7, *) 'Magnetic effect (1-centre projected) analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(EZ1,EMPTY,DZLS,DZSL,EMPTY)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(1X,'d_',A,5X,' = (',F16.6,',',F16.6,',',F16.6,') au')
!       IF(HMLT.EQ.'NORL') GOTO 23
!       WRITE(6,20) '{LS} ',0.0D0,0.0D0,DREAL(EZ1(2))
!       WRITE(7,20) '{LS} ',0.0D0,0.0D0,DREAL(EZ1(2))
!       WRITE(6,20) '{SL} ',0.0D0,0.0D0,DREAL(EZ1(3))
!       WRITE(7,20) '{SL} ',0.0D0,0.0D0,DREAL(EZ1(3))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! 23    CONTINUE
!       WRITE(6,20) '{tot}',0.0D0,0.0D0,DREAL(EZ1(5))
!       WRITE(7,20) '{tot}',0.0D0,0.0D0,DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,EMPTY,DZLS,DZSL,EMPTY,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MAGEFFP_VZ1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MAGEFFP_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
!           CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE MGNTEDM(IZ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C MM       MM  GGGGGG  NN    NN TTTTTTTT EEEEEEEE DDDDDDD  MM       MM C
! C MMM     MMM GG    GG NNN   NN    TT    EE       DD    DD MMM     MMM C
! C MMMM   MMMM GG       NNNN  NN    TT    EE       DD    DD MMMM   MMMM C
! C MM MM MM MM GG       NN NN NN    TT    EEEEEE   DD    DD MM MM MM MM C
! C MM  MMM  MM GG   GGG NN  NNNN    TT    EE       DD    DD MM  MMM  MM C
! C MM   M   MM GG    GG NN   NNN    TT    EE       DD    DD MM   M   MM C
! C MM       MM  GGGGGG  NN    NN    TT    EEEEEEEE DDDDDDD  MM       MM C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  MGNTEDM CALCULATES THE MAGNETIC EDM MATRIX ELEMENTS (MANY-CENTRE,   C
! C  CARTESIAN REDUCTION), USING THE MOMENTUM OPERATOR DIRECTLY.         C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION ORIG(3)
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 VX1(MDM,MDM,5),VY1(MDM,MDM,5),VZ1(MDM,MDM,5),
!      &           EMPTY(MDM,MDM)
!       COMPLEX*16 PLSXXY(MDM,MDM),PLSXXZ(MDM,MDM),PLSXYX(MDM,MDM),
!      &           PLSXZX(MDM,MDM),PLSYXY(MDM,MDM),PLSYYX(MDM,MDM),
!      &           PLSYYZ(MDM,MDM),PLSYZY(MDM,MDM),PLSZXZ(MDM,MDM),
!      &           PLSZYZ(MDM,MDM),PLSZZX(MDM,MDM),PLSZZY(MDM,MDM)
!       COMPLEX*16 PSLXXY(MDM,MDM),PSLXXZ(MDM,MDM),PSLXYX(MDM,MDM),
!      &           PSLXZX(MDM,MDM),PSLYXY(MDM,MDM),PSLYYX(MDM,MDM),
!      &           PSLYYZ(MDM,MDM),PSLYZY(MDM,MDM),PSLZXZ(MDM,MDM),
!      &           PSLZYZ(MDM,MDM),PSLZZX(MDM,MDM),PSLZZY(MDM,MDM)
!       COMPLEX*16 VLSX(MDM,MDM),VLSY(MDM,MDM),VLSZ(MDM,MDM),
!      &           VSLX(MDM,MDM),VSLY(MDM,MDM),VSLZ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In MGNTEDM: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In MGNTEDM: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     DEFINE ORIGIN VECTOR
!       DO IX=1,3
!         ORIG(IX) = BXYZ(IX,IZ)
!       ENDDO
! C
! C     GENERATE RAW MATRIX ELEMENTS σ_IX.∇_IX.(R_JX)/R^3
!       CALL VMPL1DV(PLSXYX,ORIG,2,1,2,1,1,2)
!       CALL VMPL1DV(PLSXZX,ORIG,2,1,3,1,1,2)
!       CALL VMPL1DV(PLSYXY,ORIG,2,2,1,2,1,2)
!       CALL VMPL1DV(PLSYZY,ORIG,2,2,3,2,1,2)
!       CALL VMPL1DV(PLSZXZ,ORIG,2,3,1,3,1,2)
!       CALL VMPL1DV(PLSZYZ,ORIG,2,3,2,3,1,2)
! C
!       CALL VMPL1DV(PSLXYX,ORIG,3,1,2,1,1,2)
!       CALL VMPL1DV(PSLXZX,ORIG,3,1,3,1,1,2)
!       CALL VMPL1DV(PSLYXY,ORIG,3,2,1,2,1,2)
!       CALL VMPL1DV(PSLYZY,ORIG,3,2,3,2,1,2)
!       CALL VMPL1DV(PSLZXZ,ORIG,3,3,1,3,1,2)
!       CALL VMPL1DV(PSLZYZ,ORIG,3,3,2,3,1,2)
! C
! C     GENERATE RAW MATRIX ELEMENTS σ_IX.∇_JX.R_IX/R^3
!       CALL VMPL1DV(PLSYYX,ORIG,2,2,2,1,1,2)
!       CALL VMPL1DV(PLSZZX,ORIG,2,3,3,1,1,2)
!       CALL VMPL1DV(PLSXXY,ORIG,2,1,1,2,1,2)
!       CALL VMPL1DV(PLSZZY,ORIG,2,3,3,2,1,2)
!       CALL VMPL1DV(PLSXXZ,ORIG,2,1,1,3,1,2)
!       CALL VMPL1DV(PLSYYZ,ORIG,2,2,2,3,1,2)
! C
!       CALL VMPL1DV(PSLYYX,ORIG,3,2,2,1,1,2)
!       CALL VMPL1DV(PSLZZX,ORIG,3,3,3,1,1,2)
!       CALL VMPL1DV(PSLXXY,ORIG,3,1,1,2,1,2)
!       CALL VMPL1DV(PSLZZY,ORIG,3,3,3,2,1,2)
!       CALL VMPL1DV(PSLXXZ,ORIG,3,1,1,3,1,2)
!       CALL VMPL1DV(PSLYYZ,ORIG,3,2,2,3,1,2)
! C
! C     CONSTRUCT MAGNETIC EDM MATRIX ELEMENTS (p -> -ⅈℏ∇)
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         MAGNETIC EDM INTEGRAL BLOCK LS
!           VLSX(I,J) =-CONE*(            PLSYXY(I,J)+PLSZXZ(I,J))
!      &               +CONE*(            PLSYYX(I,J)+PLSZZX(I,J))
!           VLSY(I,J) =-CONE*(PLSXYX(I,J)+            PLSZYZ(I,J))
!      &               +CONE*(PLSXXY(I,J)+            PLSZZY(I,J))
!           VLSZ(I,J) =-CONE*(PLSXZX(I,J)+PLSYZY(I,J)            )
!      &               +CONE*(PLSXXZ(I,J)+PLSYYZ(I,J)            )
! C
! C         MAGNETIC EDM INTEGRAL BLOCK SL
!           VSLX(I,J) =-CONE*(            PSLYXY(I,J)+PSLZXZ(I,J))
!      &               +CONE*(            PSLYYX(I,J)+PSLZZX(I,J))
!           VSLY(I,J) =-CONE*(PSLXYX(I,J)+            PSLZYZ(I,J))
!      &               +CONE*(PSLXXY(I,J)+            PSLZZY(I,J))
!           VSLZ(I,J) =-CONE*(PSLXZX(I,J)+PSLYZY(I,J)            )
!      &               +CONE*(PSLXXZ(I,J)+PSLYYZ(I,J)            )
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Magnetic EDM operator analysis:'
!       WRITE(7, *) 'Magnetic EDM operator analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(EX1,EMPTY,VLSX,VSLX,EMPTY)
!       CALL PROPRTY(EY1,EMPTY,VLSY,VSLY,EMPTY)
!       CALL PROPRTY(EZ1,EMPTY,VLSZ,VSLZ,EMPTY)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(' <α×ℓ/r^3> = (',F17.10,',',F17.10,',',F17.10,')')
!       WRITE(6,20) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
!       WRITE(7,20) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! c30    FORMAT(1X,A,6X,A,7X,A,7X,A,' | ',3X,'<α×ℓ/r^3>^2')
! 31    FORMAT(1X,I3,1X,F16.10,1X,F16.10,1X,F16.10,1X,'|',F16.10)
! 32    FORMAT(1X,'tot',1X,F16.10,1X,F16.10,1X,F16.10,1X,'|',F16.10)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! c      WRITE(6,30) 'Orb.','<α×ℓ/r^3>_x','<α×ℓ/r^3>_y','<α×ℓ/r^3>_z'
! c      WRITE(7,30) 'Orb.','<α×ℓ/r^3>_x','<α×ℓ/r^3>_y','<α×ℓ/r^3>_z'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(VX1,EMPTY,VLSX,VSLX,EMPTY,1)
!       CALL RSPT1(VY1,EMPTY,VLSY,VSLY,EMPTY,1)
!       CALL RSPT1(VZ1,EMPTY,VLSZ,VSLZ,EMPTY,1)
! C
! C     COUNTER FOR TOTAL EXPECTATION VALUE      
!       APN = 0.0D0
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       DO IOCC=1,NOCC
! C
! C       WRITE RESULTS TO FILE
!         APX = DREAL(VX1(IOCC+NSKP,IOCC+NSKP,5))
!         APY = DREAL(VY1(IOCC+NSKP,IOCC+NSKP,5))
!         APZ = DREAL(VZ1(IOCC+NSKP,IOCC+NSKP,5))
!         APT = APX+APY+APZ
!         APN = APN + APT
!         WRITE(6,31) IOCC,APX,APY,APZ,APT
!         WRITE(7,31) IOCC,APX,APY,APZ,APT
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     REPEAT TOTAL VALUES
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5)),APN
!       WRITE(7,32) DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5)),APN
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE WKNEUTJ(IZ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   WW        WW KK    KK NN    NN EEEEEEEE UU    UU TTTTTTTT  JJJJJ   C
! C   WW        WW KK   KK  NNN   NN EE       UU    UU    TT       JJ    C
! C   WW   WW   WW KK  KK   NNNN  NN EE       UU    UU    TT       JJ    C
! C   WW  WWWW  WW KKKKK    NN NN NN EEEEEE   UU    UU    TT       JJ    C
! C   WW WW  WW WW KK  KK   NN  NNNN EE       UU    UU    TT       JJ    C
! C   WWWW    WWWW KK   KK  NN   NNN EE       UU    UU    TT JJ    JJ    C
! C   WW        WW KK    KK NN    NN EEEEEEEE  UUUUUU     TT  JJJJJJ     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  WKNEUTJ CALCULATES THE INTEGRAL OF THE NUCLEAR DENSITY FUNCTION AND C
! C  THE CURRENT OPERATOR.                                               C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 EX1(5),EY1(5),EZ1(5)
!       COMPLEX*16 VX1(MDM,MDM,5),VY1(MDM,MDM,5),VZ1(MDM,MDM,5),
!      &           EMPTY(MDM,MDM)
!       COMPLEX*16 VXLS(MDM,MDM),VYLS(MDM,MDM),VZLS(MDM,MDM),
!      &           VXSL(MDM,MDM),VYSL(MDM,MDM),VZSL(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     COMPLEX UNIT
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     OPERATOR 4x4 STRUCTURE COUPLES L WITH S
!       IF(HMLT.EQ.'NORL') THEN
!         RETURN
!       ENDIF
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
! c     CALL VNCOLAP(VXLS,IZ,2,1,1,2)
! c     CALL VNCOLAP(VYLS,IZ,2,2,1,2)
!       CALL VNCOLAP(VZLS,IZ,2,3,1,2)
! c     CALL VNCOLAP(VXSL,IZ,3,1,1,2)
! c     CALL VNCOLAP(VYSL,IZ,3,2,1,2)
! c      CALL VNCOLAP(VZSL,IZ,3,3,1,2)
! C
! C     MULTIPLY BY SOME APPROPRIATE FACTORS
! C      DO I=1,NDIM-NSKP
! C        DO J=1,NDIM-NSKP
! C          VZLS(I,J) = CONE*VZLS(I,J)
! C          VZSL(I,J) =-CONE*VZSL(I,J)
! C        ENDDO
! C      ENDDO
! c
! C     MULTIPLY BY SOME APPROPRIATE FACTORS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VZLS(I,J) = CONE*VZLS(I,J)
!           VZSL(I,J) =-CONE*VZSL(I,J)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Direct overlap analysis:'
!       WRITE(7, *) 'Direct overlap analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(EX1,EMPTY,VXLS,VXSL,EMPTY)
!       CALL PROPRTY(EY1,EMPTY,VYLS,VYSL,EMPTY)
!       CALL PROPRTY(EZ1,EMPTY,VZLS,VZSL,EMPTY)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(1X,'Component ',A,' charge density overlap with centre',
!      &                                              I2,3X,' = ',F15.10)
! 21    FORMAT(' Total electron density overlap with centre',
!      &                                             I2,10X,' = ',F15.10)
!       WRITE(6,20) '{LS}',IZ,DREAL(EZ1(2))
!       WRITE(7,20) '{LS}',IZ,DREAL(EZ1(2))
!       WRITE(6,20) '{SL}',IZ,DREAL(EZ1(3))
!       WRITE(7,20) '{SL}',IZ,DREAL(EZ1(3))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,21) IZ,DREAL(EZ1(5))
!       WRITE(7,21) IZ,DREAL(EZ1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(VX1,EMPTY,VZLS,VZSL,EMPTY,NORD)
!       CALL RSPT1(VY1,EMPTY,VZLS,VZSL,EMPTY,NORD)
!       CALL RSPT1(VZ1,EMPTY,VZLS,VZSL,EMPTY,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_WKNEUTJ_VZ1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (VZ1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     APPARENTLY WE'RE UP FOR A HACK FIX HERE.
!       EMJ = 0.0D0
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_WKNEUTJ_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON VZ1
!           CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C         ADD ONLY THE SECOND PARTIAL ENERGY
!           IF(MOD(IOCC,2).EQ.0) THEN
!             EMJ = EMJ + ETOT(NAD)
!           ENDIF
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     FINAL ENERGY        
!       WRITE(6, *) 'Signs are being weird but total is ',2.0D0*EMJ
!       WRITE(7, *) 'Signs are being weird but total is ',2.0D0*EMJ
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
      SUBROUTINE NUCGRAD(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   GGGGGG  RRRRRRR     AA    DDDDDDD     C
C    NNN   NN UU    UU CC    CC GG    GG RR    RR   AAAA   DD    DD    C
C    NNNN  NN UU    UU CC       GG       RR    RR  AA  AA  DD    DD    C
C    NN NN NN UU    UU CC       GG       RR    RR AA    AA DD    DD    C
C    NN  NNNN UU    UU CC       GG   GGG RRRRRRR  AAAAAAAA DD    DD    C
C    NN   NNN UU    UU CC    CC GG    GG RR    RR AA    AA DD    DD    C
C    NN    NN  UUUUUU   CCCCCC   GGGGGG  RR    RR AA    AA DDDDDDD     C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCGRAD CALCULATES THE INTEGRAL OF A SUPPLIED NUCLEAR DENSITY MODEL C
C  AND THE GRADIENT OF THE OCCUPIED ELECTRON DENSITY.                  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 V1(MDM,MDM,5)
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
c     CALL VNCGRAD(DXLL,IZ,1,0,1,1,2)
c     CALL VNCGRAD(DYLL,IZ,1,0,2,1,2)
      CALL VNCGRAD(DZLL,IZ,1,0,3,1,2)
      IF(HMLT.NE.'NORL') THEN
c       CALL VNCGRAD(DXSS,IZ,4,0,1,1,2)
c       CALL VNCGRAD(DYSS,IZ,4,0,2,1,2)
        CALL VNCGRAD(DZSS,IZ,4,0,3,1,2)
      ENDIF
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
      WRITE(6, *) 'Nuclear/electron gradient interaction analysis:'
      WRITE(7, *) 'Nuclear/electron gradient interaction analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
c      CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
c      CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
      CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,'d_',A,5X,' = (',F16.8,',',F16.8,',',F16.8,') au')
      IF(HMLT.EQ.'NORL') GOTO 23
      WRITE(6, *) DREAL(EZ1(1)),DREAL(EZ1(4)),DREAL(EZ1(5))
      WRITE(6,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
      WRITE(7,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
      WRITE(6,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
      WRITE(7,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
23    CONTINUE
      WRITE(6,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,DZLL,EMPTY,EMPTY,DZSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_VZ1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
cC
cC         DIAGRAMATIC PERTURBATION THEORY ON V1
c          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
cC
cC         WRITE RESULTS TO FILE
c          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
c          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
c          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(6, *) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
C          WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
C     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
C     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
          WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
          WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE NUCGRADquad(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   GGGGGG  RRRRRRR     AA    DDDDDDD     C
C    NNN   NN UU    UU CC    CC GG    GG RR    RR   AAAA   DD    DD    C
C    NNNN  NN UU    UU CC       GG       RR    RR  AA  AA  DD    DD    C
C    NN NN NN UU    UU CC       GG       RR    RR AA    AA DD    DD    C
C    NN  NNNN UU    UU CC       GG   GGG RRRRRRR  AAAAAAAA DD    DD    C
C    NN   NNN UU    UU CC    CC GG    GG RR    RR AA    AA DD    DD    C
C    NN    NN  UUUUUU   CCCCCC   GGGGGG  RR    RR AA    AA DDDDDDD     C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCGRAD CALCULATES THE INTEGRAL OF A SUPPLIED NUCLEAR DENSITY MODEL C
C  AND THE GRADIENT OF THE OCCUPIED ELECTRON DENSITY.                  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 TITLE
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 V1(MDM,MDM,5)
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
      COMPLEX*16 DTT(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
      CALL VNCGRADquadTEMP(DZLL,IZ,1)
      CALL VNCGRADquadTEMP(DZSS,IZ,4)
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
C      CALL VNCGRADquad(DZLL,IZ,1)
C      IF(HMLT.NE.'NORL') THEN
C         CALL VNCGRADquad(DZSS,IZ,4)
C      ENDIF
C
C     HEAT MAP FOR THE MATRIX
      TITLE = 'NUCGRAD'
      DO I=1,NDIM/2
        DO J=1,NDIM/2
          DTT(I     ,J     ) = DZLL(I,J)
          DTT(I+NSKP,J     ) = DCMPLX(0.0D0,0.0D0)
          DTT(I     ,J+NSKP) = DCMPLX(0.0D0,0.0D0)
          DTT(I+NSKP,J+NSKP) = DZSS(I,J)
        ENDDO
      ENDDO
C     CALL ZGNUMAP(DTT,TITLE,NDIM)
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
      WRITE(6, *) 'Nuclear/electron gradient interaction analysis:'
      WRITE(7, *) 'Nuclear/electron gradient interaction analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
c      CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
c      CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
      CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,'d_',A,5X,' = (',F16.8,',',F16.8,',',F16.8,') au')
      IF(HMLT.EQ.'NORL') GOTO 23
      WRITE(6, *) DREAL(EZ1(1)),DREAL(EZ1(4)),DREAL(EZ1(5))
      WRITE(6,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
      WRITE(7,20) '{LL} ',DREAL(EX1(1)),DREAL(EY1(1)),DREAL(EZ1(1))
      WRITE(6,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
      WRITE(7,20) '{SS} ',DREAL(EX1(4)),DREAL(EY1(4)),DREAL(EZ1(4))
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
23    CONTINUE
      WRITE(6,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) '{tot}',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES (TAKE Z-AXIS PROJECTION)              C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,DZLL,EMPTY,EMPTY,DZSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_VZ1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCGRAD_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
cC
cC         DIAGRAMATIC PERTURBATION THEORY ON V1
c          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
cC
cC         WRITE RESULTS TO FILE
c          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
c          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
c          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(6, *) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
C          WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
C     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
C     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
          WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
          WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
     &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
! C
! C
!       SUBROUTINE NUCFRCE(IZ,IX)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    NN    NN UU    UU  CCCCCC  FFFFFFFF RRRRRRR   CCCCCC  EEEEEEEE    C
! C    NNN   NN UU    UU CC    CC FF       RR    RR CC    CC EE          C
! C    NNNN  NN UU    UU CC       FF       RR    RR CC       EE          C
! C    NN NN NN UU    UU CC       FFFFFF   RR    RR CC       EEEEEE      C
! C    NN  NNNN UU    UU CC       FF       RRRRRRR  CC       EE          C
! C    NN   NNN UU    UU CC    CC FF       RR    RR CC    CC EE          C
! C    NN    NN  UUUUUU   CCCCCC  FF       RR    RR  CCCCCC  EEEEEEEE    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  NUCFRCE CALCULATES THE TOTAL FORCE ON A PARTICULAR NUCLEUS, DUE TO  C
! C  AN ELECTRONIC CHARGE-DENSITY (BY ORBITAL CONTRIBUTION) AND THE      C
! C  REMAINING NUCLEI. (THE LATTER ARE TREATED AS POINT-CHARGE SOURCES.) C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
! C  ▶ IX - FORCE-VECTOR DIRECTION OF INTEREST.                          C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION FRCENN(NCNT)
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 E1(5)
!       COMPLEX*16 VLL(MDM,MDM),VSS(MDM,MDM),EMPTY(MDM,MDM)
!       COMPLEX*16 V1(MDM,MDM,5)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     COMPLEX UNIT
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VNCFRCE(VLL,IZ,1,0,IX,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VNCFRCE(VSS,IZ,4,0,IX,1,2)
!       ENDIF
! C
! C**********************************************************************C
! C     CONTRIBUTIONS FROM OTHER NUCLEAR CENTRES (POINT-CHARGE APPROX.)  C
! C**********************************************************************C
! C
! C     FORCE FOR EACH NUCLEUS JZ ON IZ
!       DO JZ=1,NCNT
! C
! C       SQUARE DISTANCE BETWEEN NUCLEI (ATOMIC UNITS)
!         DST2 = 0.0D0
!         DO JX=1,3
!           DST2 = DST2 + (BXYZ(JX,IZ)-BXYZ(JX,JZ))**2
!         ENDDO
! C
! C       POINT-CHARGE FORCE (IGNORE SELF-TERM)
!         IF(IZ.NE.JZ) THEN
!           FRCENN(JZ) =-ZNUC(IZ)*ZNUC(JZ)/DST2
!         ELSE
!           FRCENN(JZ) = 0.0D0
!         ENDIF
! C
!       ENDDO
! C
! C     TOTAL FORCE FROM ALL OTHER NUCLEI ON IZ
!       FRCENNTOT = 0.0D0
!       DO JZ=1,NCNT
!         FRCENNTOT = FRCENNTOT + FRCENN(JZ)
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Electronic SCF and nuclear summary:'
!       WRITE(7, *) 'Electronic SCF and nuclear summary:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,VLL,EMPTY,EMPTY,VSS)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(' Component ',A,' F_{',I1,'} SCF field to centre ',
!      &                                              I2,11X,' = ',F15.10)
! 21    FORMAT(' Force from centre ',I2,' on centre ',I2,21X,' = ',F15.10)
! 22    FORMAT(' Electrostatic force from SCF field to centre ',
!      &                                               I2,7X,' = ',F15.10)
!       WRITE(6,20) '{LL}',IX,IZ,DREAL(E1(1))
!       WRITE(7,20) '{LL}',IX,IZ,DREAL(E1(1))
!       WRITE(6,20) '{SS}',IX,IZ,DREAL(E1(4))
!       WRITE(7,20) '{SS}',IX,IZ,DREAL(E1(4))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       DO JZ=1,NCNT
!         IF(JZ.NE.IZ) THEN
!           WRITE(6,21) JZ,IZ,FRCENN(JZ)
!           WRITE(7,21) JZ,IZ,FRCENN(JZ)
!         ENDIF
!       ENDDO
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) IZ,DREAL(E1(5))+FRCENNTOT
!       WRITE(7,22) IZ,DREAL(E1(5))+FRCENNTOT
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
      
! c      RETURN
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCFRCE_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     APPARENTLY WE'RE UP FOR A HACK FIX HERE.
!       EMJ = 0.0D0
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCFRCE_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
!           CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE UEHFRCE(IZ,IX)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    UU    UU EEEEEEEE HH    HH FFFFFFFF RRRRRRR   CCCCCC  EEEEEEEE    C
! C    UU    UU EE       HH    HH FF       RR    RR CC    CC EE          C
! C    UU    UU EE       HH    HH FF       RR    RR CC       EE          C
! C    UU    UU EEEEEE   HHHHHHHH FFFFFF   RR    RR CC       EEEEEE      C
! C    UU    UU EE       HH    HH FF       RRRRRRR  CC       EE          C
! C    UU    UU EE       HH    HH FF       RR    RR CC    CC EE          C
! C     UUUUUU  EEEEEEEE HH    HH FF       RR    RR  CCCCCC  EEEEEEEE    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  UEHFRCE CALCULATES THE NET FORCE ON A PARTICULAR NUCLEUS DUE TO THE C
! C  INTERACTION BETWEEN THE NUCLEAR UEHLING ELECTRIC FIELD AND THE      C
! C  MOLECULAR ELECTRON CHARGE DENSITY.                                  C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
! C  ▶ IX - FORCE-VECTOR DIRECTION OF INTEREST.                          C
! C -------------------------------------------------------------------- C
! C  CAN HAVE WKR AND KSB INTERACTIONS AS WELL -- NOT MUCH POINT THOUGH. C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 E1(5)
!       COMPLEX*16 VLL(MDM,MDM),VSS(MDM,MDM),EMPTY(MDM,MDM)
!       COMPLEX*16 V1(MDM,MDM,5)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     COMPLEX UNIT
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VUEHFRCE(VLL,IZ,1,0,IX,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VUEHFRCE(VSS,IZ,4,0,IX,1,2)
!       ENDIF
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Electronic SCF and nuclear summary:'
!       WRITE(7, *) 'Electronic SCF and nuclear summary:'
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,VLL,EMPTY,EMPTY,VSS)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 22    FORMAT(' Electrostatic force from SCF field to centre ',
!      &                                               I2,7X,' = ',F15.10)
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) IZ,DREAL(E1(5))
!       WRITE(7,22) IZ,DREAL(E1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
      
! c      RETURN
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_UEHFRCE_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     APPARENTLY WE'RE UP FOR A HACK FIX HERE.
!       EMJ = 0.0D0
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_UEHFRCE_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
!           CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE ELECFLD(XYZEVAL,IX)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    EEEEEEEE LL       EEEEEEEE  CCCCCC  FFFFFFFF LL       DDDDDDD     C
! C    EE       LL       EE       CC    CC FF       LL       DD    DD    C
! C    EE       LL       EE       CC       FF       LL       DD    DD    C
! C    EEEEEE   LL       EEEEEE   CC       FFFFFF   LL       DD    DD    C
! C    EE       LL       EE       CC       FF       LL       DD    DD    C
! C    EE       LL       EE       CC    CC FF       LL       DD    DD    C
! C    EEEEEEEE LLLLLLLL EEEEEEEE  CCCCCC  FF       LLLLLLLL DDDDDDD     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  ELECFLD EVALUATES THE IX COMPONENT OF THE NET ELECTRIC FIELD FROM   C
! C  THE ELECTRONIC CHARGE DENSITY AT A POINT XYZEVAL.                   C
! C -------------------------------------------------------------------- C
! C  NOTE: REMEMBER THERE WILL BE AN ELECTRIC FIELD FROM THE NUCLEI TOO. C
! C        CALCULATE WITH POINT-CHARGE MODEL OR IGNORE IF ON A CENTRE.   C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ XYZEVAL - FIELD-POINT LOCATION (GLOBAL CARTESIAN COORDINATES).    C
! C  ▶ IX      - E-FIELD DIRECTION OF INTEREST.                          C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION XYZEVAL(3)
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 E1(5)
!       COMPLEX*16 VLL(MDM,MDM),VSS(MDM,MDM),EMPTY(MDM,MDM)
!       COMPLEX*16 V1(MDM,MDM,5)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     COMPLEX UNIT
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
!       CALL VMNPOLE(VLL,XYZEVAL,1,0,IX,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VMNPOLE(VSS,XYZEVAL,4,0,IX,1,2)
!       ENDIF
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Electronic SCF and nuclear summary:'
!       WRITE(7, *) 'Electronic SCF and nuclear summary:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,VLL,EMPTY,EMPTY,VSS)
! C
! C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
! 20    FORMAT(' Component ',A,' E_{',I1,'} SCF field to centre ',
!      &                                              I2,11X,' = ',F15.10)
! 22    FORMAT(' Electric field from SCF field to centre ',
!      &                                              I2,12X,' = ',F15.10)
!       WRITE(6,20) '{LL}',IX,IZ,DREAL(E1(1))
!       WRITE(7,20) '{LL}',IX,IZ,DREAL(E1(1))
!       WRITE(6,20) '{SS}',IX,IZ,DREAL(E1(4))
!       WRITE(7,20) '{SS}',IX,IZ,DREAL(E1(4))
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) IZ,DREAL(E1(5))
!       WRITE(7,22) IZ,DREAL(E1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
! 31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
!       WRITE(6, *) 'Expectation value for each orbital IOCC:'
!       WRITE(7, *) 'Expectation value for each orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
!      &                                       'E^{',NORD,'}[tot]'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCFRCE_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
!       IF(NORD.EQ.0) THEN
!         NAD = 0
!       ELSEIF(NORD.EQ.1) THEN
!         NAD = 1
!       ELSEIF(NORD.EQ.2) THEN
!         NAD = 2
!       ELSEIF(NORD.EQ.3) THEN
!         NAD = 5
!       ELSEIF(NORD.EQ.4) THEN
!         NAD = 10
!       ELSEIF(NORD.EQ.5) THEN
!         NAD = 20
!       ENDIF
! C
! C     APPARENTLY WE'RE UP FOR A HACK FIX HERE.
!       EMJ = 0.0D0
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELECFLD_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
!           CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
!           WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE PVACPOL(IZ,IWRT,VPI)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    PPPPPPP  VV    VV    AA     CCCCCC  PPPPPPP   OOOOOO  LL          C
! C    PP    PP VV    VV   AAAA   CC    CC PP    PP OO    OO LL          C
! C    PP    PP VV    VV  AA  AA  CC       PP    PP OO    OO LL          C
! C    PP    PP VV    VV AA    AA CC       PP    PP OO    OO LL          C
! C    PPPPPPP   VV  VV  AAAAAAAA CC       PPPPPPP  OO    OO LL          C
! C    PP         VVVV   AA    AA CC    CC PP       OO    OO LL          C
! C    PP          VV    AA    AA  CCCCCC  PP        OOOOOO  LLLLLLLL    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  PVACPOL CALCULATES THE (MOLECULAR) VACPOL INTERACTION ENERGY FROM   C
! C  A CONVERGED SCF PROBLEM, REDUCING THE RESULTS TO COMPONENT-TYPE     C
! C  OVERLAPS FOR EACH OCCUPIED SPINOR. DOES IT ONE NUCLEUS AT A TIME!   C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ   - NUCLEAR CENTRE OF INTEREST.                                C
! C  ▶ IWRT - TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON).  C
! C  ▶ VPI  - VACPOL INTERACTION (UEH, WKR, KSB).                        C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*3  VPI
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 E1(5)
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 VLL(MDM,MDM),VSS(MDM,MDM),EMPTY(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE VACPOL INTERACTION MATRIX ELEMENTS
!       WRITE(6, *) 'Calling VPOLNUC(LL) for interaction VPI = ',VPI
!       WRITE(7, *) 'Calling VPOLNUC(LL) for interaction VPI = ',VPI
!       CALL VPOLNUC(VLL,IZ,1,0,1,2,VPI)
!       IF(HMLT.NE.'NORL') THEN
!         WRITE(6, *) 'Calling VPOLNUC(SS) for interaction VPI = ',VPI
!         WRITE(7, *) 'Calling VPOLNUC(SS) for interaction VPI = ',VPI
!         CALL VPOLNUC(VSS,IZ,4,0,1,2,VPI)
!       ENDIF
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! 20    FORMAT(1X,A,I2,A)
!       WRITE(6,20) 'Vacpol interaction analysis for centre IZ = ',IZ,':'
!       WRITE(7,20) 'Vacpol interaction analysis for centre IZ = ',IZ,':'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,VLL,EMPTY,EMPTY,VSS)
! C
!       IF(IWRT.EQ.0) GOTO 110
! C
! C     WRITE TOTAL ENERGY
! 21    FORMAT(1X,A,' |',16X,A,16X,A,1X,'|',14X,A)
!       WRITE(6,21) 'Net','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(7,21) 'Net','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)

! 22    FORMAT(5X,'| ',F21.14,1X,F21.14,1X,'|',F21.14)
!       WRITE(6,22) DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!       WRITE(7,22) DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 110   CONTINUE
! C
! C**********************************************************************C
! C     FIRST ORDER ORBITAL EXPECTATION VALUES                           C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 4
! C
! 30    FORMAT(1X,A,'|',16X,A,16X,A,1X,'|',14X,A)
! 31    FORMAT(1X,I3,' | ',F21.14,1X,F21.14,1X,'|',F21.14)
! 32    FORMAT(1X,A,' |',1X,F21.14,1X,F21.14,1X,'|',F21.14)
!       WRITE(6, *) 'Vacpol first-order energy for IZ = ',IZ
!       WRITE(7, *) 'Vacpol first-order energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(7,30) 'Orb.','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PVACPOL_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PVACPOL_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
!           CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,1,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C       PRINT THE TOTALS
!         WRITE(6, *) REPEAT('-',72)
!         WRITE(7, *) REPEAT('-',72)
!         WRITE(8, *) REPEAT('-',72)
!         WRITE(6,32) 'Net',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!         WRITE(7,32) 'Net',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!         WRITE(8,32) 'Net',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     SECOND ORDER ORBITAL EXPECTATION VALUES                          C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Vacpol second-order energy for IZ = ',IZ
!       WRITE(7, *) 'Vacpol second-order energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',' E2(+)',' E2(-)','E2(TOT)'
!       WRITE(7,30) 'Orb.',' E2(+)',' E2(-)','E2(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       EP = 0.0D0
!       EN = 0.0D0
!       ET = 0.0D0
!       DO IOCC=1,NOCC
! C
! C       DIAGRAMATIC PERTURBATION THEORY ON V1
!         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,2,NSKP+IOCC,0)
! C
! C       WRITE RESULTS TO FILE
!         WRITE(6,31) IOCC,EPOS(2),ENEG(2),ETOT(2)
!         WRITE(7,31) IOCC,EPOS(2),ENEG(2),ETOT(2)
!         EP = EP + EPOS(2)
!         EN = EN + ENEG(2)
!         ET = ET + ETOT(2)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     PRINT THE TOTALS
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) 'Net',EP,EN,ET
!       WRITE(7,32) 'Net',EP,EN,ET
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     THIRD ORDER ORBITAL EXPECTATION VALUES                           C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Vacpol third-order energy for IZ = ',IZ
!       WRITE(7, *) 'Vacpol third-order energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',' E3(+)',' E3(-)','E2(TOT)'
!       WRITE(7,30) 'Orb.',' E3(+)',' E3(-)','E2(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       EP = 0.0D0
!       EN = 0.0D0
!       ET = 0.0D0
!       DO IOCC=1,NOCC
! C
! C       DIAGRAMATIC PERTURBATION THEORY ON V1
!         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,3,NSKP+IOCC,0)
! C
! C       WRITE RESULTS TO FILE
!         WRITE(6,31) IOCC,EPOS(5),ENEG(5),ETOT(5)
!         WRITE(7,31) IOCC,EPOS(5),ENEG(5),ETOT(5)
!         EP = EP + EPOS(5)
!         EN = EN + ENEG(5)
!         ET = ET + ETOT(5)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     PRINT THE TOTALS
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) 'Net',EP,EN,ET
!       WRITE(7,32) 'Net',EP,EN,ET
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     FOURTH ORDER ORBITAL EXPECTATION VALUES                          C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Vacpol fourth-order energy for IZ = ',IZ
!       WRITE(7, *) 'Vacpol fourth-order energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',' E4(+)',' E4(-)','E4(TOT)'
!       WRITE(7,30) 'Orb.',' E4(+)',' E4(-)','E4(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       EP = 0.0D0
!       EN = 0.0D0
!       ET = 0.0D0
!       DO IOCC=1,NOCC
! C
! C       DIAGRAMATIC PERTURBATION THEORY ON V1
!         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,4,NSKP+IOCC,0)
! C
! C       WRITE RESULTS TO FILE
!         WRITE(6,31) IOCC,EPOS(10),ENEG(10),ETOT(10)
!         WRITE(7,31) IOCC,EPOS(10),ENEG(10),ETOT(10)
!         EP = EP + EPOS(10)
!         EN = EN + ENEG(10)
!         ET = ET + ETOT(10)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     PRINT THE TOTALS
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) 'Net',EP,EN,ET
!       WRITE(7,32) 'Net',EP,EN,ET
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! 999   CONTINUE
! C
! C**********************************************************************C
! C     TOTAL ORBITAL EXPECTATION VALUES                                 C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Vacpol total energy for IZ = ',IZ
!       WRITE(7, *) 'Vacpol total energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',' EN(+)',' EN(-)','EN(TOT)'
!       WRITE(7,30) 'Orb.',' EN(+)',' EN(-)','EN(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       EP = 0.0D0
!       EN = 0.0D0
!       ET = 0.0D0
!       DO IOCC=1,NOCC
! C
! C       DIAGRAMATIC PERTURBATION THEORY ON V1
! C       CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,4,NSKP+IOCC,0)
!         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,3,NSKP+IOCC,0)
! C
! C       WRITE RESULTS TO FILE
!         WRITE(6,31) IOCC,EPOS(21)-EPOS(0),ENEG(21)-ENEG(0),
!      &                                    ETOT(21)-ETOT(0)
!         WRITE(7,31) IOCC,EPOS(21)-EPOS(0),ENEG(21)-ENEG(0),
!      &                                    ETOT(21)-ETOT(0)
!         EP = EP + EPOS(21)-EPOS(0)
!         EN = EN + ENEG(21)-ENEG(0)
!         ET = ET + ETOT(21)-ETOT(0)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     PRINT THE TOTALS
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) 'Net',EP,EN,ET
!       WRITE(7,32) 'Net',EP,EN,ET
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       IF(IWRT.EQ.0) RETURN
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! C     MAXIMUM PERTURBATIVE ORDER
!       NORD = 4
! C
! 40    FORMAT(1X,A,I3)
! 41    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
!       WRITE(6,40) 'Goldstone diagram values for occupied state =',IOCC
!       WRITE(7,40) 'Goldstone diagram values for occupied state =',IOCC
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO V1
!       CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE NUCSIZE(IZ,IWRT,ANEW)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      NN    NN UU    UU  CCCCCC   SSSSSS IIII ZZZZZZZZ EEEEEEEE       C
! C      NNN   NN UU    UU CC    CC SS    SS II       ZZ  EE             C
! C      NNNN  NN UU    UU CC       SS       II      ZZ   EE             C
! C      NN NN NN UU    UU CC        SSSSSS  II     ZZ    EEEEEE         C
! C      NN  NNNN UU    UU CC             SS II    ZZ     EE             C
! C      NN   NNN UU    UU CC    CC SS    SS II   ZZ      EE             C
! C      NN    NN  UUUUUU   CCCCCC   SSSSSS IIII ZZZZZZZZ EEEEEEEE       C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  NUCSIZE CALCULATES THE ORBITAL CORRECTIONS FOR A NEW NUCLEAR RADIUS C
! C  ON CENTRE IZ, ASSUMING IT'S A GAUSSIAN CHARGE DISTRIBUTION. THE     C
! C  NEW ATOMIC MASS ANEW DETERMINES RNEW BY THE USUAL FORMULA.          C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ   - NUCLEAR CENTRE OF INTEREST.                                C
! C  ▶ IWRT - TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON).  C
! C  ▶ ANEW - UPDATED NUCLEAR MASS NUMBER.                               C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 E1(5)
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 VLL(MDM,MDM),VSS(MDM,MDM),EMPTY(MDM,MDM)
!       COMPLEX*16 TLL(MDM,MDM),TSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     GENERATE ORIGINAL NUCLEAR ATTRACTION OVERLAP MATRICES
!       CALL VNCATRC(VLL,ZNUC(IZ),IZ,1,0,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VNCATRC(VSS,ZNUC(IZ),IZ,4,0,1,2)
!       ENDIF
! C
! C     PRINT OLD VALUES
!       WRITE(6, *) 'Original nucleus: ',NMDL(IZ),ANUC(IZ),RNUC(IZ)*CFM
!       WRITE(7, *) 'Original nucleus: ',NMDL(IZ),ANUC(IZ),RNUC(IZ)*CFM
! C
! C     CHANGE THE NUCLEAR FITTING PROFILE
!       NNUC(IZ) = 1
!       ANUC(IZ) = ANEW
! C
! C     NUCLEAR RADIUS
!       IF(ZNUC(IZ).GT.1.0D0.AND.ZNUC(IZ).LT.190.0D0) THEN
! C       EMPIRICAL FORMULA FOR NUCLEAR RMS RADIUS IF Z < 90 (IN FM)
!         RFM = 0.836D0*(ANUC(IZ)**(1.0D0/3.0D0)) + 0.57D0
! C       RFM = 1.20D0*(ANUC(IZ)**(1.0D0/3.0D0))
!       ELSE
! C       EMPIRICAL FORMULA FOR NUCLEAR RMS RADIUS IF Z > 90 (IN FM)
!         RFM = 0.770D0*(ANUC(IZ)**(1.0D0/3.0D0)) + 0.98D0
!       ENDIF
! C
! C     CONVERT RESULT TO ATOMIC UNITS
!       RNUC(IZ) = RFM/CFM
!       FNUC(IZ,1) = 1.0D0
!       XNUC(IZ,1) = 1.5D0/(RNUC(IZ)*RNUC(IZ))
! C
!       WRITE(6, *) 'Updated  nucleus: ','GAUSS',ANEW,RFM
!       WRITE(7, *) 'Updated  nucleus: ','GAUSS',ANEW,RFM
! C
! C     GENERATE NEW NUCLEAR ATTRACTION OVERLAP MATRICES
!       CALL VNCATRC(TLL,ZNUC(IZ),IZ,1,0,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VNCATRC(TSS,ZNUC(IZ),IZ,4,0,1,2)
!       ENDIF
! C
! C     SUBTRACT NEW FROM ORIGINAL
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLL(I,J) =-VLL(I,J)+TLL(I,J)
!           VSS(I,J) =-VSS(I,J)+TSS(I,J)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! 20    FORMAT(1X,A,I2,A)
!       WRITE(6,20) 'Nuclear interaction analysis for centre IZ = ',IZ,':'
!       WRITE(7,20) 'Nuclear interaction analysis for centre IZ = ',IZ,':'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,VLL,EMPTY,EMPTY,VSS)
! C
!       IF(IWRT.EQ.0) GOTO 110
! C
! C     WRITE TOTAL ENERGY
! 21    FORMAT(1X,A,' |',16X,A,16X,A,1X,'|',14X,A)
!       WRITE(6,21) 'Net','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(7,21) 'Net','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)

! 22    FORMAT(5X,'| ',F21.14,1X,F21.14,1X,'|',F21.14)
!       WRITE(6,22) DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!       WRITE(7,22) DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 110   CONTINUE
! C
! C**********************************************************************C
! C     FIRST ORDER ORBITAL EXPECTATION VALUES                           C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 4
! C
! 30    FORMAT(1X,A,'|',16X,A,16X,A,1X,'|',14X,A)
! 31    FORMAT(1X,I3,' | ',F21.14,1X,F21.14,1X,'|',F21.14)
! 32    FORMAT(1X,A,' |',1X,F21.14,1X,F21.14,1X,'|',F21.14)
!       WRITE(6, *) 'Nuclear first-order energy for IZ = ',IZ
!       WRITE(7, *) 'Nuclear first-order energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(7,30) 'Orb.','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCSIZE_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCSIZE_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
!           CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,1,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(7,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
!           WRITE(8,31) IOCC,DREAL(V1(IOCC+NSKP,IOCC+NSKP,1)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,4)),
!      &                     DREAL(V1(IOCC+NSKP,IOCC+NSKP,5))
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C       PRINT THE TOTALS
!         WRITE(6, *) REPEAT('-',72)
!         WRITE(7, *) REPEAT('-',72)
!         WRITE(8, *) REPEAT('-',72)
!         WRITE(6,32) 'Net',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!         WRITE(7,32) 'Net',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!         WRITE(8,32) 'Net',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! C**********************************************************************C
! C     SECOND ORDER ORBITAL EXPECTATION VALUES                          C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Nuclear size correction energy for IZ = ',IZ
!       WRITE(7, *) 'Nuclear size correction energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',' E2(+)',' E2(-)','E2(TOT)'
!       WRITE(7,30) 'Orb.',' E2(+)',' E2(-)','E2(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       EP = 0.0D0
!       EN = 0.0D0
!       ET = 0.0D0
!       DO IOCC=1,NOCC
! C
! C       DIAGRAMATIC PERTURBATION THEORY ON V1
!         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,2,NSKP+IOCC,0)
! C
! C       WRITE RESULTS TO FILE
!         WRITE(6,31) IOCC,EPOS(2),ENEG(2),ETOT(2)
!         WRITE(7,31) IOCC,EPOS(2),ENEG(2),ETOT(2)
!         EP = EP + EPOS(2)
!         EN = EN + ENEG(2)
!         ET = ET + ETOT(2)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     PRINT THE TOTALS
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) 'Net',EP,EN,ET
!       WRITE(7,32) 'Net',EP,EN,ET
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       IF(IWRT.EQ.0) RETURN
! C
! C**********************************************************************C
! C     THIRD ORDER ORBITAL EXPECTATION VALUES                           C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Nuclear size correction energy for IZ = ',IZ
!       WRITE(7, *) 'Nuclear size correction energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',' E3(+)',' E3(-)','E3(TOT)'
!       WRITE(7,30) 'Orb.',' E3(+)',' E3(-)','E3(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       EP = 0.0D0
!       EN = 0.0D0
!       ET = 0.0D0
!       DO IOCC=1,NOCC
! C
! C       DIAGRAMATIC PERTURBATION THEORY ON V1
!         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,3,NSKP+IOCC,0)
! C
! C       WRITE RESULTS TO FILE
!         WRITE(6,31) IOCC,EPOS(5),ENEG(5),ETOT(5)
!         WRITE(7,31) IOCC,EPOS(5),ENEG(5),ETOT(5)
!         EP = EP + EPOS(5)
!         EN = EN + ENEG(5)
!         ET = ET + ETOT(5)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     PRINT THE TOTALS
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) 'Net',EP,EN,ET
!       WRITE(7,32) 'Net',EP,EN,ET
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       IF(IWRT.EQ.0) RETURN
! C
! C**********************************************************************C
! C     FOURTH ORDER ORBITAL EXPECTATION VALUES                          C
! C**********************************************************************C
! C
!       WRITE(6, *) 'Nuclear size correction energy for IZ = ',IZ
!       WRITE(7, *) 'Nuclear size correction energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',' E4(+)',' E4(-)','E4(TOT)'
!       WRITE(7,30) 'Orb.',' E4(+)',' E4(-)','E4(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       EP = 0.0D0
!       EN = 0.0D0
!       ET = 0.0D0
!       DO IOCC=1,NOCC
! C
! C       DIAGRAMATIC PERTURBATION THEORY ON V1
!         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,4,NSKP+IOCC,0)
! C
! C       WRITE RESULTS TO FILE
!         WRITE(6,31) IOCC,EPOS(10),ENEG(10),ETOT(10)
!         WRITE(7,31) IOCC,EPOS(10),ENEG(10),ETOT(10)
!         EP = EP + EPOS(10)
!         EN = EN + ENEG(10)
!         ET = ET + ETOT(10)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     PRINT THE TOTALS
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) 'Net',EP,EN,ET
!       WRITE(7,32) 'Net',EP,EN,ET
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       IF(IWRT.EQ.0) RETURN
! C
! C**********************************************************************C
! C     total ORBITAL EXPECTATION VALUES                          C
! C**********************************************************************C
! C
! c      goto 999
!       WRITE(6, *) 'Nuclear size correction energy for IZ = ',IZ
!       WRITE(7, *) 'Nuclear size correction energy for IZ = ',IZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.',' EN(+)',' EN(-)','EN(TOT)'
!       WRITE(7,30) 'Orb.',' EN(-)',' EN(-)','EN(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     LOOP OVER ALL OCCUPIED ORBITALS
!       EP = 0.0D0
!       EN = 0.0D0
!       ET = 0.0D0
!       DO IOCC=1,NOCC
! C
! C       DIAGRAMATIC PERTURBATION THEORY ON V1
!         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,4,NSKP+IOCC,0)
! C
! C       WRITE RESULTS TO FILE
!         WRITE(6,31) IOCC,EPOS(21)-EPOS(0),ENEG(21)-ENEG(0),
!      &                   ETOT(21)-ETOT(0)
!         WRITE(7,31) IOCC,EPOS(21)-EPOS(0),ENEG(21)-ENEG(0),
!      &                   ETOT(21)-ETOT(0)
!         EP = EP + EPOS(21)-EPOS(0)
!         EN = EN + ENEG(21)-ENEG(0)
!         ET = ET + ETOT(21)-ETOT(0)
! C
! C     END LOOP OVER OCCUPIED ORBITALS
!       ENDDO
! C
! C     PRINT THE TOTALS
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,32) 'Net',EP,EN,ET
!       WRITE(7,32) 'Net',EP,EN,ET
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       IF(IWRT.EQ.0) RETURN
! 999   continue
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! 40    FORMAT(1X,A,I3)
! 41    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
!       WRITE(6,40) 'Goldstone diagram values for occupied state =',IOCC
!       WRITE(7,40) 'Goldstone diagram values for occupied state =',IOCC
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO V1
!       CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE PANOMLS(IWRT)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   PPPPPPP     AA    NN    NN  OOOOOO  MM       MM LL       SSSSSS    C
! C   PP    PP   AAAA   NNN   NN OO    OO MMM     MMM LL      SS    SS   C
! C   PP    PP  AA  AA  NNNN  NN OO    OO MMMM   MMMM LL      SS         C
! C   PP    PP AA    AA NN NN NN OO    OO MM MM MM MM LL       SSSSSS    C
! C   PPPPPPP  AAAAAAAA NN  NNNN OO    OO MM  MMM  MM LL            SS   C
! C   PP       AA    AA NN   NNN OO    OO MM   M   MM LL      SS    SS   C
! C   PP       AA    AA NN    NN  OOOOOO  MM       MM LLLLLLLL SSSSSS    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  PANOMLS CALCULATES THE (MOLECULAR) ELECTRON ANOMALOUS MAGNETIC      C
! C  DIPOLE MOMENT INTERACTION ENERGY FROM A CONVERGED SCF PROBLEM.      C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IWRT - TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON).  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5 NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
! C
!       COMPLEX*16 E1(5),SUMLS,SUMSL
!       COMPLEX*16 CLS,CSL
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 VLS(MDM,MDM),VSL(MDM,MDM)
!       COMPLEX*16 EMPTY(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/EIGC/COEF
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLS(I,J)   = DCMPLX(0.0D0,0.0D0)
!           VSL(I,J)   = DCMPLX(0.0D0,0.0D0)
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE ENERGY COUNTER
!       DO N=1,5
!         E1(N) = DCMPLX(0.0D0,0.0D0)
!       ENDDO
! C
!       IF(IWRT.EQ.0) GOTO 110
! C
! C**********************************************************************C
! C     PLAY AREA FOR THE BETHE & SALPETER ATOMIC EXPECTATION VALUES     C
! C**********************************************************************C
! C
! C     NUCLEAR CHARGE AND PRINCIPAL QUANTUM NUMBER
!       Z = ZNUC(1)
! C
! C     AMPLITUDE FOR ELECTRON ANOMALOUS MAGNETIC MOMENT TERM (B&S 19.3)
!       AG1 =-1.0D0/(4.0D0*PI*EMSS*CV*CV)
! C
! 50    FORMAT(1X,A,F5.1)
! 51    FORMAT(2X,A,3X,A,3X,A,2X,A,9X,A,10X,A,11X,A)
! 52    FORMAT(1X,I2,2X,I2,2X,I2,2X,'|',3X,F16.10,4X,F16.10,4X,F16.10)
!       WRITE(6,50) 'Hydrogenic approx. values for Z = ',Z
!       WRITE(7,50) 'Hydrogenic approx. values for Z = ',Z
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
!       WRITE(6,51) 'n','l','k','|','Pauli (au)','Dirac (au)','Diff (au)'
!       WRITE(7,51) 'n','l','k','|','Pauli (au)','Dirac (au)','Diff (au)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
!       DO N=1,5
!         IF(N.NE.1) WRITE(6, *) REPEAT('-',72)
!         DO M=1,2*N-1
!           L = M/2
!           IF(MOD(M,2).EQ.1) THEN
!             K =-(L+1)
!           ELSE
!             K = L
!           ENDIF
! C
! C         PAULI THEORY RESULT (B&S 18.2, 19.3, 13.13)
!           ANK   = Z*Z*Z*Z/(N*N*N*IABS(K)*(2.0D0*K+1.0D0))
!           EANMP = AG1*2.0D0*EMSS*EMSS*EMSS*ANK/CV
! C
! C         DIRAC THEORY RESULT (FULL EXPRESSION -- POINTNUC)
!           NR  = N-IABS(K)
!           GAM = DSQRT(DFLOAT(K*K)-(Z/CV)**2)
!           RNM = DSQRT(NR*NR+2.0D0*GAM*NR+K*K)
!           RMX = Z/(CV*(GAM+NR))
!           EPS = EMSS/DSQRT(1.0D0+RMX*RMX)
!           EA  =-EMSS*EMSS*Z*Z*Z/(RNM*RNM*RNM)
!           EB  = (2.0D0*GAM+2.0D0*NR+1.0D0)/(GAM*(4.0D0*GAM*GAM-1.0D0))
!           EC  = (RNM-K)*DSQRT(EMSS*EMSS-EPS*EPS)
!           ED  = (2.0D0*GAM+NR)*NR*(2.0D0*GAM+2.0D0*NR-1.0D0)
!           EE  = (RNM-K)*(RNM-K)*(2.0D0*GAM+2.0D0*NR+1.0D0)
!           EANMF = AG1*EA*EB*EC*(1.0D0-ED/EE)
! C
!           WRITE(6,52) N,L,K,EANMP,EANMF,EANMP-EANMF
!           WRITE(7,52) N,L,K,EANMP,EANMF,EANMP-EANMF
! C
!         ENDDO
!       ENDDO
! C
! 110   CONTINUE
! C
! C     GENERATE SELF-INTERACTION MATRIX ELEMENTS
!       CALL VANOMLS(VLS,2,1,2)
!       CALL VANOMLS(VSL,3,1,2)
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
!       IF(IWRT.EQ.0) GOTO 120
! C
! 20    FORMAT(1X,A,I2,A)
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
!       WRITE(6,20) 'Electron anomalous magnetic dipole moment analysis:'
!       WRITE(7,20) 'Electron anomalous magnetic dipole moment analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,EMPTY,VLS,VSL,EMPTY)
! C
! C     WRITE TOTAL ENERGY
! 21    FORMAT(1X,A,' |',16X,A,16X,A,1X,'|',14X,A)
!       WRITE(6,21) 'Net','E1(LS)','E1(SL)','E1(TOT)'
!       WRITE(7,21) 'Net','E1(LS)','E1(SL)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)

! 22    FORMAT(5X,'| ',F21.14,1X,F21.14,1X,'|',F21.14)
!       WRITE(6,22) DREAL(E1(2)),DREAL(E1(3)),DREAL(E1(5))
!       WRITE(7,22) DREAL(E1(2)),DREAL(E1(3)),DREAL(E1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 120   CONTINUE
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     INITIALISE ENERGY COUNTER
!       DO N=1,5
!         E1(N) = DCMPLX(0.0D0,0.0D0)
!       ENDDO
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,'|',2(16X,A),1X,'|',14X,A)
! 31    FORMAT(1X,I3,' | ',2(F21.14,1X),'|',F21.14)
! 32    FORMAT(1X,A,' |',1X,2(F21.14,1X),'|',F21.14)
!       WRITE(6, *) 'Electron anomalous magnetic dipole moment by IOCC:'
!       WRITE(7, *) 'Electron anomalous magnetic dipole moment by IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E1(LS)','E1(SL)','E1(TOT)'
!       WRITE(7,30) 'Orb.','E1(LS)','E1(SL)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,EMPTY,VLS,VSL,EMPTY,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PANOMLS_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PANOMLS_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         INITIALISE ENERGY COUNTERS
!           SUMLS = DCMPLX(0.0D0,0.0D0)
!           SUMSL = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FOCK MATRIX ADDRESSES
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
! C
!               K = I+NSKP
!               L = J+NSKP
! C
! C             LARGE AND SMALL CONTRIBUTIONS
!               CLS = DCONJG(COEF(I,IOCC+NSKP))*COEF(L,IOCC+NSKP)
!               CSL = DCONJG(COEF(K,IOCC+NSKP))*COEF(J,IOCC+NSKP)
! C
!               SUMLS = SUMLS + CLS*VLS(I,J)
!               SUMSL = SUMSL + CSL*VSL(I,J)
! C
!             ENDDO
!           ENDDO
! C
! C         ADD TO ENERGY TOTALS
!           E1(2) = E1(2) + SUMLS
!           E1(3) = E1(3) + SUMSL
!           E1(5) = E1(5) + SUMLS+SUMSL
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
! C         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,DREAL(SUMLS),DREAL(SUMSL),DREAL(SUMLS+SUMSL)
!           WRITE(7,31) IOCC,DREAL(SUMLS),DREAL(SUMSL),DREAL(SUMLS+SUMSL)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C       PRINT THE TOTALS
!         WRITE(6, *) REPEAT('-',72)
!         WRITE(7, *) REPEAT('-',72)
!         WRITE(8, *) REPEAT('-',72)
!         WRITE(6,32) 'Re:',DREAL(E1(2)),DREAL(E1(3)),DREAL(E1(5))
!         WRITE(6,32) 'Im:',DIMAG(E1(2)),DIMAG(E1(3)),DIMAG(E1(5))
!         WRITE(7,32) 'Re:',DREAL(E1(2)),DREAL(E1(3)),DREAL(E1(5))
!         WRITE(7,32) 'Im:',DIMAG(E1(2)),DIMAG(E1(3)),DIMAG(E1(5))
!         WRITE(8,32) 'Re:',DREAL(E1(2)),DREAL(E1(3)),DREAL(E1(5))
!         WRITE(8,32) 'Im:',DIMAG(E1(2)),DIMAG(E1(3)),DIMAG(E1(5))
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       IF(IWRT.EQ.0) RETURN
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! C     MAXIMUM PERTURBATIVE ORDER
!       NORD = 1
! C
! 40    FORMAT(1X,A,I3)
! 41    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
!       WRITE(6,40) 'Goldstone diagram values for occupied state =',IOCC
!       WRITE(7,40) 'Goldstone diagram values for occupied state =',IOCC
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO V1
!       CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE PSLFHIF(IWRT)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      PPPPPPP   SSSSSS  LL       FFFFFFFF HH    HH IIII FFFFFFFF      C
! C      PP    PP SS    SS LL       FF       HH    HH  II  FF            C
! C      PP    PP SS       LL       FF       HH    HH  II  FF            C
! C      PPPPPPP   SSSSSS  LL       FFFFFF   HHHHHHHH  II  FFFFFF        C
! C      PP             SS LL       FF       HH    HH  II  FF            C
! C      PP       SS    SS LL       FF       HH    HH  II  FF            C
! C      PP        SSSSSS  LLLLLLLL FF       HH    HH IIII FF            C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  PSLFHIF CALCULATES THE (MOLECULAR) ELECTRON SELF-INTERACTION ENERGY C
! C  FROM A CONVERGED SCF PROBLEM (FREE-WAVE DECOMPOSITION).             C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IWRT - TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON).  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5 NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
!       DIMENSION BETHE(5,0:4)
! C
!       COMPLEX*16 E1(5),SUMLL,SUMLS,SUMSL,SUMSS
!       COMPLEX*16 CLL,CSS
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 VLL(MDM,MDM),VSS(MDM,MDM)
!       COMPLEX*16 EMPTY(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/EIGC/COEF
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLL(I,J)   = DCMPLX(0.0D0,0.0D0)
!           VSS(I,J)   = DCMPLX(0.0D0,0.0D0)
!           EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE ENERGY COUNTER
!       DO N=1,5
!         E1(N) = DCMPLX(0.0D0,0.0D0)
!       ENDDO
! C
! C**********************************************************************C
! C     BETHE LOGARITHM VALUES (IN HARTREE)                              C
! C**********************************************************************C
! C
! C     INITIALISE THE TABLE OF (HYDROGEN) VALUES FROM B&S SEC. 74(γ)
!       DO N=1,5
!         DO L=0,N-1
!           BETHE(N,L) = 0.0D0
!         ENDDO
!       ENDDO
!       BETHE(1,0) = 0.5D0*19.770D0
!       BETHE(2,0) = 0.5D0*16.640D0
!       BETHE(2,1) = 0.5D0*0.9704D0
!       BETHE(3,0) = 0.5D0*15.921D0
!       BETHE(4,0) = 0.5D0*15.640D0
!       BETHE(4,1) = 0.5D0*0.9590D0
!       BETHE(4,2) = 0.5D0*0.9950D0
!       IF(INT(ZNUC(1)).EQ.2) THEN
!         BETHE(1,0) = 4.3701579D0
!         BETHE(2,0) = 4.3664091D0
!       ENDIF
! C
! C**********************************************************************C
! C     PLAY AREA FOR THE BETHE & SALPETER ATOMIC EXPECTATION VALUES     C
! C**********************************************************************C
! C
!       IF(IWRT.EQ.0) GOTO 110
! C
! C     MANUALLY-SELECTED MATCHING WAVELENGTH
!       CUTK = CV
! C
! C     AMPLITUDE FOR FREE-WAVE SELF-INTERACTION TERM (B&S 19.3)
!       AG2 = (DLOG(EMSS*CV/CUTK)-TWLG+11.0D0/24.0D0)/(3.0D0*CV*PI)
!       AG2 =-AG2/(EMSS*EMSS*CV*CV)
! C
! C     AMPLITUDE FOR LOW-ENERGY CONTRIBUTION
!       ALW =-2.0D0/(3.0D0*PI*CV)
! C
! C     NUCLEAR CHARGE AND PRINCIPAL QUANTUM NUMBER
!       Z = ZNUC(1)
! C
! 50    FORMAT(1X,A,F5.1)
! 51    FORMAT(1X,A,1X,F10.5,1X,A)
! 52    FORMAT(2X,A,3X,A,3X,A,2X,A,9X,A,10X,A,11X,A)
! 53    FORMAT(1X,I2,2X,I2,2X,I2,2X,'|',3X,F16.10,4X,F16.10,4X,F16.10)
!       WRITE(6,50) 'Hydrogenic approx. values for Z = ',Z
!       WRITE(7,50) 'Hydrogenic approx. values for Z = ',Z
!       WRITE(6,51) 'Matching wavelength lam =',CUTK,'with results in au'
!       WRITE(7,51) 'Matching wavelength lam =',CUTK,'with results in au'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
!       WRITE(6,52) 'n','l','k','|',' SE(low)','SE(high)',' SE(tot)'
!       WRITE(7,52) 'n','l','k','|',' SE(low)','SE(high)',' SE(tot)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
!       DO N=1,5
!         IF(N.NE.1) WRITE(6, *) REPEAT('-',72)
!         DO M=1,2*N-1
!           L = M/2
!           IF(MOD(M,2).EQ.1) THEN
!             K =-(L+1)
!           ELSE
!             K = L
!           ENDIF
! C
! C         HIGH-ENERGY TERM (B&S 18.2, 19.3, 21.1)
!           IF(L.EQ.0) THEN
!             EHIF =-4.0D0*(Z**4)*AG2/DFLOAT(N*N*N)
!           ELSE
!             EHIF = 0.0D0
!           ENDIF
! C
! C         LOW-ENERGY TERM (B&S 19.9, 19.15, 21.1)
!           ELOW = 0.5D0*ALW/(EMSS*EMSS*CV*CV)
!           ELOW =-ELOW*4.0D0*(Z**4)/DFLOAT(N*N*N)
!           IF(BETHE(N,L).GT.0.2D0) THEN
!             ELOW = ELOW*DLOG(CUTK*CV/BETHE(N,L))
!           ELSE
!             ELOW = 0.0D0
!           ENDIF
! C
!           WRITE(6,53) N,L,K,ELOW,EHIF,ELOW+EHIF
!           WRITE(7,53) N,L,K,ELOW,EHIF,ELOW+EHIF
! C
!         ENDDO
!       ENDDO
! C
! 110   CONTINUE
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! C     GENERATE SELF-INTERACTION MATRIX ELEMENTS
!       CALL VSLFHIF(VLL,1,1,2)
!       CALL VSLFHIF(VSS,4,1,2)
! C
!       IF(IWRT.EQ.0) GOTO 120
! C
! 20    FORMAT(1X,A,I2,A)
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
!       WRITE(6,20) 'Electron self-interaction (high-energy) analysis:'
!       WRITE(7,20) 'Electron self-interaction (high-energy) analysis:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
!       CALL PROPRTY(E1,VLL,EMPTY,EMPTY,VSS)
! C
! C     WRITE TOTAL ENERGY
! 21    FORMAT(1X,A,' |',16X,A,16X,A,1X,'|',14X,A)
!       WRITE(6,21) 'Net','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(7,21) 'Net','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)

! 22    FORMAT(5X,'| ',F21.14,1X,F21.14,1X,'|',F21.14)
!       WRITE(6,22) DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!       WRITE(7,22) DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 120   CONTINUE
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     INITIALISE ENERGY COUNTER
!       DO N=1,5
!         E1(N) = DCMPLX(0.0D0,0.0D0)
!       ENDDO
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,'|',2(16X,A),1X,'|',14X,A)
! 31    FORMAT(1X,I3,' | ',2(F21.14,1X),'|',F21.14)
! 32    FORMAT(1X,A,' |',1X,2(F21.14,1X),'|',F21.14)
!       WRITE(6, *) 'Electron self-interaction (high-energy) by IOCC:'
!       WRITE(7, *) 'Electron self-interaction (high-energy) by IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(7,30) 'Orb.','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
!       CALL RSPT1(V1,VLL,EMPTY,EMPTY,VSS,NORD)
! C
! C     PRINT MATRIX ELEMENTS TO FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PANOMLS_V1.dat',STATUS='UNKNOWN')
!         DO IOCC=1,NDIM
!           WRITE(8, *) (V1(IOCC,JOCC,5),JOCC=1,NDIM)
!         ENDDO
!       CLOSE(UNIT=8)
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PANOMLS_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         INITIALISE ENERGY COUNTERS
!           SUMLL = DCMPLX(0.0D0,0.0D0)
!           SUMSS = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FOCK MATRIX ADDRESSES
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
! C
!               K = I+NSKP
!               L = J+NSKP
! C
! C             LARGE AND SMALL CONTRIBUTIONS
!               CLL = DCONJG(COEF(I,IOCC+NSKP))*COEF(J,IOCC+NSKP)
!               CSS = DCONJG(COEF(K,IOCC+NSKP))*COEF(L,IOCC+NSKP)
! C
!               SUMLL = SUMLL + CLL*VLL(I,J)
!               SUMSS = SUMSS + CSS*VSS(I,J)
! C
!             ENDDO
!           ENDDO
! C
! C         ADD TO ENERGY TOTALS
!           E1(1) = E1(1) + SUMLL
!           E1(4) = E1(4) + SUMSS
!           E1(5) = E1(5) + SUMLL+SUMSS
! C
! C         DIAGRAMATIC PERTURBATION THEORY ON V1
! C         CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,DREAL(SUMLL),DREAL(SUMSS),DREAL(SUMLL+SUMSS)
!           WRITE(7,31) IOCC,DREAL(SUMLL),DREAL(SUMSS),DREAL(SUMLL+SUMSS)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C       PRINT THE TOTALS
!         WRITE(6, *) REPEAT('-',72)
!         WRITE(7, *) REPEAT('-',72)
!         WRITE(8, *) REPEAT('-',72)
!         WRITE(6,32) 'Re:',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!         WRITE(6,32) 'Im:',DIMAG(E1(1)),DIMAG(E1(4)),DIMAG(E1(5))
!         WRITE(7,32) 'Re:',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!         WRITE(7,32) 'Im:',DIMAG(E1(1)),DIMAG(E1(4)),DIMAG(E1(5))
!         WRITE(8,32) 'Re:',DREAL(E1(1)),DREAL(E1(4)),DREAL(E1(5))
!         WRITE(8,32) 'Im:',DIMAG(E1(1)),DIMAG(E1(4)),DIMAG(E1(5))
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       IF(IWRT.EQ.0) RETURN
! C
! C**********************************************************************C
! C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
! C**********************************************************************C
! C
! C     SPECIFY THE ORBITAL
!       IOCC = 1
! C
! C     MAXIMUM PERTURBATIVE ORDER
!       NORD = 1
! C
! 40    FORMAT(1X,A,I3)
! 41    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
!       WRITE(6,40) 'Goldstone diagram values for occupied state =',IOCC
!       WRITE(7,40) 'Goldstone diagram values for occupied state =',IOCC
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO V1
!       CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
! C
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE PSLFLWB(IWRT)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C  PPPPPPP   SSSSSS  LL       FFFFFFFF LL       WW        WW BBBBBBB   C
! C  PP    PP SS    SS LL       FF       LL       WW        WW BB    BB  C
! C  PP    PP SS       LL       FF       LL       WW   WW   WW BB    BB  C
! C  PP    PP  SSSSSS  LL       FFFFFF   LL       WW  WWWW  WW BBBBBBB   C
! C  PPPPPPP        SS LL       FF       LL       WW WW  WW WW BB    BB  C
! C  PP       SS    SS LL       FF       LL       WWWW    WWWW BB    BB  C
! C  PP        SSSSSS  LLLLLLLL FF       LLLLLLLL WW        WW BBBBBBB   C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  PSLFLWB CALCULATES THE (MOLECULAR) ELECTRON SELF-INTERACTION ENERGY C
! C  FROM A CONVERGED SCF PROBLEM, ORDERING RESULTS BY COMPONENT-TYPE    C
! C  AND OCCUPIED SPINOR. USES THE BETHE FORMULATION IN (B&S 19.9).      C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IWRT - TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON).  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5 NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION BETHE(5,0:4)
! C
!       COMPLEX*16 E1(5),SUMLL,SUMLS,SUMSL,SUMSS
!       COMPLEX*16 CLL,CLS,CSL,CSS
!       COMPLEX*16 ETT(MDM,5)
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 VLL(MDM,MDM),VLS(MDM,MDM),VSL(MDM,MDM),VSS(MDM,MDM)
!       COMPLEX*16 OLSX(MDM,MDM),OLSY(MDM,MDM),OLSZ(MDM,MDM),
!      &           OSLX(MDM,MDM),OSLY(MDM,MDM),OSLZ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/EIGC/COEF
!       COMMON/EIGE/EIGN(MDM)
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/OTTI/OLSX,OLSY,OLSZ,OSLX,OSLY,OSLZ
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSS(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE ENERGY COUNTER
!       DO N=1,5
!         E1(N) = DCMPLX(0.0D0,0.0D0)
!       ENDDO
! C
! C**********************************************************************C
! C     BETHE LOGARITHM VALUES (IN HARTREE)                              C
! C**********************************************************************C
! C
! C     INITIALISE THE TABLE OF (HYDROGEN) VALUES FROM B&S SEC. 74(γ)
!       DO N=1,5
!         DO L=0,N-1
!           BETHE(N,L) = 0.0D0
!         ENDDO
!       ENDDO
!       BETHE(1,0) = 0.5D0*19.770D0
!       BETHE(2,0) = 0.5D0*16.640D0
!       BETHE(2,1) = 0.5D0*0.9704D0
!       BETHE(3,0) = 0.5D0*15.921D0
!       BETHE(4,0) = 0.5D0*15.640D0
!       BETHE(4,1) = 0.5D0*0.9590D0
!       BETHE(4,2) = 0.5D0*0.9950D0
!       IF(INT(ZNUC(1)).EQ.2) THEN
!         BETHE(1,0) = 4.3701579D0
!         BETHE(2,0) = 4.3664091D0
!       ENDIF
! C
! C**********************************************************************C
! C     PLAY AREA FOR THE BETHE & SALPETER ATOMIC EXPECTATION VALUES     C
! C**********************************************************************C
! C
!       IF(IWRT.EQ.0) GOTO 110
! C
! C     MANUALLY-SELECTED MATCHING WAVELENGTH
!       CUTK = CV
! C
! C     AMPLITUDE FOR FREE-WAVE SELF-INTERACTION TERM (B&S 19.3)
!       AG2 = (DLOG(EMSS*CV/CUTK)-TWLG+11.0D0/24.0D0)/(3.0D0*CV*PI)
!       AG2 =-AG2/(EMSS*EMSS*CV*CV)
! C
! C     AMPLITUDE FOR LOW-ENERGY CONTRIBUTION
!       ALW =-2.0D0/(3.0D0*PI*CV)
! C
! C     NUCLEAR CHARGE AND PRINCIPAL QUANTUM NUMBER
!       Z = ZNUC(1)
! C
! 50    FORMAT(1X,A,F5.1)
! 51    FORMAT(1X,A,1X,F10.5,1X,A)
! 52    FORMAT(2X,A,3X,A,3X,A,2X,A,9X,A,10X,A,11X,A)
! 53    FORMAT(1X,I2,2X,I2,2X,I2,2X,'|',3X,F16.10,4X,F16.10,4X,F16.10)
!       WRITE(6,50) 'Hydrogenic approx. values for Z = ',Z
!       WRITE(7,50) 'Hydrogenic approx. values for Z = ',Z
!       WRITE(6,51) 'Matching wavelength lam =',CUTK,'with results in au'
!       WRITE(7,51) 'Matching wavelength lam =',CUTK,'with results in au'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
!       WRITE(6,52) 'n','l','k','|',' SE(low)','SE(high)',' SE(tot)'
!       WRITE(7,52) 'n','l','k','|',' SE(low)','SE(high)',' SE(tot)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
!       DO N=1,5
!         IF(N.NE.1) WRITE(6, *) REPEAT('-',72)
!         DO M=1,2*N-1
!           L = M/2
!           IF(MOD(M,2).EQ.1) THEN
!             K =-(L+1)
!           ELSE
!             K = L
!           ENDIF
! C
! C         HIGH-ENERGY TERM (B&S 18.2, 19.3, 21.1)
!           IF(L.EQ.0) THEN
!             EHIF =-4.0D0*(Z**4)*AG2/DFLOAT(N*N*N)
!           ELSE
!             EHIF = 0.0D0
!           ENDIF
! C
! C         LOW-ENERGY TERM (B&S 19.9, 19.15, 21.1)
!           ELOW = 0.5D0*ALW/(EMSS*EMSS*CV*CV)
!           ELOW =-ELOW*4.0D0*(Z**4)/DFLOAT(N*N*N)
!           IF(BETHE(N,L).GT.0.2D0) THEN
!             ELOW = ELOW*DLOG(CUTK*CV/BETHE(N,L))
!           ELSE
!             ELOW = 0.0D0
!           ENDIF
! C
!           WRITE(6,53) N,L,K,ELOW,EHIF,ELOW+EHIF
!           WRITE(7,53) N,L,K,ELOW,EHIF,ELOW+EHIF
! C
!         ENDDO
!       ENDDO
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 110   CONTINUE
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! C     GENERATE ALL NECESSARY OVERLAP INTEGRALS (SAVED TO COMMON)
!       CALL VMOMNT0(OLSX,2,1,1,2)
!       CALL VMOMNT0(OLSY,2,2,1,2)
!       CALL VMOMNT0(OLSZ,2,3,1,2)
!       CALL VMOMNT0(OSLX,3,1,1,2)
!       CALL VMOMNT0(OSLY,3,2,1,2)
!       CALL VMOMNT0(OSLZ,3,3,1,2)
! C
! 20    FORMAT(1X,A,I2,A)
!       WRITE(6,20) 'Electron self-interaction analysis (Bethe formula):'
!       WRITE(7,20) 'Electron self-interaction analysis (Bethe formula):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     INITIALISE ENERGY COUNTER
!       DO N=1,5
!         E1(N) = DCMPLX(0.0D0,0.0D0)
!       ENDDO
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,'|',4(16X,A),1X,'|',14X,A)
! 31    FORMAT(1X,I3,' | ',4(F21.14,1X),'|',F21.14)
! 32    FORMAT(1X,A,' |',1X,4(F21.14,1X),'|',F21.14)
!       WRITE(6, *) 'First-order interaction energy by orbital IOCC:'
!       WRITE(7, *) 'First-order interaction energy by orbital IOCC:'
!       WRITE(6, *) REPEAT('-',116)
!       WRITE(7, *) REPEAT('-',116)
!       WRITE(6,30) 'Orb.','E1(LL)','E1(LS)','E1(SL)','E1(SS)','E1(TOT)'
!       WRITE(7,30) 'Orb.','E1(LL)','E1(LS)','E1(SL)','E1(SS)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',116)
!       WRITE(7, *) REPEAT('-',116)
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_VSELFEN_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         GENERATE SELF-INTERACTION MATRIX ELEMENTS
!           CALL VSLFLWB(VLL,VLS,VSL,VSS,IOCC)
! C
! C         INITIALISE ENERGY COUNTERS
!           SUMLL = DCMPLX(0.0D0,0.0D0)
!           SUMLS = DCMPLX(0.0D0,0.0D0)
!           SUMSL = DCMPLX(0.0D0,0.0D0)
!           SUMSS = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FOCK MATRIX ADDRESSES
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
! C
!               K = I+NSKP
!               L = J+NSKP
! C
! C             LARGE AND SMALL CONTRIBUTIONS
!               CLL = DCONJG(COEF(I,IOCC+NSKP))*COEF(J,IOCC+NSKP)
!               CLS = DCONJG(COEF(I,IOCC+NSKP))*COEF(L,IOCC+NSKP)
!               CSL = DCONJG(COEF(K,IOCC+NSKP))*COEF(J,IOCC+NSKP)
!               CSS = DCONJG(COEF(K,IOCC+NSKP))*COEF(L,IOCC+NSKP)
!               SUMLL = SUMLL + CLL*VLL(I,J)
!               SUMLS = SUMLS + CLS*VLS(I,J)
!               SUMSL = SUMSL + CSL*VSL(I,J)
!               SUMSS = SUMSS + CSS*VSS(I,J)
! C
!             ENDDO
!           ENDDO
! C
! C         PLACE IN THE APPROPRIATE ARRAY
!           ETT(IOCC,1) = SUMLL
!           ETT(IOCC,2) = SUMLS
!           ETT(IOCC,3) = SUMSL
!           ETT(IOCC,4) = SUMSS
!           ETT(IOCC,5) = SUMLL+SUMLS+SUMSL+SUMSS
! C
! C         ADD TO ENERGY TOTALS
!           E1(1) = E1(1) + ETT(IOCC,1)
!           E1(2) = E1(2) + ETT(IOCC,2)
!           E1(3) = E1(3) + ETT(IOCC,3)
!           E1(4) = E1(4) + ETT(IOCC,4)
!           E1(5) = E1(5) + ETT(IOCC,5)
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,(DREAL(ETT(IOCC,N)),N=1,5)
!           WRITE(7,31) IOCC,(DREAL(ETT(IOCC,N)),N=1,5)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C       PRINT THE TOTALS
!         WRITE(6, *) REPEAT('-',116)
!         WRITE(7, *) REPEAT('-',116)
!         WRITE(8, *) REPEAT('-',116)
!         WRITE(6,32) 'Re:',(DREAL(E1(N)),N=1,5)
!         WRITE(6,32) 'Im:',(DIMAG(E1(N)),N=1,5)
!         WRITE(7,32) 'Re:',(DREAL(E1(N)),N=1,5)
!         WRITE(7,32) 'Im:',(DIMAG(E1(N)),N=1,5)
!         WRITE(8,32) 'Re:',(DREAL(E1(N)),N=1,5)
!         WRITE(8,32) 'Im:',(DIMAG(E1(N)),N=1,5)
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',116)
!       WRITE(7, *) REPEAT('=',116)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE PSLFLWA(IWRT)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C  PPPPPPP   SSSSSS  LL       FFFFFFFF LL       WW        WW    AA     C
! C  PP    PP SS    SS LL       FF       LL       WW        WW   AAAA    C
! C  PP    PP SS       LL       FF       LL       WW   WW   WW  AA  AA   C
! C  PP    PP  SSSSSS  LL       FFFFFF   LL       WW  WWWW  WW AA    AA  C
! C  PPPPPPP        SS LL       FF       LL       WW WW  WW WW AAAAAAAA  C
! C  PP       SS    SS LL       FF       LL       WWWW    WWWW AA    AA  C
! C  PP        SSSSSS  LLLLLLLL FF       LLLLLLLL WW        WW AA    AA  C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  PSLFLWA CALCULATES THE (ATOMIC PART OF) ELECTRON SELF-INTERACTION   C
! C  FROM A CONVERGED SCF PROBLEM, REDUCING THE RESULTS TO COMPONENT-    C
! C  TYPE OVERLAPS FOR EACH OCCUPIED SPINOR. THIS IS JUST THE AVERAGED   C
! C  RESULT OF BETHE, INVOLVING THE BETHE LOGARITHM.                     C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IWRT - TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON).  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5 NMDL
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
! C
!       DIMENSION BETHE(5,0:4)
! C
!       COMPLEX*16 EN(5),SUMLL,SUMSS
!       COMPLEX*16 CLL,CLS,CSL,CSS
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 V1(MDM,MDM,5)
!       COMPLEX*16 VLL(MDM,MDM),VSS(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/EIGC/COEF
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/GAMA/GAMLOG(300),GAMHLF(300)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE DUMMY ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSS(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     INITIALISE ENERGY COUNTER
!       DO N=1,5
!         EN(N) = DCMPLX(0.0D0,0.0D0)
!       ENDDO
! C
! C**********************************************************************C
! C     BETHE LOGARITHM VALUES (IN HARTREE)                              C
! C**********************************************************************C
! C
! C     INITIALISE THE TABLE OF (HYDROGEN) VALUES FROM B&S SEC. 74(γ)
!       DO N=1,5
!         DO L=0,N-1
!           BETHE(N,L) = 0.0D0
!         ENDDO
!       ENDDO
!       BETHE(1,0) = 0.5D0*19.770D0
!       BETHE(2,0) = 0.5D0*16.640D0
!       BETHE(2,1) = 0.5D0*0.9704D0
!       BETHE(3,0) = 0.5D0*15.921D0
!       BETHE(4,0) = 0.5D0*15.640D0
!       BETHE(4,1) = 0.5D0*0.9590D0
!       BETHE(4,2) = 0.5D0*0.9950D0
!       IF(INT(ZNUC(1)).EQ.2) THEN
!         BETHE(1,0) = 4.3701579D0
!         BETHE(2,0) = 4.3664091D0
!       ENDIF
! C
! C**********************************************************************C
! C     PLAY AREA FOR THE BETHE & SALPETER ATOMIC EXPECTATION VALUES     C
! C**********************************************************************C
! C
!       IF(IWRT.EQ.0) GOTO 110
! C
! C     MANUALLY-SELECTED MATCHING WAVELENGTH
!       CUTK = CV
! C
! C     AMPLITUDE FOR FREE-WAVE SELF-INTERACTION TERM (B&S 19.3)
!       AG2 = (DLOG(EMSS*CV/CUTK)-TWLG+11.0D0/24.0D0)/(3.0D0*CV*PI)
!       AG2 =-AG2/(EMSS*EMSS*CV*CV)
! C
! C     AMPLITUDE FOR LOW-ENERGY CONTRIBUTION
!       ALW =-2.0D0/(3.0D0*PI*CV)
! C
! C     NUCLEAR CHARGE AND PRINCIPAL QUANTUM NUMBER
!       Z = ZNUC(1)
! C
! 50    FORMAT(1X,A,F5.1)
! 51    FORMAT(1X,A,1X,F10.5,1X,A)
! 52    FORMAT(2X,A,3X,A,3X,A,2X,A,9X,A,10X,A,11X,A)
! 53    FORMAT(1X,I2,2X,I2,2X,I2,2X,'|',3X,F16.10,4X,F16.10,4X,F16.10)
!       WRITE(6,50) 'Hydrogenic approx. values for Z = ',Z
!       WRITE(7,50) 'Hydrogenic approx. values for Z = ',Z
!       WRITE(6,51) 'Matching wavelength lam =',CUTK,'with results in au'
!       WRITE(7,51) 'Matching wavelength lam =',CUTK,'with results in au'
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
!       WRITE(6,52) 'n','l','k','|',' SE(low)','SE(high)',' SE(tot)'
!       WRITE(7,52) 'n','l','k','|',' SE(low)','SE(high)',' SE(tot)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
!       DO N=1,5
!         IF(N.NE.1) WRITE(6, *) REPEAT('-',72)
!         DO M=1,2*N-1
!           L = M/2
!           IF(MOD(M,2).EQ.1) THEN
!             K =-(L+1)
!           ELSE
!             K = L
!           ENDIF
! C
! C         HIGH-ENERGY TERM (B&S 18.2, 19.3, 21.1)
!           IF(L.EQ.0) THEN
!             EHIF =-4.0D0*(Z**4)*AG2/DFLOAT(N*N*N)
!           ELSE
!             EHIF = 0.0D0
!           ENDIF
! C
! C         LOW-ENERGY TERM (B&S 19.9, 19.15, 21.1)
!           ELOW = 0.5D0*ALW/(EMSS*EMSS*CV*CV)
!           ELOW =-ELOW*4.0D0*(Z**4)/DFLOAT(N*N*N)
!           IF(BETHE(N,L).GT.0.2D0) THEN
!             ELOW = ELOW*DLOG(CUTK*CV/BETHE(N,L))
!           ELSE
!             ELOW = 0.0D0
!           ENDIF
! C
!           WRITE(6,53) N,L,K,ELOW,EHIF,ELOW+EHIF
!           WRITE(7,53) N,L,K,ELOW,EHIF,ELOW+EHIF
! C
!         ENDDO
!       ENDDO
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
! 110   CONTINUE
! C
! C**********************************************************************C
! C     MOLECULAR EXPECTATION VALUE                                      C
! C**********************************************************************C
! C
! C     GENERATE AVERAGED SELF-INTERACTION MATRIX ELEMENTS
!       N = 1
!       L = 0
!       CALL VSLFLWA(VLL,BETHE(N,L),1,1,2)
!       IF(HMLT.NE.'NORL') THEN
!         CALL VSLFLWA(VSS,BETHE(N,L),4,1,2)
!       ENDIF
! C
! 20    FORMAT(1X,A,I2,A)
!       WRITE(6,20) 'Electron self-interaction analysis (average):'
!       WRITE(7,20) 'Electron self-interaction analysis (average):'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C**********************************************************************C
! C     ORBITAL EXPECTATION VALUES                                       C
! C**********************************************************************C
! C
! C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
!       NORD = 1
! C
! 30    FORMAT(1X,A,'|',2(16X,A),1X,'|',14X,A)
! 31    FORMAT(1X,I3,' | ',2(F21.14,1X),'|',F21.14)
! 32    FORMAT(1X,A,' |',1X,2(F21.14,1X),'|',F21.14)
!       WRITE(6, *) 'First-order interaction energy by orbital IOCC:'
!       WRITE(7, *) 'First-order interaction energy by orbital IOCC:'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,30) 'Orb.','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(7,30) 'Orb.','E1(LL)','E1(SS)','E1(TOT)'
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
! C
! C     OPEN EXTERNAL FILE
!       OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PSLFLWA_EN.dat',STATUS='UNKNOWN')
! C
! C       LOOP OVER ALL OCCUPIED ORBITALS
!         DO IOCC=1,NOCC
! C
! C         INITIALISE ENERGY COUNTERS
!           SUMLL = DCMPLX(0.0D0,0.0D0)
!           SUMSS = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FOCK MATRIX ADDRESSES
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
! C
!               K = I+NSKP
!               L = J+NSKP
! C
! C             LARGE AND SMALL CONTRIBUTIONS
!               CLL = DCONJG(COEF(I,IOCC+NSKP))*COEF(J,IOCC+NSKP)
!               CSS = DCONJG(COEF(K,IOCC+NSKP))*COEF(L,IOCC+NSKP)
! C
! C             ADD TO TOTAL MATRIX ELEMENT
!               SUMLL = SUMLL + CLL*VLL(I,J)
!               SUMSS = SUMSS + CSS*VSS(I,J)
! C
!             ENDDO
!           ENDDO
! C
! C         ADD TO ENERGY TOTALS
!           EN(1) = EN(1) + SUMLL
!           EN(4) = EN(4) + SUMSS
!           EN(5) = EN(5) + SUMLL+SUMSS
! C
! C         WRITE RESULTS TO FILE
!           WRITE(6,31) IOCC,DREAL(SUMLL),DREAL(SUMSS),DREAL(SUMLL+SUMSS)
!           WRITE(7,31) IOCC,DREAL(SUMLL),DREAL(SUMSS),DREAL(SUMLL+SUMSS)
! C
! C       END LOOP OVER OCCUPIED ORBITALS
!         ENDDO
! C
! C       PRINT THE TOTALS
!         WRITE(6, *) REPEAT('-',72)
!         WRITE(7, *) REPEAT('-',72)
!         WRITE(8, *) REPEAT('-',72)
!         WRITE(6,32) 'Re:',DREAL(EN(1)),DREAL(EN(4)),DREAL(EN(5))
!         WRITE(6,32) 'Im:',DIMAG(EN(1)),DIMAG(EN(4)),DIMAG(EN(5))
!         WRITE(7,32) 'Re:',DREAL(EN(1)),DREAL(EN(4)),DREAL(EN(5))
!         WRITE(7,32) 'Im:',DIMAG(EN(1)),DIMAG(EN(4)),DIMAG(EN(5))
!         WRITE(8,32) 'Re:',DREAL(EN(1)),DREAL(EN(4)),DREAL(EN(5))
!         WRITE(8,32) 'Im:',DIMAG(EN(1)),DIMAG(EN(4)),DIMAG(EN(5))
! C
! C     CLOSE EXTERNAL FILE
!       CLOSE(UNIT=8)
! C
! C     END SECTION
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE COREPOLHYP(IV,IZ,RNMU,ISPN)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     CCCCCC   OOOOOO  RRRRRRR  EEEEEEEE PPPPPPP   OOOOOO  LL          C
! C    CC    CC OO    OO RR    RR EE       PP    PP OO    OO LL          C
! C    CC       OO    OO RR    RR EE       PP    PP OO    OO LL          C
! C    CC       OO    OO RR    RR EEEEEE   PP    PP OO    OO LL          C
! C    CC       OO    OO RRRRRRR  EE       PPPPPPP  OO    OO LL          C
! C    CC    CC OO    OO RR    RR EE       PP       OO    OO LL          C
! C     CCCCCC   OOOOOO  RR    RR EEEEEEEE PP        OOOOOO  LLLLLLLL    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  COREPOL CALCULATES THE FIRST-ORDER CORRECTION TO THE EXPECTATION    C
! C  VALUE OF A ONE-BODY INTERACTION HAMILTONIAN (WHICH MUST BE APPLIED  C
! C  MANUALLY INSIDE THIS ROUTINE DUE TO FORTRAN RESTRICTIONS) WHEN THE  C
! C  EFFECTS OF CORE POLARISATION ARE CONSIDERED. ONE MAY APPLY THIS TO  C
! C  A SINGLE ORBITAL IN THE VALENCE REGION, AND CONVERGENCE PROPERTIES  C
! C  OF THE RESULT ARE ENHANCED IF THE STATE POSSESSES S-TYPE STRUCTURE. C
! C  (THIS LIES SOMEWHERE BETWEEN MBPT AND PT1BODY TREATMENTS.)          C
! C -------------------------------------------------------------------- C
! C  W(1)       = <V|H(1)|V>                                             C
! C  W(1)^CP[D] = 2 SUM_{AR} <VA|1/R_{12}|VR><R|H(1)|A>/(EA-ER)          C
! C  W(1)^CP[E] =-2 SUM_{AR} <AV|1/R_{12}|VR><R|H(1)|A>/(EA-ER)          C
! C                                                                      C
! C  WHERE V = IV, A = CORE ORBITAL, R = VIRTUAL ORBITAL,                C
! C  H(1)=ONE-BODY INTERACTION HAMILTONIAN, R_{12} = COULOMB OPERATOR    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IV - A VIRTUAL ORBITAL (MUST BE UNOCCUPIED IN THE DHF PROCEDURE). C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
!       CHARACTER*80 TITLE
! C
!       DIMENSION RNLOC(3),ABC(MDM,MDM)
! C
!       COMPLEX*16 WX,WY,WZ
!       COMPLEX*16 WDX,WKX,WDY,WKY,WDZ,WKZ
!       COMPLEX*16 CONE
!       COMPLEX*16 VSUMX,VSUMY,VSUMZ
!       COMPLEX*16 VX(MDM),VY(MDM),VZ(MDM)
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
!      &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
!      &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
!      &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
!       COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
!      &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
!       COMPLEX*16 VHX(MDM,MDM),VHY(MDM,MDM),VHZ(MDM,MDM)
!       COMPLEX*16 VVAR(MDM,MDM),AVVR(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/EIGC/COEF
!       COMMON/EIGE/EIGN(MDM)
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
!       IF(HMLT.EQ.'NORL') THEN
!         WRITE(6, *) 'In COREPOL: not possible for this Hamiltonian!'
!         WRITE(7, *) 'In COREPOL: not possible for this Hamiltonian!'
!       ENDIF
! C
! C     CHECK THAT THE SUPPLIED VIRTUAL ORBITAL IS A VALID CHOICE
!       IF(IV.LE.NOCC) THEN
!         WRITE(6, *) 'In COREPOL: supply a valid orbital reference!',IV
!         WRITE(7, *) 'In COREPOL: supply a valid orbital reference!',IV
!         RETURN
!       ENDIF
! C
! C     NUMBER OF OCCUPIED AND UNOCCUPIED ORBITALS
!       NUMO = NOCC
!       NUMV = NDIM-NOCC
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE OTHER ARRAYS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
!           DXYLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DXZLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DYXLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DYZLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DZXLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DZYLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           DXYSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DXZSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DYXSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DYZSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DZXSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           DZYSL(I,J) = DCMPLX(0.0D0,0.0D0)
! C
!           WXLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           WYLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           WZLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           WXSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           WYSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           WZSL(I,J) = DCMPLX(0.0D0,0.0D0)
! C
!         ENDDO
!       ENDDO
! C
! C     LOCATION OF NUCLEUS WITH MAGNETIC MOMENT
!       DO IX=1,3
!         RNLOC(IX) = BXYZ(IX,IZ)
!       ENDDO
! C
! C     PRE-FACTOR FOR MATRIX ELEMENTS
!       RI2 = DFLOAT(ISPN)/2.D0
!       PRE =-CHZ*1.0D-6/(PMSS*CV*RI2)
! C
! C**********************************************************************C
! C     PREPARATION OF INTEGRALS OVER H(1) -- CAN EDIT THIS BIT          C
! C**********************************************************************C
! C
! C     MATRIX ELEMENT INTEGRALS
!       CALL VMNPOLE(DXYLS,RNLOC,2,1,2,1,2)
!       CALL VMNPOLE(DXZLS,RNLOC,2,1,3,1,2)
!       CALL VMNPOLE(DYXLS,RNLOC,2,2,1,1,2)
!       CALL VMNPOLE(DYZLS,RNLOC,2,2,3,1,2)
!       CALL VMNPOLE(DZXLS,RNLOC,2,3,1,1,2)
!       CALL VMNPOLE(DZYLS,RNLOC,2,3,2,1,2)
! C
!       CALL VMNPOLE(DXYSL,RNLOC,3,1,2,1,2)
!       CALL VMNPOLE(DXZSL,RNLOC,3,1,3,1,2)
!       CALL VMNPOLE(DYXSL,RNLOC,3,2,1,1,2)
!       CALL VMNPOLE(DYZSL,RNLOC,3,2,3,1,2)
!       CALL VMNPOLE(DZXSL,RNLOC,3,3,1,1,2)
!       CALL VMNPOLE(DZYSL,RNLOC,3,3,2,1,2)
! C
! C     CONSTRUCT MAGNETIC MOMENT DIPOLE MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         COMPONENT OVERLAP LS
!           WXLS(I,J) = DYZLS(I,J)-DZYLS(I,J)
!           WYLS(I,J) = DZXLS(I,J)-DXZLS(I,J)
!           WZLS(I,J) = DXYLS(I,J)-DYXLS(I,J)
! C
! C         COMPONENT OVERLAP SL
!           WXSL(I,J) = DYZSL(I,J)-DZYSL(I,J)
!           WYSL(I,J) = DZXSL(I,J)-DXZSL(I,J)
!           WZSL(I,J) = DXYSL(I,J)-DYXSL(I,J)
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     ONE-BODY EXPECTATION VALUE FOR IV                                C
! C**********************************************************************C
! C
!       WX = DCMPLX(0.0D0,0.0D0)
! C
!       IF(MOD(IV,2).EQ.0) THEN
!         NP =-1
!       ELSE
!         NP = 1
!       ENDIF
! C
! C     LOOP OVER FOCK MATRIX ADDRESSES BY BLOCK
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
!           K = I+NSKP
!           L = J+NSKP
! C
! C         ACCOUNT FOR ALL COMPONENT OVERLAP COMBINATIONS {TT'}
!           WX = WX + DCONJG(COEF(I,IV+NSKP))*COEF(L,IV+NSKP+NP)*WXLS(I,J)
!      &            + DCONJG(COEF(K,IV+NSKP))*COEF(J,IV+NSKP+NP)*WXSL(I,J)
!           WY = WY + DCONJG(COEF(I,IV+NSKP))*COEF(L,IV+NSKP+NP)*WYLS(I,J)
!      &            + DCONJG(COEF(K,IV+NSKP))*COEF(J,IV+NSKP+NP)*WYSL(I,J)
!           WZ = WZ + DCONJG(COEF(I,IV+NSKP))*COEF(L,IV+NSKP   )*WZLS(I,J)
!      &            + DCONJG(COEF(K,IV+NSKP))*COEF(J,IV+NSKP   )*WZSL(I,J)
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MATRIX ELEMENTS OVER FIRST-ORDER TERMS -- REQUIRE (IR,IA) ONLY   C
! C**********************************************************************C
! C
! C     INITIALISE VH ARRAYS
!       DO I=1,NDIM
!         DO J=1,NDIM
!           VHX(I,J) = DCMPLX(0.0D0,0.0D0)
!           VHY(I,J) = DCMPLX(0.0D0,0.0D0)
!           VHZ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     LOOP OVER ALL ORBITAL COMBINATIONS
!       DO IOCCA=1,NUMO
!         DO IVRTR=1,NUMV
! C
! C         MATRIX ADDRESSES
!           IA = NSKP+IOCCA
!           IF(IVRTR.LE.NSKP) THEN
!             IR = IVRTR
!           ELSE
!             IR = IVRTR+NUMO
!           ENDIF
! C
!           IF(MOD(IA,2).EQ.0) THEN
!             NP =-1
!           ELSE
!             NP = 1
!           ENDIF
! C
! C         INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
!           VSUMX = DCMPLX(0.0D0,0.0D0)
!           VSUMY = DCMPLX(0.0D0,0.0D0)
!           VSUMZ = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FOCK MATRIX ADDRESSES
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
! C
! C             SMALL-COMPONENT ADDRESSES
!               K = I+NSKP
!               L = J+NSKP
! C
!               VSUMX = VSUMX + DCONJG(COEF(I,IR))*COEF(L,IA+NP)*WXLS(I,J)
!      &                      + DCONJG(COEF(K,IR))*COEF(J,IA+NP)*WXSL(I,J)
!               VSUMY = VSUMY + DCONJG(COEF(I,IR))*COEF(L,IA+NP)*WYLS(I,J)
!      &                      + DCONJG(COEF(K,IR))*COEF(J,IA+NP)*WYSL(I,J)
!               VSUMZ = VSUMZ + DCONJG(COEF(I,IR))*COEF(L,IA   )*WZLS(I,J)
!      &                      + DCONJG(COEF(K,IR))*COEF(J,IA   )*WZSL(I,J)
! C
!             ENDDO
!           ENDDO
! C
! C         SAVE COUNTERS TO MATRICES
!           VHX(IR,IA) = VSUMX
!           VHY(IR,IA) = VSUMY
!           VHZ(IR,IA) = VSUMZ
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     COULOMB MATRIX ELEMENTS  -- REQUIRE (VV|AR) AND (AV|VR) ONLY     C
! C**********************************************************************C
! C
! C     GENERATE CONTRACTED COULOMB MATRIX ELEMENTS
!       CALL COREINT(VVAR,AVVR,NUMO,NUMV,IV)
! C
! C**********************************************************************C
! C     CALCULATION OF CORE-POLARISATION CORRECTIONS, WDIR AND WXCH.     C
! C**********************************************************************C
! C
! C     INITIALISE COUNTERS
!       WDX = DCMPLX(0.0D0,0.0D0)
!       WKX = DCMPLX(0.0D0,0.0D0)
!       WDY = DCMPLX(0.0D0,0.0D0)
!       WKY = DCMPLX(0.0D0,0.0D0)
!       WDZ = DCMPLX(0.0D0,0.0D0)
!       WKZ = DCMPLX(0.0D0,0.0D0)
! C
! C     LOOP OVER ALL ORBITAL COMBINATIONS
!       DO IOCCA=1,NUMO
!         DO IVRTR=1,NUMV
! C
! C         MATRIX ADDRESSES
!           IA = NSKP+IOCCA
!           IF(IVRTR.LE.NSKP) THEN
!             IR = IVRTR
!           ELSE
!             IR = IVRTR+NUMO
!           ENDIF
! C
! C         ENERGY DIFFERENCE FOR THIS (EA,EK)
!           EAK = EIGN(IA)-EIGN(IR)
! C
! C         ADD TO THE CORE-POLARISATION COUNTERS
!           WDX = WDX + 2.0D0*VVAR(IA,IR)*VHX(IR,IA)/EAK
!           WKX = WKX - 2.0D0*AVVR(IA,IR)*VHX(IR,IA)/EAK
!           WDY = WDY + 2.0D0*VVAR(IA,IR)*VHY(IR,IA)/EAK
!           WKY = WKY - 2.0D0*AVVR(IA,IR)*VHY(IR,IA)/EAK
!           WDZ = WDZ + 2.0D0*VVAR(IA,IR)*VHZ(IR,IA)/EAK
!           WKZ = WKZ - 2.0D0*AVVR(IA,IR)*VHZ(IR,IA)/EAK
! C
!         ENDDO
!       ENDDO

!       DO I=1,NDIM
!         DO J=1,NDIM
!           ABC(I,J) = 0.0D0
!         ENDDO
!       ENDDO
      
!       X = 0.0D0
!       DO IA=1,NDIM
!         DO IR=1,NDIM
!           IF(IA.LE.NSKP.OR.IA.GT.NSKP+NUMO) GOTO 150
!           IF(IR.GT.NSKP.AND.IR.LE.NSKP+NUMO) GOTO 150
!           EAK = EIGN(IA)-EIGN(IR)
!           ABC(IA,IR) = ABS(2.0D0*VVAR(IA,IR)*VHZ(IR,IA)/EAK
!      &               -     2.0D0*AVVR(IA,IR)*VHZ(IR,IA)/EAK)
! 150       CONTINUE
!         ENDDO
!       ENDDO
!       TITLE = 'COREPOL'
!       CALL DGNUMAP(ABC,TITLE,NDIM)
! C
! C**********************************************************************C
! C     PRINT RESULTS                                                    C
! C**********************************************************************C
! C
! C     ASSUME RESULTS ARE REAL FOR NOW
!       W1AU = PRE*RNMU*DREAL(WZ)
!       WDAU = PRE*RNMU*DREAL(WDZ)
!       WKAU = PRE*RNMU*DREAL(WKZ)
!       WTAU = W1AU+WDAU+WKAU
!       W1HZ = CHZ*1.0D-6*W1AU
!       WDHZ = CHZ*1.0D-6*WDAU
!       WKHZ = CHZ*1.0D-6*WKAU
!       WTHZ = CHZ*1.0D-6*WTAU
! C
! 21    FORMAT(1X,A,I3)
! 22    FORMAT(1X,A,7X,'|',4X,ES17.10,' au',5X,'|',4X,ES17.10,' MHz')
!       WRITE(6,21) 'Core polarisation corrections to IV = ',IV
!       WRITE(7,21) 'Core polarisation corrections to IV = ',IV
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) 'W(1)      ',W1AU,W1HZ
!       WRITE(7,22) 'W(1)      ',W1AU,W1HZ
!       WRITE(6,22) 'W(1)^CP[D]',WDAU,WDHZ
!       WRITE(7,22) 'W(1)^CP[D]',WDAU,WDHZ
!       WRITE(6,22) 'W(1)^CP[X]',WKAU,WKHZ
!       WRITE(7,22) 'W(1)^CP[X]',WKAU,WKHZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) 'W(1) [TOT]',WTAU,WTHZ
!       WRITE(7,22) 'W(1) [TOT]',WTAU,WTHZ
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE COREPOL(IV)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     CCCCCC   OOOOOO  RRRRRRR  EEEEEEEE PPPPPPP   OOOOOO  LL          C
! C    CC    CC OO    OO RR    RR EE       PP    PP OO    OO LL          C
! C    CC       OO    OO RR    RR EE       PP    PP OO    OO LL          C
! C    CC       OO    OO RR    RR EEEEEE   PP    PP OO    OO LL          C
! C    CC       OO    OO RRRRRRR  EE       PPPPPPP  OO    OO LL          C
! C    CC    CC OO    OO RR    RR EE       PP       OO    OO LL          C
! C     CCCCCC   OOOOOO  RR    RR EEEEEEEE PP        OOOOOO  LLLLLLLL    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  COREPOL CALCULATES THE FIRST-ORDER CORRECTION TO THE EXPECTATION    C
! C  VALUE OF A ONE-BODY INTERACTION HAMILTONIAN (WHICH MUST BE APPLIED  C
! C  MANUALLY INSIDE THIS ROUTINE DUE TO FORTRAN RESTRICTIONS) WHEN THE  C
! C  EFFECTS OF CORE POLARISATION ARE CONSIDERED. ONE MAY APPLY THIS TO  C
! C  A SINGLE ORBITAL IN THE VALENCE REGION, AND CONVERGENCE PROPERTIES  C
! C  OF THE RESULT ARE ENHANCED IF THE STATE POSSESSES S-TYPE STRUCTURE. C
! C  (THIS LIES SOMEWHERE BETWEEN MBPT AND PT1BODY TREATMENTS.)          C
! C -------------------------------------------------------------------- C
! C  W(1)       = <V|H(1)|V>                                             C
! C  W(1)^CP[D] = 2 SUM_{AR} <VA|1/R_{12}|VR><R|H(1)|A>/(EA-ER)          C
! C  W(1)^CP[E] =-2 SUM_{AR} <AV|1/R_{12}|VR><R|H(1)|A>/(EA-ER)          C
! C                                                                      C
! C  WHERE V = IV, A = CORE ORBITAL, R = VIRTUAL ORBITAL,                C
! C  H(1)=ONE-BODY INTERACTION HAMILTONIAN, R_{12} = COULOMB OPERATOR    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IV - A VIRTUAL ORBITAL (MUST BE UNOCCUPIED IN THE DHF PROCEDURE). C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*40 MOLCL,WFNFL,OUTFL
!       CHARACTER*80 TITLE
! C
!       DIMENSION ABC(MDM,MDM),CLOC(3)
! C
!       COMPLEX*16 CONE,VSUM1
!       COMPLEX*16 WD,WX,W1
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 VLL(MDM,MDM),VLS(MDM,MDM),VSL(MDM,MDM),VSS(MDM,MDM)
!       COMPLEX*16 VH1(MDM,MDM),VVAR(MDM,MDM),AVVR(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/CONV/CHZ,CEV,CCM,CFM,CNG,CDB
!       COMMON/EIGC/COEF
!       COMMON/EIGE/EIGN(MDM)
!       COMMON/FLNM/MOLCL,WFNFL,OUTFL
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     THIS IS A MANY-BODY CORRECTION
!       IF(HMLT.EQ.'BARE') THEN
!         WRITE(6, *) 'In COREPOL: core polarisation does not exist!',HMLT
!         WRITE(7, *) 'In COREPOL: core polarisation does not exist!',HMLT
!         RETURN
!       ENDIF
! C
! C     CHECK THAT THE SUPPLIED VIRTUAL ORBITAL IS A VALID CHOICE
!       IF(IV.LE.NOCC) THEN
!         WRITE(6, *) 'In COREPOL: supply a valid orbital reference!',IV
!         WRITE(7, *) 'In COREPOL: supply a valid orbital reference!',IV
!         RETURN
!       ENDIF
! C
! C     NUMBER OF OCCUPIED AND UNOCCUPIED ORBITALS
!       NUMO = NOCC
!       NUMV = NDIM-NOCC
! C
! C**********************************************************************C
! C     PREPARATION OF INTEGRALS OVER H(1) -- CAN EDIT THIS BIT          C
! C**********************************************************************C
! C
! C     INITIALISE ALL MATRIX ELEMENT ARRAYS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSS(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
!       CLOC(1) = 0.0D0
!       CLOC(2) = 0.0D0
!       CLOC(3) = 0.0D0
! Cc
! Cc     direct overlap matrix elements
! C      call VMOMNT0(VLL,1,0,1,2)
! C      call VMOMNT0(VSS,4,0,1,2)
!       call VMOMNT1(VLL,CLOC,1,0,3,1,2)
!       call VMOMNT1(VSS,CLOC,4,0,3,1,2)
! C
! C     LAPLACIAN MATRIX ELEMENTS
! C      CALL VLPLACE(VLS,2,0,1,2)
! C      CALL VLPLACE(VSL,3,0,1,2)
! C
! C     CONSTRUCT EFFECTIVE EDM OPERATOR BY MULTIPLICATION
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLS(I,J) = 2.0D0*CV*CONE*VLS(I,J)
!           VSL(I,J) =-2.0D0*CV*CONE*VSL(I,J)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     ONE-BODY EXPECTATION VALUE FOR IV                                C
! C**********************************************************************C
! C
!       W1 = DCMPLX(0.0D0,0.0D0)
! C
! C     LOOP OVER FOCK MATRIX ADDRESSES BY BLOCK
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
!           K = I+NSKP
!           L = J+NSKP
! C
! C         ACCOUNT FOR ALL COMPONENT OVERLAP COMBINATIONS {TT'}
!           W1 = W1 + DCONJG(COEF(I,IV+NSKP))*COEF(J,IV+NSKP)*VLL(I,J)
!           IF(HMLT.NE.'NORL') THEN
!             W1 = W1 + DCONJG(COEF(I,IV+NSKP))*COEF(L,IV+NSKP)*VLS(I,J)
!      &              + DCONJG(COEF(K,IV+NSKP))*COEF(J,IV+NSKP)*VSL(I,J)
!      &              + DCONJG(COEF(K,IV+NSKP))*COEF(L,IV+NSKP)*VSS(I,J)
!           ENDIF
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     MATRIX ELEMENTS OVER FIRST-ORDER TERMS -- REQUIRE (IR,IA) ONLY   C
! C**********************************************************************C
! C
! C     INITIALISE VH1 ARRAY
!       DO I=1,NDIM
!         DO J=1,NDIM
!           VH1(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     LOOP OVER ALL ORBITAL COMBINATIONS
!       DO IOCCA=1,NUMO
!         DO IVRTR=1,NUMV
! C
! C         MATRIX ADDRESSES
!           IA = NSKP+IOCCA
!           IF(IVRTR.LE.NSKP) THEN
!             IR = IVRTR
!           ELSE
!             IR = IVRTR+NUMO
!           ENDIF
! C
! C         INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
!           VSUM1 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FOCK MATRIX ADDRESSES
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
! C
! C             SMALL-COMPONENT ADDRESSES
!               K = I+NSKP
!               L = J+NSKP
! C
!               VSUM1 = VSUM1 + DCONJG(COEF(I,IR))*COEF(J,IA)*VLL(I,J)
!               IF(HMLT.NE.'NORL') THEN
!                 VSUM1 = VSUM1 + DCONJG(COEF(I,IR))*COEF(L,IA)*VLS(I,J)
!      &                        + DCONJG(COEF(K,IR))*COEF(J,IA)*VSL(I,J)
!      &                        + DCONJG(COEF(K,IR))*COEF(L,IA)*VSS(I,J)
!               ENDIF
!             ENDDO
!           ENDDO
! C
! C         SAVE COUNTERS TO MATRICES
!           VH1(IR,IA) = VSUM1
! C
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     COULOMB MATRIX ELEMENTS  -- REQUIRE (VV|AR) AND (AV|VR) ONLY     C
! C**********************************************************************C
! C
! C     GENERATE CONTRACTED COULOMB MATRIX ELEMENTS
!       CALL COREINT(VVAR,AVVR,NUMO,NUMV,IV)
! C
! C**********************************************************************C
! C     CALCULATION OF CORE-POLARISATION CORRECTIONS, WDIR AND WXCH.     C
! C**********************************************************************C
! C
! C     INITIALISE COUNTERS
!       WD = DCMPLX(0.0D0,0.0D0)
!       WX = DCMPLX(0.0D0,0.0D0)
! C
! C     LOOP OVER ALL ORBITAL COMBINATIONS
!       DO IOCCA=1,NUMO
!         DO IVRTR=1,NUMV
! C
! C         MATRIX ADDRESSES
!           IA = NSKP+IOCCA
!           IF(IVRTR.LE.NSKP) THEN
!             IR = IVRTR
!           ELSE
!             IR = IVRTR+NUMO
!           ENDIF
! C
! C         ENERGY DIFFERENCE FOR THIS (EA,EK)
!           EAK = EIGN(IA)-EIGN(IR)
! C
! C         ADD TO THE CORE-POLARISATION COUNTERS
!           WD = WD + 2.0D0*VVAR(IA,IR)*VH1(IR,IA)/EAK
!           WX = WX - 2.0D0*AVVR(IA,IR)*VH1(IR,IA)/EAK
! C
!         ENDDO
!       ENDDO

!       DO I=1,NDIM
!         DO J=1,NDIM
!           ABC(I,J) = 0.0D0
!         ENDDO
!       ENDDO
      
!       X = 0.0D0
!       DO IA=1,NDIM
!         DO IR=1,NDIM
!           IF(IA.LE.NSKP.OR.IA.GT.NSKP+NUMO) GOTO 150
!           IF(IR.GT.NSKP.AND.IR.LE.NSKP+NUMO) GOTO 150
!           EAK = EIGN(IA)-EIGN(IR)
!           ABC(IA,IR) = ABS(2.0D0*VVAR(IA,IR)*VH1(IR,IA)/EAK
!      &               -     2.0D0*AVVR(IA,IR)*VH1(IR,IA)/EAK)
! 150       CONTINUE
!         ENDDO
!       ENDDO
!       TITLE = 'COREPOL'
!       CALL DGNUMAP(ABC,TITLE,NDIM)
! C
! C**********************************************************************C
! C     PRINT RESULTS                                                    C
! C**********************************************************************C
! C
! C     ASSUME RESULTS ARE REAL FOR NOW
!       W1AU = DREAL(W1)
!       WDAU = DREAL(WD)
!       WXAU = DREAL(WX)
!       WTAU = W1AU+WDAU+WXAU
!       W1HZ = CHZ*W1AU
!       WDHZ = CHZ*WDAU
!       WXHZ = CHZ*WXAU
!       WTHZ = CHZ*WTAU
! C
! 21    FORMAT(1X,A,I3)
! 22    FORMAT(1X,A,7X,'|',4X,ES17.10,' au',5X,'|',4X,ES17.10,' Hz')
!       WRITE(6,21) 'Core polarisation corrections to IV = ',IV
!       WRITE(7,21) 'Core polarisation corrections to IV = ',IV
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) 'W(1)      ',W1AU,W1HZ
!       WRITE(7,22) 'W(1)      ',W1AU,W1HZ
!       WRITE(6,22) 'W(1)^CP[D]',WDAU,WDHZ
!       WRITE(7,22) 'W(1)^CP[D]',WDAU,WDHZ
!       WRITE(6,22) 'W(1)^CP[X]',WXAU,WXHZ
!       WRITE(7,22) 'W(1)^CP[X]',WXAU,WXHZ
!       WRITE(6, *) REPEAT('-',72)
!       WRITE(7, *) REPEAT('-',72)
!       WRITE(6,22) 'W(1) [TOT]',WTAU,WTHZ
!       WRITE(7,22) 'W(1) [TOT]',WTAU,WTHZ
!       WRITE(6, *) REPEAT('=',72)
!       WRITE(7, *) REPEAT('=',72)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE COREINT(VVAR,AVVR,NUMO,NUMV,IVRTV)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C       CCCCCC   OOOOOO  RRRRRRR  EEEEEEEE IIII NN    NN TTTTTTTT      C
! C      CC    CC OO    OO RR    RR EE        II  NNN   NN    TT         C
! C      CC       OO    OO RR    RR EE        II  NNNN  NN    TT         C
! C      CC       OO    OO RR    RR EEEEEE    II  NN NN NN    TT         C
! C      CC       OO    OO RRRRRRR  EE        II  NN  NNNN    TT         C
! C      CC    CC OO    OO RR    RR EE        II  NN   NNN    TT         C
! C       CCCCCC   OOOOOO  RR    RR EEEEEEEE IIII NN    NN    TT         C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  COREINT EVALUATES COULOUMB INTEGRALS MATRIX ELEMENTS AS REQUIRED    C
! C  FOR USE IN COREPOL WITH CONTRIBUTIONS FROM NEGATIVE-ENERGY SPECTRUM.C
! C  CONTRACTIONS CAN BE ARRANGED IN A TIME-SAVING WAY, SO THAT IT IS    C
! C  MORE USEFUL TO CUT DOWN ON ERI GENERATION TIME (USE SWAP SYMMETRY). C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IVRTV - VIRTUAL STATE TO CONTRACT OVER (DO NOT INCLUDE NSKP).     C
! C  OUTPUT:                                                             C
! C  ▶ VVAR  - DIRECT COULOMB MATRIX ELEMENTS, CONTRACTED OVER IVRTV.    C
! C  ▶ AVVR  - EXCHANGE COULOMB MATRIX ELEMENTS, CONTRACTED OVER IVRTV.  C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
!       DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP)
! C
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 RR(MB2,16)
!       COMPLEX*16 V1(MBS,8),V2(MBS,8)
!       COMPLEX*16 VV(MB2,4),AV(MB2,NUMO,4)
!       COMPLEX*16 RVV1(MBS,NUMV,2),RVV2(MBS,NUMV,2),
!      &           RAV1(MBS,NUMO*NUMV,2),RAV2(MBS,NUMO*NUMV,2)
!       COMPLEX*16 ARVV(NUMO,NUMV),VRAV(NUMO,NUMV)
!       COMPLEX*16 VVAR(MDM,MDM),AVVR(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/EIGC/COEF
!       COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
!       COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
!       COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
!       COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
!       COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
! C
! C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
!       RCFILE = .FALSE.
! C
! C     COMPONENT OVERLAP LABELS TO LOOP OVER
!       IF(HMLT.EQ.'NORL') THEN
!         ITSTRT = 1
!         ITSTOP = 1
!         ITSKIP = 1
!       ELSE
!         ITSTRT = 4
!         ITSTOP = 1
!         ITSKIP =-3
!       ENDIF
! C
! C     CLEAR THE GLOBAL DIRECT AND EXCHANGE ARRAYS
!       DO I=1,NDIM
!         DO J=1,NDIM
!           VVAR(I,J) = DCMPLX(0.0D0,0.0D0)
!           AVVR(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     CLEAR THE LOCAL DIRECT AND EXCHANGE ARRAYS
!       DO IOCCA=1,NUMO
!         DO IVRTR=1,NUMV
!           ARVV(IOCCA,IVRTR) = DCMPLX(0.0D0,0.0D0)
!           VRAV(IOCCA,IVRTR) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     FOCK MATRIX ADDRESS FOR IVRTV
!       IV = NSKP+IVRTV
! C
! C**********************************************************************C
! C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
! C**********************************************************************C
! C
!       ICOUNT = 0
! C
! C     LOOP OVER NUCLEAR CENTRES
!       DO ICT=1,NCNT
! C
! C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
!         DO KN=1,NKAP(ICT)
! C
! C         IMPORT KAPPA, MAXIMUM MQN
!           KAPPA = KAPA(KN,ICT)
!           MJMAX = 2*IABS(KAPPA)-1
! C
! C         LOOP OVER MQN VALUES AND RECORD INDEX
!           DO MJ=1,MJMAX,2
!             ICOUNT              = ICOUNT+1
!             INDEX(ICT,KAPPA,MJ) = ICOUNT
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER COMPONENT OVERLAP LABELS TT(AB) (USE INDEX 1000)       C
! C**********************************************************************C
! C
! C     COMPONENT LABEL FOR A AND B: TT = LL(1) or SS(4) <- COULOMB
! C                                  TT = LS(2) or SL(3) <- BREIT
!       DO 1000 IT1=ITSTRT,ITSTOP,ITSKIP
! C
! C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
!         ITN(1) = IT1
! C
! C       CALCULATE STARTING ADDRESS
!         IF(ITN(1).EQ.1) THEN
!           NADDAB = 0
!         ELSE
!           NADDAB = NSKP
!         ENDIF
! C
! C**********************************************************************C
! C     LOOP OVER BLOCKS OF A (USE INDEX 2000)                           C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 2000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 2000 MA=1,IABS(KQN(1))
!         MQN(1) = 2*MA-1
! C
! C     INDEX ASSIGNMENT
!       IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
! C
! C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON A
!       NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
!       NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
! C
! C**********************************************************************C
! C     LOOP OVER BLOCKS OF B (USE INDEX 3000)                           C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE B
!       DO 3000 ICNTB=1,ICNTA
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 3000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1, NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MQN(2) = 2*MB-1
! C
! C     INDEX ASSIGNMENT
!       IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
! C
! C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON B
!       NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDAB
!       NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDAB
! C
! C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
!       IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
!       IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
! C
! C     FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
!       IEAB = 1
! C
! C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
!       PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
!       PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
! C
! C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
!       IF(IQ1.LT.IQ2) GOTO 3001
! C
! C     CLEAR ARRAY FOR SECOND CONTRACTION (KL->AR)
!       DO MIJ=1,NBAS(1)*NBAS(2)
!         DO IJSPIN=1,4
!           VV(MIJ,IJSPIN) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     CLEAR ARRAY FOR SECOND CONTRACTION (KL->VR)
!       DO MIJ=1,NBAS(1)*NBAS(2)
!         DO IOCCA=1,NUMO
!           DO IJSPIN=1,4
!             AV(MIJ,IOCCA,IJSPIN) = DCMPLX(0.0D0,0.0D0)
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) (INDEX 4000)               C
! C**********************************************************************C
! C
!       DO 4000 IBAS=1,NBAS(1)
!       DO 4000 JBAS=1,NBAS(2)
! C
! C     LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
!       MIJ = (IBAS-1)*NBAS(2)+JBAS
! C
! C**********************************************************************C
! C     LOOP OVER COMPONENT OVERLAP LABELS TT(CD) (USE INDEX 5000)       C
! C**********************************************************************C
! C
! C     COMPONENT LABEL FOR C AND D: TT = LL(1) or SS(4)
!       DO 5000 IT2=ITSTRT,ITSTOP,ITSKIP
! C
! C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
!         ITN(2) = IT2
! C
! C       CALCULATE STARTING ADDRESS
!         IF(ITN(2).EQ.1) THEN
!           NADDCD = 0
!         ELSE
!           NADDCD = NSKP
!         ENDIF
! C
! C**********************************************************************C
! C     LOOP OVER BLOCKS OF C (USE INDEX 6000)                           C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE C
!       DO 6000 ICNTC=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE C
!         XYZ(1,3) = BXYZ(1,ICNTC)
!         XYZ(2,3) = BXYZ(2,ICNTC)
!         XYZ(3,3) = BXYZ(3,ICNTC)
! C
! C     LOOP OVER KQN(C) VALUES
!       DO 6000 KC=1,NKAP(ICNTC)
! C
! C       QUANTUM NUMBERS FOR BLOCK C
!         KQN(3) = KAPA(KC,ICNTC)
!         LQN(3) = LVAL(KQN(3))
! C
! C       BASIS EXPONENTS FOR BLOCK C
!         NBAS(3) = NFNC(LQN(3),ICNTC)
!         DO KBAS=1,NBAS(3)
!           EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
!         ENDDO
! C
! C     LOOP OVER |MQN(C)| VALUES
!       DO 6000 MC=1,IABS(KQN(3))
!         MQN(3) = 2*MC-1
! C
! C     INDEX ASSIGNMENT
!       IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
! C
! C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON C
!       NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDCD
!       NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDCD
! C
! C**********************************************************************C
! C     LOOP OVER BLOCKS OF D (USE INDEX 7000)                           C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE D
!       DO 7000 ICNTD=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE D
!         XYZ(1,4) = BXYZ(1,ICNTD)
!         XYZ(2,4) = BXYZ(2,ICNTD)
!         XYZ(3,4) = BXYZ(3,ICNTD)
! C
! C     LOOP OVER KQN(D) VALUES
!       DO 7000 KD=1,NKAP(ICNTD)
! C
! C       QUANTUM NUMBERS FOR BLOCK D
!         KQN(4) = KAPA(KD,ICNTD)
!         LQN(4) = LVAL(KQN(4))
! C
! C       BASIS EXPONENTS FOR BLOCK D
!         NBAS(4) = NFNC(LQN(4),ICNTD)
!         DO LBAS=1,NBAS(4)
!           EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
!         ENDDO
! C
! C     LOOP OVER |MQN(D)| VALUES
!       DO 7000 MD=1,IABS(KQN(4))
!         MQN(4) = 2*MD-1
! C
! C     INDEX ASSIGNMENT
!       IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
! C
! C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON D
!       ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDCD
!       ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDCD
! C
! C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
!       ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
!       ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
! C
! C     FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
!       IECD = 1
! C
! C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
!       PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
!       PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
! C
! C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
!       IF(IQ3.LT.IQ4) GOTO 7001
! C
! C**********************************************************************C
! C     ALL LOOPS NOW COMPLETE -- GENERATE BATCH OF ERIs AND CONTRACT    C
! C**********************************************************************C
! C
! C     RESET SCREENING COUNTERS
!       DO M=1,NBAS(3)*NBAS(4)
!         IMAP(M) = M
!         ISCR(M) = 1
!       ENDDO

! C     BATCH OF ELECTRON INTERACTION INTEGRALS (IJ|KL) FOR FIXED (IJ)
!       CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
! C
! C     CLEAR ARRAY FOR FIRST CONTRACTION (L->R)
!       DO MKV=1,NBAS(3)
!         DO IJKSPIN=1,8
!           V1(MKV,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     CLEAR ARRAY FOR FIRST CONTRACTION (K->R)
!       DO MLV=1,NBAS(4)
!         DO IJKSPIN=1,8
!           V2(MLV,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     FIRST CONTRACTION:                                               C
! C     (IJ;T|KL;T') -> (IJ;T|KV;T')  AND  (IJ;T|LK;T') -> (IJ;T|LV;T')  C
! C**********************************************************************C
! C
! C     FIRST CONTRACTION (NORMAL): (IJ;T|KL;T') -> (IJ;T|KV;T')
! C
! C     LOOP OVER BASIS FUNCTIONS IN BLOCK C AND FOR THIS IV
!       DO KBAS=1,NBAS(3)
! C
! C       CONTRACT OVER ALL LBAS IN BLOCK D
!         DO LBAS=1,NBAS(4)
! C
! C         LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
!           M = (KBAS-1)*NBAS(4) + LBAS
! C
! C         (--|-V) = (--|--) + (--|-+)
!           V1(KBAS,1) = V1(KBAS,1) + RR(M, 1)*COEF(ND1+LBAS,IV)
!      &                            + RR(M, 2)*COEF(ND2+LBAS,IV)
! C
! C         (+-|-V) = (+-|--) + (+-|-+)
!           V1(KBAS,2) = V1(KBAS,2) + RR(M, 3)*COEF(ND1+LBAS,IV)
!      &                            + RR(M, 4)*COEF(ND2+LBAS,IV)
! C
! C         (-+|-V) = (-+|--) + (-+|-+)
!           V1(KBAS,3) = V1(KBAS,3) + RR(M, 5)*COEF(ND1+LBAS,IV)
!      &                            + RR(M, 6)*COEF(ND2+LBAS,IV)
! C
! C         (++|-V) = (++|--) + (++|-+)
!           V1(KBAS,4) = V1(KBAS,4) + RR(M, 7)*COEF(ND1+LBAS,IV)
!      &                            + RR(M, 8)*COEF(ND2+LBAS,IV)
! C
! C         (--|+V) = (--|+-) + (--|++)
!           V1(KBAS,5) = V1(KBAS,5) + RR(M, 9)*COEF(ND1+LBAS,IV)
!      &                            + RR(M,10)*COEF(ND2+LBAS,IV)
! C
! C         (+-|+V) = (+-|+-) + (+-|++)
!           V1(KBAS,6) = V1(KBAS,6) + RR(M,11)*COEF(ND1+LBAS,IV)
!      &                            + RR(M,12)*COEF(ND2+LBAS,IV)
! C
! C         (-+|+V) = (-+|+-) + (-+|++)
!           V1(KBAS,7) = V1(KBAS,7) + RR(M,13)*COEF(ND1+LBAS,IV)
!      &                            + RR(M,14)*COEF(ND2+LBAS,IV)
! C
! C         (++|+V) = (++|+-) + (++|++)
!           V1(KBAS,8) = V1(KBAS,8) + RR(M,15)*COEF(ND1+LBAS,IV)
!      &                            + RR(M,16)*COEF(ND2+LBAS,IV)
! C
!         ENDDO
! C
!       ENDDO
! C
! C     UTILISE R-INTEGRAL SYMMETRY OF (CD) SWAP
!       IF(IQ3.NE.IQ4) THEN
! C
! C       FIRST CONTRACTION (SWAP): (JI;T|KL;T') -> (JI;T|KV;T')
! C
! C       CONTRACT OVER ALL LBAS IN BLOCK D
!         DO LBAS=1,NBAS(4)
! C
! C         LOOP OVER BASIS FUNCTIONS IN BLOCK C AND FOR THIS IV
!           DO KBAS=1,NBAS(3)
! C
! C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
!             M = (KBAS-1)*NBAS(4) + LBAS
! C
! C           (--|-V)' = PCD1*(--|--) + PCD2*(--|-+)
!             V2(LBAS,1) = V2(LBAS,1)
!      &                        + PCD1*RR(M, 4)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + PCD2*RR(M, 2)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C           (--|+V)' = PCD2*(--|+-) + PCD1*(--|++)
!             V2(LBAS,2) = V2(LBAS,2)
!      &                        + PCD2*RR(M, 3)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + PCD1*RR(M, 1)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C           (-+|-V)' = PCD1*(-+|--) + PCD2*(-+|-+)
!             V2(LBAS,3) = V2(LBAS,3)
!      &                        + PCD1*RR(M, 8)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + PCD2*RR(M, 6)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C           (-+|+V)' = PCD2*(-+|+-) + PCD1*(-+|++)
!             V2(LBAS,4) = V2(LBAS,4)
!      &                        + PCD2*RR(M, 7)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + PCD1*RR(M, 5)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C           (+-|-V)' = PCD1*(+-|--) + PCD2*(+-|-+)
!             V2(LBAS,5) = V2(LBAS,5)
!      &                        + PCD1*RR(M,12)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + PCD2*RR(M,10)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C           (+-|+V)' = PCD2*(+-|+-) + PCD1*(+-|++)
!             V2(LBAS,6) = V2(LBAS,6)
!      &                        + PCD2*RR(M,11)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + PCD1*RR(M, 9)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C           (++|-V)' = PCD1*(++|--) + PCD2*(++|-+)
!             V2(LBAS,7) = V2(LBAS,7)
!      &                        + PCD1*RR(M,16)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + PCD2*RR(M,14)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C           (++|+V)' = PCD2*(++|+-) + PCD1*(++|++)
!             V2(LBAS,8) = V2(LBAS,8)
!      &                        + PCD2*RR(M,15)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + PCD1*RR(M,13)*DCONJG(COEF(NC2+KBAS,IV))
! C
!           ENDDO
!         ENDDO
! C
!       ENDIF
! C
! C**********************************************************************C
! C     SECOND CONTRACTION:                                   ~          C
! C     (IJ;T|KV;T') -> (IJ;T|VV)  AND  (IJ;T|LV;T') -> (IJ;T|VV)        C
! C     (IJ;T|KV;T') -> (IJ;T|AV)  AND  (IJ;T|LV;T') -> (IJ;T|AV)        C
! C**********************************************************************C
! C
! C     SECOND CONTRACTION (NORMAL) DIRECT: (IJ;T|KV;T') -> (IJ;T|VV;T')
! C
! C     CONTRACT OVER ALL KBAS IN BLOCK C
!       DO KBAS=1,NBAS(3)
! C
! C       (--|VV) = (--|-V) + (--|+V)
!         VV(MIJ,1) = VV(MIJ,1) + V1(KBAS,1)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + V1(KBAS,2)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C       (-+|VV) = (-+|-V) + (-+|+V)
!         VV(MIJ,2) = VV(MIJ,2) + V1(KBAS,3)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + V1(KBAS,4)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C       (+-|VV) = (+-|-V) + (+-|+V)
!         VV(MIJ,3) = VV(MIJ,3) + V1(KBAS,5)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + V1(KBAS,6)*DCONJG(COEF(NC2+KBAS,IV))
! C
! C       (++|VV) = (++|-V) + (++|+V)
!         VV(MIJ,4) = VV(MIJ,4) + V1(KBAS,7)*DCONJG(COEF(NC1+KBAS,IV))
!      &                        + V1(KBAS,8)*DCONJG(COEF(NC2+KBAS,IV))
! C
!       ENDDO
! C
! C     SECOND CONTRACTION (NORMAL) EXCHANGE: (IJ;T|KV;T') -> (IJ;T|AV;T')
! C
! C     LOOP OVER OCCUPIED STATES IOCCA
!       DO IOCCA=1,NUMO
! C
! C       FOCK MATRIX ADDRESS FOR IOCCA
!         IA = NSKP+IOCCA
! C
! C       CONTRACT OVER ALL KBAS IN BLOCK C
!         DO KBAS=1,NBAS(3)
! C
! C         (--|AV) = (--|-V)' + (--|+V)'
!           AV(MIJ,IOCCA,1) = AV(MIJ,IOCCA,1)
!      &                           + V1(KBAS,1)*DCONJG(COEF(NC1+KBAS,IA))
!      &                           + V1(KBAS,2)*DCONJG(COEF(NC2+KBAS,IA))
! C
! C         (-+|AV) = (-+|-V)' + (-+|+V)'
!           AV(MIJ,IOCCA,2) = AV(MIJ,IOCCA,2)
!      &                           + V1(KBAS,3)*DCONJG(COEF(NC1+KBAS,IA))
!      &                           + V1(KBAS,4)*DCONJG(COEF(NC2+KBAS,IA))
! C
! C         (+-|AV) = (+-|-V)' + (+-|+V)'
!           AV(MIJ,IOCCA,3) = AV(MIJ,IOCCA,3)
!      &                           + V1(KBAS,5)*DCONJG(COEF(NC1+KBAS,IA))
!      &                           + V1(KBAS,6)*DCONJG(COEF(NC2+KBAS,IA))
! C
! C         (++|AV) = (++|-V)' + (++|+V)'
!           AV(MIJ,IOCCA,4) = AV(MIJ,IOCCA,4)
!      &                           + V1(KBAS,7)*DCONJG(COEF(NC1+KBAS,IA))
!      &                           + V1(KBAS,8)*DCONJG(COEF(NC2+KBAS,IA))
! C
!         ENDDO
! C
!       ENDDO
! C
! C     UTILISE R-INTEGRAL SYMMETRY OF (CD) SWAP
!       IF(IQ3.NE.IQ4) THEN
! C
! C       SECOND CONTRACTION (SWAP) DIRECT: (IJ;T|KV;T') -> (IJ;T|VV;T')
!         DO LBAS=1,NBAS(4)
! C
! C         (--|VV) = (--|-V) + (--|+V)
!           VV(MIJ,1) = VV(MIJ,1) + V2(LBAS,1)*COEF(ND1+LBAS,IV)
!      &                          + V2(LBAS,2)*COEF(ND2+LBAS,IV)
! C
! C         (-+|VV) = (-+|-V) + (-+|+V)
!           VV(MIJ,2) = VV(MIJ,2) + V2(LBAS,3)*COEF(ND1+LBAS,IV)
!      &                          + V2(LBAS,4)*COEF(ND2+LBAS,IV)
! C
! C         (+-|VV) = (+-|-V) + (+-|+V)
!           VV(MIJ,3) = VV(MIJ,3) + V2(LBAS,5)*COEF(ND1+LBAS,IV)
!      &                          + V2(LBAS,6)*COEF(ND2+LBAS,IV)
! C
! C         (++|VV) = (++|-V) + (++|+V)
!           VV(MIJ,4) = VV(MIJ,4) + V2(LBAS,7)*COEF(ND1+LBAS,IV)
!      &                          + V2(LBAS,8)*COEF(ND2+LBAS,IV)
! C
!         ENDDO
! C
! C       SECOND CONTRACTION (SWAP) EXCHANGE: (IJ;T|KV;T') -> (IJ;T|AV;T')
! C
! C       LOOP OVER OCCUPIED STATES IOCCA
!         DO IOCCA=1,NUMO
! C
! C         FOCK MATRIX ADDRESS FOR IOCCA
!           IA = NSKP+IOCCA
! C
! C         CONTRACT OVER ALL KBAS IN BLOCK C
!           DO LBAS=1,NBAS(4)
! C
! C           (--|AV) = (--|-V)' + (--|+V)'
!             AV(MIJ,IOCCA,1) = AV(MIJ,IOCCA,1)
!      &                                   + V2(LBAS,1)*COEF(ND1+LBAS,IA)
!      &                                   + V2(LBAS,2)*COEF(ND2+LBAS,IA)
! C
! C           (-+|AV) = (-+|-V)' + (-+|+V)'
!             AV(MIJ,IOCCA,2) = AV(MIJ,IOCCA,2)
!      &                                   + V2(LBAS,3)*COEF(ND1+LBAS,IA)
!      &                                   + V2(LBAS,4)*COEF(ND2+LBAS,IA)
! C
! C           (+-|AV) = (+-|-V)' + (+-|+V)'
!             AV(MIJ,IOCCA,3) = AV(MIJ,IOCCA,3)
!      &                                   + V2(LBAS,5)*COEF(ND1+LBAS,IA)
!      &                                   + V2(LBAS,6)*COEF(ND2+LBAS,IA)
! C
! C           (++|AV) = (++|-V)' + (++|+V)'
!             AV(MIJ,IOCCA,4) = AV(MIJ,IOCCA,4)
!      &                                   + V2(LBAS,7)*COEF(ND1+LBAS,IA)
!      &                                   + V2(LBAS,8)*COEF(ND2+LBAS,IA)
! C
!           ENDDO
! C
!         ENDDO
! C
!       ENDIF
! C
! C     SKIP POINT FOR IQ3.LT.IQ4
! 7001  CONTINUE
! C
! C     ALL CONTRIBUTIONS FROM THIS CLASS (C,D) NOW ACCOUNTED FOR
! 7000  CONTINUE
! 6000  CONTINUE
! C
! C     END LOOP OVER COMPONENT TYPE T'T'
! 5000  CONTINUE
! C
! C     FULL BLOCK (C,D) FOR EACH (IBAS,JBAS) AND T'T' NOW FINISHED
! 4000  CONTINUE
! C
! C**********************************************************************C
! C     THIRD CONTRACTION:                                               C
! C     (IJ;T|VV) -> (IR;T|VV)  AND  (IJ;T|AV) -> (IR;T|AV)              C
! C     (JI;T|VV) -> (JR;T|VV)  AND  (JI;T|AV) -> (JR;T|AV)              C
! C**********************************************************************C
! C
! C     THIRD CONTRACTION (NORMAL) DIRECT: (IJ;T|VV) -> (IR;T|VV)
! C
! C     CLEAR ARRAY FOR THIRD CONTRACTION (NORMAL) DIRECT
!       DO IBAS=1,NBAS(1)
!         DO IVRTR=1,NUMV
!           DO ISPIN=1,2
!             RVV1(IBAS,IVRTR,ISPIN) = DCMPLX(0.0D0,0.0D0)
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     LOOP OVER VIRTUAL STATES IVRTR
!       DO IVRTR=1,NUMV
! C
! C       FOCK MATRIX ADDRESS FOR IVRTR
!         IF(IVRTR.LE.NSKP) THEN
!           IR = IVRTR
!         ELSE
!           IR = IVRTR+NUMO
!         ENDIF
! C
! C       CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
! C
! C           LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
!             MIJ = (IBAS-1)*NBAS(2)+JBAS
! C
! C           (-R|VV) = (--|VV) + (-+|VV)
!             RVV1(IBAS,IVRTR,1) = RVV1(IBAS,IVRTR,1)
!      &                               +      VV(MIJ,1)*COEF(NB1+JBAS,IR)
!      &                               +      VV(MIJ,2)*COEF(NB2+JBAS,IR)
! C
! C           (+R|VV) = (+-|VV) + (++|VV)
!             RVV1(IBAS,IVRTR,2) = RVV1(IBAS,IVRTR,2)
!      &                               +      VV(MIJ,3)*COEF(NB1+JBAS,IR)
!      &                               +      VV(MIJ,4)*COEF(NB2+JBAS,IR)
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     THIRD CONTRACTION (NORMAL) EXCHANGE: (IJ;T|AV) -> (IR;T|AV)
! C
! C     CLEAR ARRAY FOR THIRD CONTRACTION (NORMAL) EXCHANGE
!       DO IBAS=1,NBAS(1)
!         DO MRA=1,NUMO*NUMV
!           DO ISPIN=1,2
!             RAV1(IBAS,MRA,ISPIN) = DCMPLX(0.0D0,0.0D0)
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     LOOP OVER VIRTUAL STATES IVRTR
!       DO IVRTR=1,NUMV
! C
! C       FOCK MATRIX ADDRESS FOR IVRTR
!         IF(IVRTR.LE.NSKP) THEN
!           IR = IVRTR
!         ELSE
!           IR = IVRTR+NUMO
!         ENDIF
! C
! C       LOOP OVER OCCUPIED STATES IOCCA
!         DO IOCCA=1,NUMO
! C
! C         LIST ADDRESS FOR THIS IOCCA,IVRTR COMBINATION IN RAV
!           MRA = (IOCCA-1)*NUMV + IVRTR
! C
! C         CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
!           DO IBAS=1,NBAS(1)
!             DO JBAS=1,NBAS(2)
! C
! C             LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
!               MIJ = (IBAS-1)*NBAS(2)+JBAS
! C
! C             (-R|AV) = (--|AV) + (-+|AV)
!               RAV1(IBAS,MRA,1) = RAV1(IBAS,MRA,1)
!      &                         +      AV(MIJ,IOCCA,1)*COEF(NB1+JBAS,IR)
!      &                         +      AV(MIJ,IOCCA,2)*COEF(NB2+JBAS,IR)
! C
! C             (+R|AV) = (+-|AV) + (++|AV)
!               RAV1(IBAS,MRA,2) = RAV1(IBAS,MRA,2)
!      &                         +      AV(MIJ,IOCCA,3)*COEF(NB1+JBAS,IR)
!      &                         +      AV(MIJ,IOCCA,4)*COEF(NB2+JBAS,IR)
! C
!             ENDDO
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     UTILISE R-INTEGRAL SYMMETRY OF (AB) SWAP
!       IF(IQ1.NE.IQ2) THEN
! C
! C       THIRD CONTRACTION (NORMAL) DIRECT: (JI;T|VV) -> (JR;T|VV)
! C
! C       CLEAR ARRAYS FOR THIRD CONTRACTION (SWAP) DIRECT
!         DO JBAS=1,NBAS(2)
!           DO IVRTR=1,NUMV
!             DO ISPIN=1,2
!               RVV2(JBAS,IVRTR,ISPIN) = DCMPLX(0.0D0,0.0D0)
!             ENDDO
!           ENDDO
!         ENDDO
! C
! C       LOOP OVER VIRTUAL STATES IVRTR
!         DO IVRTR=1,NUMV
! C
! C         FOCK MATRIX ADDRESS FOR IVRTR
!           IF(IVRTR.LE.NSKP) THEN
!             IR = IVRTR
!           ELSE
!             IR = IVRTR+NUMO
!           ENDIF
! C
! C         CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
!           DO IBAS=1,NBAS(1)
!             DO JBAS=1,NBAS(2)
! C
! C             LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
!               MIJ = (IBAS-1)*NBAS(2)+JBAS
! C
! C             (-R|VV)' = PAB1*(--|VV) + PAB2*(-+|VV)
!               RVV2(JBAS,IVRTR,1) = RVV2(JBAS,IVRTR,1)
!      &                       + PAB1*VV(MIJ,4)*DCONJG(COEF(NA1+IBAS,IR))
!      &                       + PAB2*VV(MIJ,2)*DCONJG(COEF(NA2+IBAS,IR))
! C
! C             (+R|VV)' = PAB2*(+-|VV) + PAB1*(++|VV)
!               RVV2(JBAS,IVRTR,2) = RVV2(JBAS,IVRTR,2)
!      &                       + PAB2*VV(MIJ,3)*DCONJG(COEF(NA1+IBAS,IR))
!      &                       + PAB1*VV(MIJ,1)*DCONJG(COEF(NA2+IBAS,IR))
! C
!             ENDDO
!           ENDDO
!         ENDDO
! C
! C       THIRD CONTRACTION (NORMAL) EXCHANGE: (JI;T|AV) -> (JR;T|AV)
! C
! C       CLEAR ARRAYS FOR THIRD CONTRACTION (SWAP) EXCHANGE
!         DO JBAS=1,NBAS(2)
!           DO MRA=1,NUMO*NUMV
!             DO ISPIN=1,2
!               RAV2(JBAS,MRA,ISPIN) = DCMPLX(0.0D0,0.0D0)
!             ENDDO
!           ENDDO
!         ENDDO
! C
! C       LOOP OVER VIRTUAL STATES IVRTR
!         DO IVRTR=1,NUMV
! C
! C         FOCK MATRIX ADDRESS FOR IVRTR
!           IF(IVRTR.LE.NSKP) THEN
!             IR = IVRTR
!           ELSE
!             IR = IVRTR+NUMO
!           ENDIF
! C
! C         LOOP OVER OCCUPIED STATES IOCCA
!           DO IOCCA=1,NUMO
! C
! C           LIST ADDRESS FOR THIS IOCCA,IVRTR COMBINATION IN RAV
!             MRA = (IOCCA-1)*NUMV + IVRTR
! C
! C           CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
!             DO IBAS=1,NBAS(1)
!               DO JBAS=1,NBAS(2)
! C
! C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
!                 MIJ = (IBAS-1)*NBAS(2)+JBAS
! C
! C               (-R|AV)' = PAB1*(--|AV) + PAB2*(-+|AV)
!                 RAV2(JBAS,MRA,1) = RAV2(JBAS,MRA,1)
!      &                 + PAB1*AV(MIJ,IOCCA,4)*DCONJG(COEF(NA1+IBAS,IR))
!      &                 + PAB2*AV(MIJ,IOCCA,2)*DCONJG(COEF(NA2+IBAS,IR))
! C
! C               (+R|AV)' = PAB2*(+-|AV) + PAB1*(++|AV)
!                 RAV2(JBAS,MRA,2) = RAV2(JBAS,MRA,2)
!      &                 + PAB2*AV(MIJ,IOCCA,3)*DCONJG(COEF(NA1+IBAS,IR))
!      &                 + PAB1*AV(MIJ,IOCCA,1)*DCONJG(COEF(NA2+IBAS,IR))
! C
!               ENDDO
!             ENDDO
!           ENDDO
!         ENDDO
! C
!       ENDIF
! C
! C**********************************************************************C
! C     FOURTH CONTRACTION:                      ~                       C
! C     (IR;T|VV) -> (AR|VV)  AND  (JR;T|VV) -> (AR|VV)                  C
! C     (IR;T|AV) -> (VR|AV)  AND  (JR;T|AV) -> (VR|AV)                  C
! C**********************************************************************C
! C
! C     FOURTH CONTRACTION (NORMAL) DIRECT: (IR;T|VV) -> (AR|VV)
! C
! C     LOOP OVER OCCUPIED STATES IOCCA
!       DO IOCCA=1,NUMO
! C
! C       FOCK MATRIX ADDRESS FOR IOCCA
!         IA = NSKP+IOCCA
! C
! C       LOOP OVER VIRTUAL STATES IVRTR
!         DO IVRTR=1,NUMV
! C
! C         CONTRACT OVER ALL IBAS IN BLOCK A
!           DO IBAS=1,NBAS(1)
! C
! C           (AR|VV) = (-R|VV) + (+R|VV)
!             ARVV(IOCCA,IVRTR) = ARVV(IOCCA,IVRTR)
!      &                   + RVV1(IBAS,IVRTR,1)*DCONJG(COEF(NA1+IBAS,IA))
!      &                   + RVV1(IBAS,IVRTR,2)*DCONJG(COEF(NA2+IBAS,IA))
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     FOURTH CONTRACTION (NORMAL) EXCHANGE: (IR;T|AV) -> (VR|AV)
! C
! C     LOOP OVER OCCUPIED STATES IOCCA
!       DO IOCCA=1,NUMO
! C
! C       LOOP OVER VIRTUAL STATES IVRTR
!         DO IVRTR=1,NUMV
! C
! C         LIST ADDRESS FOR THIS IOCCA,IVRTR COMBINATION IN RAV
!           MRA = (IOCCA-1)*NUMV + IVRTR
! C
! C         CONTRACT OVER ALL IBAS IN BLOCK A
!           DO IBAS=1,NBAS(1)
! C
! C           (VR|AV) = (-R|AV) + (+R|AV)
!             VRAV(IOCCA,IVRTR) = VRAV(IOCCA,IVRTR)
!      &                    + RAV1(IBAS,MRA,1)*DCONJG(COEF(NA1+IBAS,IV))
!      &                    + RAV1(IBAS,MRA,2)*DCONJG(COEF(NA2+IBAS,IV))
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     UTILISE R-INTEGRAL SYMMETRY OF (AB) SWAP
!       IF(IQ1.NE.IQ2) THEN
! C                                                     ~
! C       FOURTH CONTRACTION (SWAP) DIRECT: (JR;T|VV) -> (AR|VV)
! C
! C       LOOP OVER OCCUPIED STATES IOCCA
!         DO IOCCA=1,NUMO
! C
! C         FOCK MATRIX ADDRESS FOR IOCCA
!           IA = NSKP+IOCCA
! C
! C         LOOP OVER VIRTUAL STATES IVRTR AND OCCUPIED STATES
!           DO IVRTR=1,NUMV
! C
! C           CONTRACT OVER ALL IBAS IN BLOCK A
!             DO JBAS=1,NBAS(2)
! C
! C             (AR|VV) = (-R|VV)' + (+R|VV)'
!               ARVV(IOCCA,IVRTR) = ARVV(IOCCA,IVRTR)
!      &                           + RVV2(JBAS,IVRTR,1)*COEF(NB1+JBAS,IA)
!      &                           + RVV2(JBAS,IVRTR,2)*COEF(NB2+JBAS,IA)
! C
!             ENDDO
!           ENDDO
!         ENDDO
! C                                                       ~
! C       FOURTH CONTRACTION (SWAP) EXCHANGE: (JR;T|AV) -> (VR|AV)
! C
! C       LOOP OVER OCCUPIED STATES IOCCA
!         DO IOCCA=1,NUMO
! C
! C         LOOP OVER VIRTUAL STATES IVRTR AND OCCUPIED STATES
!           DO IVRTR=1,NUMV
! C
! C           LIST ADDRESS FOR THIS IOCCA,IVRTR COMBINATION IN RAV
!             MRA = (IOCCA-1)*NUMV + IVRTR
! C
! C           CONTRACT OVER ALL IBAS IN BLOCK A
!             DO JBAS=1,NBAS(2)
! C
! C             (VR|AV) = (-R|AV)' + (+R|AV)'
!               VRAV(IOCCA,IVRTR) = VRAV(IOCCA,IVRTR)
!      &                             + RAV2(JBAS,MRA,1)*COEF(NB1+JBAS,IV)
!      &                             + RAV2(JBAS,MRA,2)*COEF(NB2+JBAS,IV)
! C
!             ENDDO
!           ENDDO
!         ENDDO
! C
!       ENDIF
! C
! C     SKIP POINT FOR IQ1.LT.IQ2
! 3001  CONTINUE
! C
! C     ALL CONTRIBUTIONS FROM THIS CLASS (A,B) NOW ACCOUNTED FOR
! 3000  CONTINUE
! 2000  CONTINUE
! C
! C     END LOOP OVER COMPONENT OVERLAP TYPE TT
! 1000  CONTINUE
! C
! C**********************************************************************C
! C     ALL CONTRACTIONS COMPLETE -- LEFT WITH (AR|VV) AND (VR|AV)       C
! C**********************************************************************C
! C
! C     CONSTRUCT VVAR AND AVVR IN FOCK ADDRESSES BY COMPLEX CONJUGATION
!       DO IOCCA=1,NUMO
!         DO IVRTR=1,NUMV
! C
! C         FOCK MATRIX ADDRESSES FOR IOCCA AND IVRTR
!           IA = NSKP+IOCCA
!           IF(IVRTR.LE.NSKP) THEN
!             IR = IVRTR
!           ELSE
!             IR = IVRTR+NUMO
!           ENDIF
! C
!           VVAR(IA,IR) = ARVV(IOCCA,IVRTR)
!           AVVR(IA,IR) = VRAV(IOCCA,IVRTR)
! C
!         ENDDO
!       ENDDO
! C
!       RETURN
!       END
C
C
      SUBROUTINE VMOMNT0(VIJ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 000000   C
C VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   00   000  C
C VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT   00  0000  C
C VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT   00 00 00  C
C  VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT   0000  00  C
C   VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT   000   00  C
C    VV    MM       MM  OOOOOO  MM       MM NN    NN    TT    000000   C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMOMNT0 CONSTRUCTS A MATRIX OF (μ,T|σ_Q|ν,T') ZEROTH MOMENT         C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS.                            C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     GENERATE ELLQ COEFFICIENTS (IPHS = +1)
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMOMNT0: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMOMNT0: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
          ERT = DSQRT(PI/EIJ)**3
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*E11(M,1)
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*E21(M,1)
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
C      IF(ITT.EQ.2) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) = CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
CC
CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
C      IF(ITT.EQ.3) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) =-CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
C
      RETURN
      END
! C
! C
!       SUBROUTINE VMOMNT1(VIJ,CLOC,ITT,IQ,IX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 11     C
! C   VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   111     C
! C   VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT    11     C
! C   VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT    11     C
! C    VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT    11     C
! C     VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT    11     C
! C      VV    MM       MM  OOOOOO  MM       MM NN    NN    TT   1111    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VMOMNT1 CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X|ν,T') FIRST MOMENT        C
! C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATE X.          C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ CLOC    = LOCAL ORIGIN OVER WHICH MOMENT IX IS TO BE EVALUATED.   C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN WEIGHTING FACTOR.        C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION CLOC(3),IVCT(3)
!       DIMENSION CP(MB2,3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE ARRAY OF MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     TURN IX INTO A VECTOR
!       CALL NCART(IVCT,IX)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VMOMNT1: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VMOMNT1: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     FINITE SUM ADDRESSES FOR CARTESIAN OVERLAPS OF INTEREST
!       IAD0 = IABC(     0 ,     0 ,     0 )
!       IAD1 = IABC(IVCT(1),IVCT(2),IVCT(3))
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX  = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY  = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ  = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         COORDINATES OF EVALUATION
!           CP(M,1) = PX-CLOC(1)
!           CP(M,2) = PY-CLOC(2)
!           CP(M,3) = PZ-CLOC(3)
! C
! C         FACTORS
!           ERT = DSQRT(PI/EIJ)**3
! C
! C         INTEGRALS FOR THIS BLOCK
!           TA1 = CP(M,IX)*E11(M,IAD0) + E11(M,IAD1)
!           TA2 = CP(M,IX)*E21(M,IAD0) + E21(M,IAD1)
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = ERT*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = ERT*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE VMOMNT2(VIJ,CLOC,DLOC,ITT,IQ,IX,JX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 222222   C
! C VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   22    22  C
! C VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT         22  C
! C VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT       22    C
! C  VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT     22      C
! C   VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT   22        C
! C    VV    MM       MM  OOOOOO  MM       MM NN    NN    TT   22222222  C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VMOMNT2 CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X.X'|ν,T') SECOND MOMENT    C
! C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATES X AND X'.  C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ CLOC    = LOCAL ORIGIN OVER WHICH MOMENT IX IS TO BE EVALUATED.   C
! C  ▶ DLOC    = LOCAL ORIGIN OVER WHICH MOMENT JX IS TO BE EVALUATED.   C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z} 1ST CARTESIAN WEIGHTING FACTOR.    C
! C  ▶ JX      = {1,2,3}   -> {X,Y,Z} 2ND CARTESIAN WEIGHTING FACTOR.    C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION CLOC(3),DLOC(3),IVCT(3),JVCT(3)
!       DIMENSION CP(MB2,3),DP(MB2,3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE ARRAY OF MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     TURN IX AND JX INTO VECTORS
!       CALL NCART(IVCT,IX)
!       CALL NCART(JVCT,JX)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VMOMNT2: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VMOMNT2: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     FINITE SUM ADDRESSES FOR CARTESIAN OVERLAPS OF INTEREST
!       IAD00 = IABC(             0 ,             0 ,             0 )
!       IAD10 = IABC(IVCT(1)        ,IVCT(2)        ,IVCT(3)        )
!       IAD01 = IABC(        JVCT(1),        JVCT(2),        JVCT(3))
!       IAD11 = IABC(IVCT(1)+JVCT(1),IVCT(2)+JVCT(2),IVCT(3)+JVCT(3))
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         COORDINATES OF EVALUATION
!           CP(M,1) = PX-CLOC(1)
!           CP(M,2) = PY-CLOC(2)
!           CP(M,3) = PZ-CLOC(3)
!           DP(M,1) = PX-DLOC(1)
!           DP(M,2) = PY-DLOC(2)
!           DP(M,3) = PZ-DLOC(3)
! C
! C         FACTORS
!           ERT = DSQRT(PI/EIJ)**3
! C
! C         INTEGRALS FOR THIS BLOCK
!           IF(IX.EQ.JX) THEN
!             TA1 = 2.0D0*CP(M,IX)*DP(M,JX)*E11(M,IAD00)
!             TA2 = 2.0D0*CP(M,IX)*DP(M,JX)*E21(M,IAD00)
!           ELSE
!             TA1 =       CP(M,IX)*DP(M,JX)*E11(M,IAD00)
!             TA2 =       CP(M,IX)*DP(M,JX)*E21(M,IAD00)
!           ENDIF
!           IF(NTUV.GT.1) THEN
!             TA1 = TA1 + DP(M,JX)*E11(M,IAD10)+CP(M,IX)*E11(M,IAD01)
!             TA2 = TA2 + DP(M,JX)*E21(M,IAD10)+CP(M,IX)*E21(M,IAD01)
!           ENDIF
!           IF(NTUV.GT.2) THEN
!             TA1 = TA1 + E11(M,IAD11)
!             TA2 = TA2 + E21(M,IAD11)
!           ENDIF
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = ERT*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = ERT*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOPS OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE VMNPOLE(VIJ,CLOC,ITT,IQ,IX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C  VV    VV MM       MM NN    NN PPPPPPP   OOOOOO  LL       EEEEEEEE   C
! C  VV    VV MMM     MMM NNN   NN PP    PP OO    OO LL       EE         C
! C  VV    VV MMMM   MMMM NNNN  NN PP    PP OO    OO LL       EE         C
! C  VV    VV MM MM MM MM NN NN NN PP    PP OO    OO LL       EEEEEE     C
! C   VV  VV  MM  MMM  MM NN  NNNN PPPPPPP  OO    OO LL       EE         C
! C    VVVV   MM   M   MM NN   NNN PP       OO    OO LL       EE         C
! C     VV    MM       MM NN    NN PP        OOOOOO  LLLLLLLL EEEEEEEE   C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VMNPOLE CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X/R^3|ν,T') FIELD           C
! C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATE X.          C
! C  EXAMPLE: VALUE OF THE ELECTRIC FIELD AT COORDINATE CLOC.            C
! C -------------------------------------------------------------------- C
! C  DFNOTE: I'VE APPLIED A MODIFIER OF `CONE' TO MAKE THE ELECTRON      C
! C          ANOMALOUS MAGNETIC MOMENT CALCULATION CORRECT. CHECK IT.    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ CLOC    = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                  C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC.          C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION CLOC(3),IVCT(3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     TURN IX INTO A VECTOR
!       CALL NCART(IVCT,IX)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VMNPOLE: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VMNPOLE: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT C_LOC
!           CP(M,1) = CLOC(1)-PX
!           CP(M,2) = CLOC(2)-PY
!           CP(M,3) = CLOC(3)-PZ
! C
! C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
!           APH(M) = EIJ
!           PNC(M) = 2.0D0*PI/EIJ
! C
!         ENDDO
!       ENDDO
! C
! C     GENERATE A BATCH OF R-INTEGRALS (ADD ONE TO USUAL SUM ORDER)
!       CALL CPU_TIME(TDM1)
!       CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
!       CALL CPU_TIME(TDM2)
! C
! C     ADD TO RELEVANT TIME COUNTER
!       IF(ITT.EQ.1) THEN
!         TRLL = TRLL+TDM2-TDM1
!       ELSEIF(ITT.EQ.2) THEN
!         TRLS = TRLS+TDM2-TDM1
!       ELSEIF(ITT.EQ.3) THEN
!         TRSL = TRSL+TDM2-TDM1
!       ELSEIF(ITT.EQ.4) THEN
!         TRSS = TRSS+TDM2-TDM1
!       ENDIF
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
!           TA1 = DCMPLX(0.0D0,0.0D0)
!           TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FINITE EXPANSION ADDRESSES
!           DO ITUV=1,NTUV
! C
! C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
!             IT = IA(ITUV)
!             IU = IB(ITUV)
!             IV = IC(ITUV)
! C
! C           ADD CARTESTIAN COMPONENT IX TO OVERALL ADDRESS (R-INTS)
!             ITV1 = IABC(IT+IVCT(1),IU+IVCT(2),IV+IVCT(3))
! C
! C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
!             TA1 = TA1 - E11(M,ITUV)*RC(M,ITV1)
!             TA2 = TA2 - E21(M,ITUV)*RC(M,ITV1)
! C
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = CONE*PNC(M)*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = CONE*PNC(M)*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! C
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! C
!       RETURN
!       END
! ! C
! ! C
!       SUBROUTINE VNCELEC(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV NN    NN  CCCCCC  EEEEEEEE LL       EEEEEEEE  CCCCCC     C
! C    VV    VV NNN   NN CC    CC EE       LL       EE       CC    CC    C
! C    VV    VV NNNN  NN CC       EE       LL       EE       CC          C
! C    VV    VV NN NN NN CC       EEEEEE   LL       EEEEEE   CC          C
! C     VV  VV  NN  NNNN CC       EE       LL       EE       CC          C
! C      VVVV   NN   NNN CC    CC EE       LL       EE       CC    CC    C
! C       VV    NN    NN  CCCCCC  EEEEEEEE LLLLLLLL EEEEEEEE  CCCCCC     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VNCELEC CONSTRUCTS A MATRIX OF (NORMALISED) NUCLEAR ELECTRIC FIELD  C
! C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS: (μ,T|σ_Q.X/R^3|ν,T').      C
! C -------------------------------------------------------------------- C
! C  DFNOTE: THE ONE-CENTRE `QUADRATURE' OPTION TAKES A WHILE. TO AVOID  C
! C          UNNECESSARY COMPUTATION TIME, REPORT THE FULL VALUE IN THE  C
! C          CASE IX=1, AND NOTHING IN THE CASES IX=2 AND IX=3.          C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ      = NUCLEUS UNDER CONSIDERATION.                            C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z} ELECTRIC FIELD CARTESIAN INDEX.    C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
!       INCLUDE 'scfoptions.h'
! C
!       CHARACTER*5  NMDL
! C
!       DIMENSION IVCT(3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
!       DIMENSION RNTT(MBS,MBS)
!       DIMENSION EX2(MBS,2),LQ2(2),NBS2(2)
! C
!       COMPLEX*16 CONE,PHTT,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/GAMA/GAMLOG(300),GAMHLF(300)
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     COMPLEX FACTOR
!       IF(ITT.EQ.1) THEN
!         PHTT = DCMPLX(1.0D0,0.0D0)
!       ELSEIF(ITT.EQ.2) THEN
!         PHTT = CONE
!       ELSEIF(ITT.EQ.3) THEN
!         PHTT =-CONE
!       ELSEIF(ITT.EQ.4) THEN
!         PHTT = DCMPLX(1.0D0,0.0D0)
!       ENDIF
! C
! C     TURN IX INTO A VECTOR
!       CALL NCART(IVCT,IX)
! C
! C     INTEGRATION GRID DETAILS (WHEN QUADRATURE IS INVOKED)
!       NLIN = 100
!       NEXP = 5000
!       RMAX = 25.0D0
!       ELIN = RNUC(IZ)/DFLOAT(NLIN)
!       EEXP = DLOG(RMAX/RNUC(IZ))/DFLOAT(NEXP)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE ELECTRIC FIELD OVERLAP MATRICES (ONE-CENTRE ONLY)       C
! C**********************************************************************C
! C
! C     REASONS THAT QUADRATURE IS NOT NECESSARY
!       IF(IZ.NE.ICNTA.OR.IZ.NE.ICNTB) GOTO 3500
!       IF(NMDL(IZ).EQ.'POINT'.OR.NMDL(IZ).EQ.'GAUSS') GOTO 3500
! C
! C     CHEAT'S RECIPE: DUMP THE FULL INTEGRAL INTO THE IX= CASE
!       IF(IX.NE.1) GOTO 3600
! C
! C     ATOM-CENTRED SELECTION RULES
!       IF(KQN(1).NE.KQN(2)) GOTO 3600
!       IF(MQN(1).NE.MQN(2)) GOTO 3600
! C
! C     KQN+LQN+1 IN EACH CASE
!       T1 = DFLOAT(KQN(1)+LQN(1)+1)
!       T2 = DFLOAT(KQN(2)+LQN(2)+1)
! C
! C     SMOOSH BASIS FUNCTION DETAILS INTO APPROPRIATE ARRAYS
!       LQ2(1) = LQN(1)
!       LQ2(2) = LQN(2)
!       NBS2(1) = NBAS(1)
!       NBS2(2) = NBAS(2)
!       DO IBAS=1,NBS2(1)
!         EX2(IBAS,1) = EXL(IBAS,1)
!       ENDDO
!       DO JBAS=1,NBS2(2)
!         EX2(JBAS,2) = EXL(JBAS,2)
!       ENDDO
      
! C     RADIAL NORMALISATION FACTORS
!       CALL RNORM1(RNTT,EX2,LQ2,NBS2,ITT)
! C
! C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
!       DO IBAS=1,NBAS(1)
!         EI = EXL(IBAS,1)
!         DO JBAS=1,NBAS(2)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         NUMERICALLY INTEGRATE (LINEAR GRID) FROM 0 TO RNUC
!           XTT = 0.0D0
!           DO N=0,NLIN
!             RI  = ELIN*DFLOAT(N)
! C           RADIAL FUNCTION FOR EXPONENT EI (FACTOR OF RI MISSING)
!             IF(ITT.EQ.1.OR.ITT.EQ.2) THEN
!               RT1 = RI**(LQN(1)  )
!             ELSEIF(ITT.EQ.3.OR.ITT.EQ.4) THEN
!               IF(KQN(1).LT.0) THEN
!                 RT1 = RI**(LQN(1)  )*(  -2.0D0*EI*RI   )
!               ELSEIF(KQN(1).GT.0) THEN
!                 RT1 = RI**(LQN(1)-1)*(T1-2.0D0*EI*RI*RI)
!               ENDIF
!             ENDIF
! C           RADIAL FUNCTION FOR EXPONENT EJ (FACTOR OF RI MISSING)
!             IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
!               RT2 = RI**(LQN(2)  )
!             ELSEIF(ITT.EQ.2.OR.ITT.EQ.4) THEN
!               IF(KQN(2).LT.0) THEN
!                 RT2 = RI**(LQN(2)  )*(  -2.0D0*EJ*RI   )
!               ELSEIF(KQN(2).GT.0) THEN
!                 RT2 = RI**(LQN(2)-1)*(T2-2.0D0*EJ*RI*RI)
!               ENDIF
!             ENDIF
!             RSM = DEXP(-EIJ*RI*RI)
!             EZR = ERNUCDNS(NMDL(IZ),IZ,RI)
!             XTT = XTT + EXTINT11(RT1*RT2*RSM*EZR,N,NLIN)
!           ENDDO
! C         NUMERICALLY INTEGRATE (EXPONENTIAL GRID) FROM RNUC TO RMAX
!           YTT = 0.0D0
!           DO N=0,NEXP
!             TI  = EEXP*DFLOAT(N)
!             RI  = RNUC(IZ)*DEXP(TI)
! C           RADIAL FUNCTION FOR EXPONENT EI (FACTOR OF RI MISSING)
!             IF(ITT.EQ.1.OR.ITT.EQ.2) THEN
!               RT1 = RI**(LQN(1)  )
!             ELSEIF(ITT.EQ.3.OR.ITT.EQ.4) THEN
!               IF(KQN(1).LT.0) THEN
!                 RT1 = RI**(LQN(1)  )*(  -2.0D0*EI*RI   )
!               ELSEIF(KQN(1).GT.0) THEN
!                 RT1 = RI**(LQN(1)-1)*(T1-2.0D0*EI*RI*RI)
!               ENDIF
!             ENDIF
! C           RADIAL FUNCTION FOR EXPONENT EJ (FACTOR OF RI MISSING)
!             IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
!               RT2 = RI**(LQN(2)  )
!             ELSEIF(ITT.EQ.2.OR.ITT.EQ.4) THEN
!               IF(KQN(2).LT.0) THEN
!                 RT2 = RI**(LQN(2)  )*(  -2.0D0*EJ*RI   )
!               ELSEIF(KQN(2).GT.0) THEN
!                 RT2 = RI**(LQN(2)-1)*(T2-2.0D0*EJ*RI*RI)
!               ENDIF
!             ENDIF
!             RSM = RI*DEXP(-EIJ*RI*RI)
!             EZR = ERNUCDNS(NMDL(IZ),IZ,RI)
!             YTT = YTT + EXTINT11(RT1*RT2*RSM*EZR,N,NEXP)
!           ENDDO
!           UTT =-5.0D0*RNTT(IBAS,JBAS)*(ELIN*XTT + EEXP*YTT)/299376.0D0
! C
! C         CONTRIBUTION TO MOLECULAR MATRIX ELEMENT
!           VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + UTT
!           VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + UTT
! C
!         ENDDO
!       ENDDO
! C
! C     BATCH FINISHED
!       GOTO 3600
! C
! C     CONTINUATION POINT FOR MANY-CENTRE MATRIX ELEMENTS
! 3500  CONTINUE
! C
! C**********************************************************************C
! C     GENERATE ELECTRIC FIELD OVERLAP MATRICES (MANY-CENTRE/ANALYTIC)  C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VNCELEC: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VNCELEC: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     NUCLEAR COORDINATES
!       CX = BXYZ(1,IZ)
!       CY = BXYZ(2,IZ)
!       CZ = BXYZ(3,IZ)
! C
! C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M   = M+1
!           EIJ = EXL(IBAS,1)+EXL(JBAS,2)
!           PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
!           PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
!           PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
!           CP(M,1) = CX-PX
!           CP(M,2) = CY-PY
!           CP(M,3) = CZ-PZ
!         ENDDO
!       ENDDO
! C
!       IF(NMDL(IZ).EQ.'POINT') THEN
! C     POINT-NUCLEUS APPROXIMATION
! C
! C       PREPARE ELEMENTS FOR RMAKE
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           POINT-NUCLEUS EFFECTIVE PARAMETERS
!             EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!             APH(M) = EIJ
!             PNC(M) = 2.0D0*PI/EIJ
! C
!           ENDDO
!         ENDDO
! C
! C       GENERATE A BATCH OF R-INTEGRALS
!         CALL CPU_TIME(TDM1)
!         CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
!         CALL CPU_TIME(TDM2)
! C
! C       ADD TO RELEVANT TIME COUNTER
!         IF(ITT.EQ.1) THEN
!           TRLL = TRLL+TDM2-TDM1
!         ELSEIF(ITT.EQ.2) THEN
!           TRLS = TRLS+TDM2-TDM1
!         ELSEIF(ITT.EQ.3) THEN
!           TRSL = TRSL+TDM2-TDM1
!         ELSEIF(ITT.EQ.4) THEN
!           TRSS = TRSS+TDM2-TDM1
!         ENDIF
! C
! C       NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ELL0 AND RC)
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           INITIALISE SUM COUNTERS FOR FINITE EXPANSION
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C           LOOP OVER FINITE EXPANSION ADDRESSES
!             DO ITUV=1,NTUV
! C
! C             PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
!               IT = IA(ITUV)
!               IU = IB(ITUV)
!               IV = IC(ITUV)
! C
! C             ADD CARTESTIAN COMPONENT IX TO OVERALL ADDRESS (R-INTS)
!               ITV1 = IABC(IT+IVCT(1),IU+IVCT(2),IV+IVCT(3))
! C
! C             DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
!               TA1 = TA1 - E11(M,ITUV)*RC(M,ITV1)
!               TA2 = TA2 - E21(M,ITUV)*RC(M,ITV1)
! C
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = PHTT*PNC(M)*TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = PHTT*PNC(M)*TA2
!             VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!             VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!           ENDDO
!         ENDDO
! C
!       ELSE
! C     FINITE NUCLEAR CHARGE DISTRIBUTIONS
! C
! C       GAUSSIAN CHARGE MODEL COMPONENTS
!         XI = XNUC(IZ,0)
!         FC = FNUC(IZ,0)
! C
! C       PREPARE ELEMENTS FOR RMAKE
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
!             EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!             ESM    = EIJ+XI
!             APH(M) = EIJ*XI/ESM
!             PNC(M) = 2.0D0*PI*FC*DSQRT(XI/ESM)/EIJ
! C
!           ENDDO
!         ENDDO
! C
! C       GENERATE A BATCH OF R-INTEGRALS
!         CALL CPU_TIME(TDM1)
!         CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
!         CALL CPU_TIME(TDM2)
! C
! C       ADD TO RELEVANT TIME COUNTER
!         IF(ITT.EQ.1) THEN
!           TRLL = TRLL+TDM2-TDM1
!         ELSEIF(ITT.EQ.2) THEN
!           TRLS = TRLS+TDM2-TDM1
!         ELSEIF(ITT.EQ.3) THEN
!           TRSL = TRSL+TDM2-TDM1
!         ELSEIF(ITT.EQ.4) THEN
!           TRSS = TRSS+TDM2-TDM1
!         ENDIF
! C
! C       NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ELL0 AND RC)
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           INITIALISE SUM COUNTERS FOR FINITE EXPANSION
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C           LOOP OVER FINITE EXPANSION ADDRESSES
!             DO ITUV=1,NTUV
! C
! C             PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
!               IT = IA(ITUV)
!               IU = IB(ITUV)
!               IV = IC(ITUV)
! C
! C             CARTESTIAN ADDERSS OF THIS R-INT TERM
!               ITV1 = IABC(IT+IVCT(1),IU+IVCT(2),IV+IVCT(3))
! C
! C             DETERMINE FINITE SUM FOR THIS MATRIX ELEMENT
!               TA1 = TA1 - E11(M,ITUV)*RC(M,ITV1)
!               TA2 = TA2 - E21(M,ITUV)*RC(M,ITV1)
! C
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS)
!      &                                              + PHTT*PNC(M)*TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS)
!      &                                              + PHTT*PNC(M)*TA2
! C
!           ENDDO
!         ENDDO
! C
! C       LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
!         IF(NNUC(IZ).LE.0) GOTO 100
!         DO IFT=1,NNUC(IZ)
! C
! C         GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
!           XI = XNUC(IZ,IFT)
!           FC = FNUC(IZ,IFT)
! C
! C         INCLUDE NUCLEAR EXPONENT
!           ESM = EIJ+XI
!           ECP = EIJ*XI/ESM
! C
! C         GAUSSIAN COMPONENT OF HGTF
!           GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
! C
! C         INITIALISE TEMPORARY STORAGE ARRAYS
!           TA1 = DCMPLX(0.0D0,0.0D0)
!           TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER ALL {A,B,C}
!           DO ITUV=1,NTUV
! C
! C           CARTESIAN HERMITE POLYNOMIAL VALUES
!             HALPH = HERMITE(ECP,RPX,IA(ITUV)+IVCT(1))
!             HBETA = HERMITE(ECP,RPY,IB(ITUV)+IVCT(2))
!             HGAMA = HERMITE(ECP,RPZ,IC(ITUV)+IVCT(3))
! C
! C           HGTF IS A PRODUCT OF THESE
!             HABC = HALPH*HBETA*HGAMA*GSS
! C
! C           MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
!             TA1 = TA1 + FC*E11(M,ITUV)*HABC
!             TA2 = TA2 + FC*E21(M,ITUV)*HABC
! C
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + PHTT*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + PHTT*TA2
! C
!         ENDDO
! 100     CONTINUE
! C
! C       FINISH MATRIX ELEMENT CONSTRUCTION BY MQN SYMMETRY
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!             VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
!           ENDDO
!         ENDDO
! C
!       ENDIF
! C
! 3600  CONTINUE
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VDIPOLE(VIJ,CLOC,DLOC,ITT,IQ,IX,JX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C       VV    VV DDDDDDD IIII PPPPPPP   OOOOOO  LL      EEEEEEEE       C
! C       VV    VV DD    DD II  PP    PP OO    OO LL      EE             C
! C       VV    VV DD    DD II  PP    PP OO    OO LL      EE             C
! C       VV    VV DD    DD II  PP    PP OO    OO LL      EEEEEE         C
! C        VV  VV  DD    DD II  PPPPPPP  OO    OO LL      EE             C
! C         VVVV   DD    DD II  PP       OO    OO LL      EE             C
! C          VV    DDDDDDD IIII PP        OOOOOO  LLLLLLL EEEEEEEE       C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VDIPOLE CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X'.X/R^3|ν,T') FIELD        C
! C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATES X AND X'.  C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ CLOC    = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                  C
! C  ▶ DLOC    = LOCAL ORIGIN FOR FIRST MOMENT FIELD POINT.              C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC (FIELD).  C
! C  ▶ JX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR DLOC (MOMENT). C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION CLOC(3),DLOC(3),IVCT(3),JVCT(3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),PD(MB2,3),APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     TURN IX AND JX INTO VECTORS
!       CALL NCART(IVCT,IX)
!       CALL NCART(JVCT,JX)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VDIPOLE: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VDIPOLE: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT CLOC
!           CP(M,1) = CLOC(1)-PX
!           CP(M,2) = CLOC(2)-PY
!           CP(M,3) = CLOC(3)-PZ
! C
! C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
!           PD(M,1) = PX-DLOC(1)
!           PD(M,2) = PY-DLOC(2)
!           PD(M,3) = PZ-DLOC(3)
! C
! C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
!           APH(M) = EIJ
!           PNC(M) = 2.0D0*PI/EIJ
! C
!         ENDDO
!       ENDDO
! C
! C     GENERATE A BATCH OF R-INTEGRALS (ADD TWO TO SUM ORDER)
!       CALL CPU_TIME(TDM1)
!       CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+2)
!       CALL CPU_TIME(TDM2)
! C
! C     ADD TO RELEVANT TIME COUNTER
!       IF(ITT.EQ.1) THEN
!         TRLL = TRLL+TDM2-TDM1
!       ELSEIF(ITT.EQ.2) THEN
!         TRLS = TRLS+TDM2-TDM1
!       ELSEIF(ITT.EQ.3) THEN
!         TRSL = TRSL+TDM2-TDM1
!       ELSEIF(ITT.EQ.4) THEN
!         TRSS = TRSS+TDM2-TDM1
!       ENDIF
! C
! C     ELECTRIC FIELD MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
!           TA1 = DCMPLX(0.0D0,0.0D0)
!           TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FINITE EXPANSION ADDRESSES
!           DO ITUV=1,NTUV
! C
! C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
!             IT = IA(ITUV)
!             IU = IB(ITUV)
!             IV = IC(ITUV)
! C
! C           FIRST TERM
!             IT1 = IT+IVCT(1)+JVCT(1)
!             IU1 = IU+IVCT(2)+JVCT(2)
!             IV1 = IV+IVCT(3)+JVCT(3)
!             R1  = 0.5D0*RC(M,IABC(IT1,IU1,IV1))/APH(M)
! C
! C           SECOND TERM
!             IT2 = IT+IVCT(1)
!             IU2 = IU+IVCT(2)
!             IV2 = IV+IVCT(3)
!             R2  = PD(M,JX)*RC(M,IABC(IT2,IU2,IV2))
! C
! C           THIRD TERM
!             IT3 = IT+IVCT(1)-JVCT(1)
!             IU3 = IU+IVCT(2)-JVCT(2)
!             IV3 = IV+IVCT(3)-JVCT(3)
!             IF(IT3.GE.0.AND.IU3.GE.0.AND.IV3.GE.0) THEN
!               ID3 = IT*JVCT(1) + IU*JVCT(2) + IV*JVCT(3)
!               R3  = DFLOAT(ID3)*RC(M,IABC(IT3,IU3,IV3))
!             ELSE
!               R3  = 0.0D0
!             ENDIF
! C
! C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
!             TA1 = TA1 - E11(M,ITUV)*(R1+R2+R3)
!             TA2 = TA2 - E21(M,ITUV)*(R1+R2+R3)
! C
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE VSETGTN(VX,VY,VZ,ZORI,IQ,IX)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     VV    VV  SSSSSS  EEEEEEEE TTTTTTTT GGGGGG TTTTTTTT NN    NN     C
! C     VV    VV SS    SS EE          TT   GG    GG   TT    NNN   NN     C
! C     VV    VV SS       EE          TT   GG         TT    NNNN  NN     C
! C     VV    VV  SSSSSS  EEEEEE      TT   GG         TT    NN NN NN     C
! C      VV  VV        SS EE          TT   GG   GGG   TT    NN  NNNN     C
! C       VVVV   SS    SS EE          TT   GG    GG   TT    NN   NNN     C
! C        VV     SSSSSS  EEEEEEEE    TT    GGGGGG    TT    NN    NN     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VSETGTN IS A MODIFIED VERSION OF VDIPOLE FOR USE IN THE GTENSOR     C
! C  ROUTINE. IT CONSTRUCTS (μ,T|σ_Q.X'.X/R^3|ν,T') FOR IQ, IX, THE      C
! C  NUCLEAR ORIGIN ZORI, AND THE FULL SET JX = {X,Y,Z}.                 C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ ZORI  = LOCATION OF NUCLEUS (ORIGIN OF JX MOMENT).                C
! C  ▶ IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.             C
! C  ▶ IX    = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR FIELD TERM.      C
! C  OUTPUT:                                                             C
! C  ▶ VX - FULL MATRIX OF ELEMENTS WITH JX = X.                         C
! C  ▶ VY - FULL MATRIX OF ELEMENTS WITH JX = Y.                         C
! C  ▶ VZ - FULL MATRIX OF ELEMENTS WITH JX = Z.                         C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION ZORI(3),IVCT(3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),PD(MB2,3),APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 TXLS1,TXLS2,TYLS1,TYLS2,TZLS1,TZLS2
!       COMPLEX*16 TXSL1,TXSL2,TYSL1,TYSL2,TZSL1,TZSL2
!       COMPLEX*16 ELS11(MB2,MEQ),ELS21(MB2,MEQ)
!       COMPLEX*16 ESL11(MB2,MEQ),ESL21(MB2,MEQ)
!       COMPLEX*16 VX(MDM,MDM),VY(MDM,MDM),VZ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE MATRIX ELEMENT ARRAYS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VX(I,J) = DCMPLX(0.0D0,0.0D0)
!           VY(I,J) = DCMPLX(0.0D0,0.0D0)
!           VZ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     TURN IX INTO A VECTOR
!       CALL NCART(IVCT,IX)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDER FOR SL/LS OVERLAP
!       LAM = LQN(1)+LQN(2)+1
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       CALL CPU_TIME(TDM1)
!       CALL EQLSMK(ELS11,ELS21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,IQ)
!       CALL CPU_TIME(TDM2)
!       TELS = TELS+TDM2-TDM1
! C
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       CALL CPU_TIME(TDM1)
!       CALL EQSLMK(ESL11,ESL21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,IQ)
!       CALL CPU_TIME(TDM2)
!       TESL = TESL+TDM2-TDM1
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1)+EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1)+EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1)+EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT
!           CP(M,1) = ZORI(1)-PX
!           CP(M,2) = ZORI(2)-PY
!           CP(M,3) = ZORI(3)-PZ
! C
! C         RELATIVE COORDINATES OF MOMENT ORIGIN (ZERO HERE)
!           PD(M,1) = PX
!           PD(M,2) = PY
!           PD(M,3) = PZ
! C
! C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
!           APH(M) = EIJ
!           PNC(M) = 2.0D0*PI/EIJ
! C
!         ENDDO
!       ENDDO
! C
! C     GENERATE A BATCH OF R-INTEGRALS (ADD TWO TO SUM ORDER)
!       CALL CPU_TIME(TDM1)
!       CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+2)
!       CALL CPU_TIME(TDM2)
! C
! C     ADD TO RELEVANT TIME COUNTER
!       TRLS = TRLS + 0.5D0*(TDM2-TDM1)
!       TRSL = TRSL + 0.5D0*(TDM2-TDM1)
! C
! C     ELECTRIC FIELD MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
!           TXLS1 = DCMPLX(0.0D0,0.0D0)
!           TXLS2 = DCMPLX(0.0D0,0.0D0)
!           TYLS1 = DCMPLX(0.0D0,0.0D0)
!           TYLS2 = DCMPLX(0.0D0,0.0D0)
!           TZLS1 = DCMPLX(0.0D0,0.0D0)
!           TZLS2 = DCMPLX(0.0D0,0.0D0)
!           TXSL1 = DCMPLX(0.0D0,0.0D0)
!           TXSL2 = DCMPLX(0.0D0,0.0D0)
!           TYSL1 = DCMPLX(0.0D0,0.0D0)
!           TYSL2 = DCMPLX(0.0D0,0.0D0)
!           TZSL1 = DCMPLX(0.0D0,0.0D0)
!           TZSL2 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FINITE EXPANSION ADDRESSES
!           DO ITUV=1,NTUV
! C
! C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
!             IT = IA(ITUV)
!             IU = IB(ITUV)
!             IV = IC(ITUV)
! C
! C           ELECTRIC FIELD OFFSET
!             IT1 = IT+IVCT(1)
!             IU1 = IU+IVCT(2)
!             IV1 = IV+IVCT(3)
! C
! C           FIRST TERM
!             R1X = 0.5D0*RC(M,IABC(IT1+1,IU1  ,IV1  ))/APH(M)
!             R1Y = 0.5D0*RC(M,IABC(IT1  ,IU1+1,IV1  ))/APH(M)
!             R1Z = 0.5D0*RC(M,IABC(IT1  ,IU1  ,IV1+1))/APH(M)
! C
! C           SECOND TERM
!             R2X = PD(M,1)*RC(M,IABC(IT1  ,IU1  ,IV1  ))
!             R2Y = PD(M,2)*RC(M,IABC(IT1  ,IU1  ,IV1  ))
!             R2Z = PD(M,3)*RC(M,IABC(IT1  ,IU1  ,IV1  ))
! C
! C           THIRD TERM
!             IF(IT1.GE.0.AND.IU1.GE.0.AND.IV1.GE.0) THEN
!               R3X  = DFLOAT(IT)*RC(M,IABC(IT1-1,IU1  ,IV1  ))
!             ELSE
!               R3X  = 0.0D0
!             ENDIF
!             IF(IT1.GE.0.AND.IU1.GE.0.AND.IV1.GE.0) THEN
!               R3Y  = DFLOAT(IU)*RC(M,IABC(IT1  ,IU1-1,IV1  ))
!             ELSE
!               R3Y  = 0.0D0
!             ENDIF
!             IF(IT1.GE.0.AND.IU1.GE.0.AND.IV1.GE.0) THEN
!               R3Z  = DFLOAT(IV)*RC(M,IABC(IT1  ,IU1  ,IV1-1))
!             ELSE
!               R3Z  = 0.0D0
!             ENDIF
! C
! C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
!             TXLS1 = TXLS1 - ELS11(M,ITUV)*(R1X+R2X+R3X)
!             TXLS2 = TXLS2 - ELS21(M,ITUV)*(R1X+R2X+R3X)
!             TYLS1 = TYLS1 - ELS11(M,ITUV)*(R1Y+R2Y+R3Y)
!             TYLS2 = TYLS2 - ELS21(M,ITUV)*(R1Y+R2Y+R3Y)
!             TZLS1 = TZLS1 - ELS11(M,ITUV)*(R1Z+R2Z+R3Z)
!             TZLS2 = TZLS2 - ELS21(M,ITUV)*(R1Z+R2Z+R3Z)
! C
!             TXSL1 = TXSL1 - ESL11(M,ITUV)*(R1X+R2X+R3X)
!             TXSL2 = TXSL2 - ESL21(M,ITUV)*(R1X+R2X+R3X)
!             TYSL1 = TYSL1 - ESL11(M,ITUV)*(R1Y+R2Y+R3Y)
!             TYSL2 = TYSL2 - ESL21(M,ITUV)*(R1Y+R2Y+R3Y)
!             TZSL1 = TZSL1 - ESL11(M,ITUV)*(R1Z+R2Z+R3Z)
!             TZSL2 = TZSL2 - ESL21(M,ITUV)*(R1Z+R2Z+R3Z)
! C
!           ENDDO
! C
! C         SMALL-COMPONENT ADDRESSES
!           KBAS = IBAS+NSKP
!           LBAS = JBAS+NSKP
! C
! C         MATRIX ELEMENTS
!           VX(NA1+IBAS,NB1+LBAS) = PNC(M)*TXLS1
!           VX(NA2+IBAS,NB1+LBAS) = PNC(M)*TXLS2
!           VX(NA1+IBAS,NB2+LBAS) =-PHS*DCONJG(VX(NA2+IBAS,NB1+LBAS))
!           VX(NA2+IBAS,NB2+LBAS) = PHS*DCONJG(VX(NA1+IBAS,NB1+LBAS))
! C
!           VY(NA1+IBAS,NB1+LBAS) = PNC(M)*TYLS1
!           VY(NA2+IBAS,NB1+LBAS) = PNC(M)*TYLS2
!           VY(NA1+IBAS,NB2+LBAS) =-PHS*DCONJG(VY(NA2+IBAS,NB1+LBAS))
!           VY(NA2+IBAS,NB2+LBAS) = PHS*DCONJG(VY(NA1+IBAS,NB1+LBAS))
! C
!           VZ(NA1+IBAS,NB1+LBAS) = PNC(M)*TZLS1
!           VZ(NA2+IBAS,NB1+LBAS) = PNC(M)*TZLS2
!           VZ(NA1+IBAS,NB2+LBAS) =-PHS*DCONJG(VZ(NA2+IBAS,NB1+LBAS))
!           VZ(NA2+IBAS,NB2+LBAS) = PHS*DCONJG(VZ(NA1+IBAS,NB1+LBAS))
! C
!           VX(NA1+KBAS,NB1+JBAS) = PNC(M)*TXSL1
!           VX(NA2+KBAS,NB1+JBAS) = PNC(M)*TXSL2
!           VX(NA1+KBAS,NB2+JBAS) =-PHS*DCONJG(VX(NA2+KBAS,NB1+JBAS))
!           VX(NA2+KBAS,NB2+JBAS) = PHS*DCONJG(VX(NA1+KBAS,NB1+JBAS))
! C
!           VY(NA1+KBAS,NB1+JBAS) = PNC(M)*TYSL1
!           VY(NA2+KBAS,NB1+JBAS) = PNC(M)*TYSL2
!           VY(NA1+KBAS,NB2+JBAS) =-PHS*DCONJG(VY(NA2+KBAS,NB1+JBAS))
!           VY(NA2+KBAS,NB2+JBAS) = PHS*DCONJG(VY(NA1+KBAS,NB1+JBAS))
! C
!           VZ(NA1+KBAS,NB1+JBAS) = PNC(M)*TZSL1
!           VZ(NA2+KBAS,NB1+JBAS) = PNC(M)*TZSL2
!           VZ(NA1+KBAS,NB2+JBAS) =-PHS*DCONJG(VZ(NA2+KBAS,NB1+JBAS))
!           VZ(NA2+KBAS,NB2+JBAS) = PHS*DCONJG(VZ(NA1+KBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! C
! C     MULTIPLY EQLS COEFFICIENTS BY +i AND EQSL COEFFICIENTS BY -i
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VX(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
!           VY(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
!           VZ(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
!           VX(I+NSKP,J     ) = CONE*VX(I+NSKP,J     )
!           VY(I+NSKP,J     ) = CONE*VY(I+NSKP,J     )
!           VZ(I+NSKP,J     ) = CONE*VZ(I+NSKP,J     )
!           VX(I     ,J+NSKP) =-CONE*VX(I     ,J+NSKP)
!           VY(I     ,J+NSKP) =-CONE*VY(I     ,J+NSKP)
!           VZ(I     ,J+NSKP) =-CONE*VZ(I     ,J+NSKP)
!           VX(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)
!           VY(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)        
!           VZ(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)        
!         ENDDO
!       ENDDO
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VQDPOLE(VIJ,CLOC,DLOC,ELOC,ITT,IQ,IX,JX,KX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   VV    VV   QQQQQQ    DDDDDDD  PPPPPPP   OOOOOO  LL      EEEEEEEE   C
! C   VV    VV  QQ    QQ   DD    DD PP    PP OO    OO LL      EE         C
! C   VV    VV QQ      QQ  DD    DD PP    PP OO    OO LL      EE         C
! C   VV    VV QQ      QQ  DD    DD PP    PP OO    OO LL      EEEEEE     C
! C    VV  VV  QQ      QQ  DD    DD PPPPPPP  OO    OO LL      EE         C
! C     VVVV    QQ    QQ   DD    DD PP       OO    OO LL      EE         C
! C      VV      QQQQQQ QQ DDDDDDD  PP        OOOOOO  LLLLLLL EEEEEEEE   C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VQDPOLE CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X'.X''.X/R^3|ν,T') FIELD    C
! C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDS X, X' AND X''.  C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ CLOC    = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                  C
! C  ▶ DLOC    = LOCAL ORIGIN FOR SECOND MOMENT FIELD POINT (PART 1).    C
! C  ▶ ELOC    = LOCAL ORIGIN FOR SECOND MOMENT FIELD POINT (PART 2).    C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC (FIELD).  C
! C  ▶ JX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR DLOC (MOMENT). C
! C  ▶ KX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR ELOC (MOMENT). C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION CLOC(3),DLOC(3),ELOC(3),IVCT(3),JVCT(3),KVCT(3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),PD(MB2,3),PE(MB2,3)
!       DIMENSION APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     TURN IX, JX AND KX INTO VECTORS
!       CALL NCART(IVCT,IX)
!       CALL NCART(JVCT,JX)
!       CALL NCART(KVCT,KX)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VQDPOLE: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VQDPOLE: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT CLOC
!           CP(M,1) = CLOC(1)-PX
!           CP(M,2) = CLOC(2)-PY
!           CP(M,3) = CLOC(3)-PZ
! C
! C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
!           PD(M,1) = PX-DLOC(1)
!           PD(M,2) = PY-DLOC(2)
!           PD(M,3) = PZ-DLOC(3)
! C
! C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
!           PE(M,1) = PX-ELOC(1)
!           PE(M,2) = PY-ELOC(2)
!           PE(M,3) = PZ-ELOC(3)
! C
! C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
!           APH(M) = EIJ
!           PNC(M) = 2.0D0*PI/EIJ
! C
!         ENDDO
!       ENDDO
! C
! C     GENERATE A BATCH OF R-INTEGRALS (ADD THREE TO SUM ORDER)
!       CALL CPU_TIME(TDM1)
!       CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+3)
!       CALL CPU_TIME(TDM2)
! C
! C     ADD TO RELEVANT TIME COUNTER
!       IF(ITT.EQ.1) THEN
!         TRLL = TRLL+TDM2-TDM1
!       ELSEIF(ITT.EQ.2) THEN
!         TRLS = TRLS+TDM2-TDM1
!       ELSEIF(ITT.EQ.3) THEN
!         TRSL = TRSL+TDM2-TDM1
!       ELSEIF(ITT.EQ.4) THEN
!         TRSS = TRSS+TDM2-TDM1
!       ENDIF
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
!           TA1 = DCMPLX(0.0D0,0.0D0)
!           TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FINITE EXPANSION ADDRESSES
!           DO ITUV=1,NTUV
! C
! C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
!             IT = IA(ITUV)
!             IU = IB(ITUV)
!             IV = IC(ITUV)
! C
! C           FIRST TERM
!             IT1 = IT+IVCT(1)+JVCT(1)+KVCT(1)
!             IU1 = IU+IVCT(2)+JVCT(2)+KVCT(2)
!             IV1 = IV+IVCT(3)+JVCT(3)+KVCT(3)
!             R1  = 0.25D0*RC(M,IABC(IT1,IU1,IV1))/(APH(M)*APH(M))
! C
! C           SECOND TERM
!             IT2 = IT+IVCT(1)+JVCT(1)
!             IU2 = IU+IVCT(2)+JVCT(2)
!             IV2 = IV+IVCT(3)+JVCT(3)
!             R2  = 0.5D0*PE(M,KX)*RC(M,IABC(IT2,IU2,IV2))/APH(M)
! C
! C           THIRD TERM
!             IT3 = IT+IVCT(1)+JVCT(1)-KVCT(1)
!             IU3 = IU+IVCT(2)+JVCT(2)-KVCT(2)
!             IV3 = IV+IVCT(3)+JVCT(3)-KVCT(3)
!             IF(IT3.GT.0.AND.IU3.GT.0.AND.IV3.GT.0) THEN
!               ID3 = (IT+JVCT(1))*KVCT(1)+(IU+JVCT(2))*KVCT(2)
!      &                                  +(IV+JVCT(3))*KVCT(3)
!               R3  = 0.5D0*ID3*RC(M,IABC(IT3,IU3,IV3))/APH(M)
!             ELSE
!               R3  = 0.0D0
!             ENDIF
! C
! C           FOURTH TERM
!             IT4 = IT+IVCT(1)        +KVCT(1)
!             IU4 = IU+IVCT(2)        +KVCT(2)
!             IV4 = IV+IVCT(3)        +KVCT(3)
!             R4  = 0.5D0*PD(M,JX)*RC(M,IABC(IT4,IU4,IV4))/APH(M)
! C
! C           FIFTH TERM
!             IT5 = IT+IVCT(1)
!             IU5 = IU+IVCT(2)
!             IV5 = IV+IVCT(3)
!             R5  = PD(M,JX)*PE(M,KX)*RC(M,IABC(IT5,IU5,IV5))
! C
! C           SIXTH TERM
!             IT6 = IT+IVCT(1)-KVCT(1)
!             IU6 = IU+IVCT(2)-KVCT(2)
!             IV6 = IV+IVCT(3)-KVCT(3)
!             IF(IT6.GT.0.AND.IU6.GT.0.AND.IV6.GT.0) THEN
!               ID6 = IT*KVCT(1)+IU*KVCT(2)+IV*KVCT(3)
!               R6  = ID6*PD(M,JX)*RC(M,IABC(IT6,IU6,IV6))
!             ELSE
!               R6  = 0.0D0
!             ENDIF
! C
! C           SEVENTH TERM
!             IT7 = IT+IVCT(1)-JVCT(1)+KVCT(1)
!             IU7 = IU+IVCT(2)-JVCT(2)+KVCT(2)
!             IV7 = IV+IVCT(3)-JVCT(3)+KVCT(3)
!             IF(IT7.GT.0.AND.IU7.GT.0.AND.IV7.GT.0) THEN
!               ID7 = IT*JVCT(1)+IU*JVCT(2)+IV*JVCT(3)
!               R7  = 0.5D0*ID7*RC(M,IABC(IT7,IU7,IV7))/APH(M)
!             ELSE
!               R7  = 0.0D0
!             ENDIF
! C
! C           EIGHTH TERM
!             IT8 = IT+IVCT(1)-JVCT(1)
!             IU8 = IU+IVCT(2)-JVCT(2)
!             IV8 = IV+IVCT(3)-JVCT(3)
!             IF(IT8.GT.0.AND.IU8.GT.0.AND.IV8.GT.0) THEN
!               ID8 = IT*JVCT(1)+IU*JVCT(2)+IV*JVCT(3)
!               R8  = ID8*PE(M,KX)*RC(M,IABC(IT8,IU8,IV8))
!             ELSE
!               R8  = 0.0D0
!             ENDIF
! C
! C           NINTH TERM
!             IT9 = IT+IVCT(1)-JVCT(1)-KVCT(1)
!             IU9 = IU+IVCT(2)-JVCT(2)-KVCT(2)
!             IV9 = IV+IVCT(3)-JVCT(3)-KVCT(3)
!             IF(IT9.GT.0.AND.IU9.GT.0.AND.IV9.GT.0) THEN
!               ID9 = IT*JVCT(1)+IU*JVCT(2)+IV*JVCT(3)
!               JD9 = (IT-JVCT(1))*KVCT(1)+(IU-JVCT(2))*KVCT(2)
!      &                                  +(IV-JVCT(3))*KVCT(3)
!               R9  = ID9*JD9*PE(M,KX)*RC(M,IABC(IT9,IU9,IV9))
!             ELSE
!               R9  = 0.0D0
!             ENDIF
! C
! C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
!             TA1 = TA1 - E11(M,ITUV)*(R1+R2+R3+R4+R5+R6+R7+R8+R9)
!             TA2 = TA2 - E21(M,ITUV)*(R1+R2+R3+R4+R5+R6+R7+R8+R9)
! C
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE VNCATRC(VIJ,ZEFF,IZ,ITT,IQ,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV NN    NN  CCCCCC     AA   TTTTTTTT RRRRRRR   CCCCCC      C
! C    VV    VV NNN   NN CC    CC   AAAA     TT    RR    RR CC    CC     C
! C    VV    VV NNNN  NN CC        AA  AA    TT    RR    RR CC           C
! C    VV    VV NN NN NN CC       AA    AA   TT    RR    RR CC           C
! C     VV  VV  NN  NNNN CC       AAAAAAAA   TT    RRRRRRR  CC           C
! C      VVVV   NN   NNN CC    CC AA    AA   TT    RR    RR CC    CC     C
! C       VV    NN    NN  CCCCCC  AA    AA   TT    RR    RR  CCCCCC      C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VNCATRC CONSTRUCTS A MATRIX OF (μ,T|V_nuc|ν,T') OVERLAP             C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C  NOTE: DOES NOT INCLUDE NUCLEAR CHARGE OF IZ -- APPLY EXTERNALLY.    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ      = NUCLEAR CENTRE OF INTEREST, AS LISTED IN INPUT FILE.    C
! C  ▶ ZEFF    = EFFECTIVE CHARGE OF NUCLEAR CENTRE IZ.                  C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT C_LOC
!           CP(M,1) = BXYZ(1,IZ)-PX
!           CP(M,2) = BXYZ(2,IZ)-PY
!           CP(M,3) = BXYZ(3,IZ)-PZ
! C
!         ENDDO
!       ENDDO
! C
!       IF(NMDL(IZ).EQ.'POINT') THEN
! C     POINT-NUCLEAR APPROXIMATION
! C
! C       PREPARE ELEMENTS FOR RMAKE
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           POINT-NUCLEUS EFFECTIVE PARAMETERS
!             EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!             APH(M) = EIJ
!             PNC(M) = 2.0D0*ZEFF*PI/EIJ
! C
!           ENDDO
!         ENDDO
! C
! C       GENERATE A BATCH OF R-INTEGRALS
!         CALL CPU_TIME(TDM1)
!         CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
!         CALL CPU_TIME(TDM2)
! C
! C       ADD TO RELEVANT TIME COUNTER
!         IF(ITT.EQ.1) THEN
!           TRLL = TRLL+TDM2-TDM1
!         ELSEIF(ITT.EQ.2) THEN
!           TRLS = TRLS+TDM2-TDM1
!         ELSEIF(ITT.EQ.3) THEN
!           TRSL = TRSL+TDM2-TDM1
!         ELSEIF(ITT.EQ.4) THEN
!           TRSS = TRSS+TDM2-TDM1
!         ENDIF
! C
! C       CALCULATE OVERLAP MATRIX ELEMENTS
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
!             DO ITUV=1,NTUV
!               TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
!               TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!             VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!           ENDDO
!         ENDDO
! C
!       ELSE
! C     BEST-FIT EXPANSION
! C
! C       GAUSSIAN NUCLEAR ATTRACTION
!         XI = XNUC(IZ,0)
!         FC = FNUC(IZ,0)
! C
! C       PREPARE ELEMENTS FOR RMAKE
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
!             EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!             ESM    = EIJ+XI
!             APH(M) = EIJ*XI/ESM
!             PNC(M) = 2.0D0*PI*ZEFF*FC*DSQRT(XI/ESM)/EIJ
! C
!           ENDDO
!         ENDDO
! C
! C       GENERATE A BATCH OF R-INTEGRALS
!         CALL CPU_TIME(TDM1)
!         CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
!         CALL CPU_TIME(TDM2)
! C
! C       ADD TO RELEVANT TIME COUNTER
!         IF(ITT.EQ.1) THEN
!           TRLL = TRLL+TDM2-TDM1
!         ELSEIF(ITT.EQ.2) THEN
!           TRLS = TRLS+TDM2-TDM1
!         ELSEIF(ITT.EQ.3) THEN
!           TRSL = TRSL+TDM2-TDM1
!         ELSEIF(ITT.EQ.4) THEN
!           TRSS = TRSS+TDM2-TDM1
!         ENDIF
! C
! C       NUCLEAR ATTRACTION INTEGRALS (FINITE SUM OF ETT0 AND RC)
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
!             DO ITUV=1,NTUV
!               TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
!               TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!             VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!           ENDDO
!         ENDDO
! C
! C       CORRECTION FUNCTIONS FOR DETAILED NUCLEI
!         IF(NNUC(IZ).LE.0) GOTO 100
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           EXPONENT COMBINATIONS
!             EIJ = EXL(IBAS,1)+EXL(JBAS,2)
! C
! C           GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!             PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
!             PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
!             PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
! C
! C           COORDINATES OF EVALUATION
!             RPX = PX-BXYZ(1,IZ)
!             RPY = PY-BXYZ(2,IZ)
!             RPZ = PZ-BXYZ(3,IZ)
!             RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
! C
! C           INITIALISE TEMPORARY STORAGE ARRAYS
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C           CORRECTION FUNCTIONS FOR DETAILED NUCLEI
!             DO IFT=1,NNUC(IZ)
! C
! C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
!               XI = XNUC(IZ,IFT)
!               FC = FNUC(IZ,IFT)
! C
! C             GAUSSIAN COMPONENT OF HGTF
!               ESM = EIJ+XI
!               ECP = EIJ*XI/ESM
!               GSS = DEXP(-ECP*RSQ)
!               AMP =-0.5D0*XI/PI
! C
! C             LOOP OVER ALL {A,B,C}
!               DO ITUV=1,NTUV
! C
! C               CARTESIAN HERMITE POLYNOMIAL VALUES
!                 HALPH = HERMITE(ECP,RPX,IA(ITUV))
!                 HBETA = HERMITE(ECP,RPY,IB(ITUV))
!                 HGAMA = HERMITE(ECP,RPZ,IC(ITUV))
! C
! C               HGTF IS A PRODUCT OF THESE
!                 HABC = HALPH*HBETA*HGAMA*GSS
! C
! C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
!                 TA1 = TA1 + ZEFF*FC*AMP*E11(M,ITUV)*HABC
!                 TA2 = TA2 + ZEFF*FC*AMP*E21(M,ITUV)*HABC
! C
!               ENDDO
! C
! C           END LOOP OVER NUCLEAR BASIS FOR IZ
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!             VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
! C         END LOOP OVER BASIS SET PAIR
!           ENDDO
!         ENDDO
! C
! 100     CONTINUE
! C            
!       ENDIF
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE VPTNCD0(VIJ,IZ,ITT,IQ,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV PPPPPPP TTTTTTTT NN    NN  CCCCCC  DDDDDDD   000000      C
! C    VV    VV PP    PP   TT    NNN   NN CC    CC DD    DD 00   000     C
! C    VV    VV PP    PP   TT    NNNN  NN CC       DD    DD 00  0000     C
! C    VV    VV PP    PP   TT    NN NN NN CC       DD    DD 00 00 00     C
! C     VV  VV  PPPPPPP    TT    NN  NNNN CC       DD    DD 0000  00     C
! C      VVVV   PP         TT    NN   NNN CC    CC DD    DD 000   00     C
! C       VV    PP         TT    NN    NN  CCCCCC  DDDDDDD   000000      C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VPTNCD0 CONSTRUCTS A MATRIX OF (μ,T|ϱ_nuc|ν,T') OVERLAP             C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS (FOR A POINT NUCLEUS ONLY, AND   C
! C  RESTRICTED TO A COMMON ATOMIC CENTRE), AND SAVES THE RESULT TO VIJ. C
! C -------------------------------------------------------------------- C
! C  COMPONENT TYPES ITT = {2,3} NOT AVAILABLE -- CAN BE EASILY ADDED.   C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       DIMENSION RNTT(MBS,MBS)
!       DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),MQN(2),NBAS(2)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/GAMA/GAMLOG(300),GAMHLF(300)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(IZ)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,IZ)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),IZ)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),IZ)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(IZ)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,IZ)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),IZ)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),IZ)
!         ENDDO
! C
! C     USEFUL INTERMEDIATE VALUES
!       RL1 = DFLOAT(LQN(1))
!       RL2 = DFLOAT(LQN(2))
!       TL1 = DFLOAT(2*LQN(1)+1)
!       TL2 = DFLOAT(2*LQN(2)+1)
! C
! C     SELECTION RULE FROM ANGULAR INTEGRALS
!       IF(ITT.EQ.1.AND.KQN(1).NE.KQN(2)) GOTO 2001
!       IF(ITT.EQ.4.AND.KQN(1).NE.KQN(2)) GOTO 2001
!       IF(ITT.EQ.2.AND.KQN(1).NE.-KQN(2)) GOTO 2001
!       IF(ITT.EQ.3.AND.KQN(1).NE.-KQN(2)) GOTO 2001
! C
! C     GENERATE RADIAL NORMALISATION CONSTANTS
!       CALL RNORM1(RNTT,EXL,LQN,NBAS,ITT)
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C     SELECTION RULE FROM ANGULAR INTEGRALS
!       IF(MA.NE.MB) GOTO 3001
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(IZ,KA,2*MA-1)
!       NA2 = LRGE(IZ,KA,2*MA  )
!       NB1 = LRGE(IZ,KB,2*MB-1)
!       NB2 = LRGE(IZ,KB,2*MB  )
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
!       M = 0
!       DO IBAS=1,NBAS(1)
!         EI = EXL(IBAS,1)
!         DO JBAS=1,NBAS(2)
!           M   = M+1
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
!           EPR = EI*EJ
!           T52 = RL1+2.5D0
!           E52 = EIJ**T52
! C
!           OTT = 0.0D0
! C
!           XI  = XNUC(IZ,0)
!           FC  = FNUC(IZ,0)
! C
!           XPR = XI*DSQRT(XI)/PI32
!           PES = XI+EIJ
!           RGN = XPR/(PES*DSQRT(PES))
!           XEL = PES**(LQN(1))
! C
!           IF(ITT.EQ.1) THEN
!             OTT = FNUC(IZ,0)*GSSINT0(LQN(1)  ,EIJ,XNUC(IZ,0))
!             IF(NNUC(IZ).GT.0) THEN
!               OTT = OTT + ZCDINT0(IZ,LQN(1)  ,EIJ)
!             ENDIF
!           ELSEIF(ITT.EQ.4) THEN
!             VSA = 4.0D0*EPR*GSSINT0(LQN(1)+1,EIJ,XNUC(IZ,0))
!             IF(KQN.LT.0) THEN
!               VSN = 0.0D0
!             ELSE
!               VSN = -2.0D0*EIJ*TL*GSSINT0(LQN(1)  ,EIJ,XNUC(IZ,0))
!     &                      +TL*TL*GSSINT0(LQN(1)-1,EIJ,XNUC(IZ,0))
!             ENDIF
!             OTT = FNUC(IZ,0)*(VSA+VSN)
!             IF(NNUC(IZ).GT.0) THEN
!               VSA = 4.0D0*EPR*ZCDINT0(IZ,LQN(1)+1,EIJ)
!               IF(KQN.LT.0) THEN
!                 VSN = 0.0D0
!               ELSE
!                 VSN = -2.0D0*EIJ*TL*ZCDINT0(IZ,LQN(1)  ,EIJ)
!     &                        +TL*TL*ZCDINT0(IZ,LQN(1)-1,EIJ)
!               ENDIF
!               OTT = OTT + VSA+VSN
!             ENDIF
!           ENDIF
! C
! C         TRANSFER INTO NUCLEAR OVERLAP MATRIX
!           VIJ(NA1+IBAS,NB1+JBAS) = RNTT(IBAS,JBAS)*OTT
!           VIJ(NA2+IBAS,NB2+JBAS) = RNTT(IBAS,JBAS)*OTT
! C
!         ENDDO
!       ENDDO
! C
! 3001  CONTINUE
! 3000  CONTINUE
! 2001  CONTINUE
! 2000  CONTINUE
! 1001  CONTINUE
! 1000  CONTINUE
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VPTNCD1(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      VV    VV PPPPPPP TTTTTTTT NN    NN  CCCCCC  DDDDDDD   11        C
! C      VV    VV PP    PP   TT    NNN   NN CC    CC DD    DD 111        C
! C      VV    VV PP    PP   TT    NNNN  NN CC       DD    DD  11        C
! C      VV    VV PP    PP   TT    NN NN NN CC       DD    DD  11        C
! C       VV  VV  PPPPPPP    TT    NN  NNNN CC       DD    DD  11        C
! C        VVVV   PP         TT    NN   NNN CC    CC DD    DD  11        C
! C         VV    PP         TT    NN    NN  CCCCCC  DDDDDDD  1111       C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VNCATRC CONSTRUCTS A MATRIX OF (μ,T|V_nuc|ν,T') OVERLAP             C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C  NOTE: DOES NOT INCLUDE NUCLEAR CHARGE OF IZ -- APPLY EXTERNALLY.    C
! C -------------------------------------------------------------------- C
! C  TODO: THIS IS UNFINISHED -- CURRENTLY JUST VNCATRC.                 C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ      = NUCLEAR CENTRE OF INTEREST, AS LISTED IN INPUT FILE.    C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VPTNCD1: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VPTNCD1: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT C_LOC
!           CP(M,1) = BXYZ(1,IZ)-PX
!           CP(M,2) = BXYZ(2,IZ)-PY
!           CP(M,3) = BXYZ(3,IZ)-PZ
! C
!         ENDDO
!       ENDDO
! C
! C     ** ASSUME JUST A GAUSSIAN NUCLEUS HERE **
!       XI = XNUC(IZ,0)
!       FC = FNUC(IZ,0)
! C
! C     PREPARE ELEMENTS FOR RMAKE
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER (ZEFF MISSING)
!           EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!           ESM    = EIJ+XI
!           APH(M) = EIJ*XI/ESM
!           PNC(M) = 2.0D0*PI*FC*DSQRT(XI/ESM)/EIJ
! C
! C         POINT-NUCLEUS OPTIONS (MUST MANUALLY SET NNUC(IZ=1) HERE)
! C         APH(M) = EIJ
! C         PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
! C
!         ENDDO
!       ENDDO
! C
! C     GENERATE A BATCH OF R-INTEGRALS
!       CALL CPU_TIME(TDM1)
!       CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
!       CALL CPU_TIME(TDM2)
! C
! C     ADD TO RELEVANT TIME COUNTER
!       IF(ITT.EQ.1) THEN
!         TRLL = TRLL+TDM2-TDM1
!       ELSEIF(ITT.EQ.2) THEN
!         TRLS = TRLS+TDM2-TDM1
!       ELSEIF(ITT.EQ.3) THEN
!         TRSL = TRSL+TDM2-TDM1
!       ELSEIF(ITT.EQ.4) THEN
!         TRSS = TRSS+TDM2-TDM1
!       ENDIF
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!           TA1 = DCMPLX(0.0D0,0.0D0)
!           TA2 = DCMPLX(0.0D0,0.0D0)
!           DO ITUV=1,NTUV
!             TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
!             TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!           VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!           VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE VPTNCD2(VIJ,IZ,ITT,IQ,IX,JX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV PPPPPPP TTTTTTTT NN    NN  CCCCCC  DDDDDDD   222222      C
! C    VV    VV PP    PP   TT    NNN   NN CC    CC DD    DD 22    22     C
! C    VV    VV PP    PP   TT    NNNN  NN CC       DD    DD       22     C
! C    VV    VV PP    PP   TT    NN NN NN CC       DD    DD     22       C
! C     VV  VV  PPPPPPP    TT    NN  NNNN CC       DD    DD   22         C
! C      VVVV   PP         TT    NN   NNN CC    CC DD    DD 22           C
! C       VV    PP         TT    NN    NN  CCCCCC  DDDDDDD  22222222     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VNCATRC CONSTRUCTS A MATRIX OF (μ,T|V_nuc|ν,T') OVERLAP             C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C  NOTE: DOES NOT INCLUDE NUCLEAR CHARGE OF IZ -- APPLY EXTERNALLY.    C
! C -------------------------------------------------------------------- C
! C  TODO: THIS IS UNFINISHED -- CURRENTLY JUST VNCATRC.                 C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ      = NUCLEAR CENTRE OF INTEREST, AS LISTED IN INPUT FILE.    C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT C_LOC
!           CP(M,1) = BXYZ(1,IZ)-PX
!           CP(M,2) = BXYZ(2,IZ)-PY
!           CP(M,3) = BXYZ(3,IZ)-PZ
! C
!         ENDDO
!       ENDDO
! C
!       IF(NMDL(IZ).EQ.'POINT') THEN
! C     POINT-NUCLEUS APPROXIMATION
! C
! C       PREPARE ELEMENTS FOR RMAKE
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           POINT-NUCLEUS EFFECTIVE PARAMETERS
!             EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!             APH(M) = EIJ
!             PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
! C
!           ENDDO
!         ENDDO
! C
! C       GENERATE A BATCH OF R-INTEGRALS
!         CALL CPU_TIME(TDM1)
!         CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
!         CALL CPU_TIME(TDM2)
! C
! C       ADD TO RELEVANT TIME COUNTER
!         IF(ITT.EQ.1) THEN
!           TRLL = TRLL+TDM2-TDM1
!         ELSEIF(ITT.EQ.2) THEN
!           TRLS = TRLS+TDM2-TDM1
!         ELSEIF(ITT.EQ.3) THEN
!           TRSL = TRSL+TDM2-TDM1
!         ELSEIF(ITT.EQ.4) THEN
!           TRSS = TRSS+TDM2-TDM1
!         ENDIF
! C
! C       CALCULATE OVERLAP MATRIX ELEMENTS
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
!             DO ITUV=1,NTUV
!               TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
!               TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!             VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!           ENDDO
!         ENDDO
! C
!       ELSE
! C
! C       ** ASSUME JUST A GAUSSIAN NUCLEUS HERE **
!         XI = XNUC(IZ,0)
!         FC = FNUC(IZ,0)
! C
! C       PREPARE ELEMENTS FOR RMAKE
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER (ZEFF MISSING)
!             EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!             ESM    = EIJ+XI
!             APH(M) = EIJ*XI/ESM
!             PNC(M) = 2.0D0*PI*FC*DSQRT(XI/ESM)/EIJ
! C
! C           POINT-NUCLEUS OPTIONS (MUST MANUALLY SET NNUC(IZ=1) HERE)
! C           APH(M) = EIJ
! C           PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
! C
!           ENDDO
!         ENDDO
! C
! C       GENERATE A BATCH OF R-INTEGRALS
!         CALL CPU_TIME(TDM1)
!         CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
!         CALL CPU_TIME(TDM2)
! C
! C       ADD TO RELEVANT TIME COUNTER
!         IF(ITT.EQ.1) THEN
!           TRLL = TRLL+TDM2-TDM1
!         ELSEIF(ITT.EQ.2) THEN
!           TRLS = TRLS+TDM2-TDM1
!         ELSEIF(ITT.EQ.3) THEN
!           TRSL = TRSL+TDM2-TDM1
!         ELSEIF(ITT.EQ.4) THEN
!           TRSS = TRSS+TDM2-TDM1
!         ENDIF
! C
! C       CALCULATE OVERLAP MATRIX ELEMENTS
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
!             DO ITUV=1,NTUV
!               TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
!               TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!             VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!           ENDDO
!         ENDDO
! C
!       ENDIF
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
      SUBROUTINE VNCOLAP(VIJ,IZ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   OOOOOO  LL          AA    PPPPPPP     C
C    VV    VV NNN   NN CC    CC OO    OO LL         AAAA   PP    PP    C
C    VV    VV NNNN  NN CC       OO    OO LL        AA  AA  PP    PP    C
C    VV    VV NN NN NN CC       OO    OO LL       AA    AA PP    PP    C
C     VV  VV  NN  NNNN CC       OO    OO LL       AAAAAAAA PPPPPPP     C
C      VVVV   NN   NNN CC    CC OO    OO LL       AA    AA PP          C
C       VV    NN    NN  CCCCCC   OOOOOO  LLLLLLLL AA    AA PP          C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCOLAP CONSTRUCTS A MATRIX OF (μ,T|ϱ_nuc|ν,T') OVERLAP             C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RNTT(MBS,MBS)
      DIMENSION EX2(MBS,2),LQ2(2),NBS2(2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     INTEGRATION GRID DETAILS
      NLIN = 6000
      RMAX = 6.0D0*RNUC(IZ)
      ELIN = RMAX/DFLOAT(NLIN)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE NUCLEAR OVERLAP MATRICES (ONE-CENTRE ONLY)              C
C**********************************************************************C
C
C     REASONS THAT QUADRATURE IS NOT NECESSARY
      GOTO 3500
      IF(IZ.NE.ICNTA.OR.IZ.NE.ICNTB) GOTO 3500
      IF(NMDL(IZ).EQ.'POINT'.OR.NMDL(IZ).EQ.'GAUSS') GOTO 3500
C
C     ATOM-CENTRED SELECTION RULES
      IF(KQN(1).NE.-KQN(2)) GOTO 3600
      IF(MQN(1).NE.MQN(2)) GOTO 3600
C
C     KQN+LQN+1 IN EACH CASE
      T1 = DFLOAT(KQN(1)+LQN(1)+1)
      T2 = DFLOAT(KQN(2)+LQN(2)+1)
C
C     SMOOSH BASIS FUNCTION DETAILS INTO APPROPRIATE ARRAYS
      LQ2(1) = LQN(1)
      NBS2(1) = NBAS(1)
      DO IBAS=1,NBS2(1)
        EX2(IBAS,1) = EXL(IBAS,1)
      ENDDO
C
      LQ2(2) = LQN(2)
      NBS2(2) = NBAS(2)
      DO JBAS=1,NBS2(2)
        EX2(JBAS,2) = EXL(JBAS,2)
      ENDDO
      
C     RADIAL NORMALISATION FACTORS
      CALL RNORM1(RNTT,EX2,LQ2,NBS2,ITT)
C
C     CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         EXPONENT AND NORMALISATION COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         NUMERICALLY INTEGRATE (LINEAR GRID) FROM 0 TO RNUC
          X0I = 0.0D0
          DO N=0,NLIN
            RI = ELIN*DFLOAT(N)
            IF(ITT.EQ.1) THEN
              RT1 = RI**(LQN(1)+1)
              RT2 = RI**(LQN(2)+1)
            ELSEIF(ITT.EQ.2) THEN
              RT1 = RI**(LQN(1)+1)
              RT2 = RI**(LQN(2)  )*(T2-2.0D0*EJ*RI*RI)
            ELSEIF(ITT.EQ.3) THEN
              RT1 = RI**(LQN(1)  )*(T1-2.0D0*EI*RI*RI)
              RT2 = RI**(LQN(2)+1)
            ELSEIF(ITT.EQ.4) THEN
              RT1 = RI**(LQN(1)  )*(T1-2.0D0*EI*RI*RI)
              RT2 = RI**(LQN(2)  )*(T2-2.0D0*EJ*RI*RI)
            ENDIF
            RSM = DEXP(-EIJ*RI*RI)
            PZR = RHONUC(NMDL(IZ),IZ,RI)
            X0I = X0I + EXTINT11(RT1*RT2*RSM*PZR,N,NLIN)
          ENDDO
          X0I = 5.0D0*ELIN*X0I/299376.0D0
C
          VIJ(NA1+IBAS,NB1+JBAS) = RNTT(IBAS,JBAS)*X0I
          VIJ(NA2+IBAS,NB2+JBAS) = RNTT(IBAS,JBAS)*X0I
C
        ENDDO
      ENDDO
C
C     BATCH FINISHED
      GOTO 3600
C
C     CONTINUATION POINT FOR MANY-CENTRE MATRIX ELEMENTS
3500  CONTINUE
C
C**********************************************************************C
C     GENERATE NUCLEAR OVERLAP MATRICES (MANY-CENTRE/ANALYTIC)         C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCOLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCOLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
      IF(NMDL(IZ).EQ.'POINT') THEN
C     POINT-NUCLEUS APPROXIMATION
C
C       CALCULATE OVERLAP MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EI  = EXL(IBAS,1)
            EJ  = EXL(JBAS,2)
            EIJ = EI+EJ
C
C           GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
            PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
            PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
            PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
C
C           GAUSSIAN COMPONENT OF HGTF
            GSS = DEXP(-EIJ*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C           INITIALISE TEMPORARY STORAGE ARRAYS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER ALL {A,B,C}
            DO ITUV=1,NTUV
C
C             CARTESIAN HERMITE POLYNOMIAL VALUES
              HA0 = HERMITE(EIJ,RPX,IA(ITUV))
              HB0 = HERMITE(EIJ,RPY,IB(ITUV))
              HC0 = HERMITE(EIJ,RPZ,IC(ITUV))
C
C             HGTF IS A PRODUCT OF THESE
              HABC = HA0*HB0*HC0*GSS
C
C             MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
              TA1 = TA1 + E11(M,ITUV)*HABC
              TA2 = TA2 + E21(M,ITUV)*HABC
C
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + TA2
C
C           OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
            VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
            VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
          ENDDO
        ENDDO
C
      ELSE
C
C       CALCULATE OVERLAP MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EI  = EXL(IBAS,1)
            EJ  = EXL(JBAS,2)
            EIJ = EI+EJ
C
C           GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
            PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
            PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
            PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
C
C           INITIALISE TEMPORARY STORAGE ARRAYS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           GAUSSIAN NUCLEAR CHARGE OVERLAP
            XI = XNUC(IZ,0)
            FC = FNUC(IZ,0)
C
C           INCLUDE NUCLEAR EXPONENT
            ESM = EIJ+XI
            ECP = EIJ*XI/ESM
            P12 = DSQRT(XI/ESM)
            P32 = P12*P12*P12
C
C           GAUSSIAN COMPONENT OF HGTF
            GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C           LOOP OVER ALL {A,B,C}
            DO ITUV=1,NTUV
C
C             CARTESIAN HERMITE POLYNOMIAL VALUES
              HA0 = HERMITE(ECP,RPX,IA(ITUV))
              HB0 = HERMITE(ECP,RPY,IB(ITUV))
              HC0 = HERMITE(ECP,RPZ,IC(ITUV))
C
C             HGTF IS A PRODUCT OF THESE
              HABC = HA0*HB0*HC0*GSS
C
C             MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
              TA1 = TA1 + P32*E11(M,ITUV)*HABC
              TA2 = TA2 + P32*E21(M,ITUV)*HABC
C
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + FC*TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + FC*TA2
C
C           LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
            IF(NNUC(IZ).LE.0) GOTO 100
            DO IFT=1,NNUC(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XNUC(IZ,IFT)
              FC = FNUC(IZ,IFT)
C
C             INCLUDE NUCLEAR EXPONENT
              ESM = EIJ+XI
              ECP = EIJ*XI/ESM
              P12 = DSQRT(PI/ESM)
              P32 = P12*P12*P12
              AMP =-0.25D0/PI
C
C             GAUSSIAN COMPONENT OF HGTF
              GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C             INITIALISE TEMPORARY STORAGE ARRAYS
              TA1 = DCMPLX(0.0D0,0.0D0)
              TA2 = DCMPLX(0.0D0,0.0D0)
C
C             LOOP OVER ALL {A,B,C}
              DO ITUV=1,NTUV
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HA0 = HERMITE(ECP,RPX,IA(ITUV)  )
                HB0 = HERMITE(ECP,RPY,IB(ITUV)  )
                HC0 = HERMITE(ECP,RPZ,IC(ITUV)  )
                HA2 = HERMITE(ECP,RPX,IA(ITUV)+2)
                HB2 = HERMITE(ECP,RPY,IB(ITUV)+2)
                HC2 = HERMITE(ECP,RPZ,IC(ITUV)+2)
C
C               3D HERMITE GAUSSIANS
                HABCX = HA2*HB0*HC0*GSS
                HABCY = HA0*HB2*HC0*GSS
                HABCZ = HA0*HB0*HC2*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + AMP*P32*E11(M,ITUV)*(HABCX+HABCY+HABCZ)
                TA2 = TA2 + AMP*P32*E21(M,ITUV)*(HABCX+HABCY+HABCZ)
C
              ENDDO
C
C             MATRIX ELEMENTS
              VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + FC*TA1
              VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + FC*TA2
C
            ENDDO
100         CONTINUE
C
C           OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
            VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
            VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
          ENDDO
        ENDDO
C
      ENDIF
C
3600  CONTINUE
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
      RETURN
      END
! C
! C
      SUBROUTINE VNCGRAD(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR     AA    DDDDDDD     C
C    VV    VV NNN   NN CC    CC GG    GG RR    RR   AAAA   DD    DD    C
C    VV    VV NNNN  NN CC       GG       RR    RR  AA  AA  DD    DD    C
C    VV    VV NN NN NN CC       GG       RR    RR AA    AA DD    DD    C
C     VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  AAAAAAAA DD    DD    C
C      VVVV   NN   NNN CC    CC GG    GG RR    RR AA    AA DD    DD    C
C       VV    NN    NN  CCCCCC   GGGGGG  RR    RR AA    AA DDDDDDD     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCGRAD CONSTRUCTS MATRIX OF ϱ_nuc{∇(μ,T|σ_Q|ν,T')} INTEGRALS OVER  C
C  ALL BASIS FUNCTIONS, WHERE THE GRADIENT OF THE ELECTRONIC DENSITY   C
C  HAS BEEN USED BEFORE INTEGRATING OVER NUCLEAR DENSITY ϱ_nuc.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z}   THE DENSITY GRADIENT COMPONENT.  C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     SKIP MULTI-CENTER TERMS IF YOU WANT TO TEST AGAINST NUMERICAL INT
      if(icnta.ne.iz) goto 1001
      if(icntb.ne.iz) goto 1001
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCGRAD: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCGRAD: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RPX = PX-BXYZ(1,IZ)
          RPY = PY-BXYZ(2,IZ)
          RPZ = PZ-BXYZ(3,IZ)

C         GAUSSIAN NUCLEAR CHARGE OVERLAP
          XI = XNUC(IZ,0)
          FC = FNUC(IZ,0)
C
C         INCLUDE NUCLEAR EXPONENT
          ESM = EIJ+XI
          P12 = DSQRT(XI/ESM)
          P32 = P12*P12*P12
          ECP = EIJ*XI/ESM
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           CARTESIAN HERMITE POLYNOMIAL VALUES
            HALPH = HERMITE(ECP,RPX,IA(ITUV)+KRONECK(IX,1))
            HBETA = HERMITE(ECP,RPY,IB(ITUV)+KRONECK(IX,2))
            HGAMA = HERMITE(ECP,RPZ,IC(ITUV)+KRONECK(IX,3))
C
C           HGTF IS A PRODUCT OF THESE
            HABC = HALPH*HBETA*HGAMA*GSS
C
C           MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
            TA1 = TA1 + P32*E11(M,ITUV)*HABC
            TA2 = TA2 + P32*E21(M,ITUV)*HABC
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + FC*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + FC*TA2
C
C         LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
          IF(NNUC(IZ).LE.0) GOTO 100
          DO IFT=1,NNUC(IZ)
C
C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
            XI = XNUC(IZ,IFT)
            FC = FNUC(IZ,IFT)
C
C           INCLUDE NUCLEAR EXPONENT
            ESM = EIJ+XI
            ECP = EIJ*XI/ESM
            P12 = DSQRT(PI/ESM)
            P32 = P12*P12*P12
            AMP =-0.25D0/PI
C
C           GAUSSIAN COMPONENT OF HGTF
            GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C           INITIALISE TEMPORARY STORAGE ARRAYS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER ALL {A,B,C}
            DO ITUV=1,NTUV
C
C             CARTESIAN HERMITE POLYNOMIAL VALUES
              HAX = HERMITE(ECP,RPX,IA(ITUV)+2+KRONECK(IX,1))
              HBX = HERMITE(ECP,RPY,IB(ITUV)+  KRONECK(IX,2))
              HCX = HERMITE(ECP,RPZ,IC(ITUV)+  KRONECK(IX,3))
              HABCX = HAX*HBX*HCX*GSS
C
              HAY = HERMITE(ECP,RPX,IA(ITUV)+  KRONECK(IX,1))
              HBY = HERMITE(ECP,RPY,IB(ITUV)+2+KRONECK(IX,2))
              HCY = HERMITE(ECP,RPZ,IC(ITUV)+  KRONECK(IX,3))
              HABCY = HAY*HBY*HCY*GSS
C
              HAZ = HERMITE(ECP,RPX,IA(ITUV)+  KRONECK(IX,1))
              HBZ = HERMITE(ECP,RPY,IB(ITUV)+  KRONECK(IX,2))
              HCZ = HERMITE(ECP,RPZ,IC(ITUV)+2+KRONECK(IX,3))
              HABCZ = HAZ*HBZ*HCZ*GSS
C
C             MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
              TA1 = TA1 + AMP*P32*E11(M,ITUV)*(HABCX+HABCY+HABCZ)
              TA2 = TA2 + AMP*P32*E21(M,ITUV)*(HABCX+HABCY+HABCZ)
C
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) - FC*TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) - FC*TA2
C
          ENDDO
100       CONTINUE
C
C         OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1001  continue
1000  CONTINUE
CC
CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
C      IF(ITT.EQ.2) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) = CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
CC
CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
C      IF(ITT.EQ.3) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) =-CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
C
C     MULTIPLY ALL RESULTS BY FACTOR -2*PI/3
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) =-2.0D0*PI*VIJ(I,J)/3.0D0
        ENDDO
      ENDDO
C
C
      RETURN
      END
C
C
      SUBROUTINE VNCGRADquad(VIJ,IZ,ITT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR     AA    DDDDDDD     C
C    VV    VV NNN   NN CC    CC GG    GG RR    RR   AAAA   DD    DD    C
C    VV    VV NNNN  NN CC       GG       RR    RR  AA  AA  DD    DD    C
C    VV    VV NN NN NN CC       GG       RR    RR AA    AA DD    DD    C
C     VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  AAAAAAAA DD    DD    C
C      VVVV   NN   NNN CC    CC GG    GG RR    RR AA    AA DD    DD    C
C       VV    NN    NN  CCCCCC   GGGGGG  RR    RR AA    AA DDDDDDD     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCGRAD CONSTRUCTS MATRIX OF ϱ_nuc{∇(μ,T|σ_Q|ν,T')} INTEGRALS OVER  C
C  ALL BASIS FUNCTIONS, WHERE THE GRADIENT OF THE ELECTRONIC DENSITY   C
C  HAS BEEN USED BEFORE INTEGRATING OVER NUCLEAR DENSITY ϱ_nuc.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z}   THE DENSITY GRADIENT COMPONENT.  C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),MQN(2),NBAS(2)
      DIMENSION RNLL(MBS,MBS),RNSS(MBS,MBS)
C
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     REASONS TO QUIT THIS ROUTINE
      IF(ITT.NE.1.AND.ITT.NE.4) THEN
        WRITE(6, *) 'In VNCGRADquad: invalid choice of ITT.',ITT
        WRITE(7, *) 'In VNCGRADquad: invalid choice of ITT.',ITT
        RETURN
      ENDIF
C
C     INTEGRATION GRID DETAILS
      NLIN = 6000
      RMAX = 6.0D0*RNUC(IZ)
      ELIN = RMAX/DFLOAT(NLIN)
C
C     INITIALISE THE GRADIENT OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
      IF(ICNTA.NE.IZ) GOTO 1001
      IF(ICNTB.NE.IZ) GOTO 1001
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C       SELECTION RULES BASED ON KQN
c        IF(KA.EQ.1.AND.KB.EQ.2) GOTO 2101
c        IF(KA.EQ.2.AND.KB.EQ.1) GOTO 2101
c        IF(KA.EQ.1.AND.KB.EQ.3) GOTO 2101
c        IF(KA.EQ.3.AND.KB.EQ.1) GOTO 2101
c        GOTO 2001
c2101    CONTINUE
C
        KDIFF = IABS(KA-KB)
        IF(IABS(KQN(1)).EQ.IABS(KQN(2)).AND.KDIFF.EQ.1) GOTO 2100
        IF(KQN(1)*KQN(2).GT.0.AND.KDIFF.EQ.2) GOTO 2100
        GOTO 2001
2100    CONTINUE
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C     SELECTION RULES BASED ON MQN
      IF(MA.NE.MB) GOTO 3001
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     ANGULAR FACTORS
      L1 = MIN(LVAL(KQN(1)),LVAL(KQN(2)))
      L2 = MAX(LVAL(KQN(1)),LVAL(KQN(2)))
      M1 = MQN(1)
      IF(IABS(KQN(1)).EQ.IABS(KQN(2))) THEN
        AFAC = DFLOAT(MQN(1))/(4.0D0*KQN(1)*KQN(2)+1.0D0)
        MP = 1
        MN =-1
      ELSE
        S1  = ISIGN(1,KQN(1))
        DEN = (2*L1+1)*(2*L1+3)
        RT1 = DSQRT(L1-0.5D0*S1*M1+0.5D0)*DSQRT(L1-0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1+0.5D0*   M1+0.5D0)*DSQRT(L1-0.5D0*   M1+1.5D0)
        RT2 = DSQRT(L1+0.5D0*S1*M1+0.5D0)*DSQRT(L1+0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1-0.5D0*   M1+0.5D0)*DSQRT(L1+0.5D0*   M1+1.5D0)
        AFAC = (RT1+RT2)/DEN
        MP = 1
        MN = 1
      ENDIF
C
C**********************************************************************C
C     GENERATE OVERLAP GRADIENT MATRICES                               C
C**********************************************************************C
C
C     OVERLAP TYPE LL
      IF(ITT.EQ.1) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNLL,EXL,LQN,NBAS,1)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          EI  = EXL(IBAS,1)
          DO JBAS=1,NBAS(2)
            M  = M+1
            EJ = EXL(JBAS,2)
C
C           GAUSSIAN PARAMATER COMBINATIONS
            EIJ = EI+EJ
C
C           NUMERICALLY INTEGRATE FROM 0 TO RMAX (LINEAR GRID)
            X0I = 0.0D0
            DO N=0,NLIN
              RN  = ELIN*DFLOAT(N)
              Z1  = RN**(LQN(1)+LQN(2))
              Z2  = DEXP(-EIJ*RN*RN)
              Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
              Z4  = DFLOAT(LQN(1)+LQN(2)) + 2.0D0 - 2.0D0*EIJ*RN*RN
              X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
            ENDDO
            X0I = 5.0D0*ELIN*X0I/299376.0D0
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*RNLL(IBAS,JBAS)*X0I
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*RNLL(IBAS,JBAS)*X0I
C
          ENDDO
        ENDDO
C
      ELSEIF(ITT.EQ.4) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNSS,EXL,LQN,NBAS,4)
C
C       KQN/LQN TERMS
        T1 = DFLOAT(KQN(1)+LQN(1)+1)
        T2 = DFLOAT(KQN(2)+LQN(2)+1)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          EI = EXL(IBAS,1)
          DO JBAS=1,NBAS(2)
            EJ = EXL(JBAS,2)
            M  = M+1
C
C           GAUSSIAN PARAMETER COMBINATIONS
            EIJ = EI+EJ
            EPR = EI*EJ
C
C           NUMERICALLY INTEGRATE FROM 0 TO RMAX (LINEAR GRID)
            X0I = 0.0D0
            IF(KQN(1).LT.0.AND.KQN(2).LT.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)+2)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  = 4.0D0*EPR*DFLOAT(4+LQN(1)+LQN(2))
     &              - 8.0D0*EIJ*EPR*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(KQN(1).LT.0.AND.KQN(2).GT.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2))
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  =-2.0D0*T2*EI*DFLOAT(2+LQN(1)+LQN(2))
     &              + 4.0D0*RN*RN*T2*EI*EIJ
     &              + 4.0D0*RN*RN*EPR*DFLOAT(4+LQN(1)+LQN(2))
     &              - 8.0D0*EIJ*EPR*RN*RN*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(KQN(1).GT.0.AND.KQN(2).LT.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2))
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  =-2.0D0*T1*EJ*DFLOAT(2+LQN(1)+LQN(2))
     &              + 4.0D0*RN*RN*T1*EJ*EIJ
     &              + 4.0D0*RN*RN*EPR*DFLOAT(4+LQN(1)+LQN(2))
     &              - 8.0D0*EIJ*EPR*RN*RN*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(KQN(1).GT.0.AND.KQN(2).GT.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)-2)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  = DFLOAT(LQN(1)+LQN(2))*T1*T2
     &              - 2.0D0*RN*RN*T1*T2*EIJ 
     &              - 2.0D0*RN*RN*T2*EI*DFLOAT(2+LQN(1)+LQN(2))
     &              - 2.0D0*RN*RN*T1*EJ*DFLOAT(2+LQN(1)+LQN(2))
     &              + 4.0D0*RN*RN*RN*RN*T2*EI*EIJ
     &              + 4.0D0*RN*RN*RN*RN*T1*EJ*EIJ
     &              + 4.0D0*RN*RN*RN*RN*EPR*DFLOAT(4+LQN(1)+LQN(2))
     &              - 8.0D0*EIJ*EPR*RN*RN*RN*RN*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ENDIF
            X0I = 5.0D0*ELIN*X0I/299376.0D0
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*RNSS(IBAS,JBAS)*X0I
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*RNSS(IBAS,JBAS)*X0I
C
          ENDDO
        ENDDO
C
      ENDIF
C
C     END LOOP OVER CENTRES A AND B
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C     MULTIPLY ALL RESULTS BY FACTOR 2*PI/3
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) = 2.0D0*PI*VIJ(I,J)/3.0D0
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE VNCSCHFquadTEMP(VIJ,IZ,ITT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   SSSSSS   CCCCCC  HH    HH FFFFFFFF    C
C    VV    VV NNN   NN CC    CC SS    SS CC    CC HH    HH FF          C
C    VV    VV NNNN  NN CC       SS       CC       HH    HH FF          C
C    VV    VV NN NN NN CC        SSSSSS  CC       HHHHHHHH FFFFFF      C
C     VV  VV  NN  NNNN CC             SS CC       HH    HH FF          C
C      VVVV   NN   NNN CC    CC SS    SS CC    CC HH    HH FF          C
C       VV    NN    NN  CCCCCC   SSSSSS   CCCCCC  HH    HH FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCSCHFquad CONSTRUCTS MATRIX OF INTEGRALS OVER ATOM-CENTRED FNS,   C
C  (μ,T|x_IX σ_Q ϱ_nuc(r)|ν,T'), INTEGRATING RADIALLY BY QUADRATURE    C
C  USING THE EXACT USER-SPECIFIED NUCLEAR CHARGE DETAILS.              C
C  USES THE FORMULA PROPOSED BY FLAMBAUM (2002,2019).                  C
C  TAKES ADVANTAGE OF ANGULAR FACTORS USED IN CONSTRUCTION OF VNCGRD1. C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(1)
C
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),MQN(2),NBAS(2)
      DIMENSION RNLL(MBS,MBS),RNSS(MBS,MBS)
      DIMENSION W(-1:MKP)
      dimension qqq(0:1000,2)
C
      COMPLEX*16 VIJ(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     REASONS TO QUIT THIS ROUTINE
      IF(ITT.NE.1.AND.ITT.NE.4) THEN
        WRITE(6, *) 'In VNCSCHFquadTEMP: invalid choice of ITT.',ITT
        WRITE(7, *) 'In VNCSCHFquadTEMP: invalid choice of ITT.',ITT
        RETURN
      ENDIF
C
C     INTEGRATION GRID DETAILS
      NLIN = 1000
      RMAX = 4.0D0*RNUC(IZ)
      ELIN = RMAX/DFLOAT(NLIN)
      
      do n=0,nlin
        qqq(n,1) = ELIN*DFLOAT(N)/RNUC(IZ)
        qqq(n,2) = 0.0d0
      enddo
C      
      DO IKP=1,MKP
        W(IKP) = 0.0D0
      ENDDO
C
C     INITIALISE THE GRADIENT OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
      IF(ICNTA.NE.IZ) GOTO 1001
      IF(ICNTB.NE.IZ) GOTO 1001
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C       SELECTION RULES BASED ON KQN
c        IF(KA.EQ.1.AND.KB.EQ.2) GOTO 2101
c        IF(KA.EQ.2.AND.KB.EQ.1) GOTO 2101
c        IF(KA.EQ.1.AND.KB.EQ.3) GOTO 2101
c        IF(KA.EQ.3.AND.KB.EQ.1) GOTO 2101
c        GOTO 2001
c2101    CONTINUE
cC
        KDIFF = IABS(KA-KB)
        IF(IABS(KQN(1)).EQ.IABS(KQN(2)).AND.KDIFF.EQ.1) GOTO 2100
        IF(KQN(1)*KQN(2).GT.0.AND.KDIFF.EQ.2) GOTO 2100
        GOTO 2001
2100    CONTINUE
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C     SELECTION RULES BASED ON MQN
      IF(MA.NE.MB) GOTO 3001
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     ANGULAR FACTORS
      L1 = MIN(LVAL(KQN(1)),LVAL(KQN(2)))
      L2 = MAX(LVAL(KQN(1)),LVAL(KQN(2)))
      M1 = MQN(1)
      IF(IABS(KQN(1)).EQ.IABS(KQN(2))) THEN
        AFAC = DFLOAT(MQN(1))/(4.0D0*KQN(1)*KQN(2)+1.0D0)
        MP = 1
        MN =-1
      ELSE
        S1  = ISIGN(1,KQN(1))
        DEN = (2*L1+1)*(2*L1+3)
        RT1 = DSQRT(L1-0.5D0*S1*M1+0.5D0)*DSQRT(L1-0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1+0.5D0*   M1+0.5D0)*DSQRT(L1-0.5D0*   M1+1.5D0)
        RT2 = DSQRT(L1+0.5D0*S1*M1+0.5D0)*DSQRT(L1+0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1-0.5D0*   M1+0.5D0)*DSQRT(L1+0.5D0*   M1+1.5D0)
        AFAC = (RT1+RT2)/DEN
        MP = 1
        MN = 1
      ENDIF
C
C**********************************************************************C
C     GENERATE OVERLAP GRADIENT MATRICES                               C
C**********************************************************************C
C
C     OVERLAP TYPE LL
      IF(ITT.EQ.1) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNLL,EXL,LQN,NBAS,1)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          EI = EXL(IBAS,1)
          DO JBAS=1,NBAS(2)
            M  = M+1
            EJ = EXL(JBAS,2)
C
C           GAUSSIAN PARAMETER COMBINATIONS
            EIJ = EI+EJ
C
            DLL11 = DENT(NA1+IBAS     ,NB1+JBAS     )
            DLL22 = DENT(NA2+IBAS     ,NB2+JBAS     )
C
C           NUMERICALLY INTEGRATE FROM 0 TO RMAX (LINEAR GRID)
            X0I = 0.0D0
            W11 = MN*AFAC*RNLL(IBAS,JBAS)
            W22 = MP*AFAC*RNLL(IBAS,JBAS)
            DO N=0,NLIN
              RN  = ELIN*DFLOAT(N)
              Z1  = RN**(LQN(1)+LQN(2)+2)
              Z2  = DEXP(-EIJ*RN*RN)
              Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
              X0I = X0I + EXTINT11(Z1*Z2*Z3,N,NLIN)
              qqq(n,2) = qqq(n,2) + W11*DLL11*Z1*Z2*RN
     &                            + W22*DLL22*Z1*Z2*RN
            ENDDO
            X0I = 5.0D0*ELIN*X0I/299376.0D0
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*RNLL(IBAS,JBAS)*X0I
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*RNLL(IBAS,JBAS)*X0I
C
          ENDDO
        ENDDO
C
      ELSEIF(ITT.EQ.4) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNSS,EXL,LQN,NBAS,ITT)
C
C       KQN/LQN TERMS
        KL1 = KQN(1)+LQN(1)+1
        KL2 = KQN(2)+LQN(2)+1
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          EI = EXL(IBAS,1)
          DO JBAS=1,NBAS(2)
            EJ = EXL(JBAS,2)
            M  = M+1
C
C           GAUSSIAN PARAMETER COMBINATIONS
            EIJ = EI+EJ
C
            DSS11 = DENT(NA1+IBAS+NSKP,NB1+JBAS+NSKP)
            DSS22 = DENT(NA2+IBAS+NSKP,NB2+JBAS+NSKP)
C
C           NUMERICALLY INTEGRATE FROM 0 TO RMAX (LINEAR GRID)
            X0I = 0.0D0
            W11 = MN*AFAC*RNSS(IBAS,JBAS)
            W22 = MP*AFAC*RNSS(IBAS,JBAS)
            IF(LQN(1).EQ.0.AND.LQN(2).EQ.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)+4)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  = 4.0D0*EI*EJ
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
                qqq(n,2) = qqq(n,2) + W11*DSS11*Z1*Z2*RN*Z4
     &                              + W22*DSS22*Z1*Z2*RN*Z4
              ENDDO
            ELSEIF(LQN(1).EQ.0.AND.LQN(2).NE.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)+2)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  =-2.0D0*EI*DFLOAT(KL2)
     &              + 4.0D0*EI*EJ*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
                qqq(n,2) = qqq(n,2) + W11*DSS11*Z1*Z2*RN*Z4
     &                              + W22*DSS22*Z1*Z2*RN*Z4
              ENDDO
            ELSEIF(LQN(1).NE.0.AND.LQN(2).EQ.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)+2)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  =-2.0D0*EJ*DFLOAT(KL1)
     &              + 4.0D0*EI*EJ*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
                qqq(n,2) = qqq(n,2) + W11*DSS11*Z1*Z2*RN*Z4
     &                              + W22*DSS22*Z1*Z2*RN*Z4
              ENDDO
            ELSEIF(LQN(1).NE.0.AND.LQN(2).NE.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2))
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  = DFLOAT(KL1*KL2)
     &              - 2.0D0*EI*DFLOAT(KL2)*RN*RN
     &              - 2.0D0*EJ*DFLOAT(KL1)*RN*RN
     &              + 4.0D0*EI*EJ*RN*RN*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
                qqq(n,2) = qqq(n,2) + W11*DSS11*Z1*Z2*RN*Z4
     &                              + W22*DSS22*Z1*Z2*RN*Z4
              ENDDO
            ENDIF
            X0I = 5.0D0*ELIN*X0I/299376.0D0
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*RNSS(IBAS,JBAS)*X0I
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*RNSS(IBAS,JBAS)*X0I
C
          ENDDO
        ENDDO
C
      ENDIF
C
C     END LOOP OVER CENTRES A AND B
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C     MULTIPLICATIVE FACTORS
      RN2 = RNUC(IZ)*RNUC(IZ)
      AMP = 2.0D0*PI/RN2
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = AMP*VIJ(I,J)
        ENDDO
      ENDDO
c      
c     radial integral
      bin = 0.0d0
      AMP = 2.0D0*PI/RN2
      do n=0,nlin
        RN  = ELIN*DFLOAT(N)
        XXX = AMP*RHONUC(NMDL(IZ),IZ,RN)*qqq(n,2)
        bin = bin + 5.0D0*ELIN*EXTINT11(XXX,N,NLIN)/299376.0D0
      enddo
      write(*,*) 'TOTAL = ',BIN
C
C     OPTIONALLY FOLD IN THE NUCLEAR DENSITY AND 2*PI/3
      DO N=0,NLIN
        RN  = ELIN*DFLOAT(N)
        qqq(n,2) = 3.0D0*qqq(n,2)/RN2
C       qqq(n,2) = AMP*qqq(n,2)
        qqq(n,2) = RHONUC(NMDL(IZ),IZ,RN)*qqq(n,2)
      ENDDO
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
      if(itt.eq.4) then
C     FILE NAME AND TITLES
      XOUT   = 'INTEGRAND_LNG'
      TITLE  = 'Integrand'
      XAXIS  = 'r (au)'
      YAXIS  = 'Integrand(z)'
      KEY(1) = 'NUCSCHF'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO N=0,NLIN
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) qqq(n,1),qqq(n,2)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,1,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
      endif
C
      RETURN
      END
C
C
      SUBROUTINE VNCGRADquadTEMP(VIJ,IZ,ITT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR     AA    DDDDDDD     C
C    VV    VV NNN   NN CC    CC GG    GG RR    RR   AAAA   DD    DD    C
C    VV    VV NNNN  NN CC       GG       RR    RR  AA  AA  DD    DD    C
C    VV    VV NN NN NN CC       GG       RR    RR AA    AA DD    DD    C
C     VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  AAAAAAAA DD    DD    C
C      VVVV   NN   NNN CC    CC GG    GG RR    RR AA    AA DD    DD    C
C       VV    NN    NN  CCCCCC   GGGGGG  RR    RR AA    AA DDDDDDD     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCGRAD CONSTRUCTS MATRIX OF ϱ_nuc{∇(μ,T|σ_Q|ν,T')} INTEGRALS OVER  C
C  ALL BASIS FUNCTIONS, WHERE THE GRADIENT OF THE ELECTRONIC DENSITY   C
C  HAS BEEN USED BEFORE INTEGRATING OVER NUCLEAR DENSITY ϱ_nuc.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z}   THE DENSITY GRADIENT COMPONENT.  C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(1)
C
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),MQN(2),NBAS(2)
      DIMENSION RNLL(MBS,MBS),RNSS(MBS,MBS)
      dimension qqq(0:1000,2)
C
      COMPLEX*16 VIJ(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     REASONS TO QUIT THIS ROUTINE
      IF(ITT.NE.1.AND.ITT.NE.4) THEN
        WRITE(6, *) 'In VNCGRADquadTEMP: invalid choice of ITT.',ITT
        WRITE(7, *) 'In VNCGRADquadTEMP: invalid choice of ITT.',ITT
        RETURN
      ENDIF
C
C     INTEGRATION GRID DETAILS
      NLIN = 1000
      RMAX = 4.0D0*RNUC(IZ)
      ELIN = RMAX/DFLOAT(NLIN)
C
      do n=0,nlin
        qqq(n,1) = ELIN*DFLOAT(N)/RNUC(iz)
        qqq(n,2) = 0.0d0
      enddo
C
C     INITIALISE THE GRADIENT OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
      IF(ICNTA.NE.IZ) GOTO 1001
      IF(ICNTB.NE.IZ) GOTO 1001
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C       SELECTION RULES BASED ON KQN
c        IF(KA.EQ.1.AND.KB.EQ.2) GOTO 2101
c        IF(KA.EQ.2.AND.KB.EQ.1) GOTO 2101
c        IF(KA.EQ.1.AND.KB.EQ.3) GOTO 2101
c        IF(KA.EQ.3.AND.KB.EQ.1) GOTO 2101
c        GOTO 2001
c2101    CONTINUE
C
        KDIFF = IABS(KA-KB)
        IF(IABS(KQN(1)).EQ.IABS(KQN(2)).AND.KDIFF.EQ.1) GOTO 2100
        IF(KQN(1)*KQN(2).GT.0.AND.KDIFF.EQ.2) GOTO 2100
        GOTO 2001
2100    CONTINUE
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C     SELECTION RULES BASED ON MQN
      IF(MA.NE.MB) GOTO 3001
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     ANGULAR FACTORS
      L1 = MIN(LVAL(KQN(1)),LVAL(KQN(2)))
      L2 = MAX(LVAL(KQN(1)),LVAL(KQN(2)))
      M1 = MQN(1)
      IF(IABS(KQN(1)).EQ.IABS(KQN(2))) THEN
        AFAC = DFLOAT(MQN(1))/(4.0D0*KQN(1)*KQN(2)+1.0D0)
        MP = 1
        MN =-1
      ELSE
        S1  = ISIGN(1,KQN(1))
        DEN = (2*L1+1)*(2*L1+3)
        RT1 = DSQRT(L1-0.5D0*S1*M1+0.5D0)*DSQRT(L1-0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1+0.5D0*   M1+0.5D0)*DSQRT(L1-0.5D0*   M1+1.5D0)
        RT2 = DSQRT(L1+0.5D0*S1*M1+0.5D0)*DSQRT(L1+0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1-0.5D0*   M1+0.5D0)*DSQRT(L1+0.5D0*   M1+1.5D0)
        AFAC = (RT1+RT2)/DEN
        MP = 1
        MN = 1
      ENDIF
C
C**********************************************************************C
C     GENERATE OVERLAP GRADIENT MATRICES                               C
C**********************************************************************C
C
C     OVERLAP TYPE LL
      IF(ITT.EQ.1) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNLL,EXL,LQN,NBAS,1)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          EI  = EXL(IBAS,1)
          DO JBAS=1,NBAS(2)
            M  = M+1
            EJ = EXL(JBAS,2)
C
C           GAUSSIAN PARAMATER COMBINATIONS
            EIJ = EI+EJ
C
            DLL11 = DENT(NA1+IBAS     ,NB1+JBAS     )
            DLL22 = DENT(NA2+IBAS     ,NB2+JBAS     )
C
C           NUMERICALLY INTEGRATE FROM 0 TO RMAX (LINEAR GRID)
            X0I = 0.0D0
            W11 = MN*AFAC*RNLL(IBAS,JBAS)
            W22 = MP*AFAC*RNLL(IBAS,JBAS)
            DO N=0,NLIN
              RN  = ELIN*DFLOAT(N)
              Z1  = RN**(LQN(1)+LQN(2))
              Z2  = DEXP(-EIJ*RN*RN)
              Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
              Z4  = DFLOAT(LQN(1)+LQN(2)) + 2.0D0 - 2.0D0*EIJ*RN*RN
              qqq(n,2) = qqq(n,2) + W11*DLL11*Z1*Z2*RN*Z4
     &                            + W22*DLL22*Z1*Z2*RN*Z4
              X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
            ENDDO
            X0I = 5.0D0*ELIN*X0I/299376.0D0
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*RNLL(IBAS,JBAS)*X0I
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*RNLL(IBAS,JBAS)*X0I
C
          ENDDO
        ENDDO
C
      ELSEIF(ITT.EQ.4) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNSS,EXL,LQN,NBAS,4)
C
C       KQN/LQN TERMS
        T1 = DFLOAT(KQN(1)+LQN(1)+1)
        T2 = DFLOAT(KQN(2)+LQN(2)+1)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          EI = EXL(IBAS,1)
          DO JBAS=1,NBAS(2)
            EJ = EXL(JBAS,2)
            M  = M+1
C
C           GAUSSIAN PARAMETER COMBINATIONS
            EIJ = EI+EJ
            EPR = EI*EJ
C
            DSS11 = DENT(NA1+IBAS+NSKP,NB1+JBAS+NSKP)
            DSS22 = DENT(NA2+IBAS+NSKP,NB2+JBAS+NSKP)
C
C           NUMERICALLY INTEGRATE FROM 0 TO RMAX (LINEAR GRID)
            X0I = 0.0D0
            W11 = MN*AFAC*RNSS(IBAS,JBAS)
            W22 = MP*AFAC*RNSS(IBAS,JBAS)
            IF(KQN(1).LT.0.AND.KQN(2).LT.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)+2)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  = 4.0D0*EPR*DFLOAT(4+LQN(1)+LQN(2))
     &              - 8.0D0*EIJ*EPR*RN*RN
                qqq(n,2) = qqq(n,2) + W11*DSS11*Z1*Z2*RN*Z4
     &                              + W22*DSS22*Z1*Z2*RN*Z4
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(KQN(1).LT.0.AND.KQN(2).GT.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2))
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  =-2.0D0*T2*EI*DFLOAT(2+LQN(1)+LQN(2))
     &              + 4.0D0*RN*RN*T2*EI*EIJ
     &              + 4.0D0*RN*RN*EPR*DFLOAT(4+LQN(1)+LQN(2))
     &              - 8.0D0*EIJ*EPR*RN*RN*RN*RN
                qqq(n,2) = qqq(n,2) + W11*DSS11*Z1*Z2*RN*Z4
     &                              + W22*DSS22*Z1*Z2*RN*Z4
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(KQN(1).GT.0.AND.KQN(2).LT.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2))
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  =-2.0D0*T1*EJ*DFLOAT(2+LQN(1)+LQN(2))
     &              + 4.0D0*RN*RN*T1*EJ*EIJ
     &              + 4.0D0*RN*RN*EPR*DFLOAT(4+LQN(1)+LQN(2))
     &              - 8.0D0*EIJ*EPR*RN*RN*RN*RN
                qqq(n,2) = qqq(n,2) + W11*DSS11*Z1*Z2*RN*Z4
     &                              + W22*DSS22*Z1*Z2*RN*Z4
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(KQN(1).GT.0.AND.KQN(2).GT.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)-2)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  = DFLOAT(LQN(1)+LQN(2))*T1*T2
     &              - 2.0D0*RN*RN*T1*T2*EIJ 
     &              - 2.0D0*RN*RN*T2*EI*DFLOAT(2+LQN(1)+LQN(2))
     &              - 2.0D0*RN*RN*T1*EJ*DFLOAT(2+LQN(1)+LQN(2))
     &              + 4.0D0*RN*RN*RN*RN*T2*EI*EIJ
     &              + 4.0D0*RN*RN*RN*RN*T1*EJ*EIJ
     &              + 4.0D0*RN*RN*RN*RN*EPR*DFLOAT(4+LQN(1)+LQN(2))
     &              - 8.0D0*EIJ*EPR*RN*RN*RN*RN*RN*RN
                qqq(n,2) = qqq(n,2) + W11*DSS11*Z1*Z2*RN*Z4
     &                              + W22*DSS22*Z1*Z2*RN*Z4
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ENDIF
            X0I = 5.0D0*ELIN*X0I/299376.0D0
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*RNSS(IBAS,JBAS)*X0I
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*RNSS(IBAS,JBAS)*X0I
C
          ENDDO
        ENDDO
C
      ENDIF
C
C     END LOOP OVER CENTRES A AND B
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C     MULTIPLY ALL RESULTS BY FACTOR 2*PI/3
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) = 2.0D0*PI*VIJ(I,J)/3.0D0
        ENDDO
      ENDDO
c      
c     radial integral
      bin = 0.0d0
      amp = 2.0d0*pi/3.0d0
      do n=0,nlin
        RN  = ELIN*DFLOAT(N)
        XXX = AMP*RHONUC(NMDL(IZ),IZ,RN)*qqq(n,2)
        bin = bin + 5.0D0*ELIN*EXTINT11(XXX,N,NLIN)/299376.0D0
      enddo
      write(*,*) 'TOTAL = ',BIN
C
C     OPTIONALLY FOLD IN THE NUCLEAR DENSITY AND 2*PI/3
      DO N=0,NLIN
        RN  = ELIN*DFLOAT(N)
C       qqq(n,2) = AMP*qqq(n,2)
        qqq(n,2) = RHONUC(NMDL(IZ),IZ,RN)*qqq(n,2)
      ENDDO
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
      IF(ITT.EQ.4) THEN
C     FILE NAME AND TITLES
      XOUT   = 'INTEGRAND_VEL'
      TITLE  = 'Integrand'
      XAXIS  = 'r (au)'
      YAXIS  = 'Integrand(z)'
      KEY(1) = 'NUCGRAD'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO N=0,NLIN
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) qqq(n,1),qqq(n,2)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,1,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
      ENDIF
C
      RETURN
      END
! C
! C
!       SUBROUTINE VNCGRADbackup(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR     AA    DDDDDDD     C
! C    VV    VV NNN   NN CC    CC GG    GG RR    RR   AAAA   DD    DD    C
! C    VV    VV NNNN  NN CC       GG       RR    RR  AA  AA  DD    DD    C
! C    VV    VV NN NN NN CC       GG       RR    RR AA    AA DD    DD    C
! C     VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  AAAAAAAA DD    DD    C
! C      VVVV   NN   NNN CC    CC GG    GG RR    RR AA    AA DD    DD    C
! C       VV    NN    NN  CCCCCC   GGGGGG  RR    RR AA    AA DDDDDDD     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VNCGRAD CONSTRUCTS MATRIX OF ∇(μ,T|σ_Q.ϱ_nuc|ν,T') OVERLAP GRADIENT C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z}   THE DENSITY GRADIENT COMPONENT.  C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE GRADIENT OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THE PHASE GENERATES EQ22 AND EQ12 COEFFS FROM EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP GRADIENT MATRICES                               C
! C**********************************************************************C
! C
! C     OVERLAP GRADIENT TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP GRADIENT TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP GRADIENT TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP GRADIENT TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VNCGRAD: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VNCGRAD: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1)+EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1)+EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1)+EJ*XYZ(3,2))/EIJ
! C
! C         COORDINATES OF EVALUATION
!           RPX = PX-BXYZ(1,IZ)
!           RPY = PY-BXYZ(2,IZ)
!           RPZ = PZ-BXYZ(3,IZ)
! C
! C         GAUSSIAN COMPONENT OF HGTF
!           GSS = DEXP(-EIJ*(RPX*RPX+RPY*RPY+RPZ*RPZ))
! C
! C         INITIALISE TEMPORARY STORAGE ARRAYS
!           TA1 = DCMPLX(0.0D0,0.0D0)
!           TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER ALL {A,B,C}
!           DO ITUV=1,NTUV
! C
! C           CARTESIAN HERMITE POLYNOMIAL VALUES
!             HALPH = HERMITE(EIJ,RPX,IA(ITUV)+KRONECK(IX,1))
!             HBETA = HERMITE(EIJ,RPY,IB(ITUV)+KRONECK(IX,2))
!             HGAMA = HERMITE(EIJ,RPZ,IC(ITUV)+KRONECK(IX,3))
! C
! C           HGTF IS A PRODUCT OF THESE
!             HABC = GSS*HALPH*HBETA*HGAMA
! C
! C           MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
!             TA1 = TA1 + E11(M,ITUV)*HABC
!             TA2 = TA2 + E21(M,ITUV)*HABC
! C
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + TA2
! C
! C         OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
      SUBROUTINE VNCGRAD1(VIJ,IZ,ITT,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR     AA    DDDDDDD   11   C
C VV    VV NNN   NN CC    CC GG    GG RR    RR   AAAA   DD    DD 111   C
C VV    VV NNNN  NN CC       GG       RR    RR  AA  AA  DD    DD  11   C
C VV    VV NN NN NN CC       GG       RR    RR AA    AA DD    DD  11   C
C  VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  AAAAAAAA DD    DD  11   C
C   VVVV   NN   NNN CC    CC GG    GG RR    RR AA    AA DD    DD  11   C
C    VV    NN    NN  CCCCCC   GGGGGG  RR    RR AA    AA DDDDDDD  1111  C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCGRAD CONSTRUCTS MATRIX OF (μ,T|cosθ/r^2|ν,T) OVERLAP GRADIENT    C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  THIS IS A ONE-CENTRE EXPANSION ON ATOM IZ AND IN THE Z-DIRECTION    C
C  ONLY, MAKING USE OF ANALYTIC INTEGRALS AND SELECTION RULES.         C
C  ONLY OPTIONS AVAILABLE ARE ITT=1 (LL) AND ITT=4 (SS) WITH IQ=0.     C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),MQN(2),NBAS(2)
      DIMENSION RNLL(MBS,MBS),RNSS(MBS,MBS)
      DIMENSION W(-1:MKP)
C
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
C
      CALL FACTRL
C
C     REASONS TO QUIT THIS ROUTINE
      IF(ITT.NE.1.AND.ITT.NE.4) THEN
        WRITE(6, *) 'In VNCGRAD1: invalid choice of ITT.',ITT
        WRITE(7, *) 'In VNCGRAD1: invalid choice of ITT.',ITT
        RETURN
      ENDIF
      IF(IQ.NE.0) THEN
        WRITE(6, *) 'In VNCGRAD1: invalid choice of IQ.',IQ
        WRITE(7, *) 'In VNCGRAD1: invalid choice of IQ.',IQ
        RETURN
      ENDIF
      
      DO IKP=1,MKP
        W(IKP) = 0.0D0
      ENDDO
C
C     INITIALISE THE GRADIENT OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
      IF(ICNTA.NE.IZ) GOTO 1001
      IF(ICNTB.NE.IZ) GOTO 1001
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C       SELECTION RULES BASED ON KQN
C        IF(KA.EQ.1.AND.KB.EQ.2) GOTO 2101
C        IF(KA.EQ.2.AND.KB.EQ.1) GOTO 2101
C        IF(KA.EQ.1.AND.KB.EQ.3) GOTO 2101
C        IF(KA.EQ.3.AND.KB.EQ.1) GOTO 2101
C        GOTO 2001
C2101    CONTINUE

C        if(ka.eq.1.and.kb.eq.2) goto 2101
C        if(ka.eq.1.and.kb.eq.3) goto 2101
C        if(ka.eq.2.and.kb.eq.1) goto 2101
C        if(ka.eq.3.and.kb.eq.1) goto 2101
C        goto 2001
C2101    continue

        KDIFF = IABS(KA-KB)
        IF(IABS(KQN(1)).EQ.IABS(KQN(2)).AND.KDIFF.EQ.1) GOTO 2100
        IF(KQN(1)*KQN(2).GT.0.AND.KDIFF.EQ.2) GOTO 2100
        GOTO 2001
2100    CONTINUE
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C     SELECTION RULES BASED ON MQN
      IF(MA.NE.MB) GOTO 3001
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     ANGULAR FACTORS
      L1 = MIN(LVAL(KQN(1)),LVAL(KQN(2)))
      L2 = MAX(LVAL(KQN(1)),LVAL(KQN(2)))
      M1 = MQN(1)
      IF(IABS(KQN(1)).EQ.IABS(KQN(2))) THEN
        AFAC = DFLOAT(MQN(1))/(4.0D0*KQN(1)*KQN(2)+1.0D0)
        MP = 1
        MN =-1
      ELSE
        S1  = ISIGN(1,KQN(1))
        DEN = (2*L1+1)*(2*L1+3)
        RT1 = DSQRT(L1-0.5D0*S1*M1+0.5D0)*DSQRT(L1-0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1+0.5D0*   M1+0.5D0)*DSQRT(L1-0.5D0*   M1+1.5D0)
        RT2 = DSQRT(L1+0.5D0*S1*M1+0.5D0)*DSQRT(L1+0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1-0.5D0*   M1+0.5D0)*DSQRT(L1+0.5D0*   M1+1.5D0)
        AFAC = (RT1+RT2)/DEN
        MP = 1
        MN = 1
      ENDIF
C
C**********************************************************************C
C     GENERATE OVERLAP GRADIENT MATRICES                               C
C**********************************************************************C
C
C     OVERLAP TYPE LL
      IF(ITT.EQ.1) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNLL,EXL,LQN,NBAS,1)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EI  = EXL(IBAS,1)
            EJ  = EXL(JBAS,2)
            EIJ = EI+EJ
C
C           RADIAL INTEGRAL
            X  = EIJ*RNUC(IZ)*RNUC(IZ)
            EP = DSQRT(EIJ**(LQN(1)+LQN(2)-1))
            FC = 0.5D0*RNLL(IBAS,JBAS)/EP
C
C           W VALUES
            IF(X.LT.0.5D0) THEN
              W(2) = 1.0D0 - 0.5D0*X + X*X/6.0D0 - X*X*X/24.0D0
     &               + X*X*X*X/120.0D0 - X*X*X*X*X/720.0D0
              W(3) = DSQRT(X)*(2.0D0/3.0D0 - 2.0D0*X/5.0D0 + X*X/7.0D0
     &               - X*X*X/27.0D0 + X*X*X*X/132.0D0)
              W(4) = 0.5D0*X - X*X/3.0D0 + X*X*X/8.0D0 - X*X*X*X/30.0D0
     &               + X*X*X*X*X/144.0D0
              W(5) = DSQRT(X)*(2.0D0*X/5.0D0 - 2.0D0*X*X/7.0D0
     &               + X*X*X/9.0D0 - X*X*X*X/33.0D0)
              W(6) = X*X/3.0D0 - X*X*X/4.0D0 + X*X*X*X/10.0D0
     &               - X*X*X*X*X/36.0D0
              W(7) = DSQRT(X)*(2.0D0*X*X/7.0D0 - 2.0D0*X*X*X/9.0D0
     &               + X*X*X*X/11.0D0)
              W(8) = X*X*X/4.0D0 - X*X*X*X/5.0D0 + X*X*X*X*X/12.0D0
            ELSE
              W(2) = GAMLWR(2,X)/X
              W(3) = GAMLWR(3,X)/X
              W(4) = GAMLWR(4,X)/X
              W(5) = GAMLWR(5,X)/X
              W(6) = GAMLWR(6,X)/X
              W(7) = GAMLWR(7,X)/X
              W(8) = GAMLWR(8,X)/X
            ENDIF
C
            V1 = W(LQN(1)+LQN(2)+1)
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*FC*V1
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*FC*V1
C
          ENDDO
        ENDDO
C
      ELSEIF(ITT.EQ.4) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNSS,EXL,LQN,NBAS,ITT)
C
        if(ka.eq.1.and.kb.eq.3) goto 34
        if(ka.eq.3.and.kb.eq.1) goto 34
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EI  = EXL(IBAS,1)
            EJ  = EXL(JBAS,2)
            EIJ = EI+EJ
C
C           RADIAL INTEGRAL
            X   = EIJ*RNUC(IZ)*RNUC(IZ)
            EP  = DSQRT(EIJ**(LQN(1)+LQN(2)+1))
            FC  = 0.5D0*RNSS(IBAS,JBAS)/EP
            KL1 = KQN(1)+LQN(1)+1
            KL2 = KQN(2)+LQN(2)+1
C
C           W VALUES
            IF(X.LT.0.5D0) THEN
              W(2) = 1.0D0 - 0.5D0*X + X*X/6.0D0 - X*X*X/24.0D0
     &               + X*X*X*X/120.0D0 - X*X*X*X*X/720.0D0
              W(3) = DSQRT(X)*(2.0D0/3.0D0 - 2.0D0*X/5.0D0 + X*X/7.0D0
     &               - X*X*X/27.0D0 + X*X*X*X/132.0D0)
              W(4) = 0.5D0*X - X*X/3.0D0 + X*X*X/8.0D0 - X*X*X*X/30.0D0
     &               + X*X*X*X*X/144.0D0
              W(5) = DSQRT(X)*(2.0D0*X/5.0D0 - 2.0D0*X*X/7.0D0
     &               + X*X*X/9.0D0 - X*X*X*X/33.0D0)
              W(6) = X*X/3.0D0 - X*X*X/4.0D0 + X*X*X*X/10.0D0
     &               - X*X*X*X*X/36.0D0
              W(7) = DSQRT(X)*(2.0D0*X*X/7.0D0 - 2.0D0*X*X*X/9.0D0
     &               + X*X*X*X/11.0D0)
              W(8) = X*X*X/4.0D0 - X*X*X*X/5.0D0 + X*X*X*X*X/12.0D0
            ELSE
              W(2) = GAMLWR(2,X)/X
              W(3) = GAMLWR(3,X)/X
              W(4) = GAMLWR(4,X)/X
              W(5) = GAMLWR(5,X)/X
              W(6) = GAMLWR(6,X)/X
              W(7) = GAMLWR(7,X)/X
              W(8) = GAMLWR(8,X)/X
            ENDIF
C
            V1 = 4.0D0*EI*EJ*W(LQN(1)+LQN(2)+3)
            IF(KL1.EQ.0.AND.KL2.EQ.0) THEN
              V2 = 0.0D0
            ELSE
              V2 =-2.0D0*EIJ*(EI*KL2+EJ*KL1)*W(LQN(1)+LQN(2)+1)
            ENDIF
            IF(KL1.EQ.0.OR.KL2.EQ.0) THEN
              V3 = 0.0D0
            ELSE
              V3 = KL1*KL2*EIJ*EIJ*W(LQN(1)+LQN(2)-1)
            ENDIF
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*FC*(V1+V2+V3)
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*FC*(V1+V2+V3)
C
          ENDDO
        ENDDO
C
34      continue
c
      ENDIF
C
C     END LOOP OVER CENTRES A AND B
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VNCGRAD2(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR  DDDDDDD   222222     C
C    VV    VV NNN   NN CC    CC GG    GG RR    RR DD    DD 22    22    C
C    VV    VV NNNN  NN CC       GG       RR    RR DD    DD       22    C
C    VV    VV NN NN NN CC       GG       RR    RR DD    DD     22      C
C     VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  DD    DD   22        C
C      VVVV   NN   NNN CC    CC GG    GG RR    RR DD    DD 22          C
C       VV    NN    NN  CCCCCC   GGGGGG  RR    RR DDDDDDD  22222222    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCGRAD2 CONSTRUCTS MATRIX OF ELECTRONIC GRADIENTS SAMPLED AT THE   C
C  LOCAL ORIGIN OF NUCLEUS IZ.                                         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z}   THE DENSITY GRADIENT COMPONENT.  C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     SKIP MULTI-CENTER TERMS IF YOU WANT TO TEST AGAINST NUMERICAL INT
c     if(icnta.ne.iz) goto 1001
c     if(icntb.ne.iz) goto 1001
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCGRAD2: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCGRAD2: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RPX = PX-BXYZ(1,IZ)
          RPY = PY-BXYZ(2,IZ)
          RPZ = PZ-BXYZ(3,IZ)
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS = DEXP(-EIJ*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           CARTESIAN HERMITE POLYNOMIAL VALUES
            HALPH = HERMITE(EIJ,RPX,IA(ITUV)+KRONECK(IX,1))
            HBETA = HERMITE(EIJ,RPY,IB(ITUV)+KRONECK(IX,2))
            HGAMA = HERMITE(EIJ,RPZ,IC(ITUV)+KRONECK(IX,3))
C
C           HGTF IS A PRODUCT OF THESE
            HABC = HALPH*HBETA*HGAMA*GSS
C
C           MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
            TA1 = TA1 + E11(M,ITUV)*HABC
            TA2 = TA2 + E21(M,ITUV)*HABC
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + TA1
          VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + TA2
C
C         OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1001  continue
1000  CONTINUE
CC
CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
C      IF(ITT.EQ.2) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) = CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
CC
CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
C      IF(ITT.EQ.3) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) =-CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
C
C     MULTIPLY ALL RESULTS BY FACTOR -2*PI/3
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) =-2.0D0*PI*VIJ(I,J)/3.0D0
        ENDDO
      ENDDO
C
      RETURN
      END
! C
! C
!       SUBROUTINE VNCGRAD1TEST(VIJ,IZ,ITT,IQ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR     AA    DDDDDDD   11   C
! C VV    VV NNN   NN CC    CC GG    GG RR    RR   AAAA   DD    DD 111   C
! C VV    VV NNNN  NN CC       GG       RR    RR  AA  AA  DD    DD  11   C
! C VV    VV NN NN NN CC       GG       RR    RR AA    AA DD    DD  11   C
! C  VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  AAAAAAAA DD    DD  11   C
! C   VVVV   NN   NNN CC    CC GG    GG RR    RR AA    AA DD    DD  11   C
! C    VV    NN    NN  CCCCCC   GGGGGG  RR    RR AA    AA DDDDDDD  1111  C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VNCGRAD CONSTRUCTS MATRIX OF (μ,T|cosθ/r^2|ν,T) OVERLAP GRADIENT    C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C -------------------------------------------------------------------- C
! C  THIS IS A ONE-CENTRE EXPANSION ON ATOM IZ AND IN THE Z-DIRECTION    C
! C  ONLY, MAKING USE OF ANALYTIC INTEGRALS AND SELECTION RULES.         C
! C  ONLY OPTIONS AVAILABLE ARE ITT=1 (LL) AND ITT=4 (SS) WITH IQ=0.     C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),JQN(2),LQN(2),MQN(2),NBAS(2)
!       DIMENSION RNLL(MBS,MBS),RNSS(MBS,MBS)
!       DIMENSION W(-1:MKP)
! C
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
! C
!       CALL FACTRL
! C
! C     REASONS TO QUIT THIS ROUTINE
!       IF(ITT.NE.1.AND.ITT.NE.4) THEN
!         WRITE(6, *) 'In VNCGRAD1test: invalid choice of ITT.',ITT
!         WRITE(7, *) 'In VNCGRAD1test: invalid choice of ITT.',ITT
!         RETURN
!       ENDIF
!       IF(IQ.NE.0) THEN
!         WRITE(6, *) 'In VNCGRAD1test: invalid choice of IQ.',IQ
!         WRITE(7, *) 'In VNCGRAD1test: invalid choice of IQ.',IQ
!         RETURN
!       ENDIF
      
!       DO IKP=1,MKP
!         W(IKP) = 0.0D0
!       ENDDO
! C
! C     INITIALISE THE GRADIENT OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
!       IF(ICNTA.NE.IZ.OR.ICNTB.NE.IZ) GOTO 1001
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
!         JQN(1) = 2*IABS(KQN(1))-1
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
!         JQN(2) = 2*IABS(KQN(2))-1
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C       SELECTION RULES BASED ON KQN
! C        KDIFF = IABS(KA-KB)
! C        IF(IABS(KQN(1)).EQ.IABS(KQN(2)).AND.KDIFF.EQ.1) GOTO 2100
! C        IF(KQN(1)*KQN(2).GT.0.AND.KDIFF.EQ.2) GOTO 2100
! C        GOTO 2001
! C2100    CONTINUE
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C     SELECTION RULES BASED ON MQN
!       IF(MA.NE.MB) GOTO 3001
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     SELECTION RULES BASED ON ANGULAR FACTOR
!       IPAR = LQN(1)+LQN(2)+1
!       IF(MOD(IPAR,2).EQ.1) GOTO 3001
! C
! C     FULL ANGULAR FACTOR
! C      SN = (-1.0D0)**(JQN(1)+(1+MQN(1))/2)
! C      SP = (-1.0D0)**(JQN(1)+(1-MQN(1))/2)
! C
!       RJRT = DFLOAT((JQN(1)+1)*(JQN(2)+1))
!       RJRT = DSQRT(RJRT)
!       SJM  = SYM3J(JQN(1),1,JQN(2),-MQN(1),0,MQN(2))
!       SJJ  = SYM3J(JQN(2),1,JQN(1),1,0,-1)
! C
!       ANG = RJRT*SJM*SJJ
!       IF(DABS(ANG).LT.1.0D-4) GOTO 3001
! C
! CC     ANGULAR FACTORS
! C      L1 = MIN(LVAL(KQN(1)),LVAL(KQN(2)))
! C      L2 = MAX(LVAL(KQN(1)),LVAL(KQN(2)))
! C      M1 = MQN(1)
!       IF(IABS(KQN(1)).EQ.IABS(KQN(2))) THEN
! C        AFAC = DFLOAT(MQN(1))/(4.0D0*KQN(1)*KQN(2)+1.0D0)
!         SP = 1.0D0
!         SN =-1.0D0
!       ELSE
! C        S1  = ISIGN(1,KQN(1))
! C        DEN = (2*L1+1)*(2*L1+3)
! C        RT1 = DSQRT(L1-0.5D0*S1*M1+0.5D0)*DSQRT(L1-0.5D0*S1*M1+1.5D0)
! C     &       *DSQRT(L1+0.5D0*   M1+0.5D0)*DSQRT(L1-0.5D0*   M1+1.5D0)
! C        RT2 = DSQRT(L1+0.5D0*S1*M1+0.5D0)*DSQRT(L1+0.5D0*S1*M1+1.5D0)
! C     &       *DSQRT(L1-0.5D0*   M1+0.5D0)*DSQRT(L1+0.5D0*   M1+1.5D0)
! C        AFAC = (RT1+RT2)/DEN
!         SP = 1.0D0
!         SN = 1.0D0
!       ENDIF
! C
! C**********************************************************************C
! C     GENERATE OVERLAP GRADIENT MATRICES                               C
! C**********************************************************************C
! C
! C     OVERLAP TYPE LL
!       IF(ITT.EQ.1) THEN
! C
! C       RADIAL NORMALISATION FACTORS
!         CALL RNORM1(RNLL,EXL,LQN,NBAS,1)
! C
! C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           EXPONENT COMBINATIONS
!             EI  = EXL(IBAS,1)
!             EJ  = EXL(JBAS,2)
!             EIJ = EI+EJ
! C
! C           RADIAL INTEGRAL
!             X  = EIJ*RNUC(IZ)*RNUC(IZ)
!             EP = DSQRT(EIJ**(LQN(1)+LQN(2)-1))
!             FC = 0.5D0*RNLL(IBAS,JBAS)/EP
! C
! C           W VALUES
!             IF(X.LT.0.5D0) THEN
!               W(2) = 1.0D0 - 0.5D0*X + X*X/6.0D0 - X*X*X/24.0D0
!      &               + X*X*X*X/120.0D0 - X*X*X*X*X/720.0D0
!               W(3) = DSQRT(X)*(2.0D0/3.0D0 - 2.0D0*X/5.0D0 + X*X/7.0D0
!      &               - X*X*X/27.0D0 + X*X*X*X/132.0D0)
!               W(4) = 0.5D0*X - X*X/3.0D0 + X*X*X/8.0D0 - X*X*X*X/30.0D0
!      &               + X*X*X*X*X/144.0D0
!               W(5) = DSQRT(X)*(2.0D0*X/5.0D0 - 2.0D0*X*X/7.0D0
!      &               + X*X*X/9.0D0 - X*X*X*X/33.0D0)
!               W(6) = X*X/3.0D0 - X*X*X/4.0D0 + X*X*X*X/10.0D0
!      &               - X*X*X*X*X/36.0D0
!               W(7) = DSQRT(X)*(2.0D0*X*X/7.0D0 - 2.0D0*X*X*X/9.0D0
!      &               + X*X*X*X/11.0D0)
!               W(8) = X*X*X/4.0D0 - X*X*X*X/5.0D0 + X*X*X*X*X/12.0D0
!             ELSE
!               W(2) = GAMLWR(2,X)/X
!               W(3) = GAMLWR(3,X)/X
!               W(4) = GAMLWR(4,X)/X
!               W(5) = GAMLWR(5,X)/X
!               W(6) = GAMLWR(6,X)/X
!               W(7) = GAMLWR(7,X)/X
!               W(8) = GAMLWR(8,X)/X
!             ENDIF
! C
!             V1 = W(LQN(1)+LQN(2)+1)
! C
!             VIJ(NA1+IBAS,NB1+JBAS) = SN*ANG*FC*V1
!             VIJ(NA2+IBAS,NB2+JBAS) = SP*ANG*FC*V1
! C
!           ENDDO
!         ENDDO
! C
!       ELSEIF(ITT.EQ.4) THEN
! C
! C       RADIAL NORMALISATION FACTORS
!         CALL RNORM1(RNSS,EXL,LQN,NBAS,ITT)
! C
! C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           EXPONENT COMBINATIONS
!             EI  = EXL(IBAS,1)
!             EJ  = EXL(JBAS,2)
!             EIJ = EI+EJ
! C
! C           RADIAL INTEGRAL
!             X   = EIJ*RNUC(IZ)*RNUC(IZ)
!             EP  = DSQRT(EIJ**(LQN(1)+LQN(2)+1))
!             FC  = 0.5D0*RNSS(IBAS,JBAS)/EP
!             KL1 = KQN(1)+LQN(1)+1
!             KL2 = KQN(2)+LQN(2)+1
! C
! C           W VALUES
!             IF(X.LT.0.5D0) THEN
!               W(2) = 1.0D0 - 0.5D0*X + X*X/6.0D0 - X*X*X/24.0D0
!      &               + X*X*X*X/120.0D0 - X*X*X*X*X/720.0D0
!               W(3) = DSQRT(X)*(2.0D0/3.0D0 - 2.0D0*X/5.0D0 + X*X/7.0D0
!      &               - X*X*X/27.0D0 + X*X*X*X/132.0D0)
!               W(4) = 0.5D0*X - X*X/3.0D0 + X*X*X/8.0D0 - X*X*X*X/30.0D0
!      &               + X*X*X*X*X/144.0D0
!               W(5) = DSQRT(X)*(2.0D0*X/5.0D0 - 2.0D0*X*X/7.0D0
!      &               + X*X*X/9.0D0 - X*X*X*X/33.0D0)
!               W(6) = X*X/3.0D0 - X*X*X/4.0D0 + X*X*X*X/10.0D0
!      &               - X*X*X*X*X/36.0D0
!               W(7) = DSQRT(X)*(2.0D0*X*X/7.0D0 - 2.0D0*X*X*X/9.0D0
!      &               + X*X*X*X/11.0D0)
!               W(8) = X*X*X/4.0D0 - X*X*X*X/5.0D0 + X*X*X*X*X/12.0D0
!             ELSE
!               W(2) = GAMLWR(2,X)/X
!               W(3) = GAMLWR(3,X)/X
!               W(4) = GAMLWR(4,X)/X
!               W(5) = GAMLWR(5,X)/X
!               W(6) = GAMLWR(6,X)/X
!               W(7) = GAMLWR(7,X)/X
!               W(8) = GAMLWR(8,X)/X
!             ENDIF
! C
!             V1 = 4.0D0*EI*EJ*W(LQN(1)+LQN(2)+3)
!             IF(KL1.EQ.0.AND.KL2.EQ.0) THEN
!               V2 = 0.0D0
!             ELSE
!               V2 =-2.0D0*EIJ*(EI*KL2+EJ*KL1)*W(LQN(1)+LQN(2)+1)
!             ENDIF
!             IF(KL1.EQ.0.OR.KL2.EQ.0) THEN
!               V3 = 0.0D0
!             ELSE
!               V3 = KL1*KL2*EIJ*EIJ*W(LQN(1)+LQN(2)-1)
!             ENDIF
! C
!             VIJ(NA1+IBAS,NB1+JBAS) = SN*ANG*FC*(V1+V2+V3)
!             VIJ(NA2+IBAS,NB2+JBAS) = SP*ANG*FC*(V1+V2+V3)
! C
!           ENDDO
!         ENDDO
! C
!       ENDIF
! C
! C     END LOOP OVER CENTRES A AND B
! 3001  CONTINUE
! 3000  CONTINUE
! C2001  CONTINUE
! 2000  CONTINUE
! 1001  CONTINUE
! 1000  CONTINUE
! C
!       RETURN
!       END
! C
! C
      SUBROUTINE VNCGRAD0(VIJ,IZ,ITT,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR  DDDDDDD   000000     C
C    VV    VV NNN   NN CC    CC GG    GG RR    RR DD    DD 00   000    C
C    VV    VV NNNN  NN CC       GG       RR    RR DD    DD 00  0000    C
C    VV    VV NN NN NN CC       GG       RR    RR DD    DD 00 00 00    C
C     VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  DD    DD 0000  00    C
C      VVVV   NN   NNN CC    CC GG    GG RR    RR DD    DD 000   00    C
C       VV    NN    NN  CCCCCC   GGGGGG  RR    RR DDDDDDD   000000     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCGRAD0 CONSTRUCTS MATRIX OF (μ,T|cosθ/r^2|ν,T) OVERLAP GRADIENT   C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  THIS IS A ONE-CENTRE EXPANSION ON ATOM IZ AND IN THE Z-DIRECTION    C
C  ONLY, MAKING USE OF ANALYTIC INTEGRALS AND SELECTION RULES.         C
C  ONLY OPTIONS AVAILABLE ARE ITT=1 (LL) AND ITT=4 (SS) WITH IQ=0.     C
C -------------------------------------------------------------------- C
C  THIS VERSION REPLICATES WHAT WAS IN QUINEY ET. AL. 1997.            C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),MQN(2),NBAS(2)
      DIMENSION RNLL(MBS,MBS),RNSS(MBS,MBS)
C
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
C
C     REASONS TO QUIT THIS ROUTINE
      IF(ITT.NE.1.AND.ITT.NE.4) THEN
        WRITE(6, *) 'In VNCGRAD0: invalid choice of ITT.',ITT
        WRITE(7, *) 'In VNCGRAD0: invalid choice of ITT.',ITT
        RETURN
      ENDIF
      IF(IQ.NE.0) THEN
        WRITE(6, *) 'In VNCGRAD0: invalid choice of IQ.',IQ
        WRITE(7, *) 'In VNCGRAD0: invalid choice of IQ.',IQ
        RETURN
      ENDIF
C
C     INITIALISE THE GRADIENT OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
      IF(ICNTA.NE.IZ.OR.ICNTB.NE.IZ) GOTO 1001
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
        IF(KA.EQ.1.AND.KB.EQ.2) GOTO 2100
        IF(KA.EQ.2.AND.KB.EQ.1) GOTO 2100
        IF(KA.EQ.1.AND.KB.EQ.3) GOTO 2100
        IF(KA.EQ.3.AND.KB.EQ.1) GOTO 2100
        GOTO 2001
2100    CONTINUE
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
      IF(MQN(1).NE.1.OR.MQN(2).NE.1) GOTO 3001
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C**********************************************************************C
C     GENERATE OVERLAP GRADIENT MATRICES                               C
C**********************************************************************C
C
C     POSITIVE AND NEGATIVE MULTIPLIERS
      IF(KA.EQ.1.AND.KB.EQ.2) THEN
        MP = 1
        MN =-1
      ELSEIF(KA.EQ.2.AND.KB.EQ.1) THEN
        MP = 1
        MN =-1
      ELSEIF(KA.EQ.1.AND.KB.EQ.3) THEN
        MP = 1
        MN = 1
      ELSEIF(KA.EQ.3.AND.KB.EQ.1) THEN
        MP = 1
        MN = 1
      ENDIF
C
C     OVERLAP TYPE LL
      IF(ITT.EQ.1) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNLL,EXL,LQN,NBAS,1)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EI = EXL(IBAS,1)
            EJ = EXL(JBAS,2)
C
C           FEW COMBINATIONS SURVIVE
            V1 = 0.0D0
            IF(KA.EQ.1.AND.KB.EQ.2) THEN
              V1 = RNLL(IBAS,JBAS)/6.0D0
            ELSEIF(KA.EQ.2.AND.KB.EQ.1) THEN
              V1 = RNLL(IBAS,JBAS)/6.0D0
            ENDIF
            IF(KA.EQ.1.AND.KB.EQ.3) THEN
              V1 = DSQRT(2.0D0)*RNLL(IBAS,JBAS)/6.0D0
            ELSEIF(KA.EQ.3.AND.KB.EQ.1) THEN
              V1 = DSQRT(2.0D0)*RNLL(IBAS,JBAS)/6.0D0
            ENDIF
C
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + MP*V1
            VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + MN*V1
C
          ENDDO
        ENDDO
C
      ELSEIF(ITT.EQ.4) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNSS,EXL,LQN,NBAS,ITT)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           EXPONENT COMBINATIONS
            EI = EXL(IBAS,1)
            EJ = EXL(JBAS,2)
C
            IF(KA.EQ.1) THEN
              RSA =-2.0D0*EI
            ELSEIF(KA.EQ.2) THEN
              RSA = 3.0D0
            ENDIF
            IF(KB.EQ.1) THEN
              RSB =-2.0D0*EJ
            ELSEIF(KB.EQ.2) THEN
              RSB = 3.0D0
            ENDIF
C
C           FEW COMBINATIONS SURVIVE
            V1 = 0.0D0
            IF(KA.EQ.1.AND.KB.EQ.2) THEN
              V1 = RSA*RSB*RNSS(IBAS,JBAS)/6.0D0
            ELSEIF(KA.EQ.2.AND.KB.EQ.1) THEN
              V1 = RSA*RSB*RNSS(IBAS,JBAS)/6.0D0
            ENDIF
C
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + MP*V1
            VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + MN*V1
C
          ENDDO
        ENDDO
C
      ENDIF
C
C     END LOOP OVER CENTRES A AND B
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
      RETURN
      END
! C
! C
!       SUBROUTINE VNCGRADE(VIJ,IZ,ITT,IQ)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV NN    NN  CCCCCC   GGGGGG  RRRRRRR  DDDDDDD  EEEEEEEE    C
! C    VV    VV NNN   NN CC    CC GG    GG RR    RR DD    DD EE          C
! C    VV    VV NNNN  NN CC       GG       RR    RR DD    DD EE          C
! C    VV    VV NN NN NN CC       GG       RR    RR DD    DD EEEEEE      C
! C     VV  VV  NN  NNNN CC       GG   GGG RRRRRRR  DD    DD EE          C
! C      VVVV   NN   NNN CC    CC GG    GG RR    RR DD    DD EE          C
! C       VV    NN    NN  CCCCCC   GGGGGG  RR    RR DDDDDDD  EEEEEEEE    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VNCGRADE CONSTRUCTS MATRIX OF (μ,T|cosθ/r^2|ν,T) OVERLAP GRADIENT   C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C -------------------------------------------------------------------- C
! C  THIS IS A ONE-CENTRE EXPANSION ON ATOM IZ AND IN THE Z-DIRECTION    C
! C  ONLY, MAKING USE OF ANALYTIC INTEGRALS AND SELECTION RULES.         C
! C  ONLY OPTIONS AVAILABLE ARE ITT=1 (LL) AND ITT=4 (SS) WITH IQ=0.     C
! C -------------------------------------------------------------------- C
! C  THIS VERSION REPLICATES WHAT WAS IN QUINEY ET. AL. 1997 WHEN THE    C
! C  BOUND-STATE APPROXIMATION IS MADE.                                  C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),MQN(2),NBAS(2)
!       DIMENSION RNLL(MBS,MBS)
! C
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE THE GRADIENT OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     REASONS TO QUIT THIS ROUTINE
!       IF(ITT.NE.1) THEN
!         WRITE(6, *) 'In VNCGRADE: invalid choice of ITT.',ITT
!         WRITE(7, *) 'In VNCGRADE: invalid choice of ITT.',ITT
!         RETURN
!       ENDIF
!       IF(IQ.NE.0) THEN
!         WRITE(6, *) 'In VNCGRADE: invalid choice of IQ.',IQ
!         WRITE(7, *) 'In VNCGRADE: invalid choice of IQ.',IQ
!         RETURN
!       ENDIF
! C
! C     POTENTIAL AT THE ORIGIN
!       V0 =-2.0D0*ZNUC(IZ)*FNUC(IZ,0)*DSQRT(XNUC(IZ,0))/PI12
!       DO IFT=1,NNUC(IZ)
!         V0 = V0 - ZNUC(IZ)*FNUC(IZ,IFT)
!       ENDDO
! C
!       VS = V0/(V0-2.0D0*CV*CV)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
!       IF(ICNTA.NE.IZ.OR.ICNTB.NE.IZ) GOTO 1001
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
!         IF(KA.EQ.1.AND.KB.EQ.2) GOTO 2100
!         IF(KA.EQ.2.AND.KB.EQ.1) GOTO 2100
!         IF(KA.EQ.1.AND.KB.EQ.3) GOTO 2100
!         IF(KA.EQ.3.AND.KB.EQ.1) GOTO 2100
!         GOTO 2001
! 2100    CONTINUE
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
!       IF(MQN(1).NE.1.OR.MQN(2).NE.1) GOTO 3001
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C**********************************************************************C
! C     GENERATE OVERLAP GRADIENT MATRICES                               C
! C**********************************************************************C
! C
!       IF(KA.EQ.1.AND.KB.EQ.2) THEN
!         MP = 1
!         MN =-1
!       ELSEIF(KA.EQ.2.AND.KB.EQ.1) THEN
!         MP = 1
!         MN =-1
!       ELSEIF(KA.EQ.1.AND.KB.EQ.3) THEN
!         MP = 1
!         MN = 1
!       ELSEIF(KA.EQ.3.AND.KB.EQ.1) THEN
!         MP = 1
!         MN = 1
!       ENDIF
! C
! C     OVERLAP TYPE LL
!       IF(ITT.EQ.1) THEN
! C
! C       RADIAL NORMALISATION FACTORS
!         CALL RNORM1(RNLL,EXL,LQN,NBAS,1)
! C
! C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           EXPONENT COMBINATIONS
!             EI = EXL(IBAS,1)
!             EJ = EXL(JBAS,2)
! C
! C           FEW COMBINATIONS SURVIVE
!             V1 = 0.0D0
!             IF(KA.EQ.1.AND.KB.EQ.2) THEN
!               V1 = RNLL(IBAS,JBAS)/6.0D0
!               VQ = 1.0D0-VS
!             ELSEIF(KA.EQ.2.AND.KB.EQ.1) THEN
!               V1 = RNLL(IBAS,JBAS)/6.0D0
!               VQ = 1.0D0-VS
!             ENDIF
!             IF(KA.EQ.1.AND.KB.EQ.3) THEN
!               V1 = DSQRT(2.0D0)*RNLL(IBAS,JBAS)/6.0D0
!               VQ = 1.0D0
!             ELSEIF(KA.EQ.3.AND.KB.EQ.1) THEN
!               V1 = DSQRT(2.0D0)*RNLL(IBAS,JBAS)/6.0D0
!               VQ = 1.0D0
!             ENDIF
! C
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + MP*VQ*V1
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + MN*VQ*V1
! C
!           ENDDO
!         ENDDO
! C
!       ENDIF
! C
! C     END LOOP OVER CENTRES A AND B
! 3001  CONTINUE
! 3000  CONTINUE
! 2001  CONTINUE
! 2000  CONTINUE
! 1001  CONTINUE
! 1000  CONTINUE
! C
!       RETURN
!       END
! C
! C
      SUBROUTINE VNCSCHF(VIJ,CLOC,IZ,ITT,IQ,IX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   SSSSSS   CCCCCC  HH    HH FFFFFFFF    C
C    VV    VV NNN   NN CC    CC SS    SS CC    CC HH    HH FF          C
C    VV    VV NNNN  NN CC       SS       CC       HH    HH FF          C
C    VV    VV NN NN NN CC        SSSSSS  CC       HHHHHHHH FFFFFF      C
C     VV  VV  NN  NNNN CC             SS CC       HH    HH FF          C
C      VVVV   NN   NNN CC    CC SS    SS CC    CC HH    HH FF          C
C       VV    NN    NN  CCCCCC   SSSSSS   CCCCCC  HH    HH FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCSCHF CONSTRUCTS MATRIX OF INTEGRALS (μ,T|x_IX σ_Q ϱ_nuc(r)|ν,T') C
C  OVER ALL BASIS FUNCTIONS, USING THE USER-INPUT NUCLEAR CHARGE       C
C  DETAILS. USES THE FORMULA PROPOSED BY FLAMBAUM (2002,2019).         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z}   THE DENSITY GRADIENT COMPONENT.  C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RP(3),CC(3)
      DIMENSION CLOC(3)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GAUGE LOCATION
      CC(1) = BXYZ(1,IZ)-CLOC(1)
      CC(2) = BXYZ(2,IZ)-CLOC(2)
      CC(3) = BXYZ(3,IZ)-CLOC(3)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C      SKIP MULTI-CENTRE CONTRIBUTIONS IF TESTING NUMERICAL INTEGRATION
C      if(icnta.ne.iz) goto 1001
C      if(icntb.ne.iz) goto 1001
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C      IF(KA.EQ.1.AND.KB.EQ.2) GOTO 2100
C      IF(KA.EQ.1.AND.KB.EQ.3) GOTO 2100
C      IF(KA.EQ.2.AND.KB.EQ.1) GOTO 2100
C      IF(KA.EQ.3.AND.KB.EQ.1) GOTO 2100
C      GOTO 2001
C2100  CONTINUE
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
       IF(MQN(1).NE.1.OR.MQN(2).NE.1) GOTO 3001
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCSCHF: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCSCHF: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RP(1) = PX-BXYZ(1,IZ)
          RP(2) = PY-BXYZ(2,IZ)
          RP(3) = PZ-BXYZ(3,IZ)
          RPSQ  = RP(1)*RP(1) + RP(2)*RP(2) + RP(3)*RP(3)
C
C         GAUSSIAN NUCLEAR CHARGE DENSITY
          XI0 = XNUC(IZ,0)
          FC  = FNUC(IZ,0)
C
C         INCLUDE NUCLEAR EXPONENT
          ESM = EIJ+XI0
          P12 = DSQRT(XI0/ESM)
          P32 = P12*P12*P12
          ECP = EIJ*XI0/ESM
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS = DEXP(-ECP*RPSQ)
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           CARTESIAN EXPANSION INDICES
            IT = IA(ITUV)
            IU = IB(ITUV)
            IV = IC(ITUV)
C
C           CARTESIAN HERMITE POLYNOMIAL VALUES
            HA1 = HERMITE(ECP,RP(1),IT+KRONECK(IX,1))
            HB1 = HERMITE(ECP,RP(2),IU+KRONECK(IX,2))
            HC1 = HERMITE(ECP,RP(3),IV+KRONECK(IX,3))
            HABC1 =-HA1*HB1*HC1*GSS
C
C           GAUGE CONTRIBUTION
            HAG = HERMITE(ECP,RP(1),IT)
            HBG = HERMITE(ECP,RP(2),IU)
            HCG = HERMITE(ECP,RP(3),IV)
            HABCG = 2.0D0*XI0*CC(IX)*HAG*HBG*HCG*GSS
c           habcg = 0.0d0
C
C           MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
            TA1 = TA1 + P32*E11(M,ITUV)*(HABC1+HABCG)
            TA2 = TA2 + P32*E21(M,ITUV)*(HABC1+HABCG)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + FC*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + FC*TA2
C
C         LOOP OVER NUCLEAR FITTING FUNCTIONS
          IF(NNUC(IZ).LE.0) GOTO 100
          DO IFT=1,NNUC(IZ)
C
C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
            XI = XNUC(IZ,IFT)
            FC = FNUC(IZ,IFT)
C
C           INCLUDE NUCLEAR EXPONENT
            ESM = EIJ+XI
            P12 = DSQRT(PI/ESM)
            P32 = P12*P12*P12
            AMP = 0.25D0/PI
            ECP = EIJ*XI/ESM
C
C           GAUSSIAN COMPONENT OF HGTF
            GSS = DEXP(-ECP*RPSQ)
C
C           INITIALISE TEMPORARY STORAGE ARRAYS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER ALL {A,B,C}
            DO ITUV=1,NTUV
C
C             CARTESIAN EXPANSION INDICES
              IT = IA(ITUV)
              IU = IB(ITUV)
              IV = IC(ITUV)
C
C             CARTESIAN HERMITE POLYNOMIAL VALUES
              HA1 = HERMITE(ECP,RP(1),IT+KRONECK(IX,1))
              HB1 = HERMITE(ECP,RP(2),IU+KRONECK(IX,2))
              HC1 = HERMITE(ECP,RP(3),IV+KRONECK(IX,3))
              HABC1 = 4.0D0*XI0*HA1*HB1*HC1*GSS
C
              HAX = HERMITE(ECP,RP(1),IT+2+KRONECK(IX,1))
              HBX = HERMITE(ECP,RP(2),IU+  KRONECK(IX,2))
              HCX = HERMITE(ECP,RP(3),IV+  KRONECK(IX,3))
              HABCX = HAX*HBX*HCX*GSS
C
              HAY = HERMITE(ECP,RP(1),IT+  KRONECK(IX,1))
              HBY = HERMITE(ECP,RP(2),IU+2+KRONECK(IX,2))
              HCY = HERMITE(ECP,RP(3),IV+  KRONECK(IX,3))
              HABCY = HAY*HBY*HCY*GSS
C
              HAZ = HERMITE(ECP,RP(1),IT+  KRONECK(IX,1))
              HBZ = HERMITE(ECP,RP(2),IU+  KRONECK(IX,2))
              HCZ = HERMITE(ECP,RP(3),IV+2+KRONECK(IX,3))
              HABCZ = HAZ*HBZ*HCZ*GSS
C
              HABC2 = XI0*(HABCX+HABCY+HABCZ)/XI
C
C             GAUGE CONTRIBUTION
              HAX = HERMITE(ECP,RP(1),IT+2)
              HBX = HERMITE(ECP,RP(2),IU  )
              HCX = HERMITE(ECP,RP(3),IV  )
              HABCX = HAX*HBX*HCX*GSS
C
              HAY = HERMITE(ECP,RP(1),IT  )
              HBY = HERMITE(ECP,RP(2),IU+2)
              HCY = HERMITE(ECP,RP(3),IV  )
              HABCY = HAY*HBY*HCY*GSS
C
              HAZ = HERMITE(ECP,RP(1),IT  )
              HBZ = HERMITE(ECP,RP(2),IU  )
              HCZ = HERMITE(ECP,RP(3),IV+2)
              HABCZ = HAZ*HBZ*HCZ*GSS
C
              HABCG =-2.0D0*XI0*CC(IX)*(HABCX+HABCY+HABCZ)/XI
c             habcg = 0.0d0
C
C             MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
              TA1 = TA1 + P32*E11(M,ITUV)*(HABC1+HABC2+HABCG)
              TA2 = TA2 + P32*E21(M,ITUV)*(HABC1+HABC2+HABCG)
C
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + FC*AMP*TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + FC*AMP*TA2
C
          ENDDO
100       CONTINUE
C
C         OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  continue
1000  CONTINUE
C
C     MULTIPLICATIVE FACTORS
      RN2 = RNUC(IZ)*RNUC(IZ)
      AMP = 2.0D0*PI/3.0D0
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = AMP*VIJ(I,J)
        ENDDO
      ENDDO
C
CC
CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
C      IF(ITT.EQ.2) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) = CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
CC
CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
C      IF(ITT.EQ.3) THEN
C        DO I=1,NDIM-NSKP
C          DO J=1,NDIM-NSKP
C            VIJ(I,J) =-CONE*VIJ(I,J)
C          ENDDO
C        ENDDO
C      ENDIF
CC
      RETURN
      END
! C
! C
      SUBROUTINE VNCSCHFquad(VIJ,IZ,ITT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   SSSSSS   CCCCCC  HH    HH FFFFFFFF    C
C    VV    VV NNN   NN CC    CC SS    SS CC    CC HH    HH FF          C
C    VV    VV NNNN  NN CC       SS       CC       HH    HH FF          C
C    VV    VV NN NN NN CC        SSSSSS  CC       HHHHHHHH FFFFFF      C
C     VV  VV  NN  NNNN CC             SS CC       HH    HH FF          C
C      VVVV   NN   NNN CC    CC SS    SS CC    CC HH    HH FF          C
C       VV    NN    NN  CCCCCC   SSSSSS   CCCCCC  HH    HH FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCSCHFquad CONSTRUCTS MATRIX OF INTEGRALS OVER ATOM-CENTRED FNS,   C
C  (μ,T|x_IX σ_Q ϱ_nuc(r)|ν,T'), INTEGRATING RADIALLY BY QUADRATURE    C
C  USING THE EXACT USER-SPECIFIED NUCLEAR CHARGE DETAILS.              C
C  USES THE FORMULA PROPOSED BY FLAMBAUM (2002,2019).                  C
C  TAKES ADVANTAGE OF ANGULAR FACTORS USED IN CONSTRUCTION OF VNCGRD1. C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),MQN(2),NBAS(2)
      DIMENSION RNLL(MBS,MBS),RNSS(MBS,MBS)
      DIMENSION W(-1:MKP)
C
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     REASONS TO QUIT THIS ROUTINE
      IF(ITT.NE.1.AND.ITT.NE.4) THEN
        WRITE(6, *) 'In VNCGRAD1: invalid choice of ITT.',ITT
        WRITE(7, *) 'In VNCGRAD1: invalid choice of ITT.',ITT
        RETURN
      ENDIF
C
C     INTEGRATION GRID DETAILS
      NLIN = 6000
      RMAX = 6.0D0*RNUC(IZ)
      ELIN = RMAX/DFLOAT(NLIN)
C      
      DO IKP=1,MKP
        W(IKP) = 0.0D0
      ENDDO
C
C     INITIALISE THE GRADIENT OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
      IF(ICNTA.NE.IZ) GOTO 1001
      IF(ICNTB.NE.IZ) GOTO 1001
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C       SELECTION RULES BASED ON KQN
c        IF(KA.EQ.1.AND.KB.EQ.2) GOTO 2101
c        IF(KA.EQ.2.AND.KB.EQ.1) GOTO 2101
c        IF(KA.EQ.1.AND.KB.EQ.3) GOTO 2101
c        IF(KA.EQ.3.AND.KB.EQ.1) GOTO 2101
c        GOTO 2001
c2101    CONTINUE
cC
        KDIFF = IABS(KA-KB)
        IF(IABS(KQN(1)).EQ.IABS(KQN(2)).AND.KDIFF.EQ.1) GOTO 2100
        IF(KQN(1)*KQN(2).GT.0.AND.KDIFF.EQ.2) GOTO 2100
        GOTO 2001
2100    CONTINUE
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C     SELECTION RULES BASED ON MQN
      IF(MA.NE.MB) GOTO 3001
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     ANGULAR FACTORS
      L1 = MIN(LVAL(KQN(1)),LVAL(KQN(2)))
      L2 = MAX(LVAL(KQN(1)),LVAL(KQN(2)))
      M1 = MQN(1)
      IF(IABS(KQN(1)).EQ.IABS(KQN(2))) THEN
        AFAC = DFLOAT(MQN(1))/(4.0D0*KQN(1)*KQN(2)+1.0D0)
        MP = 1
        MN =-1
      ELSE
        S1  = ISIGN(1,KQN(1))
        DEN = (2*L1+1)*(2*L1+3)
        RT1 = DSQRT(L1-0.5D0*S1*M1+0.5D0)*DSQRT(L1-0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1+0.5D0*   M1+0.5D0)*DSQRT(L1-0.5D0*   M1+1.5D0)
        RT2 = DSQRT(L1+0.5D0*S1*M1+0.5D0)*DSQRT(L1+0.5D0*S1*M1+1.5D0)
     &       *DSQRT(L1-0.5D0*   M1+0.5D0)*DSQRT(L1+0.5D0*   M1+1.5D0)
        AFAC = (RT1+RT2)/DEN
        MP = 1
        MN = 1
      ENDIF
C
C**********************************************************************C
C     GENERATE OVERLAP GRADIENT MATRICES                               C
C**********************************************************************C
C
C     OVERLAP TYPE LL
      IF(ITT.EQ.1) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNLL,EXL,LQN,NBAS,1)
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          EI = EXL(IBAS,1)
          DO JBAS=1,NBAS(2)
            M  = M+1
            EJ = EXL(JBAS,2)
C
C           GAUSSIAN PARAMETER COMBINATIONS
            EIJ = EI+EJ
C
C           NUMERICALLY INTEGRATE FROM 0 TO RMAX (LINEAR GRID)
            X0I = 0.0D0
            DO N=0,NLIN
              RN  = ELIN*DFLOAT(N)
              Z1  = RN**(LQN(1)+LQN(2)+2)
              Z2  = DEXP(-EIJ*RN*RN)
              Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
              X0I = X0I + EXTINT11(Z1*Z2*Z3,N,NLIN)
            ENDDO
            X0I = 5.0D0*ELIN*X0I/299376.0D0
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*RNLL(IBAS,JBAS)*X0I
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*RNLL(IBAS,JBAS)*X0I
C
          ENDDO
        ENDDO
C
      ELSEIF(ITT.EQ.4) THEN
C
C       RADIAL NORMALISATION FACTORS
        CALL RNORM1(RNSS,EXL,LQN,NBAS,ITT)
C
C       KQN/LQN TERMS
        KL1 = KQN(1)+LQN(1)+1
        KL2 = KQN(2)+LQN(2)+1
C
C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          EI = EXL(IBAS,1)
          DO JBAS=1,NBAS(2)
            EJ = EXL(JBAS,2)
            M  = M+1
C
C           GAUSSIAN PARAMETER COMBINATIONS
            EIJ = EI+EJ
C
C           NUMERICALLY INTEGRATE FROM 0 TO RMAX (LINEAR GRID)
            X0I = 0.0D0
            IF(LQN(1).EQ.0.AND.LQN(2).EQ.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)+4)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  = 4.0D0*EI*EJ
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(LQN(1).EQ.0.AND.LQN(2).NE.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)+2)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  =-2.0D0*EI*DFLOAT(KL2)
     &              + 4.0D0*EI*EJ*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(LQN(1).NE.0.AND.LQN(2).EQ.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2)+2)
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  =-2.0D0*EJ*DFLOAT(KL1)
     &              + 4.0D0*EI*EJ*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ELSEIF(LQN(1).NE.0.AND.LQN(2).NE.0) THEN
              DO N=0,NLIN
                RN  = ELIN*DFLOAT(N)
                Z1  = RN**(LQN(1)+LQN(2))
                Z2  = DEXP(-EIJ*RN*RN)
                Z3  = RN*RHONUC(NMDL(IZ),IZ,RN)
                Z4  = DFLOAT(KL1*KL2)
     &              - 2.0D0*EI*DFLOAT(KL2)*RN*RN
     &              - 2.0D0*EJ*DFLOAT(KL1)*RN*RN
     &              + 4.0D0*EI*EJ*RN*RN*RN*RN
                X0I = X0I + EXTINT11(Z1*Z2*Z3*Z4,N,NLIN)
              ENDDO
            ENDIF
            X0I = 5.0D0*ELIN*X0I/299376.0D0
C
            VIJ(NA1+IBAS,NB1+JBAS) = MN*AFAC*RNSS(IBAS,JBAS)*X0I
            VIJ(NA2+IBAS,NB2+JBAS) = MP*AFAC*RNSS(IBAS,JBAS)*X0I
C
          ENDDO
        ENDDO
C
      ENDIF
C
C     END LOOP OVER CENTRES A AND B
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C     MULTIPLICATIVE FACTORS
      RN2 = RNUC(IZ)*RNUC(IZ)
      AMP = 2.0D0*PI/RN2
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = AMP*VIJ(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
! C
! C
!       SUBROUTINE VMAGEFF0(VIJ,IZ,ITT)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   VV    VV MM       MM  GGGGGG  EEEEEEEE FFFFFFFF FFFFFFFF 000000    C
! C   VV    VV MMM     MMM GG    GG EE       FF       FF      00   000   C
! C   VV    VV MMMM   MMMM GG       EE       FF       FF      00  0000   C
! C   VV    VV MM MM MM MM GG       EEEEEE   FFFFFF   FFFFFF  00 00 00   C
! C    VV  VV  MM  MMM  MM GG   GGG EE       FF       FF      0000  00   C
! C     VVVV   MM   M   MM GG    GG EE       FF       FF      000   00   C
! C      VV    MM       MM  GGGGGG  EEEEEEEE FF       FF       000000    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VMAGEFF0 CONSTRUCTS MATRIX OF (μ,T|σ±/r^3|ν,T') OVERLAP GRADIENT    C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C -------------------------------------------------------------------- C
! C  THIS IS A ONE-CENTRE EXPANSION ON ATOM IZ AND IN THE Z-DIRECTION    C
! C  ONLY, MAKING USE OF ANALYTIC INTEGRALS AND SELECTION RULES.         C
! C  ONLY OPTIONS AVAILABLE ARE ITT=2 (LS) AND ITT=3 (SL).               C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),JQN(2),LQN(2),MQN(2),NBAS(2)
!       DIMENSION RNLS(MBS,MBS),RNSL(MBS,MBS)
! C
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/GAMA/GAMLOG(300),GAMHLF(300)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     GENERATE GAMMA FUNCTION VALUES
!       CALL GAMGEN
! C
! C     INITIALISE THE GRADIENT OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     REASONS TO QUIT THIS ROUTINE
!       IF(ITT.NE.2.AND.ITT.NE.3) THEN
!         WRITE(6, *) 'In VMAGEFF0: invalid choice of ITT.',ITT
!         WRITE(7, *) 'In VMAGEFF0: invalid choice of ITT.',ITT
!         RETURN
!       ENDIF
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C     IGNORE CONTRIBUTIONS THAT AREN'T CENTRED ON IZ
!       IF(ICNTA.NE.IZ.OR.ICNTB.NE.IZ) GOTO 1001
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
!         JQN(1) = 2*IABS(KQN(1))-1
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
!         JQN(2) = 2*IABS(KQN(2))-1
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
!         IF(ITT.EQ.2.AND.KA-KB.EQ.2) GOTO 2100
!         IF(ITT.EQ.3.AND.KB-KA.EQ.2) GOTO 2100
!         GOTO 2001
! 2100    CONTINUE
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
!       IF(MQN(1).NE.MQN(2)) GOTO 3001
! C
! 88    FORMAT(3(2X,I2),' | ',3(2X,I2),' | ',2(2X,I1,'/2'),' | ',
!      &                                                 2X,F5.2,2X,F8.4)
!       ETA = SIGN(1,KQN(1))
!       IF(ITT.EQ.2) THEN
!         KSYM =-KQN(2)
!         LSYM = LVAL(KSYM)
!       ELSEIF(ITT.EQ.3) THEN
!         KSYM =-KQN(1)
!         LSYM = LVAL(KSYM)
!       ENDIF
!       MAG = MQN(1)*MQN(1)-1
!       ANG =-ETA*DSQRT(LSYM*(LSYM+1)-0.25D0*MAG)
!       IF(ITT.EQ.2) THEN
!         IF(ANG.LT.0.0D0) THEN
!           SGN =-1.0D0
!         ELSE
!           SGN = 1.0D0
!         ENDIF
!         WRITE(6,88) KQN(1),KQN(2),KSYM,LQN(1),LQN(2),LSYM,MQN(1),MQN(2),
!      &              ETA,SGN*ANG*ANG
!         WRITE(7,88) KQN(1),KQN(2),KSYM,LQN(1),LQN(2),LSYM,MQN(1),MQN(2),
!      &              ETA,SGN*ANG*ANG
!       ENDIF
!       IF(DABS(ANG).LT.1.0D-6) GOTO 3001
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C**********************************************************************C
! C     GENERATE OVERLAP GRADIENT MATRICES                               C
! C**********************************************************************C
! C
! C     OVERLAP TYPE LS
!       IF(ITT.EQ.2) THEN
! C
! C       RADIAL NORMALISATION FACTORS
!         CALL RNORM1(RNLS,EXL,LQN,NBAS,ITT)
! C
! C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
! C
! C           EXPONENT COMBINATIONS
!             EI  = EXL(IBAS,1)
!             EJ  = EXL(JBAS,2)
!             EIJ = EI+EJ
!             EP  = EIJ**(LQN(1)+LQN(2)+1)
!             IF(KQN(2).GT.0) THEN
!               F1 = (KQN(2)+LQN(2)+1)*EIJ*GAMHLF(LQN(1)+LQN(2)-1)
!             ELSE
!               F1 = 0.0D0
!             ENDIF
!             F2  = 2.0D0*EJ*GAMHLF(LQN(1)+LQN(2)+1)
! C
! C           RADIAL INTEGRAL
!             V1 = 0.5D0*RNLS(IBAS,JBAS)*(F1-F2)/DSQRT(EP)
! C
!             VIJ(NA1+IBAS,NB1+JBAS) = ANG*V1
!             VIJ(NA2+IBAS,NB2+JBAS) = ANG*V1
! C
!           ENDDO
!         ENDDO
! C
! C     OVERLAP TYPE SL
!       ELSEIF(ITT.EQ.3) THEN
! C
! C       RADIAL NORMALISATION FACTORS
!         CALL RNORM1(RNSL,EXL,LQN,NBAS,ITT)
! C
! C       CALCULATE OVERLAP GRADIENT MATRIX ELEMENTS
!         DO IBAS=1,NBAS(1)
!           EI  = EXL(IBAS,1)
!           DO JBAS=1,NBAS(2)
!             EJ  = EXL(JBAS,2)
! C
! C           GAUSSIAN PARAMETER COMBINATIONS
!             EIJ = EI+EJ
!             EP  = EIJ**(LQN(1)+LQN(2)+1)
! C
!             IF(KQN(1).GT.0) THEN
!               F1 = (KQN(1)+LQN(1)+1)*EIJ*GAMHLF(LQN(1)+LQN(2)-1)
!             ELSE
!               F1 = 0.0D0
!             ENDIF
!             F2 = 2.0D0*EI*GAMHLF(LQN(1)+LQN(2)+1)
! C
! C           RADIAL INTEGRAL
!             V1 = 0.5D0*RNSL(IBAS,JBAS)*(F1-F2)/DSQRT(EP)
! C
!             VIJ(NA1+IBAS,NB1+JBAS) = ANG*V1
!             VIJ(NA2+IBAS,NB2+JBAS) = ANG*V1
! C
!           ENDDO
!         ENDDO
! C
!       ENDIF
! C
! C     END LOOP OVER CENTRES A AND B
! 3001  CONTINUE
! 3000  CONTINUE
! 2001  CONTINUE
! 2000  CONTINUE
! 1001  CONTINUE
! 1000  CONTINUE
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VKNETIC(VIJ,ITT,IQ,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      VV    VV KK    KK NN    NN EEEEEEEE TTTTTTTT IIII CCCCCC        C
! C      VV    VV KK   KK  NNN   NN EE          TT     II CC    CC       C
! C      VV    VV KK  KK   NNNN  NN EE          TT     II CC             C
! C      VV    VV KKKKK    NN NN NN EEEEEE      TT     II CC             C
! C       VV  VV  KK  KK   NN  NNNN EE          TT     II CC             C
! C        VVVV   KK   KK  NN   NNN EE          TT     II CC    CC       C
! C         VV    KK    KK NN    NN EEEEEEEE    TT    IIII CCCCCC        C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VKNETIC CONSTRUCTS A MATRIX OF (μ,T|σ_Q(σ.P)|ν,T') OVERLAP          C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE ARRAY OF MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THE PHASE GENERATES EQ22 AND EQ12 COEFFS FROM EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELSQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VKNETIC: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VKNETIC: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         COORDINATES OF EVALUATION
!           RPX = PX-XYZ(1,2)
!           RPY = PY-XYZ(2,2)
!           RPZ = PZ-XYZ(3,2)
!           RP2 = RPX*RPX + RPY*RPY + RPZ*RPZ
! C
! C         FACTORS
!           ERT = (DSQRT(PI/EIJ)**3)
!           PRE = 8.0D0*DSQRT(EJ*EJ*EJ/(DFLOAT(2*LQN(2))+3.0D0))
! C
! C         INTEGRALS FOR THIS BLOCK
!           IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
!             X10 = 0.125D0*(2*LQN(2)+3.0D0)/EJ
!           ELSE
!             X10 = 0.250D0*(2*LQN(2)+3.0D0)/EJ - 0.5D0*RP2 - 0.75D0/EIJ
!           ENDIF
!           TA1 = X10*E11(M,1)
!           TA2 = X10*E21(M,1)
!           IF(ITT.EQ.2.OR.ITT.EQ.4) THEN
!             IF(LQN(1)+LQN(2).GT.0) THEN
!               TA1 = TA1 - RPX*E11(M,4) - RPY*E11(M,3) - RPZ*E11(M,2)
!               TA2 = TA2 - RPX*E21(M,4) - RPY*E21(M,3) - RPZ*E21(M,2)
!             ENDIF
!             IF(LQN(1)+LQN(2).GT.1) THEN
!               TA1 = TA1 - E11(M,10) - E11(M, 7) - E11(M, 5)
!               TA2 = TA2 - E21(M,10) - E21(M, 7) - E21(M, 5)
!             ENDIF
!           ENDIF
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = ERT*PRE*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = ERT*PRE*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! C
! C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
!       IF(ITT.EQ.1) THEN
!         DO I=1,NDIM-NSKP
!           DO J=1,NDIM-NSKP
!             VIJ(I,J) = CONE*VIJ(I,J)
!           ENDDO
!         ENDDO
!       ENDIF
! C
! C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
!       IF(ITT.EQ.4) THEN
!         DO I=1,NDIM-NSKP
!           DO J=1,NDIM-NSKP
!             VIJ(I,J) =-CONE*VIJ(I,J)
!           ENDDO
!         ENDDO
!       ENDIF
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VMOM0DV(VIJ,ITT,IQ,NX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C VV    VV MM       MM  OOOOOO  MM       MM  000000  DDDDDDD  VV    VV C
! C VV    VV MMM     MMM OO    OO MMM     MMM 00   000 DD    DD VV    VV C
! C VV    VV MMMM   MMMM OO    OO MMMM   MMMM 00  0000 DD    DD VV    VV C
! C VV    VV MM MM MM MM OO    OO MM MM MM MM 00 00 00 DD    DD VV    VV C
! C  VV  VV  MM  MMM  MM OO    OO MM  MMM  MM 0000  00 DD    DD  VV  VV  C
! C   VVVV   MM   M   MM OO    OO MM   M   MM 000   00 DD    DD   VVVV   C
! C    VV    MM       MM  OOOOOO  MM       MM  000000  DDDDDDD     VV    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VMOM0DV CONSTRUCTS A MATRIX OF (μ,T|σ_IQ ∇_NX|ν,T') OVERLAP         C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ NX      = {1,2,3}   -> {X,Y,Z} THE CARTESIAN DERIVATIVE.          C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR GQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE ARRAY OF MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THE PHASE GENERATES EQ22 AND EQ12 COEFFS FROM EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE GQLL COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
! C        CALL GQLLMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,1,
! C     &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE GQLS COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQLSMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE GQSL COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQSLMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE GQSS COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQSSMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VMOM0DV: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VMOM0DV: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EIJ = EXL(IBAS,1)+EXL(JBAS,2)
!           ERT = DSQRT(PI/EIJ)**3
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = ERT*G11(M,1)
!           VIJ(NA2+IBAS,NB1+JBAS) = ERT*G21(M,1)
!           VIJ(NA1+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! C
! C     ∂/∂C_X = -∂/∂X SO WE WILL NEED AN ADDITIONAL "-"
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) =-VIJ(I,J)
!         ENDDO
!       ENDDO
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VMOM1DV(VIJ,CLOC,ITT,IQ,IX,NX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   VV    VV MM       MM  OOOOOO  MM       MM  11  DDDDDDD  VV    VV   C
! C   VV    VV MMM     MMM OO    OO MMM     MMM 111  DD    DD VV    VV   C
! C   VV    VV MMMM   MMMM OO    OO MMMM   MMMM  11  DD    DD VV    VV   C
! C   VV    VV MM MM MM MM OO    OO MM MM MM MM  11  DD    DD VV    VV   C
! C    VV  VV  MM  MMM  MM OO    OO MM  MMM  MM  11  DD    DD  VV  VV    C
! C     VVVV   MM   M   MM OO    OO MM   M   MM  11  DD    DD   VVVV     C
! C      VV    MM       MM  OOOOOO  MM       MM 1111 DDDDDDD     VV      C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VMOM1DV CONSTRUCTS A MATRIX OF (μ,T|σ_IQ R_IX ∇_NX|ν,T') OVERLAP    C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ CLOC    = LOCAL ORIGIN OVER WHICH MOMENT IX IS TO BE EVALUATED.   C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN WEIGHTING FACTOR.        C
! C  ▶ NX      = {1,2,3}   -> {X,Y,Z} THE CARTESIAN DERIVATIVE.          C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR GQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION CLOC(3),IVCT(3)
! C
!       COMPLEX*16 T11,T12,T21,T22
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 G11(MB2,MEQ),G12(MB2,MEQ),G21(MB2,MEQ),G22(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     INITIALISE THE ARRAY OF MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     TURN IX INTO A VECTOR
!       CALL NCART(IVCT,IX)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE GQLL COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQLLMK(G11,G12,G21,G22,EXL,XYZ,KQN,MQN,NBAS,1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE GQLS COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQLSMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE GQSL COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQSLMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE GQSS COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQSSMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VMOM1DV: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VMOM1DV: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     ∂/∂A_X = -∂/∂X SO WE WILL NEED AN ADDITIONAL "-"
! C
! C     FINITE SUM ADDRESSES FOR CARTESIAN OVERLAPS OF INTEREST
!       IAD0 = IABC(     0 ,     0 ,     0 )
!       IAD1 = IABC(IVCT(1),IVCT(2),IVCT(3))
! C
! C     CALCULATE WEIGHTED OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         COORDINATES OF EVALUATION (GPT OFFSET BY LOCAL ORIGIN)
!           CP = (EI*XYZ(IX,1)+EJ*XYZ(IX,2))/EIJ - CLOC(IX)
! C
! C         MULTIPLICATIVE FACTOR
!           ERT = DSQRT(PI/EIJ)**3
! C
! C         INTEGRALS FOR THIS BLOCK
!           T11 = CP*G11(M,IAD0) + G11(M,IAD1)
!           T12 = CP*G12(M,IAD0) + G12(M,IAD1)
!           T21 = CP*G21(M,IAD0) + G21(M,IAD1)
!           T22 = CP*G22(M,IAD0) + G22(M,IAD1)
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = ERT*T11
! c         VIJ(NA1+IBAS,NB2+JBAS) = ERT*T12
! c         VIJ(NA2+IBAS,NB1+JBAS) = ERT*T21
!           VIJ(NA2+IBAS,NB2+JBAS) = ERT*T22
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! C
! C     ∂/∂C_X = -∂/∂X SO WE WILL NEED AN ADDITIONAL "-"
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) =-VIJ(I,J)
!         ENDDO
!       ENDDO
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VMPL1DV(VIJ,CLOC,ITT,IQ,IX,NX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV MM       MM PPPPPPP  LL        11  DDDDDDD  VV    VV     C
! C    VV    VV MMM     MMM PP    PP LL       111  DD    DD VV    VV     C
! C    VV    VV MMMM   MMMM PP    PP LL        11  DD    DD VV    VV     C
! C    VV    VV MM MM MM MM PP    PP LL        11  DD    DD VV    VV     C
! C     VV  VV  MM  MMM  MM PPPPPPP  LL        11  DD    DD  VV  VV      C
! C      VVVV   MM   M   MM PP       LL        11  DD    DD   VVVV       C
! C       VV    MM       MM PP       LLLLLLLL 1111 DDDDDDD     VV        C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VMPL1DV CONSTRUCTS A MATRIX OF (μ,T|σ_IQ.R_IX.∇_NX/R^3|ν,T') FIELD  C
! C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATE X.          C
! C  EXAMPLE: DERIVATIVE OF THE ELECTRIC FIELD AT COORDINATE CLOC.       C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ CLOC    = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                  C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC.          C
! C  ▶ NX      = {1,2,3}   -> {X,Y,Z} CARTESIAN DERIVATIVE.              C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION CLOC(3),IVCT(3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     TURN IX INTO A VECTOR
!       CALL NCART(IVCT,IX)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
!       NDRV = 1
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)+NDRV
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+NDRV+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+NDRV+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE GQLL COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
! c        CALL GQLLMK(G11,G12,G21,G22,EXL,XYZ,KQN,MQN,NBAS,1,
! c     &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE GQLS COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQLSMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE GQSL COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQSLMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE GQSS COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL GQSSMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBAS,+1,
!      &                                               IA1,IA2,IQ,NX,'R')
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VMPL1DV: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VMPL1DV: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT C_LOC
!           CP(M,1) = CLOC(1)-PX
!           CP(M,2) = CLOC(2)-PY
!           CP(M,3) = CLOC(3)-PZ
! C
! C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
!           APH(M) = EIJ
!           PNC(M) = 2.0D0*PI/EIJ
! C
!         ENDDO
!       ENDDO
! C
! C     GENERATE A BATCH OF R-INTEGRALS (ADD ONE TO USUAL SUM ORDER)
!       CALL CPU_TIME(TDM1)
!       CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
!       CALL CPU_TIME(TDM2)
! C
! C     ADD TO RELEVANT TIME COUNTER
!       IF(ITT.EQ.1) THEN
!         TRLL = TRLL+TDM2-TDM1
!       ELSEIF(ITT.EQ.2) THEN
!         TRLS = TRLS+TDM2-TDM1
!       ELSEIF(ITT.EQ.3) THEN
!         TRSL = TRSL+TDM2-TDM1
!       ELSEIF(ITT.EQ.4) THEN
!         TRSS = TRSS+TDM2-TDM1
!       ENDIF
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
!           TA1 = DCMPLX(0.0D0,0.0D0)
!           TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER FINITE EXPANSION ADDRESSES
!           DO ITUV=1,NTUV
! C
! C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
!             IT = IA(ITUV)
!             IU = IB(ITUV)
!             IV = IC(ITUV)
! C
! C           ADD CARTESTIAN COMPONENT IX TO OVERALL ADDRESS (R-INTS)
!             ITV1 = IABC(IT+IVCT(1),IU+IVCT(2),IV+IVCT(3))
! C
! C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
!             TA1 = TA1 - G11(M,ITUV)*RC(M,ITV1)
!             TA2 = TA2 - G21(M,ITUV)*RC(M,ITV1)
! C
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE VLPLACE(VIJ,ITT,IQ,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV LL       PPPPPPP  LL          AA     CCCCCC  EEEEEEEE    C
! C    VV    VV LL       PP    PP LL         AAAA   CC    CC EE          C
! C    VV    VV LL       PP    PP LL        AA  AA  CC       EE          C
! C    VV    VV LL       PP    PP LL       AA    AA CC       EEEEEE      C
! C     VV  VV  LL       PPPPPPP  LL       AAAAAAAA CC       EE          C
! C      VVVV   LL       PP       LL       AA    AA CC    CC EE          C
! C       VV    LLLLLLLL PP       LLLLLLLL AA    AA  CCCCCC  EEEEEEEE    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VLPLACE CONSTRUCTS A MATRIX OF (μ,T|σ_Q ∇^2|ν,T') OVERLAP           C
! C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM),VTEMP(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE ARRAY OF MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J)   = DCMPLX(0.0D0,0.0D0)
!           VTEMP(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VLPLACE: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VLPLACE: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX  = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY  = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ  = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         COORDINATES OF EVALUATION
!           RPX = PX-XYZ(1,2)
!           RPY = PY-XYZ(2,2)
!           RPZ = PZ-XYZ(3,2)
!           RP2 = RPX*RPX + RPY*RPY + RPZ*RPZ
! C
! C         FACTORS
!           ERT = DSQRT(PI/EIJ)**3
!           PRE = 8.0D0*EJ*EJ
! C
! C         INTEGRALS FOR THIS BLOCK
!           IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
!             X10 = 0.5D0*RP2 + 0.75D0/EIJ - 0.25D0*(2*LQN(2)+3.0D0)/EJ
!           ELSE
!             X10 = 0.5D0*RP2 + 0.75D0/EIJ - 0.25D0*(2*LQN(2)+5.0D0)/EJ
!           ENDIF
!           TA1 = X10*E11(M,1)
!           TA2 = X10*E21(M,1)
!           IF(LQN(1)+LQN(2).GT.0) THEN
!             TA1 = TA1 + RPX*E11(M,4) + RPY*E11(M,3) + RPZ*E11(M,2)
!             TA2 = TA2 + RPX*E21(M,4) + RPY*E21(M,3) + RPZ*E21(M,2)
!           ENDIF
!           IF(LQN(1)+LQN(2).GT.1) THEN
!             TA1 = TA1 + E11(M,10) + E11(M, 7) + E11(M, 5)
!             TA2 = TA2 + E21(M,10) + E21(M, 7) + E21(M, 5)
!           ENDIF
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = ERT*PRE*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = ERT*PRE*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER MQNS
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! C
! C**********************************************************************C
! C     MODIFIED SPECIAL CODE FOR VTS ELEMENTS WITH KQN(2)>0.            C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1500 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1500 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2500 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2500 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
!         IF(MOD(KB,2).EQ.0.AND.(ITT.EQ.2.OR.ITT.EQ.4)) THEN
! C
! C         QUANTUM NUMBERS FOR BLOCK B (KQN(2)' = -KQN(2))
!           KQN(2) = KAPA(KB-1,ICNTB)
!           LQN(2) = LVAL(KQN(2))
! C
! C         BASIS EXPONENTS FOR BLOCK B
!           NBAS(2) = NFNC(LQN(2),ICNTB)
!           DO JBAS=1,NBAS(2)
!             EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!           ENDDO
! C
! C         LOOP OVER |MQN(A)| VALUES
!           DO 3500 MA=1,IABS(KQN(1))
!             MJA    = 2*MA-1
!             MQN(1) = MJA
! C
! C         LOOP OVER |MQN(B)| VALUES
!           DO 3500 MB=1,IABS(KQN(2))
!             MJB    = 2*MB-1
!             MQN(2) = MJB
! C
! C         CALCULATE COMPONENT OFFSETS (KQN(2)' = -KQN(2))
!           NA1 = LRGE(ICNTA,KA  ,2*MA-1)
!           NA2 = LRGE(ICNTA,KA  ,2*MA  )
!           NB1 = LRGE(ICNTB,KB-1,2*MB-1)
!           NB2 = LRGE(ICNTB,KB-1,2*MB  )
! C
! C         THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!           PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C         OVERLAP TYPE {LS} --> GENERATE ELLQ COEFFICIENTS
!           IF(ITT.EQ.2) THEN
!             CALL CPU_TIME(TDM1)
!             CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!             CALL CPU_TIME(TDM2)
!             TELL = TELL+TDM2-TDM1
! C         OVERLAP TYPE {SS} --> GENERATE ESLQ COEFFICIENTS
!           ELSEIF(ITT.EQ.4) THEN
!             CALL CPU_TIME(TDM1)
!             CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!             CALL CPU_TIME(TDM2)
!             TESL = TESL+TDM2-TDM1
!           ENDIF
! C
! C         CALCULATE OVERLAP MATRIX ELEMENTS
!           M = 0
!           DO IBAS=1,NBAS(1)
!             DO JBAS=1,NBAS(2)
!               M = M+1
! C
! C             EXPONENT COMBINATIONS
!               EI  = EXL(IBAS,1)
!               EJ  = EXL(JBAS,2)
!               EIJ = EI+EJ
! C
! C             FACTORS
!               PRE = 8.0D0*EJ*EJ*DSQRT(PI/EIJ)**3
! C
! C             INTEGRALS FOR THIS BLOCK
!               X10 = DSQRT((2*LQN(2)+1.0D0)/(2*LQN(2)+3.0D0))/EJ
!               TA1 = CONE*X10*E11(M,1)
!               TA2 = CONE*X10*E21(M,1)
! C
! C             MATRIX ELEMENTS
!               VTEMP(NA1+IBAS,NB1+JBAS) = PRE*TA1
!               VTEMP(NA2+IBAS,NB1+JBAS) = PRE*TA2
!               VTEMP(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(PRE*TA2)
!               VTEMP(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(PRE*TA1)
! C
!             ENDDO
!           ENDDO
! C
! C       END LOOP OVER BLOCKS IN SPECIAL CASE
! 3500    CONTINUE
! C
! C     END OF CONDITIONAL FOR SPECIAL CASE
!       ENDIF
! C
! 2500  CONTINUE
! 1500  CONTINUE
! C
! C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
!       IF(ITT.EQ.4) THEN
!         DO I=1,NDIM-NSKP
!           DO J=1,NDIM-NSKP
!             VTEMP(I,J) =-CONE*VTEMP(I,J)
!           ENDDO
!         ENDDO
!       ENDIF
! C
! C     ADD THESE TO THE VIJ ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = VIJ(I,J) + VTEMP(I,J)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     END OF MODIFIED SPECIAL CODE.                                    C
! C**********************************************************************C
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VPLNWAV(VIJ,ITT,IQ,GLOC,WAVK,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C  VV    VV PPPPPPP  LL       NN    NN WW        WW    AA    VV    VV  C
! C  VV    VV PP    PP LL       NNN   NN WW        WW   AAAA   VV    VV  C
! C  VV    VV PP    PP LL       NNNN  NN WW   WW   WW  AA  AA  VV    VV  C
! C  VV    VV PP    PP LL       NN NN NN WW  WWWW  WW AA    AA VV    VV  C
! C   VV  VV  PPPPPPP  LL       NN  NNNN WW WW  WW WW AAAAAAAA  VV  VV   C
! C    VVVV   PP       LL       NN   NNN WWWW    WWWW AA    AA   VVVV    C
! C     VV    PP       LLLLLLLL NN    NN WW        WW AA    AA    VV     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VPLNWAV CONSTRUCTS A MATRIX OF (μ,T|σ_Q exp(i.K.RG)|ν,T')           C
! C  OVERLAP INTEGRALS OVER ALL BASIS FUNCTIONS.                         C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ GLOC    = (GX,GY,GZ) -> FIXED GAUGE ORIGIN.                       C
! C  ▶ WAVK    = (KX,KY,KZ) -> PHOTON WAVE THREE-VECTOR.                 C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       DIMENSION GLOC(3),WAVK(3)
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
! C
!       COMPLEX*16 CONE,EKP,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 TMP(MBS,MBS,4)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE ARRAY OF MATRIX ELEMENTS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     SQUARE OF WAVK
!       WK2 = WAVK(1)*WAVK(1) + WAVK(2)*WAVK(2) + WAVK(3)*WAVK(3)
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C       FINITE SUM TERMINATING ORDERS
!         IF(ITT.EQ.1) THEN
!           LAM = LQN(1)+LQN(2)
!         ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!           LAM = LQN(1)+LQN(2)+1
!         ELSEIF(ITT.EQ.4) THEN
!           LAM = LQN(1)+LQN(2)+2
!         ENDIF
! C
! C       NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!         NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VPLNWAV: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VPLNWAV: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         COORDINATES OF EVALUATION
!           PGX = PX-GLOC(1)
!           PGY = PY-GLOC(2)
!           PGZ = PZ-GLOC(3)
! C
! C         FACTORS
!           ERT = DSQRT(PI/EIJ)**3
!           DKP = WAVK(1)*PGX + WAVK(2)*PGY + WAVK(3)*PGZ
!           EKP = DCOS(DKP) + CONE*DSIN(DKP)
!           EKL = DEXP(-0.25D0*WK2/EIJ)
! C
! C         LOOP OVER TERMS (A,B,C) IN FINITE EXPANSION
!           DO ITUV=1,NTUV
! C
! C           EXPANSION ADDRESSES
!             IT = IA(ITUV)
!             IU = IB(ITUV)
!             IV = IC(ITUV)
!             IL = ILAM(ITUV)
! C
! C           PRODUCT (KX)^A*(KY)^B*(KZ)^C
!             EKA = (WAVK(1)**IT)*(WAVK(2)**IU)*(WAVK(3)**IV)
! C
! C           CONTRIBUTION INVOLVES EKA, CONE**IL AND AN EQ-COEFFICIENT
!             TA1 = TA1 + (CONE**IL)*EKA*E11(M,ITUV)
!             TA2 = TA2 + (CONE**IL)*EKA*E21(M,ITUV)
! C
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = ERT*EKP*EKL*TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = ERT*EKP*EKL*TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE VNCFRCE(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV NN    NN  CCCCCC  FFFFFFFF RRRRRRR   CCCCCC  EEEEEEEE    C
! C    VV    VV NNN   NN CC    CC FF       RR    RR CC    CC EE          C
! C    VV    VV NNNN  NN CC       FF       RR    RR CC       EE          C
! C    VV    VV NN NN NN CC       FFFFFF   RR    RR CC       EEEEEE      C
! C     VV  VV  NN  NNNN CC       FF       RRRRRRR  CC       EE          C
! C      VVVV   NN   NNN CC    CC FF       RR    RR CC    CC EE          C
! C       VV    NN    NN  CCCCCC  FF       RR    RR  CCCCCC  EEEEEEEE    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VNCFRCE CONSTRUCTS A MATRIX OF   ∬ ϱ_{IZ}(r).E_{IX}(r') dr dr'      C
! C  BETWEEN A NUCLEAR CHARGE DISTRIBUTION AND A FULL SET OF BASIS FNS.  C
! C  IN CLASSICAL ELECTRODYNAMICS, IQ=0 AND ITT={1,4} FOR CHARGE DENSITY.C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ      = NUCLEAR CENTRE WHICH PROVIDES ϱ_Z CHARGE DISTRIBUTION.  C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3} -> {X,Y,Z} COMPONENT OF THE FORCE VECTOR.       C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VNCFRCE: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VNCFRCE: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     PREPARE DATA FOR BATCH OF R-INTEGRALS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EI  = EXL(IBAS,1)
!           EJ  = EXL(JBAS,2)
!           EIJ = EI+EJ
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
!           PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
!           PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
! C
! C         RELATIVE COORDINATES OF FIELD POINT
!           CP(M,1) = BXYZ(1,IZ)-PX
!           CP(M,2) = BXYZ(2,IZ)-PY
!           CP(M,3) = BXYZ(3,IZ)-PZ
! C
!         ENDDO
!       ENDDO
! C
!       IF(NMDL(IZ).EQ.'POINT') THEN
! C     POINT-NUCLEUS APPROXIMATION
! C
! C       PREPARE ELEMENTS FOR RMAKE
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           POINT-NUCLEUS EFFECTIVE PARAMETERS
!             EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!             APH(M) = EIJ
!             PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
! C
!           ENDDO
!         ENDDO
! C
! C       GENERATE A BATCH OF R-INTEGRALS
!         CALL CPU_TIME(TDM1)
!         CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
!         CALL CPU_TIME(TDM2)
! C
! C       ADD TO RELEVANT TIME COUNTER
!         IF(ITT.EQ.1) THEN
!           TRLL = TRLL+TDM2-TDM1
!         ELSEIF(ITT.EQ.2) THEN
!           TRLS = TRLS+TDM2-TDM1
!         ELSEIF(ITT.EQ.3) THEN
!           TRSL = TRSL+TDM2-TDM1
!         ELSEIF(ITT.EQ.4) THEN
!           TRSS = TRSS+TDM2-TDM1
!         ENDIF
! C
! C       CALCULATE OVERLAP MATRIX ELEMENTS
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
!             DO ITUV=1,NTUV
!               IT1 = IA(ITUV)+KRONECK(1,IX)
!               IU1 = IB(ITUV)+KRONECK(2,IX)
!               IV1 = IC(ITUV)+KRONECK(3,IX)
!               ITUV1 = IABC(IT1,IU1,IV1)
!               TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV1)
!               TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV1)
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!             VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!           ENDDO
!         ENDDO
! C
!       ELSE
! C
! C       GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
!         XI = XNUC(IZ,0)
!         FC = FNUC(IZ,0)
! C
! C       PREPARE ELEMENTS FOR RMAKE
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
!             EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!             ESM    = EIJ+XI
!             APH(M) = EIJ*XI/ESM
!             PNC(M) = 2.0D0*PI*FC*ZNUC(IZ)*DSQRT(XI/ESM)/EIJ
! C
!           ENDDO
!         ENDDO
! C
! C       GENERATE A BATCH OF R-INTEGRALS
!         CALL CPU_TIME(TDM1)
!         CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
!         CALL CPU_TIME(TDM2)
! C
! C       ADD TO RELEVANT TIME COUNTER
!         IF(ITT.EQ.1) THEN
!           TRLL = TRLL+TDM2-TDM1
!         ELSEIF(ITT.EQ.2) THEN
!           TRLS = TRLS+TDM2-TDM1
!         ELSEIF(ITT.EQ.3) THEN
!           TRSL = TRSL+TDM2-TDM1
!         ELSEIF(ITT.EQ.4) THEN
!           TRSS = TRSS+TDM2-TDM1
!         ENDIF
! C
! C       CALCULATE OVERLAP MATRIX ELEMENTS
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
!             DO ITUV=1,NTUV
!               IT1 = IA(ITUV)+KRONECK(1,IX)
!               IU1 = IB(ITUV)+KRONECK(2,IX)
!               IV1 = IC(ITUV)+KRONECK(3,IX)
!               ITUV1 = IABC(IT1,IU1,IV1)
!               TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV1)
!               TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV1)
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!             VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!           ENDDO
!         ENDDO
! C
! C       LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
!         IF(NNUC(IZ).LE.0) GOTO 100
! C       DFNOTE ABANDON FOR NOW -- THE BELOW IS FOR REGULAR GAUSSIANS
!         GOTO 100
!         DO IFT=1,NNUC(IZ)
! C
! C         GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
!           XI = XNUC(IZ,IFT)
!           FC = FNUC(IZ,IFT)
! C
! C         PREPARE ELEMENTS FOR RMAKE
!           M = 0
!           DO IBAS=1,NBAS(1)
!             DO JBAS=1,NBAS(2)
!               M = M+1
! C
! C             FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
!               EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
!               ESM    = EIJ+XI
!               APH(M) = EIJ*XI/ESM
!               PNC(M) = 2.0D0*PI*FC*ZNUC(IZ)*DSQRT(XI/ESM)/EIJ
! C
!             ENDDO
!           ENDDO
! C
! C         GENERATE A BATCH OF R-INTEGRALS
!           CALL CPU_TIME(TDM1)
!           CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
!           CALL CPU_TIME(TDM2)
! C
! C         ADD TO RELEVANT TIME COUNTER
!           IF(ITT.EQ.1) THEN
!             TRLL = TRLL+TDM2-TDM1
!           ELSEIF(ITT.EQ.2) THEN
!             TRLS = TRLS+TDM2-TDM1
!           ELSEIF(ITT.EQ.3) THEN
!             TRSL = TRSL+TDM2-TDM1
!           ELSEIF(ITT.EQ.4) THEN
!             TRSS = TRSS+TDM2-TDM1
!           ENDIF
! C
! C         CALCULATE OVERLAP MATRIX ELEMENTS
!           M = 0
!           DO IBAS=1,NBAS(1)
!             DO JBAS=1,NBAS(2)
!               M = M+1
! C
! C             SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!               TA1 = DCMPLX(0.0D0,0.0D0)
!               TA2 = DCMPLX(0.0D0,0.0D0)
!               DO ITUV=1,NTUV
!                 IT1 = IA(ITUV)+KRONECK(1,IX)
!                 IU1 = IB(ITUV)+KRONECK(2,IX)
!                 IV1 = IC(ITUV)+KRONECK(3,IX)
!                 ITUV1 = IABC(IT1,IU1,IV1)
!                 TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV1)
!                 TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV1)
!               ENDDO
! C
! C             MATRIX ELEMENTS
!               VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!               VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!               VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!               VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!             ENDDO
!           ENDDO
! C
! C       END LOOP OVER NUCLEAR BASIS FOR IZ
!         ENDDO
! 100     CONTINUE
! C
!       ENDIF
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VUEHFRCE(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV UU    UU EEEEEEEE HH    HH FFFFFFFF RRRRRRR   CCCCCC     C
! C    VV    VV UU    UU EE       HH    HH FF       RR    RR CC    CC    C
! C    VV    VV UU    UU EE       HH    HH FF       RR    RR CC          C
! C    VV    VV UU    UU EEEEEE   HHHHHHHH FFFFFF   RR    RR CC          C
! C     VV  VV  UU    UU EE       HH    HH FF       RRRRRRR  CC          C
! C      VVVV   UU    UU EE       HH    HH FF       RR    RR CC    CC    C
! C       VV     UUUUUU  EEEEEEEE HH    HH FF       RR    RR  CCCCCC     C
! C                                                                      C
! C ------------------------------------~------------------------------- C
! C  VNCFRCE CONSTRUCTS A MATRIX OF   ∬ ϱ_{IZ}(r).E_{IX}(r') dr dr'      C
! C  BETWEEN A UEHLING CHARGE DISTRIBUTION AND A FULL SET OF BASIS FNS.  C
! C  IN CLASSICAL ELECTRODYNAMICS, IQ=0 AND ITT={1,4} FOR CHARGE DENSITY.C
! C -------------------------------------------------------------------- C
! C  INPUT:                                    ~                         C
! C  ▶ IZ      = NUCLEAR CENTRE WHICH PROVIDES ϱ_Z CHARGE DISTRIBUTION.  C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IX      = {1,2,3} -> {X,Y,Z} COMPONENT OF THE FORCE VECTOR.       C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C -------------------------------------------------------------------- C
! C  CAN HAVE WKR AND KSB FORCES AS WELL, BUT RESULTS WILL BE VANISHING. C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION HABC(MB2,MEQ)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BUEE/RUEE(MCT,3),FUEE(MCT,MFT),XUEE(MCT,MFT),NUEE(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VUEHFRCE: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VUEHFRCE: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     REQUIRE ADDITIONAL HERMITE FUNCTIONS
!       LAM1  = LAM+1
!       NTUV1 = (LAM1+1)*(LAM1+2)*(LAM1+3)/6
! C
! C     LOOP OVER POLARISED DENSITY BASIS SET FOR THIS NUCLEAR CENTRE
!       DO IFT=1,NUEE(IZ)
! C
! C       GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
!         XI = XUEE(IZ,IFT)
!         FC = FUEE(IZ,IFT)
! C
! C       GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
!         M = 0
!         DO IBAS=1,NBAS(1)
!           DO JBAS=1,NBAS(2)
!             M = M+1
! C
! C           SUM OF EXPONENTS
!             EIJ  = EXL(IBAS,1)+EXL(JBAS,2)
! C
! C           COMBINED EXPONENTS (ELECTRONIC AND POLARISED DENSITY)
!             ESM = EIJ+XI
!             PAB = EIJ*XI/ESM
! C
! C           HGTF CENTRE COORDINATES
!             PX = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/EIJ
!             PY = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/EIJ
!             PZ = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/EIJ
! C
! C           COORDINATES WRT LOCAL ORIGIN
!             RPX = PX-BXYZ(1,IZ)
!             RPY = PY-BXYZ(2,IZ)
!             RPZ = PZ-BXYZ(3,IZ)
! C
! C           GAUSSIAN COMPONENT OF HGTF
!             GSS = DEXP(-PAB*(RPX*RPX+RPY*RPY+RPZ*RPZ))
! C
! C           CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
!             DO ITUV=1,NTUV1
! C
! C             HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
!               HALPH = HERMITE(PAB,RPX,IA(ITUV))
!               HBETA = HERMITE(PAB,RPY,IB(ITUV))
!               HGAMA = HERMITE(PAB,RPZ,IC(ITUV))
! C
! C             ADD TO BASIS FUNCTION PRODUCT
!               HABC(M,ITUV) = HALPH*HBETA*HGAMA*GSS
! C
!             ENDDO
! C
! C           PRE-FACTOR
!             PRE = PI/ESM
!             PRE = PRE*DSQRT(PRE)*FC
! C
! C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
!             TA1 = DCMPLX(0.0D0,0.0D0)
!             TA2 = DCMPLX(0.0D0,0.0D0)
!             DO ITUV=1,NTUV
!               IT1 = IA(ITUV)+KRONECK(1,IX)
!               IU1 = IB(ITUV)+KRONECK(2,IX)
!               IV1 = IC(ITUV)+KRONECK(3,IX)
!               ITUV1 = IABC(IT1,IU1,IV1)
!               TA1 = TA1 + PRE*E11(M,ITUV)*HABC(M,ITUV1)
!               TA2 = TA2 + PRE*E21(M,ITUV)*HABC(M,ITUV1)
!             ENDDO
! C
! C           MATRIX ELEMENTS
!             VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
!             VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
!             VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
!             VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
! C
!           ENDDO
!         ENDDO
! C
! C     END LOOP OVER NUCLEAR BASIS FOR IZ
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VPOLNUC(VIJ,IZ,ITT,IQ,IA1,IA2,VPI)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C    VV    VV PPPPPPP   OOOOOO  LL       NN    NN UU    UU  CCCCCC     C
! C    VV    VV PP    PP OO    OO LL       NNN   NN UU    UU CC    CC    C
! C    VV    VV PP    PP OO    OO LL       NNNN  NN UU    UU CC          C
! C    VV    VV PP    PP OO    OO LL       NN NN NN UU    UU CC          C
! C     VV  VV  PPPPPPP  OO    OO LL       NN  NNNN UU    UU CC          C
! C      VVVV   PP       OO    OO LL       NN   NNN UU    UU CC    CC    C
! C       VV    PP        OOOOOO  LLLLLLLL NN    NN  UUUUUU   CCCCCC     C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VPOLNUC CONSTRUCTS A MATRIX OF (μ,T|σ_Q.Vpol_IZ(r)|ν,T') VACUUM     C
! C  POLARISATION INTEGRALS OVER ALL BASIS FUNCTION PAIRS.               C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IZ      = THE NUCLEAR CENTRE THAT PRODUCES THE VACPOL POTENTIAL.  C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C  ▶ VPI     = VACPOL INTERACTION (UEH, WKR, KSB).                     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*3 VPI
!       CHARACTER*5 NMDL
! C
!       DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
!       DIMENSION FPOL(MFT),XPOL(MFT)
! C
!       COMPLEX*16 CONE,TA1,TA2
!       COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
!       COMPLEX*16 VIJ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BUEE/RUEE(MCT,3),FUEE(MCT,MFT),XUEE(MCT,MFT),NUEE(MCT)
!       COMMON/BWKR/RWKR(MCT,3),FWKR(MCT,MFT),XWKR(MCT,MFT),NWKR(MCT)
!       COMMON/BKSB/RKSB(MCT,3),FKSB(MCT,MFT),XKSB(MCT,MFT),NKSB(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
!      &            ILAM(MRC)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
!       COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
! C
! C     TRANSFER THE RIGHT EFFECTIVE POTENTIAL INTO LOCAL ARRAYS
!       IF(VPI.EQ.'UEH') THEN
!         NPOL = NUEE(IZ)
!         DO IFT=1,NUEE(IZ)
!           FPOL(IFT) = FUEE(IZ,IFT)
!           XPOL(IFT) = XUEE(IZ,IFT)
!         ENDDO
!       ELSEIF(VPI.EQ.'WKR') THEN
!         NPOL = NWKR(IZ)
!         DO IFT=1,NWKR(IZ)
!           FPOL(IFT) = FWKR(IZ,IFT)
!           XPOL(IFT) = XWKR(IZ,IFT)
!         ENDDO
!       ELSEIF(VPI.EQ.'KSB') THEN
!         NPOL = NKSB(IZ)
!         DO IFT=1,NKSB(IZ)
!           FPOL(IFT) = FKSB(IZ,IFT)
!           XPOL(IFT) = XKSB(IZ,IFT)
!         ENDDO
!       ELSE
!         WRITE(6, *) 'In VPOLNUC: supply a valid VPI.',VPI
!         WRITE(7, *) 'In VPOLNUC: supply a valid VPI.',VPI
!       ENDIF
! C
! C     UNIT IMAGINARY NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
! C**********************************************************************C
! C
! C     LOOP OVER CENTRE A
!       DO 1000 ICNTA=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE A
!         XYZ(1,1) = BXYZ(1,ICNTA)
!         XYZ(2,1) = BXYZ(2,ICNTA)
!         XYZ(3,1) = BXYZ(3,ICNTA)
! C
! C     LOOP OVER CENTRE B
!       DO 1000 ICNTB=1,NCNT
! C
! C       CARTESIAN COORDINATES OF CENTRE B
!         XYZ(1,2) = BXYZ(1,ICNTB)
!         XYZ(2,2) = BXYZ(2,ICNTB)
!         XYZ(3,2) = BXYZ(3,ICNTB)
! C
! C**********************************************************************C
! C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
! C**********************************************************************C
! C
! C     LOOP OVER KQN(A) VALUES
!       DO 2000 KA=1,NKAP(ICNTA)
! C
! C       QUANTUM NUMBERS FOR BLOCK A
!         KQN(1) = KAPA(KA,ICNTA)
!         LQN(1) = LVAL(KQN(1))
! C
! C       BASIS EXPONENTS FOR BLOCK A
!         NBAS(1) = NFNC(LQN(1),ICNTA)
!         DO IBAS=1,NBAS(1)
!           EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
!         ENDDO
! C
! C     LOOP OVER KQN(B) VALUES
!       DO 2000 KB=1,NKAP(ICNTB)
! C
! C       QUANTUM NUMBERS FOR BLOCK B
!         KQN(2) = KAPA(KB,ICNTB)
!         LQN(2) = LVAL(KQN(2))
! C
! C       BASIS EXPONENTS FOR BLOCK B
!         NBAS(2) = NFNC(LQN(2),ICNTB)
!         DO JBAS=1,NBAS(2)
!           EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
!         ENDDO
! C
! C     FINITE SUM TERMINATING ORDERS
!       IF(ITT.EQ.1) THEN
!         LAM = LQN(1)+LQN(2)
!       ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         LAM = LQN(1)+LQN(2)+1
!       ELSEIF(ITT.EQ.4) THEN
!         LAM = LQN(1)+LQN(2)+2
!       ENDIF
! C
! C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
!       NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
! C
! C**********************************************************************C
! C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
! C**********************************************************************C
! C
! C     LOOP OVER |MQN(A)| VALUES
!       DO 3000 MA=1,IABS(KQN(1))
!         MJA    = 2*MA-1
!         MQN(1) = MJA
! C
! C     LOOP OVER |MQN(B)| VALUES
!       DO 3000 MB=1,IABS(KQN(2))
!         MJB    = 2*MB-1
!         MQN(2) = MJB
! C
! C**********************************************************************C
! C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
! C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
! C -------------------------------------------------------------------- C
! C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
! C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
! C**********************************************************************C
! C
! C     CALCULATE COMPONENT OFFSETS
!       NA1 = LRGE(ICNTA,KA,2*MA-1)
!       NA2 = LRGE(ICNTA,KA,2*MA  )
!       NB1 = LRGE(ICNTB,KB,2*MB-1)
!       NB2 = LRGE(ICNTB,KB,2*MB  )
! C
! C     THIS PHASE RELATES EQ22 AND EQ12 COEFFS TO EQ11 AND EQ21
!       PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
!      &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
! C
! C**********************************************************************C
! C     GENERATE OVERLAP MATRICES                                        C
! C**********************************************************************C
! C
! C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
!       IF(ITT.EQ.1) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELL = TELL+TDM2-TDM1
! C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.2) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TELS = TELS+TDM2-TDM1
! C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
!       ELSEIF(ITT.EQ.3) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESL = TESL+TDM2-TDM1
! C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
!       ELSEIF(ITT.EQ.4) THEN
!         CALL CPU_TIME(TDM1)
!         CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
!         CALL CPU_TIME(TDM2)
!         TESS = TESS+TDM2-TDM1
!       ELSE
!         WRITE(6, *) 'In VPOLNUC: allowed values are ITT = {1,2,3,4}'
!         WRITE(7, *) 'In VPOLNUC: allowed values are ITT = {1,2,3,4}'
!         WRITE(6, *) 'ITT = ',ITT
!         WRITE(7, *) 'ITT = ',ITT
!         STOP
!       ENDIF
! C
! C     CALCULATE OVERLAP MATRIX ELEMENTS
!       M = 0
!       DO IBAS=1,NBAS(1)
!         DO JBAS=1,NBAS(2)
!           M = M+1
! C
! C         EXPONENT COMBINATIONS
!           EIJ = EXL(IBAS,1)+EXL(JBAS,2)
! C
! C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
!           PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
!           PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
!           PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
! C
! C         COORDINATES OF EVALUATION
!           RPX = PX-BXYZ(1,IZ)
!           RPY = PY-BXYZ(2,IZ)
!           RPZ = PZ-BXYZ(3,IZ)
!           RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
! C
! C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
!           TA1 = DCMPLX(0.0D0,0.0D0)
!           TA2 = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER TERMS IN THE POLARISATION POTENTIAL EXPANSION FOR IZ
!           DO IFT=1,NPOL
! C
! C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
!             XI = XPOL(IFT)
!             FC = FPOL(IFT)
! C
! C           GAUSSIAN COMPONENT OF HGTF
!             ESM = EIJ+XI
!             E12 = PI12/DSQRT(ESM)
!             E32 = E12*E12*E12
!             ECP = EIJ*XI/ESM
!             GSS = DEXP(-ECP*RSQ)
! C
! C           LOOP OVER ALL {A,B,C}
!             DO ITUV=1,NTUV
! C
! C             CARTESIAN HERMITE POLYNOMIAL VALUES
!               HALPH = HERMITE(ECP,RPX,IA(ITUV))
!               HBETA = HERMITE(ECP,RPY,IB(ITUV))
!               HGAMA = HERMITE(ECP,RPZ,IC(ITUV))
! C
! C             HGTF IS A PRODUCT OF THESE
!               HABC = HALPH*HBETA*HGAMA*GSS
! C
! C             MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
!               TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,ITUV)*HABC
!               TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,ITUV)*HABC
! C
!             ENDDO
! C
! C         END LOOP OVER POLARISATION EXPANSION FOR IZ
!           ENDDO
! C
! C         MATRIX ELEMENTS
!           VIJ(NA1+IBAS,NB1+JBAS) = TA1
!           VIJ(NA2+IBAS,NB1+JBAS) = TA2
!           VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
!           VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
! C
!         ENDDO
!       ENDDO
! C
! C     END LOOP OVER CENTRES A AND B
! 3000  CONTINUE
! 2000  CONTINUE
! 1000  CONTINUE
! CC
! CC     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
! C      IF(ITT.EQ.2) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) = CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
! CC     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
! C      IF(ITT.EQ.3) THEN
! C        DO I=1,NDIM-NSKP
! C          DO J=1,NDIM-NSKP
! C            VIJ(I,J) =-CONE*VIJ(I,J)
! C          ENDDO
! C        ENDDO
! C      ENDIF
! CC
!       RETURN
!       END
! C
! C
!       SUBROUTINE OVERLAP(IOCC)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C     OOOOOO  VV    VV EEEEEEEE RRRRRRR  LL          AA    PPPPPPP     C
! C    OO    OO VV    VV EE       RR    RR LL         AAAA   PP    PP    C
! C    OO    OO VV    VV EE       RR    RR LL        AA  AA  PP    PP    C
! C    OO    OO VV    VV EEEEEE   RR    RR LL       AA    AA PP    PP    C
! C    OO    OO  VV  VV  EE       RRRRRRR  LL       AAAAAAAA PPPPPPP     C
! C    OO    OO   VVVV   EE       RR    RR LL       AA    AA PP          C
! C     OOOOOO     VV    EEEEEEEE RR    RR LLLLLLLL AA    AA PP          C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  OVERLAP TESTS THE OVERLAP PROPERTIES OF A SPINOR OVER THE COMPLETE  C
! C  BASIS SET OF NEGATIVE/POSITIVE ENERGY STATES:                       C
! C                                                                      C
! C                O_q(IOCC) = Σ_n <IOCC|αq|n><n|αq|IOCC>                C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IOCC = OCCUPIED STATE (AUTOMATICALLY SHIFTED).                    C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       COMPLEX*16 CONE
!       COMPLEX*16 T00,TXX,TYY,TZZ
!       COMPLEX*16 DLL,DLS,DSL,DSS
!       COMPLEX*16 ETOT(0:4,5,3)
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 VIJ(MDM,MDM)
!       COMPLEX*16 V00(MDM,MDM,2),VXX(MDM,MDM,2),
!      &           VYY(MDM,MDM,2),VZZ(MDM,MDM,2)
!       COMPLEX*16 OLL0(MDM,MDM),OSS0(MDM,MDM)
!       COMPLEX*16 OLSX(MDM,MDM),OLSY(MDM,MDM),OLSZ(MDM,MDM)
!       COMPLEX*16 OSLX(MDM,MDM),OSLY(MDM,MDM),OSLZ(MDM,MDM)
!       COMPLEX*16 VLL0(MDM,MDM),VSS0(MDM,MDM)
!       COMPLEX*16 VLSX(MDM,MDM),VLSY(MDM,MDM),VLSZ(MDM,MDM)
!       COMPLEX*16 VSLX(MDM,MDM),VSLY(MDM,MDM),VSLZ(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/EIGC/COEF
!       COMMON/OTTI/OLSX,OLSY,OLSZ,OSLX,OSLY,OSLZ
! C
! C     UNIT COMPLEX NUMBER
!       CONE = DCMPLX(0.0D0,1.0D0)
! C
! C     GENERATE FULL SET OF OVERLAP INTEGRALS
!       CALL VMOMNT0(OLL0,1,0,1,2)
!       CALL VMOMNT0(OSS0,4,0,1,2)
!       CALL VMOMNT0(OLSX,2,1,1,2)
!       CALL VMOMNT0(OLSY,2,2,1,2)
!       CALL VMOMNT0(OLSZ,2,3,1,2)
!       CALL VMOMNT0(OSLX,3,1,1,2)
!       CALL VMOMNT0(OSLY,3,2,1,2)
!       CALL VMOMNT0(OSLZ,3,3,1,2)
! C
!       DO I=0,4
!         DO J=1,5
!           DO K=1,3
!             ETOT(I,J,K) = DCMPLX(0.0D0,0.0D0)
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!           DO K=1,2
!             VXX(I,J,K) = DCMPLX(0.0D0,0.0D0)
!             VYY(I,J,K) = DCMPLX(0.0D0,0.0D0)
!             VZZ(I,J,K) = DCMPLX(0.0D0,0.0D0)
!             V00(I,J,K) = DCMPLX(0.0D0,0.0D0)
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     GENERATE MATRIX ELEMENTS <I|SIG|N> FOR ALL N
!       DO I=1,NDIM-NSKP
! C
! C       LOOP OVER STATES N
!         DO N=1,NDIM
! C
! C         INITIALISE THESE MATRIX ELEMENTS
!           VLL0(I,N) = DCMPLX(0.0D0,0.0D0)
!           VSS0(I,N) = DCMPLX(0.0D0,0.0D0)
!           VLSX(I,N) = DCMPLX(0.0D0,0.0D0)
!           VLSY(I,N) = DCMPLX(0.0D0,0.0D0)
!           VLSZ(I,N) = DCMPLX(0.0D0,0.0D0)
!           VSLX(I,N) = DCMPLX(0.0D0,0.0D0)
!           VSLY(I,N) = DCMPLX(0.0D0,0.0D0)
!           VSLZ(I,N) = DCMPLX(0.0D0,0.0D0)
! C
! C         CONTRACT OVER COEFFICIENTS AND RAW MATRIX ELEMENTS
!           DO L=1,NDIM-NSKP
! C
! C           <I,L|SIG_0|N,L>
!             VLL0(I,N) = VLL0(I,N) + COEF(L     ,N)*OLL0(I,L)
! C
! C           <I,S|SIG_0|N,S>
!             VSS0(I,N) = VSS0(I,N) + COEF(L+NSKP,N)*OSS0(I,L)
! C
! C           <I,L|SIG_X|N,S>
!             VLSX(I,N) = VLSX(I,N) + COEF(L+NSKP,N)*OLSX(I,L)
!             VLSY(I,N) = VLSY(I,N) + COEF(L+NSKP,N)*OLSY(I,L)
!             VLSZ(I,N) = VLSZ(I,N) + COEF(L+NSKP,N)*OLSZ(I,L)
! C
! C           <I,S|SIG_X|N,L>
!             VSLX(I,N) = VSLX(I,N) + COEF(L     ,N)*OSLX(I,L)
!             VSLY(I,N) = VSLY(I,N) + COEF(L     ,N)*OSLY(I,L)
!             VSLZ(I,N) = VSLZ(I,N) + COEF(L     ,N)*OSLZ(I,L)
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C     CONTRACT OVER OCCUPIED STATE TO FIND OVERLAPS
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
! C         ITT = 1
!           V00(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           V00(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VXX(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VXX(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VYY(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VYY(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VZZ(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VZZ(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           DO N=1,NDIM-NSKP
! C
! C           <I,L|SIG_0|N,L><N,L|SIG_0|I,L>
!             T00 = VLL0(I,N     )*DCONJG(VLL0(J,N     ))
!             V00(I,J,1) = V00(I,J,1) + T00
! C
!             T00 = VLL0(I,N+NSKP)*DCONJG(VLL0(J,N+NSKP))
!             V00(I,J,2) = V00(I,J,2) + T00
! C
! C           <I,L|SIG_X|N,S><N,S|SIG_X|I,L>
!             TXX = VLSX(I,N     )*DCONJG(VLSX(J,N     ))
!             VXX(I,J,1) = VXX(I,J,1) + TXX
! C
!             TXX = VLSX(I,N+NSKP)*DCONJG(VLSX(J,N+NSKP))
!             VXX(I,J,2) = VXX(I,J,2) + TXX
! C
! C           <I,L|SIG_Y|N,S><N,S|SIG_Y|I,L>
!             TYY = VLSY(I,N     )*DCONJG(VLSY(J,N     ))
!             VYY(I,J,1) = VYY(I,J,1) + TYY
! C
!             TYY = VLSY(I,N+NSKP)*DCONJG(VLSY(J,N+NSKP))
!             VYY(I,J,2) = VYY(I,J,2) + TYY
! C
! C           <I,L|SIG_Z|N,S><N,S|SIG_Z|I,L>
!             TZZ = VLSZ(I,N     )*DCONJG(VLSZ(J,N     ))
!             VZZ(I,J,1) = VZZ(I,J,1) + TZZ
! C
!             TZZ = VLSZ(I,N+NSKP)*DCONJG(VLSZ(J,N+NSKP))
!             VZZ(I,J,2) = VZZ(I,J,2) + TZZ
! C
!           ENDDO
! C
! C         LARGE-LARGE DENSITY FOR IOCC
!           DLL = DCONJG(COEF(I     ,IOCC+NSKP))*COEF(J     ,IOCC+NSKP)
! C
!           ETOT(0,1,1) = ETOT(0,1,1) + DLL*V00(I,J,1)
!           ETOT(0,1,2) = ETOT(0,1,2) + DLL*V00(I,J,2)
! C
!           ETOT(1,1,1) = ETOT(1,1,1) + DLL*VXX(I,J,1)
!           ETOT(1,1,2) = ETOT(1,1,2) + DLL*VXX(I,J,2)
! C
!           ETOT(2,1,1) = ETOT(2,1,1) + DLL*VYY(I,J,1)
!           ETOT(2,1,2) = ETOT(2,1,2) + DLL*VYY(I,J,2)
! C
!           ETOT(3,1,1) = ETOT(3,1,1) + DLL*VZZ(I,J,1)
!           ETOT(3,1,2) = ETOT(3,1,2) + DLL*VZZ(I,J,2)
! C
! C         ITT = 2
!           V00(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           V00(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VXX(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VXX(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VYY(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VYY(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VZZ(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VZZ(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           DO N=1,NDIM-NSKP
! C
! C           <I,L|SIG_0|N,L><N,S|SIG_0|I,S>
!             T00 = VLL0(I,N     )*DCONJG(VSS0(J,N     ))
!             V00(I,J,1) = V00(I,J,1) + T00
! C
!             T00 = VLL0(I,N+NSKP)*DCONJG(VSS0(J,N+NSKP))
!             V00(I,J,2) = V00(I,J,2) + T00
! C
! C           <I,L|SIG_X|N,S><N,L|SIG_X|I,S>
!             TXX = VLSX(I,N     )*DCONJG(VSLX(J,N     ))
!             VXX(I,J,1) = VXX(I,J,1) + TXX
! C
!             TXX = VLSX(I,N+NSKP)*DCONJG(VSLX(J,N+NSKP))
!             VXX(I,J,2) = VXX(I,J,2) + TXX
! C
! C           <I,L|SIG_Y|N,S><N,L|SIG_Y|I,S>
!             TYY = VLSY(I,N     )*DCONJG(VSLY(J,N     ))
!             VYY(I,J,1) = VYY(I,J,1) + TYY
! C
!             TYY = VLSY(I,N+NSKP)*DCONJG(VSLY(J,N+NSKP))
!             VYY(I,J,2) = VYY(I,J,2) + TYY
! C
! C           <I,L|SIG_Z|N,S><N,L|SIG_Z|I,S>
!             TZZ = VLSZ(I,N     )*DCONJG(VSLZ(J,N     ))
!             VZZ(I,J,1) = VZZ(I,J,1) + TZZ
! C
!             TZZ = VLSZ(I,N+NSKP)*DCONJG(VSLZ(J,N+NSKP))
!             VZZ(I,J,2) = VZZ(I,J,2) + TZZ
! C
!           ENDDO
! C
! C         LARGE-SMALL DENSITY FOR IOCC
!           DLS = DCONJG(COEF(I     ,IOCC+NSKP))*COEF(J+NSKP,IOCC+NSKP)
! C
!           ETOT(0,2,1) = ETOT(0,2,1) + DLS*V00(I,J,1)
!           ETOT(0,2,2) = ETOT(0,2,2) + DLS*V00(I,J,2)
! C
!           ETOT(1,2,1) = ETOT(1,2,1) + DLS*VXX(I,J,1)
!           ETOT(1,2,2) = ETOT(1,2,2) + DLS*VXX(I,J,2)
! C
!           ETOT(2,2,1) = ETOT(2,2,1) + DLS*VYY(I,J,1)
!           ETOT(2,2,2) = ETOT(2,2,2) + DLS*VYY(I,J,2)
! C
!           ETOT(3,2,1) = ETOT(3,2,1) + DLS*VZZ(I,J,1)
!           ETOT(3,2,2) = ETOT(3,2,2) + DLS*VZZ(I,J,2)
! C
! C         ITT = 3
!           V00(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           V00(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VXX(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VXX(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VYY(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VYY(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VZZ(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VZZ(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           DO N=1,NDIM-NSKP
! C
! C           <I,S|SIG_0|N,S><N,L|SIG_0|I,L>
!             T00 = VSS0(I,N     )*DCONJG(VLL0(J,N     ))
!             V00(I,J,1) = V00(I,J,1) + T00
! C
!             T00 = VSS0(I,N+NSKP)*DCONJG(VLL0(J,N+NSKP))
!             V00(I,J,2) = V00(I,J,2) + T00
! C
! C           <I,S|SIG_X|N,L><N,S|SIG_X|I,L>
!             TXX = VSLX(I,N     )*DCONJG(VLSX(J,N     ))
!             VXX(I,J,1) = VXX(I,J,1) + TXX
! C
!             TXX = VSLX(I,N+NSKP)*DCONJG(VLSX(J,N+NSKP))
!             VXX(I,J,2) = VXX(I,J,2) + TXX
! C
! C           <I,S|SIG_Y|N,L><N,S|SIG_Y|I,L>
!             TYY = VSLY(I,N     )*DCONJG(VLSY(J,N     ))
!             VYY(I,J,1) = VYY(I,J,1) + TYY
! C
!             TYY = VSLY(I,N+NSKP)*DCONJG(VLSY(J,N+NSKP))
!             VYY(I,J,2) = VYY(I,J,2) + TYY
! C
! C           <I,S|SIG_Z|N,L><N,S|SIG_Z|I,L>
!             TZZ = VSLZ(I,N     )*DCONJG(VLSZ(J,N     ))
!             VZZ(I,J,1) = VZZ(I,J,1) + TZZ
! C
!             TZZ = VSLZ(I,N+NSKP)*DCONJG(VLSZ(J,N+NSKP))
!             VZZ(I,J,2) = VZZ(I,J,2) + TZZ
! C
!           ENDDO
! C
! C         SMALL-LARGE DENSITY FOR IOCC
!           DSL = DCONJG(COEF(I+NSKP,IOCC+NSKP))*COEF(J     ,IOCC+NSKP)
! C
!           ETOT(0,3,1) = ETOT(0,3,1) + DSL*V00(I,J,1)
!           ETOT(0,3,2) = ETOT(0,3,2) + DSL*V00(I,J,2)
! C
!           ETOT(1,3,1) = ETOT(1,3,1) + DSL*VXX(I,J,1)
!           ETOT(1,3,2) = ETOT(1,3,2) + DSL*VXX(I,J,2)
! C
!           ETOT(2,3,2) = ETOT(2,3,2) + DSL*VYY(I,J,2)
!           ETOT(2,3,1) = ETOT(2,3,1) + DSL*VYY(I,J,1)
! C
!           ETOT(3,3,1) = ETOT(3,3,1) + DSL*VZZ(I,J,1)
!           ETOT(3,3,2) = ETOT(3,3,2) + DSL*VZZ(I,J,2)
! C
! C         ITT = 4
!           V00(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           V00(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VXX(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VXX(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VYY(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VYY(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           VZZ(I,J,1) = DCMPLX(0.0D0,0.0D0)
!           VZZ(I,J,2) = DCMPLX(0.0D0,0.0D0)
!           DO N=1,NDIM-NSKP
! C
! C           <I,S|SIG_0|N,S><N,S|SIG_0|I,S>
!             T00 = VSS0(I,N     )*DCONJG(VSS0(J,N     ))
!             V00(I,J,1) = V00(I,J,1) + T00
! C
!             T00 = VSS0(I,N+NSKP)*DCONJG(VSS0(J,N+NSKP))
!             V00(I,J,2) = V00(I,J,2) + T00
! C
! C           <I,S|SIG_X|N,L><N,L|SIG_X|I,S>
!             TXX = VSLX(I,N     )*DCONJG(VSLX(J,N     ))
!             VXX(I,J,1) = VXX(I,J,1) + TXX
! C
!             TXX = VSLX(I,N+NSKP)*DCONJG(VSLX(J,N+NSKP))
!             VXX(I,J,2) = VXX(I,J,2) + TXX
! C
! C           <I,S|SIG_Y|N,L><N,L|SIG_Y|I,S>
!             TYY = VSLY(I,N     )*DCONJG(VSLY(J,N     ))
!             VYY(I,J,1) = VYY(I,J,1) + TYY
! C
!             TYY = VSLY(I,N+NSKP)*DCONJG(VSLY(J,N+NSKP))
!             VYY(I,J,2) = VYY(I,J,2) + TYY
! C
! C           <I,S|SIG_Z|N,L><N,L|SIG_Z|I,S>
!             TZZ = VSLZ(I,N     )*DCONJG(VSLZ(J,N     ))
!             VZZ(I,J,1) = VZZ(I,J,1) + TZZ
! C
!             TZZ = VSLZ(I,N+NSKP)*DCONJG(VSLZ(J,N+NSKP))
!             VZZ(I,J,2) = VZZ(I,J,2) + TZZ
! C
!           ENDDO
! C
! C         SMALL-SMALL DENSITY FOR IOCC
!           DSS = DCONJG(COEF(I+NSKP,IOCC+NSKP))*COEF(J+NSKP,IOCC+NSKP)
! C
!           ETOT(0,4,1) = ETOT(0,4,1) + DSS*V00(I,J,1)
!           ETOT(0,4,2) = ETOT(0,4,2) + DSS*V00(I,J,2)
! C
!           ETOT(1,4,1) = ETOT(1,4,1) + DSS*VXX(I,J,1)
!           ETOT(1,4,2) = ETOT(1,4,2) + DSS*VXX(I,J,2)
! C
!           ETOT(2,4,1) = ETOT(2,4,1) + DSS*VYY(I,J,1)
!           ETOT(2,4,2) = ETOT(2,4,2) + DSS*VYY(I,J,2)
! C
!           ETOT(3,4,1) = ETOT(3,4,1) + DSS*VZZ(I,J,1)
!           ETOT(3,4,2) = ETOT(3,4,2) + DSS*VZZ(I,J,2)
! C
!         ENDDO
!       ENDDO
! C
! C     POSITIVE + NEGATIVE
!       DO I=0,3
!         DO ITT=1,4
!           ETOT(I,ITT,3) = ETOT(I,ITT,1) + ETOT(I,ITT,2)
!         ENDDO
!       ENDDO
! C
! C     SUM OF CARTESIAN COMPONENTS
!       DO ITT=1,4
!         DO IX=1,3
!           ETOT(4,ITT,1) = ETOT(4,ITT,1) + ETOT(IX,ITT,1)
!           ETOT(4,ITT,2) = ETOT(4,ITT,2) + ETOT(IX,ITT,2)
!           ETOT(4,ITT,3) = ETOT(4,ITT,3) + ETOT(IX,ITT,3)
!         ENDDO      
!       ENDDO
! C
! C     SUM OF ALL COMPONENT TYPES
!       DO I=0,4
!         DO J=1,4
!           DO K=1,3
!             ETOT(I,5,K) = ETOT(I,5,K) + ETOT(I,J,K)
!           ENDDO
!         ENDDO
!       ENDDO
! C
!       NLNES = 121
! 50    FORMAT(12X,A,2X,A,2X,A,2X,A,2X,'|  ',A)
! 51    FORMAT(1X,A,I1,' |',4(2X,ES20.12),' |  ',ES20.12)
! 52    FORMAT(1X,A,' |',4(2X,ES20.12),' |  ',ES20.12)
! C
!       WRITE(6, *) REPEAT('*',121)
!       WRITE(7, *) REPEAT('*',121)
!       WRITE(6, *) REPEAT(' ', 53),'NEGATIVE-ENERGY'
!       WRITE(7, *) REPEAT(' ', 53),'NEGATIVE-ENERGY'
!       WRITE(6, *) REPEAT('*',121)
!       WRITE(7, *) REPEAT('*',121)
!       WRITE(6, *)
!       WRITE(7, *)
!       WRITE(6, *) 'REAL'
!       WRITE(7, *) 'REAL'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       WRITE(6,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(7,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       DO ITT=1,4
!         WRITE(6,51) 'ITT = ',ITT,(DREAL(ETOT(I,ITT,1)),I=0,4)
!         WRITE(7,51) 'ITT = ',ITT,(DREAL(ETOT(I,ITT,1)),I=0,4)
!       ENDDO
!       WRITE(6, *) REPEAT('-',NLNES)
!       WRITE(7, *) REPEAT('-',NLNES)
!       WRITE(6,52) 'TOTAL  ',(DREAL(ETOT(I,5,1)),I=0,4)
!       WRITE(7,52) 'TOTAL  ',(DREAL(ETOT(I,5,1)),I=0,4)
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)

!       WRITE(6, *)
!       WRITE(7, *)
!       WRITE(6, *) 'IMAGINARY'
!       WRITE(7, *) 'IMAGINARY'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       WRITE(6,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(7,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       DO ITT=1,4
!         WRITE(6,51) 'ITT = ',ITT,(DIMAG(ETOT(I,ITT,1)),I=0,4)
!         WRITE(7,51) 'ITT = ',ITT,(DIMAG(ETOT(I,ITT,1)),I=0,4)
!       ENDDO
!       WRITE(6, *) REPEAT('-',NLNES)
!       WRITE(7, *) REPEAT('-',NLNES)
!       WRITE(6,52) 'TOTAL  ',(DIMAG(ETOT(I,5,1)),I=0,4)
!       WRITE(7,52) 'TOTAL  ',(DIMAG(ETOT(I,5,1)),I=0,4)
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
! C
!       WRITE(6, *)
!       WRITE(7, *)
!       WRITE(6, *) REPEAT('*',121)
!       WRITE(7, *) REPEAT('*',121)
!       WRITE(6, *) REPEAT(' ', 53),'POSITIVE-ENERGY'
!       WRITE(7, *) REPEAT(' ', 53),'POSITIVE-ENERGY'
!       WRITE(6, *) REPEAT('*',121)
!       WRITE(7, *) REPEAT('*',121)
!       WRITE(6, *)
!       WRITE(7, *)
!       WRITE(6, *) 'REAL'
!       WRITE(7, *) 'REAL'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       WRITE(6,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(7,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       DO ITT=1,4
!         WRITE(6,51) 'ITT = ',ITT,(DREAL(ETOT(I,ITT,2)),I=0,4)
!         WRITE(7,51) 'ITT = ',ITT,(DREAL(ETOT(I,ITT,2)),I=0,4)
!       ENDDO
!       WRITE(6, *) REPEAT('-',NLNES)
!       WRITE(7, *) REPEAT('-',NLNES)
!       WRITE(6,52) 'TOTAL  ',(DREAL(ETOT(I,5,2)),I=0,4)
!       WRITE(7,52) 'TOTAL  ',(DREAL(ETOT(I,5,2)),I=0,4)
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)

!       WRITE(6, *)
!       WRITE(7, *)
!       WRITE(6, *) 'IMAGINARY'
!       WRITE(7, *) 'IMAGINARY'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       WRITE(6,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(7,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       DO ITT=1,4
!         WRITE(6,51) 'ITT = ',ITT,(DIMAG(ETOT(I,ITT,2)),I=0,4)
!         WRITE(7,51) 'ITT = ',ITT,(DIMAG(ETOT(I,ITT,2)),I=0,4)
!       ENDDO
!       WRITE(6, *) REPEAT('-',NLNES)
!       WRITE(7, *) REPEAT('-',NLNES)
!       WRITE(6,52) 'TOTAL  ',(DIMAG(ETOT(I,5,2)),I=0,4)
!       WRITE(7,52) 'TOTAL  ',(DIMAG(ETOT(I,5,2)),I=0,4)
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
! C
!       WRITE(6, *)
!       WRITE(7, *)
!       WRITE(6, *) REPEAT('*',121)
!       WRITE(7, *) REPEAT('*',121)
!       WRITE(6, *) REPEAT(' ', 58),'TOTAL'
!       WRITE(7, *) REPEAT(' ', 58),'TOTAL'
!       WRITE(6, *) REPEAT('*',121)
!       WRITE(7, *) REPEAT('*',121)
!       WRITE(6, *)
!       WRITE(7, *)
!       WRITE(6, *) 'REAL'
!       WRITE(7, *) 'REAL'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       WRITE(6,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(7,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       DO ITT=1,4
!         WRITE(6,51) 'ITT = ',ITT,(DREAL(ETOT(I,ITT,3)),I=0,4)
!         WRITE(7,51) 'ITT = ',ITT,(DREAL(ETOT(I,ITT,3)),I=0,4)
!       ENDDO
!       WRITE(6, *) REPEAT('-',NLNES)
!       WRITE(7, *) REPEAT('-',NLNES)
!       WRITE(6,52) 'TOTAL  ',(DREAL(ETOT(I,5,3)),I=0,4)
!       WRITE(7,52) 'TOTAL  ',(DREAL(ETOT(I,5,3)),I=0,4)
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)

!       WRITE(6, *)
!       WRITE(7, *)
!       WRITE(6, *) 'IMAGINARY'
!       WRITE(7, *) 'IMAGINARY'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       WRITE(6,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(7,50) 'Σ_n <m|α0|n><n|α0|m>','Σ_n <m|αx|n><n|αx|m>',
!      &            'Σ_n <m|αy|n><n|αy|m>','Σ_n <m|αz|n><n|αz|m>',
!      &            'Σ_n <m|α|n>·<n|α|m>'
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
!       DO ITT=1,4
!         WRITE(6,51) 'ITT = ',ITT,(DIMAG(ETOT(I,ITT,3)),I=0,4)
!         WRITE(7,51) 'ITT = ',ITT,(DIMAG(ETOT(I,ITT,3)),I=0,4)
!       ENDDO
!       WRITE(6, *) REPEAT('-',NLNES)
!       WRITE(7, *) REPEAT('-',NLNES)
!       WRITE(6,52) 'TOTAL  ',(DIMAG(ETOT(I,5,3)),I=0,4)
!       WRITE(7,52) 'TOTAL  ',(DIMAG(ETOT(I,5,3)),I=0,4)
!       WRITE(6, *) REPEAT('=',NLNES)
!       WRITE(7, *) REPEAT('=',NLNES)
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VSLFLWB(VLL,VLS,VSL,VSS,IOCC)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C  VV    VV  SSSSSS  LL       FFFFFFFF LL       WW        WW BBBBBBB   C
! C  VV    VV SS    SS LL       FF       LL       WW        WW BB    BB  C
! C  VV    VV SS       LL       FF       LL       WW   WW   WW BB    BB  C
! C  VV    VV  SSSSSS  LL       FFFFFF   LL       WW  WWWW  WW BBBBBBB   C
! C   VV  VV        SS LL       FF       LL       WW WW  WW WW BB    BB  C
! C    VVVV   SS    SS LL       FF       LL       WWWW    WWWW BB    BB  C
! C     VV     SSSSSS  LLLLLLLL FF       LLLLLLLL WW        WW BBBBBBB   C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VSLFLWB CONSTRUCTS A MATRIX OF (μ,T|σ_Q.Vslf|ν,T') ELECTRON SELF-   C
! C  INTERACTION INTEGRALS OVER ALL BASIS FUNCTION PAIRS (BETHE METHOD). C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ IOCC    = OCCUPIED STATE (AUTOMATICALLY SHIFTED).                 C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*1 CHL,LLAB
!       CHARACTER*5 NMDL
! C
!       DIMENSION RKNT(MDM)
!       DIMENSION IORD(MDM)
!       dimension tally(mbs)
! C
!       COMPLEX*16 TSM
!       COMPLEX*16 CL,CS
!       COMPLEX*16 EX(MDM,4),EY(MDM,4),EZ(MDM,4),ET(MDM,4)
!       COMPLEX*16 VLL(MDM,MDM),VLS(MDM,MDM),VSL(MDM,MDM),VSS(MDM,MDM)
!       COMPLEX*16 COEF(MDM,MDM)
!       COMPLEX*16 OLSX(MDM,MDM),OLSY(MDM,MDM),OLSZ(MDM,MDM),
!      &           OSLX(MDM,MDM),OSLY(MDM,MDM),OSLZ(MDM,MDM)
!       COMPLEX*16 PINLSX(MDM,MDM),PINLSY(MDM,MDM),PINLSZ(MDM,MDM)
!       COMPLEX*16 PINSLX(MDM,MDM),PINSLY(MDM,MDM),PINSLZ(MDM,MDM)
!       COMPLEX*16 WLS(MDM,3),WSL(MDM,3)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/EIGC/COEF
!       COMMON/EIGE/EIGN(MDM)
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
!       COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
!       COMMON/SPEC/KQNLST(MDM),MQNLST(MDM),NQNLST(MDM)
!       COMMON/OTTI/OLSX,OLSY,OLSZ,OSLX,OSLY,OSLZ
! C
!       DATA EPS/1.0D-2/
! C
! C     SET THE LOW-ENERGY CUTOFF TO M*CV FOR NOW
!       CUTK = CV
! C
! C     AMPLITUDE FOR LOW-ENERGY CONTRIBUTION
!       ALW =-2.0D0/(3.0D0*PI*CV)
! C
! C     INITIALISE STORAGE ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VLL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSS(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     SERIES OF ENERGY DIFFERENCES
!       EM = EIGN(IOCC+NSKP)
!       DO N=1,NDIM-NSKP
!         EDIF = EM-EIGN(N+NSKP)
!         ARGL = (CUTK*CV-EDIF)/DABS(EDIF)
!         IF(DABS(EDIF).GT.EPS) THEN
!           RKNT(N) = EDIF*DLOG(ARGL)
!         ELSE
!           RKNT(N) = 0.0D0
!         ENDIF
!       ENDDO
! C
! C     GENERATE MATRIX ELEMENTS <I|SIG|N> FOR ALL N
!       DO I=1,NDIM-NSKP
! C
! C       LOOP OVER ALL POSITIVE-ENERGY STATES N
!         DO N=1,NDIM-NSKP
! C
! C         INITIALISE THESE MATRIX ELEMENTS
!           PINLSX(I,N) = DCMPLX(0.0D0,0.0D0)
!           PINLSY(I,N) = DCMPLX(0.0D0,0.0D0)
!           PINLSZ(I,N) = DCMPLX(0.0D0,0.0D0)
!           PINSLX(I,N) = DCMPLX(0.0D0,0.0D0)
!           PINSLY(I,N) = DCMPLX(0.0D0,0.0D0)
!           PINSLZ(I,N) = DCMPLX(0.0D0,0.0D0)
! C
! C         CONTRACT OVER COEFFICIENTS AND RAW MATRIX ELEMENTS
!           DO L=1,NDIM-NSKP
! C
! C           SMALL-COMPONENT COEFFICIENT
!             CL = COEF(L     ,N+NSKP)
!             CS = COEF(L+NSKP,N+NSKP)
! C
! C           <I,L|SIG_X|N,S>
!             PINLSX(I,N) = PINLSX(I,N) + CS*OLSX(I,L)
!             PINLSY(I,N) = PINLSY(I,N) + CS*OLSY(I,L)
!             PINLSZ(I,N) = PINLSZ(I,N) + CS*OLSZ(I,L)
! C
! C           <I,S|SIG_X|N,L>
!             PINSLX(I,N) = PINSLX(I,N) + CL*OSLX(I,L)
!             PINSLY(I,N) = PINSLY(I,N) + CL*OSLY(I,L)
!             PINSLZ(I,N) = PINSLZ(I,N) + CL*OSLZ(I,L)
! C
!           ENDDO
! C
!         ENDDO
!       ENDDO
! C
! C     FORM THE DOT PRODUCT OF MATRICES AND MULTIPLY BY ENERGY TERM
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
! C
!           VLL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VLS(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSL(I,J) = DCMPLX(0.0D0,0.0D0)
!           VSS(I,J) = DCMPLX(0.0D0,0.0D0)
! C
! C         LOOP OVER ALL POSITIVE-ENERGY STATES N
!           DO N=1,NDIM-NSKP
! C
! C           ITT = 1: <I,L|SIG|N,S><N,S|SIG|I,L>
!             TXX = PINLSX(I,N)*DCONJG(PINLSX(J,N))
!             TYY = PINLSY(I,N)*DCONJG(PINLSY(J,N))
!             TZZ = PINLSZ(I,N)*DCONJG(PINLSZ(J,N))
! C
!             VLL(I,J) = VLL(I,J) + ALW*RKNT(N)*(TXX+TYY+TZZ)
! C
! C           ITT = 2: <I,L|SIG|N,S><N,L|SIG|I,S>
!             TXX = PINLSX(I,N)*DCONJG(PINSLX(J,N))
!             TYY = PINLSY(I,N)*DCONJG(PINSLY(J,N))
!             TZZ = PINLSZ(I,N)*DCONJG(PINSLZ(J,N))
! C
!             VLS(I,J) = VLS(I,J) + ALW*RKNT(N)*(TXX+TYY+TZZ)
! C
! C           ITT = 3: <I,S|SIG|N,L><N,S|SIG|I,L>
!             TXX = PINSLX(I,N)*DCONJG(PINLSX(J,N))
!             TYY = PINSLY(I,N)*DCONJG(PINLSY(J,N))
!             TZZ = PINSLZ(I,N)*DCONJG(PINLSZ(J,N))
! C
!             VSL(I,J) = VSL(I,J) + ALW*RKNT(N)*(TXX+TYY+TZZ)
! C
! C           ITT = 4: <I,S|SIG|N,L><N,L|SIG|I,S>
!             TXX = PINSLX(I,N)*DCONJG(PINSLX(J,N))
!             TYY = PINSLY(I,N)*DCONJG(PINSLY(J,N))
!             TZZ = PINSLZ(I,N)*DCONJG(PINSLZ(J,N))
! C
!             VSS(I,J) = VSS(I,J) + ALW*RKNT(N)*(TXX+TYY+TZZ)
! C
!           ENDDO
!         ENDDO
!       ENDDO
! C
! C**********************************************************************C
! C     CODE FOR TESTING PURPOSES                                        C
! C**********************************************************************C
! C
! C     COMMENT OUT THIS LINE IF YOU WANT TO SEE THE CONTRIBUTIONS
!       GOTO 888
! C     GENERATE MATRIX ELEMENTS <IOCC|SIG|N> FOR ALL N
! C
! C     LOOP OVER STATES N
!       DO N=1,NDIM-NSKP
! C
! C       INITIALISE MATRIX ELEMENT STORAGE
!         WLS(N,1) = DCMPLX(0.0D0,0.0D0)
!         WLS(N,2) = DCMPLX(0.0D0,0.0D0)
!         WLS(N,3) = DCMPLX(0.0D0,0.0D0)
!         WSL(N,1) = DCMPLX(0.0D0,0.0D0)
!         WSL(N,2) = DCMPLX(0.0D0,0.0D0)
!         WSL(N,3) = DCMPLX(0.0D0,0.0D0)
! C
!         DO I=1,NDIM-NSKP
! C
! C         SMALL-COMPONENT COEFFICIENT
!           CL = COEF(I     ,IOCC+NSKP)
!           CS = COEF(I+NSKP,IOCC+NSKP)
! C
! C         <IOCC,L|SIG_X|N,S>
!           WLS(N,1) = WLS(N,1) + DCONJG(CL)*PINLSX(I,N)
!           WLS(N,2) = WLS(N,2) + DCONJG(CL)*PINLSY(I,N)
!           WLS(N,3) = WLS(N,3) + DCONJG(CL)*PINLSZ(I,N)
! C
! C         <IOCC,L|SIG_X|N,S>
!           WSL(N,1) = WSL(N,1) + DCONJG(CS)*PINSLX(I,N)
!           WSL(N,2) = WSL(N,2) + DCONJG(CS)*PINSLY(I,N)
!           WSL(N,3) = WSL(N,3) + DCONJG(CS)*PINSLZ(I,N)
! C
!         ENDDO
!       ENDDO
! C
! C     CALCULATE CONTRIBUTIONS TO THE SELF-INTERACTION ENERGY
!       WRITE(6, *) 'IOCC = ',IOCC
!       WRITE(7, *) 'IOCC = ',IOCC
! 80    FORMAT(1X,I3,2X,I4,A,'_',I1,'/2',2X,I2,'/2',2X,F19.10,2X,F17.10,
!      &                         2X,'| ',3(F13.10,1X),'|',2(1X,ES17.10))
! 81    FORMAT(3X,'N',5X,'spinor',3X,'m_j',17X,'E(N)',12X,'RKNT(N)',2X,
!      &     '|',4X,'<I|sX|N>^2',4X,'<I|sY|N>^2',4X,'<I|sZ|N>^2',1X,
!      &     '|',13X,'SE(N)',13X,'TALLY')
!       NLNES = 142
!       DO ITT=1,4
!         WRITE(6, *) 'ITT  = ',ITT
!         WRITE(7, *) 'ITT  = ',ITT
!         WRITE(6, *) REPEAT('=',NLNES)
!         WRITE(7, *) REPEAT('=',NLNES)
!         WRITE(6,81)
!         WRITE(7,81)
!         WRITE(6, *) REPEAT('=',NLNES)
!         WRITE(7, *) REPEAT('=',NLNES)
!         TSM = DCMPLX(0.0D0,0.0D0)
!         DO N=1,NDIM-NSKP
!           IF(ITT.EQ.1) THEN
!             EX(N,ITT) = WLS(N,1)*DCONJG(WLS(N,1))
!             EY(N,ITT) = WLS(N,2)*DCONJG(WLS(N,2))
!             EZ(N,ITT) = WLS(N,3)*DCONJG(WLS(N,3))
!           ELSEIF(ITT.EQ.2) THEN
!             EX(N,ITT) = WLS(N,1)*DCONJG(WSL(N,1))
!             EY(N,ITT) = WLS(N,2)*DCONJG(WSL(N,2))
!             EZ(N,ITT) = WLS(N,3)*DCONJG(WSL(N,3))
!           ELSEIF(ITT.EQ.3) THEN
!             EX(N,ITT) = WSL(N,1)*DCONJG(WLS(N,1))
!             EY(N,ITT) = WSL(N,2)*DCONJG(WLS(N,2))
!             EZ(N,ITT) = WSL(N,3)*DCONJG(WLS(N,3))
!           ELSEIF(ITT.EQ.4) THEN
!             EX(N,ITT) = WSL(N,1)*DCONJG(WSL(N,1))
!             EY(N,ITT) = WSL(N,2)*DCONJG(WSL(N,2))
!             EZ(N,ITT) = WSL(N,3)*DCONJG(WSL(N,3))
!           ENDIF          
!           ET(N,ITT) = ALW*RKNT(N)*(EX(N,ITT)+EY(N,ITT)+EZ(N,ITT))
!           TSM = TSM + ET(N,ITT)
!         ENDDO
! C      
! C       ORGANISE RESULTS IN ORDER OF CONTRIBUTIONS
!         DO N=1,NDIM-NSKP
!           IORD(N) = 0
!         ENDDO
! C
!         TSM = DCMPLX(0.0D0)
!         DO M=1,NDIM-NSKP
!           EBIG = 0.0D0
!           DO N=1,NDIM-NSKP
! C           THIS LINE DISABLES THE ORDERING PROCESS
!             GOTO 74
!             IF(IORD(N).EQ.1) GOTO 74
!             IF(ABS(ET(N,ITT)).GT.EBIG) THEN
!               EBIG = ABS(ET(N,ITT))
!               K = N
!             ENDIF
! 74          CONTINUE
!           ENDDO
!           K = M
!           IF(ABS(ET(K,ITT)).LT.1.0D-9) GOTO 76
!           IORD(K) = 1
!           IF(LABKQN(K).LT.0) THEN
!             ILQN =-LABKQN(K)-1
!           ELSE
!             ILQN = LABKQN(K)
!           ENDIF
!           CHL  = LLAB(ILQN)
!           TSM = TSM + ET(K,ITT)
!           WRITE(6,80) K,NQNLST(K),CHL,2*IABS(LABKQN(K))-1,LABMQN(K),
!      &                EIGN(K+NSKP),RKNT(K),DREAL(EX(K,ITT)),
!      &                DREAL(EY(K,ITT)),DREAL(EZ(K,ITT)),
!      &                DREAL(ET(K,ITT)),DREAL(TSM)
!           WRITE(7,80) K,NQNLST(K),CHL,2*IABS(LABKQN(K))-1,LABMQN(K),
!      &                EIGN(K+NSKP),RKNT(K),DREAL(EX(K,ITT)),
!      &                DREAL(EY(K,ITT)),DREAL(EZ(K,ITT)),
!      &                DREAL(ET(K,ITT)),DREAL(TSM)
! 76        CONTINUE
!         ENDDO
! 75      CONTINUE
!         WRITE(6, *) REPEAT('=',NLNES)
!         WRITE(7, *) REPEAT('=',NLNES)
! C
!       ENDDO
! 888   CONTINUE
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VSLFLWA(VIJ,BETHELOG,ITT,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C  VV    VV  SSSSSS  LL       FFFFFFFF LL       WW        WW    AA     C
! C  VV    VV SS    SS LL       FF       LL       WW        WW   AAAA    C
! C  VV    VV SS       LL       FF       LL       WW   WW   WW  AA  AA   C
! C  VV    VV  SSSSSS  LL       FFFFFF   LL       WW  WWWW  WW AA    AA  C
! C   VV  VV        SS LL       FF       LL       WW WW  WW WW AAAAAAAA  C
! C    VVVV   SS    SS LL       FF       LL       WWWW    WWWW AA    AA  C
! C     VV     SSSSSS  LLLLLLLL FF       LLLLLLLL WW        WW AA    AA  C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VSLFLWA CONSTRUCTS (μ,T|∇^2φ|ν,T') ELECTRON SELF-INTERACTION MATRIX C
! C  ELEMENTS (LOW-ENERGY) USING BETHE LOGARITHMS. THESE LOGARITHMS      C
! C  KIND OF REPRESENT THE NON-RELATIVISTIC PART OF THE LAMB SHIFT.      C
! C  THIS IS AN *AVERAGED* PROCEDURE, AND YOU NEED ACCESS TO BETHELOG AS C
! C  WELL AS KNOWN ATOMIC STATES (NOT APPLICABLE TO MOLECULAR PROBLEMS). C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       COMPLEX*16 VIJ(MDM,MDM)
!       COMPLEX*16 VTT(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     CHECK THE COMPONENT-TYPE OVERLAP
!       IF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         WRITE(6, *) 'In VSLFLWA: illegal component-type overlap.',ITT
!         WRITE(7, *) 'In VSLFLWA: illegal component-type overlap.',ITT
!         RETURN
!       ENDIF
! C
! C     MANUALLY-SELECTED MATCHING WAVELENGTH
!       CUTK = CV
! C
! C     AMPLITUDE FOR LOW-ENERGY SELF-INTERACTION TERM (B&S 19.15)
!       ALW =-DLOG(CUTK*CV/BETHELOG)/(3.0D0*EMSS*EMSS*CV*CV*CV*PI)
! C
! C     LOOP OVER NUCLEAR CENTRES
!       DO IZ=1,NCNT
! C
! C       GENERATE DIRECT OVERLAP MATRICES (ZEROTH MOMENT)
!         CALL VNCOLAP(VTT,IZ,ITT,0,1,2)
! C
! C       GENERATE DIRECT OVERLAP MATRICES USING POINT NUCLEI
! C       CALL VPTNCD0(VTT,IZ,ITT,0,1,2)
! C
! C       SELF-ENERGY (FACTOR -4π FROM POISSON'S EQUATION)
!         DO I=1,NDIM-NSKP
!           DO J=1,NDIM-NSKP
!             VIJ(I,J) = VIJ(I,J) -4.0D0*PI*ZNUC(IZ)*ALW*VTT(I,J)
!           ENDDO
!         ENDDO
! C
! C     END LOOP OVER NUCLEAR CENTRES
!       ENDDO
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VSLFHIF(VIJ,ITT,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C      VV    VV  SSSSSS  LL       FFFFFFFF HH    HH IIII FFFFFFFF      C
! C      VV    VV SS    SS LL       FF       HH    HH  II  FF            C
! C      VV    VV SS       LL       FF       HH    HH  II  FF            C
! C      VV    VV  SSSSSS  LL       FFFFFF   HHHHHHHH  II  FFFFFF        C
! C       VV  VV        SS LL       FF       HH    HH  II  FF            C
! C        VVVV   SS    SS LL       FF       HH    HH  II  FF            C
! C         VV     SSSSSS  LLLLLLLL FF       HH    HH IIII FF            C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VSLFHIF CONSTRUCTS (μ,T|∇^2φ|ν,T') ELECTRON SELF-INTERACTION MATRIX C
! C  ELEMENTS (HIGH-ENERGY) USING THE BETHE AND SALPETER APPROACH.       C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
! C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       COMPLEX*16 VIJ(MDM,MDM)
!       COMPLEX*16 VTT(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     CHECK THE COMPONENT-TYPE OVERLAP
!       IF(ITT.EQ.2.OR.ITT.EQ.3) THEN
!         WRITE(6, *) 'In VSLFHIF: illegal component-type overlap.',ITT
!         WRITE(7, *) 'In VSLFHIF: illegal component-type overlap.',ITT
!         RETURN
!       ENDIF
! C
! C     MANUALLY-SELECTED MATCHING WAVELENGTH
!       CUTK = CV
! C
! C     AMPLITUDE FOR FREE-WAVE SELF-INTERACTION TERM (B&S 19.3)
!       AG2 = (DLOG(EMSS*CV/CUTK)-TWLG+11.0D0/24.0D0)/(3.0D0*CV*PI)
!       AG2 =-AG2/(EMSS*EMSS*CV*CV)
! C
! C     LOOP OVER NUCLEAR CENTRES
!       DO IZ=1,NCNT
! C
! C       NUCLEAR CONTACT MATRIX ELEMENTS
!         CALL VNCOLAP(VTT,IZ,ITT,0,1,2)
! C
! C       SELF-ENERGY (FACTOR -4π FROM POISSON'S EQUATION)
!         DO I=1,NDIM-NSKP
!           DO J=1,NDIM-NSKP
!             VIJ(I,J) = VIJ(I,J) - 4.0D0*PI*ZNUC(IZ)*AG2*VTT(I,J)
!           ENDDO
!         ENDDO
! C
! C     END LOOP OVER NUCLEAR CENTRES
!       ENDDO
! C
!       RETURN
!       END
! C
! C
!       SUBROUTINE VANOMLS(VIJ,ITT,IA1,IA2)
!       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
! C**********************************************************************C
! C                                                                      C
! C   VV    VV    AA    NN    NN  OOOOOO  MM       MM LL       SSSSSS    C
! C   VV    VV   AAAA   NNN   NN OO    OO MMM     MMM LL      SS    SS   C
! C   VV    VV  AA  AA  NNNN  NN OO    OO MMMM   MMMM LL      SS         C
! C   VV    VV AA    AA NN NN NN OO    OO MM MM MM MM LL       SSSSSS    C
! C    VV  VV  AAAAAAAA NN  NNNN OO    OO MM  MMM  MM LL            SS   C
! C     VVVV   AA    AA NN   NNN OO    OO MM   M   MM LL      SS    SS   C
! C      VV    AA    AA NN    NN  OOOOOO  MM       MM LLLLLLLL SSSSSS    C
! C                                                                      C
! C -------------------------------------------------------------------- C
! C  VANOMLS CONSTRUCTS A SET OF MATRIX ELEMENTS OVER THE VECTOR DOT     C
! C  PRODUCT α.E FOR THE ELECTRON ANOMALOUS MAGNETIC DIPOLE MOMENT.      C
! C -------------------------------------------------------------------- C
! C  INPUT:                                                              C
! C  ▶ ITT     = {2,3}     -> {LS,SL} COMPONENT COMBINATION.             C
! C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
! C**********************************************************************C
!       INCLUDE 'parameters.h'
! C
!       CHARACTER*5 NMDL
! C
!       COMPLEX*16 VIJ(MDM,MDM)
!       COMPLEX*16 VTT(MDM,MDM)
! C
!       COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
!       COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
!      &            FNUC(MCT,0:MFT),XNUC(MCT,0:MFT),NNUC(MCT),NMDL(MCT)
!       COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
!      &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
!       COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
!       COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
! C
! C     INITIALISE THE OVERLAP ARRAY
!       DO I=1,NDIM-NSKP
!         DO J=1,NDIM-NSKP
!           VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
!         ENDDO
!       ENDDO
! C
! C     CHECK THE COMPONENT-TYPE OVERLAP
!       IF(ITT.EQ.1.OR.ITT.EQ.4) THEN
!         WRITE(6, *) 'In VANOMLS: illegal component-type overlap.',ITT
!         WRITE(7, *) 'In VANOMLS: illegal component-type overlap.',ITT
!         RETURN
!       ENDIF
! C
! C     AMPLITUDE FOR ELECTRON ANOMALOUS MAGNETIC MOMENT TERM (B&S 19.3)
!       AG1 =-1.0D0/(4.0D0*PI*EMSS*CV*CV)
! C
! C     LOOP OVER NUCLEAR CENTRES
!       DO IZ=1,NCNT
! C
! C       LOOP OVER CARTESIAN INDICES
!         DO IX=1,3
! C
! C         GENERATE THIS SET OF ELECTRIC FIELD INTEGRALS
!           CALL VNCELEC(VTT,IZ,ITT,IX,IX,IA1,IA2)
! C
! C         ADD TO THE TOTAL DOT PRODUCT (WITH AMPLITUDE)
!           DO I=1,NDIM-NSKP
!             DO J=1,NDIM-NSKP
!               VIJ(I,J) = VIJ(I,J) + ZNUC(IZ)*AG1*VTT(I,J)
!             ENDDO
!           ENDDO
! C
! C       END LOOP OVER CARTESIAN INDICES
!         ENDDO
! C
! C     END LOOP OVER NUCLEAR CENTRES
!       ENDDO
! C
!       RETURN
!       END
C
C
C**********************************************************************C
C ==================================================================== C
C  [10] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C**********************************************************************C
C
C
      SUBROUTINE DGNUMAP(ARRAY,TITLE,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  DDDDDDD   GGGGGG  NN    NN UU    UU MM       MM    AA    PPPPPPP    C
C  DD    DD GG    GG NNN   NN UU    UU MMM     MMM   AAAA   PP    PP   C
C  DD    DD GG       NNNN  NN UU    UU MMMM   MMMM  AA  AA  PP    PP   C
C  DD    DD GG       NN NN NN UU    UU MM MM MM MM AA    AA PP    PP   C
C  DD    DD GG   GGG NN  NNNN UU    UU MM  MMM  MM AAAAAAAA PPPPPPP    C
C  DD    DD GG    GG NN   NNN UU    UU MM   M   MM AA    AA PP         C
C  DDDDDDD   GGGGGG  NN    NN  UUUUUU  MM       MM AA    AA PP         C
C                                                                      C
C -------------------------------------------------------------------- C
C  DGNUMAP EXPORTS AN ARRAY OF DOUBLE-PRECISION NUMBERS TO AN EXTERNAL C
C  DATA FILE AND PLOTS IT AS ONE HEAT MAP.                             C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*80 TITLE
C
      DIMENSION ARRAY(MDM,MDM)
C
C     PRINT TO EXTERNAL DATA FILE
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//".dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (ARRAY(I,J),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
      XEND = DFLOAT(NDIM)-0.5D0
      YEND = DFLOAT(NDIM)-0.5D0
C
C     WRITE GNUPLOT MAKE FILE
      OPEN(UNIT=9,FILE='plots/'//TRIM(TITLE)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(TITLE)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(TITLE)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf size 4,4'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(TITLE)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') 'load "plots/pals/jet2.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A,F6.1,A)') 'set xrange [-0.5:',XEND,']'
      WRITE(9,'(A,F6.1,A)') 'set yrange [',YEND,':-0.5] reverse'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(TITLE)//'.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(TITLE)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(TITLE)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE ZGNUMAP(ARRAY,TITLE,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  ZZZZZZZZ  GGGGGG  NN    NN UU    UU MM       MM    AA    PPPPPPP    C
C       ZZ  GG    GG NNN   NN UU    UU MMM     MMM   AAAA   PP    PP   C
C      ZZ   GG       NNNN  NN UU    UU MMMM   MMMM  AA  AA  PP    PP   C
C     ZZ    GG       NN NN NN UU    UU MM MM MM MM AA    AA PP    PP   C
C    ZZ     GG   GGG NN  NNNN UU    UU MM  MMM  MM AAAAAAAA PPPPPPP    C
C   ZZ      GG    GG NN   NNN UU    UU MM   M   MM AA    AA PP         C
C  ZZZZZZZZ  GGGGGG  NN    NN  UUUUUU  MM       MM AA    AA PP         C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZGNUMAP EXPORTS AN ARRAY OF COMPLEX DOUBLE-PRECISION NUMBERS TO AN  C
C  EXTERNAL DATA FILE AND PLOTS IT AS TWO HEAT MAPS.                   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*80 TITLE
C
      COMPLEX*16 ARRAY(MDM,MDM)
C
C     PRINT TO EXTERNAL DATA FILES
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//"_r.dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (DREAL(ARRAY(I,J)),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//"_i.dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (DIMAG(ARRAY(I,J)),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
      XEND = DFLOAT(NDIM)-0.5D0
      YEND = DFLOAT(NDIM)-0.5D0
C
C     WRITE GNUPLOT MAKE FILES
      OPEN(UNIT=9,FILE='plots/'//TRIM(TITLE)//'_i.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(TITLE)//'_i.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(TITLE)//'_i.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf size 4,4'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(TITLE)//'_i.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') 'load "plots/pals/jet2.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A,F6.1,A)') 'set xrange [-0.5:',XEND,']'
      WRITE(9,'(A,F6.1,A)') 'set yrange [',YEND,':-0.5] reverse'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(TITLE)//'_i.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(TITLE)//'_r.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(TITLE)//'_r.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(TITLE)//'_r.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf size 4,4'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(TITLE)//'_r.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') 'load "plots/pals/jet2.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A,F6.1,A)') 'set xrange [-0.5:',XEND,']'
      WRITE(9,'(A,F6.1,A)') 'set yrange [',YEND,':-0.5] reverse'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(TITLE)//'_r.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(TITLE)//'_i.gnuplot')
      CALL SYSTEM('gnuplot plots/'//TRIM(TITLE)//'_r.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(TITLE)//'_i.pdf')
      CALL SYSTEM('xdg-open plots/'//TRIM(TITLE)//'_r.pdf')
C
      RETURN
      END
C
C
      FUNCTION KRONECK(IX,JX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    KK    KK RRRRRRR   OOOOOO  NN    NN EEEEEEEE CCCCCC  KK    KK     C
C    KK   KK  RR    RR OO    OO NNN   NN EE      CC    CC KK   KK      C
C    KK  KK   RR    RR OO    OO NNNN  NN EE      CC       KK  KK       C
C    KKKKK    RR    RR OO    OO NN NN NN EEEEEE  CC       KKKKK        C
C    KK  KK   RRRRRRR  OO    OO NN  NNNN EE      CC       KK  KK       C
C    KK   KK  RR    RR OO    OO NN   NNN EE      CC    CC KK   KK      C
C    KK    KK RR    RR  OOOOOO  NN    NN EEEEEEEE CCCCCC  KK    KK     C
C                                                                      C
C -------------------------------------------------------------------- C
C  KRONECK IS A KRONECKER DELTA FUNCTION FOR INDICES IX AND JX.        C
C**********************************************************************C
C
      IF(IX.EQ.JX) THEN
        KRONECK = 1
      ELSE
        KRONECK = 0
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [11] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] RMAKE: BATCH OF R-INTEGRALS FOR BASIS FUNCTION OVERLAPS.       C
C   [B] FUNFM: LIST OF BOYS INTEGRALS FOR USE IN RMAKE.                C
C   [C] BOYSGEN: OUTPUT DATA FILE WITH FAMILY OF BOYS FUNCTIONS.       C
C   [D] HGTFS: BATCH OF HGTF AMPLITUDES EVALUATED AT (X,Y,Z).          C
C   [E] HERMITE: EVALUATION OF H_I (P,X) BY RECURRENCE.                C
C   [F] HTFRMS: BATCH OF HGTF FOURIER TRANSFORMS AT (QX,QY,QZ).        C
C**********************************************************************C
C
C
      SUBROUTINE RMAKE(RC,QP,APH,MAXM,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           RRRRRRR  MM       MM    AA    KK    KK EEEEEEEE            C
C           RR    RR MMM     MMM   AAAA   KK   KK  EE                  C
C           RR    RR MMMM   MMMM  AA  AA  KK  KK   EE                  C
C           RR    RR MM MM MM MM AA    AA KKKKK    EEEEEE              C
C           RRRRRRR  MM  MMM  MM AAAAAAAA KK  KK   EE                  C
C           RR    RR MM   M   MM AA    AA KK   KK  EE                  C
C           RR    RR MM       MM AA    AA KK    KK EEEEEEEE            C
C                                                                      C
C -------------------------------------------------------------------- C
C  RMAKE GENERATES A COMPLETE SET OF R-INTEGRALS REQUIRED IN THE       C
C  FINITE SUM REPRESENTATION OF A MULTI-CENTRE GAUSSIAN OVERLAP.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION FS(MB2,ML4),APH(MB2),QP(MB2,3),RC(MB2,MRC),RC2(MB2,MRC)
      DIMENSION F1(MB2,ML4),F2(MB2,ML4),F3(MB2,ML4),F4(MB2,ML4)
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2),
     &          I1(MB2),I2(MB2),I3(MB2),I4(MB2)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     VALUES WHICH DETERMINE EVALUATION METHOD
      EPSZR = 1.0D-11
      EPSPL = 1.7D+01
      EPSAS = 3.0D+01
C
C**********************************************************************C
C     THE FIRST STEP OF THIS ROUTINE IS TO EVALUATE THE REQUIRED       C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
C     INITIALISE COUNTERS FOR EVALUATION METHODS IN BATCH
      N1 = 0
      N2 = 0
      N3 = 0
      N4 = 0
C
C     FOR EACH PAIR OF BASIS FUNCTIONS (EXPONENTS EI AND EJ IN 'M'),
C     DETERMINE THE BEST WAY TO EVALUATE THE BOYS FUNCTION
      DO M=1,MAXM
C
        X = QP(M,1)*QP(M,1) + QP(M,2)*QP(M,2) + QP(M,3)*QP(M,3)
        X = X*APH(M)
C
C       CASE 1: IF X=0.0D0 USE EXACT FORMULA
        IF(X.LE.EPSZR) THEN
C
          N1     = N1+1
          X1(N1) = X
          I1(N1) = M
C
C       CASE 2: IF X<EPSPL USE A POLYNOMIAL EXPANSION
        ELSEIF(X.GT.EPSZR.AND.X.LE.EPSPL) THEN
C
          N2     = N2+1
          X2(N2) = X
          I2(N2) = M
C
C       CASE 3: IF X<EPSAS USE ASYMPTOIC FORMULA WITH EXPONENTIAL
        ELSEIF(X.GT.EPSPL.AND.X.LE.EPSAS) THEN
C
          N3     = N3+1
          X3(N3) = X
          I3(N3) = M
C
C       CASE 4: IF X>EPSAS USE ASYMPTOIC FORMULA WITHOUT EXPONENTIAL
        ELSE
C
          N4     = N4+1
          X4(N4) = X
          I4(N4) = M
C
        ENDIF
C
      ENDDO
C
C     EVALUATE THE BOYS INTEGRALS -- A BATCH FOR EACH ITYPE
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS X=0.0D0.
C     THE VALUE OF THIS FUNCTION IS 2N+1 (DONE IN FUNFM).
      IF(N1.GT.0) THEN
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO K=1,LAM+1
          DO M=1,N1
            FS(I1(M),K) = F1(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=EPSPL.
C     EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C     AND RECURRENCE IN DIRECTION OF DECREASING M.
      IF(N2.GT.0) THEN
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO K=1,LAM+1
          DO M=1,N2
            FS(I2(M),K) = F2(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=EPSAS.
C     EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      IF(N3.GT.0) THEN
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO K=1,LAM+1
          DO M=1,N3
            FS(I3(M),K) = F3(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 4: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=EPSAS.
C     EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      IF(N4.GT.0) THEN
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO K=1,LAM+1
          DO M=1,N4
            FS(I4(M),K) = F4(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     WITH THE FULL SET OF BOYS' INTEGRALS WE NOW APPLY RECURRENCE     C
C     RELATIONS TO F_N (X) AND EVALUATE THE R-INTEGRALS.               C
C**********************************************************************C
C
C     CONSTRUCT TOP LEVEL (FOR MAXIMUM LAM VALUE)
      DO M=1,MAXM
        RC(M,1)= (-2.0D0*APH(M))**LAM
        RC(M,1) = RC(M,1)*FS(M,LAM+1)
      ENDDO
C
C     MINIMUM LEVEL ILV BASED ON LAM VALUE
      IF(MOD(LAM,2).EQ.0) THEN
       ITUVMIN = 1
      ELSE
       ITUVMIN = 2
      ENDIF
C
C     INITIALISE ITUV COUNTER (RELATES TO # CARTESIAN INDICES FOR lam)
      ITUV=-1
C
C     MAIN LOOP: LEVEL 'ILV' STARTING AT LAM-1 AND WORKING BACKWARDS
      DO ILV=LAM-1,ITUVMIN,-2
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT = DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU = DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV = DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
        DO M=1,MAXM
          RC2(M,1) = (-2.0D0*APH(M))**ILV
          RC2(M,1) = RC2(M,1)*FS(M,ILV+1)
        ENDDO
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT = DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU = DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV = DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXM
                 RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                 RC(M,N2) =-QP(M,2)*RC2(M,K1)
                 RC(M,N3) =-QP(M,3)*RC2(M,K1)
               ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXM
          RC(M,1) = (-2.0D0*APH(M))**(ILV-1)
          RC(M,1) = RC(M,1)*FS(M,ILV)
        ENDDO
C
      ENDDO
C
C
C     AN ADDITIONAL LOOP OVER ADDRESSES (WHEN LAM IS ODD)
      IF(MOD(LAM,2).EQ.1) THEN
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT=DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXM
          RC2(M,1) = FS(M,1)
        ENDDO
C
C       MOVE THE RC2 ARRAY INTO RC
C
        ITMAX = (LAM+1)*(LAM+2)*(LAM+3)/6
        DO IT=1,ITMAX
          DO M=1,MAXM
            RC(M,IT) = RC2(M,IT)
          ENDDO
        ENDDO
C
C     END IF STATEMENT FOR THE ODD LAM CASE
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FUNFM(FM,T,N,LAM,ITYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           FFFFFFFF UU    UU NN    NN FFFFFFFF MM       MM            C
C           FF       UU    UU NNN   NN FF       MMM     MMM            C
C           FF       UU    UU NNNN  NN FF       MMMM   MMMM            C
C           FFFFFF   UU    UU NN NN NN FFFFFF   MM MM MM MM            C
C           FF       UU    UU NN  NNNN FF       MM  MMM  MM            C
C           FF       UU    UU NN   NNN FF       MM   M   MM            C
C           FF        UUUUUU  NN    NN FF       MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  FUNFM EVALUATES INTEGRAL [INT_{0}^{1} U^{2M} EXP(-T*U^{2}) dU]      C
C  FOR VARIABLE T > 0 FOR ALL ORDERS 0 < M < LAM.                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITYPE = 1 - SPECIAL CASE X = 0.0D0.                               C
C  ▶ ITYPE = 2 - POWER SERIES AND REVERSE RECURRENCE.                  C
C                (60 TERMS WILL BE USED, SO USE MUST SUPPLY A VALUE    C
C                 APPROPRIATE TO THE MAX VALUE OF X IN BATCH).         C
C  ▶ ITYPE = 3 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C  ▶ ITYPE = 4 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C                ALL TERMS DEPENDING ON EXP(-X) ARE OMITTED TO AVOID   C
C                NUMERICAL UNDERFLOW PROBLEMS.                         C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION FM(MB2,ML4),T(MB2),TLAM(MB2),TT2(MB2),
     &          TXP(MB2),TRT(MB2)
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      DATA A0,B0/4.994501191201870D-1,4.551838436668326D-1/
C
C**********************************************************************C
C     ITYPE = 1: SPECIAL CASE FOR T = 0.0D0                            C
C**********************************************************************C
C
      IF(ITYPE.EQ.1) THEN
C
        DO K=1,LAM+1
          MVAL  = K-1
          VALUE = 1.0D0/DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,K) = VALUE
          ENDDO
        ENDDO
        RETURN
C
C**********************************************************************C
C     ITYPE = 2: POWER SERIES EVALUATION                               C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.2) THEN
C
C       INITIALISE THE POWER SERIES FOR M = LAM
        DO M=1,N
          TXP(M)      = DEXP(-T(M))
          TT2(M)      = 2.0D0*T(M)
          TLAM(M)     = 1.0D0
          FM(M,LAM+1) = 1.0D0
        ENDDO
C
C       LOOP OVER TERMS IN THE POWER SERIES
        DO K=1,60
          DLAM = DFLOAT(2*LAM+2*K+1)
          DO M=1,N
            TLAM(M)     = TLAM(M)*TT2(M)/DLAM
            FM(M,LAM+1) = FM(M,LAM+1) + TLAM(M)
          ENDDO
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DEN = DFLOAT(2*LAM+1)
        DO M=1,N
          FM(M,LAM+1) = FM(M,LAM+1)*TXP(M)/DEN
        ENDDO
C
C       NOW COMPLETE TABLE BY BACKWARDS RECURRENCE
        DO I=1,LAM
          MIND  = LAM-I+1
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND) = (TT2(M)*FM(M,MIND+1) + TXP(M))/COEFF
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 3: ASYMPTOTIC EXPANSION WITH EXPONENTIAL ARGUMENT.       C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.3) THEN
C
C       INITIALISE THE ASYMPTOTIC EXPANSION
        DO M=1,N
          TXP(M) = DEXP(-T(M))
          TT2(M) = 2.0D0*T(M)
          TRT(M) = DSQRT(T(M))
        ENDDO
C
C       SEED VALUES
        DO M=1,N
          FM(M,1) = A0/(B0+T(M))
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DO M=1,N
          FM(M,1) = 0.5D0*PI12/TRT(M) - TXP(M)*FM(M,1)
        ENDDO
C
C       NOW COMPLETE TABLE BY FORWARD RECURRENCE
        DO MIND=1,LAM
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND+1) = (COEFF*FM(M,MIND) - TXP(M))/TT2(M)
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 4: ASYMPTOTIC EXPANSION WITH VERY LARGE ARGUMENT         C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.4) THEN
C
C       INITIALISE THE ASYMPTOTIC EXPANSION
        DO M=1,N
          TT2(M)  = 2.0D0*T(M)
          FM(M,1) = 0.5D0*PI12/DSQRT(T(M))
        ENDDO
C
C       NOW COMPLETE TABLE BY FORWARD RECURRENCE
        DO MIND=1,LAM
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND+1) = COEFF*FM(M,MIND)/TT2(M)
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE OUT OF RANGE: INVALID INPUT TO FUNFM                       C
C**********************************************************************C
C
      ELSE
91      FORMAT(2X,'In FUNFM: invalid type (must be 1-4)',I4)
        WRITE(6,91) ITYPE
        WRITE(7,91) ITYPE
        STOP
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BOYSGEN(LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB   OOOOOO  YY    YY  SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C    BB    BB OO    OO YY    YY SS    SS GG    GG EE       NNN   NN    C
C    BB    BB OO    OO  YY  YY  SS       GG       EE       NNNN  NN    C
C    BBBBBBB  OO    OO   YYYY    SSSSSS  GG       EEEEEE   NN NN NN    C
C    BB    BB OO    OO    YY          SS GG   GGG EE       NN  NNNN    C
C    BB    BB OO    OO    YY    SS    SS GG    GG EE       NN   NNN    C
C    BBBBBBB   OOOOOO     YY     SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  BOYSGEN PRODUCES A DATA FILE WHICH CONTAINS A FAMILY OF BOYS        C
C  FUNCTIONS OVER A SPECIFIED REGION, GIVEN A MAXIMUM FAMILY           C
C  PARAMETER DETERMINED BY LAM.                                        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2)
      DIMENSION F1(MB2,ML4),F2(MB2,ML4),F3(MB2,ML4),
     &          F4(MB2,ML4),FS(MB2,ML4)
C
C     EVALUATION PARAMETERS
      NTOT = 400
      XMIN = 0.00D0
      XMAX = 4.00D1
      HSTP = (XMAX-XMIN)/NTOT
C
C     VALUES WHICH DETERMINE EVALUATION METHOD
      EPSZR = 1.0D-11
      EPSPL = 1.7D+01
      EPSAS = 3.0D+01
C
C**********************************************************************C
C     THE FIRST STEP OF THIS SUBROUTINE IS TO EVALUATE THE REQUIRED    C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
      OPEN(UNIT=8,FILE='plots/boysfunction.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO NX=0,NTOT
C
      X = XMIN + HSTP*NX
C
C     CASE 0: ARGUMENT OF THE BOYS FUNCTION IS X = 0.
C             THE VALUE OF THIS FUNCTION IS (2N+1).
      IF(X.LE.EPSZR) THEN
C
        N1     = 1
        X1(N1) = X
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO JJ=1,LAM+1
          FS(N1,JJ) = F1(N1,JJ)
        ENDDO
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=17.
C             EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C             AND RECURRENCE IN DIRECTION OF DECREASING M.
      ELSEIF(X.GT.EPSZR.AND.X.LE.EPSPL) THEN
C
        N2     = 1
        X2(N2) = X
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO JJ=1,LAM+1
          FS(N2,JJ) = F2(N2,JJ)
        ENDDO
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      ELSEIF(X.GT.EPSPL.AND.X.LE.EPSAS) THEN
C
        N3     = 1
        X3(N3) = X
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO JJ=1,LAM+1
          FS(N3,JJ) = F3(N3,JJ)
        ENDDO
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      ELSE
C
        N4     = 1
        X4(N4) = X
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO JJ=1,LAM+1
          FS(N4,JJ) = F4(N4,JJ)
        ENDDO
C
      ENDIF
C
      WRITE(8, *) X,(FS(1,L),L=1,LAM+1)
C
      ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              HH    HH  GGGGGG TTTTTTTT FFFFFFFF SSSSSS               C
C              HH    HH GG    GG   TT    FF      SS    SS              C
C              HH    HH GG         TT    FF      SS                    C
C              HHHHHHHH GG         TT    FFFFFF   SSSSSS               C
C              HH    HH GG   GGG   TT    FF            SS              C
C              HH    HH GG    GG   TT    FF      SS    SS              C
C              HH    HH  GGGGGG    TT    FF       SSSSSS               C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTFS GENERATES AN ARRAY OF HGTF FUNCTIONS EVALUATED AT A SET OF    C
C  COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM TO       C
C  TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A        C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTRE, RP.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION EXL(MBS,2),NBAS(2)
      DIMENSION XYZEVAL(3),XYZ(3,2)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     CALCULATE NUMBER OF UNIQUE CONTRIBUTIONS TO FINITE EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OF EXPONENTS
          PAB  = EXL(IBAS,1)+EXL(JBAS,2)
C
C         HGTF CENTRE COORDINATES
          PX = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/PAB
          PY = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/PAB
          PZ = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/PAB
C
C         COORDINATES WRT LOCAL ORIGIN
          RPX = XYZEVAL(1)-PX
          RPY = XYZEVAL(2)-PY
          RPZ = XYZEVAL(3)-PZ
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS = DEXP(-PAB*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C         CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            HALPH = HERMITE(PAB,RPX,IA(ITUV))
            HBETA = HERMITE(PAB,RPY,IB(ITUV))
            HGAMA = HERMITE(PAB,RPZ,IC(ITUV))
C
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = HALPH*HBETA*HGAMA*GSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION HERMITE(P,X,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    HH    HH EEEEEEEE RRRRRRR  MM       MM IIII TTTTTTTT EEEEEEEE     C
C    HH    HH EE       RR    RR MMM     MMM  II     TT    EE           C
C    HH    HH EE       RR    RR MMMM   MMMM  II     TT    EE           C
C    HHHHHHHH EEEEEE   RR    RR MM MM MM MM  II     TT    EEEEEE       C
C    HH    HH EE       RRRRRRR  MM  MMM  MM  II     TT    EE           C
C    HH    HH EE       RR    RR MM   M   MM  II     TT    EE           C
C    HH    HH EEEEEEEE RR    RR MM       MM IIII    TT    EEEEEEEE     C
C                                                                      C
C -------------------------------------------------------------------- C
C  HERMITE EVALUATES HERMITE POLYNOMIAL H_I (P,X) BY RECURRENCE.       C
C**********************************************************************C
C
      IF(I.LT.0) THEN
        WRITE(6, *) 'In HERMITE: index less than zero. I = ',I
        WRITE(7, *) 'In HERMITE: index less than zero. I = ',I
        STOP
      ENDIF
C
      IF(I.GT.40) THEN
        WRITE(6, *) 'In HERMITE: index greater than 40. I = ',I
        WRITE(7, *) 'In HERMITE: index greater than 40. I = ',I
        STOP
      ENDIF
C
C     NEED FIRST TWO VALUES TO ESTABLISH RECURRENCE RELATION
      TEMP1 = 1.0D0
      TEMP2 = 2.0D0*P*X
C
      IF(I.EQ.0) THEN
        HERMITE = TEMP1
      ELSEIF(I.EQ.1) THEN
        HERMITE = TEMP2
      ELSEIF(I.GT.1) THEN
        DO N=2,I
          TEMP3 = 2.0D0*P*(X*TEMP2 - (N-1)*TEMP1)
          TEMP1 = TEMP2
          TEMP2 = TEMP3
        ENDDO
        HERMITE = TEMP2
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE HTFRMS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       HH    HH TTTTTTTT FFFFFFFF RRRRRRR  MM       MM  SSSSSS        C
C       HH    HH    TT    FF       RR    RR MMM     MMM SS    SS       C
C       HH    HH    TT    FF       RR    RR MMMM   MMMM SS             C
C       HHHHHHHH    TT    FFFFFF   RR    RR MM MM MM MM  SSSSSS        C
C       HH    HH    TT    FF       RRRRRRR  MM  MMM  MM       SS       C
C       HH    HH    TT    FF       RR    RR MM   M   MM SS    SS       C
C       HH    HH    TT    FF       RR    RR MM       MM  SSSSSS        C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTFS GENERATES AN ARRAY OF HGTF FOURIER TRANSFORMS EVALUATED AT A  C
C  SET OF COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM   C
C  TO TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A     C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTRE, RP.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,2),NBAS(2)
      DIMENSION XYZEVAL(3),XYZ(3,2)
C
      COMPLEX*16 CONE,PHS,PHSQP
      COMPLEX*16 HABC(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CALCULATE NUMBER OF UNIQUE CONTRIBUTIONS TO FINITE EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OF EXPONENTS
          PAB  = EXL(IBAS,1)+EXL(JBAS,2)
C
C         HGTF CENTRE COORDINATES
          PX = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/PAB
          PY = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/PAB
          PZ = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/PAB
C
C         COORDINATES WRT LOCAL ORIGIN
          QPX = XYZEVAL(1)*PX
          QPY = XYZEVAL(2)*PY
          QPZ = XYZEVAL(3)*PZ
C
C         DOT PRODUCT FACTOR (COMPLEX WITH UNIT MAGNITUDE)
          QPVEC = QPX+QPY+QPZ
C         PHSQP = DEXP(-CONE*QPVEC)
          PHSQP = DCOS(QPVEC) + CONE*DSIN(QPVEC)
C
C         GAUSSIAN COMPONENT OF HTFRM
          QX2 = XYZEVAL(1)*XYZEVAL(1)
          QY2 = XYZEVAL(2)*XYZEVAL(2)
          QZ2 = XYZEVAL(3)*XYZEVAL(3)
          GSS = DEXP(-0.75D0*(QX2*QX2+QY2*QY2+QZ2*QZ2)/PAB)
C
C         INTEGRAL TRANSFORM TERM
          PRT = PAB*DSQRT(PAB)
          SCL = PI*PI12/PRT
C
C         CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           TEST TO DETERMINE MULTIPLICATIVE FACTOR
            IF(MOD(ILAM(ITUV),4).EQ.0) THEN
              PHS = DCMPLX(1.0D0,0.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.1) THEN
              PHS =-DCMPLX(0.0D0,1.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.2) THEN
              PHS =-DCMPLX(1.0D0,0.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.3) THEN
              PHS = DCMPLX(0.0D0,1.0D0)
            ENDIF
C
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            QXA = XYZEVAL(1)**(IA(ITUV))
            QXB = XYZEVAL(2)**(IB(ITUV))
            QXC = XYZEVAL(3)**(IC(ITUV))
C
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = SCL*PHS*QXA*QXB*QXC*PHSQP*GSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [12] EQ-COEFFS: BASIS FUNCTION OVERLAP SPIN-STRUCTURE FACTORS.      C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] EQSAVE: MAIN ROUTINE FOR BUILDING A GLOBAL FILE OF EQ-COEFFS.  C
C   [B] E0LLGN: GENERATE FULL SET OF E0LL COEFFICIENTS AND SAVE.       C
C   [C] E0SSGN: GENERATE FULL SET OF E0SS COEFFICIENTS AND SAVE.       C
C   [D] EILSGN: GENERATE FULL SET OF EILS COEFFICIENTS AND SAVE.       C
C   [E] EISLGN: GENERATE FULL SET OF EISL COEFFICIENTS AND SAVE.       C
C -------------------------------------------------------------------- C
C   [A] EQLLMK: GENERATE A BATCH OF EQLL COEFFICIENTS: (--) AND (+-).  C
C   [B] EQLSMK: GENERATE A BATCH OF EQLS COEFFICIENTS: (--) AND (+-).  C
C   [C] EQSLMK: GENERATE A BATCH OF EQSL COEFFICIENTS: (--) AND (+-).  C
C   [D] EQSSMK: GENERATE A BATCH OF EQSS COEFFICIENTS: (--) AND (+-).  C
C   [E] EILSB3: GENERATE A VECTOR BATCH OF EILS COEFFICIENTS FOR BREIT.C
C   [F] EISLB3: GENERATE A VECTOR BATCH OF EISL COEFFICIENTS FOR BREIT.C
C   [G] EQLL: A RAW BLOCK OF EQLL COEFFICIENTS FOR EQLLMK.             C
C   [H] EQLS: A RAW BLOCK OF EQLS COEFFICIENTS FOR EQLSMK.             C
C   [I] EQSL: A RAW BLOCK OF EQSL COEFFICIENTS FOR EQSLMK.             C
C   [J] EQSS: A RAW BLOCK OF EQSS COEFFICIENTS FOR EQSSMK.             C
C   [K] ESGTF: SET OF ES-COEFFS OVER SPHERICAL HARMONICS AND HGTFS.    C
C   [L] EVRS: EXPANSION COEFFS IN HGTF OVERLAPS, CALLED IN ESGTF.      C
C   [M] ESTEPLM: SIMULTANEOUS INCREASE IN (L,M) FOR USE IN EVRS.       C
C   [N] ESTEPL: INCREMENT IN L FOR USE IN EVRS.                        C
C   [O] ESTEPN: INCREMENT IN N FOR USE IN EVRS.                        C
C -------------------------------------------------------------------- C
C   [A] RNORM1: A BLOCK OF TT' NORMALISATION COEFFS.                   C
C   [B] DNORM: NORM FOR A REAL OR COMPLEX PART OF EQ-COEFF LIST.       C
C**********************************************************************C
C
C
      SUBROUTINE EQSAVE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        EEEEEEEE  QQQQQQ    SSSSSS     AA    VV    VV EEEEEEEE        C
C        EE       QQ    QQ  SS    SS   AAAA   VV    VV EE              C
C        EE      QQ      QQ SS        AA  AA  VV    VV EE              C
C        EEEEEE  QQ      QQ  SSSSSS  AA    AA VV    VV EEEEEE          C
C        EE      QQ      QQ       SS AAAAAAAA  VV  VV  EE              C
C        EE       QQ    QQ  SS    SS AA    AA   VVVV   EE              C
C        EEEEEEEE  QQQQQQ QQ SSSSSS  AA    AA    VV    EEEEEEEE        C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSAVE CONSTRUCTS A SET OF COMMON ARRAYS FOR ALL REQUIRED EQTT'     C
C  COEFFICIENTS IN A CALCULATION THAT RESTS WITHIN QED.                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION NTUV(0:MKP+1,4),NTRM(0:MKP+1,4),NWRD(0:MKP+1,4),
     &          SPCE(0:MKP+1,4)
      DIMENSION NTUVT(4),NTRMT(4),NWRDT(4),SPCET(4)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     MAXIMUM REQUIRED COMPONENT TYPES
      IF(HMLT.EQ.'NORL') THEN
        ITTMAX = 1
      ELSEIF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') THEN
        ITTMAX = 2
      ELSEIF(TREE.NE.'MBPTN') THEN
        ITTMAX = 3
      ELSE
        ITTMAX = 4
      ENDIF
C
C**********************************************************************C
C     LOOP OVER FOCK BLOCK AND COUNT ALL REQUIRED EQ-WORDS.            C
C**********************************************************************C
C
C     INITIALISE MAXIMUM LAMBDA
      LAMMX = 0
C
C     INITIALISE TOTAL COEFFICIENT COUNTERS
      DO ITT=1,4
        DO LAM=0,MKP+1
          NTUV(LAM,ITT) = 0
          NTRM(LAM,ITT) = 0
          NWRD(LAM,ITT) = 0
          SPCE(LAM,ITT) = 0.0D0
        ENDDO
        NTUVT(ITT) = 0
        NTRMT(ITT) = 0
        NWRDT(ITT) = 0
        SPCET(ITT) = 0.0D0
      ENDDO
C
C     LOOP OVER CENTRES A AND B
      DO ICNTA=1,NCNT
        DO ICNTB=1,NCNT
C
C         LOOP OVER KQNA VALUES
          DO KA=1,NKAP(ICNTA)
C
C           QUANTUM NUMBERS FOR BLOCK A
            IF(KAPA(KA,ICNTA).LT.0) THEN
              LQNA =-KAPA(KA,ICNTA)-1
            ELSE
              LQNA = KAPA(KA,ICNTA)
            ENDIF
            NBASA = NFNC(LQNA,ICNTA)
C
C           LOOP OVER KQNB VALUES
            DO KB=1,NKAP(ICNTB)
C
C             QUANTUM NUMBERS FOR BLOCK B
              IF(KAPA(KB,ICNTB).LT.0) THEN
                LQNB =-KAPA(KB,ICNTB)-1
              ELSE
                LQNB = KAPA(KB,ICNTB)
              ENDIF
              NBASB = NFNC(LQNB,ICNTB)
C
C             LOOP OVER |MQNA| VALUES
              DO MA=1,IABS(KAPA(KA,ICNTA))
                MJA = 2*MA-1
C
C               LOOP OVER |MQNB| VALUES
                DO MB=1,IABS(KAPA(KB,ICNTB))
                  MJB = 2*MB-1
C
C                 NUMBER OF BASIS FUNCTION OVERLAPS
                  MAXAB = NBASA*NBASB
C
C                 CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
                  LAM  = LQNA+LQNB
C
C                 NUMBER OF TERMS IN EXPANSIONS OF THIS LENGTH
                  NTUV(LAM  ,1) = (LAM+1)*(LAM+2)*(LAM+3)/6
                  NTUV(LAM+2,2) = (LAM+3)*(LAM+4)*(LAM+5)/6
                  NTUV(LAM+1,3) = (LAM+2)*(LAM+3)*(LAM+4)/6
                  NTUV(LAM+1,4) = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C                 INCREASE NUMBER OF WORDS FOR THIS LAMBDA VALUE
                  NTRM(LAM  ,1) = NTRM(LAM  ,1) + NTUV(LAM  ,1)*MAXAB
                  NTRM(LAM+2,2) = NTRM(LAM+2,2) + NTUV(LAM+2,2)*MAXAB
                  NTRM(LAM+1,3) = NTRM(LAM+1,3) + NTUV(LAM+1,3)*MAXAB
                  NTRM(LAM+1,4) = NTRM(LAM+1,4) + NTUV(LAM+1,4)*MAXAB
C
C                 UPDATE LARGEST LAMBDA VALUE
                  IF(LAM.GT.LAMMX) THEN
                    LAMMX = LAM
                  ENDIF
C
C               END LOOPS OVER |MQNA| AND |MQNB|
                ENDDO
              ENDDO
C
C           END LOOPS OVER KQNA AND KQNB
            ENDDO
          ENDDO
C
C       END LOOPS OVER ICNTA AND ICNTB
        ENDDO
      ENDDO
C
C     NUMBER OF WORDS IN SET AND SPACE REQUIRED
      DO LAM=0,LAMMX+2
        NWRD(LAM,1) =  4*NTRM(LAM,1)
        NWRD(LAM,2) =  4*NTRM(LAM,2)
        NWRD(LAM,3) = 12*NTRM(LAM,3)
        NWRD(LAM,4) = 12*NTRM(LAM,4)
        DO ITT=1,ITTMAX
          SPCE(LAM,ITT) = 8.0D-6*NWRD(LAM,ITT)
        ENDDO
      ENDDO
C
C     CALCULATE TOTALS
      DO ITT=1,ITTMAX
        DO LAM=0,LAMMX+2
          NTUVT(ITT) = NTUVT(ITT) + NTUV(LAM,ITT)
          NTRMT(ITT) = NTRMT(ITT) + NTRM(LAM,ITT)
          NWRDT(ITT) = NWRDT(ITT) + NWRD(LAM,ITT)
          SPCET(ITT) = SPCET(ITT) + SPCE(LAM,ITT)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     SUMMARY OF WORD ANALYSIS                                         C
C**********************************************************************C
C
C     SECTION TITLE
20    FORMAT(1X,A,9X,A,4X,A,6X,A,8X,A,8X,A,6X,A)
21    FORMAT(1X,A,8X,I2,4X,I5,3X,I9,7X,I2,3X,I10,5X,F10.3)
22    FORMAT(1X,A,13X,I10,7X,I2,3X,I10,5X,F10.3)
23    FORMAT(1X,A,9X,I2,3X,I5,3X,I9,7X,I2,3X,I10,5X,F10.3)
24    FORMAT(1X,A,5X,A,3X,A,6X,A,8X,A,8X,A,6X,A)
25    FORMAT(1X,A,40X,I10,5X,F10.3)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',22),'Eq-coefficient word analysis'
      WRITE(7, *) REPEAT(' ',22),'Eq-coefficient word analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) 'Type','Λ','Terms','Length','#','Words','Size (MB)'
      WRITE(7,20) 'Type','Λ','Terms','Length','#','Words','Size (MB)'
C
C     E0LL ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=0,LAMMX
        IF(LAM.EQ.0) THEN
          WRITE(6,21) 'E0LL',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
          WRITE(7,21) 'E0LL',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
          WRITE(7,21) '    ',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
        ENDIF
      ENDDO
C
      IF(HMLT.EQ.'NORL') GOTO 100
C
C     E0SS ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=2,LAMMX+2
        IF(LAM.EQ.2) THEN
          WRITE(6,21) 'E0SS',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
          WRITE(7,21) 'E0SS',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
          WRITE(7,21) '    ',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
        ENDIF
      ENDDO
C
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 100
C
C     E0SS ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=1,LAMMX+1
        IF(LAM.EQ.1) THEN
          WRITE(6,21) 'EILS',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
          WRITE(7,21) 'EILS',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
          WRITE(7,21) '    ',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
        ENDIF
      ENDDO
C
      IF(TREE.NE.'MBPTN') GOTO 100
C
C     EISL ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=1,LAMMX+1
        IF(LAM.EQ.1) THEN
          WRITE(6,21) 'EISL',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
          WRITE(7,21) 'EISL',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
          WRITE(7,21) '    ',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
        ENDIF
      ENDDO
C
100   CONTINUE
C
C     SUMMARY OF TOTALS
      NWRDNET = 0
      SPCENET = 0.0D0
      DO ITT=1,ITTMAX
        NWRDNET = NWRDNET + NWRDT(ITT)
        SPCENET = SPCENET + SPCET(ITT)
      ENDDO
C
C     FIGURE OUT HOW MUCH SPACE IS ALLOWED BY PARAMETERS
      IF(HMLT.EQ.'NORL') THEN
        MWRD = 4
        MARR = 1
      ENDIF
      IF(HMLT.EQ.'DHFR') THEN
        MWRD = 8
        MARR = 2
      ENDIF
      IF(HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
        MWRD = 20
        MARR = 3
      ENDIF
      IF(TREE.EQ.'MBPTN') THEN
        IF(HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
          MWRD = 32
          MARR = 4
        ENDIF
      ENDIF
      SPCEMFL = 8.0D-6*MARR*MWRD*MFL
C
C     SUMMARISE TOTALS BY OVERLAP TYPE
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,24) 'Total','Λ_max','Terms','Length','#',
     &                                              'Words','Size (MB)'
      WRITE(7,24) 'Total','Λ_max','Terms','Length','#',
     &                                              'Words','Size (MB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'E0LL',LAMMX  ,NTUVT(1),NTRMT(1), 4,NWRDT(1),SPCET(1)
      WRITE(7,23) 'E0LL',LAMMX  ,NTUVT(1),NTRMT(1), 4,NWRDT(1),SPCET(1)
      IF(HMLT.EQ.'NORL') GOTO 200
      WRITE(6,23) 'E0SS',LAMMX+2,NTUVT(2),NTRMT(2), 4,NWRDT(2),SPCET(2)
      WRITE(7,23) 'E0SS',LAMMX+2,NTUVT(2),NTRMT(2), 4,NWRDT(2),SPCET(2)
      IF(HMLT.EQ.'DHFR') GOTO 200
      WRITE(6,23) 'EILS',LAMMX+1,NTUVT(3),NTRMT(3),12,NWRDT(3),SPCET(3)
      WRITE(7,23) 'EILS',LAMMX+1,NTUVT(3),NTRMT(3),12,NWRDT(3),SPCET(3)
      IF(TREE.NE.'MBPTN') GOTO 200
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 200
      WRITE(6,23) 'EISL',LAMMX+1,NTUVT(4),NTRMT(4),12,NWRDT(4),SPCET(4)
      WRITE(7,23) 'EISL',LAMMX+1,NTUVT(4),NTRMT(4),12,NWRDT(4),SPCET(4)
200   CONTINUE
C      
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,25) '       ',NWRDNET,SPCENET
      WRITE(7,25) '       ',NWRDNET,SPCENET
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'parameters.h',MFL,MWRD,MWRD*MFL,SPCEMFL
      WRITE(7,22) 'parameters.h',MFL,MWRD,MWRD*MFL,SPCEMFL
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     OPTION WHEN NUMBER OF WORDS EXCEEDS ALLOCATED SIZE LIMIT
      IF(NTRMT(1).GT.MFL) THEN
        WRITE(6, *) 'In EQSAVE: E0LL words exceed allocated limit.'
        WRITE(7, *) 'In EQSAVE: E0LL words exceed allocated limit.'
        GOTO 150
      ENDIF
C
      IF(HMLT.NE.'NORL') THEN
        IF(NTRMT(2).GT.MFL) THEN
          WRITE(6, *) 'In EQSAVE: E0SS words exceed allocated limit.'
          WRITE(7, *) 'In EQSAVE: E0SS words exceed allocated limit.'
          GOTO 150
        ENDIF
      ENDIF
C     NO NEED TO ASK ABOUT EILS OR EISL! E0SS IS LARGER THAN EITHER.
C
C     SIZE LIMITS ARE ALL OK -- SKIP TO BATCH GENERATION
      GOTO 250
C
C     ONE OF THE CLASSES EXCEEDS WORD LIMIT
150   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     HAVE TO GENERATE E COEFFICIENTS BY BATCH
      WRITE(6, *) 'In EQSAVE: Eq-coefficients to be generated by batch.'
      WRITE(7, *) 'In EQSAVE: Eq-coefficients to be generated by batch.'
C
C     FLIP THE EQ-GENERATION TOGGLE AND EXIT
      EQFILE = .FALSE.
      GOTO 300
C
250   CONTINUE
C
C**********************************************************************C
C     GENERATE COMPLETE BATCHES OF EQ-COEFFS                           C
C**********************************************************************C
C
C     SECTION TITLE
      WRITE(6, *) REPEAT(' ',18),'Generating Eq-coefficient data files'
      WRITE(7, *) REPEAT(' ',18),'Generating Eq-coefficient data files'
C
C     E0LL COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL E0LLGN
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 300
C
C     E0SS COEFFICIENTS
      CALL E0SSGN
      CALL CPU_TIME(TDM3)
      TESS = TELL+TDM3-TDM2
C
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 300
C
C     EILS COEFFICIENTS
      CALL EILSGN
      CALL CPU_TIME(TDM4)
      TELS = TELS+TDM4-TDM3
C
      IF(TREE.NE.'MBPTN') GOTO 300
C
C     EISL COEFFICIENTS
      CALL EISLGN
      CALL CPU_TIME(TDM5)
      TESL = TESL+TDM5-TDM4
C
300   CONTINUE
C
C     END OF SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE E0LLGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE 000000  LL       LL       GGGGGG  NN    NN          C
C         EE      00   000 LL       LL      GG    GG NNN   NN          C
C         EE      00  0000 LL       LL      GG       NNNN  NN          C
C         EEEEEE  00 00 00 LL       LL      GG       NN NN NN          C
C         EE      0000  00 LL       LL      GG   GGG NN  NNNN          C
C         EE      000   00 LL       LL      GG    GG NN   NNN          C
C         EEEEEEEE 000000  LLLLLLLL LLLLLLLL GGGGGG  NN    NN          C
C                                                                      C
C -------------------------------------------------------------------- C
C  E0LLGN GENERATES A FULL SET OF E0LL COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY E0LL, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)
      NTUVLL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ELL0(AB) COEFFICIENTS
      CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ELL0(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLL
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0LLFL(IAD+M,1) = DREAL(E11(M,ITUV))
          E0LLFL(IAD+M,2) = DIMAG(E11(M,ITUV))
          E0LLFL(IAD+M,3) = DREAL(E21(M,ITUV))
          E0LLFL(IAD+M,4) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLL*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE E0SSGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE 000000   SSSSSS   SSSSSS   GGGGGG  NN    NN         C
C         EE      00   000 SS    SS SS    SS GG    GG NNN   NN         C
C         EE      00  0000 SS       SS       GG       NNNN  NN         C
C         EEEEEE  00 00 00  SSSSSS   SSSSSS  GG       NN NN NN         C
C         EE      0000  00       SS       SS GG   GGG NN  NNNN         C
C         EE      000   00 SS    SS SS    SS GG    GG NN   NNN         C
C         EEEEEEEE 000000   SSSSSS   SSSSSS   GGGGGG  NN    NN         C
C                                                                      C
C -------------------------------------------------------------------- C
C  E0SSGN GENERATES A FULL SET OF E0SS COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY E0SS, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ESS0(AB) COEFFICIENTS
      CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ESS0(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVSS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0SSFL(IAD+M,1) = DREAL(E11(M,ITUV))
          E0SSFL(IAD+M,2) = DIMAG(E11(M,ITUV))
          E0SSFL(IAD+M,3) = DREAL(E21(M,ITUV))
          E0SSFL(IAD+M,4) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVSS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EILSGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII LL       SSSSSS   GGGGGG  NN    NN           C
C           EE        II  LL      SS    SS GG    GG NNN   NN           C
C           EE        II  LL      SS       GG       NNNN  NN           C
C           EEEEEE    II  LL       SSSSSS  GG       NN NN NN           C
C           EE        II  LL            SS GG   GGG NN  NNNN           C
C           EE        II  LL      SS    SS GG    GG NN   NNN           C
C           EEEEEEEE IIII LLLLLLLL SSSSSS   GGGGGG  NN    NN           C
C                                                                      C
C -------------------------------------------------------------------- C
C  EILSGN GENERATES A FULL SET OF EILS COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY EILS, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+1
      NTUVLS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IADILS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE EILS(AB) COEFFICIENTS
      CALL EQLSMK(E11X,E21X,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQLSMK(E11Y,E21Y,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQLSMK(E11Z,E21Z,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
C
C     WRITE EILS(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          EILSFL(IAD+M, 1) = DREAL(E11X(M,ITUV))
          EILSFL(IAD+M, 2) = DIMAG(E11X(M,ITUV))
          EILSFL(IAD+M, 3) = DREAL(E21X(M,ITUV))
          EILSFL(IAD+M, 4) = DIMAG(E21X(M,ITUV))
          EILSFL(IAD+M, 5) = DREAL(E11Y(M,ITUV))
          EILSFL(IAD+M, 6) = DIMAG(E11Y(M,ITUV))
          EILSFL(IAD+M, 7) = DREAL(E21Y(M,ITUV))
          EILSFL(IAD+M, 8) = DIMAG(E21Y(M,ITUV))
          EILSFL(IAD+M, 9) = DREAL(E11Z(M,ITUV))
          EILSFL(IAD+M,10) = DIMAG(E11Z(M,ITUV))
          EILSFL(IAD+M,11) = DREAL(E21Z(M,ITUV))
          EILSFL(IAD+M,12) = DIMAG(E21Z(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EISLGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII  SSSSSS  LL       GGGGGG  NN    NN           C
C           EE        II  SS    SS LL      GG    GG NNN   NN           C
C           EE        II  SS       LL      GG       NNNN  NN           C
C           EEEEEE    II   SSSSSS  LL      GG       NN NN NN           C
C           EE        II        SS LL      GG   GGG NN  NNNN           C
C           EE        II  SS    SS LL      GG    GG NN   NNN           C
C           EEEEEEEE IIII  SSSSSS  LLLLLLLL GGGGGG  NN    NN           C
C                                                                      C
C -------------------------------------------------------------------- C
C  EISLGN GENERATES A FULL SET OF EISL COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY EISL, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        LQN(1) = LVAL(KQN(1))
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        LQN(2) = LVAL(KQN(2))
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+1
      NTUVSL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IADISL(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE EISL(AB) COEFFICIENTS
      CALL EQSLMK(E11X,E21X,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQSLMK(E11Y,E21Y,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQSLMK(E11Z,E21Z,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
C
C     WRITE EISL(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVSL
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          EISLFL(IAD+M, 1) = DREAL(E11X(M,ITUV))
          EISLFL(IAD+M, 2) = DIMAG(E11X(M,ITUV))
          EISLFL(IAD+M, 3) = DREAL(E21X(M,ITUV))
          EISLFL(IAD+M, 4) = DIMAG(E21X(M,ITUV))
          EISLFL(IAD+M, 5) = DREAL(E11Y(M,ITUV))
          EISLFL(IAD+M, 6) = DIMAG(E11Y(M,ITUV))
          EISLFL(IAD+M, 7) = DREAL(E21Y(M,ITUV))
          EISLFL(IAD+M, 8) = DIMAG(E21Y(M,ITUV))
          EISLFL(IAD+M, 9) = DREAL(E11Z(M,ITUV))
          EISLFL(IAD+M,10) = DIMAG(E11Z(M,ITUV))
          EISLFL(IAD+M,11) = DREAL(E21Z(M,ITUV))
          EISLFL(IAD+M,12) = DIMAG(E21Z(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVSL*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    LL       LL       MM       MM KK    KK      C
C      EE       QQ    QQ   LL       LL       MMM     MMM KK   KK       C
C      EE      QQ      QQ  LL       LL       MMMM   MMMM KK  KK        C
C      EEEEEE  QQ      QQ  LL       LL       MM MM MM MM KKKKK         C
C      EE      QQ      QQ  LL       LL       MM  MMM  MM KK  KK        C
C      EE       QQ    QQ   LL       LL       MM   M   MM KK   KK       C
C      EEEEEEEE  QQQQQQ QQ LLLLLLLL LLLLLLLL MM       MM KK    KK      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLLMK GENERATES A BATCH OF EQLL COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     CALCULATE LQN VALUES
      LA = LVAL(KQ2(1))
      LB = LVAL(KQ2(2))
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLL  = LA+LB
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLL BY PHASE TERM IF EQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLL BY PHASE TERM IF EQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    LL       SSSSSS  MM       MM KK    KK       C
C      EE       QQ    QQ   LL      SS    SS MMM     MMM KK   KK        C
C      EE      QQ      QQ  LL      SS       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  LL       SSSSSS  MM MM MM MM KKKKK          C
C      EE      QQ      QQ  LL            SS MM  MMM  MM KK  KK         C
C      EE       QQ    QQ   LL      SS    SS MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS  MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLSMK GENERATES A BATCH OF EQLS COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     CALCULATE LQN VALUES
      LA = LVAL(KQ2(1))
      LB = LVAL(KQ2(2))
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+1
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    SSSSSS  LL       MM       MM KK    KK       C
C      EE       QQ    QQ  SS    SS LL       MMM     MMM KK   KK        C
C      EE      QQ      QQ SS       LL       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  SSSSSS  LL       MM MM MM MM KKKKK          C
C      EE      QQ      QQ       SS LL       MM  MMM  MM KK  KK         C
C      EE       QQ    QQ  SS    SS LL       MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ SSSSSS  LLLLLLLL MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSLMK GENERATES A BATCH OF EQSL COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     CALCULATE LQN VALUES
      LA = LVAL(KQ2(1))
      LB = LVAL(KQ2(2))
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSL  = LA+LB+1
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    SSSSSS   SSSSSS  MM       MM KK    KK       C
C      EE       QQ    QQ  SS    SS SS    SS MMM     MMM KK   KK        C
C      EE      QQ      QQ SS       SS       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  SSSSSS   SSSSSS  MM MM MM MM KKKKK          C
C      EE      QQ      QQ       SS       SS MM  MMM  MM KK  KK         C
C      EE       QQ    QQ  SS    SS SS    SS MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ SSSSSS   SSSSSS  MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSSMK GENERATES A BATCH OF EQSS COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+2 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     CALCULATE LQN VALUES
      LA = LVAL(KQ2(1))
      LB = LVAL(KQ2(2))
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSS  = LA+LB+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSS BY PHASE TERM IF EQSS ARE NEEDED
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSS BY PHASE TERM IF EQSS ARE NEEDED
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY SIMPLE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EILSB3(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII LL       SSSSSS  BBBBBBB   333333            C
C           EE        II  LL      SS    SS BB    BB 33    33           C
C           EE        II  LL      SS       BB    BB       33           C
C           EEEEEE    II  LL       SSSSSS  BBBBBBB    33333            C
C           EE        II  LL            SS BB    BB       33           C
C           EE        II  LL      SS    SS BB    BB 33    33           C
C           EEEEEEEE IIII LLLLLLLL SSSSSS  BBBBBBB   333333            C
C                                                                      C
C -------------------------------------------------------------------- C
C  EILSB3 GENERATES A BATCH OF EILS COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C  THIS ACTUALLY MAKES A VECTOR LIST OF THE EQLS NEEDED FOR BREIT.     C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+1
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E11X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQLS(E11Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQLS(E11Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV,1) = PHS*E11X(M,ITUV)
          E11(M,ITUV,2) = PHS*E11Y(M,ITUV)
          E11(M,ITUV,3) = PHS*E11Z(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)

C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E21X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQLS(E21Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQLS(E21Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV,1) = PHS*E21X(M,ITUV)
          E21(M,ITUV,2) = PHS*E21Y(M,ITUV)
          E21(M,ITUV,3) = PHS*E21Z(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EISLB3(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          EEEEEEEE IIII  SSSSSS  LL       BBBBBBB   333333            C
C          EE        II  SS    SS LL       BB    BB 33    33           C
C          EE        II  SS       LL       BB    BB       33           C
C          EEEEEE    II   SSSSSS  LL       BBBBBBB    33333            C
C          EE        II        SS LL       BB    BB       33           C
C          EE        II  SS    SS LL       BB    BB 33    33           C
C          EEEEEEEE IIII  SSSSSS  LLLLLLLL BBBBBBB   333333            C
C                                                                      C
C -------------------------------------------------------------------- C
C  EISLB3 GENERATES A BATCH OF EISL COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C  THIS ACTUALLY MAKES A VECTOR LIST OF EQSL NEEDED FOR BREIT (MBPT).  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSL  = LA+LB+1
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E11X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQSL(E11Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQSL(E11Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV,1) = PHS*E11X(M,ITUV)
          E11(M,ITUV,2) = PHS*E11Y(M,ITUV)
          E11(M,ITUV,3) = PHS*E11Z(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)

C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E21X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQSL(E21Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQSL(E21Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV,1) = PHS*E21X(M,ITUV)
          E21(M,ITUV,2) = PHS*E21Y(M,ITUV)
          E21(M,ITUV,3) = PHS*E21Z(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ELSQ FROM ESLQ.
C
      RETURN
      END
C
C
      SUBROUTINE EQLL(ELL,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                EEEEEEEE  QQQQQQ    LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EEEEEE  QQ      QQ  LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EEEEEEEE  QQQQQQ QQ LLLLLLLL LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLL GENERATES A BLOCK OF RAW EQLL/GQLL-COEFFICIENTS FOR A GIVEN    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQLLMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  OUTPUT:                                                             C
C  ▶ ELL  - RAW EQLL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNLL(MBS,MBS)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELL(MB2,MEQ),ESG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO ITUV=1,MEQ
        DO M=1,MB2
          ELL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     BASIS FUNCTION OVERLAP LIST LENGTH
      MAXM = NBS(1)*NBS(2)
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: ALL KQN(1) AND KQN(2) TYPES.                             C
C**********************************************************************C
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELL0 AND ELLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLL
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) +     CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLL
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELLX AND ELLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLL
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLL
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) +     CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      LAM0  = LQLAB(1)+LQLAB(2)
      NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C     GENERATE RNLL NORMALISATION CONSTANTS
      CALL RNORM1(RNLL,EXL,LQN,NBS,1)
C
C     NORMALISE THE ELLQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = RNLL(IBAS,JBAS)*ELL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ELLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = CONE*ELL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQLS(ELS,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    LL       SSSSSS                  C
C                 EE       QQ    QQ   LL      SS    SS                 C
C                 EE      QQ      QQ  LL      SS                       C
C                 EEEEEE  QQ      QQ  LL       SSSSSS                  C
C                 EE      QQ      QQ  LL            SS                 C
C                 EE       QQ    QQ   LL      SS    SS                 C
C                 EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLS GENERATES A BLOCK OF RAW EQLS-COEFFICIENTS FOR A GIVEN         C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQLSMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  OUTPUT:                                                             C
C  ▶ ELS  - RAW EQLS-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNLS(MBS,MBS)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ELS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(JBAS,2)
          T0(M) = DFLOAT(2*LQN(2)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-EXL(IBAS,1)*EXL(JBAS,2)*AB2/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(2).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQLS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+2
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNLS NORMALISATION CONSTANTS
      CALL RNORM1(RNLS,EXL,LQN,NBS,2)
C
C     NORMALISE THE ELSQ COEFFICIENT BLOCK AND MULTIPLY BY FACTOR i
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = CONE*RNLS(IBAS,JBAS)*ELS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ELSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = CONE*ELS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQSL(ESL,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS  LL                       C
C                 EE       QQ    QQ  SS    SS LL                       C
C                 EE      QQ      QQ SS       LL                       C
C                 EEEEEE  QQ      QQ  SSSSSS  LL                       C
C                 EE      QQ      QQ       SS LL                       C
C                 EE       QQ    QQ  SS    SS LL                       C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS  LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSL GENERATES A BLOCK OF RAW EQSL-COEFFICIENTS FOR A GIVEN         C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQSLMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  OUTPUT:                                                             C
C  ▶ ESL  - RAW EQSL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNSL(MBS,MBS)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESL(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(IBAS,1)
          T0(M) = DFLOAT(2*LQN(1)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESL0 AND ESLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESLX AND ESLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESL0 AND ESLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESLX AND ESLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSL [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+2
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNSL NORMALISATION CONSTANTS
      CALL RNORM1(RNSL,EXL,LQN,NBS,3)
C
C     NORMALISE THE ESLQ COEFFICIENT BLOCK AND MULTIPLY BY FACTOR -i
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV2
            ESL(M,ITUV) =-CONE*RNSL(IBAS,JBAS)*ESL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ESLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV2
            ESL(M,ITUV) = CONE*ESL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQSS(ESS,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS   SSSSSS                  C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EE      QQ      QQ SS       SS                       C
C                 EEEEEE  QQ      QQ  SSSSSS   SSSSSS                  C
C                 EE      QQ      QQ       SS       SS                 C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS   SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSS GENERATES A BLOCK OF RAW EQSS-COEFFICIENTS FOR A GIVEN         C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQSSMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  OUTPUT:                                                             C
C  ▶ ESS  - RAW EQSS-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNSS(MBS,MBS)
      DIMENSION T22(MB2),T20(MB2),T02(MB2),T00(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      RL1 = DFLOAT(2*LQN(1)+1)
      RL2 = DFLOAT(2*LQN(2)+1)
C
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T22(M) = 4.0D0*EXL(IBAS,1)*EXL(JBAS,2)
          T20(M) =-2.0D0*RL2*EXL(IBAS,1)
          T02(M) =-2.0D0*RL1*EXL(JBAS,2)
          T00(M) = RL1*RL2
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(1).LT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).LT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +    TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
200   CONTINUE
C
C**********************************************************************C
C     CASE 3: KQN(1).GT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).GT.0) GOTO 300
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

300   CONTINUE      
C
C**********************************************************************C
C     CASE 4: KQN(1).GT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).LT.0) GOTO 400
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL ESTEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL ESTEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL ESTEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          LAM2  = LQLAB(1)+LQLAB(2)+2
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL ESTEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL ESTEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO EQSS [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
400   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     GENERATE RNSS NORMALISATION CONSTANTS
      CALL RNORM1(RNSS,EXL,LQN,NBS,4)
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM4  = LQN(1)+LQN(2)+4
      NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C     NORMALISE THE ESSQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = RNSS(IBAS,JBAS)*ESS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ESSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = CONE*ESS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ESGTF(ESG,LQN,MQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              EEEEEEEE SSSSSS   GGGGGG TTTTTTTT FFFFFFFF              C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EE      SS       GG         TT    FF                    C
C              EEEEEE   SSSSSS  GG         TT    FFFFFF                C
C              EE            SS GG   GGG   TT    FF                    C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EEEEEEEE SSSSSS   GGGGGG    TT    FF                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESGTF CONSTRUCTS THE EXPANSION COEFFICIENTS OF THE OVERLAP DENSITY  C
C  OF TWO SPHERICAL HARMONIC FUNCTIONS IN AN AUXILIARY HGTF BASIS.     C
C                                                                      C
C  THE OVERLAP DENSITY IS DEFINED BY Y*[L,M]Y[L',M'], WHERE Y[L,M] ARE C
C  SPHERICAL HARMONICS FOLLOWING THE CONDON-SHORTLEY PHASE CONVENTION. C
C                                                                      C
C  THE REQUIRED COEFFICIENTS ARE GENERATED BY A CALL TO EVRS, WHICH IS C
C  CONSTRUCTED ACCORDING TO THE RECURRENCE RELATIONS DEFINED BY        C
C  V.R.SAUNDERS. THE OUTPUT OF EVRS IS THEN ADJUSTED TO INCLUDE THE    C
C  ANGULAR NORMALISATION CONSTANTS, AS WELL AS A PHASE FACTOR TO       C
C  CONVERT FROM THE SCHIFF TO THE CONDON-SHORTLEY PHASE CONVENTION.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LQN  - PAIR OF BASIS SET ORBITAL QUANTUM NUMBERS.                 C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ MAXM - SIZE OF THIS BLOCK.                                        C
C  OUTPUT:                                                             C
C  ▶ ESG  - EXPANSION COEFFICIENTS FOR EACH OVERLAP IN THE BLOCK.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQN(2),MQN(2),MQNLAB(2)
C
      COMPLEX*16 ESG(MB2,MEQ)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     EVRS IS CALLED WITH THE SIGN OF MQN(1) REVERSED
C     TO AFFECT COMPLEX CONJUGATION, ALONG WITH THE REQUISITE
C     PHASE, WHICH IS CALCULATED LATER.
      MQNLAB(1) =-MQN(1)
      MQNLAB(2) = MQN(2)
C
C     GENERATE RAW COEFFICIENTS WITH EVRS
      CALL EVRS(ESG,LQN,MQNLAB,MAXM)
C
C     MQN PHASES
      PHS1 = (-1.0D0)**((MQN(1)+IABS(MQN(1)))/2)
      PHS2 = (-1.0D0)**((MQN(2)+IABS(MQN(2)))/2)
C
C     CG COEFFICIENTS
      PI4 = 0.25D0/PI
      DGL = DFLOAT((2*LQN(1)+1)*(2*LQN(2)+1))
      CG1 = RFACT(LQN(1)-IABS(MQN(1)))/RFACT(LQN(1)+IABS(MQN(1)))
      CG2 = RFACT(LQN(2)-IABS(MQN(2)))/RFACT(LQN(2)+IABS(MQN(2)))
C
C     ANGULAR NORMALISATION CONSTANT
      ANG = PHS1*PHS2*PI4*DSQRT(DGL*CG1*CG2)
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      LAM  = LQN(1)+LQN(2)
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     APPLY ANGULAR FACTOR TO RAW COEFFICIENTS
      DO M=1,MAXM
        DO ITUV=1,NTUV
          ESG(M,ITUV) = ANG*ESG(M,ITUV)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE EVRS(ESG,LQN,MQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE VV    VV RRRRRRR   SSSSSS                   C
C                 EE       VV    VV RR    RR SS    SS                  C
C                 EE       VV    VV RR    RR SS                        C
C                 EEEEEE   VV    VV RR    RR  SSSSSS                   C
C                 EE        VV  VV  RRRRRRR        SS                  C
C                 EE         VVVV   RR    RR SS    SS                  C
C                 EEEEEEEE    VV    RR    RR  SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  EVRS EVALUATES THE EXPANSION COEFFICIENTS OF THE OVERLAP CHARGE     C
C  DENSITY OF SGTFS IN AN AUXILIARY HGTF. COEFFICIENTS ARE EVALUATED   C
C  USING THE RECURRENCE RELATIONS DEFINED BY VIC SAUNDERS IN:          C
C                                                                      C
C  V.R.SAUNDERS, "MOLECULAR INTEGRALS FOR GAUSSIAN-TYPE FUNCTIONS",    C
C  METHODS OF COMPUTATIONAL MOLECULAR PHYSICS, DIERCKSEN AND WILSON,   C
C  pp 1-26, REIDEL PUBLISHING, DORDRECHT (1983).                       C
C                                                                      C
C  THE EQ-COEFFS IN THIS PROCEDURE ARE FOR AN UN-NORMALISED SGTF.      C
C  THE COEFFICIENTS ARE DETERMINED ACCORDING TO THE SAME RULES AS      C
C  DEFINED IN THE ABOVE ARTICLE. CONSEQUENTLY, IT SHOULD BE NOTED THAT C
C  THE COEFFICIENTS ARE THOSE OF SPHERICAL HARMONIC FUNCTIONS THAT ARE C
C   ▶ UN-NORMALISED                                                    C
C   ▶ SATISFY THE SCHIFF PHASE CONVENTION.                             C
C                                                                      C
C  THE OUTLINE FOR THE GENERATION OF EQ-COEFFICIENTS IS TAKEN FROM p16 C
C  OF THE ABOVE ARTICLE. EQUATION NUMBERS ARE GIVEN IN COMMENTS.       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LQN  - PAIR OF BASIS SET ORBITAL QUANTUM NUMBERS.                 C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ MAXM - SIZE OF THIS BLOCK.                                        C
C  OUTPUT:                                                             C
C  ▶ ESG  - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION NBAS(2),LQN(2),MQN(2)
C
      COMPLEX*16 ESG(MB2,MEQ),ETEMP(MB2*MRC)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     IMPORT LQN AND BASIS PAIR MQNS FOR LOCAL USE
      LQNA = LQN(1)
      LQNB = LQN(2)
      MQNA = MQN(1)
      MQNB = MQN(2)
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      LMAX = LQN(1)+LQN(2)
      NTUV = (LMAX+1)*(LMAX+2)*(LMAX+3)/6
C
C     INITIALISE ESG AND ARRAY
      DO M=1,MAXM
        DO ITUV=1,NTUV
          ESG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     EXIT IF LQN,MQN ORDERS YIELD ZERO CG-COEFFICIENTS
      IF(IABS(MQN(1)).GT.LQN(1).OR.IABS(MQN(2)).GT.LQN(2)) RETURN
C
C     CHECK THAT LMAX IS WITHIN THE BOUNDS OF MKP
      IF(LMAX.GT.MKP+1) THEN
        WRITE(6, *) 'In EVRS: LMAX exceeds MKP+1 parameter.',LMAX,MKP+1
        WRITE(7, *) 'In EVRS: LMAX exceeds MKP+1 parameter.',LMAX,MKP+1
        STOP
      ENDIF
C
c     INITIALISE TEMPORARY ARRAY
      DO M=1,MB2*MRC
        ETEMP(M) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     SET INITIAL VALUES TO E[0,0;0,0;0,0,0,0] = RKAB
      DO M=1,MAXM
        ETEMP(M) = DCMPLX(RKAB(M),0.0D0)
      ENDDO
C
C     STEP 1:
C     GENERATE E[|MQNA|,MQNA;0,0] FROM E[0,0;0,0] USING
C     SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE A
      ISTART = 0
      LAM    = 0
      CALL ESTEPLM(ETEMP,LAM,ISTART,MQNA,MAXM,1)
C
C     STEP 2:
C     GENERATE E[LQNA,MQNA;0,0] FROM E[|MQNA|,MQNA;0,0]
C     USING THE STEP OF LQN ONLY ON CENTRE A
      CALL ESTEPL(ETEMP,LAM,ISTART,LQNA,MQNA,MAXM,1)
C
C     STEP 3:
C     GENERATE E[LQNA,MQNA;|MQNB|,MQNB] FROM E[LQNA,MQNA;0,0]
C     USING SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE B
      CALL ESTEPLM(ETEMP,LAM,ISTART,MQNB,MAXM,2)
C
C     STEP 4:
C     GENERATE E[LQNA,MQNA;LQNB,MQNB] FROM E[LQNA,MQNA;|MQNB|,MQNB]
C     USING THE STEP OF LQN ONLY ON CENTRE B
      CALL ESTEPL(ETEMP,LAM,ISTART,LQNB,MQNB,MAXM,2)
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     STEP 5:
C     COPY FINAL BLOCK OF ENTRIES AS THE REQUIRED OUTPUT
      K = 0
      DO ITUV=1,NTUV
        DO M=1,MAXM
          K = K+1
          ESG(M,ITUV) = ETEMP(ISTART+K)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ESTEPLM(ETEMP,LAM,ISTART,MQN,MAXM,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL       MM       MM    C
C   EE      SS    SS   TT    EE       PP    PP LL       MMM     MMM    C
C   EE      SS         TT    EE       PP    PP LL       MMMM   MMMM    C
C   EEEEEE   SSSSSS    TT    EEEEEE   PP    PP LL       MM MM MM MM    C
C   EE            SS   TT    EE       PPPPPPP  LL       MM  MMM  MM    C
C   EE      SS    SS   TT    EE       PP       LL       MM   M   MM    C
C   EEEEEEEE SSSSSS    TT    EEEEEEEE PP       LLLLLLLL MM       MM    C
C                                                                      C
C -------------------------------------------------------------------- C
C  SIMULTANEOUSLY INCREMENT THE QUANTUM NUMBERS LQN & MQN, STARTING    C
C  WITH E[0,0], USING THE RECURSION ALGORITHM OF V.R.SAUNDERS IN       C
C  `MOLECULAR INTEGRALS FOR GAUSSIAN TYPE FUNCTIONS' 1983.             C
C -------------------------------------------------------------------- C
C       E[0,0;IT,IU,IV] -> E[|MQN|+1,±(|MQN|+1);IT,IU,IV]  Eq.(64)     C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LAM    - LENGTH OF THE INPUT HGTF EXPANSION.                      C
C  ▶ ISTART - COUNTER TO TRACK THE START OF THIS PORTION OF THE LIST.  C
C  ▶ MQN    - MAGNETIC QUANTUM NUMBER.                                 C
C  ▶ MAXM   - NUMBER OF EXPONENT/DENSITY PAIRS.                        C
C  ▶ IZ     - CENTRE TO STEP UP.                                       C
C  OUTPUT:                                                             C
C  ▶ ETEMP  - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PX(MB2),PY(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(MB2*MRC)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IF |MQN|.EQ.0 THEN NO INCREMENT IN (LQN,MQN) IS REQUIRED
      IF(IABS(MQN).EQ.0) RETURN
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PX(M) = PAX(M)
          PY(M) = PAY(M)
        ELSEIF(IZ.EQ.2) THEN
          PX(M) = PBX(M)
          PY(M) = PBY(M)
        ENDIF
      ENDDO
C
C     PHASE TERM FOR SIGN OF MQN
      PHM = DFLOAT(ISIGN(1,MQN))
C
C     LOOP OVER ALL MAGNETIC NUMBERS UP TO THIS MQN (USE LQN AS COUNTER)
      DO LQN=0,IABS(MQN)-1
C
C       DEGENERACY COUNTER 2*LQN+1
        R2L1 = DFLOAT(2*LQN+1)
C
C       NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C       ISTART LABELS THE PREVIOUS LQN VALUE
C       JSTART LABELS THE CURRENT  LQN VALUE
C       KSTART LABELS THE NEXT     LQN VALUE
        JSTART = ISTART
        KSTART = JSTART + NTUV*MAXM
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C       J0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                               C
C       K0-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                               C
C       K1-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                               C
C       K2-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                               C
C       K3-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                               C
C       K4-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                               C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LQN)
              J0 = JSTART + (IABC(IT  ,IU  ,IV)-1)*MAXM
              K0 = KSTART + (IABC(IT  ,IU  ,IV)-1)*MAXM
              K1 = KSTART + (IABC(IT+1,IU  ,IV)-1)*MAXM
              K2 = KSTART + (IABC(IT  ,IU+1,IV)-1)*MAXM
              IF(IT.NE.0) K3 = KSTART + (IABC(IT-1,IU  ,IV  )-1)*MAXM
              IF(IU.NE.0) K4 = KSTART + (IABC(IT  ,IU-1,IV  )-1)*MAXM
C
C             INVOKE RECURRENCE RELATIONS ON LAYER (LQN+1)
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              DO M=1,MAXM
                T1 = R2L1/P2(M)
                TX = R2L1*PX(M)
                TY = R2L1*PY(M)
                ETEMP(K0+M) = ETEMP(K0+M) +          TX*ETEMP(J0+M)
     &                                    + PHM*CONE*TY*ETEMP(J0+M)
                ETEMP(K1+M) = ETEMP(K1+M) +          T1*ETEMP(J0+M)
                ETEMP(K2+M) = ETEMP(K2+M) + PHM*CONE*T1*ETEMP(J0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.NE.0) THEN
                FC = R2L1*DFLOAT(IT)
                DO M=1,MAXM
                  ETEMP(K3+M) = ETEMP(K3+M) +          FC*ETEMP(J0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.NE.0) THEN
                FC = R2L1*DFLOAT(IU)
                DO M=1,MAXM
                  ETEMP(K4+M) = ETEMP(K4+M) + PHM*CONE*FC*ETEMP(J0+M)
                ENDDO
              ENDIF
C
C           END OF LOOPS OVER HGTF INDICES
            ENDDO
          ENDDO
        ENDDO
C
C       UPDATE 'PREVIOUS' START VALUE
        ISTART = ISTART + NTUV*MAXM
C
C       UPDATE LAMBDA VALUE
        LAM = LAM+1
C
C     END OF LOOP OVER MQN COUNTER
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ESTEPL(ETEMP,LAM,ISTART0,LQN,MQN,MAXM,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL                C
C         EE      SS    SS   TT    EE       PP    PP LL                C
C         EE      SS         TT    EE       PP    PP LL                C
C         EEEEEE   SSSSSS    TT    EEEEEE   PP    PP LL                C
C         EE            SS   TT    EE       PPPPPPP  LL                C
C         EE      SS    SS   TT    EE       PP       LL                C
C         EEEEEEEE SSSSSS    TT    EEEEEEEE PP       LLLLLLLL          C
C                                                                      C
C -------------------------------------------------------------------- C
C  DECREMENT THE LQN, STARTING WITH E[MQN,±|MQN|], USING THE RECURSION C
C  ALGORITHM OF V.R.SAUNDERS IN `MOLECULAR INTEGRALS FOR GAUSSIAN TYPE C
C  FUNCTIONS' 1983 (EDITED BY G.H.F. DIERCKSEN AND S. WILSON).         C
C -------------------------------------------------------------------- C
C (1)  E[|MQN|,±MQN;IT,IU,IV] -> E[LQN+1,±MQN;IT,IU,IV]    Eq.(64)     C
C (2)  E[LQN  ,±MQN;IT,IU,IV] -> E[LQN+1,±MQN;IT,IU,IV]                C
C (3)  E[LQN-1,±MQN;IT,IU,IV] -> E[LQN+1,±MQN;IT,IU,IV]                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LAM     - LENGTH OF THE INPUT HGTF EXPANSION.                     C
C  ▶ ISTART0 - COUNTER TO TRACK THE START OF THIS PORTION OF THE LIST. C
C  ▶ LQN     - ORBITAL QUANTUM NUMBER.                                 C
C  ▶ MQN     - MAGNETIC QUANTUM NUMBER.                                C
C  ▶ MAXM    - NUMBER OF EXPONENT/DENSITY PAIRS.                       C
C  ▶ IZ      - CENTRE TO STEP UP.                                      C
C  OUTPUT:                                                             C
C  ▶ ETEMP   - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(MB2*MRC)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IF LQN.LE.|MQN| THEN NO INCREMENT IN LQN IS REQUIRED
      IF(LQN.LE.IABS(MQN)) RETURN
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(IZ.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     STEP (1): E[|MQN|,MQN;IT,IU,IV] -> E[|MQN|+1,MQN;IT,IU,IV].      C
C               IT MAPS SOME INDEX SETS FROM DATA OBTAINED IN ESTEPLM. C
C -------------------------------------------------------------------- C
C     INDEX MAPPINGS: J0-> E[MQN  ,MQN;IT  ,IU  ,IV  ]                 C
C                     K0-> E[MQN+1,MQN;IT  ,IU  ,IV  ]                 C
C                     K6-> E[MQN+1,MQN;IT  ,IU  ,IV+1]                 C
C                     K9-> E[MQN+1,MQN;IT  ,IU  ,IV-1]                 C
C**********************************************************************C
C
C     ISTART0 LABELS THE GLOBAL STARTING VALUE
C     ISTART  LABELS THE PREVIOUS LQN VALUE
C     JSTART  LABELS THE CURRENT  LQN VALUE
C     KSTART  LABELS THE NEXT     LQN VALUE
      JSTART = ISTART0
      KSTART = JSTART + NTUV*MAXM
C
C     OVERALL LQN/MQN FACTOR SIMPLIFIES WHEN LQN = |MQN|
      RLM  = DFLOAT(2*IABS(MQN)+1)
C
C     LOOP OVER THE HGTF INDICES OF THE SEED LAYER
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
C           STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LQN+1)
            J0 = JSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXM
            K0 = KSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXM
            K6 = KSTART + (IABC(IT  ,IU  ,IV+1)-1)*MAXM
            IF(IV.NE.0) K9 = KSTART + (IABC(IT  ,IU  ,IV-1)-1)*MAXM
C
C           INVOKE RECURRENCE RELATIONS ON LAYER (LQN+1)
C
C           TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
            DO M=1,MAXM
              TZ = RLM*PZ(M)
              TP = RLM/P2(M)
              ETEMP(K0+M) = ETEMP(K0+M) + TZ*ETEMP(J0+M)
              ETEMP(K6+M) = ETEMP(K6+M) + TP*ETEMP(J0+M)
            ENDDO
C
C           SPECIAL CASE EXCLUDES IV=0
            IF(IV.GE.1) THEN
              FC = RLM*DFLOAT(IV)
              DO M=1,MAXM
                ETEMP(K9+M) = ETEMP(K9+M) + FC*ETEMP(J0+M)
              ENDDO
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     UPDATE BLOCK LOCATORS
      ISTART  = ISTART0
      ISTART0 = ISTART0 + NTUV*MAXM
C
C     UPDATE LAMBDA VALUE
      LAM = LAM+1
C
C     IF LQN=|MQN|+1 THEN SET IS FINISHED
      IF(LQN.EQ.IABS(MQN)+1) RETURN
C
C**********************************************************************C
C   THIS AND SUBSEQUENT STEPS IN RECURRENCE INVOLVE THREE LAYERS:      C
C            E[LQN  ,MQN;IT,IU,IV] -> E[LQN+1,MQN;IT,IU,IV]            C
C            E[LQN-1,MQN;IT,IU,IV] -> E[LQN+1,MQN;IT,IU,IV]            C
C -------------------------------------------------------------------- C
C   INDEX MAPPINGS: I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                  C
C                   J0 -> E[LQN  ,MQN;IT  ,IU  ,IV  ]                  C
C                   K0 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                  C
C                   K1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                  C
C                   K2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                  C
C                   K3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                  C
C                   K4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                  C
C                   K5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                  C
C                   K6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                  C
C                   K7 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                  C
C                   K8 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                  C
C                   K9 -> E[LQN+1,MQN;IT  ,IU  ,IV-1]                  C
C                   K10-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                  C
C                   K11-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                  C
C                   K12-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                  C
C**********************************************************************C
C
C     LOOP OVER LSTP FOR FIXED MQN DOWN TO LQN-1
      DO LSTP=IABS(MQN)+1,LQN-1

C       OVERALL LSTP/MQN FACTORS
        RLM1 = DFLOAT(2*LSTP+1)/DFLOAT(LSTP-IABS(MQN)+1)
        RLM2 =-DFLOAT(LSTP+IABS(MQN))/DBLE(LSTP-IABS(MQN)+1)
C
C       NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
        JSTART = ISTART0
        KSTART = ISTART0 + MAXM*NTUV
C
C**********************************************************************C
C     STEP (2): E[LSTP  ,MQN;IT,IU,IV] -> E[LSTP+1,MQN;IT,IU,IV].      C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LSTP)
              J0 = JSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXM
              K0 = KSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXM
              K6 = KSTART + (IABC(IT  ,IU  ,IV+1)-1)*MAXM
              IF(IV.NE.0) K9 = KSTART + (IABC(IT  ,IU  ,IV-1)-1)*MAXM
C
C             INVOKE RECURRENCE RELATIONS ON LAYER (LSTP)
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              DO M=1,MAXM
                TZ = PZ(M)
                TP = 1.0D0/P2(M)
                ETEMP(K0+M) = ETEMP(K0+M) + TZ*RLM1*ETEMP(J0+M)
                ETEMP(K6+M) = ETEMP(K6+M) + TP*RLM1*ETEMP(J0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IV=0
              IF(IV.GE.1) THEN
                FC = DFLOAT(IV)
                DO M=1,MAXM
                  ETEMP(K9+M) = ETEMP(K9+M) + FC*RLM1*ETEMP(J0+M)
                ENDDO
              ENDIF
C
            ENDDO
          ENDDO
        ENDDO
C
C**********************************************************************C
C     STEP (3): E[LSTP-1,MQN;IT,IU,IV] -> E[LSTP+1,MQN;IT,IU,IV].      C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM-1
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LSTP)
              I0  = ISTART+(IABC(IT  ,IU  ,IV  )-1)*MAXM
              K0  = KSTART+(IABC(IT  ,IU  ,IV  )-1)*MAXM
              K1  = KSTART+(IABC(IT+2,IU  ,IV  )-1)*MAXM
              K2  = KSTART+(IABC(IT  ,IU+2,IV  )-1)*MAXM
              K3  = KSTART+(IABC(IT  ,IU  ,IV+2)-1)*MAXM
              K4  = KSTART+(IABC(IT+1,IU  ,IV  )-1)*MAXM
              K5  = KSTART+(IABC(IT  ,IU+1,IV  )-1)*MAXM
              K6  = KSTART+(IABC(IT  ,IU  ,IV+1)-1)*MAXM
              IF(IT.GT.0) K7  = KSTART + (IABC(IT-1,IU  ,IV  )-1)*MAXM
              IF(IU.GT.0) K8  = KSTART + (IABC(IT  ,IU-1,IV  )-1)*MAXM
              IF(IV.GT.0) K9  = KSTART + (IABC(IT  ,IU  ,IV-1)-1)*MAXM
              IF(IT.GT.1) K10 = KSTART + (IABC(IT-2,IU  ,IV  )-1)*MAXM
              IF(IU.GT.1) K11 = KSTART + (IABC(IT  ,IU-2,IV  )-1)*MAXM
              IF(IV.GT.1) K12 = KSTART + (IABC(IT  ,IU  ,IV-2)-1)*MAXM
C
C             INVOKE RECURRENCE RELATIONS ON LAYER (LSTP-1)
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              TI = DFLOAT(2*(IT+IU+IV)+3)
              DO M=1,MAXM
                T1 = 1.0D0/P22(M)
                TX = PX(M)/P(M)
                TY = PY(M)/P(M)
                TZ = PZ(M)/P(M)
                TT = PP(M) + TI/P2(M)
                ETEMP(K0+M) = ETEMP(K0+M) + RLM2*TT*ETEMP(I0+M)
                ETEMP(K1+M) = ETEMP(K1+M) + RLM2*T1*ETEMP(I0+M)
                ETEMP(K2+M) = ETEMP(K2+M) + RLM2*T1*ETEMP(I0+M)
                ETEMP(K3+M) = ETEMP(K3+M) + RLM2*T1*ETEMP(I0+M)
                ETEMP(K4+M) = ETEMP(K4+M) + RLM2*TX*ETEMP(I0+M)
                ETEMP(K5+M) = ETEMP(K5+M) + RLM2*TY*ETEMP(I0+M)
                ETEMP(K6+M) = ETEMP(K6+M) + RLM2*TZ*ETEMP(I0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.GE.1) THEN
                DO M=1,MAXM
                  TX = DFLOAT(2*IT)*PX(M)
                  ETEMP(K7+M) = ETEMP(K7+M) + RLM2*TX*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.GE.1) THEN
                DO M=1,MAXM
                  TY = DFLOAT(2*IU)*PY(M)
                  ETEMP(K8+M) = ETEMP(K8+M) + RLM2*TY*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IV=0
              IF(IV.GE.1) THEN
                DO M=1,MAXM
                  TZ = DFLOAT(2*IV)*PZ(M)
                  ETEMP(K9+M) = ETEMP(K9+M) + RLM2*TZ*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IT=0,1
              IF(IT.GE.2) THEN
                TX = DFLOAT(IT*(IT-1))
                DO M=1,MAXM
                  ETEMP(K10+M) = ETEMP(K10+M) + RLM2*TX*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0,1
              IF(IU.GE.2) THEN
                TY = DFLOAT(IU*(IU-1))
                DO M=1,MAXM
                  ETEMP(K11+M) = ETEMP(K11+M) + RLM2*TY*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IV=0,1
              IF(IV.GE.2) THEN
                TZ = DFLOAT(IV*(IV-1))
                DO M=1,MAXM
                  ETEMP(K12+M) = ETEMP(K12+M) + RLM2*TZ*ETEMP(I0+M)
                ENDDO
              ENDIF
C
            ENDDO
          ENDDO
        ENDDO
C
C       UPDATE BLOCK LOCATORS
        ISTART  = ISTART0
        ISTART0 = ISTART0 + MAXM*NTUV
C
C       UPDATE LAMBDA VALUE
        LAM = LAM+1
C
C     END OF LOOP OVER LSTP FOR FIXED MQN
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ESTEPN(ESG,ENSG,LAM,MAXM,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  NN    NN          C
C         EE      SS    SS   TT    EE       PP    PP NNN   NN          C
C         EE      SS         TT    EE       PP    PP NNNN  NN          C
C         EEEEEE   SSSSSS    TT    EEEEEE   PP    PP NN NN NN          C
C         EE            SS   TT    EE       PPPPPPP  NN  NNNN          C
C         EE      SS    SS   TT    EE       PP       NN   NNN          C
C         EEEEEEEE SSSSSS    TT    EEEEEEEE PP       NN    NN          C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE QUANTUM NUMBER (NQN):                                 C
C                E[NQN  ,LQN,MQN] -> E[NQN+1,LQN,MQN].                 C
C -------------------------------------------------------------------- C
C  ▶ ONLY PERFORMS A SINGLE STEP IN NQN.                               C
C  ▶ LAM IS THE EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE INPUT COEFFS.  C
C    EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE OUTPUT COEFFS IS LAM+2.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ESG  - EQ-COEFFICIENT BATCH.                                      C
C  ▶ LAM  - EFFECTIVE TOTAL ANGULAR MOMENTUM.                          C
C  ▶ MAXM - NUMBER OF EXPONENT/DENSITY PAIRS.                          C
C  ▶ IZ   - CENTRE TO STEP UP.                                         C
C  OUTPUT:                                                             C
C  ▶ ENSG - EQ-COEFFICIENT BATCH AFTER NQN HAS BEEN STEPPED UP.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM WITH N'=N+1
      NTUV = (LAM+3)*(LAM+4)*(LAM+5)/6
C
C     INITIALISE NEW ARRAY
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ENSG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(IZ.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C**********************************************************************C
C     INDEX MAPPINGS: I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                C
C                     K0 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                C
C                     K1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                C
C                     K2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                C
C                     K3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                C
C                     K4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                C
C                     K5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                C
C                     K6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                C
C                     K7 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                C
C                     K8 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                C
C                     K9 -> E[LQN+1,MQN;IT  ,IU  ,IV-1]                C
C                     K10-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                C
C                     K11-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                C
C                     K12-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                C
C**********************************************************************C
C
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
C           STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (NQN)
            I0  = IABC(IT  ,IU  ,IV  )
            K0  = IABC(IT  ,IU  ,IV  )
            K1  = IABC(IT+2,IU  ,IV  )
            K2  = IABC(IT  ,IU+2,IV  )
            K3  = IABC(IT  ,IU  ,IV+2)
            K4  = IABC(IT+1,IU  ,IV  )
            K5  = IABC(IT  ,IU+1,IV  )
            K6  = IABC(IT  ,IU  ,IV+1)
            IF(IT.GT.0) K7  = IABC(IT-1,IU  ,IV  )
            IF(IU.GT.0) K8  = IABC(IT  ,IU-1,IV  )
            IF(IV.GT.0) K9  = IABC(IT  ,IU  ,IV-1)
            IF(IT.GT.1) K10 = IABC(IT-2,IU  ,IV  )
            IF(IU.GT.1) K11 = IABC(IT  ,IU-2,IV  )
            IF(IV.GT.1) K12 = IABC(IT  ,IU  ,IV-2)
C
C           INVOKE RECURRENCE RELATIONS ON LAYER (NQN+1)
C
C           TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
            TT = DFLOAT((2*(IT+IU+IV))+3)
            DO M=1,MAXM
              T1 = 1.0D0/P22(M)
              TX = PX(M)/P(M)
              TY = PY(M)/P(M)
              TZ = PZ(M)/P(M)
              TP = PP(M) + TT/P2(M)
              ENSG(M,K0) = ENSG(M,K0) + TP*ESG(M,I0)
              ENSG(M,K1) = ENSG(M,K1) + T1*ESG(M,I0)
              ENSG(M,K2) = ENSG(M,K2) + T1*ESG(M,I0)
              ENSG(M,K3) = ENSG(M,K3) + T1*ESG(M,I0)
              ENSG(M,K4) = ENSG(M,K4) + TX*ESG(M,I0)
              ENSG(M,K5) = ENSG(M,K5) + TY*ESG(M,I0)
              ENSG(M,K6) = ENSG(M,K6) + TZ*ESG(M,I0)
            ENDDO
C
C           SPECIAL CASE EXCLUDES IT=0
            IF(IT.GE.1) THEN
              RT2 = DFLOAT(2*IT)
              DO M=1,MAXM
                T0 = PX(M)*RT2
                ENSG(M,K7) = ENSG(M,K7) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IU=0
            IF(IU.GE.1) THEN
              RU1 = DFLOAT(2*IU)
              DO M=1,MAXM
                T0 = PY(M)*RU1
                ENSG(M,K8) = ENSG(M,K8) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IV=0
            IF(IV.GE.1) THEN
              RV1 = DFLOAT(2*IV)
              DO M=1,MAXM
                T0 = PZ(M)*RV1
                ENSG(M,K9) = ENSG(M,K9) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IT=0,1
            IF(IT.GE.2) THEN
              RT2 = DFLOAT(IT*(IT-1))
              DO M=1,MAXM
                ENSG(M,K10) = ENSG(M,K10) + RT2*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IU=0,1
            IF(IU.GE.2) THEN
              RU2 = DFLOAT(IU*(IU-1))
              DO M=1,MAXM
                ENSG(M,K11) = ENSG(M,K11) + RU2*ESG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IV=0,1
            IF(IV.GE.2) THEN
              RV2 = DFLOAT(IV*(IV-1))
              DO M=1,MAXM
                ENSG(M,K12) = ENSG(M,K12) + RV2*ESG(M,I0)
              ENDDO
            ENDIF

          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNORM1(RNTT,EXL,LQN,NBAS,ITT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         RRRRRRR  NN    NN  OOOOOO  RRRRRRR  MM       MM  11          C
C         RR    RR NNN   NN OO    OO RR    RR MMM     MMM 111          C
C         RR    RR NNNN  NN OO    OO RR    RR MMMM   MMMM  11          C
C         RR    RR NN NN NN OO    OO RR    RR MM MM MM MM  11          C
C         RRRRRRR  NN  NNNN OO    OO RRRRRRR  MM  MMM  MM  11          C
C         RR    RR NN   NNN OO    OO RR    RR MM   M   MM  11          C
C         RR    RR NN    NN  OOOOOO  RR    RR MM       MM 1111         C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNORM1 GENERATES TT' RADIAL BASIS FUNCTION NORMALISATION CONSTANTS, C
C  BUT KEEPS THEM ISOLATED IN A PAIR OF COLUMNS.                       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ LQN  - PAIR OF ORBITAL QUANTUM NUMBERS.                           C
C  ▶ NBAS - PAIR OF PARAMETER LIST LENGTHS.                            C
C  ▶ ITT  - COMPONENT-TYPE OVERLAPS.                                   C
C  OUTPUT:                                                             C
C  ▶ RNTT - BATCH OF NORMALISATION CONSTANTS.                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RNTT(MBS,MBS)
      DIMENSION RN1(MBS),RN2(MBS)
      DIMENSION EXL(MBS,2),LQN(2),NBAS(2)
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     LEFT-HAND NORMALISATION LIST
      GL = TWLG-GAMLOG(2*LQN(1)+3)
      GS = TWLG-GAMLOG(2*LQN(1)+5)
      UL = DFLOAT(LQN(1))+1.5D0
      US = DFLOAT(LQN(1))+0.5D0
      DO IBAS=1,NBAS(1)
        ELOG = DLOG(2.0D0*EXL(IBAS,1))
        IF(ITT.EQ.1.OR.ITT.EQ.2) THEN
          RN1(IBAS) = DEXP(0.5D0*(GL+UL*ELOG))
        ELSEIF(ITT.EQ.3.OR.ITT.EQ.4) THEN
          RN1(IBAS) = DEXP(0.5D0*(GS+US*ELOG))
        ENDIF
      ENDDO
C
C     RIGHT-HAND NORMALISATION LIST
      GL = TWLG-GAMLOG(2*LQN(2)+3)
      GS = TWLG-GAMLOG(2*LQN(2)+5)
      UL = DFLOAT(LQN(2))+1.5D0
      US = DFLOAT(LQN(2))+0.5D0
      DO JBAS=1,NBAS(2)
        ELOG = DLOG(2.0D0*EXL(JBAS,2))
        IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
          RN2(JBAS) = DEXP(0.5D0*(GL+UL*ELOG))
        ELSEIF(ITT.EQ.2.OR.ITT.EQ.4) THEN
          RN2(JBAS) = DEXP(0.5D0*(GS+US*ELOG))
        ENDIF
      ENDDO
C
C     FULL MATRIX SET OF NORMALISATION CONSTANTS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          RNTT(IBAS,JBAS) = RN1(IBAS)*RN2(JBAS)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DNORM(NMAX,ECFF,ICMP,SCL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           DDDDDDD  NN    NN  OOOOOO  RRRRRRR  MM       MM            C
C           DD    DD NNN   NN OO    OO RR    RR MMM     MMM            C
C           DD    DD NNNN  NN OO    OO RR    RR MMMM   MMMM            C
C           DD    DD NN NN NN OO    OO RR    RR MM MM MM MM            C
C           DD    DD NN  NNNN OO    OO RRRRRRR  MM  MMM  MM            C
C           DD    DD NN   NNN OO    OO RR    RR MM   M   MM            C
C           DDDDDDD  NN    NN  OOOOOO  RR    RR MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DNORM CALCULATES A SCALE NORM FOR A REAL OR COMPLEX PART OF A LIST  C
C  ECFF OF LENGTH NMAX, AND STORES THE RESULT IN SCL.                  C
C**********************************************************************C
C
      DIMENSION ECMP(NMAX)
C
      COMPLEX*16 ECFF(NMAX)
C
C     SENSITIVITY TOLERANCE PARAMETER
      EPS = 1.0D-10
C
C     IMPORT EITHER THE REAL OR COMPLEX COMPONENT FROM ECFF
      DO N=1,NMAX
        IF(ICMP.EQ.1) THEN
          ECMP(N) = DREAL(ECFF(N))
        ELSEIF(ICMP.EQ.2) THEN
          ECMP(N) = DIMAG(ECFF(N))
        ELSE
          WRITE(6, *) 'In DNORM: choose component 1 or 2.'
          WRITE(7, *) 'In DNORM: choose component 1 or 2.'
        ENDIF
      ENDDO
C
C     LOOP OVER ELEMENTS OF ECMP
      SSQ = 1.0D0
      SCL = 0.0D0
      DO N=1,NMAX
        IF(DABS(ECMP(N)).GT.EPS) THEN
          ABN = DABS(ECMP(N))
          IF(SCL.LT.ABN) THEN
            SSQ = 1.0D0 + SSQ*(SCL/ABN)**2
          ELSE
            SSQ = SSQ   +     (ABN/SCL)**2
          ENDIF
        ENDIF
      ENDDO
      SCL = SCL*DSQRT(SSQ)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [13] GQ-COEFFS: ANALYTIC DERIVS OF OVERLAP SPIN-STRUCTURE FACTORS.  C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] GQLLMK: GENERATE A BATCH OF GQLL COEFFICIENTS: (--) AND (+-).  C
C   [B] GQLSMK: GENERATE A BATCH OF GQLS COEFFICIENTS: (--) AND (+-).  C
C   [C] GQSLMK: GENERATE A BATCH OF GQSL COEFFICIENTS: (--) AND (+-).  C
C   [D] GQSSMK: GENERATE A BATCH OF GQSS COEFFICIENTS: (--) AND (+-).  C
C   [E] GQLL: A RAW BLOCK OF GQLL COEFFICIENTS FOR GQLLMK.             C
C   [F] GQLS: A RAW BLOCK OF GQLS COEFFICIENTS FOR GQLSMK.             C
C   [G] GQSL: A RAW BLOCK OF GQSL COEFFICIENTS FOR GQSLMK.             C
C   [H] GQSS: A RAW BLOCK OF GQSS COEFFICIENTS FOR GQSSMK.             C
C   [I] GSGTF: SET OF GS-COEFFS OVER SPHERICAL HARMONICS AND HGTFS.    C
C   [J] GVRS: EXPANSION COEFFS IN HGTF OVERLAPS, CALLED IN GSGTF.      C
C   [K] GSTEPLM: SIMULTANEOUS INCREASE IN (L,M) FOR USE IN GVRS.       C
C   [L] GSTEPL: INCREMENT IN L FOR USE IN GVRS.                        C
C   [M] GSTEPN: INCREMENT IN N FOR USE IN GVRS.                        C
C**********************************************************************C
C
C
      SUBROUTINE GQLLMK(G11,G12,G21,G22,EXL,XYZ,KQN,MQN,NBS,
     &                                           IPHS,IA1,IA2,IQ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      GGGGGG    QQQQQQ    LL       LL       MM       MM KK    KK      C
C     GG    GG  QQ    QQ   LL       LL       MMM     MMM KK   KK       C
C     GG       QQ      QQ  LL       LL       MMMM   MMMM KK  KK        C
C     GG       QQ      QQ  LL       LL       MM MM MM MM KKKKK         C
C     GG   GGG QQ      QQ  LL       LL       MM  MMM  MM KK  KK        C
C     GG    GG  QQ    QQ   LL       LL       MM   M   MM KK   KK       C
C      GGGGGG    QQQQQQ QQ LLLLLLLL LLLLLLLL MM       MM KK    KK      C
C                                                                      C
C -------------------------------------------------------------------- C
C  GQLLMK GENERATES A BATCH OF GQLL COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  ▶ NX      - CARTESIAN PARTIAL DERIVATIVE COMPONENT.                 C
C  ▶ LR      - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C  ▶ G11     - UNIQUE GQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ G21     - UNIQUE GQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,4),XY2(3,4),KQ2(4),MQ2(4),NB2(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ),E12(MB2,MEQ),E22(MB2,MEQ)
      COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ),G12(MB2,MEQ),G22(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLL  = LA+LB+NDRV
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE G11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQLL(E11,G11,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQLL BY PHASE TERM IF GQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
          G11(M,ITUV) = PHS*G11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE G12, FOR MQN PAIRS (-|MA|,+|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) = MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQLL(E12,G12,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQLL BY PHASE TERM IF GQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E12(M,ITUV) = PHS*E12(M,ITUV)
          G12(M,ITUV) = PHS*G12(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     3: GENERATE AND STORE G21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQLL(E21,G21,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQLL BY PHASE TERM IF GQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
          G21(M,ITUV) = PHS*G21(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     4: GENERATE AND STORE G22, FOR MQN PAIRS (+|MA|,+|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) = MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQLL(E22,G22,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQLL BY PHASE TERM IF GQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E22(M,ITUV) = PHS*E22(M,ITUV)
          G22(M,ITUV) = PHS*G22(M,ITUV)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GQLSMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBS,IPHS,
     &                                                IA1,IA2,IQ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       GGGGGG    QQQQQQ    LL       SSSSSS  MM       MM KK    KK      C
C      GG    GG  QQ    QQ   LL      SS    SS MMM     MMM KK   KK       C
C      GG       QQ      QQ  LL      SS       MMMM   MMMM KK  KK        C
C      GG       QQ      QQ  LL       SSSSSS  MM MM MM MM KKKKK         C
C      GG   GGG QQ      QQ  LL            SS MM  MMM  MM KK  KK        C
C      GG    GG  QQ    QQ   LL      SS    SS MM   M   MM KK   KK       C
C       GGGGGG    QQQQQQ QQ LLLLLLLL SSSSSS  MM       MM KK    KK      C
C                                                                      C
C -------------------------------------------------------------------- C
C  GQLSMK GENERATES A BATCH OF EQLS COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  ▶ NX      - CARTESIAN PARTIAL DERIVATIVE COMPONENT.                 C
C  ▶ LR      - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C  ▶ G11     - UNIQUE GQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ G21     - UNIQUE GQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+NDRV
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE G11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQLS(E11,G11,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQLS BY PHASE TERM IF GQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
          G11(M,ITUV) = PHS*G11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE G21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQLS(E21,G21,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQLS BY PHASE TERM IF GQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
          G21(M,ITUV) = PHS*G21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT G22 AND G12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE GQSLMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBS,IPHS,
     &                                                IA1,IA2,IQ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       GGGGGG    QQQQQQ    SSSSSS  LL       MM       MM KK    KK      C
C      GG    GG  QQ    QQ  SS    SS LL       MMM     MMM KK   KK       C
C      GG       QQ      QQ SS       LL       MMMM   MMMM KK  KK        C
C      GG       QQ      QQ  SSSSSS  LL       MM MM MM MM KKKKK         C
C      GG   GGG QQ      QQ       SS LL       MM  MMM  MM KK  KK        C
C      GG    GG  QQ    QQ  SS    SS LL       MM   M   MM KK   KK       C
C       GGGGGG    QQQQQQ QQ SSSSSS  LLLLLLLL MM       MM KK    KK      C
C                                                                      C
C -------------------------------------------------------------------- C
C  GQSLMK GENERATES A BATCH OF EQSL COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  ▶ NX      - CARTESIAN PARTIAL DERIVATIVE COMPONENT.                 C
C  ▶ LR      - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C  ▶ G11     - UNIQUE GQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ G21     - UNIQUE GQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSL  = LA+LB+NDRV
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE G11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQSL(E11,G11,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQSL BY PHASE TERM IF GQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
          G11(M,ITUV) = PHS*G11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE G21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQSL(E21,G21,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQSL BY PHASE TERM IF GQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
          G21(M,ITUV) = PHS*G21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT G22 AND G12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE GQSSMK(E11,E21,G11,G21,EXL,XYZ,KQN,MQN,NBS,IPHS,
     &                                                IA1,IA2,IQ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       GGGGGG    QQQQQQ    SSSSSS   SSSSSS  MM       MM KK    KK      C
C      GG    GG  QQ    QQ  SS    SS SS    SS MMM     MMM KK   KK       C
C      GG       QQ      QQ SS       SS       MMMM   MMMM KK  KK        C
C      GG       QQ      QQ  SSSSSS   SSSSSS  MM MM MM MM KKKKK         C
C      GG   GGG QQ      QQ       SS       SS MM  MMM  MM KK  KK        C
C      GG    GG  QQ    QQ  SS    SS SS    SS MM   M   MM KK   KK       C
C       GGGGGG    QQQQQQ QQ SSSSSS   SSSSSS  MM       MM KK    KK      C
C                                                                      C
C -------------------------------------------------------------------- C
C  GQSSMK GENERATES A BATCH OF EQSS COEFFICIENTS FOR BASIS FUNCTION    C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+2 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  ▶ NX      - CARTESIAN PARTIAL DERIVATIVE COMPONENT.                 C
C  ▶ LR      - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C  ▶ G11     - UNIQUE GQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ G21     - UNIQUE GQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 G11(MB2,MEQ),G21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSS  = LA+LB+NDRV
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE G11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQSS(E11,G11,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQSS BY PHASE TERM IF GQSS ARE NEEDED
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
          G11(M,ITUV) = PHS*G11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE G21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL GQSS(E21,G21,EX2,XY2,KQ2,MQ2,NB2,IQ,NX,LR)
C                                    ~
C     MULTIPLY GQSS BY PHASE TERM IF GQSS ARE NEEDED
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
          G21(M,ITUV) = PHS*G21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT G22 AND G12 ARE RELATED TO THESE BY SIMPLE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE GQLL(ELL,GLL,EXL,XYZ,KQN,MQN,NBS,IQ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 GGGGGG    QQQQQQ    LL       LL                      C
C                GG    GG  QQ    QQ   LL       LL                      C
C                GG       QQ      QQ  LL       LL                      C
C                GG       QQ      QQ  LL       LL                      C
C                GG   GGG QQ      QQ  LL       LL                      C
C                GG    GG  QQ    QQ   LL       LL                      C
C                 GGGGGG    QQQQQQ QQ LLLLLLLL LLLLLLLL                C
C                                                                      C
C -------------------------------------------------------------------- C
C  GQLL GENERATES A BLOCK OF RAW EQLL/GQLL-COEFFICIENTS FOR A GIVEN    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY GQLLMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  ▶ NX   - CARTESIAN PARTIAL DERIVATIVE COMPONENT.                    C
C  ▶ LR   - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).   C
C  OUTPUT:                                                             C
C  ▶ ELL  - RAW EQLL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C  ▶ GLL  - RAW GQLL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNLL(MBS,MBS)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELL(MB2,MEQ),ESG(MB2,MEQ)
      COMPLEX*16 GLL(MB2,MEQ),GSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO ITUV=1,MEQ
        DO M=1,MB2
          ELL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          GLL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     BASIS FUNCTION OVERLAP LIST LENGTH
      MAXM = NBS(1)*NBS(2)
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: ALL KQN(1) AND KQN(2) TYPES.                             C
C**********************************************************************C
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GLL0 AND E/GLLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLL/GQLL
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) +     CAB*ESG(M,ITUV)
              GLL(M,ITUV) = GLL(M,ITUV) +     CAB*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLL/GQLL
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
              GLL(M,ITUV) = GLL(M,ITUV) + SIG*CAB*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GLLX AND E/GLLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLL/GQLL
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
              GLL(M,ITUV) = GLL(M,ITUV) + SIG*CAB*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLL/GQLL
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) +     CAB*ESG(M,ITUV)
              GLL(M,ITUV) = GLL(M,ITUV) +     CAB*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      LAM0  = LQLAB(1)+LQLAB(2)+NDRV
      NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C     GENERATE RNLL NORMALISATION CONSTANTS
      CALL RNORM1(RNLL,EXL,LQN,NBS,1)
C
C     NORMALISE THE ELLQ/GLLQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M   = M+1
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = RNLL(IBAS,JBAS)*ELL(M,ITUV)
            GLL(M,ITUV) = RNLL(IBAS,JBAS)*GLL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ELLY AND GLLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = CONE*ELL(M,ITUV)
            GLL(M,ITUV) = CONE*GLL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE GQLS(ELS,GLS,EXL,XYZ,KQN,MQN,NBS,IQ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 GGGGGG    QQQQQQ    LL       SSSSSS                  C
C                GG    GG  QQ    QQ   LL      SS    SS                 C
C                GG       QQ      QQ  LL      SS                       C
C                GG       QQ      QQ  LL       SSSSSS                  C
C                GG   GGG QQ      QQ  LL            SS                 C 
C                GG    GG  QQ    QQ   LL      SS    SS                 C
C                 GGGGGG    QQQQQQ QQ LLLLLLLL SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  GQLS GENERATES A BLOCK OF RAW EQLS/GQLS-COEFFICIENTS FOR A GIVEN    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY GQLSMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  ▶ NX   - CARTESIAN PARTIAL DERIVATIVE COMPONENT.                    C
C  ▶ LR   - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).   C
C  OUTPUT:                                                             C
C  ▶ ELS  - RAW EQLS-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C  ▶ GLS  - RAW GQLS-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNLS(MBS,MBS)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
      COMPLEX*16 GLS(MB2,MEQ),GSG(MB2,MEQ),GNSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ELS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          GLS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(JBAS,2)
          T0(M) = DFLOAT(2*LQN(2)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-EXL(IBAS,1)*EXL(JBAS,2)*AB2/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GLS0 AND E/GLSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GLSX AND E/GLSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(2).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GLS0 AND E/GLSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GLSX AND E/GLSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQLS/GQLS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
              GLS(M,ITUV) = GLS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+NDRV+2
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNLS NORMALISATION CONSTANTS
      CALL RNORM1(RNLS,EXL,LQN,NBS,2)
C
C     NORMALISE THE ELSQ/GLSQ COEFFICIENT BLOCK AND MULTIPLY BY FACTOR i
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M   = M+1
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = CONE*RNLS(IBAS,JBAS)*ELS(M,ITUV)
            GLS(M,ITUV) = CONE*RNLS(IBAS,JBAS)*GLS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ELSY AND GLSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = CONE*ELS(M,ITUV)
            GLS(M,ITUV) = CONE*GLS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE GQSL(ESL,GSL,EXL,XYZ,KQN,MQN,NBS,IQ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 GGGGGG    QQQQQQ    SSSSSS  LL                       C
C                GG    GG  QQ    QQ  SS    SS LL                       C
C                GG       QQ      QQ SS       LL                       C
C                GG       QQ      QQ  SSSSSS  LL                       C
C                GG   GGG QQ      QQ       SS LL                       C
C                GG    GG  QQ    QQ  SS    SS LL                       C
C                 GGGGGG    QQQQQQ QQ SSSSSS  LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  GQSL GENERATES A BLOCK OF RAW EQSL/GQSL-COEFFICIENTS FOR A GIVEN    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY GQSLMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  ▶ NX   - CARTESIAN PARTIAL DERIVATIVE COMPONENT.                    C
C  ▶ LR   - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).   C
C  OUTPUT:                                                             C
C  ▶ ESL  - RAW EQSL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C  ▶ GSL  - RAW GQSL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNSL(MBS,MBS)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESL(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
      COMPLEX*16 GSL(MB2,MEQ),GSG(MB2,MEQ),GNSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          GSL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(IBAS,1)
          T0(M) = DFLOAT(2*LQN(1)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GSL0 AND E/GSLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GSLX AND E/GSLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GSL0 AND E/GSLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GSLX AND E/GSLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSL/GQSL [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
              GSL(M,ITUV) = GSL(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+NDRV+2
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNSL NORMALISATION CONSTANTS
      CALL RNORM1(RNSL,EXL,LQN,NBS,3)
C
C     NORMALISE THE ESLQ/GSLQ COEFFICIENT BLOCK AND MULTIPLY BY FACTOR -i
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          DO ITUV=1,NTUV2
            ESL(M,ITUV) =-CONE*RNSL(IBAS,JBAS)*ESL(M,ITUV)
            GSL(M,ITUV) =-CONE*RNSL(IBAS,JBAS)*GSL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ESLY AND GSLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV2
            ESL(M,ITUV) = CONE*ESL(M,ITUV)
            GSL(M,ITUV) = CONE*GSL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE GQSS(ESS,GSS,EXL,XYZ,KQN,MQN,NBS,IQ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 GGGGGG    QQQQQQ    SSSSSS   SSSSSS                  C
C                GG    GG  QQ    QQ  SS    SS SS    SS                 C
C                GG       QQ      QQ SS       SS                       C
C                GG       QQ      QQ  SSSSSS   SSSSSS                  C
C                GG   GGG QQ      QQ       SS       SS                 C
C                GG    GG  QQ    QQ  SS    SS SS    SS                 C
C                 GGGGGG    QQQQQQ QQ SSSSSS   SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  GQSS GENERATES A BLOCK OF RAW EQSS/GQSS-COEFFICIENTS FOR A GIVEN    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY GQSSMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ XYZ  - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                  C
C  ▶ KQN  - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.              C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ NBS  - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                      C
C  ▶ IQ   - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.            C
C  ▶ NX   - CARTESIAN PARTIAL DERIVATIVE COMPONENT.                    C
C  ▶ LR   - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).   C
C  OUTPUT:                                                             C
C  ▶ ESS  - RAW EQSS-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C  ▶ GSS  - RAW GQSS-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RNSS(MBS,MBS)
      DIMENSION T22(MB2),T20(MB2),T02(MB2),T00(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
      COMPLEX*16 GSS(MB2,MEQ),GSG(MB2,MEQ),GNSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          GSS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      LQN(1) = LVAL(KQN(1))
      LQN(2) = LVAL(KQN(2))
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      RL1 = DFLOAT(2*LQN(1)+1)
      RL2 = DFLOAT(2*LQN(2)+1)
C
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T22(M) = 4.0D0*EXL(IBAS,1)*EXL(JBAS,2)
          T20(M) =-2.0D0*RL2*EXL(IBAS,1)
          T02(M) =-2.0D0*RL1*EXL(JBAS,2)
          T00(M) = RL1*RL2
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      ABDST(1) = XYZ(1,1)-XYZ(1,2)
      ABDST(2) = XYZ(2,1)-XYZ(2,2)
      ABDST(3) = XYZ(3,1)-XYZ(3,2)
      AB2 = ABDST(1)*ABDST(1) + ABDST(2)*ABDST(2) + ABDST(3)*ABDST(3)
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          EIBS(M) = EXL(IBAS,1)
          EJBS(M) = EXL(JBAS,2)
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          UV(M)   = EXL(IBAS,1)*EXL(JBAS,2)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(1).LT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GSS0 AND E/GSSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GSSX AND E/GSSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).LT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GSS0 AND E/GSSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +    TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +    TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GSSX AND E/GSSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
200   CONTINUE
C
C**********************************************************************C
C     CASE 3: KQN(1).GT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).GT.0) GOTO 300
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GSS0 AND E/GSSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GSSX AND E/GSSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

300   CONTINUE      
C
C**********************************************************************C
C     CASE 4: KQN(1).GT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).LT.0) GOTO 400
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR E/GSS0 AND E/GSSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          LAM4  = LQLAB(1)+LQLAB(2)+NDRV+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO GQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO GQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG/GSG)
          CALL GSTEPN(ENSG,ESG,GNSG,GSG,LAM2,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES) CONTRIBUTION TO GQSS [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          LAM4  = LQLAB(1)+LQLAB(2)+NDRV+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG/GSG)
          CALL GSTEPN(ENSG,ESG,GNSG,GSG,LAM2,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR E/GSSX AND E/GSSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          LAM4  = LQLAB(1)+LQLAB(2)+NDRV+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG/GSG)
          CALL GSTEPN(ENSG,ESG,GNSG,GSG,LAM2,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) + SIG*TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)+NDRV
          LAM2  = LQLAB(1)+LQLAB(2)+NDRV+2
          LAM4  = LQLAB(1)+LQLAB(2)+NDRV+4
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES/GS) COEFFICIENTS
          CALL GSGTF(ESG,GSG,LQLAB,MQLAB,MAXM,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG/GNSG)
          CALL GSTEPN(ESG,ENSG,GSG,GNSG,LAM0,MAXM,2,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GNSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG/GSG)
          CALL GSTEPN(ENSG,ESG,GNSG,GSG,LAM2,MAXM,1,NX,LR)
C
C         ADD THIS ANGULAR-(ES/GS) CONTRIBUTION TO EQSS/GQSS [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
              GSS(M,ITUV) = GSS(M,ITUV) +     TK*GSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
400   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     GENERATE RNSS NORMALISATION CONSTANTS
      CALL RNORM1(RNSS,EXL,LQN,NBS,4)
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM4  = LQN(1)+LQN(2)+NDRV+4
      NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C     NORMALISE THE ESSQ/GSSQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M   = M+1
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = RNSS(IBAS,JBAS)*ESS(M,ITUV)
            GSS(M,ITUV) = RNSS(IBAS,JBAS)*GSS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ESSY AND GSSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = CONE*ESS(M,ITUV)
            GSS(M,ITUV) = CONE*GSS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE GSGTF(ESG,GSG,LQN,MQN,MAXM,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              GGGGGG   SSSSSS   GGGGGG TTTTTTTT FFFFFFFF              C
C             GG    GG SS    SS GG    GG   TT    FF                    C
C             GG       SS       GG         TT    FF                    C
C             GG        SSSSSS  GG         TT    FFFFFF                C
C             GG   GGG       SS GG   GGG   TT    FF                    C
C             GG    GG SS    SS GG    GG   TT    FF                    C
C              GGGGGG   SSSSSS   GGGGGG    TT    FF                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  GSGTF CONSTRUCTS THE EXPANSION COEFFICIENTS OF THE OVERLAP DENSITY  C
C  OF TWO SPHERICAL HARMONIC FUNCTIONS IN AN AUXILIARY HGTF BASIS.     C
C                                                                      C
C  THE OVERLAP DENSITY IS DEFINED BY Y*[L,M]Y[L',M'], WHERE Y[L,M] ARE C
C  SPHERICAL HARMONICS FOLLOWING THE CONDON-SHORTLEY PHASE CONVENTION. C
C                                                                      C
C  THE REQUIRED COEFFICIENTS ARE GENERATED BY A CALL TO GVRS, WHICH IS C
C  CONSTRUCTED ACCORDING TO THE RECURRENCE RELATIONS DEFINED BY        C
C  V.R.SAUNDERS. THE OUTPUT OF GVRS IS THEN ADJUSTED TO INCLUDE THE    C
C  ANGULAR NORMALISATION CONSTANTS, AS WELL AS A PHASE FACTOR TO       C
C  CONVERT FROM THE SCHIFF TO THE CONDON-SHORTLEY PHASE CONVENTION.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LQN  - PAIR OF BASIS SET ORBITAL QUANTUM NUMBERS.                 C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ MAXM - SIZE OF THIS BLOCK.                                        C
C  ▶ NX   - CARTESIAN DERIVATIVE DIRECTION.                            C
C  ▶ LR   - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).   C
C  OUTPUT:                                                             C
C  ▶ ESG  - EXPANSION COEFFICIENTS FOR EACH OVERLAP IN THE BLOCK.      C
C  ▶ GSG  - DERIVATIVE COEFFICIENTS FOR EACH OVERLAP IN THE BLOCK.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION LQN(2),MQN(2),MQNLAB(2)
C
      COMPLEX*16 ESG(MB2,MEQ),GSG(MB2,MEQ)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     PRESENCE OF ANALYTIC DERIVATIVE BOOSTS FINITE EXPANSION DEGREE
      NDRV = 1
C
C     GVRS IS CALLED WITH THE SIGN OF MQN(1) REVERSED
C     TO AFFECT COMPLEX CONJUGATION, ALONG WITH THE REQUISITE
C     PHASE, WHICH IS CALCULATED LATER.
      MQNLAB(1) =-MQN(1)
      MQNLAB(2) = MQN(2)
C
C     GENERATE RAW COEFFICIENTS WITH GVRS
      CALL GVRS(ESG,GSG,LQN,MQNLAB,MAXM,NX,LR)
C
C     MQN PHASES
      PHS1 = (-1.0D0)**((MQN(1)+IABS(MQN(1)))/2)
      PHS2 = (-1.0D0)**((MQN(2)+IABS(MQN(2)))/2)
C
C     CG COEFFICIENTS
      PI4 = 0.25D0/PI
      DGL = DFLOAT((2*LQN(1)+1)*(2*LQN(2)+1))
      CG1 = RFACT(LQN(1)-IABS(MQN(1)))/RFACT(LQN(1)+IABS(MQN(1)))
      CG2 = RFACT(LQN(2)-IABS(MQN(2)))/RFACT(LQN(2)+IABS(MQN(2)))
C
C     ANGULAR NORMALISATION CONSTANT      
      ANG = PHS1*PHS2*PI4*DSQRT(DGL*CG1*CG2)
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      LAM  = LQN(1)+LQN(2)+NDRV
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     APPLY MULTIPLICATIVE CONSTANT TO RAW ANGULAR COEFFICIENTS
      DO M=1,MAXM
        DO ITUV=1,NTUV
          ESG(M,ITUV) = ANG*ESG(M,ITUV)
          GSG(M,ITUV) = ANG*GSG(M,ITUV)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GVRS(ESG,GSG,LQN,MQN,MAXM,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                  GGGGGG  VV    VV RRRRRRR   SSSSSS                   C
C                 GG    GG VV    VV RR    RR SS    SS                  C
C                 GG       VV    VV RR    RR SS                        C
C                 GG       VV    VV RR    RR  SSSSSS                   C
C                 GG   GGG  VV  VV  RRRRRRR        SS                  C
C                 GG    GG   VVVV   RR    RR SS    SS                  C
C                  GGGGGG     VV    RR    RR  SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  GVRS EVALUATES THE EXPANSION COEFFICIENTS OF THE OVERLAP CHARGE     C
C  DENSITY OF SGTFS IN AN AUXILIARY HGTF. COEFFICIENTS ARE EVALUATED   C
C  USING THE RECURRENCE RELATIONS DEFINED BY VIC SAUNDERS IN:          C
C                                                                      C
C  V.R.SAUNDERS, "MOLECULAR INTEGRALS FOR GAUSSIAN-TYPE FUNCTIONS",    C
C  METHODS OF COMPUTATIONAL MOLECULAR PHYSICS, DIERCKSEN AND WILSON,   C
C  pp 1-26, REIDEL PUBLISHING, DORDRECHT (1983).                       C
C                                                                      C
C  THE EQ-COEFFS IN THIS PROCEDURE ARE FOR AN UN-NORMALISED SGTF.      C
C  THE COEFFICIENTS ARE DETERMINED ACCORDING TO THE SAME RULES AS      C
C  DEFINED IN THE ABOVE ARTICLE. CONSEQUENTLY, IT SHOULD BE NOTED THAT C
C  THE COEFFICIENTS ARE THOSE OF SPHERICAL HARMONIC FUNCTIONS THAT ARE C
C   ▶ UN-NORMALISED                                                    C
C   ▶ SATISFY THE SCHIFF PHASE CONVENTION.                             C
C                                                                      C
C  THE OUTLINE FOR THE GENERATION OF EQ-COEFFICIENTS IS TAKEN FROM p16 C
C  OF THE ABOVE ARTICLE. EQUATION NUMBERS ARE GIVEN IN COMMENTS.       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LQN  - PAIR OF BASIS SET ORBITAL QUANTUM NUMBERS.                 C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ MAXM - SIZE OF THIS BLOCK.                                        C
C  ▶ NX   - CARTESIAN DERIVATIVE DIRECTION.                            C
C  ▶ LR   - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).   C
C  OUTPUT:                                                             C
C  ▶ ESG  - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.       C
C  ▶ GSG  - UN-NORMALISED DERIVATIVE COEFFICIENTS FOR THIS BLOCK.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION NBAS(2),LQN(2),MQN(2)
C
      COMPLEX*16 ESG(MB2,MEQ),ETEMP(MB2*MRC)
      COMPLEX*16 GSG(MB2,MEQ),GTEMP(MB2*MRC)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     INDEX SUMMATION TERMINALS BASED ON MAX DEGREE OF HGTF
      NDRV = 1
      LMAX = LQN(1)+LQN(2)+NDRV
      NTUV = (LMAX+1)*(LMAX+2)*(LMAX+3)/6
C
C     INITIALISE ESG AND GSG ARRAYS
      DO M=1,MAXM
        DO ITUV=1,NTUV
          ESG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          GSG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     IMPORT LQN AND BASIS PAIR MQNS FOR LOCAL USE
      LQNA = LQN(1)
      LQNB = LQN(2)
      MQNA = MQN(1)
      MQNB = MQN(2)
C
C     EXIT IF LQN,MQN ORDERS YIELD ZERO CG-COEFFICIENTS
      IF(IABS(MQN(1)).GT.LQN(1).OR.IABS(MQN(2)).GT.LQN(2)) RETURN
C
C     CHECK THAT LMAX IS WITHIN THE BOUNDS OF MKP
      IF(LMAX.GT.MKP+1) THEN
        WRITE(6, *) 'In GVRS: LMAX exceeds MKP+1 parameter.',LMAX,MKP+1
        WRITE(7, *) 'In GVRS: LMAX exceeds MKP+1 parameter.',LMAX,MKP+1
        STOP
      ENDIF
C
C     INITIALISE TEMPORARY ARRAYS
      DO M=1,MRC*MB2
        ETEMP(M) = DCMPLX(0.0D0,0.0D0)
        GTEMP(M) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     SET STARTING POINT E[0,0;0,0;0,0,0] = RKAB
C     SET STARTING POINT G[0,0;0,0;0,0,0] = ∂/∂A_NX  E[0,0;0,0;0,0,0]
      DO M=1,MAXM
        ETEMP(M) = DCMPLX(RKAB(M),0.0D0)
        GTEMP(M) = DCMPLX(2.0D0*UV(M)*ABDST(NX)*RKAB(M)/P(M),0.0D0)
      ENDDO
C
C     RESULT OF CARTESIAN KRONECKER DELTAS
      MX = KRONECK(1,NX)
      MY = KRONECK(2,NX)
      MZ = KRONECK(3,NX)
C
C     SET 1ST RECURRENCE G[0,0;0,0;1,0,0] = EI/(EI+EJ) E[0,0;0,0;0,0,0]
      ISTART = (IABC(MX,MY,MZ)-1)*MAXM
      IF(LR.EQ.'L') THEN
        DO M=1,MAXM
          K = ISTART+M
          GTEMP(K) = DCMPLX(EIBS(M)*RKAB(M)/P(M),0.0D0)
        ENDDO
      ELSEIF(LR.EQ.'R') THEN
        DO M=1,MAXM
          K = ISTART+M
          GTEMP(K) = DCMPLX(EJBS(M)*RKAB(M)/P(M),0.0D0)
        ENDDO
      ENDIF
C
C     INITIALISE STARTING ADDRESS AND EXPANSION DEGREE
      ISTART = 0
      LAM    = 1
C
C     STEP 1:
C     GENERATE E/G[|MQNA|,MQNA;0,0] FROM E/G[0,0;0,0] USING
C     SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE A
      CALL GSTEPLM(ETEMP,GTEMP,LAM,ISTART,MQNA,MAXM,1,NX,LR)
C
C     STEP 2:
C     GENERATE E/G[LQNA,MQNA;0,0] FROM E/G[|MQNA|,MQNA;0,0]
C     USING THE STEP OF LQN ONLY ON CENTRE A
      CALL GSTEPL(ETEMP,GTEMP,LAM,ISTART,LQNA,MQNA,MAXM,1,NX,LR)
C
C     STEP 3:
C     GENERATE E/G[LQNA,MQNA;|MQNB|,MQNB] FROM E/G[LQNA,MQNA;0,0]
C     SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE B
      CALL GSTEPLM(ETEMP,GTEMP,LAM,ISTART,MQNB,MAXM,2,NX,LR)
C
C     STEP 4:
C     GENERATE E/G[LQNA,MQNA;LQNB,MQNB] FROM E/G[LQNA,MQNA;|MQNB|,MQNB]
C     USING THE STEP OF LQN ONLY ON CENTRE B
      CALL GSTEPL(ETEMP,GTEMP,LAM,ISTART,LQNB,MQNB,MAXM,2,NX,LR)
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS DEGREE LAM
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     STEP 5:
C     COPY FINAL BLOCK OF ENTRIES AS THE REQUIRED OUTPUT
      K = 0
      DO ITUV=1,NTUV
        DO M=1,MAXM
          K = K+1
          ESG(M,ITUV) = ETEMP(ISTART+K)
          GSG(M,ITUV) = GTEMP(ISTART+K)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GSTEPLM(ETEMP,GTEMP,LAM,ISTART,MQN,MAXM,IZ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    GGGGGG   SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL       MM       MM   C
C   GG    GG SS    SS   TT    EE       PP    PP LL       MMM     MMM   C
C   GG       SS         TT    EE       PP    PP LL       MMMM   MMMM   C
C   GG        SSSSSS    TT    EEEEEE   PP    PP LL       MM MM MM MM   C
C   GG   GGG       SS   TT    EE       PPPPPPP  LL       MM  MMM  MM   C
C   GG    GG SS    SS   TT    EE       PP       LL       MM   M   MM   C
C    GGGGGG   SSSSSS    TT    EEEEEEEE PP       LLLLLLLL MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  SIMULTANEOUSLY INCREMENT THE QUANTUM NUMBERS LQN & MQN, STARTING    C
C  WITH E[0,0], USING THE RECURSION ALGORITHM OF V.R.SAUNDERS IN       C
C  `MOLECULAR INTEGRALS FOR GAUSSIAN TYPE FUNCTIONS' 1983 (A) AND      C
C  `ANALYTICAL HF GRADIENTS FOR PERIODIC SYSTEMS', JOURNAL OF QUANTUM  C
C  CHEMISTRY, VOL. 82, 1-13, 2001 (B)                                  C
C -------------------------------------------------------------------- C
C       E[0,0;IT,IU,IV] -> E[|MQN|+1,±(|MQN|+1);IT,IU,IV]  Eq.(64 A)   C
C       G[0,0;IT,IU,IV] -> G[|MQN|+1,±(|MQN|+1);IT,IU,IV]  Eq.(64 A)   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LAM    - LENGTH OF THE INPUT HGTF EXPANSION.                      C
C  ▶ ISTART - COUNTER TO TRACK THE START OF THIS PORTION OF THE LIST.  C
C  ▶ MQN    - MAGNETIC QUANTUM NUMBER.                                 C
C  ▶ MAXM   - NUMBER OF EXPONENT/DENSITY PAIRS.                        C
C  ▶ IZ     - CENTRE TO STEP UP.                                       C
C  ▶ NX     - CARTESIAN DERIVATIVE DIRECTION.                          C
C  ▶ LR     - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R). C
C  OUTPUT:                                                             C
C  ▶  ETEMP - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.     C
C  ▶  GTEMP - UN-NORMALISED DERIVATIVE COEFFICIENTS FOR THIS BLOCK.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION PX(MB2),PY(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(MB2*MRC),GTEMP(MB2*MRC)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IF |MQN|.EQ.0 THEN NO INCREMENT IN (LQN,MQN) IS REQUIRED
      IF(IABS(MQN).EQ.0) RETURN
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PX(M) = PAX(M)
          PY(M) = PAY(M)
        ELSEIF(IZ.EQ.2) THEN
          PX(M) = PBX(M)
          PY(M) = PBY(M)
        ENDIF
      ENDDO
C
C     PHASE TERM FOR SIGN OF MQN
      PHM = DFLOAT(ISIGN(1,MQN))
C
C     LOOP OVER ALL MAGNETIC NUMBERS UP TO THIS MQN (USE LQN AS COUNTER)
      DO LQN=0,IABS(MQN)-1
C
C       DEGENERACY COUNTER 2*LQN+1
        R2L1 = DFLOAT(2*LQN+1)
C
C       NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C       ISTART LABELS THE PREVIOUS LQN VALUE
C       JSTART LABELS THE CURRENT  LQN VALUE
C       KSTART LABELS THE NEXT     LQN VALUE
        JSTART = ISTART
        KSTART = JSTART + NTUV*MAXM
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C       J0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                               C
C       K0-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                               C
C       K1-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                               C
C       K2-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                               C
C       K3-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                               C
C       K4-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                               C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LQN)
              J0 = JSTART + (IABC(IT  ,IU  ,IV)-1)*MAXM
              K0 = KSTART + (IABC(IT  ,IU  ,IV)-1)*MAXM
              K1 = KSTART + (IABC(IT+1,IU  ,IV)-1)*MAXM
              K2 = KSTART + (IABC(IT  ,IU+1,IV)-1)*MAXM
              IF(IT.NE.0) K3 = KSTART + (IABC(IT-1,IU  ,IV  )-1)*MAXM
              IF(IU.NE.0) K4 = KSTART + (IABC(IT  ,IU-1,IV  )-1)*MAXM
C
C             RECURRENCE RELATIONS ON LAYER (LQN+1) OF E'S AND G'S
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              DO M=1,MAXM
                T1 = R2L1/P2(M)
                TX = R2L1*PX(M)
                TY = R2L1*PY(M)
                ETEMP(K0+M) = ETEMP(K0+M) +          TX*ETEMP(J0+M)
     &                                    + PHM*CONE*TY*ETEMP(J0+M)
                GTEMP(K0+M) = GTEMP(K0+M) +          TX*GTEMP(J0+M)
     &                                    + PHM*CONE*TY*GTEMP(J0+M)
                ETEMP(K1+M) = ETEMP(K1+M) +          T1*ETEMP(J0+M)
                GTEMP(K1+M) = GTEMP(K1+M) +          T1*GTEMP(J0+M)
                ETEMP(K2+M) = ETEMP(K2+M) + PHM*CONE*T1*ETEMP(J0+M)
                GTEMP(K2+M) = GTEMP(K2+M) + PHM*CONE*T1*GTEMP(J0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.NE.0) THEN
                FC = R2L1*DFLOAT(IT)
                DO M=1,MAXM
                  ETEMP(K3+M) = ETEMP(K3+M) +          FC*ETEMP(J0+M)
                  GTEMP(K3+M) = GTEMP(K3+M) +          FC*GTEMP(J0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.NE.0) THEN
                FC = R2L1*DFLOAT(IU)
                DO M=1,MAXM
                  ETEMP(K4+M) = ETEMP(K4+M) + PHM*CONE*FC*ETEMP(J0+M)
                  GTEMP(K4+M) = GTEMP(K4+M) + PHM*CONE*FC*GTEMP(J0+M)
                ENDDO
              ENDIF
C
C             RECURRENCE RELATIONS ON G'S SOMETIMES HAVE CROSSING TERMS
              IF(NX.EQ.3) GOTO 100
              IF(IZ.EQ.1.AND.LR.EQ.'R') GOTO 100
              IF(IZ.EQ.2.AND.LR.EQ.'L') GOTO 100
C
              IF(NX.EQ.1) THEN
C             CROSSING TERM FROM X-DERIVATIVE
C
                DO M=1,MAXM
                  T0 = R2L1
                  GTEMP(K0+M) = GTEMP(K0+M) -          T0*ETEMP(J0+M)
                ENDDO
C
              ELSEIF(NX.EQ.2) THEN
C             CROSSING TERM FROM Y-DERIVATIVE
C
                DO M=1,MAXM
                  T0 = R2L1
                  GTEMP(K0+M) = GTEMP(K0+M) - PHM*CONE*T0*ETEMP(J0+M)
                ENDDO
C
              ENDIF
C
100           CONTINUE
C
C           END OF LOOPS OVER HGTF INDICES
            ENDDO
          ENDDO
        ENDDO
C
C       UPDATE 'PREVIOUS' START VALUE
        ISTART = ISTART + NTUV*MAXM
C
C       UPDATE LAMBDA VALUE
        LAM = LAM+1
C
C     END OF LOOP OVER MQN COUNTER
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GSTEPL(ETEMP,GTEMP,LAM,ISTART0,LQN,MQN,MAXM,IZ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          GGGGGG   SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL               C
C         GG    GG SS    SS   TT    EE       PP    PP LL               C
C         GG       SS         TT    EE       PP    PP LL               C
C         GG        SSSSSS    TT    EEEEEE   PP    PP LL               C
C         GG   GGG       SS   TT    EE       PPPPPPP  LL               C
C         GG    GG SS    SS   TT    EE       PP       LL               C
C          GGGGGG   SSSSSS    TT    EEEEEEEE PP       LLLLLLLL         C
C                                                                      C
C -------------------------------------------------------------------- C
C  DECREMENT THE LQN, STARTING WITH G[MQN,±|MQN|], USING THE RECURSION C
C  ALGORITHM OF V.R.SAUNDERS IN `MOLECULAR INTEGRALS FOR GAUSSIAN TYPE C
C  FUNCTIONS' 1983 (EDITED BY G.H.F. DIERCKSEN AND S. WILSON).         C
C -------------------------------------------------------------------- C
C (1)  E/G[|MQN|,±MQN;IT,IU,IV] -> E/G[LQN+1,±MQN;IT,IU,IV]    Eq.(64) C
C (2)  E/G[LQN  ,±MQN;IT,IU,IV] -> E/G[LQN+1,±MQN;IT,IU,IV]            C
C (3)  E/G[LQN-1,±MQN;IT,IU,IV] -> E/G[LQN+1,±MQN;IT,IU,IV]            C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LAM     - LENGTH OF THE INPUT HGTF EXPANSION.                     C
C  ▶ ISTART0 - COUNTER TO TRACK THE START OF THIS PORTION OF THE LIST. C
C  ▶ LQN     - ORBITAL QUANTUM NUMBER.                                 C
C  ▶ MQN     - MAGNETIC QUANTUM NUMBER.                                C
C  ▶ MAXM    - NUMBER OF EXPONENT/DENSITY PAIRS.                       C
C  ▶ IZ      - CENTRE TO STEP UP.                                      C
C  ▶ NX      - CARTESIAN DERIVATIVE DIRECTION.                         C
C  ▶ LR      - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).C
C  OUTPUT:                                                             C
C  ▶ ETEMP   - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.    C
C  ▶ GTEMP - UN-NORMALISED DERIVATIVE COEFFICIENTS FOR THIS BLOCK.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(MB2*MRC),GTEMP(MB2*MRC)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IF LQN.LE.|MQN| THEN NO INCREMENT IN LQN IS REQUIRED
      IF(LQN.LE.IABS(MQN)) RETURN
C
C     IDENTIFY ADDRESS FROM DERIVATIVE
      MX = KRONECK(1,NX)
      MY = KRONECK(2,NX)
      MZ = KRONECK(3,NX)
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(IZ.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     STEP (1): E[|MQN|,MQN;IT,IU,IV] -> E[|MQN|+1,MQN;IT,IU,IV].      C
C               G[|MQN|,MQN;IT,IU,IV] -> G[|MQN|+1,MQN;IT,IU,IV].      C
C               IT MAPS SOME INDEX SETS FROM DATA OBTAINED IN GSTEPLM. C
C -------------------------------------------------------------------- C
C     INDEX MAPPINGS: J0-> E/G[MQN  ,MQN;IT  ,IU  ,IV  ]               C
C                     K0-> E/G[MQN+1,MQN;IT  ,IU  ,IV  ]               C
C                     K6-> E/G[MQN+1,MQN;IT  ,IU  ,IV+1]               C
C                     K9-> E/G[MQN+1,MQN;IT  ,IU  ,IV-1]               C
C**********************************************************************C
C
C     ISTART0 LABELS THE GLOBAL STARTING VALUE
C     ISTART  LABELS THE PREVIOUS LQN VALUE
C     JSTART  LABELS THE CURRENT  LQN VALUE
C     KSTART  LABELS THE NEXT     LQN VALUE
      JSTART = ISTART0
      KSTART = JSTART + NTUV*MAXM
C
C     OVERALL LQN/MQN FACTOR SIMPLIFIES WHEN LQN = |MQN|
      RLM  = DFLOAT(2*IABS(MQN)+1)
C
C     LOOP OVER THE HGTF INDICES OF THE SEED LAYER
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
C           STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LQN+1)
            J0 = JSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXM
            K0 = KSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXM
            K6 = KSTART + (IABC(IT  ,IU  ,IV+1)-1)*MAXM
            IF(IV.NE.0) K9 = KSTART + (IABC(IT  ,IU  ,IV-1)-1)*MAXM
C
C           RECURRENCE RELATIONS ON LAYER (LQN+1) OF E'S AND G'S
C
C           TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
            DO M=1,MAXM
              TZ = RLM*PZ(M)
              TP = RLM/P2(M)
              ETEMP(K0+M) = ETEMP(K0+M) + TZ*ETEMP(J0+M)
              GTEMP(K0+M) = GTEMP(K0+M) + TZ*GTEMP(J0+M)
              ETEMP(K6+M) = ETEMP(K6+M) + TP*ETEMP(J0+M)
              GTEMP(K6+M) = GTEMP(K6+M) + TP*GTEMP(J0+M)
            ENDDO
C
C           SPECIAL CASE EXCLUDES IV=0
            IF(IV.GE.1) THEN
              FC = RLM*DFLOAT(IV)
              DO M=1,MAXM
                ETEMP(K9+M) = ETEMP(K9+M) + FC*ETEMP(J0+M)
                GTEMP(K9+M) = GTEMP(K9+M) + FC*GTEMP(J0+M)
              ENDDO
            ENDIF
C
C           RECURRENCE RELATIONS ON G'S SOMETIMES HAVE CROSSING TERMS
            IF(NX.NE.3) GOTO 100
            IF(IZ.EQ.1.AND.LR.EQ.'R') GOTO 100
            IF(IZ.EQ.2.AND.LR.EQ.'L') GOTO 100
C
C           CROSSING TERM FROM Z-DERIVATIVE
            T0 = RLM
            DO M=1,MAXM
              GTEMP(K0+M) = GTEMP(K0+M) - T0*ETEMP(J0+M)
            ENDDO
C
100         CONTINUE
C
          ENDDO
        ENDDO
      ENDDO
C
C     UPDATE BLOCK LOCATORS
      ISTART  = ISTART0
      ISTART0 = ISTART0 + NTUV*MAXM
C
C     UPDATE LAMBDA VALUE
      LAM = LAM+1
C
C     IF LQN=|MQN|+1 THEN SET IS FINISHED
      IF(LQN.EQ.IABS(MQN)+1) RETURN
C
C**********************************************************************C
C   THIS AND SUBSEQUENT STEPS IN RECURRENCE INVOLVE THREE LAYERS:      C
C            E[LQN  ,MQN;IT,IU,IV] -> E[LQN+1,MQN;IT,IU,IV]            C
C            E[LQN-1,MQN;IT,IU,IV] -> E[LQN+1,MQN;IT,IU,IV]            C
C -------------------------------------------------------------------- C
C   INDEX MAPPINGS: I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                  C
C                   J0 -> E[LQN  ,MQN;IT  ,IU  ,IV  ]                  C
C                   K0 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                  C
C                   K1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                  C
C                   K2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                  C
C                   K3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                  C
C                   K4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                  C
C                   K5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                  C
C                   K6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                  C
C                   K7 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                  C
C                   K8 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                  C
C                   K9 -> E[LQN+1,MQN;IT  ,IU  ,IV-1]                  C
C                   K10-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                  C
C                   K11-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                  C
C                   K12-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                  C
C**********************************************************************C
C
C     LOOP OVER LQN FOR FIXED MQN
      DO LQN=IABS(MQN)+1,LQN-1

C       OVERALL LQN/MQN FACTORS
        RLM1 = DFLOAT(2*LQN+1)/DFLOAT(LQN-IABS(MQN)+1)
        RLM2 =-DFLOAT(LQN+IABS(MQN))/DBLE(LQN-IABS(MQN)+1)
C
C       NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
        JSTART = ISTART0
        KSTART = ISTART0 + MAXM*NTUV
C
C**********************************************************************C
C     STEP (2): E[LQN  ,MQN;IT,IU,IV] -> E[LQN+1,MQN;IT,IU,IV].        C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LQN)
              J0 = JSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXM
              K0 = KSTART + (IABC(IT  ,IU  ,IV  )-1)*MAXM
              K6 = KSTART + (IABC(IT  ,IU  ,IV+1)-1)*MAXM
              IF(IV.NE.0) K9 = KSTART + (IABC(IT  ,IU  ,IV-1)-1)*MAXM
C
C             RECURRENCE RELATIONS ON LAYER (LQN) OF E'S AND G'S
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              DO M=1,MAXM
                TZ = PZ(M)
                TP = 1.0D0/P2(M)
                ETEMP(K0+M) = ETEMP(K0+M) + TZ*RLM1*ETEMP(J0+M)
                GTEMP(K0+M) = GTEMP(K0+M) + TZ*RLM1*GTEMP(J0+M)
                ETEMP(K6+M) = ETEMP(K6+M) + TP*RLM1*ETEMP(J0+M)
                GTEMP(K6+M) = GTEMP(K6+M) + TP*RLM1*GTEMP(J0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IV=0
              IF(IV.GE.1) THEN
                FC = DFLOAT(IV)
                DO M=1,MAXM
                  ETEMP(K9+M) = ETEMP(K9+M) + FC*RLM1*ETEMP(J0+M)
                  GTEMP(K9+M) = GTEMP(K9+M) + FC*RLM1*GTEMP(J0+M)
                ENDDO
              ENDIF
C
C             RECURRENCE RELATIONS ON G'S SOMETIMES HAVE CROSSING TERMS
              IF(NX.NE.3) GOTO 200
              IF(IZ.EQ.1.AND.LR.EQ.'R') GOTO 200
              IF(IZ.EQ.2.AND.LR.EQ.'L') GOTO 200
C
C             CROSSING TERM FROM Z-DERIVATIVE
              T0 = RLM1
              DO M=1,MAXM
                GTEMP(K0+M) = GTEMP(K0+M) - T0*ETEMP(J0+M)
              ENDDO
C
200           CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
C
C**********************************************************************C
C     STEP (3): E[LQN-1,MQN;IT,IU,IV] -> E[LQN+1,MQN;IT,IU,IV].        C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM-1
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
C
C             STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (LQN)
              I0  = ISTART+(IABC(IT  ,IU  ,IV  )-1)*MAXM
              K0  = KSTART+(IABC(IT  ,IU  ,IV  )-1)*MAXM
              K1  = KSTART+(IABC(IT+2,IU  ,IV  )-1)*MAXM
              K2  = KSTART+(IABC(IT  ,IU+2,IV  )-1)*MAXM
              K3  = KSTART+(IABC(IT  ,IU  ,IV+2)-1)*MAXM
              K4  = KSTART+(IABC(IT+1,IU  ,IV  )-1)*MAXM
              K5  = KSTART+(IABC(IT  ,IU+1,IV  )-1)*MAXM
              K6  = KSTART+(IABC(IT  ,IU  ,IV+1)-1)*MAXM
              KN  = KSTART+(IABC(IT+MX,IU+MY,IV+MZ)-1)*MAXM
              IF(IT.GT.0) K7  = KSTART+(IABC(IT-1,IU  ,IV  )-1)*MAXM
              IF(IU.GT.0) K8  = KSTART+(IABC(IT  ,IU-1,IV  )-1)*MAXM
              IF(IV.GT.0) K9  = KSTART+(IABC(IT  ,IU  ,IV-1)-1)*MAXM
              IF(IT.GT.1) K10 = KSTART+(IABC(IT-2,IU  ,IV  )-1)*MAXM
              IF(IU.GT.1) K11 = KSTART+(IABC(IT  ,IU-2,IV  )-1)*MAXM
              IF(IV.GT.1) K12 = KSTART+(IABC(IT  ,IU  ,IV-2)-1)*MAXM
              IF(IT-MX.GE.0.AND.IU-MY.GE.0.AND.IV-MZ.GE.0) THEN
                KM = KSTART+(IABC(IT-MX,IU-MY,IV-MZ)-1)*MAXM
              ENDIF
C
C             RECURRENCE RELATIONS ON LAYER (LQN-1) OF E'S AND G'S
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              TI = DFLOAT(2*(IT+IU+IV)+3)
              DO M=1,MAXM
                T1 = 1.0D0/P22(M)
                TX = PX(M)/P(M)
                TY = PY(M)/P(M)
                TZ = PZ(M)/P(M)
                TT = PP(M) + TI/P2(M)
                ETEMP(K0+M) = ETEMP(K0+M) + RLM2*TT*ETEMP(I0+M)
                GTEMP(K0+M) = GTEMP(K0+M) + RLM2*TT*GTEMP(I0+M)
                ETEMP(K1+M) = ETEMP(K1+M) + RLM2*T1*ETEMP(I0+M)
                GTEMP(K1+M) = GTEMP(K1+M) + RLM2*T1*GTEMP(I0+M)
                ETEMP(K2+M) = ETEMP(K2+M) + RLM2*T1*ETEMP(I0+M)
                GTEMP(K2+M) = GTEMP(K2+M) + RLM2*T1*GTEMP(I0+M)
                ETEMP(K3+M) = ETEMP(K3+M) + RLM2*T1*ETEMP(I0+M)
                GTEMP(K3+M) = GTEMP(K3+M) + RLM2*T1*GTEMP(I0+M)
                ETEMP(K4+M) = ETEMP(K4+M) + RLM2*TX*ETEMP(I0+M)
                GTEMP(K4+M) = GTEMP(K4+M) + RLM2*TX*GTEMP(I0+M)
                ETEMP(K5+M) = ETEMP(K5+M) + RLM2*TY*ETEMP(I0+M)
                GTEMP(K5+M) = GTEMP(K5+M) + RLM2*TY*GTEMP(I0+M)
                ETEMP(K6+M) = ETEMP(K6+M) + RLM2*TZ*ETEMP(I0+M)
                GTEMP(K6+M) = GTEMP(K6+M) + RLM2*TZ*GTEMP(I0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.GE.1) THEN
                DO M=1,MAXM
                  TX = DFLOAT(2*IT)*PX(M)
                  ETEMP(K7+M) = ETEMP(K7+M) + RLM2*TX*ETEMP(I0+M)
                  GTEMP(K7+M) = GTEMP(K7+M) + RLM2*TX*GTEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.GE.1) THEN
                DO M=1,MAXM
                  TY = DFLOAT(2*IU)*PY(M)
                  ETEMP(K8+M) = ETEMP(K8+M) + RLM2*TY*ETEMP(I0+M)
                  GTEMP(K8+M) = GTEMP(K8+M) + RLM2*TY*GTEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IV=0
              IF(IV.GE.1) THEN
                DO M=1,MAXM
                  TZ = DFLOAT(2*IV)*PZ(M)
                  ETEMP(K9+M) = ETEMP(K9+M) + RLM2*TZ*ETEMP(I0+M)
                  GTEMP(K9+M) = GTEMP(K9+M) + RLM2*TZ*GTEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IT=0,1
              IF(IT.GE.2) THEN
                TX = DFLOAT(IT*(IT-1))
                DO M=1,MAXM
                  ETEMP(K10+M) = ETEMP(K10+M) + RLM2*TX*ETEMP(I0+M)
                  GTEMP(K10+M) = GTEMP(K10+M) + RLM2*TX*GTEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0,1
              IF(IU.GE.2) THEN
                TY = DFLOAT(IU*(IU-1))
                DO M=1,MAXM
                  ETEMP(K11+M) = ETEMP(K11+M) + RLM2*TY*ETEMP(I0+M)
                  GTEMP(K11+M) = GTEMP(K11+M) + RLM2*TY*GTEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IV=0,1
              IF(IV.GE.2) THEN
                TZ = DFLOAT(IV*(IV-1))
                DO M=1,MAXM
                  ETEMP(K12+M) = ETEMP(K12+M) + RLM2*TZ*ETEMP(I0+M)
                  GTEMP(K12+M) = GTEMP(K12+M) + RLM2*TZ*GTEMP(I0+M)
                ENDDO
              ENDIF
C
C             RECURRENCE RELATIONS ON G'S SOMETIMES HAVE CROSSING TERMS
              IF(IZ.EQ.1.AND.LR.EQ.'R') GOTO 300
              IF(IZ.EQ.2.AND.LR.EQ.'L') GOTO 300
C
C             TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
              DO M=1,MAXM
                T0 = 1.0D0/P(M)
                TN = 2.0D0*(MX*PX(M) + MY*PY(M) + MZ*PZ(M))
                GTEMP(KN+M) = GTEMP(KN+M) - RLM2*T0*ETEMP(I0+M)
                GTEMP(K0+M) = GTEMP(K0+M) - RLM2*TN*ETEMP(I0+M)
              ENDDO
C
C             SPECIAL CASE EXCLUDES IX=0
              IF(IT-MX.GE.0.AND.IU-MY.GE.0.AND.IV-MZ.GE.0) THEN
                TM = 2.0D0*DFLOAT(MX*IT + MY*IU + MZ*IV)
                DO M=1,MAXM
                  GTEMP(KM+M) = GTEMP(KM+M) - RLM2*TM*ETEMP(I0+M)
                ENDDO
              ENDIF
C
300           CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
C
C       UPDATE BLOCK LOCATORS
        ISTART  = ISTART0
        ISTART0 = ISTART0 + MAXM*NTUV
C
C       UPDATE LAMBDA VALUE
        LAM = LAM+1
C
C     END OF LOOP OVER LQN FOR FIXED MQN
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GSTEPN(ESG,ENSG,GSG,GNSG,LAM,MAXM,IZ,NX,LR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          GGGGGG   SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  NN    NN         C
C         GG    GG SS    SS   TT    EE       PP    PP NNN   NN         C
C         GG       SS         TT    EE       PP    PP NNNN  NN         C
C         GG        SSSSSS    TT    EEEEEE   PP    PP NN NN NN         C
C         GG   GGG       SS   TT    EE       PPPPPPP  NN  NNNN         C
C         GG    GG SS    SS   TT    EE       PP       NN   NNN         C
C          GGGGGG   SSSSSS    TT    EEEEEEEE PP       NN    NN         C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE QUANTUM NUMBER (NQN):                                 C
C              E/G[NQN  ,LQN,MQN] -> E/G[NQN+1,LQN,MQN].               C
C -------------------------------------------------------------------- C
C  ▶ ONLY PERFORMS A SINGLE STEP IN NQN.                               C
C  ▶ LAM IS THE EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE INPUT COEFFS.  C
C    EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE OUTPUT COEFFS IS LAM+2.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ESG  - EQ-COEFFICIENT BATCH.                                      C
C  ▶ GSG  - GQ-COEFFICIENT BATCH.                                      C
C  ▶ LAM  - EFFECTIVE TOTAL ANGULAR MOMENTUM.                          C
C  ▶ MAXM - NUMBER OF EXPONENT/DENSITY PAIRS.                          C
C  ▶ IZ   - CENTRE TO STEP UP.                                         C
C  ▶ NX   - CARTESIAN DERIVATIVE DIRECTION.                            C
C  ▶ LR   - BASIS FUNCTION THAT PARTIAL DERIVATIVE APPLIES TO (L/R).   C
C  OUTPUT:                                                             C
C  ▶ ENSG - EQ-COEFFICIENT BATCH AFTER NQN HAS BEEN STEPPED UP.        C
C  ▶ GNSG - GQ-COEFFICIENT BATCH AFTER NQN HAS BEEN STEPPED UP.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*1 LR
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 ESG(MB2,MEQ),ENSG(MB2,MEQ)
      COMPLEX*16 GSG(MB2,MEQ),GNSG(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),UV(MB2),RKAB(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2),
     &            PA2(MB2),PB2(MB2),EIBS(MB2),EJBS(MB2),ABDST(3)
C
C     NUMBER OF TERMS IN CARTESIAN EXPANSION FOR THIS LAM WITH N'=N+1
      NTUV = (LAM+3)*(LAM+4)*(LAM+5)/6
C
C     INITIALISE NEW ARRAY
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ENSG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          GNSG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     IDENTIFY ADDRESS FROM DERIVATIVE
      MX = KRONECK(1,NX)
      MY = KRONECK(2,NX)
      MZ = KRONECK(3,NX)
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(IZ.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C**********************************************************************C
C     INDEX MAPPINGS: I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                C
C                     K0 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                C
C                     K1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                C
C                     K2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                C
C                     K3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                C
C                     K4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                C
C                     K5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                C
C                     K6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                C
C                     K7 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                C
C                     K8 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                C
C                     K9 -> E[LQN+1,MQN;IT  ,IU  ,IV-1]                C
C                     K10-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                C
C                     K11-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                C
C                     K12-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                C
C**********************************************************************C
C
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
C           STARTING LOCATION FOR GIVEN (IA,IB,IC) AND EFF. (NQN)
            I0  = IABC(IT  ,IU  ,IV  )
            K0  = IABC(IT  ,IU  ,IV  )
            K1  = IABC(IT+2,IU  ,IV  )
            K2  = IABC(IT  ,IU+2,IV  )
            K3  = IABC(IT  ,IU  ,IV+2)
            K4  = IABC(IT+1,IU  ,IV  )
            K5  = IABC(IT  ,IU+1,IV  )
            K6  = IABC(IT  ,IU  ,IV+1)
            KN  = IABC(IT+MX,IU+MY,IV+MZ)
            IF(IT.GT.0) K7  = IABC(IT-1,IU  ,IV  )
            IF(IU.GT.0) K8  = IABC(IT  ,IU-1,IV  )
            IF(IV.GT.0) K9  = IABC(IT  ,IU  ,IV-1)
            IF(IT.GT.1) K10 = IABC(IT-2,IU  ,IV  )
            IF(IU.GT.1) K11 = IABC(IT  ,IU-2,IV  )
            IF(IV.GT.1) K12 = IABC(IT  ,IU  ,IV-2)
            IF(IT-MX.GE.0.AND.IU-MY.GE.0.AND.IV-MZ.GE.0) THEN
              KM = IABC(IT-MX,IU-MY,IV-MZ)
            ENDIF
C
C           RECURRENCE RELATIONS ON LAYER (LQN+1) OF E'S AND G'S
C
C           TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
            TT = DFLOAT((2*(IT+IU+IV))+3)
            DO M=1,MAXM
              T0 = 1.0D0/P(M)
              T1 = 1.0D0/P22(M)
              TX = PX(M)/P(M)
              TY = PY(M)/P(M)
              TZ = PZ(M)/P(M)
              TP = PP(M) + TT/P2(M)
              TN = 2.0D0*(MX*PX(M) + MY*PY(M) + MZ*PZ(M))
              ENSG(M,K0) = ENSG(M,K0) + TP*ESG(M,I0)
              GNSG(M,K0) = GNSG(M,K0) + TP*GSG(M,I0)
              ENSG(M,K1) = ENSG(M,K1) + T1*ESG(M,I0)
              GNSG(M,K1) = GNSG(M,K1) + T1*GSG(M,I0)
              ENSG(M,K2) = ENSG(M,K2) + T1*ESG(M,I0)
              GNSG(M,K2) = GNSG(M,K2) + T1*GSG(M,I0)
              ENSG(M,K3) = ENSG(M,K3) + T1*ESG(M,I0)
              GNSG(M,K3) = GNSG(M,K3) + T1*GSG(M,I0)
              ENSG(M,K4) = ENSG(M,K4) + TX*ESG(M,I0)
              GNSG(M,K4) = GNSG(M,K4) + TX*GSG(M,I0)
              ENSG(M,K5) = ENSG(M,K5) + TY*ESG(M,I0)
              GNSG(M,K5) = GNSG(M,K5) + TY*GSG(M,I0)
              ENSG(M,K6) = ENSG(M,K6) + TZ*ESG(M,I0)
              GNSG(M,K6) = GNSG(M,K6) + TZ*GSG(M,I0)
            ENDDO
C
C           SPECIAL CASE EXCLUDES IT=0
            IF(IT.GE.1) THEN
              RT2 = DFLOAT(2*IT)
              DO M=1,MAXM
                T0 = PX(M)*RT2
                ENSG(M,K7) = ENSG(M,K7) + T0*ESG(M,I0)
                GNSG(M,K7) = GNSG(M,K7) + T0*GSG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IU=0
            IF(IU.GE.1) THEN
              RU1 = DFLOAT(2*IU)
              DO M=1,MAXM
                T0 = PY(M)*RU1
                ENSG(M,K8) = ENSG(M,K8) + T0*ESG(M,I0)
                GNSG(M,K8) = GNSG(M,K8) + T0*GSG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IV=0
            IF(IV.GE.1) THEN
              RV1 = DFLOAT(2*IV)
              DO M=1,MAXM
                T0 = PZ(M)*RV1
                ENSG(M,K9) = ENSG(M,K9) + T0*ESG(M,I0)
                GNSG(M,K9) = GNSG(M,K9) + T0*GSG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IT=0,1
            IF(IT.GE.2) THEN
              RT2 = DFLOAT(IT*(IT-1))
              DO M=1,MAXM
                ENSG(M,K10) = ENSG(M,K10) + RT2*ESG(M,I0)
                GNSG(M,K10) = GNSG(M,K10) + RT2*GSG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IU=0,1
            IF(IU.GE.2) THEN
              RU2 = DFLOAT(IU*(IU-1))
              DO M=1,MAXM
                ENSG(M,K11) = ENSG(M,K11) + RU2*ESG(M,I0)
                GNSG(M,K11) = GNSG(M,K11) + RU2*GSG(M,I0)
              ENDDO
            ENDIF
C
C           SPECIAL CASE EXCLUDES IV=0,1
            IF(IV.GE.2) THEN
              RV2 = DFLOAT(IV*(IV-1))
              DO M=1,MAXM
                ENSG(M,K12) = ENSG(M,K12) + RV2*ESG(M,I0)
                GNSG(M,K12) = GNSG(M,K12) + RV2*GSG(M,I0)
              ENDDO
            ENDIF
C
C           RECURRENCE RELATIONS ON G'S SOMETIMES HAVE CROSSING TERMS
            IF(IZ.EQ.1.AND.LR.EQ.'R') GOTO 100
            IF(IZ.EQ.2.AND.LR.EQ.'L') GOTO 100
C
C           TERMS THAT ALWAYS APPLY (NO SPECIAL CASES)
            DO M=1,MAXM
              TN = 2.0D0*(MX*PX(M) + MY*PY(M) + MZ*PZ(M))
              T0 = 1.0D0/P(M)
              GNSG(M,KN) = GNSG(M,KN) - T0*ESG(M,I0)
              GNSG(M,K0) = GNSG(M,K0) - TN*ESG(M,I0)
            ENDDO
C
C           SPECIAL CASE EXCLUDES NX=0
            IF(IT-MX.GE.0.AND.IU-MY.GE.0.AND.IV-MZ.GE.0) THEN
              TM = 2.0D0*DFLOAT(MX*IT + MY*IU + MZ*IV)
              DO M=1,MAXM
                GNSG(M,KM) = GNSG(M,KM) - TM*ESG(M,I0)
              ENDDO
            ENDIF
C
100         CONTINUE
C
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION EXTINT11(Y,I,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     EEEEEEEE XX     XX TTTTTTTT IIII NN    NN TTTTTTTT 11   11       C
C     EE        XX   XX     TT     II  NNN   NN    TT   111  111       C
C     EE         XX XX      TT     II  NNNN  NN    TT    11   11       C
C     EEEEEE      XXX       TT     II  NN NN NN    TT    11   11       C
C     EE         XX XX      TT     II  NN  NNNN    TT    11   11       C
C     EE        XX   XX     TT     II  NN   NNN    TT    11   11       C
C     EEEEEEEE XX     XX    TT    IIII NN    NN    TT   1111 1111      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EXTINT11 DETERMINES THE VALUE OF THE CONTRIBUTION TO AN INTEGRAL    C
C  BASED ON THE REPEATED 11-POINT NEWTON-COTES FORMULA, WHERE Y IS     C
C  THE VALUE F(X_I), I IS THE INDEX OF INTEREST, AND THE START AND     C
C  END POINTS OF THE INTEGRAL ARE F(X_0) AND F(X_N) RESPECTIVELY.      C
C  IT IS NUMERICALLY ADVANTAGEOUS TO MULTIPLY BY 5.0D+0/2.99376D+5     C
C  AFTER THE SUM IS CALCULATED.                                        C
C**********************************************************************C
C
C     FUNCTION ONLY ALLOWS I BETWEEN 0 AND N
      IF(I.LT.0.OR.I.GT.N) THEN
        WRITE(6, *) 'In EXTINT11: invalid index I. I = ',I
        WRITE(7, *) 'In EXTINT11: invalid index I. I = ',I
        STOP
      ENDIF
C
C     FOR THIS FORMULA TO APPLY, N MUST BE A MULTIPLE OF 10
      IF(MOD(N,10).NE.0.OR.N.LT.10) THEN
        M = MOD(N,10)
        WRITE(6, *) 'In EXTINT11: invalid discretisation N. N = ',M
        WRITE(7, *) 'In EXTINT11: invalid discretisation N. N = ',M
        STOP
      ENDIF
C
      IF(I.EQ.0.OR.I.EQ.N) THEN
        EXTINT11 = 16067.0D0*Y
      ELSEIF(MOD(I,10).EQ.0) THEN
        EXTINT11 = 32134.0D0*Y
      ELSEIF(MOD(I,10).EQ.1.OR.MOD(I,10).EQ.9) THEN
        EXTINT11 = 106300.0D0*Y
      ELSEIF(MOD(I,10).EQ.2.OR.MOD(I,10).EQ.8) THEN
        EXTINT11 =-48525.0D0*Y
      ELSEIF(MOD(I,10).EQ.3.OR.MOD(I,10).EQ.7) THEN
        EXTINT11 = 272400.0D0*Y
      ELSEIF(MOD(I,10).EQ.4.OR.MOD(I,10).EQ.6) THEN
        EXTINT11 =-260550.0D0*Y
      ELSEIF(MOD(I,10).EQ.5) THEN
        EXTINT11 = 427368.0D0*Y
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE GNULINE(XOUT,TITLE,XAXIS,YAXIS,NDAT,KEY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       GGGGGG  NN    NN UU    UU LL       IIII NN    NN EEEEEEEE      C
C      GG    GG NNN   NN UU    UU LL        II  NNN   NN EE            C
C      GG       NNNN  NN UU    UU LL        II  NNNN  NN EE            C
C      GG       NN NN NN UU    UU LL        II  NN NN NN EEEEEE        C
C      GG   GGG NN  NNNN UU    UU LL        II  NN  NNNN EE            C
C      GG    GG NN   NNN UU    UU LL        II  NN   NNN EE            C
C       GGGGGG  NN    NN  UUUUUU  LLLLLLLL IIII NN    NN EEEEEEEE      C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNULINE IS A CONTROLLING ROUTINE THAT GENERATES A GNUPLOT MAKE FILE C
C  FOR A SET OF DATA POINTS.                                           C
C**********************************************************************C
C
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(NDAT)
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(XOUT)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot raw data'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ENDIF
      ENDDO
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf enhance font "palatino,10"'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(XOUT)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Load line style definitions'
      WRITE(9,'(A)') 'load "plots/plotstyles.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A)') 'set xlabel "'//TRIM(XAXIS)//'"'
      WRITE(9,'(A)') 'set ylabel "'//TRIM(YAXIS)//'"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plotting range'
      WRITE(9,'(A)') 'xmin = GPVAL_X_MIN'
      WRITE(9,'(A)') 'xmax = GPVAL_X_MAX'
      WRITE(9,'(A)') 'ymin = GPVAL_Y_MIN'
      WRITE(9,'(A)') 'ymax = GPVAL_Y_MAX'
      WRITE(9,'(A)') 'set xrange [xmin:xmax] noreverse nowriteback'
      WRITE(9,'(A)') 'set yrange [ymin:ymax] noreverse nowriteback'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Grid style'
      WRITE(9,'(A)') 'set style line 102 lc rgb"#808080" lt 0 lw 1'
      WRITE(9,'(A)') 'set grid back ls 102'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ENDIF
      ENDDO
      CLOSE(UNIT=9)
C
      WRITE(6, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
      WRITE(7, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
C
      RETURN
      END

