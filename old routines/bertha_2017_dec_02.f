      PROGRAM BERTHA
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         BBBBBBB  EEEEEEEE RRRRRRR TTTTTTTT HH    HH    AA            C
C         BB    BB EE       RR    RR   TT    HH    HH   AAAA           C
C         BB    BB EE       RR    RR   TT    HH    HH  AA  AA          C
C         BBBBBBB  EEEEEE   RR    RR   TT    HHHHHHHH AA    AA         C
C         BB    BB EE       RRRRRRR    TT    HH    HH AAAAAAAA         C
C         BB    BB EE       RR    RR   TT    HH    HH AA    AA         C
C         BBBBBBB  EEEEEEEE RR    RR   TT    HH    HH AA    AA         C
C                                                                      C
C                 (THE PROGRAM FORMERLY KNOWN AS...)                   C
C                                                                      C
C     SSSSSS  WW         WW IIII RRRRRRR  LL      EEEEEEEE SSSSSS      C
C    SS    SS WW         WW  II  RR    RR LL      EE      SS    SS     C
C    SS       WW         WW  II  RR    RR LL      EE      SS           C
C     SSSSSS  WW    W    WW  II  RR    RR LL      EEEEEE   SSSSSS      C
C          SS WW   WWW   WW  II  RRRRRRR  LL      EE            SS     C
C    SS    SS  WW WW WW WW   II  RR    RR LL      EE      SS    SS     C
C     SSSSSS    WW     WW   IIII RR    RR LLLLLLL EEEEEEEE SSSSSS      C
C                                                                      C
C -------------------------------------------------------------------- C
C                                                                      C
C        A RELATIVISTIC MOLECULAR ELECTRONIC STRUCTURE PROGRAM         C
C            BASED ON THE ANALYTIC FINITE BASIS SET METHOD.            C
C                                                                      C
C        (c)   H.M.QUINEY, H.SKAANE, I.P.GRANT (OXFORD, 1996)          C
C              D. FLYNN (UNIMELB, 2017)                                C
C                                                                      C
C ==================================================================== C
C                         HAMILTONIANS (HMLTN)                         C
C                         --------------------                         C
C   'NORL' NON-RELATIVISTIC HAMILTONIAN (PAULI EQUATION).              C
C   'BARE' BARE NUCLEUS DIRAC HAMILTONIAN (NO ELECTRON INTERACTION).   C
C   'DHFR' DIRAC-COULOMB HAMILTONIAN.                                  C
C   'DHFP' DIRAC-COULOMB HAMILTONIAN (+1ST ORDER BREIT).               C
C   'DHFB' DIRAC-COULOMB-BREIT HAMILTONIAN.                            C
C   'DHFQ' DIRAC-COULOMB-BREIT HAMILTONIAN WITH LEADING-ORDER QED.     C
C                                                                      C
C ==================================================================== C
C                      CALCULATION TREES (ITREE)                       C
C                      -------------------------                       C
C    I: HARTREE-FOCK SCF CALCULATION.                                  C
C   II: MANY-BODY DIAGRAMMATIC PERTURBATION THEORY.                    C
C  III: MULTI-CONFIGURATIONAL SCF CALCULATION.                         C
C   IV: DENSITY MATRIX RENORMALISATION GROUP CALCULATION.              C
C    V: CALCULATION OF MOLECULAR EXPECTATION VALUES.                   C
C   VI: VISUALS (ELECTROMAGNETIC FIELDS, POTENTIALS, AMPLITUDES ETC).  C
C                                                                      C
C ==================================================================== C
C                          TABLE OF CONTENTS                           C
C                          -----------------                           C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C   [4] ATOMIC HARTREE-FOCK: AVERAGE OF CONFIG. ATOMIC SCF.            C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTER HARTREE-FOCK SCF.          C
C   [6] MULTI-CONFIG: MANY-CENTER MULTICONFIG. SCF CALCULATIONS.       C
C   [7] DMRG: DENSITY MATRIX RENORMALISATION GROUP CALCULATIONS.       C
C   [8] MBPT: CORRELATION ENERGY CALCULATION ROUTINES.                 C
C   [9] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C  [10] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C  [11] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C  [12] E-COEFFS: FINITE BASIS OVERLAP SPIN STRUCTURE FACTORS.         C
C  [13] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C                                                                      C
C**********************************************************************C
C
      CHARACTER*4  HMLTN
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      
      DIMENSION KQN(2)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/TCPU/TTOT,TATM,TSCF,TMPT,TMCF,TDMG,TPRP,TPLT
C
C     START OF BERTHA RUN-TIME
      CALL CPU_TIME(T0)
C
C     READ DATA FROM USER-SPECIFIED INPUT FILE
      CALL CARDIN
C
C     OPEN FILE FOR TERMINAL RECORD
      OPEN(UNIT=7,FILE=TRIM(OUTFL)//'.out',STATUS='UNKNOWN')
C
C     PRINT SUMMARY OF INPUT DATA
      CALL INPUT
C
C     PRINT MEMORY ALLOCATION SUMMARY
      CALL MEMORY
C
C     INTER-ATOMIC ANGLES AND NUCLEAR REPULSION ENERGY
      CALL NUCGEOM
C
C     FOCK MATRIX SYMMETRY TYPE INDICES
      CALL FOCKIND
C
C     CARTESIAN EXPANSION INDICES FOR BASIS FUNCTION OVERLAP PAIRS
      CALL CARTIND
      
C      KQN(1) =-1
C      KQN(2) =-1
C      CALL TESTANG(KQN)
C      STOP
C
C     ATOMIC HARTREE-FOCK SCF ROUTINE
      CALL CPU_TIME(T1)
      IF(INEW.EQ.0) THEN
        CALL ATOMIC
      ENDIF
      CALL CPU_TIME(T2)
      TATM = T2-T1
C
C     MOLECULAR HARTREE-FOCK SCF ROUTINE
      IF(INEW.EQ.0.OR.ITREE.EQ.1) THEN
        IF(IMOL.NE.0) THEN
          CALL HFSCF
        ENDIF
      ENDIF
      CALL CPU_TIME(T3)
      TSCF = T3-T2
C
C     MANY-BODY DIAGRAMMATIC PERTURBATION THEORY
      IF(ITREE.EQ.2) THEN
        CALL MBPT
      ENDIF
      CALL CPU_TIME(T4)
      TMPT = T4-T3
C
C     MULTI-CONFIGURATIONAL SELF CONSISTENT FIELD CALCULATION
      IF(ITREE.EQ.3) THEN
        CALL MCSCF
      ENDIF
      CALL CPU_TIME(T5)
      TMCF = T5-T4
C
C     DENSITY MATRIX RENORMALISATION GROUP CALCULATION
      IF(ITREE.EQ.4) THEN
        CALL DMRG
      ENDIF
      CALL CPU_TIME(T6)
      TDMG = T6-T5
C
C     ONE-BODY HAMILTONIAN INTERACTIONS FROM A CONVERGED SOLUTION
      IF(ITREE.EQ.5) THEN
        CALL PT1BODY
      ENDIF
      CALL CPU_TIME(T7)
      TPRP = T7-T6
C
C     ELECTROMAGNETIC FIELDS AND POTENTIALS
      IF(ITREE.EQ.6) THEN
        CALL FIELDS
      ENDIF
      CALL CPU_TIME(T8)
      TPLT = T8-T7
C
C     END OF BERTHA RUN-TIME
      TTOT = T8-T0
C
C     PRINT SUMMARY OF OUTPUT DATA
      CALL OUTPUT
C
C     CLOSE FILE FOR TERMINAL RECORD
      CLOSE(UNIT=7)
C
C     SUCCESSFUL EXIT
      END PROGRAM
C
C
C**********************************************************************C
C ==================================================================== C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] CARDIN: READ MOLECULAR DATA FROM A USER-SPECIFIED FILE.        C
C   [B] INPUT: WRITE A SUMMARY OF DATA INPUT OPTIONS TO TERMINAL.      C
C   [C] MEMORY: WRITE A SUMMARY OF MEMORY REQUIREMENTS OF BIG ARRAYS.  C
C   [D] OUTPUT: WRITE A SUMMARY OF TOTAL CALCULATION STATS/DATA.       C
C**********************************************************************C
C
C
      SUBROUTINE CARDIN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            CCCCCC     AA    RRRRRRR  DDDDDDD IIII NN    NN           C
C           CC    CC   AAAA   RR    RR DD    DD II  NNN   NN           C
C           CC        AA  AA  RR    RR DD    DD II  NNNN  NN           C
C           CC       AA    AA RR    RR DD    DD II  NN NN NN           C
C           CC       AAAAAAAA RRRRRRR  DD    DD II  NN  NNNN           C
C           CC    CC AA    AA RR    RR DD    DD II  NN   NNN           C
C            CCCCCC  AA    AA RR    RR DDDDDDD IIII NN    NN           C
C                                                                      C
C                          INPUT ROUTINE FOR                           C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  CARDIN READS AND PREPARES DATA FROM A USER-SPECIFIED INPUT FILE.    C
C  THIS IS ALSO WHERE ATOMIC ELEMENT NAMES AND CV ARE SPECIFIED.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*1  DUMLIN
      CHARACTER*2  ELMNT(120)
      CHARACTER*4  HMLTN
      CHARACTER*7  HMINT(10),PTYPE(10)
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/EIGN/EIGEN(MDM)
      COMMON/FILL/NCNF(MCT,MKP,MKP+1),NLVL(MCT,MKP),IFILL(MCT)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(3),SHLV
      COMMON/MDLV/ELMNT
      COMMON/PLOT/NPTYPE,PTYPE
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/PT1B/NHMINT,HMINT
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
      DATA CV/1.370359898D2/
      DATA ELMNT/'H' ,'He','Li','Be','B' ,'C' ,'N' ,'O' ,'F' ,'Ne',
     &           'Na','Mg','Al','Si','P' ,'S' ,'Cl','Ar','K' ,'Ca',
     &           'Sc','Ti','V' ,'Cr','Mn','Fe','Co','Ni','Cu','Zn',
     &           'Ga','Ge','As','Se','Br','Kr','Rb','Sr','Y' ,'Zr',
     &           'Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
     &           'Sb','Te','I' ,'Xe','Cs','Ba','La','Ce','Pr','Nd',
     &           'Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
     &           'Lu','Hf','Ta','W' ,'Re','Os','Ir','Pt','Au','Hg',
     &           'Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th',
     &           'Pa','U' ,'Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
     &           'Md','No','Lr','Rf','Db','Sg','Bh','Hs','Mt','Ds',
     &           'Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og','Ue','Un'/
C
C     LINK THE OPENMP ROUTINE LIBRARY
      INCLUDE 'omp_lib.h'
C
C**********************************************************************C
C     MOLECULE NAME AND CALCULATION TYPE                               C
C**********************************************************************C
C
C     MOLECULE LABEL
      READ(5, *) DUMLIN
      READ(5, *) MOLCL
C
C     CHOICE OF HAMILTONIAN HMLTN: NORL, BARE, DHFR, DHFP, DHFB OR DHFQ
10    FORMAT(A4)
      READ(5, *) DUMLIN
      READ(5,10) HMLTN
C
C     ALLOW VALID HAMILTONIANS TO PASS
      IF(HMLTN.EQ.'NORL'.OR.HMLTN.EQ.'BARE'.OR.HMLTN.EQ.'DHFR'.OR.
     &   HMLTN.EQ.'DHFP'.OR.HMLTN.EQ.'DHFB'.OR.HMLTN.EQ.'DHFQ') GOTO 20
C
C     UNKNOWN HAMILTONIAN - ABNORMAL EXIT
      WRITE(6, *) 'In CARDIN: unknown HMLTN value. HMLTN = ',HMLTN
      WRITE(7, *) 'In CARDIN: unknown HMLTN value. HMLTN = ',HMLTN
      STOP
C
20    CONTINUE
C
C     WAVE FUNCTION FILE NAME
      WFNFL = 'output/'//TRIM(MOLCL)//'_'//HMLTN//'.wfn'
C
C     HARTREE-FOCK SCF(1), MBPT(2), MCSCF(3), DMRG(4), HMINT(5), PLOTS(6)
      READ(5, *) DUMLIN
      READ(5, *) ITREE
C
C     ENSURE USER HAS SELECTED VALID CHOICE OF ITREE
      IF(ITREE.LT.1.OR.ITREE.GT.6) THEN
        WRITE(6, *) 'In CARDIN: invalid calculation tree. ',ITREE
        WRITE(7, *) 'In CARDIN: invalid calculation tree. ',ITREE
        STOP
      ENDIF
C
C     OUTPUT FILE NAME
      IF(ITREE.EQ.1) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLTN//'_HFSCF'
      ELSEIF(ITREE.EQ.2) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLTN//'_MBPT'
      ELSEIF(ITREE.EQ.3) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLTN//'_MCSCF'
      ELSEIF(ITREE.EQ.4) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLTN//'_DMRG'
      ELSEIF(ITREE.EQ.5) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLTN//'_EXPVL'
      ELSEIF(ITREE.EQ.6) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLTN//'_PLOTS'
      ENDIF
C
C     NEW START(0), RESUME(1)
      READ(5, *) DUMLIN
      READ(5, *) INEW
C
C     E-COEFFICIENTS BY BATCH (0), TO LARGE EXTERNAL FILE (1)
      READ(5, *) DUMLIN
      READ(5, *) IEQS
C
C     SERIAL CALCULATION (0), OPENMP PARALLEL ENABLED (1)
      READ(5, *) DUMLIN
      READ(5, *) IPAR
C
C     MAX. NUMBER OF THREADS
C     ICOR = OMP_GET_NUM_PROCS()
      ICOR = 1
C
C**********************************************************************C
C     ATOMIC CENTERS AND BASIS FUNCTIONS                               C
C**********************************************************************C
C
C     BASIS SET TYPE: GEOMETRIC (1) OR OPTIMISED (2)
      READ(5, *) DUMLIN
      READ(5, *) INTYPE
C
C     NUMBER OF ATOMIC CENTERS
      READ(5, *) DUMLIN
      READ(5, *) NCNT
C
C     CHECK THAT NCNT CAN BE SUPPORTED BY SYSTEM PARAMETERS
      IF(NCNT.GT.MCT) THEN
        WRITE(6, *) 'In CARDIN: number of centers exceeds MCT.',MCT
        WRITE(7, *) 'In CARDIN: number of centers exceeds MCT.',MCT
        STOP
      ENDIF
C
C     SPECIFY ATOM OR MOLECULE
      IF(NCNT.EQ.1) THEN
        IMOL = 0
      ELSE
        IMOL = 1
      ENDIF
C
C     INITIALISE MAXIMUM LQN AND DIMENSION COUNTERS
      LBIG = 0
      NDIM = 0
C
C     LOOP OVER ATOMIC CENTERS
      DO ICNT=1,NCNT
C
C       CARTESIAN COORDINATES OF THIS CENTER
        READ(5, *) DUMLIN
        READ(5, *) (COORD(J,ICNT),J=1,3)
C
C       ZNUC, ATOMIC MASS, MAXIMUM LQN AND ATOMIC CHARGE
        READ(5, *) DUMLIN
        READ(5, *) IZNUC(ICNT),AMASS(ICNT),LMAX(ICNT),IQNUC(ICNT)
C
C       CHECK THAT LMAX CAN BE SUPPORTED BY SYSTEM PARAMETERS
        IF(2*LMAX(ICNT)+1.GT.MKP) THEN
          WRITE(6, *) 'In CARDIN: LMAX runs outside MKP storage.'
          WRITE(7, *) 'In CARDIN: LMAX runs outside MKP storage.'
          STOP
        ENDIF
C
C       AUFBAU FILLING FOR THIS CENTER: AUTOMATIC (0) OR MANUAL (1)
        READ(5, *) DUMLIN
        READ(5, *) IFILL(ICNT)
C
C       IF FILLING IS MANUAL, IMPORT ATOMIC ELECTRON CONFIGURATION
        IF(IFILL(ICNT).NE.0) THEN
          READ(5, *) DUMLIN
          DO L=1,LMAX(ICNT)+1
            READ(5, *) NLVL(ICNT,L),(NCNF(ICNT,L,N),N=1,NLVL(ICNT,L))
          ENDDO
        ENDIF
C
C       NUMBER OF KAPPA VALUES FOR THIS ATOM
        NKAP(ICNT) = 2*LMAX(ICNT)+1
C
C       NUCLEAR CHARGE AS A REAL VALUE
        ZNUC(ICNT) = DFLOAT(IZNUC(ICNT))
C
C       GAUSSIAN WIDTH PARAMETER FOR NUCLEAR CHARGE
        IF(IZNUC(ICNT).EQ.1) THEN
          CNUC(ICNT) = 2.1248239171D9
        ELSEIF(IZNUC(ICNT).EQ.8) THEN
          CNUC(ICNT) = 5.8631436655D8
        ELSE
          CDEN = AMASS(ICNT)**(1.0D0/3.0D0)
          CDEN = 0.836D0*CDEN + 0.57D0
          CDEN = 0.529177249D0/CDEN
          CNUC(ICNT) = 1.50D10*CDEN*CDEN
        ENDIF
C
C       UPDATE OVERALL MAXIMUM OCCURRING LQN
        IF(LMAX(ICNT).GT.LBIG) LBIG = LMAX(ICNT)
C
C       INITIATE IF STATEMENT FOR TYPE OF BASIS FUNCTION
        READ(5, *) DUMLIN
C
C       GEOMETRIC BASIS FUNCTIONS
        IF(INTYPE.EQ.1) THEN
C
C         GENERATE THE EVEN TEMPERED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX(ICNT)
C
C           READ GENERATING PARAMETERS A, B AND NFUNCT
            READ(5, *) APARAM,BPARAM,NFUNCT(LQN+1,ICNT)
C
C           CHECK THAT NFUNCT CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFUNCT(LQN+1,ICNT).GT.MBS) THEN
              WRITE(6, *) 'In CARDIN: too many basis functions.'
              WRITE(7, *) 'In CARDIN: too many basis functions.'
              STOP
            ENDIF
C
C           GENERATE NFUNCT BASIS EXPONENTS USING VARIABLE ZETA
            ZETA = APARAM
            DO IBAS=1,NFUNCT(LQN+1,ICNT)
              EXPSET(IBAS,LQN+1,ICNT) = ZETA
              ZETA = ZETA*BPARAM
            ENDDO
C
          ENDDO
C
C       OPTIMISED EXPONENTS FROM A RECORDED LIST
        ELSEIF(INTYPE.EQ.2) THEN
C
C         READ IN THE OPTIMISED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX(ICNT)
C
C           READ NUMBER OF BASIS FUNCTIONS
            READ(5, *) NFUNCT(LQN+1,ICNT)
C
C           CHECK THAT THIS CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFUNCT(LQN+1,ICNT).GT.MBS) THEN
              WRITE(6, *) 'In CARDIN: too many basis functions.'
              WRITE(7, *) 'In CARDIN: too many basis functions.'
              STOP
            ENDIF
C
C           READ BASIS EXPONENTS FROM A LIST
            DO IBAS=1,NFUNCT(LQN+1,ICNT)
              READ(5, *) EXPSET(IBAS,LQN+1,ICNT)
            ENDDO
C
          ENDDO
C
C       END IF STATEMENT FOR TYPE OF BASIS FUNCTION
        ENDIF
C
C       LOOP OVER ALL LQNS IN THIS CENTER AND ADD TO FOCK DIMENSION
        DO LQN=0,LMAX(ICNT)
C
C         EXTEND DIMENSION OF FOCK MATRIX
          NDIM = NDIM + 4*(2*LQN+1)*NFUNCT(LQN+1,ICNT)
C
C         ASSIGN KQN VALUES
          IF(LQN.NE.0) THEN
            KVALS(2*LQN  ,ICNT) = LQN
          ENDIF
          KVALS(2*LQN+1,ICNT) =-LQN-1
C
        ENDDO
C
C     END LOOP OVER ATOMIC CENTERS
      ENDDO
C
C     TOTAL DIMENSION DEPENDING ON CHOICE OF HAMILTONIAN
      IF(HMLTN.EQ.'NORL') THEN
        NDIM   = NDIM/2
        NSHIFT = 0
      ELSE
        NSHIFT = NDIM/2
      ENDIF
C
C     CHECK THAT SYSTEM PARAMETERS CAN SUPPORT NDIM
      IF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        WRITE(7, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        STOP
      ENDIF
C
C**********************************************************************C
C     CLOSED/OPEN SHELL DETAILS                                        C
C**********************************************************************C
C
C     NUMBER OF CLOSED- AND OPEN-SHELL ELECTRONS AND TOTAL ELECTRONS
      READ(5, *) DUMLIN
      READ(5, *) NCLS,NOPN,NOELEC
C
C     TOTAL NUMBER OF ELECTRONS IN SYSTEM
C     DFNOTE: THIS IS A HACK FOR NOW
      NOCC = NCLS + NOPN
      NVRT = NDIM - NSHIFT - NOCC
C
C     NOCC = 0
C     DO IZ=1,NCNT
C       NOCC = NOCC + IZNUC(IZ) - IQNUC(IZ)
C     ENDDO
C
C     INITIATE IF STATEMENT DEPENDING ON CLOSED/OPEN SHELLS

C     OPEN-SHELL MOLECULE
      goto 555
C     DFNOTE: ENABLE THIS OPTION
      IF(NOPN.NE.0) THEN
C
C       FRACTIONAL OCCUPANCY OF THE OPEN SHELL
        FOPN = DFLOAT(NOELEC)/DFLOAT(NOPN)
C
C       LABELS FOR THE OPEN SHELL
        READ(5, *) DUMLIN
        READ(5, *) ACFF,BCFF,(IOPN(M),M=1,NOPN)
C
C       PRINT THE LABELS FOR THE CLOSED-SHELL SPINORS USING KNOWN
C       IDENTITY OF THE OPEN-SHELL SPINORS
        JCL = 1
        JOP = 1
        DO JCOUNT=1,NOCC
C
C         APPLY LABEL TO EACH ORBITAL
          IF(JCOUNT.NE.IOPN(JOP)) THEN
            ICLS(JCL) = JCOUNT
            JCL = JCL + 1
          ELSE
            JOP = JOP + 1
          ENDIF
C
        ENDDO
C
C     CLOSED-SHELL MOLECULE
      ELSE
C
C       LABEL THE CLOSED-SHELL ELECTRONS
        DO JCL=1,NCLS
          ICLS(JCL) = JCL
        ENDDO
C
C     END IF STATEMENT FOR CLOSED/OPEN SHELLS
      ENDIF
C
555   continue
C
C     ALL SPINORS ARE CLOSED
      DO JCL=1,NCLS
        ICLS(JCL) = JCL
      ENDDO
C
C**********************************************************************C
C     LEVEL SHIFTING AND INTEGRAL INCLUSION                            C
C**********************************************************************C
C
C     LEVEL SHIFT PARAMETER FOR EACH INTEGRAL STAGE (SKAANE 4.4.3)
      READ(5, *) DUMLIN
      READ(5, *) (SHLEV(N),N=1,3)
C
C     STARTING STAGE OF INTEGRAL INCLUSION LEVEL (1-3)
      READ(5, *) DUMLIN
      READ(5, *) ILEV
C
C     REASONS TO CHANGE THE INTEGRAL INCLUSION LEVEL
      IF(HMLTN.EQ.'NORL') THEN
        ILEV = 1
      ENDIF
C
      IF(NCNT.EQ.1.OR.INEW.EQ.1) THEN
        ILEV = 3
      ENDIF
C
C     IMPLEMENT THE STARTING SHIFT FACTOR
      IF(ILEV.GE.1.AND.ILEV.LE.3) THEN
        SHLV = SHLEV(ILEV)
      ELSE
        WRITE(6, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        WRITE(7, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        STOP
      ENDIF
C
C**********************************************************************C
C     NON-HF CALCULATION DETAILS                                       C
C**********************************************************************C
C
C     EXPECTATION VALUE CALCULATIONS: ELCMNPL,MAGDIPL ETC
      IF(ITREE.EQ.5) THEN
C
C       READ NUMBER OF EXPECTATION VALUES
        READ(5, *) DUMLIN
        READ(5, *) NHMINT
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NHMINT.LT.1.OR.NHMINT.GT.10) THEN
          WRITE(6, *) 'In CARDIN: invalid number of expectation values.'
          WRITE(7, *) 'In CARDIN: invalid number of expectation values.'
          STOP
        ENDIF
C
C       READ IN EACH INTERACTION HAMILTONIAN
        DO N=1,NHMINT
          READ(5, *) HMINT(N)
        ENDDO
C
      ENDIF
C
C     DATA PLOTTING: AMPLITUDES, EM FIELDS AND POTENTIALS
      IF(ITREE.EQ.6) THEN
C
C       READ NUMBER OF PLOT TYPES
        READ(5, *) DUMLIN
        READ(5, *) NPTYPE
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NPTYPE.LT.1.OR.NPTYPE.GT.10) THEN
          WRITE(6, *) 'In CARDIN: invalid number of plot types.'
          WRITE(7, *) 'In CARDIN: invalid number of plot types.'
          STOP
        ENDIF
C
C       READ IN EACH PLOT TYPE
        DO N=1,NPTYPE
          READ(5, *) PTYPE(N)
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     READ IN ANY EXTERNAL DATA FILES                                  C
C**********************************************************************C
C
C     READ IN A WAVE FUNCTION FILE IF PROMPTED
      IF(INEW.EQ.1) THEN
        OPEN(UNIT=8,FILE=WFNFL,STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          READ(8, *) EIGEN(I),(C(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE INPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               IIII NN    NN PPPPPPP  UU    UU TTTTTTTT               C
C                II  NNN   NN PP    PP UU    UU    TT                  C
C                II  NNNN  NN PP    PP UU    UU    TT                  C
C                II  NN NN NN PP    PP UU    UU    TT                  C
C                II  NN  NNNN PPPPPPP  UU    UU    TT                  C
C                II  NN   NNN PP       UU    UU    TT                  C
C               IIII NN    NN PP        UUUUUU     TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  INPUT PRINTS MOLECULAR DATA INPUT OPTIONS TO THE TERMINAL.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MCT=6,MBS=26,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TSCF/TSCFS(32)
      COMMON/TMMD/TMMDS(7)
C
C     INITIALISE TIME COUNTERS
      DO NT=1,32
        TSCFS(NT) = 0.0D0
      ENDDO
C
      DO NT=1,8
        TMMDS(NT) = 0.0D0
      ENDDO
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',30),'INPUT SUMMARY'
      WRITE(7, *) REPEAT(' ',30),'INPUT SUMMARY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     TITLE FOR INPUT OPTIONS
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',21),'Calculation tree and data files'
      WRITE(7, *) REPEAT(' ',21),'Calculation tree and data files'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     CALCULATION TREE
      IF(ITREE.EQ.1) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',43),'Hartree-Fock'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',43),'Hartree-Fock'
      ELSEIF(ITREE.EQ.2) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',51),'MBPT'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',51),'MBPT'
      ELSEIF(ITREE.EQ.3) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',50),'MCSCF'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',50),'MCSCF'
      ELSEIF(ITREE.EQ.4) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',51),'DMRG'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',51),'DMRG'
      ELSEIF(ITREE.EQ.5) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',44),'Expct. vals'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',44),'Expct. vals'
      ELSEIF(ITREE.EQ.6) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',47),'Plotting'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',47),'Plotting'
      ENDIF
C
C     PRINT THE HAMILTONIAN OPTION
      WRITE(6, *) 'Hamiltonian type:',REPEAT(' ',51),HMLTN
      WRITE(7, *) 'Hamiltonian type:',REPEAT(' ',51),HMLTN
C
C     CONFIRM SOLUTION SPACE DIMENSION OR EXIT
      IF(NDIM.LE.MDM) THEN
        WRITE(6, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
        WRITE(7, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
      ELSEIF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        WRITE(7, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        STOP
      ENDIF
C
C     NEW START OR READ IN HFSCF EXPANSION COEFFICIENTS
      IF(INEW.EQ.0) THEN
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
      ELSE
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
      ENDIF
C
C     E-COEFFICIENT CALCULATION
      IF(IEQS.EQ.0) THEN
        WRITE(6, *) 'E-coefficients:',REPEAT(' ',49),'By batch'
        WRITE(7, *) 'E-coefficients:',REPEAT(' ',49),'By batch'
      ELSE
        WRITE(6, *) 'E-coefficients:',REPEAT(' ',45),'Save to file'
        WRITE(7, *) 'E-coefficients:',REPEAT(' ',45),'Save to file'
      ENDIF
C
C     OPENMP PARALLEL OPTION
      IF(IPAR.EQ.0) THEN
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
      ELSE
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(6, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),ICOR
        WRITE(7, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),ICOR
      ENDIF
C
C     SECTION FOR FILE NAMES
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     PRINT INPUT FILE NAME
      LF = LEN(TRIM(MOLCL))
      WRITE(6, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
      WRITE(7, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
C
C     PRINT FILE OUTPUT NAMES
      LN = LEN(TRIM(OUTFL))
      WRITE(6, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
      WRITE(7, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
C
C     RECORD TIME AT BEGINNING OF CALCULATION
      CALL CPU_TIME(TBEG)
      CALL TIMENOW(STAMP)
      WRITE(6, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
      WRITE(7, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
C
C     END OF INPUT SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE MEMORY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RRRRRRR  YY    YY      C
C     MMM     MMM EE       MMM     MMM OO    OO RR    RR YY    YY      C
C     MMMM   MMMM EE       MMMM   MMMM OO    OO RR    RR  YY  YY       C
C     MM MM MM MM EEEEEE   MM MM MM MM OO    OO RR    RR   YYYY        C
C     MM  MMM  MM EE       MM  MMM  MM OO    OO RRRRRRR     YY         C
C     MM   M   MM EE       MM   M   MM OO    OO RR    RR    YY         C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RR    RR    YY         C
C                                                                      C
C -------------------------------------------------------------------- C
C  MEMORY SUMMARISES THE SIZE AND MEMORY REQUIREMENTS OF BIG ARRAYS.   C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MFL=10000000,MKP=9,
     &                           MNU=MKP+1,MAB=2*MNU+5,NINT=1801,MLM=30)
C
      INTEGER*8  NAMEM,NCMEM,NDMEM,NEMEM,NMMEM,NRMEM,NTMEM
      INTEGER*16 NHMEM
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 C(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)

      COMMON/BSKL/EK(MB2),EL(MB2),RNKL(MB2,4),IKIND(MB2),JLIND(MB2),
     &            EIK(MB2,MAB),EJL(MB2,MAB),EKL(MB2,MAB)
      COMMON/BSBT/B1(MB2,MAB,MAB),B2(MB2,MAB,MAB),B3(MB2,MAB,MAB),
     &            B4(MB2,MAB,MAB)
      COMMON/BTRE/BKLLSS(MB2,4),BKSLSL(MB2,4),BKSSLL(MB2,4),
     &            BMSLSL(MB2,4)
      COMMON/CLRE/CKLLLL(MB2,4),CKSSSS(MB2,4),CKSLSL(MB2,4),
     &            CJLLLL(MB2,4),CJSSSS(MB2,4),CJLLSS(MB2,4),
     &            CJSSLL(MB2,4)
      COMMON/COEF/C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     TITLE FOR MEMORY SUMMARY
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Approx. system memory allocation'
      WRITE(7, *) REPEAT(' ',20),'Approx. system memory allocation'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     APPROXIMATE THE MEMORY STORAGE ALLOCATION
      NAMEM = SIZE(B1) + SIZE(B2) + SIZE(B3) + SIZE(B4)
     &      + SIZE(EK) + SIZE(EIK) + SIZE(EJL)
     &      + SIZE(EL) + SIZE(EKL) + SIZE(RNKL)
      NCMEM = 2*SIZE(C)
      NDMEM = 2*SIZE(DENC) + 2*SIZE(DENO) + 2*SIZE(DENT)
      NEMEM = SIZE(E0LLFL) + SIZE(E0SSFL) + SIZE(EILSFL)
      NHMEM = 20*MFL
      NMMEM = 2*SIZE(OVAP) + 2*SIZE(HNUC) + 2*SIZE(HKIN)
     &      + 2*SIZE(VUEH) + 2*SIZE(GDIR) + 2*SIZE(GXCH)
     &      + 2*SIZE(QDIR) + 2*SIZE(QXCH) + 2*SIZE(BDIR)
     &      + 2*SIZE(BXCH) + 2*SIZE(FOCK)
      NRMEM = SIZE(CKLLLL) + SIZE(CKSSSS) + SIZE(CKSLSL) + SIZE(CJLLLL)
     &      + SIZE(CJSSSS) + SIZE(CJLLSS) + SIZE(CJSSLL)
     &      + SIZE(BKLLSS) + SIZE(BKSLSL) + SIZE(BKSSLL) + SIZE(BMSLSL)
      NTMEM = NAMEM + NCMEM + NDMEM + NEMEM + NHMEM + NMMEM + NRMEM
C
C     SIZES (IN GIGABYTES)
      SAMEM = NAMEM*8.0D-9
      SCMEM = NCMEM*8.0D-9
      SDMEM = NDMEM*8.0D-9
      SEMEM = NEMEM*8.0D-9
      SHMEM = NHMEM*8.0D-9
      SMMEM = NMMEM*8.0D-9
      SRMEM = NRMEM*8.0D-9
      STMEM = NTMEM*8.0D-9
C
20    FORMAT(1X,A,4X,A,19X,A,9X,A)
21    FORMAT(1X,A,6X,A,5X,I12,9X,F9.5)
      WRITE(6,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(7,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(7,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(6,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(7,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(6,21) 'CLRE','Atomic Coulomb/Breit ints. ',NRMEM,SRMEM
      WRITE(7,21) 'CLRE','Atomic Coulomb/Breit ints. ',NRMEM,SRMEM
      WRITE(6,21) 'BSKL','Atomic mean-field submatrx.',NAMEM,SAMEM
      WRITE(7,21) 'BSKL','Atomic mean-field submatrx.',NAMEM,SAMEM
      WRITE(6,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(7,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(6,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(7,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(6,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(7,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) '    ','Total                      ',NTMEM,STMEM
      WRITE(7,21) '    ','Total                      ',NTMEM,STMEM
C
C     END OF MEMORY SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE OUTPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  UU    UU TTTTTTTT PPPPPPP  UU    UU TTTTTTTT        C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PPPPPPP  UU    UU    TT           C
C         OO    OO UU    UU    TT    PP       UU    UU    TT           C
C          OOOOOO   UUUUUU     TT    PP        UUUUUU     TT           C
C                                                                      C
C                       SUMMARISING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  OUTPUT PRINTS A SUMMARY OF TOTAL CALCULATION DATA TO TERMINAL.      C
C**********************************************************************C
      PARAMETER(MCT=6,MBS=26,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TCPU/TTOT,TATM,TSCF,TMPT,TMCF,TDMG,TPRP,TPLT
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',30),'OUTPUT SUMMARY'
      WRITE(7, *) REPEAT(' ',30),'OUTPUT SUMMARY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME AT BERTHA EXIT
      CALL TIMENOW(STAMP)
C
C     PRINT TABLE OF DATA
20    FORMAT(1X,A,26X,A)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',28),'CPU time summary'
      WRITE(7, *) REPEAT(' ',28),'CPU time summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(INEW.EQ.0) THEN
        WRITE(6,20) 'Atomic Hartree-Fock SCF:      ',HMS(TATM)
        WRITE(7,20) 'Atomic Hartree-Fock SCF:      ',HMS(TATM)
      ENDIF
      IF(ITREE.EQ.1.OR.INEW.EQ.0) THEN
        WRITE(6,20) 'Molecular Hartree-Fock SCF:   ',HMS(TSCF)
        WRITE(7,20) 'Molecular Hartree-Fock SCF:   ',HMS(TSCF)
      ELSEIF(ITREE.EQ.2) THEN
        WRITE(6,20) 'Many-body perturbation theory:',HMS(TMPT)
        WRITE(7,20) 'Many-body perturbation theory:',HMS(TMPT)
      ELSEIF(ITREE.EQ.3) THEN
        WRITE(6,20) 'Multi-configurational SCF:    ',HMS(TMCF)
        WRITE(7,20) 'Multi-configurational SCF:    ',HMS(TMCF)
      ELSEIF(ITREE.EQ.4) THEN
        WRITE(6,20) 'Density matrix renorm. group: ',HMS(TDMG)
        WRITE(7,20) 'Density matrix renorm. group: ',HMS(TDMG)
      ELSEIF(ITREE.EQ.5) THEN
        WRITE(6,20) 'Property calculation:         ',HMS(TPRP)
        WRITE(7,20) 'Property calculation:         ',HMS(TPRP)
      ELSEIF(ITREE.EQ.6) THEN
        WRITE(6,20) 'Plotting:                     ',HMS(TPLT)
        WRITE(7,20) 'Plotting:                     ',HMS(TPLT)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(7,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     SUCCESSFUL EXIT MESSAGE
      WRITE(6, *)
      WRITE(7, *)
      WRITE(6, *) 'Successful BERTHA exit at:',REPEAT(' ',26),STAMP
      WRITE(7, *) 'Successful BERTHA exit at:',REPEAT(' ',26),STAMP
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] NUCGEOM: BOND DISTANCES AND NUCLEAR REPULSION ENERGY.          C
C   [B] FOCKIND: CALCULATE ADDRESSES OF FOCK MATRIX FOR BASIS QN'S.    C
C   [C] CARTIND: GENERATES INDICES FOR EQ-COEFFS AND R-INTEGRALS.      C
C   [D] AUFBAU: DETERMINES GROUND STATE ATOMIC ELECTRON CONFIG.        C
C   [E] SPECTRM: DISPLAYS EIGENVALES AND ATOMIC TERM SYMBOLS.          C
C   [F] ELLTERM: GIVES THE CHARACTER CORRESPONDING TO LQN VALUE L.     C
C   [G] ROTATE: PERFORM TWO EULER ROTATIONS ON ALL ATOMIC CENTERS.     C
C   [H] MMPROD: PRODUCT OF TWO SQUARE ARRAYS OF DOUBLES.               C
C   [I] MVPROD: PRODUCT OF A SQUARE MATRIX AND VECTOR OF DOUBLES.      C
C   [K] HMS: RETURNS A QUOTED TIME IN SECONDS AS 'MIN-SEC'.            C
C   [J] MS: RETURNS A QUOTED TIME IN SECONDS AS 'HR-MIN-SEC'.          C
C   [L] TIMENOW: RETURNS A DATE STRING FOR THE CPU TIME.               C
C**********************************************************************CC
C
      SUBROUTINE NUCGEOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  NN    NN UU    UU  CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C  NNN   NN UU    UU CC    CC GG    GG EE       OO    OO MMM     MMM   C
C  NNNN  NN UU    UU CC       GG       EE       OO    OO MMMM   MMMM   C
C  NN NN NN UU    UU CC       GG       EEEEEE   OO    OO MM MM MM MM   C
C  NN  NNNN UU    UU CC       GG   GGG EE       OO    OO MM  MMM  MM   C
C  NN   NNN UU    UU CC    CC GG    GG EE       OO    OO MM   M   MM   C
C  NN    NN  UUUUUU   CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCGEOM TRANSLATES AND ROTATES A MOLECULE IN A WAY THAT IS BEST     C
C  SUITED TO EFFICIENT COMPUTATION, IDENTIFIES MOLECULAR SHAPE AND     C
C  BOND DISTANCES, AND CALCULATES NUCLEAR REPULSION ENERGY.            C
C -------------------------------------------------------------------- C
C  DFNOTE: THE TSYM PACKAGE (WERNER 1996) CAN BE DIRECTLY IMPLEMENTED  C
C          AT THIS POINT AND PERFORMS POINT GROUP SYMMETRY ANALYSIS.   C
C          THIS RESULTS IN A HAMILTONIAN MATRIX OF BLOCK STRUCTURE     C
C          ACCORDING TO IRREPS, AND SPEEDS UP SCF CALCULATIONS.        C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9)
C
      CHARACTER*2 ELMNT(120),ELA,ELB,ELC
      CHARACTER*8 SHAPE,SPCES
C
      DIMENSION XYZ(3,MCT),DIST(MCT),CENT(3),IZAD(MCT,3)
C
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/GEOM/SHAPE
      COMMON/MDLV/ELMNT
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT

      DATA PI/3.1415926535897932D0/
C
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',25),'MOLECULAR COORDINATES'
      WRITE(7, *) REPEAT(' ',25),'MOLECULAR COORDINATES'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C**********************************************************************C
C     IDENTIFY LARGEST ATOMIC CENTERS                                  C
C**********************************************************************C
C
C     IDENTIFY THE THREE LARGEST NUCLEAR CHARGES
      LZ1 = 0
      LZ2 = 0
      LZ3 = 0
      DO N=1,NCNT
        IZ = IZNUC(N)
        IF(IZ.GT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = LZ1
          LZ1 = IZ
        ELSEIF(IZ.GT.LZ2.AND.IZ.LT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = IZ
        ELSEIF(IZ.GT.LZ3.AND.IZ.LT.LZ2) THEN
          LZ3 = IZ
        ENDIF
      ENDDO
C
C     COUNT CENTERS WITH TOP THREE NUCLEAR CHARGES
      NZ1 = 0
      NZ2 = 0
      NZ3 = 0
      DO N=1,NCNT
        IZ = IZNUC(N)
        IF(IZ.EQ.LZ1) THEN
          NZ1 = NZ1 + 1
          IZAD(NZ1,1) = N
        ELSEIF(IZ.EQ.LZ2) THEN
          NZ2 = NZ2 + 1
          IZAD(NZ2,2) = N
        ELSEIF(IZ.EQ.LZ3) THEN
          NZ3 = NZ3 + 1
          IZAD(NZ3,3) = N
        ENDIF
      ENDDO
C
C     DESIGNATE SPECIES OF MOLECULE
      IF(NZ2.EQ.0) THEN
        SPCES = 'HOMONUC.'
      ELSE
        SPCES = 'HTRONUC.'
      ENDIF
C
C**********************************************************************C
C     TRANSLATION: ORIGIN COINCIDES WITH CENTER OF ALL HEAVY ATOMS     C
C**********************************************************************C
C
C     CALCULATE CENTER OF ALL CHARGES LZ1
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ1
          CENT(I) = CENT(I) + COORD(I,IZAD(N,1))
        ENDDO
        CENT(I) = CENT(I)/NZ1
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     TRANSLATE MOLECULE BY CENT(I) AND CALCULATE DISTANCE TO ORIGIN
      DO N=1,NCNT
        DO I=1,3
          XYZ(I,N) = COORD(I,N) - CENT(I)
        ENDDO
        DIST(N) = DSQRT(XYZ(1,N)**2 + XYZ(2,N)**2 + XYZ(3,N)**2)
      ENDDO
C
C     ALERT THE USER IF TRANSLATION WAS SUBSTANTIAL
      IF(DCNT.GT.1.0D-4) THEN
        WRITE(6, *) 'In NUCGEOM: molecule has been translated.'
        WRITE(7, *) 'In NUCGEOM: molecule has been translated.'
      ENDIF
C
C     ONE-CENTER (MUST BE ATOMIC)
      IF(NCNT.EQ.1) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'ATOMIC'
C
C       NO ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     FIRST ROTATION: FIX ON A ROTATION CENTER AND ROTATE TO Z-AXIS.   C
C**********************************************************************C
C
C     IF AN LZ1 CENTER IS ON Z-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(3,N))
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 200
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTER THAT DOES NOT LIE ON ORIGIN
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        IF(DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 35
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTER ALREADY ON
C     THE Z-AXIS AND NO LZ1 CENTER OFF THE ORIGIN --> MOVE TO LZ2.
C
C     VECTOR CENTER OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTER OF LZ2 IS ON Z-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DABS(CENT(3))
      IF(DABS(X).LT.1.0D-4.AND.DCNT.GT.1.0D-4) THEN
        GOTO 200
      ENDIF
C
C     IF CENTER OF LZ2 IS ON ORIGIN, FIX ON AN LZ2 NOT ON THE ORIGIN
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          IF(DIST(N).GT.1.0D-4) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 35
          ENDIF
        ENDDO
      ENDIF
C
C     LZ1 AND LZ2 ALWAYS SUFFICIENT TO DEFINE A Z ORIENTATION
C
C     SKIP POINT (ROTATION CENTER HAS BEEN IDENTIFIED)
35    CONTINUE
C
C     CALCULATE FIRST ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
C     BETA  IS ROTATION ANGLE FROM (X,Z) TO (0,Z')
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      BETA  = DACOS(CENT(3)/DCNT)
      CALL ROTATE(XYZ,NCNT,ALPHA,BETA)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Z-AXIS ROTATION NECESSARY
200   CONTINUE
C
C     TWO-CENTER (MUST BE DIATOMIC)
      IF(NCNT.EQ.2) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'DIATOMIC'
C
C       NO FURTHER ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     SECOND ROTATION: FIX ON A ROTATION CENTER AND ROTATE TO Y-AXIS.  C
C**********************************************************************C
C
C     CHECK WHETHER MOLECULE IS LINEAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2 + XYZ(2,N)**2
        IF(TEST.GT.1.0D-6) GOTO 40
      ENDDO
      SHAPE = 'LINEAR'
      GOTO 300
40    CONTINUE
C
C     IF AN LZ1 CENTER IS ON YZ-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DSQRT(XYZ(2,N)**2 + XYZ(3,N)**2)
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 300
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTER THAT DOES NOT LIE ON ORIGIN OR Z-AXIS
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(2,N))
        IF(DABS(X).GT.1.0D-4.AND.DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 50
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTER ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTER OFF THE ORIGIN --> MOVE TO LZ2.
C
C     IF THERE ARE NO LZ2 CENTERS, SKIP ROTATION
      IF(NZ2.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTER OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTER OF LZ2 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTER OF LZ2 IS NOT ON Y-AXIS, MAKE IT THE CENTER
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTER OF LZ2 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTER OF LZ2 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ2 CENTER ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTER OFF THE ORIGIN --> MOVE TO LZ3.
C
C     IF THERE ARE NO LZ3 CENTERS, SKIP ROTATION
      IF(NZ3.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTER OF ALL LZ3
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ3
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ3
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTER OF LZ3 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTER OF LZ3 IS NOT ON Y-AXIS, MAKE IT THE CENTER
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTER OF LZ3 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTER OF LZ3 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     SKIP POINT (ROTATION CENTER HAS BEEN IDENTIFIED)
50    CONTINUE

C     CALCULATE ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      CALL ROTATE(XYZ,NCNT,ALPHA,0.0D0)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Y-AXIS ROTATION NECESSARY
300   CONTINUE
C
C     IF MOLECULE ALREADY HAS LABEL, SKIP
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR')
     & GOTO 400
C
C     CHECK WHETHER MOLECULE IS PLANAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2
        IF(TEST.GT.1.0D-6) GOTO 60
      ENDDO
      SHAPE = 'PLANAR'
60    CONTINUE
C
C     NO MOLECULAR SYMMETRY
      SHAPE = 'NOSYMM'
C
400   CONTINUE
C
C     TRANSFER ALL TEMPORARY COORDINATES TO THE COMMON ARRAY
      DO N=1,NCNT
        DO I=1,3
          COORD(I,N) = XYZ(I,N)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR GEOMETRY, BOND DISTANCES AND NUCLEAR REPULSION ENERGY  C
C**********************************************************************C
C
C     ATOMIC COORDINATES
20    FORMAT(13X,A)
21    FORMAT(1X,A,12X,A,14X,A,14X,A)
22    FORMAT(1X,I2,' (',A,') ',6X,F16.10,5X,F16.10,5X,F16.10)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) '  Molecular geometry A: Cartesian coordinates'
      WRITE(7,20) '  Molecular geometry A: Cartesian coordinates'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,21) 'Center','x-coord','y-coord','z-coord'
      WRITE(7,21) 'Center','x-coord','y-coord','z-coord'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO ICNT=1,NCNT
        ELA = ELMNT(IZNUC(ICNT))
        WRITE(6,22) ICNT,ELA,COORD(1,ICNT),COORD(2,ICNT),COORD(3,ICNT)
        WRITE(7,22) ICNT,ELA,COORD(1,ICNT),COORD(2,ICNT),COORD(3,ICNT)
      ENDDO
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     BOND ANGLES AND DISTANCES
30    FORMAT(21X,A)
31    FORMAT(1X,A,8X,A,12X,A,12X,A)
32    FORMAT(1X,A,2X,A,7X,F14.6)
33    FORMAT(40X,A,2X,A,2X,A,9X,F14.6)
      IF(NCNT.EQ.1) THEN
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
      ELSEIF(NCNT.GT.1) THEN
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'Molecular geometry B: R-matrix'
        WRITE(7,30) 'Molecular geometry B: R-matrix'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,31) 'C1  C2','Bond distance','C1  C2  C3','Angle (deg)'
        WRITE(7,31) 'C1  C2','Bond distance','C1  C2  C3','Angle'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
C
        ICNT = 1
        DO JCNT=2,NCNT
          ELA = ELMNT(IZNUC(ICNT))
          ELB = ELMNT(IZNUC(JCNT))
          R1X = COORD(1,JCNT) - COORD(1,ICNT)
          R1Y = COORD(2,JCNT) - COORD(2,ICNT)
          R1Z = COORD(3,JCNT) - COORD(3,ICNT)
          D1  = DSQRT(R1X*R1X + R1Y*R1Y + R1Z*R1Z)
          WRITE(6,32) ELA,ELB,D1
          WRITE(7,32) ELA,ELB,D1
C
          DO KCNT=2,JCNT-1
            ELA = ELMNT(IZNUC(ICNT))
            ELB = ELMNT(IZNUC(JCNT))
            ELC = ELMNT(IZNUC(KCNT))
            R2X = COORD(1,KCNT) - COORD(1,ICNT)
            R2Y = COORD(2,KCNT) - COORD(2,ICNT)
            R2Z = COORD(3,KCNT) - COORD(3,ICNT)
            D2  = DSQRT(R2X*R2X + R2Y*R2Y + R2Z*R2Z)
            SP  = (R1X*R2X + R1Y*R2Y + R1Z*R2Z)
            D12 = D1*D2
            DEG = 180.0D0/PI
            ANG = DEG*DACOS(SP/D12)
            WRITE(6,33) ELB,ELA,ELC,ANG
            WRITE(7,33) ELB,ELA,ELC,ANG
          ENDDO
          IF(JCNT.NE.NCNT) THEN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
          ENDIF
        ENDDO
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
        DO ICNT=1,NCNT
          DO JCNT=1,ICNT-1
            SEP  = DSQRT((COORD(1,ICNT) - COORD(1,JCNT))**2
     #                  +(COORD(2,ICNT) - COORD(2,JCNT))**2
     #                  +(COORD(3,ICNT) - COORD(3,JCNT))**2)
            EPNT = ZNUC(ICNT)*ZNUC(JCNT)/SEP
C
CC          THIS CODE INCLUDES GAUSSIAN CHARGE STRUCTURE EFFECTS,
CC          BUT CORRECTIONS EXCEED DOUBLE FLOAT ACCURACY LIMITS...
C           EPRD = CNUC(ICNT)*CNUC(JCNT)
C           ESUM = CNUC(ICNT)+CNUC(JCNT)
C           EGAU = DSQRT(EPRD/ESUM)*SEP
C           EERF = DERF(EGAU)
C           ESEP = EPNT*EERF
C
            ESEP = EPNT
            ENUC = ENUC + ESEP

          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FOCKIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       FFFFFFFF OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C       FF      OO    OO CC    CC KK   KK   II  NNN   NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NNNN  NN DD    DD      C
C       FFFFFF  OO    OO CC       KKKKK     II  NN NN NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NN  NNNN DD    DD      C
C       FF      OO    OO CC    CC KK   KK   II  NN   NNN DD    DD      C
C       FF       OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  FOCKIND ASSIGNS INDICES FOR FOCK MATRIX BLOCKS DEPENDING ON         C
C  ICNT, KQN AND MQN QUANTUM NUMBERS OF EACH BASIS FUNCTION.           C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     QUANTUM NUMBER LABELS
      ILST = 0
      DO ICNT=1,NCNT
        DO IMV=1,(MKP+1)/2
          MQN = 2*IMV-1
C
C         LABEL MQN<0 BLOCKS
          DO KA=1,NKAP(ICNT)
            KQN = KVALS(KA,ICNT)
            IF(KQN.GT.0) THEN
              LQN = KQN
            ELSE
              LQN =-KQN-1
            ENDIF
            NBAS  = NFUNCT(LQN+1,ICNT)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LARGE(ICNT,KA,MQN) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = ICNT
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) =-MQN
              ENDDO
              ILST = ILST+NBAS
            ENDIF
          ENDDO
C
C         LABEL MQN>0 BLOCKS
          DO KA=1,NKAP(ICNT)
            KQN = KVALS(KA,ICNT)
            IF(KQN.GT.0) THEN
              LQN = KQN
            ELSE
              LQN =-KQN-1
            ENDIF
            NBAS  = NFUNCT(LQN+1,ICNT)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LARGE(ICNT,KA,MQN+1) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = ICNT
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) = MQN
              ENDDO
              ILST = ILST + NBAS
            ENDIF
          ENDDO

        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE CARTIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        CCCCCC     AA    RRRRRRR TTTTTTTT IIII NN    NN DDDDDDD       C
C       CC    CC   AAAA   RR    RR   TT     II  NNN   NN DD    DD      C
C       CC        AA  AA  RR    RR   TT     II  NNNN  NN DD    DD      C
C       CC       AA    AA RR    RR   TT     II  NN NN NN DD    DD      C
C       CC       AAAAAAAA RRRRRRR    TT     II  NN  NNNN DD    DD      C
C       CC    CC AA    AA RR    RR   TT     II  NN   NNN DD    DD      C
C        CCCCCC  AA    AA RR    RR   TT    IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  CARTIND GENERATES INDICES FOR EQ-COEFFICIENTS AND R-INTEGRALS.      C
C**********************************************************************C
      PARAMETER(MKP=9,ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C     LOOP OVER ALL (A,B,C) SO THAT A+B+C=LAM AND APPLY ORDERED ADDRESS
      N = 0
      DO LAM=0,ML4
        DO IA=0,LAM
          DO IB=0,LAM
            DO IC=0,LAM
C
C             TEST WHETER A+B+C=LAM
              IF(IA+IB+IC.NE.LAM) GOTO 10
C
C             UPDATE ADDRESS
              N = N+1
C
C             CARTESIAN INDICES (A,B,C) AND LAM VALUE FOR THIS ADDRESS
              IVEC(N)   = IA
              JVEC(N)   = IB
              KVEC(N)   = IC
              LAMVEC(N) = LAM
C
C             GLOBAL ADDRESS FOR THIS (A,B,C) INDEX
              INABCD(IA,IB,IC) = N
C
C             SKIP POINT FOR (A,B,C) THAT DO NOT ADD TO LAM
10            CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE AUFBAU(IZNUC,IQNUC,NORB,NOCC,LQNMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            AA    UU    UU FFFFFFF BBBBBBB     AA    UU    UU         C
C           AAAA   UU    UU FF      BB    BB   AAAA   UU    UU         C
C          AA  AA  UU    UU FF      BB    BB  AA  AA  UU    UU         C
C         AA    AA UU    UU FFFFF   BBBBBBB  AA    AA UU    UU         C
C         AAAAAAAA UU    UU FF      BB    BB AAAAAAAA UU    UU         C
C         AA    AA UU    UU FF      BB    BB AA    AA UU    UU         C
C         AA    AA  UUUUUU  FF      BBBBBBB  AA    AA  UUUUUU          C
C                                                                      C
C -------------------------------------------------------------------- C
C  AUFBAU DETERMINES THE GROUND STATE ELECTRONIC CONFIGURATION OF A    C
C  NEUTRAL ATOM OF CHARGE IZNUC, UP TO COMPLETE OCCUPATION WITH THE    C
C  LIMIT LQNMAX = 4 (g-ORBITALS). 220 AVAILABLE ORBITALS.              C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    LQNMAX IS THE HIGHEST LQN REQUIRED TO DESCRIBE THE GROUND STATE   C
C    NOCC SAVES THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS      C
C    NORB SAVES THE NUMBER OF ELECTRONS IN OF TYPE LQN IN SHELL N      C
C  PARAMETERS:                                                         C
C    IAUF STORES THE LQN OF ORBITALS IN ORDER OF HYDROGENIC ENERGY     C
C**********************************************************************C
      PARAMETER(MKP=9)
C
      DIMENSION NORB(MKP,12),NOCC(MKP),IAUF((MKP+1)*(MKP+3)/4)
C
C     INITIALISE THE COUNTER FOR NUMBER OF ELECTRONS IN EACH ORBTIAL
      DO LQN=0,(MKP-1)/2
        NOCC(LQN+1) = 0
      ENDDO
C
C     LQN OF ATOMIC ENERGY LEVELS IN AUFBAU ORDER
      ICT = 0
      DO L=0,(MKP-1)/2
        DO M=1,2
          DO J=L,0,-1
          ICT = ICT + 1
          IAUF(ICT) = J
          ENDDO
        ENDDO
      ENDDO
C
C     INITIALISE THE MAX LQN COUNTER
      LQNMAX = 0
C
C     INITIALISE THE NUMBER OF ELECTRONS LEFT TO FILL ORBITALS WITH
      ILEFT = IZNUC-IQNUC
C
C     INITIALISE LOOP OVER ORBITALS
      DO M=1,30
C
C       EXIT IF THERE ARE NO ELECTRONS LEFT TO COUNT
        IF(ILEFT.EQ.0) GOTO 20
C
C       THE LQN OF THIS ORBITAL IS STORED IN IAUF
        LQN = IAUF(M)
C
C       UPDATE THE MAX LQN COUNTER IF NECESSARY
        IF(LQN.GT.LQNMAX) THEN
          LQNMAX = LQN
        ENDIF
C
C       ADD TO THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS
        NOCC(LQN+1) = NOCC(LQN+1)+1
C
C       DETERMINE NO. OF ELECTRONS REQ'D TO FULLY OCCUPY THIS SUBSHELL
        IFULL = 4*LQN + 2
C
C       BEGIN IF STATEMENT TO DETERMINE THE SUBSHELL OCCUPATION
        IF(ILEFT.GT.IFULL) THEN
C
C         IF THERE ARE MORE ELECTRONS LEFT THAN IFULL, FILL THE SUBSHELL
          NORB(LQN+1,NOCC(LQN+1)) = IFULL
          ILEFT = ILEFT-IFULL
C
        ELSE
C
C         OTHERWISE, LEAVE ALL REMAINING ELECTRONS IN THIS NSHELL
          NORB(LQN+1,NOCC(LQN+1)) = ILEFT
          GOTO 20
C
C       END THE NSHELL IF STATEMENT
        ENDIF
C
C     END LOOP OVER ATOMIC ORBITALS
      ENDDO
20    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE SPECTRM(IBND,IVIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS  PPPPPPP  EEEEEEEE  CCCCCC  TTTTTTTT RRRRRRR  MM       MM   C
C  SS    SS PP    PP EE       CC    CC    TT    RR    RR MMM     MMM   C
C  SS       PP    PP EE       CC          TT    RR    RR MMMM   MMMM   C
C   SSSSSS  PP    PP EEEEEE   CC          TT    RR    RR MM MM MM MM   C
C        SS PPPPPPP  EE       CC          TT    RRRRRRR  MM  MMM  MM   C
C  SS    SS PP       EE       CC    CC    TT    RR    RR MM   M   MM   C
C   SSSSSS  PP       EEEEEEEE  CCCCCC     TT    RR    RR MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPECTRM SUMMARISES THE ENERGY LEVELS OF AN SCF ITERATION, USING     C
C  ATOMIC TERM SYMBOLS, ATOMIC CENTERS AND FRACTIONAL POPULATIONS.     C
C  IT ALSO APPLIES SYMMETRY LABELS TO EACH STATE AND SORTS MQN M'FOLDS.C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    IBND - NUMBER OF BOUND ORBITALS TO INCLUDE.                       C
C    IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE.                     C
C -------------------------------------------------------------------- C
C  DFNOTE: FIGURE OUT HOW TO SORT THROUGH MANIFOLD IN ATOMIC CASE.     C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*1 CHL,ELLTERM
      CHARACTER*2 ELMNT(120),ELA
      CHARACTER*4 HMLTN
C
      DIMENSION FRAC(MDM,MCT,MKP,MKP+1),NPR(MCT,MKP,MKP+1)
      DIMENSION ICNLST(MDM),KQNLST(MDM),MQNLST(MDM),NQNLST(MDM),
     &          POPLST(MDM)
C
      COMPLEX*16 C(MDM,MDM),CTEMP,ROT1,ROT2
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/EIGN/EIGEN(MDM)
      COMMON/MDLV/ELMNT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
      DATA PI/3.1415926535897932D0/
C
C     SENSITIVITY TOLERANCE PARAMETER
      EPS = 1.0D-14
C
C     INITIALISE COUNTER ARRAYS
      DO ICNT=1,NCNT
        DO IKAP=1,NKAP(ICNT)
          IKQN = KVALS(IKAP,ICNT)
          IF(IKQN.LT.0) THEN
            ILQN =-IKQN-1
          ELSE
            ILQN = IKQN
          ENDIF
          NMV = 2*IABS(IKQN)
          DO IMV=1,NMV
            DO IOCC=1,IBND+IVIR
              FRAC(IOCC,ICNT,IKAP,IMV) = 0.0D0
            ENDDO
            NPR(ICNT,IKAP,IMV) = ILQN
          ENDDO
        ENDDO
      ENDDO
C
C     INTERNAL ROTATION BETWEEN PAIRS OF STATES
      DO IPAIR=1,NDIM-NSHIFT,2
C
C       SKIP NEGATIVE ENERGY SPECTRUM
        MPAIR = IPAIR+NSHIFT
C
C       TEMPORARY LARGE VALUE
        RLRG = 10.0D10
C
C       INITIAL INCRIMENTAL RADIAN (SWEEP OVER ALL POSSIBLE ANGLES)
        RINC = PI/180.0D0
C
C       SEARCH FOR STARTING POINT BY SWEEPING ANGLES 0 <= PHI < PI
        DO NPHI=0,179
C
C         CALCULATE ROTATION ANGLE AND COS/SIN TRANSFORMATIONS
          PHI  = RINC*DFLOAT(NPHI)
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*C(I,MPAIR  ) + SPHI*C(I,MPAIR+1)
            ROT2 =-SPHI*C(I,MPAIR  ) + CPHI*C(I,MPAIR+1)
            OLAP = OLAP + CDABS(ROT1)*CDABS(ROT2)
          ENDDO
C
C         FIND PHI WHICH RESULTS IN SMALLEST SUM OF PRODUCTS
          IF(OLAP.LT.RLRG) THEN
            PHI0 = PHI
            RLRG = OLAP
          ENDIF
        ENDDO
C
C       NEW STARTING ROTATION ANGLE BASED ON THE ABOVE SEARCH
        PHI  = PHI0 - RINC
        SOLD = 1.0D11
C
C       SWEEP THROUGH INCREMENTAL ANGLES AND SEARCH AGAIN
        DO NPHI=1,4000
          PHI  = PHI + RINC
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*C(I,MPAIR  ) + SPHI*C(I,MPAIR+1)
            ROT2 =-SPHI*C(I,MPAIR  ) + CPHI*C(I,MPAIR+1)
            OLAP = OLAP + CDABS(ROT1)*CDABS(ROT2)
          ENDDO
C
C         IF THE NEW VALUE IS BELOW A TOLERANCE, FINISH.
          IF(DABS(OLAP-SOLD).LT.EPS) GOTO 1
C
C         IF SUM OF COEFFICIENT PRODUCTS IS BIGGER THAN COUNTER, REFINE.
          IF(OLAP.GT.SOLD) THEN
            RINC =-RINC/10.0D0
          ENDIF
C
C         DECREASE COUNTER VALUE
          SOLD = OLAP
C
        ENDDO
1       CONTINUE
C
C       PERFORM THE ACTUAL ROTATION USING THE BEST SOLUTION PHI
        CPHI = DCOS(PHI)
        SPHI = DSIN(PHI)
        DO I=1,NDIM
          ROT1 = CPHI*C(I,MPAIR  ) + SPHI*C(I,MPAIR+1)
          ROT2 =-SPHI*C(I,MPAIR  ) + CPHI*C(I,MPAIR+1)
C
          C(I,MPAIR  ) = ROT1
          C(I,MPAIR+1) = ROT2
        ENDDO
C
      ENDDO
C
C     CALCULATE FRACTIONAL OCCUPATION FOR EACH SOLUTION VECTOR
C
C     LOOP OVER OCCUPIED ORBITALS
      DO IOCC=1,IBND+IVIR
C
C       IGNORE NEGATIVE SPECTRUM
        MOCC = IOCC + NSHIFT
C
C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
        DO I=1,NDIM-NSHIFT
          IS = I+NSHIFT
          ICNT = LABICN(I)
          IKQN = LABKQN(I)
          IMQN = LABMQN(I)
          IF(IKQN.LT.0) THEN
            IKAP =-2*IKQN-1
          ELSE
            IKAP = 2*IKQN
          ENDIF
          IF(IMQN.LT.0) THEN
            IMV = IABS(IMQN)
          ELSE
            IMV = IMQN+1
          ENDIF
C
          DO J=1,NDIM-NSHIFT
            JS = J+NSHIFT
            JCNT = LABICN(J)
            JKQN = LABKQN(J)
            JMQN = LABMQN(J)
C
C           LARGE AND SMALL CONTRIBUTIONS
            TMP = DREAL(DCONJG(C(I ,MOCC))*C(J ,MOCC)*OVAP(I ,J ))
     &          + DREAL(DCONJG(C(IS,MOCC))*C(JS,MOCC)*OVAP(IS,JS))
C
C           DECIDE WHERE TO PUT CONTRIBUTION
            IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
              FRAC(IOCC,ICNT,IKAP,IMV) = FRAC(IOCC,ICNT,IKAP,IMV) + TMP
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     IDENTIFY CONVENTIONAL DIRAC QUANTUM NUMBERS BASED ON FRAC.
C
C     LOOP OVER POSITIVE ENERGY SPECTRUM IN PAIRS
      DO IOCC=1,NDIM-NSHIFT
C
C       SEARCH FOR HIGHEST POPULATED ATOMIC STATE
        PLTN = 0.0D0
        DO ICNT=1,NCNT
          DO IKAP=1,NKAP(ICNT)
            IKQN = KVALS(IKAP,ICNT)
            NMV  = 2*IABS(IKQN)
            DO IMV=1,NMV
              IF(FRAC(IOCC,ICNT,IKAP,IMV).GT.PLTN) THEN
                PLTN = FRAC(IOCC,ICNT,IKAP,IMV)
                KCNT = ICNT
                KKQN = IKQN
                KKAP = IKAP
                KMV  = IMV
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        NPR(KCNT,KKAP,KMV) = NPR(KCNT,KKAP,KMV)+1
C
C       APPLY DIRAC LABELS ACCORDING TO HIGHEST POPULATED STATE
        NQNLST(IOCC) = NPR(KCNT,KKAP,KMV)
        ICNLST(IOCC) = KCNT
        KQNLST(IOCC) = KKQN
        POPLST(IOCC) = FRAC(IOCC,KCNT,KKAP,KMV)
        IF(MOD(KMV,2).EQ.1) THEN
          MQNLST(IOCC) =-KMV
        ELSE
          MQNLST(IOCC) = KMV-1
        ENDIF
C
C     END LOOP OVER ORBITALS
      ENDDO
C
C     SORTING: ORGANISE POSITIVE-ENERGY SOLUTIONS IN MQN PAIRS
C
      IF(NCNT.EQ.1) THEN
C
C       LOOP OVER ALL STATES
        DO IOCC=1,NDIM-NSHIFT
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MOCC = IOCC+NSHIFT
C
C         IDENTIFY KQN OF STATE
          IKQN = KQNLST(IOCC)
C
C         FOR THIS KQN VALUE, SEARCH NEXT 2*|KQN| ENTRIES AND ORDER
C
        ENDDO
C
      ELSEIF(NCNT.GT.1) THEN
C
C       LOOP OVER PAIRS OF STATES
        DO IPAIR=1,NDIM-NSHIFT,2
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MPAIR = IPAIR+NSHIFT
C
C         NO NEED TO SWAP IF MQN OF THE FIRST STATE IS NEGATIVE
          IF(MQNLST(IPAIR).LT.0) GOTO 100
C
C         SWAP EIGENVALUES, EXPANSION COEFFICIENTS AND MQN VALUES
          ETEMP          = EIGEN(MPAIR+1)
          EIGEN(MPAIR+1) = EIGEN(MPAIR  )
          EIGEN(MPAIR  ) = ETEMP
C
          DO I=1,NDIM
            CTEMP        = C(I,MPAIR+1)
            C(I,MPAIR+1) = C(I,MPAIR  )
            C(I,MPAIR  ) = CTEMP
          ENDDO
C
          MTEMP           = MQNLST(IPAIR+1)
          MQNLST(IPAIR+1) = MQNLST(IPAIR  )
          MQNLST(IPAIR  ) = MTEMP
C
          PTEMP           = POPLST(IPAIR+1)
          POPLST(IPAIR+1) = POPLST(IPAIR  )
          POPLST(IPAIR  ) = PTEMP
C
C         SKIP POINT FOR ALREADY-SORTED PAIRS
100       CONTINUE
C
        ENDDO
C
      ENDIF
C
C     PRINT TITLE TO TERMINAL/FILE
20    FORMAT(1X,'Orb.',2X,'Center',4X,'Term sym.',3X,'m_j',14X,
     &                                    'Energy (au)',6X,'Population')
21    FORMAT(1X,I3,2X,I2,' (',A,')',4X,I2,A,'_',I1,'/2',4X,I2,'/2',7X,
     &                                                  F18.12,6X,F10.8)
C
      WRITE(6,20)
      WRITE(7,20)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     SUMMARISE RESULTS
      DO IOCC=1,IBND+IVIR
C
        MOCC = IOCC+NSHIFT
C
        ICNT = ICNLST(IOCC)
        INQN = NQNLST(IOCC)
        IKQN = KQNLST(IOCC)
        IMQN = MQNLST(IOCC)
        ELA  = ELMNT(IZNUC(ICNT))
        IF(IKQN.LT.0) THEN
          ILQN =-IKQN-1
        ELSE
          ILQN = IKQN
        ENDIF
        CHL  = ELLTERM(ILQN)
        IJQN = 2*IABS(IKQN)-1

        IF(IOCC.LE.IBND) THEN
          PLTN = POPLST(IOCC)
        ELSE
          PLTN = 0.0D0
        ENDIF
C
        IF(HMLTN.EQ.'NORL') THEN
          PLTN = 0.5D0*PLTN
        ENDIF
C
C       OUTPUT TO TERMINAL
        WRITE(6,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGEN(MOCC),PLTN
        WRITE(7,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGEN(MOCC),PLTN
        IF(IOCC.EQ.IBND.AND.IVIR.NE.0) THEN
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF
C
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      FUNCTION ELLTERM(L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE LL       LL     TTTTTTTT EEEEEEEE RRRRRRR  MM       MM    C
C   EE       LL       LL        TT    EE       RR    RR MMM     MMM    C
C   EE       LL       LL        TT    EE       RR    RR MMMM   MMMM    C
C   EEEEEE   LL       LL        TT    EEEEEE   RR    RR MM MM MM MM    C
C   EE       LL       LL        TT    EE       RRRRRRR  MM  MMM  MM    C
C   EE       LL       LL        TT    EE       RR    RR MM   M   MM    C
C   EEEEEEEE LLLLLLLL LLLLLLLL  TT    EEEEEEEE RR    RR MM       MM    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELLTERM(L) EVALUATES A CHARACTER CORRESPONDING TO TERM SYMBOL L.    C
C**********************************************************************C
C
      CHARACTER*1 ELLTERM
C
      IF(L.EQ.0) THEN
        ELLTERM = 's'
      ELSEIF(L.EQ.1) THEN
        ELLTERM = 'p'
      ELSEIF(L.EQ.2) THEN
        ELLTERM = 'd'
      ELSEIF(L.EQ.3) THEN
        ELLTERM = 'f'
      ELSEIF(L.EQ.4) THEN
        ELLTERM = 'g'
      ELSEIF(L.EQ.5) THEN
        ELLTERM = 'h'
      ELSEIF(L.EQ.6) THEN
        ELLTERM = 'i'
      ELSEIF(L.EQ.7) THEN
        ELLTERM = 'j'
      ELSEIF(L.EQ.8) THEN
        ELLTERM = 'k'
      ELSEIF(L.EQ.9) THEN
        ELLTERM = 'l'
      ELSEIF(L.EQ.10) THEN
        ELLTERM = 'm'
      ELSEIF(L.EQ.11) THEN
        ELLTERM = 'n'
      ELSEIF(L.EQ.12) THEN
        ELLTERM = 'o'
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ROTATE(XYZ,NCNT,ALPHA,BETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          RRRRRRR   OOOOOO TTTTTTTT   AA   TTTTTTTT EEEEEEEE          C
C          RR    RR OO    OO   TT     AAAA     TT    EE                C
C          RR    RR OO    OO   TT    AA  AA    TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EEEEEE            C
C          RRRRRRR  OO    OO   TT   AAAAAAAA   TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EE                C
C          RR    RR  OOOOOO    TT   AA    AA   TT    EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ROTATE PERFORMS TWO ROTATIONS ON ALL ATOMIC CENTERS, FIRST SO THAT  C
C  Y DOES NOT CHANGE, AND THEN SO THAT Z DOES NOT CHANGE.              C
C**********************************************************************C
C
      DIMENSION XYZ(3,NCNT),V(3),W(3)
      DIMENSION AR(3,3),BR(3,3),RR(3,3)
C
C     INITIALISE MATRICES
      DO I=1,3
        DO J=1,3
          AR(I,J) = 0.0D0
          BR(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     FIX ALL VALUES OF Z AND ROTATE BY ALPHA
      AR(3,3) = 1.0D0
      AR(1,1) = DCOS(ALPHA)
      AR(2,2) = DCOS(ALPHA)
      AR(1,2) = DSIN(ALPHA)
      AR(2,1) =-DSIN(ALPHA)
C
C     FIX ALL VALUES OF Y AND ROTATE BY BETA
      BR(2,2) = 1.0D0
      BR(1,1) = DCOS(BETA)
      BR(3,3) = DCOS(BETA)
      BR(3,1) = DSIN(BETA)
      BR(1,3) =-DSIN(BETA)
C
C     EVALUATE OVERALL ROTATION MATRIX
      CALL MMPROD(BR,AR,RR,3)
C
C     ROTATE ALL VECTORS IN XYZ
      DO N=1,NCNT
        DO I=1,3
          V(I) = XYZ(I,N)
        ENDDO
        CALL MVPROD(RR,V,W,3)
        DO I=1,3
          XYZ(I,N) = W(I)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MMPROD(A,B,X,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM MM       MM PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD       C
C     MMM     MMM MMM     MMM PP    PP RR    RR OO    OO DD    DD      C
C     MMMM   MMMM MMMM   MMMM PP    PP RR    RR OO    OO DD    DD      C
C     MM MM MM MM MM MM MM MM PP    PP RR    RR OO    OO DD    DD      C
C     MM  MMM  MM MM  MMM  MM PPPPPPP  RRRRRRR  OO    OO DD    DD      C
C     MM   M   MM MM   M   MM PP       RR    RR OO    OO DD    DD      C
C     MM       MM MM       MM PP       RR    RR  OOOOOO  DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  MMPROD CALCULATES THE PRODUCT OF TWO SQUARE, DOUBLE-PRECISION       C
C  MATRIX ARRAYS OF DIMENSION N, AND OUTPUTS THE RESULT INTO X.        C
C**********************************************************************C
C
      DIMENSION A(N,N),B(N,N),X(N,N)
C
C     INITIALISE X MATRIX
      DO I=1,N
        DO J=1,N
          X(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          DO K=1,N
            X(I,J) = X(I,J) + A(I,K)*B(K,J)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MVPROD(A,V,W,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       MM       MM VV    VV PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD        C
C       MMM     MMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MMMM   MMMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM MM MM MM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM  MMM  MM  VV  VV  PPPPPPP  RRRRRRR  OO    OO DD    DD       C
C       MM   M   MM   VVVV   PP       RR    RR OO    OO DD    DD       C
C       MM       MM    VV    PP       RR    RR  OOOOOO  DDDDDDD        C
C                                                                      C
C -------------------------------------------------------------------- C
C  MVPROD CALCULATES THE PRODUCT OF A SQUARE MATRIX OF DIMENSION N     C
C  AND A VECTOR OF DIMENSION N, AND OUTPUTS THE RESULT INTO W.         C
C**********************************************************************C
C
      DIMENSION A(N,N),V(N),W(N)
C
C     INITIALISE W MATRIX
      DO I=1,N
        W(I) = 0.0D0
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          W(I) = W(I) + A(I,J)*V(J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION MS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          MM       MM  SSSSSS                         C
C                          MMM     MMM SS    SS                        C
C                          MMMM   MMMM SS                              C
C                          MM MM MM MM  SSSSSS                         C
C                          MM  MMM  MM       SS                        C
C                          MM   M   MM SS    SS                        C
C                          MM       MM  SSSSSS                         C
C                                                                      C
C -------------------------------------------------------------------- C
C   MS RETURNS A QUOTED TIME IN SECONDS USING 'MIN-SEC' FORMAT.        C
C**********************************************************************C
C
      CHARACTER*4 MINUTES
      CHARACTER*7 SECONDS
      CHARACTER*11 MS
C
C     INITIALISE COUNTERS
      NMIN = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PRINT THE MINUTE
      IF(NMIN.EQ.0) THEN
        WRITE(MINUTES,'(A)') '    '
      ELSE
        WRITE(MINUTES,'(I3,A)') NMIN,'m'
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F4.2,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F4.2,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(MS,'(A,A)') MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      FUNCTION HMS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                     HH    HH MM       MM  SSSSSS                     C
C                     HH    HH MMM     MMM SS    SS                    C
C                     HH    HH MMMM   MMMM SS                          C
C                     HHHHHHHH MM MM MM MM  SSSSSS                     C
C                     HH    HH MM  MMM  MM       SS                    C
C                     HH    HH MM   M   MM SS    SS                    C
C                     HH    HH MM       MM  SSSSSS                     C
C                                                                      C
C -------------------------------------------------------------------- C
C   HMS RETURNS A QUOTED TIME IN SECONDS USING 'HR-MIN-SEC' FORMAT.    C
C**********************************************************************C
C
      CHARACTER*4 HOURS,MINUTES
      CHARACTER*8 SECONDS
      CHARACTER*16 HMS
C
C     INITIALISE COUNTERS
      NMIN = 0
      NHRS = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0 <= NMIN < 60
      DO WHILE (NMIN.GE.60)
        NMIN = NMIN - 60
        NHRS = NHRS + 1
      ENDDO
C
C     PRINT THE HOUR
      IF(NHRS.EQ.0) THEN
        WRITE(HOURS,'(A)') '    '
      ELSE
        WRITE(HOURS,'(I3,A)') NHRS,'h'
      ENDIF
C
C     PRINT THE MINUTE
      IF(NHRS.EQ.0) THEN
        IF(NMIN.EQ.0) THEN
          WRITE(MINUTES,'(1X,A)') '   '
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ELSEIF(NHRS.NE.0) THEN
        IF(NMIN.LT.10) THEN
          WRITE(MINUTES,'(1X,I1,I1,A)') 0,NMIN,'m'
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F5.3,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F5.3,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(HMS,'(A,A,A)') HOURS//MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      SUBROUTINE TIMENOW(STAMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  TTTTTTTT IIII MM       MM EEEEEEEE NN    NN  OOOOOO  WW         WW  C
C     TT     II  MMM     MMM EE       NNN   NN OO    OO WW         WW  C
C     TT     II  MMMM   MMMM EE       NNNN  NN OO    OO WW         WW  C
C     TT     II  MM MM MM MM EEEEEE   NN NN NN OO    OO WW    W    WW  C
C     TT     II  MM  MMM  MM EE       NN  NNNN OO    OO WW   WWW   WW  C
C     TT     II  MM   M   MM EE       NN   NNN OO    OO  WW WW WW WW   C
C     TT    IIII MM       MM EEEEEEEE NN    NN  OOOOOO    WW     WW    C
C                                                                      C
C -------------------------------------------------------------------- C
C  TIMENOW CREATES A DATE STRING SPECIFYING CPU TIME WHEN CALLED.      C
C**********************************************************************C
C
      CHARACTER*5  ZONE
      CHARACTER*8  DATE
      CHARACTER*10 TIME
      CHARACTER*20 STAMP
C
      DIMENSION IVL(8)
C
C     CALL TIME AND DATE ROUTINE
      CALL DATE_AND_TIME(DATE,TIME,ZONE,IVL)
C
C     PRINT THE DAY
      IF(IVL(3).LT.10) THEN
        WRITE(STAMP,'(1X,I1,I1,A)') 0,IVL(3),'/'
      ELSE
        WRITE(STAMP,'(1X,I2,A)') IVL(3),'/'
      ENDIF
C
C     PRINT THE MONTH
      IF(IVL(2).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(2),'/'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(2),'/'
      ENDIF
C
C     PRINT THE YEAR
      WRITE(STAMP,'(A,I4)') TRIM(STAMP),IVL(1)
C
C     PRINT THE HOUR
      IF(IVL(5).LT.10) THEN
        WRITE(STAMP,'(A,A,I1,I1,A)') TRIM(STAMP),' ',0,IVL(5),':'
      ELSE
        WRITE(STAMP,'(A,A,I2,A)') TRIM(STAMP),' ',IVL(5),':'
      ENDIF
C
C     PRINT THE MINUTE
      IF(IVL(6).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(6),':'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(6),':'
      ENDIF
C
C     PRINT THE SECOND
      IF(IVL(7).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1)') TRIM(STAMP),0,IVL(7)
      ELSE
        WRITE(STAMP,'(A,I2)') TRIM(STAMP),IVL(7)
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] DENSTY0: GENERATES CLOSED- AND OPEN-SHELL MOLECULAR DENSITY.   C
C   [B] DENSTY: GENERATES CLOSED- AND OPEN-SHELL MOLECULAR DENSITY.    C
C   [C] LEVSHFT: APPLIES A LEVEL SHIFT TO OCCUPIED ORBITALS IN FOCK.   C
C   [D] ENERGIES: USE DENSITY MATRIX TO CALCULATE ENERGY TERMS.        C
C**********************************************************************C
C
C
      SUBROUTINE DENSTY0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    DDDDDDD  EEEEEEEE NN    NN  SSSSSS TTTTTTTT YY    YY  000000      C
C    DD    DD EE       NNN   NN SS    SS   TT    YY    YY 00   000     C
C    DD    DD EE       NNNN  NN SS         TT     YY  YY  00  0000     C
C    DD    DD EEEEEE   NN NN NN  SSSSSS    TT      YYYY   00 00 00     C
C    DD    DD EE       NN  NNNN       SS   TT       YY    0000  00     C
C    DD    DD EE       NN   NNN SS    SS   TT       YY    000   00     C
C    DDDDDDD  EEEEEEEE NN    NN  SSSSSS    TT       YY     000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSTY0 IS A STARTING DENSITY ROUTINE FOR USE ONLY WHEN INEW = 0.   C
C  THIS IS BECAUSE 'ATOMIC' CALCULATES AVERAGE OVER SHELL OCCUPANCIES. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      COMPLEX*16 SUM
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM),C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/OCPD/IOCPN(MDM),IOCCM0
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     CONSTRUCT THE CLOSED-SHELL AND TOTAL DENSITY ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,IOCCM0
            SUM = SUM + DCONJG(C(I,IOCC+NSHIFT))*C(J,IOCC+NSHIFT)
          ENDDO
          DENC(I,J) = SUM
          DENO(I,J) = 0.0D0
          DENT(I,J) = DENC(I,J) + DENO(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DENSTY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS TTTTTTTT YY    YY         C
C         DD    DD EE       NNN   NN SS    SS   TT    YY    YY         C
C         DD    DD EE       NNNN  NN SS         TT     YY  YY          C
C         DD    DD EEEEEE   NN NN NN  SSSSSS    TT      YYYY           C
C         DD    DD EE       NN  NNNN       SS   TT       YY            C
C         DD    DD EE       NN   NNN SS    SS   TT       YY            C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS    TT       YY            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSTY GENERATES DENSITY MATRICES FROM THE EXPANSION COEFFS C.      C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      COMPLEX*16 SUM
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM),C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     MAKE CLOSED-SHELL DENSITY AND EMPTY OPEN-SHELL DENSITY (RSCF 81)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NCLS
            ICL = ICLS(IOCC)
            SUM = SUM +     DCONJG(C(I,ICL+NSHIFT))*C(J,ICL+NSHIFT)
          ENDDO
          DENC(I,J) = SUM
          DENT(I,J) = DENC(I,J)
          DENO(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
      IF(NOPN.EQ.0) GOTO 100
C
C     MAKE THE OPEN-SHELL DENSITY (RSCF 82)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NOPN
            IOP = IOPN(IOCC)
            SUM = SUM + FOPN*DCONJG(C(I,IOP+NSHIFT))*C(J,IOP+NSHIFT)
          ENDDO
          DENO(I,J) = SUM
          DENT(I,J) = DENT(I,J) + DENO(I,J)
        ENDDO
      ENDDO
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE LEVSHFT(SHLV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   LL       EEEEEEEE VV      VV  SSSSSS  HH    HH FFFFFFFF TTTTTTTT   C
C   LL       EE       VV      VV SS    SS HH    HH FF          TT      C
C   LL       EE       VV      VV SS       HH    HH FF          TT      C
C   LL       EEEEEE    VV    VV   SSSSSS  HHHHHHHH FFFFFF      TT      C
C   LL       EE         VV  VV         SS HH    HH FF          TT      C
C   LL       EE          VVVV    SS    SS HH    HH FF          TT      C
C   LLLLLLLL EEEEEEEE     VV      SSSSSS  HH    HH FF          TT      C
C                                                                      C
C -------------------------------------------------------------------- C
C  LEVSHFT APPLIES A LEVEL SHIFT OF SHLV TO UNOCCUPIED ORBITALS IN THE C
C  FOCK MATRIX.                                                        C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      COMPLEX*16 C(MDM,MDM),A(MDM),SUM
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     LOOP OVER ALL NON-OCCUPIED POSITIVE-ENERGY (I.E., VIRTUAL) OCCS
      DO IVIR=NSHIFT+NOCC+1,NDIM
C
C       LIST OF FOCK ADDRESSES WITH 'I' WITH AN AMOUNT FROM EACH IVIR
        DO I=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO J=1,NDIM
            SUM = SUM + OVAP(I,J)*C(J,IVIR)
          ENDDO
          A(I) = SUM
        ENDDO
C
C       ADD A LEVEL SHIFT'S WORTH OF INTERACTION ENERGY TO ALL FOCK(I,J)
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = FOCK(I,J) + SHLV*A(I)*DCONJG(A(J))
          ENDDO
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ENERGIES
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE NN    NN EEEEEEEE RRRRRRR   GGGGGG IIII EEEEEEEE SSSSSS   C
C   EE       NNN   NN EE       RR    RR GG    GG II  EE      SS    SS  C
C   EE       NNNN  NN EE       RR    RR GG       II  EE      SS        C
C   EEEEEE   NN NN NN EEEEEE   RR    RR GG       II  EEEEEE   SSSSSS   C
C   EE       NN  NNNN EE       RRRRRRR  GG   GGG II  EE            SS  C
C   EE       NN   NNN EE       RR    RR GG    GG II  EE      SS    SS  C
C   EEEEEEEE NN    NN EEEEEEEE RR    RR  GGGGGG IIII EEEEEEEE SSSSSS   C
C                                                                      C
C -------------------------------------------------------------------- C
C  ENERGIES CALCULATES INTERACTION ENERGIES OF THE CURRENT DENSITY     C
C  MATRIX OVER OCCUPIED SPINORS WITH THE MATRIX REP OF OPERATORS.      C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 ETMP(12)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE MOLECULAR ENERGY COUNTERS
      DO N=1,12
        ETMP(N) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP( 1) = ETMP( 1) +       DENT(I,J)*HNUC(I,J)
          ETMP( 2) = ETMP( 2) +       DENT(I,J)*HKIN(I,J)
          ETMP( 3) = ETMP( 3) +       DENT(I,J)*VUEH(I,J)
          ETMP( 4) = ETMP( 4) + 0.5D0*DENT(I,J)*GDIR(I,J)
          ETMP( 5) = ETMP( 5) + 0.5D0*DENT(I,J)*GXCH(I,J)
          ETMP( 6) = ETMP( 6) + 0.5D0*DENT(I,J)*BDIR(I,J)
          ETMP( 7) = ETMP( 7) + 0.5D0*DENT(I,J)*BXCH(I,J)
          ETMP( 8) = ETMP( 8) - 0.5D0*DENO(I,J)*QDIR(I,J)
     &                        + 0.5D0*DENT(I,J)*QDIR(I,J)*(FOPN-1.0D0)
          ETMP( 9) = ETMP( 9) - 0.5D0*DENO(I,J)*QXCH(I,J)
     &                        + 0.5D0*DENT(I,J)*QXCH(I,J)*(FOPN-1.0D0)
          ETMP(12) = ETMP(12) +       DENT(I,J)*FOCK(I,J)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EHNC = DREAL(ETMP( 1))
      EHKN = DREAL(ETMP( 2))
      EUEH = DREAL(ETMP( 3))
      EGDR = DREAL(ETMP( 4))
      EGXC = DREAL(ETMP( 5))
      EBDR = DREAL(ETMP( 6))
      EBXC = DREAL(ETMP( 7))
      EQDR = DREAL(ETMP( 8))
      EQXC = DREAL(ETMP( 9))
      EMDR = DREAL(ETMP(10))
      EMXC = DREAL(ETMP(11))
C
C     ADD ALL CONTRIBUTIONS TO THE TOTAL ENERGY
      EONE = EHNC+EHKN
      ECLG = EGDR-EGXC
      ECLQ = EQDR-EQXC
      EBRG = EBDR-EBXC
      EBRQ = EMDR-EMXC
      ETOT = ENUC+EONE+EUEH+ECLG+ECLQ+EBRG
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [4] ATOMIC HARTREE-FOCK: SINGLE-CENTER SCF CALCULATIONS.           C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] ATOMIC: MAIN ROUTNE FOR ATOMIC SCF CALCULATIONS.               C
C   [B] HFSCF0: ATOMIC SCF ROUTINE (AVERAGE OF CONFIGURATION MODEL.)   C
C   [C] OVRLP0: GENERATES ATOMIC OVERLAP MATRIX.                       C
C   [D] ONEEL0: GENERATES ATOMIC ONE-ELECTRON MATRIX (ALL HAMILS).     C
C   [E] BNUCINT0: CALCULATES AN ATOMIC BARE NUCLEUS INTEGRAL.          C
C   [F] COULOMB0: ATOMIC MEAN-FIELD COULOMB MATRIX (BETA INTEGRALS).   C
C   [G] BREIT0: CONSTRUCTION OF ATOMIC BREIT INTERACTION MATRIX.       C
C   [H] KLSET: ADDRESSES AND 'KL' EXPONENT POWERS FOR ATOMIC ERI/BII.  C
C   [I] BETACLM: SET OF BETA INTEGRALS FOR ATOMIC ERIS.                C
C   [J] BETABRT: SET OF BETA INTEGRALS FOR ATOMIC BIIS.                C
C   [K] ERI0: BATCH OF ATOMIC COULOMB INTERACTION INTEGRALS.           C
C   [L] BII0: BATCH OF ATOMIC BREIT INTERACTION INTEGRALS.             C
C   [M] ANGCLM0: ATOMIC ANGULAR COULOMB COEFFICIENTS.                  C
C   [N] ANGBRT0: ATOMIC ANGULAR BREIT COEFFICIENTS.                    C
C   [O] BRCOEF0: EXCHANGE MAGNETIC COEFFICIENTS FOR ANGBRT0.           C
C   [P] ABC000: 3-J SYMBOLS FOR USE IN NON-REL ANGCLM0 (LS COUPLING).  C
C   [Q] SYM3JSQ: 3-J SYMBOLS FOR USE IN ANGCLM0 AND ANGBRT0 (JJ).      C
C   [R] UEHLING0: GENERATES ATOMIC UEHLING INTERACTION MATRIX.         C
C   [S] UEHINT0: CALCULATES AN ATOMIC UEHLING INTEGRAL.                C
C   [T] RNORM0: GENERATE BATCHES OF ALL TT' NORMALISATION FACTORS.     C
C   [U] GAMGEN: LIST OF GAMMA FUNCTIONS FOR INT AND HALF-INT ARGS.     C
C   [V] FACTRLS: LIST OF FACTORIALS AND DOUBLE FACTORIALS.             C
C**********************************************************************C
C
C
      SUBROUTINE ATOMIC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             AA   TTTTTTTT OOOOOO  MM       MM IIII CCCCCC            C
C            AAAA     TT   OO    OO MMM     MMM  II CC    CC           C
C           AA  AA    TT   OO    OO MMMM   MMMM  II CC                 C
C          AA    AA   TT   OO    OO MM MM MM MM  II CC                 C
C          AAAAAAAA   TT   OO    OO MM  MMM  MM  II CC                 C
C          AA    AA   TT   OO    OO MM   M   MM  II CC    CC           C
C          AA    AA   TT    OOOOOO  MM       MM IIII CCCCCC            C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  ATOMIC PERFORMS A SINGLE-CENTER SCF PROCEDURE FOR EACH ATOM IN THE  C
C  MOLECULE AND ASSEMBLES AN INITIAL COEFFICIENT MATRIX.               C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 C(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/EIGN/EIGEN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/OCPD/IOCPN(MDM),IOCCM0
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TATM/TTOT
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',26),'ATOMIC HARTREE-FOCK SCF'
      WRITE(7, *) REPEAT(' ',26),'ATOMIC HARTREE-FOCK SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     SPECIAL EXIT FOR ONE-ELECTRON PROBLEMS
      IF(NOELEC.LE.1.AND.NCNT.NE.1) THEN
        WRITE(6, *) 'This is a one-electron problem. Skip ATOMIC.'
        WRITE(7, *) 'This is a one-electron problem. Skip ATOMIC.'
        RETURN
      ENDIF
C
C     RECORD TIME AT START OF ATOMIC CALCULATION
      CALL CPU_TIME(TDUM)
C
C     INITIALISE MOLECULAR MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          C(I,J)    = DCMPLX(0.0D0,0.0D0)
          OVAP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
C
C     INITIALISE OCCUPATION COUNTER
      IOCCM0 = 0
C
C     HARTREE-FOCK SCF PROCEDURE FOR EACH ISOLATED ATOM
      DO ICNT=1,NCNT
        CALL HFSCF0(ICNT)
      ENDDO
C
C     SAVE EIGENVECTORS TO OUTPUT FILE
      OPEN(UNIT=8,FILE=TRIM(WFNFL),STATUS='UNKNOWN')
      REWIND(UNIT=10)
      DO I=1,NDIM
        WRITE(8, *) EIGEN(I),(C(J,I),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
c
C     GENERATE DENSITY MATRIX
      CALL DENSTY0
C
C     TIME TAKEN FOR ATOMIC CALCULATION
      CALL CPU_TIME(TTOT)
      TTOT = TTOT - TDUM
C
C     DATE AND TIME AT END OF ITERATION
      CALL TIMENOW(STAMP)
C
C     ATOMIC SCF SUMMARY HEADER
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT(' ',27),'Atomic SCF summary'
      WRITE(7, *) REPEAT(' ',27),'Atomic SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     PRODUCE SPECTRUM SUMMARY AND INCLUDE FIRST 6 VIRTUAL STATES
      CALL SPECTRM(IOCCM0,0)
C
C     MOLECULAR ENERGIES
20    FORMAT(1X,A,31X,F21.12)
      WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) 'Source',REPEAT(' ',60),'Energy'
      WRITE(7, *) 'Source',REPEAT(' ',60),'Energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Nucleus-nucleus  (N)',ENUC
      WRITE(7,20) 'Nucleus-nucleus  (N)',ENUC
      WRITE(6,20) 'One-electron     (H)',EONE
      WRITE(7,20) 'One-electron     (H)',EONE
      IF(HMLTN.EQ.'BARE') GOTO 202
      WRITE(6,20) 'Coulomb (closed) (G)',ECLG
      WRITE(7,20) 'Coulomb (closed) (G)',ECLG
      IF(HMLTN.EQ.'NORL'.OR.HMLTN.EQ.'DHFR') GOTO 202
      WRITE(6,20) 'Breit (closed)   (B)',EBRG
      WRITE(7,20) 'Breit (closed)   (B)',EBRG
202   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Molecule total   (F)',ETOT
      WRITE(7,20) 'Molecule total   (F)',ETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     CALCULATION TIME
30    FORMAT(1X,A,26X,A)
      WRITE(6,30) 'Total atomic SCF time         ',HMS(TTOT)
      WRITE(7,30) 'Total atomic SCF time         ',HMS(TTOT)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Time at end of calculation',STAMP
      WRITE(7,30) 'Time at end of calculation',STAMP
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE HFSCF0(ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          HH    HH FFFFFFFF SSSSSS   CCCCCC  FFFFFFFF 000000          C
C          HH    HH FF      SS    SS CC    CC FF      00   000         C
C          HH    HH FF      SS       CC       FF      00  0000         C
C          HHHHHHHH FFFFFF   SSSSSS  CC       FFFFFF  00 00 00         C
C          HH    HH FF            SS CC       FF      0000  00         C
C          HH    HH FF      SS    SS CC    CC FF      000   00         C
C          HH    HH FF       SSSSSS   CCCCCC  FF       000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  HFSCF PERFORMS AN ATOMIC SINGLE-DETERMINANT ITERATIVE SELF-         C
C  CONSISTENT FIELD PROCEDURE OVER THE USER-SPECIFIED HAMILTONIAN.     C
C  USES THE CLOSED-SHELL AVERAGE OF CONFIGURATION MODEL, WITH SUBSHELL C
C  OCCUPATIONS DETERMINED EITHER MANUALLY OR BY THE AUFBAU ROUTINE.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT - ATOMIC CENTER INDEX                                        C
C -------------------------------------------------------------------- C
C  DFNOTE: UNFINISHED -- BREIT INTERACTION STILL A MESS.               C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MNU=MKP+1,
     &                                              LWK=128*MBS,MIT=100)
C
      CHARACTER*1 ELLTERM,QSGN
      CHARACTER*2 ELMNT(120),ELNM
      CHARACTER*4 HMLTN
      CHARACTER*8 ZWRT,QWRT,EWRT
      CHARACTER*80 TITLE
C
      DIMENSION BMAT(MDM,MDM)
C
      DIMENSION QE(MKP),QA(MKP),NORB(MKP,12),NUMOCC(MKP)
      DIMENSION W1(2*MBS),W2(2*MBS),T(LWK)
      DIMENSION O1(2*MBS,2*MBS),H1(2*MBS,2*MBS),U1(2*MBS,2*MBS),
     &          O2(2*MBS,2*MBS),H2(2*MBS,2*MBS),U2(2*MBS,2*MBS)
      DIMENSION DENLL(MB2,2*MKP+1),DFNLL(MB2,2*MKP+1),
     &          DENSL(MB2,2*MKP+1),DFNSL(MB2,2*MKP+1),
     &          DENSS(MB2,2*MKP+1),DFNSS(MB2,2*MKP+1)
C
      COMPLEX*16 C(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/ANGL/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4),
     &            NUS(MNU),NUNUM,NUI,NUF
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BSXP/EXLA(MBS),EXLB(MBS)
      COMMON/COEF/C
      COMMON/EIGN/EIGEN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/FILL/NCNF(MCT,MKP,MKP+1),NLVL(MCT,MKP),IFILL(MCT)
      COMMON/GAOC/G11(2*MBS,2*MBS),G21(2*MBS,2*MBS),DEN1(MB2,3),
     &            G12(2*MBS,2*MBS),G22(2*MBS,2*MBS),DEN2(MB2,3),
     &            B11(2*MBS,2*MBS),B21(2*MBS,2*MBS),
     &            B12(2*MBS,2*MBS),B22(2*MBS,2*MBS)
      COMMON/MDLV/ELMNT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/OCPD/IOCPN(MDM),IOCCM0
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C      COMMON/RANG/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
C      COMMON/RBIJ/EIJ(MAB),RNIJ(3),EI,EJ
C      COMMON/RBKL/EK(MB2),EL(MB2),RNKL(MB2,4),
C     &            EIK(MB2,MAB),EJL(MB2,MAB),EKL(MB2,MAB)
C      COMMON/RBQN/NBASA,NBASB,LQNA,LQNB,MAXM
C      COMMON/BSXP/EXLA(MBS),EXLB(MBS)
C      COMMON/RMAT/B1(MB2,MAB,MAB),B2(MB2,MAB,MAB),B3(MB2,MAB,MAB),
C     &            B4(MB2,MAB,MAB)
C      COMMON/RNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     EMPTY BMAT ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          BMAT(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     CONVERGENCE TOLERANCE VALUE
      IF(HMLTN.EQ.'NORL') THEN
        ENRGTOL = 5.0D-12
      ELSE
        ENRGTOL = 5.0D-13
      ENDIF
C
C     IMPORT ATOMIC CHARGE DETAILS
      IZN  = IZNUC(ICNT)
      ZCRG = ZNUC(ICNT)
      ELNM = ELMNT(IZN)
      ICRG = IQNUC(ICNT)
      MLQN = LMAX(ICNT)
C
C     CONVERT IZN AND ICRG TO STRINGS AND WRITE TITLE
      IF(IZN.LT.10) THEN
        WRITE(ZWRT,'(A,I1)') 'Z = ',IZN
      ELSEIF(IZN.LT.100) THEN
        WRITE(ZWRT,'(A,I2)') 'Z = ',IZN
      ELSE
        WRITE(ZWRT,'(A,I3)') 'Z = ',IZN
      ENDIF
C
      IF(ICRG.LT.10) THEN
        WRITE(QWRT,'(A,I2)') 'Q = ',ICRG
      ELSEIF(IZN.LT.100) THEN
        WRITE(QWRT,'(A,I3)') 'Q = ',ICRG
      ELSE
        WRITE(QWRT,'(A,I4)') 'Q = ',ICRG
      ENDIF
C
      IF(ICRG.GT.0) THEN
        QSGN = '+'
      ELSEIF(ICRG.LT.0) THEN
        QSGN = '-'
      ENDIF
C
      ICMD = IABS(ICRG)
      IF(ICRG.EQ.0) THEN
        WRITE(EWRT,'(A,A,A)') '(',TRIM(ELNM),')'
      ELSEIF(ICMD.EQ.1) THEN
        WRITE(EWRT,'(A,A,A,A,A)') '(',TRIM(ELNM),'^',QSGN,')'
      ELSEIF(ICMD.LT.10) THEN
        WRITE(EWRT,'(A,A,A,I1,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSEIF(ICMD.LT.100) THEN
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSE
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ENDIF
C
C     PRINT TITLE SUMMARY FOR THIS ATOM
20    FORMAT(17X,'Center',I3,':',3X,A,3X,A,3X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) ICNT,ZWRT,QWRT,EWRT
      WRITE(7,20) ICNT,ZWRT,QWRT,EWRT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
      IF(IFILL(ICNT).EQ.0) THEN
        CALL AUFBAU(IZN,ICRG,NORB,NUMOCC,LMXCONF)
      ELSE
        LMXCONF = LMAX(ICNT)
        DO LQN=1,LMXCONF+1
          NUMOCC(LQN) = NLVL(ICNT,LQN)
          DO N=1,NLVL(ICNT,LQN)
            NORB(LQN,N) = NCNF(ICNT,LQN,N)
          ENDDO
        ENDDO
      ENDIF
C
C     IDENTIFY THE HIGHEST OCCUPIED SHELL
      NMAX = 1
      DO LQN=1,LMXCONF+1
        IF(NUMOCC(LQN).GT.NMAX) THEN
          NMAX = NUMOCC(LQN)
        ENDIF
      ENDDO
C
C     CHECK WHETHER THERE ARE SUFFICIENT BASIS FUNCTION TYPES
      IF(MLQN.LT.LMXCONF) THEN
        WRITE(6, *) 'In HFSCF0: insufficient angular types in basis.'
        WRITE(7, *) 'In HFSCF0: insufficient angular types in basis.'
        WRITE(6, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        WRITE(7, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        STOP
      ENDIF
C
C     PRINT ATOMIC CONFIGURATION
30    FORMAT(1X,A,2X,A,1X,'|',2X'NSHELL ',12(2X,I2))
31    FORMAT(1X,'LQN = ',I1,3X,I2,2X,'|'1X,' OCC(',A,'):',A,12(2X,I2))
C
      IF(IFILL(ICNT).EQ.0) THEN
        WRITE(6,30) 'Aufbau:','#fns',(N,N=1,12)
        WRITE(7,30) 'Aufbau:','#fns',(N,N=1,12)
      ELSE
        WRITE(6,30) 'Manual:','#fns',(N,N=1,12)
        WRITE(7,30) 'Manual:','#fns',(N,N=1,12)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LQN=0,LMAX(ICNT)
        WRITE(6,31) LQN,NFUNCT(LQN+1,ICNT),ELLTERM(LQN),
     &               REPEAT(' ',LQN*4),(NORB(LQN+1,J),J=1,NUMOCC(LQN+1))
        WRITE(7,31) LQN,NFUNCT(LQN+1,ICNT),ELLTERM(LQN),
     &               REPEAT(' ',LQN*4),(NORB(LQN+1,J),J=1,NUMOCC(LQN+1))
      ENDDO
C
C     RESULTS FOR EACH ITERATION
40    FORMAT(1X,A,10X,A,10X,A,13X,A,11X,A)
41    FORMAT(I3,2X,F15.6,2X,F15.6,2X,F18.6,4X,ES12.5)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(7,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     IMPORT NUCLEAR RADIUS FOR THIS CENTER
      PNUC = CNUC(ICNT)
C
C     INITIALISE A STORAGE BIN FOR PREVIOUS ATOMIC ENERGY
      EPRV = 0.0D0
C
C**********************************************************************C
C     ZERO-BODY PROBLEM: IZN-ICRG = 0. (NO ELECTRONS AROUND CENTER.)   C
C**********************************************************************C
C
      IF(IZN.EQ.ICRG) THEN
C
C       NO OCCUPYING ELECTRON -> NO EIGENVALUE NEEDED
C
        EH = 0.0D0
        EG = 0.0D0
        EB = 0.0D0
        ENEW = EH-EG-EB

        WRITE(6,41) 1,EH,EG,ENEW,1.0D0
        WRITE(7,41) 1,EH,EG,ENEW,1.0D0
C
        GOTO 1001
C
C**********************************************************************C
C     ONE-BODY PROBLEM: IZN-ICRG = 1. (NO COULOMB ENERGY.)             C
C**********************************************************************C
C
      ELSEIF(IZN-ICRG.EQ.1) THEN
C
C       IMPORT ORDERED ELECTRON OCCUPATION NUMBER
        IOCCML = IOCCM0
C
C       GROUND STATE OF SINGLY-OCCUPIED ATOM: LQNA = 0
        LQNA = 0
C
C       EFFECTIVE AND AVERAGE OCCUPATION NUMBERS FOR THIS LQNA ORBITAL
C       A CLOSED SUBSHELL (NSHELL,LQNA) CONTAINS NCLS ELECTRONS
        NCLS = 4*LQNA+2
C
C       CORRESPONDING RELATIVISTIC QUANTUM NUMBER
        KAPA2 =-LQNA-1
        IF(HMLTN.EQ.'NORL') THEN
          RK2A2 = DFLOAT(NCLS)
        ELSE
          RK2A2 = DFLOAT(2*IABS(KAPA2))
        ENDIF
C
C       IMPORT BASIS FUNCTION EXPONENTS
        NBASA = NFUNCT(LQNA+1,ICNT)
        DO IBAS=1,NBASA
          EXLA(IBAS) = EXPSET(IBAS,LQNA+1,ICNT)
        ENDDO
C
C       MATRIX DIMENSIONS FOR THIS LQNA BLOCK
        IF(HMLTN.EQ.'NORL') THEN
          NBLC = 0
        ELSE
          NBLC = NBASA
        ENDIF
        NMAT = NBASA+NBLC
C
C       GENERATE OVERLAP AND BARE DIRAC MATRICES
        CALL OVRLP0(O2,EXLA,     KAPA2,NBASA)
        CALL ONEEL0(H2,EXLA,ZCRG,KAPA2,NBASA)
C
C       ATOMIC UEHLING INTERACTION
        IF(HMLTN.EQ.'DHFQ') THEN
C
C         GENERATE UEHLING MATRIX ELEMENTS
          CALL UEHLING0(U2,EXLA,ZCRG,KAPA2,NBASA)
C
C         ADD UEHLING MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
          DO IBAS=1,NMAT
            DO JBAS=1,NMAT
              H2(IBAS,JBAS) = H2(IBAS,JBAS) + U2(IBAS,JBAS)
            ENDDO
          ENDDO
C
        ENDIF
C
C       DIAGONALISE MATRIX (THIS NEEDS LAPACK LIBRARY)
        CALL DSYGV(1,'V','U',NMAT,H2,2*MBS,O2,2*MBS,W2,T,LWK,INFO)
        IF(INFO.NE.0) THEN
          WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
          WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
          STOP
        ENDIF
C
C       COEFFICIENT MATRIX ADDRESSES
        IL1 = LARGE(ICNT,2*LQNA+1,1)
        IL2 = LARGE(ICNT,2*LQNA+1,2)
        IS1 = IL1 + NSHIFT
        IS2 = IL2 + NSHIFT
C
C       EFFECTIVE OCCUPATION NUMBER
        QF = 1.0D0/DSQRT(2.0D0)
C
C       COPY INTO MASTER COEFFICIENT LIST
        DO IBAS=1,NBASA
C
C         LARGE COMPONENT OF KRAMERS PAIR
          CL = QF*H2(IBAS      ,NBLC+1)
          C(IL1+IBAS,IOCCML+NSHIFT+1) = DCMPLX(CL,0.0D0)
          C(IL2+IBAS,IOCCML+NSHIFT+2) = DCMPLX(CL,0.0D0)
C
C         SMALL COMPONENT OF KRAMERS PAIR
          IF(HMLTN.NE.'NORL') THEN
            CS = QF*H2(IBAS+NBLC,NBLC+1)
            C(IS1+IBAS,IOCCML+NSHIFT+1) = DCMPLX(CS,0.0D0)
            C(IS2+IBAS,IOCCML+NSHIFT+2) = DCMPLX(CS,0.0D0)
          ENDIF
C
        ENDDO
C
C       STORE LOWEST ENERGY EIGENVALUES TO MASTER LIST
        EIGEN(IOCCML+NSHIFT+1) = W2(NBLC+1)
        EIGEN(IOCCML+NSHIFT+2) = W2(NBLC+1)
C
C       INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
        IOCCML = IOCCML+2
C
C       ONE- AND TWO-BODY ENERGIES
        EH = W2(NBLC+1)
C
C       UEHLING INTERACTION ENERGIES FOR OCCUPIED ELECTRONS
        M = 0
        DO IBAS=1,NBASA
          DO JBAS=1,NBASA
            M = M+1
C
C           SMALL-COMPONENT ADDRESSES
            KBAS = IBAS+NBLC
            LBAS = JBAS+NBLC
C
C           ADD CONTRIBUTIONS TO UEHLING ENERGY
            EU = EU + U2(IBAS,JBAS)*H2(IBAS,NBLC+1)*H2(JBAS,NBLC+1)
            IF(HMLTN.NE.'NORL') THEN
              EU = EU + U2(KBAS,LBAS)*H2(KBAS,NBLC+1)*H2(LBAS,NBLC+1)
            ENDIF
C
          ENDDO
        ENDDO
C
        EG = 0.0D0
        EB = 0.0D0
        ENEW = EH
C
C       WRITE RESULT
        WRITE(6,41) 1,EH,0.0D0,ENEW,1.0D0
        WRITE(7,41) 1,EH,0.0D0,ENEW,1.0D0
C
C       UPDATE FOCK LABEL FOR OCCUPATION COUNTER
        IOCCM0 = IOCCML
C
C       EXIT TO CONVERGENCE
        GOTO 1001
C
      ENDIF
C
C**********************************************************************C
C     TWO-BODY PROBLEM: INTERACTING ELECTRONS. (TREAT WITH SCF.)       C
C -------------------------------------------------------------------- C
C     ENTER ITERATIVE SELF-CONSISTENT FIELD PROCEDURE (USE INDEX 1000) C
C**********************************************************************C
C
      DO 1000 ITER=1,MIT

C       INITIALISE ONE-BODY AND TWO-BODY ENERGY COUNTERS
        EH = 0.0D0
        EU = 0.0D0
        EG = 0.0D0
        EB = 0.0D0
C
C       INITIALISE ELECTRON OCCUPATION COUNTER
        IOCCML = IOCCM0
C
C**********************************************************************C
C     ONE-ELECTRON PART: LOOP OVER BASIS FUNCTIONS I,J (USE INDEX 100) C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO 100 LQNA=0,LMXCONF
C
C     RECORD LQNA VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
      NBASA = NFUNCT(LQNA+1,ICNT)
      DO IBAS=1,NBASA
        EXLA(IBAS) = EXPSET(IBAS,LQNA+1,ICNT)
      ENDDO
C
C     MATRIX DIMENSIONS FOR THIS LQNA BLOCK
      IF(HMLTN.EQ.'NORL') THEN
        NBLC = 0
      ELSE
        NBLC = NBASA
      ENDIF
      NMAT = NBASA+NBLC
C
C     EFFECTIVE AND AVERAGE OCCUPATION NUMBERS FOR THIS LQNA ORBITAL
C     A CLOSED SUBSHELL (NSHELL,LQNA) CONTAINS NCLS ELECTRONS
      NCLS = 4*LQNA+2
C
C     FOR EACH OCCUPIED NSHELL OF THIS LQNA CLASS
      DO IOCC=1,NUMOCC(LQNA+1)
C
C       NUMBER OF CHARGES IN THIS SUBSHELL (NSHELL,LQNA)
        NQ = NORB(LQNA+1,IOCC)
C
C       IF SUBSHELL IS CLOSED THERE IS NO FRACTIONAL OCCUPANCY
        IF(NQ.EQ.NCLS) THEN
          QE(IOCC) = 1.0D0
C       IF SUBSHELL IS OPEN, CONSTRUCT FRACTION (GRANT 6.6.24)
        ELSE
          QE(IOCC) = DFLOAT(NQ-1)/DFLOAT(NCLS-1)
        ENDIF
C
C       ACTUAL FRACTIONAL SUBSHELL OCCUPANCY
        IF(NQ.GT.0) THEN
          QA(IOCC) = DFLOAT(NQ)/DFLOAT(NCLS)
        ELSE
          QA(IOCC) = 0.0D0
        ENDIF
C
      ENDDO
C
C     POSITIVE KAPPA(A) CHOICE (APPLIES ONLY FOR LQNA > 0)
      IF(LQNA.EQ.0.OR.HMLTN.EQ.'NORL') GOTO 130

      KAPA1 = LQNA
      RK2A1 = DFLOAT(2*IABS(KAPA1))
C
C     GENERATE OVERLAP AND BARE DIRAC MATRICES
      CALL OVRLP0(O1,EXLA,     KAPA1,NBASA)
      CALL ONEEL0(H1,EXLA,ZCRG,KAPA1,NBASA)
C
C     ATOMIC UEHLING INTERACTION
      IF(HMLTN.EQ.'DHFQ') THEN
C
C       GENERATE UEHLING MATRIX ELEMENTS
        CALL UEHLING0(U1,EXLA,ZCRG,KAPA1,NBASA)
C
C       ADD UEHLING MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
        DO IBAS=1,NMAT
          DO JBAS=1,NMAT
            H1(IBAS,JBAS) = H1(IBAS,JBAS) + U1(IBAS,JBAS)
          ENDDO
        ENDDO
C
      ENDIF
C
130   CONTINUE
C
C     NEGATIVE KAPPA(A) CHOICE (APPLIES TO ALL LQNA VALUES)
      KAPA2 =-LQNA-1
      IF(HMLTN.EQ.'NORL') THEN
        RK2A2 = DFLOAT(NCLS)
      ELSE
        RK2A2 = DFLOAT(2*IABS(KAPA2))
      ENDIF
C
C     GENERATE OVERLAP AND BARE DIRAC MATRICES
      CALL OVRLP0(O2,EXLA,     KAPA2,NBASA)
      CALL ONEEL0(H2,EXLA,ZCRG,KAPA2,NBASA)
C
C     ATOMIC UEHLING INTERACTION
      IF(HMLTN.EQ.'DHFQ') THEN
C
C       GENERATE UEHLING MATRIX ELEMENTS
        CALL UEHLING0(U2,EXLA,ZCRG,KAPA2,NBASA)
C
C       ADD UEHLING MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
        DO IBAS=1,NMAT
          DO JBAS=1,NMAT
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + U2(IBAS,JBAS)
          ENDDO
        ENDDO
C
      ENDIF
C
C     SKIP SCF INTERACTIONS IN FIRST ITERATION
      IF(ITER.EQ.1) GOTO 150
C
C     INITIALISE RELEVANT COUNTERS AND ARRAYS
      RK2B1 = 0.0D0
      RK2B2 = 0.0D0
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
          G11(IBAS,JBAS) = 0.0D0
          G12(IBAS,JBAS) = 0.0D0
          G21(IBAS,JBAS) = 0.0D0
          G22(IBAS,JBAS) = 0.0D0
          B11(IBAS,JBAS) = 0.0D0
          B12(IBAS,JBAS) = 0.0D0
          B21(IBAS,JBAS) = 0.0D0
          B22(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     TWO-ELECTRON PART: LOOP OVER BASIS FUNCTIONS K,L (USE INDEX 200) C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO 200 LQNB=0,LMXCONF
C
C     RECORD LQNB VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
      NBASB = NFUNCT(LQNB+1,ICNT)
      DO JBAS=1,NBASB
        EXLB(JBAS) = EXPSET(JBAS,LQNB+1,ICNT)
      ENDDO
C
C     NUMBER OF BASIS FUNCTION OVERLAPS IN THIS BLOCK
      MAXM = NBASB*NBASB
C
C     POSITIVE KAPPA(B) CHOICE (APPLIES ONLY FOR LQNB > 0)
      IF(LQNB.EQ.0.OR.HMLTN.EQ.'NORL') GOTO 230
C
C     ANGULAR QUANTUM NUMBER AND DEGENERACY
      KAPB1 = LQNB
      RK2B1 = DFLOAT(2*IABS(KAPB1))
C
C     RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
      IF(LQNA.EQ.LQNB) THEN
        DO M=1,MAXM
          DEN1(M,1) = DENLL(M,2*LQNB  )
          DEN1(M,2) = DENSL(M,2*LQNB  )
          DEN1(M,3) = DENSS(M,2*LQNB  )
        ENDDO
      ELSEIF(LQNA.NE.LQNB) THEN
        DO M=1,MAXM
          DEN1(M,1) = DFNLL(M,2*LQNB  )
          DEN1(M,2) = DFNSL(M,2*LQNB  )
          DEN1(M,3) = DFNSS(M,2*LQNB  )
        ENDDO
      ENDIF
C
230   CONTINUE
C
C     NEGATIVE KAPPA(B) CHOICE (APPLIES TO ALL LQNB VALUES)
C
C     ANGULAR QUANTUM NUMBER AND DEGENERACY
      KAPB2 =-LQNB-1
      IF(HMLTN.EQ.'NORL') THEN
        RK2B2 = DFLOAT(4*LQNB+2)
      ELSE
        RK2B2 = DFLOAT(2*IABS(KAPB2))
      ENDIF
C
C     RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
      IF(LQNA.EQ.LQNB) THEN
        DO M=1,MAXM
          DEN2(M,1) = DENLL(M,2*LQNB+1)
          IF(HMLTN.NE.'NORL') THEN
            DEN2(M,2) = DENSL(M,2*LQNB+1)
            DEN2(M,3) = DENSS(M,2*LQNB+1)
          ENDIF
        ENDDO
      ELSEIF(LQNA.NE.LQNB) THEN
        DO M=1,MAXM
          DEN2(M,1) = DFNLL(M,2*LQNB+1)
          IF(HMLTN.NE.'NORL') THEN
            DEN2(M,2) = DFNSL(M,2*LQNB+1)
            DEN2(M,3) = DFNSS(M,2*LQNB+1)
          ENDIF
        ENDDO
      ENDIF
C
C**********************************************************************C
C     GENERATE ATOMIC MEAN-FIELD COULOMB MATRIX                        C
C**********************************************************************C
C
C     EVALUATE CLOSED-SHELL ELECTRON REPULSION ANGULAR INTEGRALS
      CALL ANGCLM0
C
C     GENERATE THE MEAN-FIELD ATOMIC COULOMB MATRIX OVER DENSITIES
      CALL COULOMB0
C
C     ADD COULOMB MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
C
          IF(HMLTN.EQ.'NORL') THEN
C         NON-RELATIVISTIC COULOMB MATRIX
C
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B2*G22(IBAS,JBAS)
C
          ELSE
C         RELATIVISTIC COULOMB MATRIX
C
            H1(IBAS,JBAS) = H1(IBAS,JBAS) + RK2B1*G11(IBAS,JBAS)
     &                                    + RK2B2*G12(IBAS,JBAS)
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B1*G21(IBAS,JBAS)
     &                                    + RK2B2*G22(IBAS,JBAS)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C     TWO-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
          IF(HMLTN.EQ.'NORL') THEN
C         NON-RELATIVISTIC COULOMB ENERGY
C
            EG = EG + RK2A2*RK2B2*G22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
          ELSE
C         RELATIVISTIC  COULOMB ENERGY
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBASA
            LBAS = JBAS+NBASA
C
C           LL BLOCK
            EG = EG
     &         +       RK2A1*RK2B1*G11(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &         +       RK2A1*RK2B2*G12(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &         +       RK2A2*RK2B1*G21(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
     &         +       RK2A2*RK2B2*G22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C           SL BLOCK
            EG = EG
     &         + 2.0D0*RK2A1*RK2B1*G11(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &         + 2.0D0*RK2A1*RK2B2*G12(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &         + 2.0D0*RK2A2*RK2B1*G21(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
     &         + 2.0D0*RK2A2*RK2B2*G22(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
C
C           SS BLOCK
            EG = EG
     &         +       RK2A1*RK2B1*G11(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &         +       RK2A1*RK2B2*G12(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &         +       RK2A2*RK2B1*G21(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
     &         +       RK2A2*RK2B2*G22(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE ATOMIC MEAN-FIELD BREIT MATRIX                          C
C**********************************************************************C
C
C     GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX
C     DFNOTE: BREIT0 NOT WORKING YET
C      goto 250

      IF(ITER.NE.10) GOTO 250
      IF(HMLTN.NE.'DHFP') GOTO 250
C
C      IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') GOTO 250
C
C     EVALUATE CLOSED-SHELL BREIT INTERACTION ANGULAR INTEGRALS
      CALL ANGBRT0
C
C     GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX OVER DENSITIES
      CALL BREIT0
C
      GOTO 251
C
C     ADD TWO-PARTICLE CONTRIBUTIONS TO FOCK MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
C
          H1(IBAS,JBAS) = H1(IBAS,JBAS) + RK2B1*B11(IBAS,JBAS)
     &                                  + RK2B2*B12(IBAS,JBAS)
          H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B1*B21(IBAS,JBAS)
     &                                  + RK2B2*B22(IBAS,JBAS)
C
        ENDDO
      ENDDO
C
251   CONTINUE
C
      ebll = 0.0d0
      ebss = 0.0d0
      ebsl = 0.0d0
C     TWO-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
C         LL BLOCK
          EB = EB
     &       +       RK2A1*RK2B1*B11(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &       +       RK2A1*RK2B2*B12(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &       +       RK2A2*RK2B1*B21(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
     &       +       RK2A2*RK2B2*B22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
     
          ebll = ebll +   RK2A2*RK2B2*B22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C         SL BLOCK
          EB = EB
     &       + 2.0D0*RK2A1*RK2B1*B11(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &       + 2.0D0*RK2A1*RK2B2*B12(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &       + 2.0D0*RK2A2*RK2B1*B21(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
     &       + 2.0D0*RK2A2*RK2B2*B22(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
     
          ebsl = ebsl + 2*RK2A2*RK2B2*B22(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
C
C         SS BLOCK
          EB = EB
     &       +       RK2A1*RK2B1*B11(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &       +       RK2A1*RK2B2*B12(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &       +       RK2A2*RK2B1*B21(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
     &       +       RK2A2*RK2B2*B22(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
     
          ebss = ebss +   RK2A2*RK2B2*B22(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
        ENDDO
      ENDDO
C
      write(*,*) rk2a2,rk2b2
      write(*,*) 'eb(ll-ss) = ',ebll
      write(*,*) 'eb(ss-ll) = ',ebss
      write(*,*) 'eb(sl-sl) = ',ebsl
      WRITE(*,*) 'TOTAL MAYBE = ',(ebll+ebss+ebsl)/2.0D0
      WRITE(*, *) 'BENERGY = ',EB/2.0D0
      WRITE(*, *) 'CORRECT = ',6.37933D-5
      WRITE(*, *) '|ERROR| = ',DABS(0.5D0*EB-6.37933D-5)
      EB = 0.0D0
C
C     PUT BREIT MATRIX COMPONENTS INTO A BIGGER MATRIX
C
      IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 161
C     CASE KQNA>0, KQNB>0
      IL1 = LARGE(ICNT,2*LQNA  ,1)
      IL2 = LARGE(ICNT,2*LQNA  ,2)
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
C
      JL1 = LARGE(ICNT,2*LQNB  ,1)
      JL2 = LARGE(ICNT,2*LQNB  ,2)
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
      RKK = RK2A1*RK2B1
C
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
          BMAT(IL1+IBAS,JL1+JBAS) = B11(IBAS,JBAS)
          BMAT(IL2+IBAS,JL2+JBAS) = B11(IBAS,JBAS)

          BMAT(IL1+IBAS,JS1+JBAS) = B11(IBAS,LBAS)
          BMAT(IL2+IBAS,JS2+JBAS) = B11(IBAS,LBAS)

          BMAT(IS1+IBAS,JL1+JBAS) = B11(KBAS,JBAS)
          BMAT(IS2+IBAS,JL2+JBAS) = B11(KBAS,JBAS)

          BMAT(IS1+IBAS,JS1+JBAS) = B11(KBAS,LBAS)
          BMAT(IS2+IBAS,JS2+JBAS) = B11(KBAS,LBAS)
C
        ENDDO
      ENDDO
161   CONTINUE
C
      IF(LQNA.EQ.0) GOTO 162
C     CASE KQNA>0, KQNB<0
      IL1 = LARGE(ICNT,2*LQNA  ,1)
      IL2 = LARGE(ICNT,2*LQNA  ,2)
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
C
      JL1 = LARGE(ICNT,2*LQNB+1,1)
      JL2 = LARGE(ICNT,2*LQNB+1,2)
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
          BMAT(IL1+IBAS,JL1+JBAS) = B12(IBAS,JBAS)
          BMAT(IL2+IBAS,JL2+JBAS) = B12(IBAS,JBAS)

          BMAT(IL1+IBAS,JS1+JBAS) = B12(IBAS,LBAS)
          BMAT(IL2+IBAS,JS2+JBAS) = B12(IBAS,LBAS)

          BMAT(IS1+IBAS,JL1+JBAS) = B12(KBAS,JBAS)
          BMAT(IS2+IBAS,JL2+JBAS) = B12(KBAS,JBAS)

          BMAT(IS1+IBAS,JS1+JBAS) = B12(KBAS,LBAS)
          BMAT(IS2+IBAS,JS2+JBAS) = B12(KBAS,LBAS)
C
        ENDDO
      ENDDO
162   CONTINUE
C
      IF(LQNB.EQ.0) GOTO 163
C     CASE KQNA<0, KQNB>0
      IL1 = LARGE(ICNT,2*LQNA+1,1)
      IL2 = LARGE(ICNT,2*LQNA+1,2)
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
C
      JL1 = LARGE(ICNT,2*LQNB  ,1)
      JL2 = LARGE(ICNT,2*LQNB  ,2)
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
      RKK = RK2A2*RK2B1
C
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
          BMAT(IL1+IBAS,JL1+JBAS) = B21(IBAS,JBAS)
          BMAT(IL2+IBAS,JL2+JBAS) = B21(IBAS,JBAS)

          BMAT(IL1+IBAS,JS1+JBAS) = B21(IBAS,LBAS)
          BMAT(IL2+IBAS,JS2+JBAS) = B21(IBAS,LBAS)

          BMAT(IS1+IBAS,JL1+JBAS) = B21(KBAS,JBAS)
          BMAT(IS2+IBAS,JL2+JBAS) = B21(KBAS,JBAS)

          BMAT(IS1+IBAS,JS1+JBAS) = B21(KBAS,LBAS)
          BMAT(IS2+IBAS,JS2+JBAS) = B21(KBAS,LBAS)
C
        ENDDO
      ENDDO
163   CONTINUE
C
C     CASE KQNA<0, KQNB<0
      IL1 = LARGE(ICNT,2*LQNA+1,1)
      IL2 = LARGE(ICNT,2*LQNA+1,2)
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
C
      JL1 = LARGE(ICNT,2*LQNB+1,1)
      JL2 = LARGE(ICNT,2*LQNB+1,2)
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
      RKK = RK2A2*RK2B2
C
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
          BMAT(IL1+IBAS,JL1+JBAS) = B22(IBAS,JBAS)
          BMAT(IL2+IBAS,JL2+JBAS) = B22(IBAS,JBAS)
C
          BMAT(IL1+IBAS,JS1+JBAS) = B22(IBAS,LBAS)
          BMAT(IL2+IBAS,JS2+JBAS) = B22(IBAS,LBAS)
C
          BMAT(IS1+IBAS,JL1+JBAS) = B22(KBAS,JBAS)
          BMAT(IS2+IBAS,JL2+JBAS) = B22(KBAS,JBAS)
C
          BMAT(IS1+IBAS,JS1+JBAS) = B22(KBAS,LBAS)
          BMAT(IS2+IBAS,JS2+JBAS) = B22(KBAS,LBAS)
C
        ENDDO
      ENDDO
169   CONTINUE
C
250   CONTINUE
C
C**********************************************************************C
C     FINISHED GENERATING TWO-ELECTRON INTEGRALS                       C
C**********************************************************************C
C
C     END LOOP OVER LQNS FOR ORBITAL B
200   CONTINUE
C
C       UEHLING INTERACTION ENERGIES FOR OCCUPIED ELECTRONS
        IF(HMLTN.EQ.'DHFQ') THEN
C
          M = 0
          DO IBAS=1,NBASA
            DO JBAS=1,NBASA
              M = M+1
C
              IF(HMLTN.EQ.'NORL') THEN
C             NON-RELATIVISTIC UEHLING ENERGY
C
                EU = EU + RK2A2*U2(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
              ELSE
C             RELATIVISTIC  UEHLING ENERGY
C
C               SMALL COMPONENT BLOCK ADDRESSES
                KBAS = IBAS+NBASA
                LBAS = JBAS+NBASA
C
C               LL BLOCK
                EU = EU + RK2A1*U1(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &                  + RK2A2*U2(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C               SS BLOCK
                EU = EU + RK2A1*U1(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &                  + RK2A2*U2(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
              ENDIF
C
            ENDDO
          ENDDO
C
        ENDIF
C
C     FINISH GENERATING SCF CONTRIBUTIONS
150   CONTINUE
C
C     FINISHED CALCULATING OVERLAP COMBINATIONS BETWEEN THIS LQNA
C     VALUE AND ALL POSSIBLE LQNB VALUES
C
C**********************************************************************C
C     MATRIX DIAGONALISATION AND COEFFICIENT MATRIX UPDATES            C
C**********************************************************************C
C
C     POSITIVE KAPPA(A) CHOICE (APPLIES ONLY FOR LQNA > 0)
      IF(LQNA.EQ.0.OR.HMLTN.EQ.'NORL') GOTO 140
C
C     DIAGONALISE FOCK MATRIX (THIS NEEDS LAPACK LIBRARY)
      CALL DSYGV(1,'V','U',NMAT,H1,2*MBS,O1,2*MBS,W1,T,LWK,INFO)
      IF(INFO.NE.0) THEN
        WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        STOP
      ENDIF
C
C     ATOMIC SELECTION RULE: ORTHOGONALITY IN BLOCKS OF KQN -> KA = KB
C
C     BEGIN LOOP OVER MQNA VALUES
      DO IMVAL=1,IABS(KAPA1)
C
C       COEFFICIENT MATRIX ADDRESSES
        IL1 = LARGE(ICNT,2*LQNA  ,IMVAL*2-1)
        IL2 = LARGE(ICNT,2*LQNA  ,IMVAL*2  )
        IS1 = IL1 + NSHIFT
        IS2 = IL2 + NSHIFT
C
C       COPY INTO MASTER COEFFICIENT LIST IF QA IS POSITIVE
        DO IOCC=1,NUMOCC(LQNA+1)
C
C         EFFECTIVE OCCUPATION NUMBER
          QF = DSQRT(QA(IOCC))
C
C         COPY INTO MASTER COEFFICIENT LIST
          DO IBAS=1,NBASA
C
C           LARGE COMPONENT OF KRAMERS PAIR
            CL = QF*H1(IBAS      ,NBASA+IOCC)
            C(IL1+IBAS,IOCCML+NSHIFT+1) = DCMPLX(CL,0.0D0)
            C(IL2+IBAS,IOCCML+NSHIFT+2) = DCMPLX(CL,0.0D0)
C
C           SMALL COMPONENT OF KRAMERS PAIR
            CS = QF*H1(IBAS+NBASA,NBASA+IOCC)
            C(IS1+IBAS,IOCCML+NSHIFT+1) = DCMPLX(CS,0.0D0)
            C(IS2+IBAS,IOCCML+NSHIFT+2) = DCMPLX(CS,0.0D0)
C
          ENDDO
C
C         STORE LOWEST ENERGY EIGENVALUES TO MASTER LIST
          EIGEN(IOCCML+NSHIFT+1) = W1(NBASA+IOCC)
          EIGEN(IOCCML+NSHIFT+2) = W1(NBASA+IOCC)
C
C         INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
          IOCCML = IOCCML+2
C
        ENDDO
      ENDDO
C
C
C     BUILD ATOMIC CHARGE DENSITY MATRIX FOR THIS KQNA BLOCK
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         INITIALISE ATOMIC DENSITY LISTS FOR THIS BLOCK
          DENLL(M,2*LQNA  ) = 0.0D0
          DENSL(M,2*LQNA  ) = 0.0D0
          DENSS(M,2*LQNA  ) = 0.0D0
C
          DFNLL(M,2*LQNA  ) = 0.0D0
          DFNSL(M,2*LQNA  ) = 0.0D0
          DFNSS(M,2*LQNA  ) = 0.0D0
C
C         LOOP OVER ALL OCCUPIED SHELLS OF THIS KQN TYPE
          DO IOCC=1,NUMOCC(LQNA+1)
C
C           DENSITY OVERLAPS FROM EIGENVECTOR PRODUCTS
            DLL = H1(IBAS     ,NBLC+IOCC)*H1(JBAS     ,NBLC+IOCC)
            DSL = H1(IBAS+NBLC,NBLC+IOCC)*H1(JBAS     ,NBLC+IOCC)
            DSS = H1(IBAS+NBLC,NBLC+IOCC)*H1(JBAS+NBLC,NBLC+IOCC)
C
C           ADD DENSITY CONTRIBUTIONS TO ATOMIC LIST
            DENLL(M,2*LQNA  ) = DENLL(M,2*LQNA  ) + QE(IOCC)*DLL
            DENSL(M,2*LQNA  ) = DENSL(M,2*LQNA  ) + QE(IOCC)*DSL
            DENSS(M,2*LQNA  ) = DENSS(M,2*LQNA  ) + QE(IOCC)*DSS
C
            DFNLL(M,2*LQNA  ) = DFNLL(M,2*LQNA  ) + QA(IOCC)*DLL
            DFNSL(M,2*LQNA  ) = DFNSL(M,2*LQNA  ) + QA(IOCC)*DSL
            DFNSS(M,2*LQNA  ) = DFNSS(M,2*LQNA  ) + QA(IOCC)*DSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     ONE-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      DO IOCC=1,NUMOCC(LQNA+1)
        EH = EH + QA(IOCC)*RK2A1*W1(NBLC+IOCC)
      ENDDO
C
140   CONTINUE
C
C
C     NEGATIVE KAPPA(A) CHOICE (APPLIES TO ALL LQNA VALUES)
C
C     DIAGONALISE FOCK MATRIX (THIS NEEDS LAPACK LIBRARY)
      CALL DSYGV(1,'V','U',NMAT,H2,2*MBS,O2,2*MBS,W2,T,LWK,INFO)
      IF(INFO.NE.0) THEN
        WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        STOP
      ENDIF
C
C     ATOMIC SELECTION RULE: ORTHOGONALITY IN BLOCKS OF KQN -> KA = KB
C
C     BEGIN LOOP OVER MQNA VALUES
      DO IMVAL=1,IABS(KAPA2)
C
C       COEFFICIENT MATRIX ADDRESSES
        IL1 = LARGE(ICNT,2*LQNA+1,IMVAL*2-1)
        IL2 = LARGE(ICNT,2*LQNA+1,IMVAL*2  )
        IS1 = IL1 + NSHIFT
        IS2 = IL2 + NSHIFT
C
C       LOOP OVER ALL OCCUPIED PRINCIPAL SHELLS N FOR THIS KQNA
        DO IOCC=1,NUMOCC(LQNA+1)
C
C         EFFECTIVE OCCUPATION NUMBER
          QF = DSQRT(QA(IOCC))
C
C         COPY INTO MASTER COEFFICIENT LIST
          DO IBAS=1,NBASA
C
C           LARGE COMPONENT OF KRAMERS PAIR
            CL = QF*H2(IBAS     ,NBLC+IOCC)
            C(IL1+IBAS,IOCCML+NSHIFT+1) = DCMPLX(CL,0.0D0)
            C(IL2+IBAS,IOCCML+NSHIFT+2) = DCMPLX(CL,0.0D0)
C
C           SMALL COMPONENT OF KRAMERS PAIR
            IF(HMLTN.NE.'NORL') THEN
              CS = QF*H2(IBAS+NBLC,NBLC+IOCC)
              C(IS1+IBAS,IOCCML+NSHIFT+1) = DCMPLX(CS,0.0D0)
              C(IS2+IBAS,IOCCML+NSHIFT+2) = DCMPLX(CS,0.0D0)
            ENDIF
C
          ENDDO
C
C         STORE LOWEST ENERGY EIGENVALUES TO MASTER LIST
          EIGEN(IOCCML+NSHIFT+1) = W2(NBLC+IOCC)
          EIGEN(IOCCML+NSHIFT+2) = W2(NBLC+IOCC)
C
C         INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
          IOCCML = IOCCML+2
C
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC SPECIAL CASE: ALSO FILL IN THE +KQNA BLOCK
      IF(HMLTN.EQ.'NORL'.AND.LQNA.GE.1) THEN
C
C       BEGIN LOOP OVER MQNA VALUES IN +KQNA BLOCK
        DO IMVAL=1,IABS(KVALS(2*LQNA  ,ICNT))
C
C         COEFFICIENT MATRIX ADDRESSES
          IL1 = LARGE(ICNT,2*LQNA  ,IMVAL*2-1)
          IL2 = LARGE(ICNT,2*LQNA  ,IMVAL*2  )
C
C         LOOP OVER ALL OCCUPIED PRINCIPAL SHELLS N FOR THIS KQNA
          DO IOCC=1,NUMOCC(LQNA+1)
C
C           EFFECTIVE OCCUPATION NUMBER
            QF = DSQRT(QA(IOCC))
C
C           COPY INTO MASTER COEFFICIENT LIST
            DO IBAS=1,NBASA
C
C             LARGE COMPONENT OF KRAMERS PAIR
              CL = QF*H2(IBAS     ,NBLC+IOCC)
              C(IL1+IBAS,IOCCML+NSHIFT+1) = DCMPLX(CL,0.0D0)
              C(IL2+IBAS,IOCCML+NSHIFT+2) = DCMPLX(CL,0.0D0)
C
            ENDDO
C
C         STORE LOWEST ENERGY EIGENVALUES TO MASTER LIST
          EIGEN(IOCCML+NSHIFT+1) = W2(NBLC+IOCC)
          EIGEN(IOCCML+NSHIFT+2) = W2(NBLC+IOCC)
C
C         INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
          IOCCML = IOCCML+2
C
          ENDDO
C
        ENDDO
      ENDIF
C
C     BUILD ATOMIC CHARGE DENSITY MATRIX FOR THIS KQNA BLOCK
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         INITIALISE ATOMIC DENSITY LISTS FOR THIS BLOCK
          DENLL(M,2*LQNA+1) = 0.0D0
          DFNLL(M,2*LQNA+1) = 0.0D0
C
          IF(HMLTN.NE.'NORL') THEN
            DENSL(M,2*LQNA+1) = 0.0D0
            DFNSL(M,2*LQNA+1) = 0.0D0
C
            DENSS(M,2*LQNA+1) = 0.0D0
            DFNSS(M,2*LQNA+1) = 0.0D0
          ENDIF
C
C         LOOP OVER ALL OCCUPIED SHELLS OF THIS KQN TYPE
          DO IOCC=1,NUMOCC(LQNA+1)
C
C           LL DENSITY CONTRIBUTIONS
            DLL = H2(IBAS     ,NBLC+IOCC)*H2(JBAS     ,NBLC+IOCC)
            DENLL(M,2*LQNA+1) = DENLL(M,2*LQNA+1) + QE(IOCC)*DLL
            DFNLL(M,2*LQNA+1) = DFNLL(M,2*LQNA+1) + QA(IOCC)*DLL
C
            IF(HMLTN.NE.'NORL') THEN
C
C             SL DENSITY CONTRIBUTIONS
              DSL = H2(IBAS+NBLC,NBLC+IOCC)*H2(JBAS     ,NBLC+IOCC)
              DENSL(M,2*LQNA+1) = DENSL(M,2*LQNA+1) + QE(IOCC)*DSL
              DFNSL(M,2*LQNA+1) = DFNSL(M,2*LQNA+1) + QA(IOCC)*DSL
C
C             SS DENSITY CONTRIBUTIONS
              DSS = H2(IBAS+NBLC,NBLC+IOCC)*H2(JBAS+NBLC,NBLC+IOCC)
              DENSS(M,2*LQNA+1) = DENSS(M,2*LQNA+1) + QE(IOCC)*DSS
              DFNSS(M,2*LQNA+1) = DFNSS(M,2*LQNA+1) + QA(IOCC)*DSS
C
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     ONE-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      DO IOCC=1,NUMOCC(LQNA+1)
        EH = EH + QA(IOCC)*RK2A2*W2(NBLC+IOCC)
      ENDDO
C
C     END LOOP OVER LQNA VALUES
100   CONTINUE
C
C     COULOMB AND BREIT ENERGIES HAVE BEEN DOUBLE-COUNTED
      EG = EG/2.0D0
      EB = EB/2.0D0
C
      E2 = EG+EB
C
C     TOTAL ATOMIC ENERGY IN THIS ITERATION
      ENEW = EH-EG-EB
C
C     RELATIVE CHANGE IN ENERGY
      ETEST = DABS((EPRV-ENEW)/ENEW)
C
C     WRITE THE ITERATION NUMBER AND THE TOTAL ENERGY
      WRITE(6,41) ITER,EH,E2,ENEW,ETEST
      WRITE(7,41) ITER,EH,E2,ENEW,ETEST
C
C     SUCCESSFUL CONVERGENCE
      IF(ETEST.LE.ENRGTOL) THEN
        GOTO 1001
      ELSE
        EPRV = ENEW
      ENDIF
      
      IF(ITER.EQ.10) GOTO 1001
C
C     BARE NUCLEUS APPROXIMATION
      IF(HMLTN.EQ.'BARE') GOTO 1001
C
C     END LOOP OVER ITERATIONS
1000  CONTINUE
C
C     WARN USER THAT ATOMIC SCF DID NOT CONVERGE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6, *) 'In HFSCF0: no convergence in ',ITER,' iterations.'
      WRITE(7, *) 'In HFSCF0: no convergence in ',ITER,' iterations.'
C
C     COVERGENCE SUCCESSFUL
1001  CONTINUE
C
C**********************************************************************C
C     CONSTRUCT MOLECULAR OVERLAP MATRIX                               C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO 101 LQNA=0,LMXCONF
C
C     IMPORT BASIS FUNCTION EXPONENTS
      NBASA = NFUNCT(LQNA+1,ICNT)
      DO IBAS=1,NBASA
        EXLA(IBAS) = EXPSET(IBAS,LQNA+1,ICNT)
      ENDDO
C
C     ONLY NEED 'KQN =+LQN' IN SOME CASES
      IF(LQNA.EQ.0) GOTO 131
C
C     FIRST RELATIVISTIC QUANTUM NUMBER
      KAPA1 = LQNA
C
C     GENERATE OVERLAP MATRIX
      CALL OVRLP0(O1,EXLA,KAPA1,NBASA)
C
131   CONTINUE
C
C     NEED 'KQN =-LQN-1' ALWAYS
C
C     SECOND RELATIVISTIC QUANTUM NUMBER
      KAPA2 =-LQNA-1
C
C     GENERATE OVERLAP MATRIX
      CALL OVRLP0(O2,EXLA,KAPA2,NBASA)
C
C     NOW FILL IN THESE OVERLAP MATRICES...
C
C     ONLY NEED 'KQN =+LQN' IN SOME CASES
      IF(LQNA.EQ.0) GOTO 141
C
C     BEGIN LOOP OVER MQNA VALUES
      DO IMVAL=1,IABS(KAPA1)
C
C       COEFFICIENT MATRIX ADDRESSES FOR 'KQN =+LQN' CHOICE
        IL1 = LARGE(ICNT,2*LQNA  ,IMVAL*2-1)
        IL2 = LARGE(ICNT,2*LQNA  ,IMVAL*2  )
        IS1 = IL1 + NSHIFT
        IS2 = IL2 + NSHIFT
C
C       TRANSFER OVERLAP MATRIX TO COMMON ARRAY
        DO IBAS=1,NBASA
          DO JBAS=1,NBASA
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBASA
            LBAS = JBAS+NBASA
C
C           MATRIX ELEMENTS
            OVAP(IL1+IBAS,IL1+JBAS) = DCMPLX(O1(IBAS,JBAS),0.0D0)
            OVAP(IL2+IBAS,IL2+JBAS) = DCMPLX(O1(IBAS,JBAS),0.0D0)

            IF(HMLTN.NE.'NORL') THEN
              OVAP(IS1+IBAS,IS1+JBAS) = DCMPLX(O1(KBAS,LBAS),0.0D0)
              OVAP(IS2+IBAS,IS2+JBAS) = DCMPLX(O1(KBAS,LBAS),0.0D0)
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
141   CONTINUE
C
C     NEED 'KQN =-LQN-1' ALWAYS
C
C     BEGIN LOOP OVER MQNA VALUES
      DO IMVAL=1,IABS(KAPA2)
C
C       COEFFICIENT MATRIX ADDRESSES FOR 'KQN =+LQN' CHOICE
        IL1 = LARGE(ICNT,2*LQNA+1,IMVAL*2-1)
        IL2 = LARGE(ICNT,2*LQNA+1,IMVAL*2  )
        IS1 = IL1 + NSHIFT
        IS2 = IL2 + NSHIFT
C
C       TRANSFER OVERLAP MATRIX TO COMMON ARRAY
        DO IBAS=1,NBASA
          DO JBAS=1,NBASA
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBASA
            LBAS = JBAS+NBASA
C
C           MATRIX ELEMENTS
            OVAP(IL1+IBAS,IL1+JBAS) = DCMPLX(O2(IBAS,JBAS),0.0D0)
            OVAP(IL2+IBAS,IL2+JBAS) = DCMPLX(O2(IBAS,JBAS),0.0D0)
C
            IF(HMLTN.NE.'NORL') THEN
              OVAP(IS1+IBAS,IS1+JBAS) = DCMPLX(O2(KBAS,LBAS),0.0D0)
              OVAP(IS2+IBAS,IS2+JBAS) = DCMPLX(O2(KBAS,LBAS),0.0D0)
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     END LOOP OVER LQN VALUES
101   CONTINUE
C
C**********************************************************************C
C     WRITTEN SUMMARY                                                  C
C**********************************************************************C
C
C     SUMMARY OF ENERGY CONTRIBUTIONS
50    FORMAT(1X,A,24X,F19.12)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,50) 'One-electron energy          ',EH
      WRITE(7,50) 'One-electron energy          ',EH
      WRITE(6,50) 'Two-electron energy (Coulomb)',EG
      WRITE(7,50) 'Two-electron energy (Coulomb)',EG
      IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') GOTO 500
      WRITE(6,50) 'Two-electron energy (Breit)  ',EB
      WRITE(7,50) 'Two-electron energy (Breit)  ',EB
500   CONTINUE
      WRITE(6,50) 'Total energy                 ',ENEW
      WRITE(7,50) 'Total energy                 ',ENEW
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
C
C     UPDATE COUNTER FOR HIGHEST OCCUPIED ATOMIC ORBITAL
      IOCCM0 = IOCCML
C
C     ADD RESULTS FROM THIS ATOM TO MOLECULAR ENERGY
      ETOT = ETOT + ENEW
      EONE = EONE + EH
      ECLG = ECLG + EG
      EBRG = EBRG + EB
cC
cC     DFNOTE: BREIT0 FIX
c      IF(HMLTN.EQ.'DHFB') THEN
c        TITLE = 'Atomic_BREIT0'
c        CALL ARRYPLT(BMAT,TITLE,NDIM)
c        STOP
c      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE OVRLP0(OVAP,EXL,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  VV    VV RRRRRRR  LL      PPPPPPP   000000          C
C         OO    OO VV    VV RR    RR LL      PP    PP 00   000         C
C         OO    OO VV    VV RR    RR LL      PP    PP 00  0000         C
C         OO    OO VV    VV RR    RR LL      PP    PP 00 00 00         C
C         OO    OO  VV  VV  RRRRRRR  LL      PPPPPPP  0000  00         C
C         OO    OO   VVVV   RR    RR LL      PP       000   00         C
C          OOOOOO     VV    RR    RR LLLLLLL PP        000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  OVRLP0 CALCULATES THE ATOMIC OVERLAP MATRIX FOR SYMMETRY TYPE KQN.  C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      DIMENSION RN(MBS*MBS,4),OVAP(2*MBS,2*MBS),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T32 = RL+1.5D0
          T52 = RL+2.5D0
          E32 = EIJ**T32
          E52 = EIJ**T52
          SLL = 0.5D0*RN(M,1)*GAMHLF(2*LQN+3)/E32
          SSS = 2.0D0*RN(M,3)*GAMHLF(2*LQN+5)*EPR/E52
C
C         OVERLAP MATRIX ELEMENTS
          OVAP(IBAS     ,JBAS     ) = SLL
          IF(HMLTN.EQ.'NORL') GOTO 50
          OVAP(IBAS+NBAS,JBAS     ) = 0.0D0
          OVAP(JBAS     ,IBAS+NBAS) = 0.0D0
          OVAP(IBAS+NBAS,JBAS+NBAS) = SSS
50        CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ONEEL0(HMAT,EXL,ZCRG,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  NN    NN EEEEEEEE EEEEEEEE LL      000000           C
C         OO    OO NNN   NN EE       EE       LL     00   000          C
C         OO    OO NNNN  NN EE       EE       LL     00  0000          C
C         OO    OO NN NN NN EEEEEE   EEEEEE   LL     00 00 00          C
C         OO    OO NN  NNNN EE       EE       LL     0000  00          C
C         OO    OO NN   NNN EE       EE       LL     000   00          C
C          OOOOOO  NN    NN EEEEEEEE EEEEEEEE LLLLLLL 000000           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ONEEL0 CALCULATES THE ATOMIC DIRAC AND OVERLAP MATRICES FOR         C
C  SYMMETRY TYPE KQN, USING EVEN-TEMPERED SGTFS.                       C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      DIMENSION RN(MBS*MBS,4),HMAT(2*MBS,2*MBS),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      G  = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M    = M+1
          EJ   = EXL(JBAS)
          EIJ  = EI+EJ
          EPR  = EI*EJ
          T52  = RL+2.5D0
          E52  = EIJ**T52
C
C         LL OVERLAP
          ULL =-ZCRG*RN(M,1)*BNUCINT0(2*LQN+1,EIJ)
          IF(HMLTN.EQ.'NORL') THEN
            PLL = RN(M,1)*GAMHLF(2*LQN+5)*EPR/E52
          ELSE
            PLL = 0.0D0
          ENDIF
C
C         TRANSFER INTO ARRAY
          HMAT(IBAS,JBAS) = ULL + PLL
C
C         LS,SL AND SS OVERLAPS
          IF(HMLTN.EQ.'NORL') GOTO 50
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBAS
          LBAS = JBAS+NBAS
C
C         OVERLAPS, KINETIC ELEMENTS AND SS POTENTIAL INTEGRALS
          SSS = 2.0D0*RN(M,3)*GAMHLF(2*LQN+5)*EPR/E52
          PSL = 2.0D0*RN(M,2)*GAMHLF(2*LQN+5)*EPR/E52
C
          VSA  = 4.0D0*EPR*BNUCINT0(2*LQN+3,EIJ)
          IF(KQN.GT.0) THEN
            VSN =-2.0D0*EIJ*G*BNUCINT0(2*LQN+1,EIJ)
     &                   +G*G*BNUCINT0(2*LQN-1,EIJ)
          ELSE
            VSN = 0.0D0
          ENDIF
          USS =-ZCRG*RN(M,3)*(VSA+VSN)
C
C         TRANSFER INTO ARRAY
          HMAT(KBAS,JBAS) = CV*PSL
          HMAT(JBAS,KBAS) = HMAT(KBAS,JBAS)
          HMAT(KBAS,LBAS) = USS-2.0D0*CV*CV*SSS
C
50        CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION BNUCINT0(N,ZETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  BBBBBBB  NN    NN UU    UU  CCCCCC IIII NN    NN TTTTTTTT 000000    C
C  BB    BB NNN   NN UU    UU CC    CC II  NNN   NN    TT   00   000   C
C  BB    BB NNNN  NN UU    UU CC       II  NNNN  NN    TT   00  0000   C
C  BBBBBBB  NN NN NN UU    UU CC       II  NN NN NN    TT   00 00 00   C
C  BB    BB NN  NNNN UU    UU CC       II  NN  NNNN    TT   0000  00   C
C  BB    BB NN   NNN UU    UU CC    CC II  NN   NNN    TT   000   00   C
C  BBBBBBB  NN    NN  UUUUUU   CCCCCC IIII NN    NN    TT    000000    C
C                                                                      C
C -------------------------------------------------------------------- C
C  BNUCINT0 CALCULATES A ONE-CENTER BARE NUCLEAR ATTRACTION INTEGRAL   C
C  GIVEN EXPONENT SUM ZETA, ORDER N (RADIAL POWER) AND LOCAL NUCLEAR   C
C  WIDTH PNUC. MAXIMUM ORDER IS N=21, SO TREATS LQNMAX=8 (k-TYPE).     C
C -------------------------------------------------------------------- C
C  BNUCINT0(N,ZETA) = INT{R^N*EXP(-ZETA*R^2)*ERF(SQRT(PNUC)*R)}.       C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9)
C
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     ROUTINE ONLY ALLOWS ODD PARAMETERS N
      IF(MOD(N,2).NE.1) THEN
        WRITE(6, *) 'In BNUCINT0: order N must be odd. N = ',N
        WRITE(7, *) 'In BNUCINT0: order N must be odd. N = ',N
      ENDIF
C
C     FACTORS NEEDED FOR ALL PARAMETERS N
      X   = ZETA/PNUC
      X5  = X*X*X*X*X
      T0  = PNUC+ZETA
      RAT = PNUC/T0
      TRM = 0.5D0*DSQRT(PNUC)/ZETA/DSQRT(T0)
      DO I=1,(N-1)/2
        TRM = 0.5D0*TRM*RAT/ZETA
      ENDDO
C
      IF(N.EQ.1) THEN
        TRM = TRM
      ELSEIF(N.EQ.3) THEN
        VA  = 2.0D0 + 3.0D0*X
        TRM = TRM*VA
      ELSEIF(N.EQ.5) THEN
        VA  = 8.0D0 + 20.0D0*X + 15.0D0*X*X
        TRM = TRM*VA
      ELSEIF(N.EQ.7) THEN
        VA  = 16.0D0 + 56.0D0*X + 70.0D0*X*X + 35.0D0*X*X*X
        TRM = 3.0D0*TRM*VA
      ELSEIF(N.EQ.9) THEN
        VA  = 128.0D0 + 576.0D0*X + 1008.0D0*X*X + 840.0D0*X*X*X
        VB  = 315.0D0*X*X*X*X
        TRM = 3.0D0*TRM*(VA+VB)
      ELSEIF(N.EQ.11) THEN
        VA  = 256.0D0 + 1408.0D0*X + 3168.0D0*X*X + 3696.0D0*X*X*X
        VB  = 2310.0D0*X*X*X*X + 693.0D0*X*X*X*X*X
        TRM = 15.0D0*TRM*(VA+VB)
      ELSEIF(N.EQ.13) THEN
        VA  = 1024.0D0 + 6656.0D0*X + 18304.0D0*X*X
        VB  = 27456.0D0*X*X*X + 24024.0D0*X*X*X*X
        VC  = 12012.0D0*X5 + 3003.0D0*X5*X
        TRM = 45.0D0*TRM*(VA+VB+VC)
      ELSEIF(N.EQ.15) THEN
        VA  = 2048.0D0 + 15360.0D0*X + 49920.0D0*X*X
        VB  = 91520.0D0*X*X*X+ 102960.0D0*X*X*X*X + 72072.0D0*X5
        VC  = 30030.0D0*X5*X + 6435.0D0*X5*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC)
      ELSEIF(N.EQ.17) THEN
        VA  = 32768.0D0 + 278528.0D0*X + 1044480.0D0*X*X
        VB  = 2263040.0D0*X*X*X + 3111680.0D0*X*X*X*X
        VC  = 2800512.0D0*X5 + 1633632.0D0*X5*X + 583440.0D0*X5*X*X
        VD  = 109395.0D0*X5*X*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(N.EQ.19) THEN
        VA  = 65536.0D0 + 6222592.0D0*X + 2646016.0D0*X*X
        VB  = 6615040.0D0*X*X*X + 10749440.0D0*X*X*X*X
        VC  = 11824384.0D0*X5 + 8868288.0D0*X5*X + 4434144.0D0*X5*X*X
        VD  = 1385670.0D0*X5*X*X*X + 230945.0D0*X5*X*X*X*X
        TRM = 2835.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(N.EQ.21) THEN
        VA  = 262144.0D0 + 2752512.0D0*X + 13074432.0D0*X*X
        VB  = 37044224.0D0*X*X*X + 69457920.0D0*X*X*X*X
        VC  = 90295296.0D0*X5 + 82770688.0D0*X5*X
        VD  = 53209728.0D0*X5*X*X + 23279256.0D0*X5*X*X*X
        VE  = 6466460.0D0*X5*X*X*X*X + 969969.0D0*X5*X5
        TRM = 14175.0D0*TRM*(VA+VB+VC+VD+VE)
      ELSE
        WRITE(6, *) 'In BNUCINT0: order N too large. N = ',N
        WRITE(7, *) 'In BNUCINT0: order N too large. N = ',N
      ENDIF
C
C     TRANSFER DATA TO BNUCINT0
      BNUCINT0 = TRM
C
      RETURN
      END
C
C
      SUBROUTINE COULOMB0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    CCCCCC   OOOOOO  UU    UU LL      MM       MM BBBBBBB   000000    C
C   CC    CC OO    OO UU    UU LL      MMM     MMM BB    BB 00   000   C
C   CC       OO    OO UU    UU LL      MMMM   MMMM BB    BB 00  0000   C
C   CC       OO    OO UU    UU LL      MM MM MM MM BBBBBBB  00 00 00   C
C   CC       OO    OO UU    UU LL      MM  MMM  MM BB    BB 0000  00   C
C   CC    CC OO    OO UU    UU LL      MM   M   MM BB    BB 000   00   C
C    CCCCCC   OOOOOO   UUUUUU  LLLLLLL MM       MM BBBBBBB   000000    C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB0 CONSTRUCTS THE ATOMIC COULOMB MATRIX FROM RADIAL DIRECT    C
C  AND EXCHANGE INTEGRALS AND A MEAN-FIELD CHARGE DENSITY.             C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+5)
C
      CHARACTER*4 HMLTN
C
      DIMENSION RN(MB2,4)
C
      COMMON/BSIJ/EIJ(MAB),RNIJ(3),EI,EJ
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BSXP/EXLA(MBS),EXLB(MBS)
      COMMON/CLRE/RKLLLL(MB2,4),RKSSSS(MB2,4),RKSLSL(MB2,4),
     &            RJLLLL(MB2,4),RJSSSS(MB2,4),RJLLSS(MB2,4),
     &            RJSSLL(MB2,4)
      COMMON/GAOC/G11(2*MBS,2*MBS),G21(2*MBS,2*MBS),D1(MB2,3),
     &            G12(2*MBS,2*MBS),G22(2*MBS,2*MBS),D2(MB2,3),
     &            B11(2*MBS,2*MBS),B21(2*MBS,2*MBS),
     &            B12(2*MBS,2*MBS),B22(2*MBS,2*MBS)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     INITIALISE COULOMB MATRIX
      DO IBAS=1,2*MBS
        DO JBAS=1,2*MBS
          G11(IBAS,JBAS) = 0.0D0
          G21(IBAS,JBAS) = 0.0D0
          G12(IBAS,JBAS) = 0.0D0
          G22(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     GENERATE 'KL' EXPONENT POWERS FOR LATER BETA-INTEGRAL GENERATION
      CALL KLSET
C
C     GENERATE A BATCH OF NORMALISATION CONSTANTS
      CALL RNORM0(RN,EXLA,NBASA,LQNA)
C
C     ITERATE OVER ALL MATRIX ELEMENTS
      IJ = 0
      DO IBAS=1,NBASA
        EI = EXLA(IBAS)
        DO JBAS=1,NBASA
C
C         BASIS EXPONENT COMBINATIONS FOR LATER B-INTEGRAL GENERATION
          IJ = IJ+1
C
          EJ = EXLA(JBAS)
          EIJ0 = EI+EJ
          EIJR = DSQRT(EIJ0)
          EIJA = EIJ0**(-LQNA)
          DO N=1,6
            EIJ(N) = EIJA
            EIJA   = EIJA/EIJR
          ENDDO
          RNIJ(1) = RN(IJ,1)
          RNIJ(2) = RN(IJ,2)
          RNIJ(3) = RN(IJ,3)
C
C         GENERATE A SET OF COULOMB BETA INTEGRALS
          CALL BETACLM
C
C         GENERATE BATCH OF RADIAL INTEGRALS (J AND K MATRICES)
          CALL ERI0
C
          IF(HMLTN.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
C           INITIALISE COUNTER
            GLL = 0.0D0
C
C           BUILD THE FOCK MATRIX
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,4)*D2(M,1) - RKLLLL(M,4)*D2(M,1)
            ENDDO
C
C           TRANSFER COUNTER VALUE TO COULOMB MATRIX
            G22(IBAS,JBAS) = GLL
C
          ELSE
C         RELATIVISTIC HAMILTONIAN
C
C           SMALL-COMPONENT MATRIX ADDRESSES
            KBAS = IBAS + NBASA
            LBAS = JBAS + NBASA
C
C    (11)   KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 10
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
C           SUM OVER MEAN FIELD CONTRIBUTIONS FOR THIS BASIS PAIR
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,1)*D1(M,1) - RKLLLL(M,1)*D1(M,1)
     &                  + RJLLSS(M,1)*D1(M,3)
              GSL = GSL                       - RKSLSL(M,1)*D1(M,2)
              GSS = GSS + RJSSSS(M,1)*D1(M,3) - RKSSSS(M,1)*D1(M,3)
     &                  + RJSSLL(M,1)*D1(M,1)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G11(IBAS,JBAS) = GLL
            G11(KBAS,JBAS) = GSL
            G11(JBAS,KBAS) = GSL
            G11(KBAS,LBAS) = GSS
C
10          CONTINUE
C
C    (21)   KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNB.EQ.0) GOTO 11
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,2)*D1(M,1) - RKLLLL(M,2)*D1(M,1)
     &                  + RJLLSS(M,2)*D1(M,3)
              GSL = GSL                       - RKSLSL(M,2)*D1(M,2)
              GSS = GSS + RJSSSS(M,2)*D1(M,3) - RKSSSS(M,2)*D1(M,3)
     &                  + RJSSLL(M,2)*D1(M,1)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G21(IBAS,JBAS) = GLL
            G21(KBAS,JBAS) = GSL
            G21(JBAS,KBAS) = GSL
            G21(KBAS,LBAS) = GSS
C
11          CONTINUE

C
C    (12)   KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0) GOTO 12
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,3)*D2(M,1) - RKLLLL(M,3)*D2(M,1)
     &                  + RJLLSS(M,3)*D2(M,3)
              GSL = GSL                       - RKSLSL(M,3)*D2(M,2)
              GSS = GSS + RJSSSS(M,3)*D2(M,3) - RKSSSS(M,3)*D2(M,3)
     &                  + RJSSLL(M,3)*D2(M,1)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G12(IBAS,JBAS) = GLL
            G12(KBAS,JBAS) = GSL
            G12(JBAS,KBAS) = GSL
            G12(KBAS,LBAS) = GSS
C
12          CONTINUE
C
C    (22)   KQNA < 0 AND KQNB < 0  CONTRIBUTIONS (CANNOT SKIP)
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,4)*D2(M,1) - RKLLLL(M,4)*D2(M,1)
     &                  + RJLLSS(M,4)*D2(M,3)
              GSL = GSL                       - RKSLSL(M,4)*D2(M,2)
              GSS = GSS + RJSSSS(M,4)*D2(M,3) - RKSSSS(M,4)*D2(M,3)
     &                  + RJSSLL(M,4)*D2(M,1)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G22(IBAS,JBAS) = GLL
            G22(KBAS,JBAS) = GSL
            G22(JBAS,KBAS) = GSL
            G22(KBAS,LBAS) = GSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BREIT0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT 000000            C
C           BB    BB RR    RR EE        II     TT   00   000           C
C           BB    BB RR    RR EE        II     TT   00  0000           C
C           BBBBBBB  RR    RR EEEEEE    II     TT   00 00 00           C
C           BB    BB RRRRRRR  EE        II     TT   0000  00           C
C           BB    BB RR    RR EE        II     TT   000   00           C
C           BBBBBBB  RR    RR EEEEEEEE IIII    TT    000000            C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT0 CONSTRUCTS THE ATOMIC BREIT MATRIX FROM RADIAL DIRECT AND    C
C  EXCHANGE INTEGRALS AND A MEAN-FIELD CHARGE DENSITY.                 C
C -------------------------------------------------------------------- C
C  DFNOTE: NOT FINISHED YET. EXCHANGE TERMS INCORRECT FOR S-TYPE GTFS. C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+5)
C
      DIMENSION RN(MB2,4)
C
      COMMON/BSIJ/EIJ(MAB),RNIJ(3),EI,EJ
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BSXP/EXLA(MBS),EXLB(MBS)
      COMMON/BTRE/RKLLSS(MB2,4),RKSLSL(MB2,4),RKSSLL(MB2,4),
     &            RMSLSL(MB2,4)
      COMMON/GAOC/G11(2*MBS,2*MBS),G21(2*MBS,2*MBS),D1(MB2,3),
     &            G12(2*MBS,2*MBS),G22(2*MBS,2*MBS),D2(MB2,3),
     &            B11(2*MBS,2*MBS),B21(2*MBS,2*MBS),
     &            B12(2*MBS,2*MBS),B22(2*MBS,2*MBS)
C
C     INITIALISE BREIT MATRIX
      DO IBAS=1,2*MBS
        DO JBAS=1,2*MBS
          B11(IBAS,JBAS) = 0.0D0
          B21(IBAS,JBAS) = 0.0D0
          B12(IBAS,JBAS) = 0.0D0
          B22(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     GENERATE 'KL' EXPONENT POWERS FOR LATER BETA-INTEGRAL GENERATION
      CALL KLSET
C
C     GENERATE A BATCH OF NORMALISATION CONSTANTS
      CALL RNORM0(RN,EXLA,NBASA,LQNA)
C
C     ITERATE OVER ALL MATRIX ELEMENTS
      IJ = 0
      DO IBAS=1,NBASA
        EI = EXLA(IBAS)
        DO JBAS=1,NBASA
C
C         BASIS EXPONENT COMBINATIONS FOR LATER B-INTEGRAL GENERATION
          IJ = IJ+1
C
          EJ = EXLA(JBAS)
          EIJ0 = EI+EJ
          EIJR = DSQRT(EIJ0)
          EIJA = EIJ0**(-LQNA)
          DO N=1,6
            EIJ(N) = EIJA
            EIJA   = EIJA/EIJR
          ENDDO
          RNIJ(1) = RN(IJ,1)
          RNIJ(2) = RN(IJ,2)
          RNIJ(3) = RN(IJ,3)
C
C         GENERATE A SET OF BREIT BETA INTEGRALS
          CALL BETABRT
C
C         GENERATE BATCH OF RADIAL INTEGRALS (J AND K MATRICES)
          CALL BII0
C
C         SMALL-COMPONENT MATRIX ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
C    (11) KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 10
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
C
C         SUM OVER MEAN FIELD CONTRIBUTIONS FOR THIS BASIS PAIR
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,1)*D1(M,3)
            BSL = BSL + RKSLSL(M,1)*D1(M,2) + RMSLSL(M,1)*D1(M,2)
            BSS = BSS + RKSSLL(M,1)*D1(M,1)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B11(IBAS,JBAS) = BLL
          B11(KBAS,JBAS) = BSL
          B11(JBAS,KBAS) = BSL
          B11(KBAS,LBAS) = BSS
C
10        CONTINUE
C
C    (21) KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 11
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,2)*D1(M,3)
            BSL = BSL + RKSLSL(M,2)*D1(M,2) + RMSLSL(M,2)*D1(M,2)
            BSS = BSS + RKSSLL(M,2)*D1(M,1)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B21(IBAS,JBAS) = BLL
          B21(KBAS,JBAS) = BSL
          B21(JBAS,KBAS) = BSL
          B21(KBAS,LBAS) = BSS
C
11        CONTINUE

C
C    (12) KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 12
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,3)*D2(M,3)
            BSL = BSL + RKSLSL(M,3)*D2(M,2) + RMSLSL(M,3)*D2(M,2)
            BSS = BSS + RKSSLL(M,3)*D2(M,1)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B12(IBAS,JBAS) = BLL
          B12(KBAS,JBAS) = BSL
          B12(JBAS,KBAS) = BSL
          B12(KBAS,LBAS) = BSS
C
12        CONTINUE
C
C    (22) KQNA < 0 AND KQNB < 0  CONTRIBUTIONS (CANNOT SKIP)
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,4)*D2(M,3)
            BSL = BSL + RKSLSL(M,4)*D2(M,2) + RMSLSL(M,4)*D2(M,2)
            BSS = BSS + RKSSLL(M,4)*D2(M,1)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B22(IBAS,JBAS) = BLL
          B22(KBAS,JBAS) = BSL
          B22(JBAS,KBAS) = BSL
          B22(KBAS,LBAS) = BSS
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE KLSET
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             KK    KK LL       SSSSSS  EEEEEEEE TTTTTTTT              C
C             KK   KK  LL      SS    SS EE          TT                 C
C             KK  KK   LL      SS       EE          TT                 C
C             KKKKK    LL       SSSSSS  EEEEEE      TT                 C
C             KK  KK   LL            SS EE          TT                 C
C             KK   KK  LL      SS    SS EE          TT                 C
C             KK    KK LLLLLLLL SSSSSS  EEEEEEEE    TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLSET GENERATES LISTS OF 'KL' EXPONENT POWERS FOR LATER USE         C
C  IN BETA INTEGRAL CONSTRUCTION AND ELECTRON REPULSION INTEGRALS.     C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+5)
C
      COMMON/ANGL/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4),
     &            NUS(MNU),NUNUM,NUI,NUF
      COMMON/BSKL/EK(MB2),EL(MB2),RNKL(MB2,4),IKIND(MB2),JLIND(MB2),
     &            EIK(MB2,MAB),EJL(MB2,MAB),EKL(MB2,MAB)
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BSXP/EXLA(MBS),EXLB(MBS)
C
C     GENERATE INDICES AND EXPONENT COMBINATIONS
      M = 0
      DO KBAS=1,NBASB
        EK0 = EXLB(KBAS)
        DO LBAS=1, NBASB
          M   = M+1
          EL0 = EXLB(LBAS)
          IKIND(M) = KBAS
          JLIND(M) = LBAS
          EK(M)    = EK0
          EL(M)    = EL0
          EKL0     = EK0+EL0
          EKLR     = DSQRT(EKL0)
          EKPW     = EKL0**LQNB
          EKLA     = 1.0D0/EKPW
          DO N=1,6
            EKL(M,N) = EKLA
            EKLA     = EKLA/EKLR
          ENDDO
        ENDDO
      ENDDO
C
C     NORMALISATION CONSTANTS
      CALL RNORM0(RNKL,EXLB,NBASB,LQNB)
C
      RETURN
      END
C
C
      SUBROUTINE BETACLM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   BBBBBBB  EEEEEEEE TTTTTTTT   AA     CCCCCC  LL       MM       MM   C
C   BB    BB EE          TT     AAAA   CC    CC LL       MMM     MMM   C
C   BB    BB EE          TT    AA  AA  CC       LL       MMMM   MMMM   C
C   BBBBBBB  EEEEEE      TT   AA    AA CC       LL       MM MM MM MM   C
C   BB    BB EE          TT   AAAAAAAA CC       LL       MM  MMM  MM   C
C   BB    BB EE          TT   AA    AA CC    CC LL       MM   M   MM   C
C   BBBBBBB  EEEEEEEE    TT   AA    AA  CCCCCC  LLLLLLLL MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  BETACLM GENERATES A BATCH OF BETA INTEGRALS FOR LATER USE IN THE    C
C  CONSTRUCTION OF ATOMIC ELECTRON REPULSION INTEGRALS.                C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+5)
C
      CHARACTER*4 HMLTN
C
      DIMENSION XJ(MB2,2),XK(MB2,2),IAA(2),IBB(2)
      DIMENSION RTIK0(MBS),RTJL0(MBS),PTIK0(MBS),PTJL0(MBS)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
C
      COMMON/ANGL/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4),
     &            NUS(MNU),NUNUM,NUI,NUF
      COMMON/BSIJ/EIJ(MAB),RNIJ(3),EI,EJ
      COMMON/BSKL/EK(MB2),EL(MB2),RNKL(MB2,4),IKIND(MB2),JLIND(MB2),
     &            EIK(MB2,MAB),EJL(MB2,MAB),EKL(MB2,MAB)
      COMMON/BSBT/B1(MB2,MAB,MAB),B2(MB2,MAB,MAB),B3(MB2,MAB,MAB),
     &            B4(MB2,MAB,MAB)
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BSXP/EXLA(MBS),EXLB(MBS)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     TENSOR ORDER AND RELEVANT POWER
      NUI    = NUS(    1)
      NUF    = NUS(NUNUM)
      IPOWER = LQNA+LQNB-NUF
C
C     A BLOCK OF BASIS EXPONENT PRODUCTS
      DO KBAS=1,NBASB
        RTIK0(KBAS) = DSQRT(EI+EXLB(KBAS))
        RTJL0(KBAS) = DSQRT(EJ+EXLB(KBAS))
        PTIK0(KBAS) = RTIK0(KBAS)**(-IPOWER)
        PTJL0(KBAS) = RTJL0(KBAS)**(-IPOWER)
      ENDDO
C
C     GENERATE COMMON ARRAYS EIK(MAXM,MAB) AND EJL(MAX,MAB)
      DO M=1,MAXM
        RTIK  = RTIK0(IKIND(M))
        RTJL  = RTJL0(JLIND(M))
        EIK(M,1) = PTIK0(IKIND(M))
        EJL(M,1) = PTJL0(JLIND(M))
        DO IPOW=2,2*NUF+6
          EIK(M,IPOW) = EIK(M,IPOW-1)/RTIK
          EJL(M,IPOW) = EJL(M,IPOW-1)/RTJL
        ENDDO
      ENDDO
C
C     GENERATE ARRAYS XJ(MB2,2) AND XK(MB2,2) FOR LOCAL USE
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = EI+EJ+TKL0
        XJ(M,1) = (EI   +EJ   )/TIJKL
        XJ(M,2) = (EK(M)+EL(M))/TIJKL
        XK(M,1) = (EI   +EK(M))/TIJKL
        XK(M,2) = (EJ   +EL(M))/TIJKL
      ENDDO
C
C**********************************************************************C
C     GENERATE ALL OF THE INCOMPLETE BETA FUNCTIONS FOR J-TYPE         C
C**********************************************************************C
C
C     PARAMETER NVALS USED TO DEFINE J- OR K-TYPE
      NVALS = 3
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
        IAA(1) = 2*LQNA+2*NX-1
        IAA(2) = 2*LQNB+2*NX-1
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = 2*LQNB+2*NY-2
          IBB(2) = 2*LQNA+2*NY-2
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+FCT*XJ(M,IBETA)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO J=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      =  1.0D0-XROOT(M)
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
            ENDIF
C
C           SORT THE BETA INTEGRAL INTO THE CORRECT ARRAY
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                B1(M,NX,NY) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                B2(M,NX,NY) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE ALL OF THE INCOMPLETE BETA FUNCTIONS FOR K-TYPE         C
C**********************************************************************C
C
C     PARAMETER NVALS USED TO DEFINE J- OR K- TYPE
      NVALS = (NUF-NUI)/2 + 3
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
        IAA(1) = LQNA+LQNB+NUI+2*NX-1
        IAA(2) = LQNA+LQNB+NUI+2*NX-1
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = LQNA+LQNB-NUF+2*NY-2
          IBB(2) = LQNA+LQNB-NUF+2*NY-2
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA = (IAA(IBETA)-1)/2
            IB =  IBB(IBETA)   /2
C
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
              RA = X
              RB = DFLOAT(1-IB)
              RC = X+1.0D0
              RD =   1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XK(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO J=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XK(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XK(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XK(M,IBETA)
              ENDDO
C
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XK(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
            ENDIF
C
C           SORT THE BETA INTEGRAL INTO THE CORRECT ARRAY
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                B3(M,NX,NY) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                B4(M,NX,NY) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C     ALL BETA INTEGRAL LISTS COMPLETE
C
      RETURN
      END
C
C
      SUBROUTINE BETABRT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     BBBBBBB  EEEEEEEE TTTTTTTT   AA    BBBBBBB  RRRRRRR TTTTTTTT     C
C     BB    BB EE          TT     AAAA   BB    BB RR    RR   TT        C
C     BB    BB EE          TT    AA  AA  BB    BB RR    RR   TT        C
C     BBBBBBB  EEEEEE      TT   AA    AA BBBBBBB  RR    RR   TT        C
C     BB    BB EE          TT   AAAAAAAA BB    BB RRRRRRR    TT        C
C     BB    BB EE          TT   AA    AA BB    BB RR    RR   TT        C
C     BBBBBBB  EEEEEEEE    TT   AA    AA BBBBBBB  RR    RR   TT        C
C                                                                      C
C -------------------------------------------------------------------- C
C  BETABRT GENERATES A BATCH OF BETA INTEGRALS FOR LATER USE IN THE    C
C  CONSTRUCTION OF ATOMIC BREIT INTERATION INTEGRALS.                  C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+5)
C
      CHARACTER*4 HMLTN
C
      DIMENSION XJ(MB2,2),XK(MB2,2),IAA(2),IBB(2)
      DIMENSION RTIK(MB2),RTJL(MB2),RTIK0(MBS),RTJL0(MBS),
     &          PTIK0(MBS),PTJL0(MBS),TTIK0(MBS),TTJL0(MBS)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
C
      COMMON/ANGL/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4),
     &            NUS(MNU),NUNUM,NUI,NUF
      COMMON/BSIJ/EIJ(MAB),RNIJ(3),EI,EJ
      COMMON/BSKL/EK(MB2),EL(MB2),RNKL(MB2,4),IKIND(MB2),JLIND(MB2),
     &            EIK(MB2,MAB),EJL(MB2,MAB),EKL(MB2,MAB)
      COMMON/BSBT/B1(MB2,MAB,MAB),B2(MB2,MAB,MAB),B3(MB2,MAB,MAB),
     &            B4(MB2,MAB,MAB)
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BSXP/EXLA(MBS),EXLB(MBS)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     TENSOR ORDER AND RELEVANT POWER
      NUI    = NUS(    1)
      NUF    = NUS(NUNUM)
      IPOWER = LQNA+LQNB-NUF
C
C     A BLOCK OF BASIS EXPONENT PRODUCTS
      DO KBAS=1,NBASB
        TTIK0(KBAS) = EI+EXLB(KBAS)
        TTJL0(KBAS) = EJ+EXLB(KBAS)
        RTIK0(KBAS) = DSQRT(TTIK0(KBAS))
        RTJL0(KBAS) = DSQRT(TTJL0(KBAS))
        PTIK0(KBAS) = RTIK0(KBAS)**(-IPOWER)
        PTJL0(KBAS) = RTJL0(KBAS)**(-IPOWER)
      ENDDO
C
C     GENERATE COMMON ARRAYS EIK(MAXM,MAB) AND EJL(MAX,MAB)
      DO M=1,MAXM
        RTIK(M)  = RTIK0(IKIND(M))
        RTJL(M)  = RTJL0(JLIND(M))
        EIK(M,1) = PTIK0(IKIND(M))
        EJL(M,1) = PTJL0(JLIND(M))
        DO IPOW=2,2*NUF+6
          EIK(M,IPOW) = EIK(M,IPOW-1)/RTIK(M)
          EJL(M,IPOW) = EJL(M,IPOW-1)/RTJL(M)
        ENDDO
      ENDDO
C
C     GENERATE ARRAYS XJ(MB2,2) AND XK(MB2,2) FOR LOCAL USE
      TIJ0 = EI+EJ
      DO M=1,MAXM
        TIK0     = TTIK0(IKIND(M))
        TJL0     = TTJL0(JLIND(M))
        TKL0     = EK(M)+EL(M)
        TIJKL    = TIJ0+TKL0
        XJ(M,1)  = TIJ0/TIJKL
        XJ(M,2)  = TKL0/TIJKL
        XK(M,1)  = TIK0/TIJKL
        XK(M,2)  = TJL0/TIJKL
      ENDDO
C
C**********************************************************************C
C     GENERATE ALL OF THE INCOMPLETE BETA FUNCTIONS FOR K-TYPE         C
C**********************************************************************C
C
C     PARAMETER NVALS USED TO DEFINE J- OR K- TYPE
      NVALS = (NUF-NUI)/2 + 3
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
        IAA(1) = LQNA+LQNB+NUI+2*NX-1
        IAA(2) = LQNA+LQNB+NUI+2*NX-1
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = LQNA+LQNB-NUF+2*NY-2
          IBB(2) = LQNA+LQNB-NUF+2*NY-2
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA = (IAA(IBETA)-1)/2
            IB =  IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
              RA = X
              RB = DFLOAT(1-IB)
              RC = X+1.0D0
              RD =   1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XK(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XK(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XK(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XK(M,IBETA)
              ENDDO
C
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XK(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                B1(M,NX,NY) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                B2(M,NX,NY) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE INCOMPLETE BETA FUNCTIONS FOR BREIT MATRIX ELEMENTS     C
C -------------------------------------------------------------------- C
C     DFNOTE: THIS SHOULD LOOK THE SAME AS B3 AND B4, EXCEPT THE       C
C             BETA INTEGRAL INDICES (IA,IB;Z) AND (IA',IB',Z') WILL    C
C             REQUIRE DIFFERENT POWERS.                                C
C**********************************************************************C
C
      IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ'.AND.HMLTN.NE.'DHFP') THEN
        GOTO 70
      ENDIF
C
C     TOTAL NUMBER OF P,Q VALUES NEEDED (ACCOUNT FOR NU AND T=S CHOICE)
      NVALS = (NUF-NUI)/2 + 2
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
C
C       NX PARAMETER VALUE FOR B5 AND B6
        IAA(1) = LQNA+LQNB+NUI+2*NX
        IAA(2) = LQNA+LQNB+NUI+2*NX
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
C
C         NY PARAMETER VALUE FOR B5 AND B6
          IBB(1) = LQNA+LQNB-NUF+2*NY-1
          IBB(2) = LQNA+LQNB-NUF+2*NY-1
C
C         LOOP OVER BETA INTEGRAL TYPE (B5 OR B6)
          DO IBETA=1,2
            IA = (IAA(IBETA)-1)/2
            IB =  IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA) + 0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X + 1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XK(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XK(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA) + 0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XK(M,IBETA))
                DEN      =  1.0D0-XROOT(M)
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XK(M,IBETA)
              ENDDO
C
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XK(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                B3(M,NX,NY) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                B4(M,NX,NY) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
70    CONTINUE
C
C     ALL BETA INTEGRAL LISTS COMPLETE
C
      RETURN
      END

C
C
      SUBROUTINE ERI0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                    EEEEEEEE RRRRRRR  IIII 000000                     C
C                    EE       RR    RR  II 00   000                    C
C                    EE       RR    RR  II 00  0000                    C
C                    EEEEEE   RR    RR  II 00 00 00                    C
C                    EE       RRRRRRR   II 0000  00                    C
C                    EE       RR    RR  II 000   00                    C
C                    EEEEEEEE RR    RR IIII 000000                     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI0 EVALUATES A DIRECT AND EXCHANGE BATCH OF ELECTRON REPULSION    C
C  INTEGRALS OF ALL COMPONENT LABEL COMBINATIONS L AND S IN THE ATOMIC C
C  SCF PROCEDURE FOR A USER-SPECIFIED HAMILTONIAN.                     C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    RJLLLL(M,N) - DIRECT ERI OVERLAP {LL,LL}                          C
C    RJSSSS(M,N) - DIRECT ERI OVERLAP {SS,SS}                          C
C    RJLLSS(M,N) - DIRECT ERI OVERLAP {LL,SS}                          C
C    RJSSLL(M,N) - DIRECT ERI OVERLAP {SS,LL}                          C
C    RKLLLL(M,N) - EXCHANGE ERI OVERLAP {LL,LL}                        C
C    RKSSSS(M,N) - EXCHANGE ERI OVERLAP {SS,SS}                        C
C    RKSLSL(M,N) - EXCHANGE ERI OVERLAP {SL,SL}                        C
C -------------------------------------------------------------------- C
C    N = 1 - KQN(A) > 0, KQN(B) > 0 (TYPICAL LABEL 11)                 C
C    N = 2 - KQN(A) < 0, KQN(B) > 0 (TYPICAL LABEL 12)                 C
C    N = 3 - KQN(A) > 0, KQN(B) < 0 (TYPICAL LABEL 21)                 C
C    N = 4 - KQN(A) < 0, KQN(B) < 0 (TYPICAL LABEL 22)                 C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+5)
C
      CHARACTER*4 HMLTN
C
      COMMON/ANGL/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4),
     &            NUS(MNU),NUNUM,NUI,NUF
      COMMON/BSIJ/EIJ(MAB),RNIJ(3),EI,EJ
      COMMON/BSKL/EK(MB2),EL(MB2),RNKL(MB2,4),IKIND(MB2),JLIND(MB2),
     &            EIK(MB2,MAB),EJL(MB2,MAB),EKL(MB2,MAB)
      COMMON/BSBT/B1(MB2,MAB,MAB),B2(MB2,MAB,MAB),B3(MB2,MAB,MAB),
     &            B4(MB2,MAB,MAB)
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/CLRE/RKLLLL(MB2,4),RKSSSS(MB2,4),RKSLSL(MB2,4),
     &            RJLLLL(MB2,4),RJSSSS(MB2,4),RJLLSS(MB2,4),
     &            RJSSLL(MB2,4)
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXM
        DO N=1,4
          RJLLLL(M,N) = 0.0D0
          RJLLSS(M,N) = 0.0D0
          RJSSLL(M,N) = 0.0D0
          RJSSSS(M,N) = 0.0D0
          RKLLLL(M,N) = 0.0D0
          RKSLSL(M,N) = 0.0D0
          RKSSSS(M,N) = 0.0D0
        ENDDO
      ENDDO
C
      IF(HMLTN.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        C5 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+5)
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
C       PREPARE VALUES FOR UPCOMING CALCULATIONS
        C1 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+1)
        C3 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+3)
        C5 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+5)
        C7 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+7)
        C9 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+9)
C
        V1 = 1.0D0
        V2 = 2.0D0
        V4 = 4.0D0
        V8 = 8.0D0
        VS = 1.6D1
C
        F  = DFLOAT(2*LQNA+1)
        G  = DFLOAT(2*LQNB+1)
C
        F0G0 = 1.0D0
        F1G0 = F
        F0G1 = G
        F1G1 = F*G
        F2G0 = F*F
        F0G2 = G*G
        F2G1 = F*F*G
        F1G2 = F*G*G
        F2G2 = F*F*G*G
C
      ENDIF
C
C**********************************************************************C
C     AN (LQNA,LQNB) COMBINATION HAS 1, 2 OR 4 (KQNA,KQNB) SUB-BLOCKS  C
C     SMALL-COMPONENT CONTRIBUTIONS DEPEND ON KQN SYMMETRY TYPE.       C
C**********************************************************************C
C
C     INITIATE LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0000 = 1.0D0
        E1000 = EI
        E0100 = EJ
        E0010 = EK(M)
        E0001 = EL(M)
        E1100 = EI*EJ
        E1010 = EI*EK(M)
        E1001 = EI*EL(M)
        E0110 = EJ*EK(M)
        E0101 = EJ*EL(M)
        E0011 = EK(M)*EL(M)
        E1110 = EI*EJ*EK(M)
        E1101 = EI*EJ*EL(M)
        E1011 = EI*EK(M)*EL(M)
        E0111 = EJ*EK(M)*EL(M)
        E1111 = EI*EJ*EK(M)*EL(M)
C
C**********************************************************************C
C       DIRECT INTEGRAL MATRICES: RJSSSS, RJLLSS, RJSSLL, RJLLLL       C
C**********************************************************************C
C
        IF(HMLTN.EQ.'NORL') THEN
C       NON-RELATIVISTIC HAMILTONIAN
C
          B22 = EIJ(4)*EKL(M,3)*B1(M,2,2) + EIJ(3)*EKL(M,4)*B2(M,2,2)
          RJLLLL(M,4) = C5*B22
C
        ELSE
C       RELATIVISTIC HAMILTONIAN
C
C         TEMPORARY STORAGE OF VALUES
C         BXY MARKS 'B' BETA COMBINATION AND 'X' ONTO EFFECTIVE LQN STORE
          B00 = EIJ(2)*EKL(M,1)*B1(M,1,1) + EIJ(1)*EKL(M,2)*B2(M,1,1)
          B02 = EIJ(2)*EKL(M,3)*B1(M,1,2) + EIJ(1)*EKL(M,4)*B2(M,2,1)
          B04 = EIJ(2)*EKL(M,5)*B1(M,1,3) + EIJ(1)*EKL(M,6)*B2(M,3,1)
          B20 = EIJ(4)*EKL(M,1)*B1(M,2,1) + EIJ(3)*EKL(M,2)*B2(M,1,2)
          B22 = EIJ(4)*EKL(M,3)*B1(M,2,2) + EIJ(3)*EKL(M,4)*B2(M,2,2)
          B24 = EIJ(4)*EKL(M,5)*B1(M,2,3) + EIJ(3)*EKL(M,6)*B2(M,3,2)
          B40 = EIJ(6)*EKL(M,1)*B1(M,3,1) + EIJ(5)*EKL(M,2)*B2(M,1,3)
          B42 = EIJ(6)*EKL(M,3)*B1(M,3,2) + EIJ(5)*EKL(M,4)*B2(M,2,3)
          B44 = EIJ(6)*EKL(M,5)*B1(M,3,3) + EIJ(5)*EKL(M,6)*B2(M,3,3)
C
C         FILL RJ ARRAYS FOR THIS LQNA,LQNB BLOCK
C
C         LQNA  =  0 AND LQNB  =  0 (REQUIRED FOR ALL BLOCKS)
          RJLLLL(M,4) = V1*F0G0*E0000*C5*B22
          RJLLSS(M,4) = V4*F0G0*E0011*C7*B24
          RJSSLL(M,4) = V4*F0G0*E1100*C7*B42
          RJSSSS(M,4) = VS*F0G0*E1111*C9*B44
C
C         LQNA =/= 0                (NEED KQNA > 0 BLOCK)
          IF(LQNA.EQ.0) GOTO 103
          RJLLLL(M,3) = RJLLLL(M,4)
          RJLLSS(M,3) = RJLLSS(M,4)
          RJSSLL(M,3) = V4*F0G0*E1100*C7*B42
     &                - V2*F1G0*E1000*C5*B22 - V2*F1G0*E0100*C5*B22
     &                + V1*F2G0*E0000*C3*B02
          RJSSSS(M,3) = VS*F0G0*E1111*C9*B44
     &                - V8*F1G0*E1011*C7*B24 - V8*F1G0*E0111*C7*B24
     &                + V4*F2G0*E0011*C5*B04
103       CONTINUE
C
C                        LQNB =/= 0 (NEED KQNB > 0 BLOCK)
          IF(LQNB.EQ.0) GOTO 102
          RJLLLL(M,2) = RJLLLL(M,4)
          RJLLSS(M,2) = V4*F0G0*E0011*C7*B24
     &                - V2*F0G1*E0010*C5*B22 - V2*F0G1*E0001*C5*B22
     &                + V1*F0G2*E0000*C3*B20
          RJSSLL(M,2) = RJSSLL(M,4)
          RJSSSS(M,2) = VS*F0G0*E1111*C9*B44
     &                - V8*F0G1*E1110*C7*B42 - V8*F0G1*E1101*C7*B42
     &                + V4*F0G2*E1100*C5*B40
102       CONTINUE
C
C         LQNA =/= 0 AND LQNB =/= 0 (NEED KQNA,KQNB > 0 BLOCK)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 101
          RJLLLL(M,1) = RJLLLL(M,4)
          RJLLSS(M,1) = RJLLSS(M,2)
          RJSSLL(M,1) = RJSSLL(M,3)
          RJSSSS(M,1) = VS*F0G0*E1111*C9*B44
     &                - V8*F0G1*E1110*C7*B42 - V8*F0G1*E1101*C7*B42
     &                - V8*F1G0*E1011*C7*B24 - V8*F1G0*E0111*C7*B24
     &                + V4*F2G0*E0011*C5*B04 + V4*F0G2*E1100*C5*B40
     &                + V4*F1G1*E1001*C5*B22 + V4*F1G1*E0110*C5*B22
     &                + V4*F1G1*E0101*C5*B22 + V4*F1G1*E1010*C5*B22
     &                - V2*F1G2*E1000*C3*B20 - V2*F1G2*E0100*C3*B20
     &                - V2*F2G1*E0010*C3*B02 - V2*F2G1*E0001*C3*B02
     &                + V1*F2G2*E0000*C1*B00
101       CONTINUE
C
        ENDIF
C
C**********************************************************************C
C       EXCHANGE INTEGRAL MATRICES: RKSSSS, RKSLSL, RKLLLL             C
C**********************************************************************C
C
C       LOOP OVER ORDERS FOR BETA INTEGRALS
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         INDEX OFFSETS FOR THE EXPONENT LISTS
          IA = NUF+NU
          IB = NUF-NU
C
C         INDEX OFFSETS FOR BETA INTEGRAL ARRAYS
          NX = (-NUI+NU)/2
          NY = ( NUF-NU)/2
C
          IF(HMLTN.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
            B22 = EIK(M,IA+4)*EJL(M,IB+3)*B3(M,NX+2,NY+2)
     &          + EIK(M,IB+3)*EJL(M,IA+4)*B4(M,NX+2,NY+2)
            RKLLLL(M,4) = RKLLLL(M,4) + BK(LTEN,4)*C5*B22
C
          ELSE
C         RELATIVISTIC HAMILTONIAN
C
C           TEMPORARY STORAGE OF VALUES
C           BXY MARKS 'B' BETA COMBINATION AND 'X' TO EFFECTIVE LQN STORE
C           ONTO WHICH NU IS ADDED OR SUBTRACTED.
C
            B00 = EIK(M,IA+2)*EJL(M,IB+1)*B3(M,NX+1,NY+1)
     &          + EIK(M,IB+1)*EJL(M,IA+2)*B4(M,NX+1,NY+1)
            B02 = EIK(M,IA+2)*EJL(M,IB+3)*B3(M,NX+1,NY+2)
     &          + EIK(M,IB+1)*EJL(M,IA+4)*B4(M,NX+2,NY+1)
            B04 = EIK(M,IA+2)*EJL(M,IB+5)*B3(M,NX+1,NY+3)
     &          + EIK(M,IB+1)*EJL(M,IA+6)*B4(M,NX+3,NY+1)
            B20 = EIK(M,IA+4)*EJL(M,IB+1)*B3(M,NX+2,NY+1)
     &          + EIK(M,IB+3)*EJL(M,IA+2)*B4(M,NX+1,NY+2)
            B22 = EIK(M,IA+4)*EJL(M,IB+3)*B3(M,NX+2,NY+2)
     &          + EIK(M,IB+3)*EJL(M,IA+4)*B4(M,NX+2,NY+2)
            B24 = EIK(M,IA+4)*EJL(M,IB+5)*B3(M,NX+2,NY+3)
     &          + EIK(M,IB+3)*EJL(M,IA+6)*B4(M,NX+3,NY+2)
            B40 = EIK(M,IA+6)*EJL(M,IB+1)*B3(M,NX+3,NY+1)
     &          + EIK(M,IB+5)*EJL(M,IA+2)*B4(M,NX+1,NY+3)
            B42 = EIK(M,IA+6)*EJL(M,IB+3)*B3(M,NX+3,NY+2)
     &          + EIK(M,IB+5)*EJL(M,IA+4)*B4(M,NX+2,NY+3)
            B44 = EIK(M,IA+6)*EJL(M,IB+5)*B3(M,NX+3,NY+3)
     &          + EIK(M,IB+5)*EJL(M,IA+6)*B4(M,NX+3,NY+3)
C
C           LQNA  =  0 AND LQNB  =  0 (REQUIRED FOR ALL BLOCKS)
            RKLLLL(M,4) = RKLLLL(M,4) + BK(LTEN,4)*V1*F0G0*E0000*C5*B22
            RKSLSL(M,4) = RKSLSL(M,4) + BK(LTEN,4)*V4*F0G0*E1010*C7*B42
            RKSSSS(M,4) = RKSSSS(M,4) + BK(LTEN,4)*VS*F0G0*E1111*C9*B44
C
C           LQNA =/= 0                (NEED KQNA > 0 BLOCK)
            IF(LQNA.EQ.0) GOTO 203
            RKLL = V1*F0G0*E0000*C5*B22
            RKSL = V4*F0G0*E1010*C7*B42 - V2*F1G0*E0010*C5*B22
            RKSS = VS*F0G0*E1111*C9*B44 - V8*F1G0*E1011*C7*B42
     &           - V8*F1G0*E0111*C7*B24 + V4*F2G0*E0011*C5*B22
            RKLLLL(M,3) = RKLLLL(M,3) + BK(LTEN,3)*RKLL
            RKSLSL(M,3) = RKSLSL(M,3) + BK(LTEN,3)*RKSL
            RKSSSS(M,3) = RKSSSS(M,3) + BK(LTEN,3)*RKSS
203         CONTINUE
C
C                        LQNB =/= 0 (NEED KQNB > 0 BLOCK)
            IF(LQNB.EQ.0) GOTO 202
            RKLL = V1*F0G0*E0000*C5*B22
            RKSL = V4*F0G0*E1010*C7*B42 - V2*F0G1*E1000*C5*B22
            RKSS = VS*F0G0*E1111*C9*B44 - V8*F0G1*E1110*C7*B42
     &           - V8*F0G1*E1101*C7*B24 + V4*F0G2*E1100*C5*B22
            RKLLLL(M,2) = RKLLLL(M,2) + BK(LTEN,2)*RKLL
            RKSLSL(M,2) = RKSLSL(M,2) + BK(LTEN,2)*RKSL
            RKSSSS(M,2) = RKSSSS(M,2) + BK(LTEN,2)*RKSS
202         CONTINUE
C
C           LQNA =/= 0 AND LQNB =/= 0 (NEED KQNA,KQNB > 0 BLOCK)
            IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 201
            RKLL = V1*F0G0*E0000*C5*B22
            RKSL = V4*F0G0*E1010*C7*B42 - V2*F1G0*E0010*C5*B22
     &           - V2*F0G1*E1000*C5*B22 + V1*F1G1*E0000*C3*B02
            RKSS = VS*F0G0*E1111*C9*B44
     &           - V8*F0G1*E1110*C7*B42 - V8*F0G1*E1101*C7*B24
     &           - V8*F1G0*E1011*C7*B42 - V8*F1G0*E0111*C7*B24
     &           + V4*F2G0*E0011*C5*B22 + V4*F0G2*E1100*C5*B22
     &           + V4*F1G1*E0110*C5*B22 + V4*F1G1*E1001*C5*B22
     &           + V4*F1G1*E1010*C5*B40 + V4*F1G1*E0101*C5*B04
     &           - V2*F2G1*E0010*C3*B20 - V2*F1G2*E1000*C3*B20
     &           - V2*F2G1*E0001*C3*B02 - V2*F1G2*E0100*C3*B02
     &           + V1*F2G2*E0000*C1*B00
            RKLLLL(M,1) = RKLLLL(M,1) + BK(LTEN,1)*RKLL
            RKSLSL(M,1) = RKSLSL(M,1) + BK(LTEN,1)*RKSL
            RKSSSS(M,1) = RKSSSS(M,1) + BK(LTEN,1)*RKSS
201         CONTINUE
C
          ENDIF
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     NORMALISE ACCUMULATED INTEGRALS (DIRECT AND EXCHANGE)            C
C**********************************************************************C
C
      IF(HMLTN.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          T0LLLL = RNIJ(1)*RNKL(M,1)
          RJLLLL(M,4) = RJLLLL(M,4)*T0LLLL
          RKLLLL(M,4) = RKLLLL(M,4)*T0LLLL
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          T0LLLL = RNIJ(1)*RNKL(M,1)
          T0LLSS = RNIJ(1)*RNKL(M,3)
          T0SLSL = RNIJ(2)*RNKL(M,2)
          T0SSLL = RNIJ(3)*RNKL(M,1)
          T0SSSS = RNIJ(3)*RNKL(M,3)
          DO N=1,4
            RJLLLL(M,N) = RJLLLL(M,N)*T0LLLL
            RJLLSS(M,N) = RJLLSS(M,N)*T0LLSS
            RJSSLL(M,N) = RJSSLL(M,N)*T0SSLL
            RJSSSS(M,N) = RJSSSS(M,N)*T0SSSS
            RKLLLL(M,N) = RKLLLL(M,N)*T0LLLL
            RKSLSL(M,N) = RKSLSL(M,N)*T0SLSL
            RKSSSS(M,N) = RKSSSS(M,N)*T0SSSS
          ENDDO
        ENDDO
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BII0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                      BBBBBBB IIII IIII 000000                        C
C                      BB    BB II   II 00   000                       C
C                      BB    BB II   II 00  0000                       C
C                      BBBBBBB  II   II 00 00 00                       C
C                      BB    BB II   II 0000  00                       C
C                      BB    BB II   II 000   00                       C
C                      BBBBBBB IIII IIII 000000                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  BII0 EVALUATES A DIRECT AND EXCHANGE BATCH OF BREIT INTERACTION     C
C  INTEGRALS OF ALL COMPONENT LABEL COMBINATIONS L AND S IN THE ATOMIC C
C  (RELATIVISTIC) SCF PROCEDURE.                                       C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    RKLLSS(M,N) - EXCHANGE BII OVERLAP {LL,SS}                        C
C    RKSLSL(M,N) - EXCHANGE BII OVERLAP {SL,SL}                        C
C    RKSSLL(M,N) - EXCHANGE BII OVERLAP {SS,LL}                        C
C    RMSLSL(M,N) - SEMI-RANGE BII OVERLAP {SL,SL}                      C
C -------------------------------------------------------------------- C
C    N = 1 - KQN(A) > 0, KQN(B) > 0 (TYPICAL LABEL 11)                 C
C    N = 2 - KQN(A) < 0, KQN(B) > 0 (TYPICAL LABEL 12)                 C
C    N = 3 - KQN(A) > 0, KQN(B) < 0 (TYPICAL LABEL 21)                 C
C    N = 4 - KQN(A) < 0, KQN(B) < 0 (TYPICAL LABEL 22)                 C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+5)
C
      COMMON/ANGL/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4),
     &            NUS(MNU),NUNUM,NUI,NUF
      COMMON/BSIJ/EIJ(MAB),RNIJ(3),EI,EJ
      COMMON/BSKL/EK(MB2),EL(MB2),RNKL(MB2,4),IKIND(MB2),JLIND(MB2),
     &            EIK(MB2,MAB),EJL(MB2,MAB),EKL(MB2,MAB)
      COMMON/BSBT/B1(MB2,MAB,MAB),B2(MB2,MAB,MAB),B3(MB2,MAB,MAB),
     &            B4(MB2,MAB,MAB)
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BTRE/RKLLSS(MB2,4),RKSLSL(MB2,4),RKSSLL(MB2,4),
     &            RMSLSL(MB2,4)
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXM
        DO N=1,4
          RKLLSS(M,N) = 0.0D0
          RKSLSL(M,N) = 0.0D0
          RKSSLL(M,N) = 0.0D0
          RMSLSL(M,N) = 0.0D0
        ENDDO
      ENDDO
C
C     PREPARE VALUES FOR UPCOMING CALCULATIONS
      C1 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+1)
      C3 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+3)
      C5 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+5)
      C7 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+7)
      C9 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+9)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
      V8 = 8.0D0
      VS = 1.6D1
C
      F  = DFLOAT(2*LQNA+1)
      G  = DFLOAT(2*LQNB+1)
C
      F0G0 = 1.0D0
      F1G0 = F
      F0G1 = G
      F1G1 = F*G
      F2G0 = F*F
      F0G2 = G*G
      F2G1 = F*F*G
      F1G2 = F*G*G
      F2G2 = F*F*G*G
C
C**********************************************************************C
C     AN (LQNA,LQNB) COMBINATION HAS 1, 2 OR 4 (KQNA,KQNB) SUB-BLOCKS  C
C     SMALL-COMPONENT CONTRIBUTIONS DEPEND ON KQN SYMMETRY TYPE.       C
C**********************************************************************C
C
C     INITIATE LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0000 = 1.0D0
        E1000 = EI
        E0100 = EJ
        E0010 = EK(M)
        E0001 = EL(M)
        E1100 = EI*EJ
        E1010 = EI*EK(M)
        E1001 = EI*EL(M)
        E0110 = EJ*EK(M)
        E0101 = EJ*EL(M)
        E0011 = EK(M)*EL(M)
        E1110 = EI*EJ*EK(M)
        E1101 = EI*EJ*EL(M)
        E1011 = EI*EK(M)*EL(M)
        E0111 = EJ*EK(M)*EL(M)
        E1111 = EI*EJ*EK(M)*EL(M)
C
C**********************************************************************C
C       EXCHANGE INTEGRAL MATRICES: RKLLSS, RKSLSL, RKSSLL             C
C**********************************************************************C
C
C       LOOP OVER ORDERS FOR BETA INTEGRALS
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         INDEX OFFSETS FOR THE EXPONENT LISTS
          IA = NUF+NU
          IB = NUF-NU
C
C         INDEX OFFSETS FOR BETA INTEGRAL ARRAYS
          NX = (-NUI+NU)/2
          NY = ( NUF-NU)/2
C
C         TEMPORARY STORAGE OF VALUES
C         BXY MARKS 'B' BETA COMBINATION AND 'X' TO EFFECTIVE LQN STORE
C         ONTO WHICH NU IS ADDED OR SUBTRACTED.
          B02 = EIK(M,IA+2)*EJL(M,IB+3)*B1(M,NX+1,NY+2)
     &        + EIK(M,IB+1)*EJL(M,IA+4)*B2(M,NX+2,NY+1)
          B22 = EIK(M,IA+4)*EJL(M,IB+3)*B1(M,NX+2,NY+2)
     &        + EIK(M,IB+3)*EJL(M,IA+4)*B2(M,NX+2,NY+2)
          B42 = EIK(M,IA+6)*EJL(M,IB+3)*B1(M,NX+3,NY+2)
     &        + EIK(M,IB+5)*EJL(M,IA+4)*B2(M,NX+2,NY+3)
          B11 = EIK(M,IA+3)*EJL(M,IB+2)*B1(M,NX+1,NY+1)
     &        + EIK(M,IB+2)*EJL(M,IA+3)*B2(M,NX+1,NY+1)
          B13 = EIK(M,IA+3)*EJL(M,IB+4)*B1(M,NX+1,NY+2)
     &        + EIK(M,IB+2)*EJL(M,IA+5)*B2(M,NX+2,NY+1)
          B31 = EIK(M,IA+5)*EJL(M,IB+2)*B1(M,NX+2,NY+1)
     &        + EIK(M,IB+4)*EJL(M,IA+3)*B2(M,NX+1,NY+2)
          B33 = EIK(M,IA+5)*EJL(M,IB+4)*B1(M,NX+3,NY+3)
     &        + EIK(M,IB+4)*EJL(M,IA+5)*B2(M,NX+3,NY+3)

c         B33 = EIK(M,IA+5)*EJL(M,IB+4)*B1(M,NX+2,NY+3)
c     &       + EIK(M,IB+6)*EJL(M,IA+3)*B2(M,NX+3,NY+2)
C
C         LQNA  =  0 AND LQNB  =  0 (REQUIRED FOR ALL BLOCKS)
          RKLLSS(M,4) = RKLLSS(M,4) + ELL(LTEN,4)*V4*F0G0*E0011*C7*B33
          RKSLSL(M,4) = RKSLSL(M,4) + ESL(LTEN,4)*V4*F0G0*E1010*C7*B42
C          RKSLSL(M,4) = RKSLSL(M,4) + ESL(LTEN,4)*V4*F0G0*E1100*C7*B33
          RKSSLL(M,4) = RKSSLL(M,4) + ESS(LTEN,4)*V4*F0G0*E1100*C7*B33

c          rkll = rkll + ell(lten,4)*rkt1
c          rkss = rkss + ess(lten,4)*rkt1
c          rksl = rksl + esl(lten,4)*rkt1 + gsl(lten,4)*rmt1
c          
c          rkt1 = gamaa1(lten)*gamab1(lten)*eikpow(m,ia+1)*ejlpow(m,ib  )*babz1(m,lten)
c               + gamaa2(lten)*gamab2(lten)*eikpow(m,ib  )*ejlpow(m,ia+1)*babz2(m,lten)
cC
C         LQNA =/= 0                (NEED KQNA > 0 BLOCK)
          IF(LQNA.EQ.0) GOTO 203
          RKLL = V4*F0G0*E0011*C7*B33
          RKSL = V4*F0G0*E1010*C7*B42 - V2*F1G0*E0010*C5*B22
          RKSS = V4*F0G0*E1100*C7*B33 - V2*F1G0*E1000*C5*B31
     &         - V2*F1G0*E0100*C5*B13 + V1*F2G0*E0000*C3*B11
          RKLLSS(M,3) = RKLLSS(M,3) + ELL(LTEN,3)*RKLL
          RKSLSL(M,3) = RKSLSL(M,3) + ESL(LTEN,3)*RKSL
          RKSSLL(M,3) = RKSSLL(M,3) + ESS(LTEN,3)*RKSS
203       CONTINUE
C
C         LQNB =/= 0                (NEED KQNB > 0 BLOCK)
          IF(LQNB.EQ.0) GOTO 202
          RKLL = V4*F0G0*E0011*C7*B33 - V2*F0G1*E0010*C5*B31
     &         - V2*F0G1*E0001*C5*B13 + V1*F1G1*E0000*C3*B11
          RKSL = V4*F0G0*E1010*C7*B42 - V2*F0G1*E1000*C5*B22
          RKSS = V4*F0G0*E1100*C7*B33
          RKLLSS(M,2) = RKLLSS(M,2) + ELL(LTEN,2)*RKLL
          RKSLSL(M,2) = RKSLSL(M,2) + ESL(LTEN,2)*RKSL
          RKSSLL(M,2) = RKSSLL(M,2) + ESS(LTEN,2)*RKSS
202       CONTINUE
C
C         LQNA =/= 0 AND LQNB =/= 0 (NEED KQNA,KQNB > 0 BLOCK)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 201
          RKLL = V4*F0G0*E0011*C7*B33 - V2*F0G1*E0010*C5*B31
     &         - V2*F0G1*E0001*C5*B13 + V1*F1G1*E0000*C3*B11
          RKSL = V4*F0G0*E1010*C7*B42 - V2*F1G0*E0010*C5*B22
     &         - V2*F0G1*E1000*C5*B22 + V1*F1G1*E0000*C3*B02
          RKSS = V4*F0G0*E1100*C7*B33 - V2*F1G0*E1000*C5*B31
     &         - V2*F1G0*E0100*C5*B13 + V1*F2G0*E0000*C3*B11
          RKLLSS(M,1) = RKLLSS(M,1) + ELL(LTEN,1)*RKLL
          RKSLSL(M,1) = RKSLSL(M,1) + ESL(LTEN,1)*RKSL
          RKSSLL(M,1) = RKSSLL(M,1) + ESS(LTEN,1)*RKSS
201       CONTINUE
C
        ENDDO
C
C**********************************************************************C
C       BREIT INTEGRAL MATRICES: RMSLSL                                C
C**********************************************************************C
C
C       LOOP OVER ORDERS FOR BETA INTEGRALS
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         INDEX OFFSETS FOR BETA INTEGRAL ARRAYS
          IA = NUF+NU
          IB = NUF-NU
C
          NX = (-NUI+NU)/2
          NY = ( NUF-NU)/2
C
C         TEMPORARY STORAGE OF VALUES
C         BXY MARKS 'B' BETA COMBINATION AND 'X' TO EFFECTIVE LQN STORE
C         ONTO WHICH NU IS ADDED OR SUBTRACTED.
cc          B11 = EIK(M,IA+3)*EJL(M,IB+2)*B3(M,NX+2,NY+2)
cc     &        - EIK(M,IB+2)*EJL(M,IA+3)*B4(M,NX+2,NY+2)
cc          B13 = EIK(M,IA+3)*EJL(M,IB+4)*B3(M,NX+2,NY+3)
cc     &        - EIK(M,IB+2)*EJL(M,IA+5)*B4(M,NX+3,NY+2)
cc          B31 = EIK(M,IA+5)*EJL(M,IB+2)*B3(M,NX+3,NY+2)
cc     &        - EIK(M,IB+4)*EJL(M,IA+3)*B4(M,NX+2,NY+3)
cc          B33 = EIK(M,IA+5)*EJL(M,IB+4)*B3(M,NX+3,NY+3)
cc     &        - EIK(M,IB+4)*EJL(M,IA+5)*B4(M,NX+3,NY+3)
C
          B11 = EIK(M,IA+3)*EJL(M,IB+2)*B3(M,NX+1,NY+1)
          B13 = EIK(M,IA+3)*EJL(M,IB+4)*B3(M,NX+1,NY+2)
          B31 = EIK(M,IA+5)*EJL(M,IB+2)*B3(M,NX+2,NY+1)
          B33 = EIK(M,IA+5)*EJL(M,IB+4)*B3(M,NX+2,NY+2)
C
C         LQNA  =  0 AND LQNB  =  0 (REQUIRED FOR ALL BLOCKS)
          RMSLSL(M,4) = RMSLSL(M,4) + GSL(LTEN,4)*V4*F0G0*E1100*C7*B33
C
C         LQNA =/= 0                (NEED KQNA > 0 BLOCK)
          IF(LQNA.EQ.0) GOTO 303
          RMSL = V4*F0G0*E1100*C7*B33 - V2*F1G0*E1000*C5*B31
     &         - V2*F1G0*E0100*C5*B13 + V1*F2G0*E0000*C3*B11
          RMSLSL(M,3) = RMSLSL(M,3) + GSL(LTEN,3)*RMSL
303       CONTINUE
C
C         LQNB =/= 0                (NEED KQNB > 0 BLOCK)
          IF(LQNB.EQ.0) GOTO 302
          RMSL = V4*F0G0*E1100*C7*B33
          RMSLSL(M,2) = RMSLSL(M,2) + GSL(LTEN,2)*RMSL
302       CONTINUE
C
C         LQNA =/= 0 AND LQNB =/= 0 (NEED KQNA,KQNB > 0 BLOCK)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 301
          RMSL = V4*F0G0*E1100*C7*B33 - V2*F1G0*E1000*C5*B31
     &         - V2*F1G0*E0100*C5*B13 + V1*F2G0*E0000*C3*B11
          RMSLSL(M,1) = RMSLSL(M,1) + GSL(LTEN,1)*RMSL
301       CONTINUE
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     NORMALISE ACCUMULATED INTEGRALS (DIRECT AND EXCHANGE)            C
C**********************************************************************C
C
      DO M=1,MAXM
        T0LLSS = RNIJ(1)*RNKL(M,3)
        T0SLSL = RNIJ(2)*RNKL(M,2)
        T0SSLL = RNIJ(3)*RNKL(M,1)
        DO N=1,4
          RKLLSS(M,N) = RKLLSS(M,N)*T0LLSS
          RKSSLL(M,N) = RKSSLL(M,N)*T0SSLL
          RKSLSL(M,N) = RKSLSL(M,N)*T0SLSL
          RMSLSL(M,N) = RMSLSL(M,N)*T0SLSL
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ANGCLM0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     AA    NN    NN  GGGGGG   CCCCCC  LL       MM       MM  000000    C
C    AAAA   NNN   NN GG    GG CC    CC LL       MMM     MMM 00   000   C
C   AA  AA  NNNN  NN GG       CC       LL       MMMM   MMMM 00  0000   C
C  AA    AA NN NN NN GG       CC       LL       MM MM MM MM 00 00 00   C
C  AAAAAAAA NN  NNNN GG   GGG CC       LL       MM  MMM  MM 0000  00   C
C  AA    AA NN   NNN GG    GG CC    CC LL       MM   M   MM 000   00   C
C  AA    AA NN    NN  GGGGGG   CCCCCC  LLLLLLLL MM       MM  000000    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGCLM0 EVALUATES THE ANGULAR COEFFICIENTS OF THE COULOMB           C
C  INTERACTIONS FOR CLOSED SHELLS IN THE (L1,L2) MANIFOLD.             C
C**********************************************************************C
      PARAMETER(MKP=9,MNU=MKP+1)
C
      CHARACTER*4 HMLTN
C
      COMMON/ANGL/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4),
     &            NUS(MNU),NUNUM,NUI,NUF
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     CALCULATE KQNA AND 2*JQNA VALUES FROM LQNA
      KLA =-LQNA-1
      KRA = LQNA
      JLA = 2*IABS(KLA)-1
      JRA = 2*IABS(KRA)-1
C
C     CALCULATE KQNB AND 2*JQNB VALUES FROM LQNB
      KLB =-LQNB-1
      KRB = LQNB
      JLB = 2*IABS(KLB)-1
      JRB = 2*IABS(KRB)-1
C
C     GENERATE LIST OF FACTORIALS
      CALL FACTRLS
C
C     START AND END PARAMETERS FROM TRIANGLE RULE
      NUI = IABS(LQNA-LQNB)
      NUF = LQNA+LQNB+1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 0
      DO NU=NUI,NUF
C
C       TEST WHETHER 'LQNA+LQNB+NU' ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.1) THEN
C       ONLY ANGULAR COEFFICIENTS OF EVEN PARITY ARE NON-ZERO
C
C         SAVE THIS TENSOR ORDER
          LTEN       = LTEN+1
          NUS(LTEN)  = NU
C
          IF(HMLTN.EQ.'NORL') THEN
            BK(LTEN,4) = 0.5D0*ABC000(LQNA,LQNB,NU)
          ELSE
            BK(LTEN,1) = SYM3JSQ(JRA,JRB,NU)
            BK(LTEN,2) = SYM3JSQ(JLA,JRB,NU)
            BK(LTEN,3) = SYM3JSQ(JRA,JLB,NU)
            BK(LTEN,4) = SYM3JSQ(JLA,JLB,NU)
          ENDIF
        ENDIF
C
      ENDDO
C
C     NUMBER OF SURVIVING TENSOR ORDERS
      NUNUM = LTEN
C
      RETURN
      END
C
C
      SUBROUTINE ANGBRT0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        AA    NN    NN  GGGGGG  BBBBBBB  RRRRRRR TTTTTTTT 000000      C
C       AAAA   NNN   NN GG    GG BB    BB RR    RR   TT   00   000     C
C      AA  AA  NNNN  NN GG       BB    BB RR    RR   TT   00  0000     C
C     AA    AA NN NN NN GG       BBBBBBB  RR    RR   TT   00 00 00     C
C     AAAAAAAA NN  NNNN GG   GGG BB    BB RRRRRRR    TT   0000  00     C
C     AA    AA NN   NNN GG    GG BB    BB RR    RR   TT   000   00     C
C     AA    AA NN    NN  GGGGGG  BBBBBBB  RR    RR   TT    000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGBRT0 EVALUATES ANGULAR COEFFICIENTS OF THE ATOMIC CLOSED SHELL   C
C  BREIT INTERACTION FOR ALL (K1,K2) VALUES IN THE MANIFOLD (L1,L2).   C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    NUNUM - NUMBER OF NU VALUES THAT SATISFY PARITY RESTRICTION RULE. C
C    NUI - MINIMUM NU VALUE IN THIS MANIFOLD.                          C
C    NUF - MAXIMUM NU VALUE IN THIS MANIFOLD.                          C
C    ELL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;LL) TERMS    C
C    ESS(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SS) TERMS    C
C    ESL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SL) TERMS    C
C    GSL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SL) TERMS    C
C**********************************************************************C
      PARAMETER(MKP=9,MNU=MKP+1)
C
      DIMENSION SCOEF(4,2)
C
      COMMON/ANGL/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4),
     &            NUS(MNU),NUNUM,NUI,NUF
      COMMON/BSQN/NBASA,NBASB,LQNA,LQNB,MAXM
C
C     INITIALISE COEFFICIENT ARRAYS
      DO LTEN=1,MNU
        DO N=1,4
          ELL(LTEN,N) = 0.0D0
          ESS(LTEN,N) = 0.0D0
          ESL(LTEN,N) = 0.0D0
          GSL(LTEN,N) = 0.0D0
        ENDDO
        NUS(LTEN) = 0
      ENDDO
      NUNUM = 0
C
C     CALCULATE KQNA AND 2*JQNA VALUES FROM LQNA
      KLA =-LQNA-1
      KRA = LQNA
      JLA = 2*IABS(KLA)-1
      JRA = 2*IABS(KRA)-1
C
C     CALCULATE KQNB AND 2*JQNB VALUES FROM LQNB
      KLB =-LQNB-1
      KRB = LQNB
      JLB = 2*IABS(KLB)-1
      JRB = 2*IABS(KRB)-1
C
C     GENERATE LIST OF FACTORIALS
      CALL FACTRLS
C
C**********************************************************************C
C     (4) JLA AND JLB               (REQUIRED FOR ALL BLOCKS)          C
C**********************************************************************C
C
C     START AND END PARAMETERS FROM TRIANGLE RULE
      NUI = IABS(JLA-JLB)/2
      NUF =     (JLA+JLB)/2
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JLA,JLB,NU)
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.0.AND.NU.NE.0) THEN
C       CASE 1: ANGULAR COEFFICIENTS OF ODD PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          RNU  = DFLOAT(NU*(NU+1))
          COEF = DFLOAT((KLA+KLB)*(KLA+KLB))/RNU
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,4) = ELL(LTEN,4) + COEF*RAW
          ESS(LTEN,4) = ESS(LTEN,4) + COEF*RAW
          ESL(LTEN,4) = ESL(LTEN,4) + COEF*RAW
C
        ELSEIF(IPARAB.EQ.1) THEN
C       CASE 2: ANGULAR COEFFICIENTS OF EVEN-PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEF,KLA,KLB,NU)
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN)  = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,4) = ELL(LTEN,4) - SCOEF(1,1)*RAW
          ESL(LTEN,4) = ESL(LTEN,4) - SCOEF(2,1)*RAW
          ESS(LTEN,4) = ESS(LTEN,4) - SCOEF(3,1)*RAW
          GSL(LTEN,4) = GSL(LTEN,4) - SCOEF(4,1)*RAW
C
C         STEP PARAMETER FOR ADDITIONS TO COEFFICIENTS
          IF(NU.GT.0) THEN
            LTEN = LTEN + 1
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN)  = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,4) = ELL(LTEN,4) - SCOEF(1,2)*RAW
          ESL(LTEN,4) = ESL(LTEN,4) - SCOEF(2,2)*RAW
          ESS(LTEN,4) = ESS(LTEN,4) - SCOEF(3,2)*RAW
          GSL(LTEN,4) = GSL(LTEN,4) - SCOEF(4,2)*RAW
C
        ENDIF
C
      ENDDO
C
C     ADJUST NUNUM IF NECESSARY
      NUNUM = MAX(LTEN,NUNUM)
C
C**********************************************************************C
C     (3) JRA AND JLB                (NEED KQNA > 0 BLOCK)             C
C**********************************************************************C
C
      IF(LQNA.EQ.0) GOTO 203
C
C     START AND END PARAMETERS FROM TRIANGLE RULE
      NUI = IABS(JRA-JLB)/2
      NUF =     (JRA+JLB)/2
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JRA,JLB,NU)
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.0.AND.NU.NE.0) THEN
C       CASE 1: ANGULAR COEFFICIENTS OF ODD PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          RNU  = DFLOAT(NU*(NU+1))
          COEF = DFLOAT((KRA+KLB)*(KRA+KLB))/RNU
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN)  = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,3) = ELL(LTEN,3) + COEF*RAW
          ESS(LTEN,3) = ESS(LTEN,3) + COEF*RAW
          ESL(LTEN,3) = ESL(LTEN,3) + COEF*RAW
C
        ELSEIF(IPARAB.EQ.1) THEN
C       CASE 2: ANGULAR COEFFICIENTS OF EVEN-PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEF,KRA,KLB,NU)
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,3) = ELL(LTEN,3) - SCOEF(1,1)*RAW
          ESL(LTEN,3) = ESL(LTEN,3) - SCOEF(2,1)*RAW
          ESS(LTEN,3) = ESS(LTEN,3) - SCOEF(3,1)*RAW
          GSL(LTEN,3) = GSL(LTEN,3) - SCOEF(4,1)*RAW
C
C         STEP PARAMETER FOR ADDITIONS TO COEFFICIENTS
          IF(NU.GT.0) THEN
            LTEN = LTEN + 1
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,3) = ELL(LTEN,3) - SCOEF(1,2)*RAW
          ESL(LTEN,3) = ESL(LTEN,3) - SCOEF(2,2)*RAW
          ESS(LTEN,3) = ESS(LTEN,3) - SCOEF(3,2)*RAW
          GSL(LTEN,3) = GSL(LTEN,3) - SCOEF(4,2)*RAW
C
        ENDIF
      ENDDO
C
C     ADJUST NUNUM IF NECESSARY
      NUNUM = MAX(LTEN,NUNUM)
C
203   CONTINUE
C
C**********************************************************************C
C     (2) JLA AND JRB               (NEED KQNB > 0 BLOCK)              C
C**********************************************************************C
C
      IF(LQNB.EQ.0) GOTO 202
C
C     START AND END PARAMETERS FROM TRIANGLE RULE
      NUI = IABS(JLA-JRB)/2
      NUF =     (JLA+JRB)/2
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JLA,JRB,NU)
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.0.AND.NU.NE.0) THEN
C       CASE 1: ANGULAR COEFFICIENTS OF ODD PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          RNU  = DFLOAT(NU*(NU+1))
          COEF = DFLOAT((KLA+KRB)*(KLA+KRB))/RNU
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,2) = ELL(LTEN,2) + COEF*RAW
          ESS(LTEN,2) = ESS(LTEN,2) + COEF*RAW
          ESL(LTEN,2) = ESL(LTEN,2) + COEF*RAW
C
        ELSEIF(IPARAB.EQ.1) THEN
C       CASE 2: ANGULAR COEFFICIENTS OF EVEN-PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEF,KLA,KRB,NU)
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,2) = ELL(LTEN,2) - SCOEF(1,1)*RAW
          ESL(LTEN,2) = ESL(LTEN,2) - SCOEF(2,1)*RAW
          ESS(LTEN,2) = ESS(LTEN,2) - SCOEF(3,1)*RAW
          GSL(LTEN,2) = GSL(LTEN,2) - SCOEF(4,1)*RAW
C
C         STEP PARAMETER FOR ADDITIONS TO COEFFICIENTS
          IF(NU.GT.0) THEN
            LTEN = LTEN + 1
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN)  = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,2) = ELL(LTEN,2) - SCOEF(1,2)*RAW
          ESL(LTEN,2) = ESL(LTEN,2) - SCOEF(2,2)*RAW
          ESS(LTEN,2) = ESS(LTEN,2) - SCOEF(3,2)*RAW
          GSL(LTEN,2) = GSL(LTEN,2) - SCOEF(4,2)*RAW
C
        ENDIF
      ENDDO
C
C     ADJUST NUNUM IF NECESSARY
      NUNUM = MAX(LTEN,NUNUM)
C
202   CONTINUE
C
C**********************************************************************C
C     (1) JRA AND JRB               (NEED KQNA,KQNB > 0 BLOCK)         C
C**********************************************************************C
C
      IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 201
C
C     START AND END PARAMETERS FROM TRIANGLE RULE
      NUI = IABS(JRA-JRB)/2
      NUF =     (JRA+JRB)/2
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JRA,JRB,NU)
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.0.AND.NU.NE.0) THEN
C       CASE 1: ANGULAR COEFFICIENTS OF ODD PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          RNU  = DFLOAT(NU*(NU+1))
          COEF = DFLOAT((KRA+KRB)*(KRA+KRB))/RNU
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,1) = ELL(LTEN,1) + COEF*RAW
          ESS(LTEN,1) = ESS(LTEN,1) + COEF*RAW
          ESL(LTEN,1) = ESL(LTEN,1) + COEF*RAW
C
        ELSEIF(IPARAB.EQ.1) THEN
C       CASE 2: ANGULAR COEFFICIENTS OF EVEN-PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEF,KRA,KRB,NU)
C
          NUS(LTEN)  = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,1) = ELL(LTEN,1) - SCOEF(1,1)*RAW
          ESL(LTEN,1) = ESL(LTEN,1) - SCOEF(2,1)*RAW
          ESS(LTEN,1) = ESS(LTEN,1) - SCOEF(3,1)*RAW
          GSL(LTEN,1) = GSL(LTEN,1) - SCOEF(4,1)*RAW
C
C         STEP PARAMETER FOR ADDITIONS TO COEFFICIENTS
          IF(NU.GT.0) THEN
            LTEN = LTEN + 1
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN)  = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,1) = ELL(LTEN,1) - SCOEF(1,2)*RAW
          ESL(LTEN,1) = ESL(LTEN,1) - SCOEF(2,2)*RAW
          ESS(LTEN,1) = ESS(LTEN,1) - SCOEF(3,2)*RAW
          GSL(LTEN,1) = GSL(LTEN,1) - SCOEF(4,2)*RAW
C
        ENDIF
      ENDDO
C
C     ADJUST NUNUM IF NECESSARY
      NUNUM = MAX(LTEN,NUNUM)
C
201   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BRCOEF0(SCOEFF,KA,KB,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB  RRRRRRR   CCCCCC   OOOOOO  EEEEEEEE FFFFFFFF 000000      C
C    BB    BB RR    RR CC    CC OO    OO EE       FF      00   000     C
C    BB    BB RR    RR CC       OO    OO EE       FF      00  0000     C
C    BBBBBBB  RR    RR CC       OO    OO EEEEEE   FFFFFF  00 00 00     C
C    BB    BB RRRRRRR  CC       OO    OO EE       FF      0000  00     C
C    BB    BB RR    RR CC    CC OO    OO EE       FF      000   00     C
C    BBBBBBB  RR    RR  CCCCCC   OOOOOO  EEEEEEEE FF       000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRCOEF0 EVALUATES THE INTERMEDIATE COEFFICIENTS OF THE BREIT        C
C  INTERACTION FOR CLOSED SHELLS (TABLE 3 OF GRANT AND PYPER 1976).    C
C**********************************************************************C
      DIMENSION SCOEFF(4,2)
C
      RU  = DFLOAT(NU)
      RK  = DFLOAT(KB-KA)
C
      IF(NU-1.GE.0) THEN
        NM = NU-1
        RM = RU-1.0D0
        B1 = DFLOAT(NM+2)/DFLOAT(2*(2*NM+1))
        C1 =-DFLOAT(NM-1)/DFLOAT(2*(2*NM+1)*NU)
        SCOEFF(1,1) =-(RU+RK)*(C1*RK+B1)
        SCOEFF(2,1) =  B1*RU - C1*RK*RK
        SCOEFF(3,1) =-(RU-RK)*(B1-C1*RK)
        SCOEFF(4,1) = RK*(B1-C1*RU)
      ELSE
        SCOEFF(1,1) = 0.0D0
        SCOEFF(2,1) = 0.0D0
        SCOEFF(3,1) = 0.0D0
        SCOEFF(4,1) = 0.0D0
      ENDIF
C
      IF(NU+1.GE.1) THEN
        NP = NU+1
        RP = RU+1.0D0
        B2 = DFLOAT(NP-1)/DFLOAT(2*   (2*NP+1))
        C2 = DFLOAT(NP+2)/DFLOAT(2*NP*(2*NP+1))
        SCOEFF(1,2) =-(RK-RP)*( C2*B2+RK)
        SCOEFF(2,2) =- B2*RP  + C2*RK*RK
        SCOEFF(3,2) = (RK+RP)*( B2-C2*RK)
        SCOEFF(4,2) =-RK*(B2+C2*RP)
      ELSE
        SCOEFF(1,2) = 0.0D0
        SCOEFF(2,2) = 0.0D0
        SCOEFF(3,2) = 0.0D0
        SCOEFF(4,2) = 0.0D0
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ABC000(L1,L2,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           AA    BBBBBBB   CCCCCC   000000   000000   000000          C
C          AAAA   BB    BB CC    CC 00   000 00   000 00   000         C
C         AA  AA  BB    BB CC       00  0000 00  0000 00  0000         C
C        AA    AA BBBBBBB  CC       00 00 00 00 00 00 00 00 00         C
C        AAAAAAAA BB    BB CC       0000  00 0000  00 0000  00         C
C        AA    AA BB    BB CC    CC 000   00 000   00 000   00         C
C        AA    AA BBBBBBB   CCCCCC   000000   000000   000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ABC000 EVALUATES THE NON-RELATIVISTIC 3-J SYMBOL FOR ATOMIC COULOMB C
C  ANGULAR COEFFICIENT ROUTINES, TAKEN FROM BRINK AND SATCHLER.        C
C  L1,L2, AND K MUST BE EQUAL TO THE ACTUAL (INTEGER) ANGULAR MOMENTA  C
C  OF THE ELECTRON AND PHOTON.                                         C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:20),SFACT(0:20)
C
C     TRIANGLE INEQUALITY RESTRICTIONS
      IF(K.LT.IABS(L1-L2).OR.K.GT.(L1+L2)) THEN
        ABC000 = 0.0D0
        RETURN
      ENDIF
      LLK = L1+L2+K
C
C     PARITY SELECTION RULE
      IF((LLK/2)*2.NE.LLK) THEN
        ABC000 = 0.0D0
        RETURN
      ENDIF
C
      RF1 = RFACT(  L1+L2-K   )
      RF2 = RFACT(- L1+L2+K   )
      RF3 = RFACT(  L1-L2+K   )
      RF4 = RFACT(  L1+L2+K +1)
      RF5 = RFACT(( L1+L2+K)/2)
      RF6 = RFACT(( L1+L2-K)/2)
      RF7 = RFACT(( L1-L2+K)/2)
      RF8 = RFACT((-L1+L2+K)/2)
C
      T1  = RF1*RF2*RF3
      T2  = T1/RF4
      T3  = RF6*RF7*RF8
      T4  = RF5/T3
C
      ABC000 = T2*T4*T4
C
      RETURN
      END
C
C
      FUNCTION SYM3JSQ(J1,J2,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS  YY    YY MM       MM  333333       JJJJ SSSSSS   QQQQQQ    C
C  SS    SS YY    YY MMM     MMM 33    33       JJ SS    SS QQ    QQ   C
C  SS       YY    YY MMMM   MMMM       33       JJ SS       QQ    QQ   C
C   SSSSSS   YY  YY  MM MM MM MM    3333        JJ  SSSSSS  QQ    QQ   C
C        SS   YYYY   MM  MMM  MM       33       JJ       SS QQ   QQQ   C
C  SS    SS    YY    MM   M   MM  33   33 JJ    JJ SS    SS QQ    QQ   C
C   SSSSSS     YY    MM       MM   33333   JJJJJJ   SSSSSS   QQQQQQ Q  C
C                                                                      C
C -------------------------------------------------------------------- C
C  SYM3JSQ EVALUATES THE SQUARE OF A 3-J SYMBOL,   /  j   K   j' \^2   C
C  WHERE j = J1/2 AND j' = J2/2, FOR THE           \-1/2  0  1/2 /     C
C  COULOMB/BREIT ANGULAR COEFFICIENT ROUTINES.                         C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:20),SFACT(0:20)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(K.LT.IABS((J1-J2)/2).OR.K.GT.(J1+J2)/2) THEN
        SYM3JSQ = 0.0D0
        RETURN
      ELSEIF(J1.LE.0.OR.J2.LE.0) THEN
        SYM3JSQ = 0.0D0
        RETURN
      ENDIF
C
C     VARIABLE WHICH DEPENDS ON PARITY OF ARGUMENTS
      JJK = (J1+J2)/2 + K
      IF((JJK/2)*2.EQ.JJK) THEN
        M = K
      ELSE
        M = K+1
      ENDIF
C
      RN1 = RFACT(( J1+J2)/2 - K)
      RN2 = RFACT((-J1+J2)/2 + K)
      RN3 = RFACT(( J1-J2)/2 + K)
      RN4 = SFACT(( J1+J2)/2 + M)
      RD1 = DFLOAT(J1+1)
      RD2 = DFLOAT(J2+1)
      RD3 = RFACT(( J1+J2)/2 + K + 1)
      RD4 = SFACT(( J1+J2)/2 - M    )
      RD5 = SFACT(( J1-J2)/2 + M - 1)
      RD6 = SFACT((-J1+J2)/2 + M - 1)
      PHS = (-1.0D0)**((J2-(3*J1))/2+M)
C
      RNUM  = RN1*RN2*RN3*(RN4)**2
      RDEN  = RD1*RD2*RD3*(RD4*RD5*RD6)**2
C
      SYM3JSQ = PHS*RNUM/RDEN
C
      RETURN
      END
C
C
      SUBROUTINE UEHLING0(UMAT,EXL,ZCRG,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  UU    UU EEEEEEEE HH    HH LL      IIII NN    NN  GGGGGG   000000   C
C  UU    UU EE       HH    HH LL       II  NNN   NN GG    GG 00   000  C
C  UU    UU EE       HH    HH LL       II  NNNN  NN GG       00  0000  C
C  UU    UU EEEEEE   HHHHHHHH LL       II  NN NN NN GG       00 00 00  C
C  UU    UU EE       HH    HH LL       II  NN  NNNN GG   GGG 0000  00  C
C  UU    UU EE       HH    HH LL       II  NN   NNN GG    GG 000   00  C
C   UUUUUU  EEEEEEEE HH    HH LLLLLLL IIII NN    NN  GGGGGG   000000   C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHLING0 GENERATES ATOMIC UEHLING INTERACTION MATRIX FOR KQNA.      C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      DIMENSION RN(MBS*MBS,4),UMAT(2*MBS,2*MBS),EXL(MBS)
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
      DATA PI/3.1415926535897932D0/
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      G  = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     COMPTON WAVELENGTH FOR COUPLING TO THE ELECTRON FIELD
      CMP = 1.0D0/CV
C
C     PRE-FACTOR COMMON TO ALL MATRIX ELEMENTS
      VCF = 6.0D0*CV*PI
      VCF =-ZCRG/VCF
C
C     CHARGE MOMENT FACTOR
      FCT = 1.0D0/(PNUC*CMP*CMP)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M    = M+1
          EJ   = EXL(JBAS)
          EIJ  = EI+EJ
          EPR  = EI*EJ
          T52  = RL+2.5D0
          E52  = EIJ**T52
C
C         LL OVERLAP
          UMAT(IBAS,JBAS) = VCF*RN(M,1)*UEHINT0(LQN+1,EIJ)/EIJ
C
C         SS OVERLAP
          IF(HMLTN.EQ.'NORL') GOTO 50
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBAS
          LBAS = JBAS+NBAS
C
          VSA = 4.0D0*EPR*UEHINT0(LQN+2,EIJ)
          IF(KQN.GT.0) THEN
            VSN =-2.0D0*EIJ*G*UEHINT0(LQN+1,EIJ)
     &                  + G*G*UEHINT0(LQN  ,EIJ)
          ELSE
            VSN = 0.0D0
          ENDIF
C
          UMAT(KBAS,LBAS) = VCF*RN(M,3)*(VSA+VSN)
C
50        CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION UEHINT0(N,ZETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       UU    UU EEEEEEEE HH    HH IIII NN    NN TTTTTTTT 000000       C
C       UU    UU EE       HH    HH  II  NNN   NN    TT   00   000      C
C       UU    UU EE       HH    HH  II  NNNN  NN    TT   00  0000      C
C       UU    UU EEEEEE   HHHHHHHH  II  NN NN NN    TT   00 00 00      C
C       UU    UU EE       HH    HH  II  NN  NNNN    TT   0000  00      C
C       UU    UU EE       HH    HH  II  NN   NNN    TT   000   00      C
C        UUUUUU  EEEEEEEE HH    HH IIII NN    NN    TT    000000       C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHINT0 CALCULATES AN ATOMIC UEHLING POTENTIAL OVERLAP INTEGRAL     C
C  FOR A LOCAL GAUSSIAN NUCLEAR CHARGE DISTRIBUTION.                   C
C -------------------------------------------------------------------- C
C  DFNOTE: AT THE MOMENT THIS IS JUST A COPY OF BNUCINT0.              C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9)
C
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     ROUTINE ONLY ALLOWS ODD PARAMETERS N
      IF(MOD(N,2).NE.1) THEN
        WRITE(6, *) 'In UEHINT0: order N must be odd. N = ',N
        WRITE(7, *) 'In UEHINT0: order N must be odd. N = ',N
      ENDIF
C
C     FACTORS NEEDED FOR ALL PARAMETERS N
      X   = ZETA/PNUC
      X5  = X*X*X*X*X
      T0  = PNUC+ZETA
      RAT = PNUC/T0
      TRM = 0.5D0*DSQRT(PNUC)/ZETA/DSQRT(T0)
      DO I=1,(N-1)/2
        TRM = 0.5D0*TRM*RAT/ZETA
      ENDDO
C
      IF(N.EQ.1) THEN
        TRM = TRM
      ELSEIF(N.EQ.3) THEN
        VA  = 2.0D0 + 3.0D0*X
        TRM = TRM*VA
      ELSEIF(N.EQ.5) THEN
        VA  = 8.0D0 + 20.0D0*X + 15.0D0*X*X
        TRM = TRM*VA
      ELSEIF(N.EQ.7) THEN
        VA  = 16.0D0 + 56.0D0*X + 70.0D0*X*X + 35.0D0*X*X*X
        TRM = 3.0D0*TRM*VA
      ELSEIF(N.EQ.9) THEN
        VA  = 128.0D0 + 576.0D0*X + 1008.0D0*X*X + 840.0D0*X*X*X
        VB  = 315.0D0*X*X*X*X
        TRM = 3.0D0*TRM*(VA+VB)
      ELSEIF(N.EQ.11) THEN
        VA  = 256.0D0 + 1408.0D0*X + 3168.0D0*X*X + 3696.0D0*X*X*X
        VB  = 2310.0D0*X*X*X*X + 693.0D0*X*X*X*X*X
        TRM = 15.0D0*TRM*(VA+VB)
      ELSEIF(N.EQ.13) THEN
        VA  = 1024.0D0 + 6656.0D0*X + 18304.0D0*X*X
        VB  = 27456.0D0*X*X*X + 24024.0D0*X*X*X*X
        VC  = 12012.0D0*X5 + 3003.0D0*X5*X
        TRM = 45.0D0*TRM*(VA+VB+VC)
      ELSEIF(N.EQ.15) THEN
        VA  = 2048.0D0 + 15360.0D0*X + 49920.0D0*X*X
        VB  = 91520.0D0*X*X*X+ 102960.0D0*X*X*X*X + 72072.0D0*X5
        VC  = 30030.0D0*X5*X + 6435.0D0*X5*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC)
      ELSEIF(N.EQ.17) THEN
        VA  = 32768.0D0 + 278528.0D0*X + 1044480.0D0*X*X
        VB  = 2263040.0D0*X*X*X + 3111680.0D0*X*X*X*X
        VC  = 2800512.0D0*X5 + 1633632.0D0*X5*X + 583440.0D0*X5*X*X
        VD  = 109395.0D0*X5*X*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(N.EQ.19) THEN
        VA  = 65536.0D0 + 6222592.0D0*X + 2646016.0D0*X*X
        VB  = 6615040.0D0*X*X*X + 10749440.0D0*X*X*X*X
        VC  = 11824384.0D0*X5 + 8868288.0D0*X5*X + 4434144.0D0*X5*X*X
        VD  = 1385670.0D0*X5*X*X*X + 230945.0D0*X5*X*X*X*X
        TRM = 2835.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(N.EQ.21) THEN
        VA  = 262144.0D0 + 2752512.0D0*X + 13074432.0D0*X*X
        VB  = 37044224.0D0*X*X*X + 69457920.0D0*X*X*X*X
        VC  = 90295296.0D0*X5 + 82770688.0D0*X5*X
        VD  = 53209728.0D0*X5*X*X + 23279256.0D0*X5*X*X*X
        VE  = 6466460.0D0*X5*X*X*X*X + 969969.0D0*X5*X5
        TRM = 14175.0D0*TRM*(VA+VB+VC+VD+VE)
      ELSE
        WRITE(6, *) 'In UEHINT0: order N too large. N = ',N
        WRITE(7, *) 'In UEHINT0: order N too large. N = ',N
      ENDIF
C
C     TRANSFER DATA TO UEHINT0
      UEHINT0 = TRM
C
      RETURN
      END
C
C
      SUBROUTINE RNORM0(RN,EXL,NBAS,LQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       RRRRRRR  NN    NN  OOOOOO  RRRRRRR  MM       MM  000000        C
C       RR    RR NNN   NN OO    OO RR    RR MMM     MMM 00   000       C
C       RR    RR NNNN  NN OO    OO RR    RR MMMM   MMMM 00  0000       C
C       RR    RR NN NN NN OO    OO RR    RR MM MM MM MM 00 00 00       C
C       RRRRRRR  NN  NNNN OO    OO RRRRRRR  MM  MMM  MM 0000  00       C
C       RR    RR NN   NNN OO    OO RR    RR MM   M   MM 000   00       C
C       RR    RR NN    NN  OOOOOO  RR    RR MM       MM  000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNORM0 EVALUATES NORMALISATION CONSTANTS OF ALL VARIETIES.          C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS)
C
      DIMENSION RN(MB2,4),EXL(MBS),RNL(MBS),RNS(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
C
      DATA TWOLOG/6.93147180559945309D-1/
C
      RLQN = DFLOAT(LQN)
      G1   = TWOLOG - GAMLOG(2*LQN+3)
      G2   = TWOLOG - GAMLOG(2*LQN+5)
      R1   = RLQN + 1.5D0
      R2   = RLQN + 0.5D0
      DO IBAS=1,NBAS
        ELOG      = DLOG(2.0D0*EXL(IBAS))
        RNL(IBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNS(IBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     RN(M,1) ARE THE LL NORMALISATION CONSTANTS
C     RN(M,2) ARE THE SL NORMALISATION CONSTANTS
C     RN(M,3) ARE THE SS NORMALISATION CONSTANTS
C     RN(M,4) ARE THE LS NORMALISATION CONSTANTS
C
      M = 0
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          M = M+1
          RN(M,1) = RNL(IBAS)*RNL(JBAS)
          RN(M,2) = RNS(IBAS)*RNL(JBAS)
          RN(M,3) = RNS(IBAS)*RNS(JBAS)
          RN(M,4) = RNL(IBAS)*RNS(JBAS)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GAMGEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG     AA    MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C       GG    GG   AAAA   MMM     MMM GG    GG EE       NNN   NN       C
C       GG        AA  AA  MMMM   MMMM GG       EE       NNNN  NN       C
C       GG       AA    AA MM MM MM MM GG       EEEEEE   NN NN NN       C
C       GG   GGG AAAAAAAA MM  MMM  MM GG   GGG EE       NN  NNNN       C
C       GG    GG AA    AA MM   M   MM GG    GG EE       NN   NNN       C
C        GGGGGG  AA    AA MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMGEN EVALUATES INTEGER/HALF-INTEGER GAMMA VALUES AND THEIR LOGS.  C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    GAMLOG(N) = DLOG(GAMMA(N/2))                                      C
C    GAMHLF(N) = GAMMA(N/2)                                            C
C**********************************************************************C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
C
      DATA ROOTPI,RTPILG/1.7724538509055160D0,5.7236494292470009D-1/
C
C     STARTING VALUES
      GAMLOG(1) = RTPILG
      GAMLOG(2) = 0.0D0
      GAMHLF(1) = ROOTPI
      GAMHLF(2) = 1.0D0
C
C     SEED VALUES FOR INCREMENT
      F1 = 0.5D0
      F2 = 1.0D0
C
C     FILL TABLE VALUES
      DO N=4,50,2
        GAMLOG(N-1) = GAMLOG(N-3) + DLOG(F1)
        GAMLOG(N  ) = GAMLOG(N-2) + DLOG(F2)
        GAMHLF(N-1) = GAMHLF(N-3)*F1
        GAMHLF(N  ) = GAMHLF(N-2)*F2
        F1 = F1 + 1.0D0
        F2 = F2 + 1.0D0
      ENDDO
C
      RETURN
      END
C
C
       SUBROUTINE FACTRLS
       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     FFFFFFFF   AA     CCCCCC TTTTTTTT RRRRRRR  LL       SSSSSS       C
C     FF        AAAA   CC    CC   TT    RR    RR LL      SS    SS      C
C     FF       AA  AA  CC         TT    RR    RR LL      SS            C
C     FFFFFF  AA    AA CC         TT    RR    RR LL       SSSSSS       C
C     FF      AAAAAAAA CC         TT    RRRRRRR  LL            SS      C
C     FF      AA    AA CC    CC   TT    RR    RR LL      SS    SS      C
C     FF      AA    AA  CCCCCC    TT    RR    RR LLLLLLLL SSSSSS       C
C                                                                      C
C -------------------------------------------------------------------- C
C  FACTRLS GENERATES A SET OF N! AND N!! AS REAL NUMBERS.              C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    RFACT - REGULAR FACTORIALS, RFACT(N) = N!                         C
C    SFACT - SEMI-FACTORIALS,    SFACT(N) = N!!                        C
C**********************************************************************C
C
      COMMON/FCTS/RFACT(0:20),SFACT(0:20)
C
      RFACT(0) = 1.0D0
      RFACT(1) = 1.0D0
      SFACT(0) = 1.0D0
      SFACT(1) = 1.0D0
      DO I=2,20
        RNUMBER  = DFLOAT(I)
        RFACT(I) = RNUMBER*RFACT(I-1)
        SFACT(I) = RNUMBER*SFACT(I-2)
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTER SCF CALCULATIONS.          C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] HFSCF: MAIN ROUTINE FOR MOLECULAR HARTREE-FOCK SCF PROCEDURE.  C
C   [B] OVRLP: CONSTRUCTS THE ONE-ELECTRON OVERLAP MATRIX.             C
C   [C] ONEEL: ONE-ELECTRON MULTI-CENTER MATRIX OF INTEGRALS.          C
C   [D] UEHLING: CONSTRUCTS MULTI-CENTER UEHLING MATRIX ELEMENTS.      C
C   [E] COULOMB: CONSTRUCTS ALL MULTI-CENTER COULOMB SCF ELEMENTS.     C
C   [F] ERI: GENERATES A BLOCK OF ELECTRON REPULSION INTEGRALS.        C
C   [G] CLMMAT: MULTIPLIES BATCH FROM RR BY DENSITIES, ADDS TO GMAT.   C
C   [H] BREIT: MATRIX REP OF MEAN-FIELD BREIT INTERACTION.             C
C   [I] BII: GENERATES A BLOCK OF BREIT INTERACTION INTEGRALS.         C
C   [J] BRTMAT: MULTIPLIES BATCH FROM RR BY DENSITIES, ADDS TO BMAT.   C
C   [K] COULOMB1: CONTRSUCTS ALL ONE-CENTER COULOMB SCF ELEMENTS.      C
C   [L] BREIT1: CONTRSUCTS ALL ONE-CENTER BREIT SCF ELEMENTS.          C
C   [M] RABCD: EVALUATES ONE-CENTER RADIAL 2-BODY INTEGRALS.           C
C   [N] PREPIJ: CALCULATES I,J BASIS EXPONENT COMBINATIONS FOR RABCD.  C
C   [O] PREPKL: CALCULATES K,L BASIS EXPONENT COMBINATIONS FOR RABCD.  C
C   [P] ANGCLM1: ANGULAR TERMS FOR ONE-CENTER COULOMB INTEGRALS.       C
C   [Q] ANGBRT1: ANGULAR TERMS FOR ONE-CENTER BREIT INTEGRALS.         C
C   [R] BRCOEF1: INTERMEDIATE COUPLING TERMS FOR ABOVE BREIT INTEGRALS.C
C   [S] TESTANG: TESTS A FULL BATCH OF COMMON ANGULAR COEFFICIENTS.    C
C   [T] DK: ANGULAR AND CG-COEFFICIENT PRE-FACTORS FOR 'ANGLES'.       C
C   [U] SYM3J: EVALUATES A SINGLE WIGNER 3J-SYMBOL.                    C
C   [V] COUPLE: ESTABLISH OPEN/CLOSED SHELL COUPLING BETWEEN ARRAYS.   C
C   [W] SPARSITY: SEARCHES FOR VANISHING MATRIX ELEMTNS IN A MATRIX.   C
C   [X] NCART: RETURNS THE CARTESIAN INDEX FROM A LOOP INDEX.          C
C   [Y] NCNTRS: RETURNS NUMBER OF UNIQUE NUCLEAR CENTERS FROM INPUT.   C
C   [Z] ZPROJ: RETURNS A METRIC FOR Z-AXIS DEVIATION OF SOME COORDS.   C
C**********************************************************************CC
C
      SUBROUTINE HFSCF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              HH    HH FFFFFFFF SSSSSS   CCCCCC  FFFFFFFF             C
C              HH    HH FF      SS    SS CC    CC FF                   C
C              HH    HH FF      SS       CC       FF                   C
C              HHHHHHHH FFFFFF   SSSSSS  CC       FFFFFF               C
C              HH    HH FF            SS CC       FF                   C
C              HH    HH FF      SS    SS CC    CC FF                   C
C              HH    HH FF       SSSSSS   CCCCCC  FF                   C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  HFSCF PERFORMS A SINGLE-DETERMINANT ITERATIVE SELF-CONSISTENT FIELD C
C  PROCEDURE OVER THE USER-SPECIFIED HAMILTONIAN.                      C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9,LWK=64*MDM,MIT=200)
C
      CHARACTER*4  HMLTN
      CHARACTER*11 MS
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 TESTER,title
C
      DIMENSION RWORK(3*MDM),ESAV(0:MIT),DNRM(MIT),WEDN(MIT)
      DIMENSION NMLEV(4),TMLEV(4)
      DIMENSION ARRAY(MDM,MDM),btest(mdm,mdm)
C
      COMPLEX*16 WORK(LWK)
      COMPLEX*16 DTMP(MDM,MDM),OTMP(MDM,MDM),C(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGN/EIGEN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(3),SHLV
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/T2EL/F2ES(5,7),T2ES(5,7),N2EB(5,7),N2EI(5,7),N2ES(5,7)
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',23),'MOLECULAR HARTREE-FOCK SCF'
      WRITE(7, *) REPEAT(' ',23),'MOLECULAR HARTREE-FOCK SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME AT START OF MOLECULAR SCF CALCULATION
      CALL CPU_TIME(TSCF1)
C
C     PARAMETERS FOR COMPLETING STAGES
      ENRGLV1 = 1.0D-08
      ENRGLV2 = 5.0D-11
      ENRGTOL = 1.0D-12
      DSTYTOL = 1.0D-10
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
      CALL FACTRLS
C
C     INITIALISE ENERGY NORM STORAGE
      IF(INEW.EQ.0) THEN
        ESAV(0) = ETOT
      ELSE
        ESAV(0) = 1.0D0
      ENDIF
C
C     INITIALISE INTEGRAL INCLUSION LEVEL VALUES
      DO N=1,4
        NMLEV(N) = 0
        TMLEV(N) = 0.0D0
      ENDDO
C
C     INITIALISE ARRAYS AND TEMPORARY DENSITY MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          OVAP(I,J) = DCMPLX(0.0D0,0.0D0)
          HNUC(I,J) = DCMPLX(0.0D0,0.0D0)
          HKIN(I,J) = DCMPLX(0.0D0,0.0D0)
          VUEH(I,J) = DCMPLX(0.0D0,0.0D0)
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          FOCK(I,J) = DCMPLX(0.0D0,0.0D0)
          DTMP(I,J) = DENT(I,J)
        ENDDO
      ENDDO
C
C     IF READING IN PREVIOUS SOLUTION, CALCULATE MOLECULAR DENSITY
      IF(INEW.EQ.1) THEN
        CALL DENSTY
      ENDIF
C
C     CALCULATE THE FULL SET OF EQ-COEFFICIENTS
      CALL CPU_TIME(T1)
      IF(IEQS.EQ.1) THEN
        CALL EQFILE
      ENDIF
      CALL CPU_TIME(T2)
      TEPP = T2-T1
C
C     GENERATE DIAGONAL TWO-ELECTRON INTEGRALS FOR SCREENING LATER
      CALL CPU_TIME(T1)
      IF(NOELEC.GT.1) THEN
        IF(HMLTN.NE.'BARE') THEN
          CALL SELFCLM
          IF(HMLTN.NE.'NORL'.AND.HMLTN.NE.'DHFR') THEN
            CALL SELFBRT
          ENDIF
        ENDIF
      ENDIF
      CALL CPU_TIME(T2)
      TSCR = TSCR+T2-T1
C
C     PLOT THE MATRIX
C     TITLE = 'Coul_diag'
C     CALL ARRYPLT(GDSC,TITLE,NDIM)
C     STOP
C
C     PRINT THE FIRST INTEGRAL INCLUSION LEVEL
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      IF(ILEV.EQ.1) THEN
        WRITE(6,40)
        WRITE(7,40)
      ELSEIF(ILEV.EQ.2) THEN
        IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') THEN
          WRITE(6,41)
          WRITE(7,41)
        ELSE
          WRITE(6,42)
          WRITE(7,42)
        ENDIF
      ELSEIF(ILEV.EQ.3) THEN
        WRITE(6,43)
        WRITE(7,43)
      ENDIF
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      
      IF(HMLTN.EQ.'DHFP') GOTO 998
C
C       BREIT0 FIX
C       GENERATE MATRIX REP OF BREIT INTERACTION
c        CALL BREIT
C
C        OPEN(UNIT=8,FILE='plots/Molecular_BREIT.dat',STATUS='UNKNOWN')
C        REWIND(UNIT=8)
C        DO I=1,NDIM
Cc          WRITE(8, *) (dreal(bdir(i,j)-bxch(i,j)),J=1,NDIM)
C          WRITE(8, *) (dreal(bxch(i,j)),J=1,NDIM)
C        ENDDO
C        CLOSE(UNIT=8)
C
C**********************************************************************C
C     START OF SELF-CONSISTENT FIELD CALCULATIONS                      C
C**********************************************************************C
C
C     LOOP OVER ITERATIONS (SUCCESSFUL CONVERGENCE EXIT LATER)
      DO ITER=1,MIT
C
C       TIME AT START OF ITERATION
        CALL CPU_TIME(TMIT)
C
C       GENERATE ONE-BODY MATRIX AND OVERLAP MATRIX
        CALL CPU_TIME(T1)
        IF(ITER.EQ.1) THEN
          CALL OVRLP
          CALL ONEEL
        ENDIF
        CALL CPU_TIME(T2)
        T1EL = T2-T1
        THMX = THMX+T1EL
C
C       GENERATE UEHLING INTERACTION MATRIX
        CALL CPU_TIME(T1)
        IF(HMLTN.EQ.'DHFQ') THEN
          IF(ITER.EQ.1) THEN
            CALL UEHLING
          ENDIF
        ENDIF
        CALL CPU_TIME(T2)
        T1EL = T1EL+T2-T1
        THMX = THMX+T2-T1
C
C       RESET TWO-ELECTRON INTEGRAL SCREENING COUNTERS
        DO MCNT=1,5
          DO ITT=1,7
            N2EB(MCNT,ITT) = 0
            N2EI(MCNT,ITT) = 0
            N2ES(MCNT,ITT) = 0
            T2ES(MCNT,ITT) = 0.0D0
          ENDDO
        ENDDO
C
C       GENERATE MEAN-FIELD CLOSED- AND OPEN-SHELL COULOMB MATRIX
        IF(HMLTN.NE.'BARE'.AND.NOELEC.GT.1) THEN
C
C         BUILD HERMITIAN MATRIX FOR MANY-CENTER COULOMB CONTRIBUTIONS
          CALL CPU_TIME(T1)
          CALL COULOMB
          CALL CPU_TIME(T2)
          TCL2 = T2-T1
          TC2T = TC2T+TCL2
C
C         ADD ALL ONE-CENTER CONTRIBUTIONS (RACAH ALGEBRA)
          CALL CPU_TIME (T1)
          CALL COULOMB1
          CALL CPU_TIME(T2)
          TCL1 = T2-T1
          TC1T = TC1T+TCL1
C
        ELSE
C
          TCL1 = 0.0D0
          TCL2 = 0.0D0
C
        ENDIF
C
C       GENERATE MEAN-FIELD BREIT MATRIX
        IF((HMLTN.EQ.'DHFB'.OR.HMLTN.EQ.'DHFQ').AND.NOELEC.GT.1) THEN
C
C         BUILD HERMITIAN MATRIX FOR MANY-CENTER BREIT INTEGRALS
          CALL CPU_TIME(T1)
          CALL BREIT
          CALL CPU_TIME(T2)
          TBR2 = T2-T1
          TB2T = TB2T+TBR2
C
          TBR1 = 0.0D0
          TB1T = TB1T+TBR1
C
        ELSE
C
          TBR1 = 0.0D0
          TBR2 = 0.0D0
C
        ENDIF
C
C       ADD TWO- AND MANY-CENTER BINS TO (TT|TT) TOTALS
        DO MCNT=1,4
          DO ITT=1,6
            N2EB(5,ITT) = N2EB(5,ITT) + N2EB(MCNT,ITT)
            N2EI(5,ITT) = N2EI(5,ITT) + N2EI(MCNT,ITT)
            N2ES(5,ITT) = N2ES(5,ITT) + N2ES(MCNT,ITT)
            T2ES(5,ITT) = T2ES(5,ITT) + T2ES(MCNT,ITT)
          ENDDO
        ENDDO
C
C       ADD ALL (TT|TT) RESULTS TO TOTALS
        DO MCNT=1,5
          DO ITT=1,6
            N2EB(MCNT,7) = N2EB(MCNT,7) + N2EB(MCNT,ITT)
            N2EI(MCNT,7) = N2EI(MCNT,7) + N2EI(MCNT,ITT)
            N2ES(MCNT,7) = N2ES(MCNT,7) + N2ES(MCNT,ITT)
            T2ES(MCNT,7) = T2ES(MCNT,7) + T2ES(MCNT,ITT)
          ENDDO
        ENDDO
C
C       FRACTION OF BLOCKS SCREENED
        DO MCNT=1,5
          DO ITT=1,7
            IF(N2EI(MCNT,ITT).NE.0) THEN
              RATIO = DFLOAT(N2ES(MCNT,ITT))/DFLOAT(N2EI(MCNT,ITT))
              F2ES(MCNT,ITT) = 100.0D0*RATIO
            ELSE
              F2ES(MCNT,ITT) = 0.0D0
            ENDIF
          ENDDO
        ENDDO
C
C       ESTABLISH COUPLING BETWEEN CLOSED- AND OPEN-SHELL MATRIX REPS
        IF(HMLTN.NE.'BARE') THEN
          IF(NOELEC.GT.1.AND.NOPN.NE.0) THEN
            CALL COUPLE
          ENDIF
        ENDIF
C
C       CONSTRUCT FOCK MATRIX FROM ONE- AND TWO-BODY INTERACTIONS
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = HNUC(I,J) + HKIN(I,J) + GDIR(I,J) - GXCH(I,J)
     &                - QDIR(I,J) + QXCH(I,J) + BDIR(I,J) - BXCH(I,J)
     &                + VUEH(I,J)
          ENDDO
        ENDDO
C
C       UPDATE MOLECULAR ENERGIES (BASED ON *PREVIOUS* DENSITY D^{N-1})
        CALL ENERGIES
C
C       START TIMER ON MATRIX DIAGONALISATION PROCEDURE
        CALL CPU_TIME(T1)
C
C       IMPLEMENT SPARSITY CHECK ON FOCK MATRIX
        CALL SPARSITY(FOCK,NDIM,1.0D-10)
C
C       LEVEL-SHIFT THE VIRTUAL SPACE TO MAKE ORBITALS LESS ACCESSIBLE
        IF(INEW.NE.0.OR.ITER.NE.1) THEN
          CALL LEVSHFT(SHLV)
        ENDIF
        NMLEV(ILEV) = NMLEV(ILEV)+1
C
C       SAVE OVERLAP MATRIX IN TEMPORARY MATRIX (ZHEGV OVERWRITES IT)
        DO I=1,NDIM
          DO J=1,NDIM
            OTMP(I,J) = OVAP(I,J)
          ENDDO
        ENDDO
C
C       DIAGONALISE FOCK MATRIX (REQUIRES LAPACK LIBRARY)
        CALL ZHEGV(1,'V','L',NDIM,FOCK,MDM,OVAP,MDM,
     &                                       EIGEN,WORK,LWK,RWORK,INFO)
        IF(INFO.NE.0) THEN
          WRITE(6, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INFO
          WRITE(7, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INFO
        ENDIF
C
C       TRANSFER EIGENVECTORS TO THE C ARRAY AND RESTORE OVAP ARRAY
        DO J=1,NDIM
          DO I=1,NDIM
            C(I,J)    = FOCK(I,J)
            OVAP(I,J) = OTMP(I,J)
          ENDDO
        ENDDO
C
C       DEDUCT LEVEL SHIFT VALUE FROM VIRTUAL ORBITAL EIGENVALUES
        IF(ITER.NE.1) THEN
          DO IVIR=NSHIFT+NOCC+1,NDIM
            EIGEN(IVIR) = EIGEN(IVIR) - SHLV
          ENDDO
        ENDIF
C
C       WRITE EIGENVECTORS TO OUTPUT FILE
        OPEN(UNIT=8,FILE=TRIM(WFNFL),STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          WRITE(8, *) EIGEN(I),(C(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
C
C       MATRIX DIAGONALISATION COMPLEX
        CALL CPU_TIME(T2)
        TDGN = T2-T1
        TEIG = TEIG+TDGN
C
C       UPDATE THE DENSITY MATRIX
        CALL DENSTY
C
C       DENSITY DIFFERENCE NORM CALCULATION
        DNRM(ITER) = 0.0D0
        DO J=1,NDIM
          DO I=1,NDIM
            TMP        = ABS(DENT(I,J)-DTMP(I,J))
            DNRM(ITER) = DNRM(ITER)+TMP*TMP
            DTMP(I,J)  = DENT(I,J)
          ENDDO
        ENDDO
        RDM2 = DFLOAT(NDIM*NDIM)
        DNRM(ITER) = DSQRT(DNRM(ITER))/RDM2
C
C       IF DNRM IS SMALL ENOUGH, REDUCE REQUIREMENTS TO ENTER STAGE 3
        IF(DNRM(ITER).LE.1.0D-09) THEN
          ENRGLV2 = 1.0D+02*DNRM(ITER)
        ENDIF
C
C       WEIGHTED ENERGY DIFFERENCE NORM, WEDN
        DOFF = DABS(ETOT)+1.0D0
        WEDN(ITER) = DABS(ESAV(ITER-1)-ETOT)/DOFF
        ESAV(ITER) = ETOT
C
C       UPDATE TIME COUNTERS AT END OF ITERATION
        CALL CPU_TIME(TDON)
        TSTP = TDON-TMIT
        TMLEV(ILEV) = TMLEV(ILEV)+TSTP
C
C       DATE AND TIME AT END OF ITERATION
        CALL TIMENOW(STAMP)
C
C       HEADER FOR ITERATION SUMMARY
20      FORMAT(27X,A,1X,I3)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6,20) 'Iteration number',ITER
        WRITE(7,20) 'Iteration number',ITER
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       PRODUCE SPECTRUM SUMMARY AND INCLUDE FIRST 6 VIRTUAL STATES
        LF = LEN(TRIM(MOLCL))+LEN(TRIM(HMLTN))
        LF = 23-LF/2
21      FORMAT(1X,A,'Molecular spectrum for ',A,' (',A,')')
        WRITE(6,21) REPEAT(' ',LF),TRIM(MOLCL),TRIM(HMLTN)
        WRITE(7,21) REPEAT(' ',LF),TRIM(MOLCL),TRIM(HMLTN)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        CALL SPECTRM(NOCC,6)
C
C       MOLECULAR ENERGIES
22      FORMAT(1X,A,22X,F21.12)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
        WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) 'Source',REPEAT(' ',60),'Energy'
        WRITE(7, *) 'Source',REPEAT(' ',60),'Energy'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,22) 'Nucleus-nucleus           (N)',ENUC
        WRITE(7,22) 'Nucleus-nucleus           (N)',ENUC
        WRITE(6,22) 'Electron-nucleus          (V)',EHNC
        WRITE(7,22) 'Electron-nucleus          (V)',EHNC
        WRITE(6,22) 'Electron kinetic          (T)',EHKN
        WRITE(7,22) 'Electron kinetic          (T)',EHKN
        IF(HMLTN.NE.'DHFQ') GOTO 80
        WRITE(6,22) 'Uehling interaction       (U)',EUEH
        WRITE(7,22) 'Uehling interaction       (U)',EUEH
80      CONTINUE
        IF(HMLTN.EQ.'BARE'.OR.NOELEC.LE.1) GOTO 100
        WRITE(6,22) 'Coulomb direct (closed)   (J)',EGDR
        WRITE(7,22) 'Coulomb direct (closed)   (J)',EGDR
        WRITE(6,22) 'Coulomb exchange (closed) (K)',EGXC
        WRITE(7,22) 'Coulomb exchange (closed) (K)',EGXC
        IF(NOPN.EQ.0) GOTO 110
        WRITE(6,22) 'Coulomb direct (open)     (Q)',EQDR
        WRITE(7,22) 'Coulomb direct (open)     (Q)',EQDR
        WRITE(6,22) 'Coulomb exchange (open)   (S)',EQXC
        WRITE(7,22) 'Coulomb exchange (open)   (S)',EQXC
110     CONTINUE
        IF(HMLTN.EQ.'NORL'.OR.HMLTN.EQ.'DHFR') GOTO 100
        WRITE(6,22) 'Breit direct (closed)     (B)',EBDR
        WRITE(7,22) 'Breit direct (closed)     (B)',EBDR
        WRITE(6,22) 'Breit exchange (closed)   (W)',EBXC
        WRITE(7,22) 'Breit exchange (closed)   (W)',EBXC
        IF(NOPN.EQ.0) GOTO 100
        WRITE(6,22) 'Breit direct (open)       (Y)',EMDR
        WRITE(7,22) 'Breit direct (open)       (Y)',EMDR
        WRITE(6,22) 'Breit exchange (open)     (Z)',EMXC
        WRITE(7,22) 'Breit exchange (open)     (Z)',EMXC
100     CONTINUE
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,22) 'Molecule total               ',ETOT
        WRITE(7,22) 'Molecule total               ',ETOT
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       TWO-ELECTRON INTEGRAL SUMMARY
23      FORMAT(1X,A,4X,'1-center',4X,'2-center',4X,'3-center',
     &                                     4X,'4-center',7X,'Total')
24      FORMAT(1X,A,3X,I9,3X,I9,3X,I9,3X,I9,3X,I9)
25      FORMAT(1X,A,3X,F9.2,3X,F9.2,3X,F9.2,3X,F9.2,3X,F9.2)
26      FORMAT(1X,A,1X,A,1X,A,1X,A,1X,A,1X,A)

        IF(HMLTN.EQ.'BARE'.OR.NOELEC.LE.1) THEN
          GOTO 207
        ENDIF

        ISCRN = 0
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(7, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        IF(HMLTN.EQ.'NORL') THEN
          WRITE(6,23) '(LL|LL)     '
          WRITE(7,23) '(LL|LL)     '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Blocks  (#) ',(N2EB(MCNT,1),MCNT=1,5)
          WRITE(7,24) 'Blocks  (#) ',(N2EB(MCNT,1),MCNT=1,5)
          IF(ISCRN.NE.1) GOTO 240
          WRITE(6,24) 'Integrals(#)',(N2EI(MCNT,1),MCNT=1,5)
          WRITE(7,24) 'Integrals(#)',(N2EI(MCNT,1),MCNT=1,5)
          WRITE(6,24) 'Screened (#)',(N2ES(MCNT,1),MCNT=1,5)
          WRITE(7,24) 'Screened (#)',(N2ES(MCNT,1),MCNT=1,5)
          WRITE(6,25) 'Screened (%)',(F2ES(MCNT,1),MCNT=1,5)
          WRITE(7,25) 'Screened (%)',(F2ES(MCNT,1),MCNT=1,5)
240       CONTINUE
          WRITE(6,26) 'Time        ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(7,26) 'Time        ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
        ELSE
          WRITE(6,23) 'Blocks  (#) '
          WRITE(7,23) 'Blocks  (#) '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) '(LL|LL)     ',(N2EB(MCNT,1),MCNT=1,5)
          WRITE(7,24) '(LL|LL)     ',(N2EB(MCNT,1),MCNT=1,5)
          IF(HMLTN.EQ.'NORL') GOTO 211
          WRITE(6,24) '(LL|SS)     ',(N2EB(MCNT,2),MCNT=1,5)
          WRITE(7,24) '(LL|SS)     ',(N2EB(MCNT,2),MCNT=1,5)
          WRITE(6,24) '(SS|LL)     ',(N2EB(MCNT,3),MCNT=1,5)
          WRITE(7,24) '(SS|LL)     ',(N2EB(MCNT,3),MCNT=1,5)
          WRITE(6,24) '(SS|SS)     ',(N2EB(MCNT,4),MCNT=1,5)
          WRITE(7,24) '(SS|SS)     ',(N2EB(MCNT,4),MCNT=1,5)
          IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') GOTO 211
          WRITE(6,24) '(LS|LS)     ',(N2EB(MCNT,5),MCNT=1,5)
          WRITE(7,24) '(LS|LS)     ',(N2EB(MCNT,5),MCNT=1,5)
          WRITE(6,24) '(SL|SL)     ',(N2EB(MCNT,6),MCNT=1,5)
          WRITE(7,24) '(SL|SL)     ',(N2EB(MCNT,6),MCNT=1,5)
211       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Total       ',(N2EB(MCNT,7),MCNT=1,5)
          WRITE(7,24) 'Total       ',(N2EB(MCNT,7),MCNT=1,5)
          IF(ISCRN.NE.1) GOTO 250
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Integrals(#)'
          WRITE(7,23) 'Integrals(#)'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) '(LL|LL)     ',(N2EI(MCNT,1),MCNT=1,5)
          WRITE(7,24) '(LL|LL)     ',(N2EI(MCNT,1),MCNT=1,5)
          IF(HMLTN.EQ.'NORL') GOTO 212
          WRITE(6,24) '(LL|SS)     ',(N2EI(MCNT,2),MCNT=1,5)
          WRITE(7,24) '(LL|SS)     ',(N2EI(MCNT,2),MCNT=1,5)
          WRITE(6,24) '(SS|LL)     ',(N2EI(MCNT,3),MCNT=1,5)
          WRITE(7,24) '(SS|LL)     ',(N2EI(MCNT,3),MCNT=1,5)
          WRITE(6,24) '(SS|SS)     ',(N2EI(MCNT,4),MCNT=1,5)
          WRITE(7,24) '(SS|SS)     ',(N2EI(MCNT,4),MCNT=1,5)
          IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') GOTO 212
          WRITE(6,24) '(LS|LS)     ',(N2EI(MCNT,5),MCNT=1,5)
          WRITE(7,24) '(LS|LS)     ',(N2EI(MCNT,5),MCNT=1,5)
          WRITE(6,24) '(SL|SL)     ',(N2EI(MCNT,6),MCNT=1,5)
          WRITE(7,24) '(SL|SL)     ',(N2EI(MCNT,6),MCNT=1,5)
212       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Total       ',(N2EI(MCNT,7),MCNT=1,5)
          WRITE(7,24) 'Total       ',(N2EI(MCNT,7),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Screened (#)'
          WRITE(7,23) 'Screened (#)'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) '(LL|LL)     ',(N2ES(MCNT,1),MCNT=1,5)
          WRITE(7,24) '(LL|LL)     ',(N2ES(MCNT,1),MCNT=1,5)
          IF(HMLTN.EQ.'NORL') GOTO 214
          WRITE(6,24) '(LL|SS)     ',(N2ES(MCNT,2),MCNT=1,5)
          WRITE(7,24) '(LL|SS)     ',(N2ES(MCNT,2),MCNT=1,5)
          WRITE(6,24) '(SS|LL)     ',(N2ES(MCNT,3),MCNT=1,5)
          WRITE(7,24) '(SS|LL)     ',(N2ES(MCNT,3),MCNT=1,5)
          WRITE(6,24) '(SS|SS)     ',(N2ES(MCNT,4),MCNT=1,5)
          WRITE(7,24) '(SS|SS)     ',(N2ES(MCNT,4),MCNT=1,5)
          IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') GOTO 214
          WRITE(6,24) '(LS|LS)     ',(N2ES(MCNT,5),MCNT=1,5)
          WRITE(7,24) '(LS|LS)     ',(N2ES(MCNT,5),MCNT=1,5)
          WRITE(6,24) '(SL|SL)     ',(N2ES(MCNT,6),MCNT=1,5)
          WRITE(7,24) '(SL|SL)     ',(N2ES(MCNT,6),MCNT=1,5)
214       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Total       ',(N2ES(MCNT,7),MCNT=1,5)
          WRITE(7,24) 'Total       ',(N2ES(MCNT,7),MCNT=1,5)
250       CONTINUE
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Screened (%)'
          WRITE(7,23) 'Screened (%)'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,25) '(LL|LL)     ',(F2ES(MCNT,1),MCNT=1,5)
          WRITE(7,25) '(LL|LL)     ',(F2ES(MCNT,1),MCNT=1,5)
          IF(HMLTN.EQ.'NORL') GOTO 216
          WRITE(6,25) '(LL|SS)     ',(F2ES(MCNT,2),MCNT=1,5)
          WRITE(7,25) '(LL|SS)     ',(F2ES(MCNT,2),MCNT=1,5)
          WRITE(6,25) '(SS|LL)     ',(F2ES(MCNT,3),MCNT=1,5)
          WRITE(7,25) '(SS|LL)     ',(F2ES(MCNT,3),MCNT=1,5)
          WRITE(6,25) '(SS|SS)     ',(F2ES(MCNT,4),MCNT=1,5)
          WRITE(7,25) '(SS|SS)     ',(F2ES(MCNT,4),MCNT=1,5)
          IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') GOTO 216
          WRITE(6,25) '(LS|LS)     ',(F2ES(MCNT,5),MCNT=1,5)
          WRITE(7,25) '(LS|LS)     ',(F2ES(MCNT,5),MCNT=1,5)
          WRITE(6,25) '(SL|SL)     ',(F2ES(MCNT,6),MCNT=1,5)
          WRITE(7,25) '(SL|SL)     ',(F2ES(MCNT,6),MCNT=1,5)
216       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,25) 'Total       ',(F2ES(MCNT,7),MCNT=1,5)
          WRITE(7,25) 'Total       ',(F2ES(MCNT,7),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Time        '
          WRITE(7,23) 'Time        '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,26) '(LL|LL)     ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(7,26) '(LL|LL)     ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          IF(HMLTN.EQ.'NORL') GOTO 219
          WRITE(6,26) '(LL|SS)     ',(MS(T2ES(MCNT,2)),MCNT=1,5)
          WRITE(7,26) '(LL|SS)     ',(MS(T2ES(MCNT,2)),MCNT=1,5)
          WRITE(6,26) '(SS|LL)     ',(MS(T2ES(MCNT,3)),MCNT=1,5)
          WRITE(7,26) '(SS|LL)     ',(MS(T2ES(MCNT,3)),MCNT=1,5)
          WRITE(6,26) '(SS|SS)     ',(MS(T2ES(MCNT,4)),MCNT=1,5)
          WRITE(7,26) '(SS|SS)     ',(MS(T2ES(MCNT,4)),MCNT=1,5)
          IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') GOTO 219
          WRITE(6,26) '(LS|LS)     ',(MS(T2ES(MCNT,5)),MCNT=1,5)
          WRITE(7,26) '(LS|LS)     ',(MS(T2ES(MCNT,5)),MCNT=1,5)
          WRITE(6,26) '(SL|SL)     ',(MS(T2ES(MCNT,6)),MCNT=1,5)
          WRITE(7,26) '(SL|SL)     ',(MS(T2ES(MCNT,6)),MCNT=1,5)
219       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,26) 'Total       ',(MS(T2ES(MCNT,7)),MCNT=1,5)
          WRITE(7,26) 'Total       ',(MS(T2ES(MCNT,7)),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
        ENDIF
207     CONTINUE
C
C       MATRIX CONSTRUCTION STOPWATCH
        TMOR = TSTP-T1EL-TCL1-TCL2-TBR1-TBR2-TDGN
30      FORMAT(1X,A,24X,A)
31      FORMAT(1X,A,1X,I3,16X,A)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',20),'Fock construction labour analysis'
        WRITE(7, *) REPEAT(' ',20),'Fock construction labour analysis'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'One-electron matrices           ',HMS(T1EL)
        WRITE(7,30) 'One-electron matrices           ',HMS(T1EL)
        IF(HMLTN.EQ.'BARE') GOTO 220
        WRITE(6,30) 'Coulomb (atomic)                ',HMS(TCL1)
        WRITE(7,30) 'Coulomb (atomic)                ',HMS(TCL1)
        WRITE(6,30) 'Coulomb (many-center)           ',HMS(TCL2)
        WRITE(7,30) 'Coulomb (many-center)           ',HMS(TCL2)
        IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') GOTO 220
        WRITE(6,30) 'Breit (atomic)                  ',HMS(TBR1)
        WRITE(7,30) 'Breit (atomic)                  ',HMS(TBR1)
        WRITE(6,30) 'Breit (many-center)             ',HMS(TBR2)
        WRITE(7,30) 'Breit (many-center)             ',HMS(TBR2)
220     CONTINUE
        WRITE(6,30) 'Matrix diagonalisation          ',HMS(TDGN)
        WRITE(7,30) 'Matrix diagonalisation          ',HMS(TDGN)
        WRITE(6,30) 'Other sources                   ',HMS(TMOR)
        WRITE(7,30) 'Other sources                   ',HMS(TMOR)
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,30) 'Total iteration time            ',HMS(TSTP)
        WRITE(7,30) 'Total iteration time            ',HMS(TSTP)
        WRITE(6,31) 'Time at end of iteration        ',ITER,STAMP
        WRITE(7,31) 'Time at end of iteration        ',ITER,STAMP
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       CONVERGENCE STATUS
32      FORMAT(1X,A,42X,I3)
33      FORMAT(1X,A,37X,F8.5)
34      FORMAT(1X,A,29X,1P,D16.9)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',26),'Convergence analysis'
        WRITE(7, *) REPEAT(' ',26),'Convergence analysis'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,32) 'Iteration number           ',ITER
        WRITE(7,32) 'Iteration number           ',ITER
        WRITE(6,32) 'Integral inclusion level   ',ILEV
        WRITE(7,32) 'Integral inclusion level   ',ILEV
        WRITE(6,33) 'Level shift parameter      ',SHLV
        WRITE(7,33) 'Level shift parameter      ',SHLV
        WRITE(6,34) 'Density difference norm    ',DNRM(ITER)
        WRITE(7,34) 'Density difference norm    ',DNRM(ITER)
        WRITE(6,34) 'Weighted energy difference ',WEDN(ITER)
        WRITE(7,34) 'Weighted energy difference ',WEDN(ITER)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       TEST FOR CONVERGENCE OR INTEGRAL CLASS UPDATE
40      FORMAT(29X,'Stage 1: (LL|LL)')
41      FORMAT(23X,'Stage 2: (LL|SS) and (SS|LL)')
42      FORMAT(14X,'Stage 2: (LL|SS), (SS|LL), (LS|LS) and (SL|SL)')
43      FORMAT(29X,'Stage 3: (SS|SS)')
44      FORMAT(23X,'Stage 4: (LS|LS) and (SL|SL)')
C
C       THREE-STRIKE RULE: IF ENERGY DIFFERENCE KEEPS INCREASING, EXIT
        IF(ITER.GT.3) THEN
C
C         STORE LAST FEW ENERGY DIFFERENCE VALUES
          WE1 = WEDN(ITER-3)
          WE2 = WEDN(ITER-2)
          WE3 = WEDN(ITER-1)
          WE4 = WEDN(ITER  )
C
C         IF EACH IS SEQUENTIALLY BIGGER THAN THE LAST, EXIT
          IF(WE4.GT.WE3.AND.WE3.GT.WE2.AND.WE2.GT.WE1) THEN
            WRITE(6, *) ' '
            WRITE(7, *) ' '
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6, *) 'In HFSCF: energy not converging. Exit BERTHA.'
            WRITE(7, *) 'In HFSCF: energy not converging. Exit BERTHA.'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            STOP
          ENDIF
C
        ENDIF
C
C       BARE NUCLEUS APPROXIMATION: NO COULOMB INTEGRALS AND NO SCF.
        IF(HMLTN.EQ.'BARE'.OR.NOELEC.LE.1) GOTO 300
C
C       CURRENTLY AT STAGE 1: (LL|LL)
        IF(ILEV.EQ.1) THEN
C
C         NON-RELATIVISTIC HAMILTONIAN ONLY INVOLVES (LL|LL)
          IF(HMLTN.EQ.'NORL') THEN
C
C           SATISFIES ALL CRITERIA - SUCCESSFUL CONVERGENCE
            IF(WEDN(ITER).LT.ENRGTOL.AND.DNRM(ITER).LT.DSTYTOL) THEN
              GOTO 300
            ENDIF
C
C         ALL OTHER HAMILTONIANS REQUIRE FURTHER INTEGRAL INCLUSIONS
          ELSE
C
C           IF STAGE 1 HAS NOT CONVERGED, ITERATE AGAIN
            IF(WEDN(ITER).GE.ENRGLV1) THEN
              SHLV = SHLEV(ILEV)
C           IF STAGE 1 HAS CONVERGED, PROCEED TO STAGE 2
            ELSEIF(WEDN(ITER).LT.ENRGLV1) THEN
              ILEV = 2
              SHLV = SHLEV(ILEV)
              WRITE(6, *) ' '
              WRITE(7, *) ' '
              WRITE(6, *) REPEAT('*',72)
              WRITE(7, *) REPEAT('*',72)
              IF(HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') THEN
                WRITE(6,41)
                WRITE(7,41)
              ELSE
                WRITE(6,42)
                WRITE(7,42)
              ENDIF
              WRITE(6, *) REPEAT('*',72)
              WRITE(7, *) REPEAT('*',72)
              WRITE(6, *) ' '
              WRITE(7, *) ' '
            ENDIF
C
          ENDIF
C
C       CURRENTLY AT STAGE 2: (LL|SS), (SS|LL), (LS|LS), (SL|SL)
        ELSEIF(ILEV.EQ.2) THEN

C         IF STAGE 2 HAS CONVERGED, PROCEED TO STAGE 3
          IF(WEDN(ITER).LT.ENRGLV2) THEN
            ILEV = 3
            SHLV = SHLEV(ILEV)
            WRITE(6, *) ' '
            WRITE(7, *) ' '
            WRITE(6, *) REPEAT('*',72)
            WRITE(7, *) REPEAT('*',72)
            WRITE(6,43)
            WRITE(7,43)
            WRITE(6, *) REPEAT('*',72)
            WRITE(7, *) REPEAT('*',72)
            WRITE(6, *) ' '
            WRITE(7, *) ' '
          ENDIF
C
C       CURRENTLY AT STAGE 3: (SS|SS)
        ELSEIF(ILEV.EQ.3) THEN
C
C         SATISFIES ALL CRITERIA - SUCCESSFUL CONVERGENCE
          IF(WEDN(ITER).LT.ENRGTOL.AND.DNRM(ITER).LT.DSTYTOL) THEN
            GOTO 300
          ENDIF
C
        ENDIF
C
C     END LOOP OVER ITERATIONS
      ENDDO
C
C     FORCED EXIT: UNSUCCESSFUL CONVERGENCE
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6, *) 'In HFSCF: convergence not attained. ITER = ',ITER
      WRITE(7, *) 'In HFSCF: convergence not attained. ITER = ',ITER
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      STOP
C
C     EARLY EXIT: SUCCESSFUL CONVERGENCE
300   CONTINUE
C
C**********************************************************************C
C     END OF SELF-CONSISTENT FIELD CALCULATIONS                        C
C**********************************************************************C
C
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) REPEAT(':',72)
      WRITE(7, *) REPEAT(':',72)
      WRITE(6, *) REPEAT(' ',25),'Successful convergence!'
      WRITE(7, *) REPEAT(' ',25),'Successful convergence!'
      WRITE(6, *) REPEAT(':',72)
      WRITE(7, *) REPEAT(':',72)
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C**********************************************************************C
C     ADDITIONAL OPTIONS AFTER CONVERGENCE (1ST ORDER P.T.)            C
C**********************************************************************C
C
998   CONTINUE
C     CALCULATE THE PERTUBATIVE VALUE OF THE BREIT ENERGY
      IF(HMLTN.EQ.'DHFP') THEN
        CALL CPU_TIME(TPRTI)
C
C       PRINT CALL TO NEW STAGE OF R-INTEGRALS
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('*',72)
        WRITE(7, *) REPEAT('*',72)
        WRITE(6,44)
        WRITE(7,44)
        WRITE(6, *) REPEAT('*',72)
        WRITE(7, *) REPEAT('*',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       TITLE FOR CALL TO BREIT ROUTINE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',25),'Call to BREIT routine'
        WRITE(7, *) REPEAT(' ',25),'Call to BREIT routine'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
C
C       GENERATE MATRIX REP OF BREIT INTERACTION
        TSCR = 0.0D0
        CALL CPU_TIME(T1)
        CALL BREIT
        CALL CPU_TIME(T2)
        TBR2 = T2-T1
        TB2T = TB2T+TBR2
C
C       CALCULATE FRACTION OF SCREENED INTEGRALS
        TSCR = TSCR + TSCR
        DO MCNT=1,5
          DO ITT=5,6
            F2ES(MCNT,ITT) = 100*N2ES(MCNT,ITT)/DFLOAT(N2EI(MCNT,ITT))
          ENDDO
        ENDDO
C
C       ADD BREIT MATRIX TO MOST RECENT FOCK MATRIX
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = FOCK(I,J) + BDIR(I,J) - BXCH(I,J)
          ENDDO
        ENDDO
C
C       DIAGONALISE FOCK MATRIX (REQUIRES LAPACK LIBRARY)
        CALL ZHEGV(1,'V','L',NDIM,FOCK,MDM,OVAP,MDM,
     &                                     EIGEN,WORK,LWK,RWORK,INFO)
        IF(INFO.NE.0) THEN
          WRITE(6, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INFO
          WRITE(7, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INFO
        ENDIF
C
C       TRANSFER EIGENVECTORS TO THE C ARRAY
        DO J=1,NDIM
          DO I=1,NDIM
            C(I,J) = FOCK(I,J)
          ENDDO
        ENDDO
C
C       DEDUCT LEVEL SHIFT VALUE FROM VIRTUAL ORBITAL EIGENVALUES
        IF(ITER.EQ.1) THEN
          DO IVIR=NSHIFT+NOCC+1,NDIM
            EIGEN(IVIR) = EIGEN(IVIR) - SHLV
          ENDDO
        ENDIF
C
C       UPDATE EIGENVALUES AND COEFFICIENTS
        OPEN(UNIT=8,FILE=TRIM(WFNFL)//'(+B).wfn',STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          WRITE(8, *) EIGEN(I),(C(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
C
C       RECALCULATE TOTAL ENERGY
        CALL ENERGIES
C
C       UPDATE TOTAL BREIT CALCULATION TIME
        CALL CPU_TIME(TPRTF)
        TBMX = TPRTF - TPRTI
C
C       SUMMARISE DIRECT AND EXCHANGE ENERGIES
        WRITE(6,22) 'Breit direct (closed)     (B)',EBDR
        WRITE(7,22) 'Breit direct (closed)     (B)',EBDR
        WRITE(6,22) 'Breit exchange (closed)   (W)',EBXC
        WRITE(7,22) 'Breit exchange (closed)   (W)',EBXC
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'Total BREIT time                ',HMS(TBMX)
        WRITE(7,30) 'Total BREIT time                ',HMS(TBMX)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       TWO-ELECTRON CALCULATION BREAKDOWN
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(7, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,23) '(LS|LS)     '
        WRITE(7,23) '(LS|LS)     '
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,24) 'Integrals(#)',(N2EI(MCNT,5),MCNT=1,5)
        WRITE(7,24) 'Integrals(#)',(N2EI(MCNT,5),MCNT=1,5)
        IF(ISCRN.NE.0) GOTO 260
        WRITE(6,24) 'Screened (#)',(N2ES(MCNT,5),MCNT=1,5)
        WRITE(7,24) 'Screened (#)',(N2ES(MCNT,5),MCNT=1,5)
        WRITE(6,25) 'Screened (%)',(F2ES(MCNT,5),MCNT=1,5)
        WRITE(7,25) 'Screened (%)',(F2ES(MCNT,5),MCNT=1,5)
260     CONTINUE
        WRITE(6,26) 'Time        ',(MS(T2ES(MCNT,5)),MCNT=1,5)
        WRITE(7,26) 'Time        ',(MS(T2ES(MCNT,5)),MCNT=1,5)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       LEVEL ITERATIONS AND TIME
        NMLEV(4) = 1
        TMLEV(4) = TBMX
        ITER     = ITER+1
C
      ENDIF
C
C**********************************************************************C
C     SUMMARY OF CALCULATION DETAILS                                   C
C**********************************************************************C
C
C     TIME AT END OF MOLECULAR CALCULATION
      CALL CPU_TIME(TSCF2)
      TTOT = TSCF2 - TSCF1
C
C     DATE AND TIME AT END OF CALCULATION
      CALL TIMENOW(STAMP)
C
C     PRINT OUT FINAL SCF RESULTS
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'Molecular SCF summary'
      WRITE(7, *) REPEAT(' ',25),'Molecular SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     MOLECULAR ENERGIES
      EDIR = EGDR+EQDR+EBDR+EMDR
      EXCH = EGXC+EQXC+EBXC+EMXC
50    FORMAT(1X,A,22X,A,11X,A,14X,A)
51    FORMAT(1X,A,39X,F17.9)
52    FORMAT(1X,A,1X,F17.9,2X,F17.9,2X,F17.9)
      WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,50) 'Source','Direct','Exchange','Total'
      WRITE(7,50) 'Source','Direct','Exchange','Total'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,51) 'Nucleus-nucleus ',ENUC
      WRITE(7,51) 'Nucleus-nucleus ',ENUC
      WRITE(6,51) 'Electron-nucleus',EHNC
      WRITE(7,51) 'Electron-nucleus',EHNC
      WRITE(6,51) 'Electron kinetic',EHKN
      WRITE(7,51) 'Electron kinetic',EHKN
      IF(HMLTN.NE.'DHFQ') GOTO 405
      WRITE(6,51) 'Uehling effects ',EUEH
      WRITE(6,51) 'Uehling effects ',EUEH
405   CONTINUE
      IF(HMLTN.EQ.'BARE') GOTO 400
      WRITE(6,52) 'Coulomb (closed)',EGDR,EGXC,ECLG
      WRITE(7,52) 'Coulomb (closed)',EGDR,EGXC,ECLG
      IF(NOPN.EQ.0) GOTO 410
      WRITE(6,52) 'Coulomb (open)  ',EQDR,EQXC,ECLQ
      WRITE(7,52) 'Coulomb (open)  ',EQDR,EQXC,ECLQ
410   CONTINUE
      IF(HMLTN.EQ.'NORL'.OR.HMLTN.EQ.'DHFR') GOTO 400
      WRITE(6,52) 'Breit (closed)  ',EBDR,EBXC,EBRG
      WRITE(7,52) 'Breit (closed)  ',EBDR,EBXC,EBRG
      IF(NOPN.EQ.0) GOTO 400
      WRITE(6,52) 'Breit (open)    ',EMDR,EMXC,EBRQ
      WRITE(7,52) 'Breit (open)    ',EMDR,EMXC,EBRQ
400   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,52) 'Molecule        ',EDIR,EXCH,ETOT
      WRITE(7,52) 'Molecule        ',EDIR,EXCH,ETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     E-COEFFICIENT AND R-INTEGRAL ANALYSIS
53    FORMAT(1X,A,5X,A,14X,A,20X,A)
54    FORMAT(1X,A,3X,A,14X,A,A)
55    FORMAT(38X,A,A)
56    FORMAT(1X,A,2X,A,33X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',21),'E-coefficients and R-integrals'
      WRITE(7, *) REPEAT(' ',21),'E-coefficients and R-integrals'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,53) 'E-coefficients','Time','R-integrals','Time'
      WRITE(7,53) 'E-coefficients','Time','R-integrals','Time'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,54) 'E0LL',HMS(TELL),'(LL|LL)            ',HMS(TRLL)
      WRITE(7,54) 'E0LL',HMS(TELL),'(LL|LL)            ',HMS(TRLL)
      IF(HMLTN.EQ.'NORL') GOTO 420
      WRITE(6,54) 'E0SS',HMS(TESS),'(LL|SS) and (SS|LL)',HMS(TRLS)
      WRITE(7,54) 'E0SS',HMS(TESS),'(LL|SS) and (SS|LL)',HMS(TRLS)
      WRITE(6,55)                  '(SS|SS)            ',HMS(TRSS)
      WRITE(7,55)                  '(SS|SS)            ',HMS(TRSS)
      IF(HMLTN.EQ.'BARE'.OR.HMLTN.EQ.'DHFR') GOTO 420
      WRITE(6,54) 'EILS',HMS(TELS),'(LS|LS) and (SL|SL)',HMS(TRBR)
      WRITE(7,54) 'EILS',HMS(TELS),'(LS|LS) and (SL|SL)',HMS(TRBR)
420   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,56) 'Total',HMS(TELL+TESS+TELS),HMS(TRLL+TRLS+TRSS+TRBR)
      WRITE(7,56) 'Total',HMS(TELL+TESS+TELS),HMS(TRLL+TRLS+TRSS+TRBR)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     CONVERGENCE ANALYSIS
      T1 = TMLEV(1)
      T2 = TMLEV(2)
      T3 = TMLEV(3)
      T4 = TMLEV(4)
59    FORMAT(1X,A,3X,A,16X,A,6X,A,14X,A)
60    FORMAT(1X,I1,7X,A,2X,F8.5,13X,I3,2X,A)
61    FORMAT(1X,I1,7X,A)
62    FORMAT(9X,A,2X,F8.5,13X,I3,2X,A)
63    FORMAT(1X,A,46X,I3,2X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',25),'Convergence analysis'
      WRITE(7, *) REPEAT(' ',25),'Convergence analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,59) 'Stage','Inclusion','Shift','Iterations','Time'
      WRITE(7,59) 'Stage','Inclusion','Shift','Iterations','Time'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,60) 1,'(LL|LL)             ',SHLEV(1),NMLEV(1),HMS(T1)
      WRITE(7,60) 1,'(LL|LL)             ',SHLEV(1),NMLEV(1),HMS(T1)
      IF(HMLTN.EQ.'NORL') GOTO 440
      IF(HMLTN.EQ.'DHFB'.OR.HMLTN.EQ.'DHFQ') THEN
        WRITE(6,61) 2,'(LL|SS) and (SS|LL),'
        WRITE(7,61) 2,'(LL|SS) and (SS|LL),'
        WRITE(6,62)   '(LS|LS) and (SL|SL) ',SHLEV(2),NMLEV(2),HMS(T2)
        WRITE(7,62)   '(LS|LS) and (SL|SL) ',SHLEV(2),NMLEV(2),HMS(T2)
      ELSE
        WRITE(6,60) 2,'(LL|SS) and (SS|LL) ',SHLEV(2),NMLEV(2),HMS(T2)
        WRITE(7,60) 2,'(LL|SS) and (SS|LL) ',SHLEV(2),NMLEV(2),HMS(T2)
      ENDIF
      WRITE(6,60) 3,'(SS|SS)             ',SHLEV(3),NMLEV(3),HMS(T3)
      WRITE(7,60) 3,'(SS|SS)             ',SHLEV(3),NMLEV(3),HMS(T3)
      IF(HMLTN.EQ.'DHFP') THEN
        WRITE(6,60) 4,'(LS|LS) and (SL|SL) ',SHLEV(3),NMLEV(4),HMS(T4)
        WRITE(7,60) 4,'(LS|LS) and (SL|SL) ',SHLEV(3),NMLEV(4),HMS(T4)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,63) 'Total',ITER,HMS(T1+T2+T3+T4)
      WRITE(7,63) 'Total',ITER,HMS(T1+T2+T3+T4)
440   CONTINUE
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     HFSCF LABOUR ANALYIS
57    FORMAT(1X,A,24X,A)
58    FORMAT(1X,A,1X,25X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT(' ',26),'HFSCF labour analysis'
      WRITE(7, *) REPEAT(' ',26),'HFSCF labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(HMLTN.EQ.'BARE') GOTO 530
      TC1O = TC1T-TC1S-TC1B-TC1R-TC1F-TC1M
      WRITE(6, *) REPEAT(' ',24),'Coulomb (atomic) details'
      WRITE(7, *) REPEAT(' ',24),'Coulomb (atomic) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TC1S)
      WRITE(7,57) 'Screening                       ',HMS(TC1S)
      WRITE(6,57) 'Basis intermediates             ',HMS(TC1B)
      WRITE(7,57) 'Basis intermediates             ',HMS(TC1B)
      WRITE(6,57) 'R(AB|CD) integrals              ',HMS(TC1R)
      WRITE(7,57) 'R(AB|CD) integrals              ',HMS(TC1R)
      WRITE(6,57) 'Full integrals                  ',HMS(TC1F)
      WRITE(7,57) 'Full integrals                  ',HMS(TC1F)
      WRITE(6,57) 'Matrix construction             ',HMS(TC1M)
      WRITE(7,57) 'Matrix construction             ',HMS(TC1M)
      WRITE(6,57) 'Other                           ',HMS(TC1O)
      WRITE(7,57) 'Other                           ',HMS(TC1O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TC1T)
      WRITE(7,57) 'Total                           ',HMS(TC1T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      TC2O = TC2T-TC2S-TCEC-TCRM-TCRR-TCC1-TCC2-TCMC
      WRITE(6, *) REPEAT(' ',21),'Coulomb (many-center) details'
      WRITE(7, *) REPEAT(' ',21),'Coulomb (many-center) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TC2S)
      WRITE(7,57) 'Screening                       ',HMS(TC2S)
      WRITE(6,57) 'Eq-coefficients                 ',HMS(TCEC)
      WRITE(7,57) 'Eq-coefficients                 ',HMS(TCEC)
      WRITE(6,57) 'R-integral make                 ',HMS(TCRM)
      WRITE(7,57) 'R-integral make                 ',HMS(TCRM)
      WRITE(6,57) 'R-integral read                 ',HMS(TCRR)
      WRITE(7,57) 'R-integral read                 ',HMS(TCRR)
      WRITE(6,57) '1st contraction                 ',HMS(TCC1)
      WRITE(7,57) '1st contraction                 ',HMS(TCC1)
      WRITE(6,57) '2nd contraction                 ',HMS(TCC2)
      WRITE(7,57) '2nd contraction                 ',HMS(TCC2)
      WRITE(6,57) 'Matrix construction             ',HMS(TCMC)
      WRITE(7,57) 'Matrix construction             ',HMS(TCMC)
      WRITE(6,57) 'Other                           ',HMS(TC2O)
      WRITE(7,57) 'Other                           ',HMS(TC2O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TC2T)
      WRITE(7,57) 'Total                           ',HMS(TC2T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(HMLTN.EQ.'NORL'.OR.HMLTN.EQ.'DHFR') GOTO 530
      TB1O = TB1T-TB1S-TB1B-TB1R-TB1F-TB1M
      WRITE(6, *) REPEAT(' ',25),'Breit (atomic) details'
      WRITE(7, *) REPEAT(' ',25),'Breit (atomic) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TB1S)
      WRITE(7,57) 'Screening                       ',HMS(TB1S)
      WRITE(6,57) 'Basis intermediates             ',HMS(TB1B)
      WRITE(7,57) 'Basis intermediates             ',HMS(TB1B)
      WRITE(6,57) 'R(AB|CD) integrals              ',HMS(TB1R)
      WRITE(7,57) 'R(AB|CD) integrals              ',HMS(TB1R)
      WRITE(6,57) 'Full integrals                  ',HMS(TB1F)
      WRITE(7,57) 'Full integrals                  ',HMS(TB1F)
      WRITE(6,57) 'Matrix construction             ',HMS(TB1M)
      WRITE(7,57) 'Matrix construction             ',HMS(TB1M)
      WRITE(6,57) 'Other                           ',HMS(TB1O)
      WRITE(7,57) 'Other                           ',HMS(TB1O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TB1T)
      WRITE(7,57) 'Total                           ',HMS(TB1T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
555   CONTINUE
      TB2O = TB2T-TB2S-TBEC-TBRM-TBRR-TBC1-TBC2-TBMC
      WRITE(6, *) REPEAT(' ',22),'Breit (many-center) details'
      WRITE(7, *) REPEAT(' ',22),'Breit (many-center) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TB2S)
      WRITE(7,57) 'Screening                       ',HMS(TB2S)
      WRITE(6,57) 'Eq-coefficients                 ',HMS(TBEC)
      WRITE(7,57) 'Eq-coefficients                 ',HMS(TBEC)
      WRITE(6,57) 'R-integral make                 ',HMS(TBRM)
      WRITE(7,57) 'R-integral make                 ',HMS(TBRM)
      WRITE(6,57) 'R-integral read                 ',HMS(TBRR)
      WRITE(7,57) 'R-integral read                 ',HMS(TBRR)
      WRITE(6,57) '1st contraction                 ',HMS(TBC1)
      WRITE(7,57) '1st contraction                 ',HMS(TBC1)
      WRITE(6,57) '2nd contraction                 ',HMS(TBC2)
      WRITE(7,57) '2nd contraction                 ',HMS(TBC2)
      WRITE(6,57) 'Matrix construction             ',HMS(TBMC)
      WRITE(7,57) 'Matrix construction             ',HMS(TBMC)
      WRITE(6,57) 'Other                           ',HMS(TB2O)
      WRITE(7,57) 'Other                           ',HMS(TB2O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TB2T)
      WRITE(7,57) 'Total                           ',HMS(TB2T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
530   CONTINUE
      TOTH = TTOT-TEPP-THMX-TC1T-TC2T-TB1T-TB2T-TEIG
      WRITE(6, *) REPEAT(' ',27),'Overall SCF summary'
      WRITE(7, *) REPEAT(' ',27),'Overall SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'E-coefficient data file prep.   ',HMS(TEPP)
      WRITE(7,57) 'E-coefficient data file prep.   ',HMS(TEPP)
      WRITE(6,57) 'Nuclear, kinetic and overlap    ',HMS(THMX)
      WRITE(7,57) 'Nuclear, kinetic and overlap    ',HMS(THMX)
      IF(HMLTN.EQ.'BARE') GOTO 430
      WRITE(6,57) 'Coulomb (atomic)                ',HMS(TC1T)
      WRITE(7,57) 'Coulomb (atomic)                ',HMS(TC1T)
      WRITE(6,57) 'Coulomb (many-center)           ',HMS(TC2T)
      WRITE(7,57) 'Coulomb (many-center)           ',HMS(TC2T)
      IF(HMLTN.EQ.'NORL'.OR.HMLTN.EQ.'DHFR') GOTO 430
      WRITE(6,57) 'Breit (atomic)                  ',HMS(TB1T)
      WRITE(7,57) 'Breit (atomic)                  ',HMS(TB1T)
      WRITE(6,57) 'Breit (many-center)             ',HMS(TB2T)
      WRITE(7,57) 'Breit (many-center)             ',HMS(TB2T)
430   CONTINUE
      WRITE(6,57) 'Matrix diagonalisation          ',HMS(TEIG)
      WRITE(7,57) 'Matrix diagonalisation          ',HMS(TEIG)
      WRITE(6,57) 'Other sources                   ',HMS(TOTH)
      WRITE(7,57) 'Other sources                   ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TTOT)
      WRITE(7,57) 'Total                           ',HMS(TTOT)
      WRITE(6,58) 'Time at end of calculation',STAMP
      WRITE(7,58) 'Time at end of calculation',STAMP
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE OVRLP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              OOOOOO  VV    VV RRRRRRR  LL      PPPPPPP               C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO  VV  VV  RRRRRRR  LL      PPPPPPP               C
C             OO    OO   VVVV   RR    RR LL      PP                    C
C              OOOOOO     VV    RR    RR LLLLLLL PP                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  OVRLP CONSTRUCTS A MOLECULAR BASIS FUNCTION OVERLAP MATRIX.         C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION RC(MB2,MRC),EXPT(MBS,4),XYZ(3,4),APH(MB2),CP(MB2,3),
     &          PNC(MB2),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      DATA PI/3.1415926535897932D0/
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          OVAP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO IBAS=1,NBAS(2)
          EXPT(IBAS,2) = EXPSET(IBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS           C
C     OF (MA,MB). FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE          C
C     ORDERED                                                          C
C     11: = (-|MQN(A)|,-|MQN(B)|)                                      C
C     12: = (-|MQN(A)|,+|MQN(B)|)                                      C
C     21: = (+|MQN(A)|,-|MQN(B)|)                                      C
C     22: = (+|MQN(A)|,+|MQN(B)|)                                      C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LARGE(ICNTA,KA,MJA  )
      IL2 = LARGE(ICNTA,KA,MJA+1)
      JL1 = LARGE(ICNTB,KB,MJB  )
      JL2 = LARGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      FASE = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL + TDM2 - TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-FASE*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = FASE*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC OVERLAP CALCULATIONS COMPLETE
      IF(HMLTN.EQ.'NORL') GOTO 500
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS + TDM2 - TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-FASE*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = FASE*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF THE OVERLAP MATRIX FOR THIS BLOCK OF   C
C     BASIS FUNCTIONS -- NOW OVERLAY THE RESULTS INTO OVAP.            C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LARGE(ICNTA,KA,MJA  )
      IL2 = LARGE(ICNTA,KA,MJA+1)
      JL1 = LARGE(ICNTB,KB,MJB  )
      JL2 = LARGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
C     LL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVAP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVAP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVAP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVAP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVAP(JL1+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL2+JBAS))
            OVAP(JL1+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVAP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVAP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVAP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVAP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVAP(JL1+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL2+JBAS))
            OVAP(JL1+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC OVERLAP MATRIX COMPLETE
      IF(HMLTN.EQ.'NORL') GOTO 600
C
C     SS BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVAP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVAP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVAP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVAP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVAP(JS1+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS2+JBAS))
            OVAP(JS1+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVAP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVAP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVAP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVAP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVAP(JS1+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS2+JBAS))
            OVAP(JS1+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ONEEL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               OOOOOO  NN    NN EEEEEEE EEEEEEE LL                    C
C              OO    OO NNN   NN EE      EE      LL                    C
C              OO    OO NNNN  NN EE      EE      LL                    C
C              OO    OO NN NN NN EEEEEE  EEEEEE  LL                    C
C              OO    OO NN  NNNN EE      EE      LL                    C
C              OO    OO NN   NNN EE      EE      LL                    C
C               OOOOOO  NN    NN EEEEEEE EEEEEEE LLLLLLL               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ONEEL CONSTRUCTS A FULL SET OF MULTI-CENTER OVERLAP, KINETIC AND    C
C  NUCLEAR ATTRACTION BASIS FUNCTION MATRIX ELEMENTS.                  C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CTMP1,CTMP2,CTMP3,CTMP4
      COMPLEX*16 E11A,E11B,E11C,TRM11,E21A,E21B,E21C,TRM21
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4),
     &           VLL(MBS,MBS,4),VSS(MBS,MBS,4),
     &           TLL(MBS,MBS,4),TLS(MBS,MBS,4),TSL(MBS,MBS,4)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/DENS/DENC,DENO,DENT
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          HNUC(I,J) = DCMPLX(0.0D0,0.0D0)
          HKIN(I,J) = DCMPLX(0.0D0,0.0D0)
          OVAP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 2000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
         LQN(1) = KQN(1)
        ELSE
         LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO IBAS=1,NBAS(2)
          EXPT(IBAS,2) = EXPSET(IBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS           C
C     OF (MA,MB). FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE          C
C     ORDERED                                                          C
C     11: = (-|MQN(A)|,-|MQN(B)|) -> 1                                 C
C     12: = (-|MQN(A)|,+|MQN(B)|) -> 2                                 C
C     21: = (+|MQN(A)|,-|MQN(B)|) -> 3                                 C
C     22: = (+|MQN(A)|,+|MQN(B)|) -> 4                                 C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      FASE = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXM = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IB=1,4
            SLL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            SSS(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            TLL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            TLS(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            TSL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            VLL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
          DO M=1,MAXM
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL + TDM2 - TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ    = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT  = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-FASE*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = FASE*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = COORD(1,IZ)
        CY = COORD(2,IZ)
        CZ = COORD(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            ESM = CNUC(IZ)+EIJ
            PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
            APH(M) = (EIJ*CNUC(IZ))/ESM
            PNC(M) = 2.0D0*PI*DSQRT(CNUC(IZ)/ESM)*ZNUC(IZ)/EIJ
            CP(M,1) = CX - PX
            CP(M,2) = CY - PY
            CP(M,3) = CZ - PZ
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXM,LAM)
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUME OF ELL0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVLL
              VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                         - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                         - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
            VLL(IBAS,JBAS,2) =-FASE*DCONJG(VLL(IBAS,JBAS,3))
            VLL(IBAS,JBAS,4) = FASE*DCONJG(VLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
      ENDDO
C
C     CONSTRUCT NON-RELATIVISTIC KINETIC ENERGY INTEGRALS (IOS 91)
      IF(HMLTN.EQ.'NORL') THEN
        RL2 = DFLOAT(2*LQN(2)+3)
        M   = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M     = M+1
            EJ    = EXPT(JBAS,2)
            EIJ   = EXPT(IBAS,1) + EXPT(JBAS,2)
            EROOT = DSQRT(PI/EIJ)**3
            PX = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
C
            PBX = PX - XYZ(1,2)
            PBY = PY - XYZ(2,2)
            PBZ = PZ - XYZ(3,2)
            PB2 = PBX*PBX + PBY*PBY + PBZ*PBZ
C
            E0FC = EJ*RL2 - 2.0D0*EJ*EJ*PB2 - 3.00D0*EJ*EJ/EIJ
            E1FC = 4.0D0*EJ*EJ
C
C           TRUNCATE EXPRESSION DEPENDING ON LAM VALUE
C           ALL COMBINATIONS ALLOW FOR THE LAM = 0 MANIFOLD
            TRM11 = E0FC*E11(M,1)
            TRM21 = E0FC*E21(M,1)
C           IF LAM > 0 PROVIDE SECOND BUNCH OF TERMS
            IF(LAM.GE.1) THEN
              E11A = E11(M,INABCD(1,0,0))
              E21A = E21(M,INABCD(1,0,0))
              E11B = E11(M,INABCD(0,1,0))
              E21B = E21(M,INABCD(0,1,0))
              E11C = E11(M,INABCD(0,0,1))
              E21C = E21(M,INABCD(0,0,1))
              TRM11 = TRM11 - E1FC*(PBX*E11A + PBY*E11B + PBZ*E11C)
              TRM21 = TRM21 - E1FC*(PBX*E21A + PBY*E21B + PBZ*E21C)
            ENDIF
C           IF LAM > 1 PROVIDE FINAL BUNCH OF TERMS
            IF(LAM.GE.2) THEN
              E11A = E11(M,INABCD(2,0,0))
              E21A = E21(M,INABCD(2,0,0))
              E11B = E11(M,INABCD(0,2,0))
              E21B = E21(M,INABCD(0,2,0))
              E11C = E11(M,INABCD(0,0,2))
              E21C = E21(M,INABCD(0,0,2))
              TRM11 = TRM11 - E1FC*(E11A + E11B + E11C)
              TRM21 = TRM21 - E1FC*(E21A + E21B + E21C)
            ENDIF
            TLL(IBAS,JBAS,1) = EROOT*TRM11
            TLL(IBAS,JBAS,3) = EROOT*TRM21
            TLL(IBAS,JBAS,2) =-FASE*DCONJG(TLL(IBAS,JBAS,3))
            TLL(IBAS,JBAS,4) = FASE*DCONJG(TLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
C       NON-RELATIVISTIC HAMILTONIAN MATRICES COMPLETE
        GOTO 500
      ENDIF
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
          DO M=1,MAXM
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS + TDM2 - TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ     = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT   = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-FASE*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = FASE*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = COORD(1,IZ)
        CY = COORD(2,IZ)
        CZ = COORD(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            ESM = CNUC(IZ) + EIJ
            PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
            APH(M) = EIJ*CNUC(IZ)/ESM
            PNC(M) = 2.0D0*PI*DSQRT(CNUC(IZ)/ESM)*ZNUC(IZ)/EIJ
            CP(M,1) = CX - PX
            CP(M,2) = CY - PY
            CP(M,3) = CZ - PZ
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXM,LAM)
        CALL CPU_TIME(TDM2)
        TRSS = TRSS + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUME OF ESS0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVSS
              VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                           + PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                           + PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SUBTRACT THE SS OVERLAP MATRIX AND FINISH CONSTRUCTION
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          VSS(IBAS,JBAS,1) =-VSS(IBAS,JBAS,1)
     &                       - 2.0D0*CV*CV*SSS(IBAS,JBAS,1)
          VSS(IBAS,JBAS,3) =-VSS(IBAS,JBAS,3)
     &                       - 2.0D0*CV*CV*SSS(IBAS,JBAS,3)
          VSS(IBAS,JBAS,2) =-FASE*DCONJG(VSS(IBAS,JBAS,3))
          VSS(IBAS,JBAS,4) = FASE*DCONJG(VSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 3: THE SL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     KINETIC MATRIX ELEMENTS
      FACT = CV*DSQRT(DFLOAT(2*LQN(2)+3))
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ    = EXPT(IBAS,1) + EXPT(JBAS,2)
          EJRT   = FACT*DSQRT(EXPT(JBAS,2))
          EROOT  = DSQRT(PI/EIJ)**3
          TSL(IBAS,JBAS,1) = EJRT*EROOT*E11(M,1)
          TSL(IBAS,JBAS,3) = EJRT*EROOT*E21(M,1)
          TSL(IBAS,JBAS,2) =-FASE*DCONJG(TSL(IBAS,JBAS,3))
          TSL(IBAS,JBAS,4) = FASE*DCONJG(TSL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C
C**********************************************************************C
C     PART 4: THE LS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
C
      CALL CPU_TIME(TDM1)
C
C     DFNOTE: THE INDEX SWAP '2 1' MAKES FILE IMPORT ANNOYING. I'M LAZY.
C             JUST GENERATE THESE EQ'S AS A BATCH (DOESN'T TAKE LONG).
C
C     IF(IEQS.EQ.0) THEN
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,2,1,0)
C     ELSEIF(IEQS.EQ.1) THEN
C       DO ITUV=1,NTUVSS
C         IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
C         M = 0
C         DO IBAS=1,NBAS(1)
C           DO JBAS=1,NBAS(2)
C             M = M+1
C             N = (JBAS-1)*NBAS(2) + IBAS
C             PI^{SL}_{IJ} = PI^{LS}_{JI}* (THE NEXT LINES ARE WRONG)
C             E11(M,ITUV) = DCMPLX(E0SSFL(IAD+N,1),-E0SSFL(IAD+N,2))
C             E21(M,ITUV) = DCMPLX(E0SSFL(IAD+N,3),-E0SSFL(IAD+N,4))
C           ENDDO
C         ENDDO
C       ENDDO
C     ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS + TDM2 - TDM1
C
C     KINETIC MATRIX ELEMENTS
      FACT = CV*DSQRT(DFLOAT(2*LQN(1)+3))
      M = 0
      DO JBAS=1,NBAS(2)
        DO IBAS=1,NBAS(1)
          M = M+1
          EIJ    = EXPT(JBAS,2) + EXPT(IBAS,1)
          EIRT   = FACT*DSQRT(EXPT(IBAS,1))
          EROOT  = DSQRT(PI/EIJ)**3
          TLS(IBAS,JBAS,1) = EIRT*EROOT*E11(M,1)
          TLS(IBAS,JBAS,3) = EIRT*EROOT*E21(M,1)
          TLS(IBAS,JBAS,2) =-FASE*DCONJG(TLS(IBAS,JBAS,3))
          TLS(IBAS,JBAS,4) = FASE*DCONJG(TLS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     GENERATE LS MATRICES FROM THE ABOVE SL MATRICES
      M = 0
      DO JBAS=1,NBAS(2)
        DO IBAS=1,NBAS(1)
          M = M + 1
          CTMP1 = DCONJG(TLS(IBAS,JBAS,1))
          CTMP2 = DCONJG(TLS(IBAS,JBAS,2))
          CTMP3 = DCONJG(TLS(IBAS,JBAS,3))
          CTMP4 = DCONJG(TLS(IBAS,JBAS,4))
C
          TLS(IBAS,JBAS,1) = CTMP1
          TLS(IBAS,JBAS,2) = CTMP3
          TLS(IBAS,JBAS,3) = CTMP2
          TLS(IBAS,JBAS,4) = CTMP4
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF HNUC AND HKIN FOR THIS BLOCK.          C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LARGE(ICNTA,KA,MJA  )
      IL2 = LARGE(ICNTA,KA,MJA+1)
      JL1 = LARGE(ICNTB,KB,MJB  )
      JL2 = LARGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
C     LL OVERLAP BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVAP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVAP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVAP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVAP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
C
            OVAP(JL1+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL2+JBAS))
            OVAP(JL1+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVAP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVAP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVAP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVAP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
C
            OVAP(JL1+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL2+JBAS))
            OVAP(JL1+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     LL NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HNUC(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            HNUC(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            HNUC(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            HNUC(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            HNUC(JL1+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL2+JBAS))
            HNUC(JL1+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            HNUC(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            HNUC(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            HNUC(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            HNUC(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            HNUC(JL1+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL2+JBAS))
            HNUC(JL1+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC HAMILTONIAN HAS A KINETIC MATRIX IN THE LL BLOCK
      IF(HMLTN.EQ.'NORL') THEN
C
C       LL KINETIC BLOCKS
        IF(IL1.GT.JL1) THEN
          DO JBAS=1,NBAS(2)
            DO IBAS=1,NBAS(1)
              HKIN(IL1+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,1)
              HKIN(IL1+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,2)
              HKIN(IL2+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,3)
              HKIN(IL2+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,4)
C
              HKIN(JL1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL2+JBAS))
              HKIN(JL1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL2+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
        IF(IL1.EQ.JL1) THEN
          DO JBAS=1,NBAS(2)
            DO IBAS=JBAS,NBAS(1)
              HKIN(IL1+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,1)
              HKIN(IL1+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,2)
              HKIN(IL2+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,3)
              HKIN(IL2+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,4)
C
              HKIN(JL1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL2+JBAS))
              HKIN(JL1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL2+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
        GOTO 600
C
      ENDIF
C
C     SS OVERLAP BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVAP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVAP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVAP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVAP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
C
            OVAP(JS1+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS2+JBAS))
            OVAP(JS1+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVAP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVAP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVAP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVAP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
C
            OVAP(JS1+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS2+JBAS))
            OVAP(JS1+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SS NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HNUC(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            HNUC(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            HNUC(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            HNUC(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            HNUC(JS1+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS2+JBAS))
            HNUC(JS1+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            HNUC(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            HNUC(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            HNUC(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            HNUC(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            HNUC(JS1+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS2+JBAS))
            HNUC(JS1+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     LS BLOCKS
      IF(IL1.GE.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HKIN(IL1+IBAS,JS1+JBAS) = TLS(IBAS,JBAS,1)
            HKIN(IL1+IBAS,JS2+JBAS) = TLS(IBAS,JBAS,2)
            HKIN(IL2+IBAS,JS1+JBAS) = TLS(IBAS,JBAS,3)
            HKIN(IL2+IBAS,JS2+JBAS) = TLS(IBAS,JBAS,4)
C
            HKIN(JS1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JS1+JBAS))
            HKIN(JS2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JS2+JBAS))
            HKIN(JS1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JS1+JBAS))
            HKIN(JS2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HKIN(IS1+IBAS,JL1+JBAS) = TSL(IBAS,JBAS,1)
            HKIN(IS1+IBAS,JL2+JBAS) = TSL(IBAS,JBAS,2)
            HKIN(IS2+IBAS,JL1+JBAS) = TSL(IBAS,JBAS,3)
            HKIN(IS2+IBAS,JL2+JBAS) = TSL(IBAS,JBAS,4)
C
            HKIN(JL1+JBAS,IS1+IBAS) = DCONJG(HKIN(IS1+IBAS,JL1+JBAS))
            HKIN(JL2+JBAS,IS1+IBAS) = DCONJG(HKIN(IS1+IBAS,JL2+JBAS))
            HKIN(JL1+JBAS,IS2+IBAS) = DCONJG(HKIN(IS2+IBAS,JL1+JBAS))
            HKIN(JL2+JBAS,IS2+IBAS) = DCONJG(HKIN(IS2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
C     END LOOPS OVER BASIS PAIRS A,B
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE UEHLING
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       UU    UU EEEEEEEE HH    HH LL      IIII NN    NN  GGGGGG       C
C       UU    UU EE       HH    HH LL       II  NNN   NN GG    GG      C
C       UU    UU EE       HH    HH LL       II  NNNN  NN GG            C
C       UU    UU EEEEEE   HHHHHHHH LL       II  NN NN NN GG            C
C       UU    UU EE       HH    HH LL       II  NN  NNNN GG   GGG      C
C       UU    UU EE       HH    HH LL       II  NN   NNN GG    GG      C
C        UUUUUU  EEEEEEEE HH    HH LLLLLLL IIII NN    NN  GGGGGG       C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHLING CONSTRUCTS A FULL SET OF MULTI-CENTER UEHLING INTERACTION   C
C  MATRIX ELEMENTS.                                                    C
C -------------------------------------------------------------------- C
C  DFNOTE: AT THE MOMENT THIS IS JUST A COPY OF THE ONEEL NUCLEAR      C
C          ATTRACTION MATRIX MAKER.                                    C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CTMP1,CTMP2,CTMP3,CTMP4
      COMPLEX*16 E11A,E11B,E11C,TRM11,E21A,E21B,E21C,TRM21
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VLL(MBS,MBS,4),VSS(MBS,MBS,4)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/DENS/DENC,DENO,DENT
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     INITIALISE STORAGE MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          VUEH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 2000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
         LQN(1) = KQN(1)
        ELSE
         LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO IBAS=1,NBAS(2)
          EXPT(IBAS,2) = EXPSET(IBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS           C
C     OF (MA,MB). FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE          C
C     ORDERED                                                          C
C     11: = (-|MQN(A)|,-|MQN(B)|) -> 1                                 C
C     12: = (-|MQN(A)|,+|MQN(B)|) -> 2                                 C
C     21: = (+|MQN(A)|,-|MQN(B)|) -> 3                                 C
C     22: = (+|MQN(A)|,+|MQN(B)|) -> 4                                 C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      FASE = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IB=1,4
            VLL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL + TDM2 - TDM1
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = COORD(1,IZ)
        CY = COORD(2,IZ)
        CZ = COORD(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            ESM = CNUC(IZ)+EIJ
            PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
            APH(M) = EIJ*CNUC(IZ)/ESM
            PNC(M) = 2.0D0*PI*DSQRT(CNUC(IZ)/ESM)*ZNUC(IZ)/EIJ
            CP(M,1) = CX - PX
            CP(M,2) = CY - PY
            CP(M,3) = CZ - PZ
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXAB,LAM)
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUME OF ELL0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVLL
              VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                         - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                         - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
            VLL(IBAS,JBAS,2) =-FASE*DCONJG(VLL(IBAS,JBAS,3))
            VLL(IBAS,JBAS,4) = FASE*DCONJG(VLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CALCULATIONS ARE COMPLETE
      IF(HMLTN.EQ.'NORL') GOTO 500
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS + TDM2 - TDM1
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = COORD(1,IZ)
        CY = COORD(2,IZ)
        CZ = COORD(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            ESM = CNUC(IZ) + EIJ
            PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
            APH(M) = (EIJ*CNUC(IZ))/ESM
            PNC(M) = 2.0D0*PI*DSQRT(CNUC(IZ)/ESM)*ZNUC(IZ)/EIJ
            CP(M,1) = CX - PX
            CP(M,2) = CY - PY
            CP(M,3) = CZ - PZ
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXAB,LAM)
        CALL CPU_TIME(TDM2)
        TRSS = TRSS + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUME OF ELL0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVSS
              VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                           + PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                           + PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
            VSS(IBAS,JBAS,2) =-FASE*DCONJG(VSS(IBAS,JBAS,3))
            VSS(IBAS,JBAS,4) = FASE*DCONJG(VSS(IBAS,JBAS,1))
          ENDDO
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF VUEH FOR THIS BLOCK.                   C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LARGE(ICNTA,KA,MJA  )
      IL2 = LARGE(ICNTA,KA,MJA+1)
      JL1 = LARGE(ICNTB,KB,MJB  )
      JL2 = LARGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
C     LL UEHLING INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VUEH(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VUEH(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VUEH(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VUEH(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VUEH(JL1+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL2+JBAS))
            VUEH(JL1+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VUEH(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VUEH(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VUEH(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VUEH(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VUEH(JL1+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL2+JBAS))
            VUEH(JL1+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
      GOTO 600
C
C     SS UEHLING INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VUEH(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VUEH(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VUEH(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VUEH(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VUEH(JS1+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS2+JBAS))
            VUEH(JS1+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VUEH(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VUEH(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VUEH(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VUEH(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VUEH(JS1+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS2+JBAS))
            VUEH(JS1+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
C     END LOOPS OVER BASIS PAIRS A,B
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE COULOMB
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    CCCCCC   OOOOOO  UU    UU LL      OOOOOO  MM       MM BBBBBBB     C
C   CC    CC OO    OO UU    UU LL     OO    OO MMM     MMM BB    BB    C
C   CC       OO    OO UU    UU LL     OO    OO MMMM   MMMM BB    BB    C
C   CC       OO    OO UU    UU LL     OO    OO MM MM MM MM BBBBBBB     C
C   CC       OO    OO UU    UU LL     OO    OO MM  MMM  MM BB    BB    C
C   CC    CC OO    OO UU    UU LL     OO    OO MM   M   MM BB    BB    C
C    CCCCCC   OOOOOO   UUUUUU  LLLLLLL OOOOOO  MM       MM BBBBBBB     C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB GENERATES ALL MANY-CENTER ELECTRON REPULSION INTEGRALS IN   C
C  BATCHES AND ADDS THEM TO THE SCF CLOSED/OPEN-SHELL COULOMB MATRIX.  C
C  CALCULATIONS ARE MADE WITH A RELATIVISTIC MCMURCHIE-DAVIDSON SCHEME.C
C -------------------------------------------------------------------- C
C  DFNOTE: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.  C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4 HMLTN
      CHARACTER*8 SHAPE
C
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
      COMPLEX*16 RR(MB2,16)
C
      DIMENSION GDSC(MDM,MDM),BDSC(MDM,MDM)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-MKP:MKP,2*(MKP+1)*MKP),ICNT(4)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GEOM/SHAPE
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVIR
      COMMON/SWRZ/GDSC,BDSC
      COMMON/T2EL/F2ES(5,7),T2ES(5,7),N2EB(5,7),N2EI(5,7),N2ES(5,7)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     LINK THE OPENMP ROUTINE LIBRARY
      INCLUDE 'omp_lib.h'
C
C     SCREENING SENSITIVITY TOLERANCE
      SENS = 1.0D-12
C
C     SAVED BATCHES OF R(AB|CD) INTEGRALS IN ERI
      IF(IEQS.EQ.0) THEN
        IERC = 0
      ELSE
        IERC = 1
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLTN.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLTN.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     LINEAR MOLECULE SHORTCUT OPTION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTERS
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTER
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KVALS(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL ATOMIC CENTERS (USE INDEX 1000)                    C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 1000 ICNTA=1,NCNT
        ICNT(1) = ICNTA
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 1000 ICNTB=1,ICNTA
        ICNT(2) = ICNTB
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER CENTER C
      DO 1000 ICNTC=1,NCNT
        ICNT(3) = ICNTC
C
C       CARTESIAN COORDINATES OF CENTER C
        XYZ(1,3) = COORD(1,ICNTC)
        XYZ(2,3) = COORD(2,ICNTC)
        XYZ(3,3) = COORD(3,ICNTC)
C
C     LOOP OVER CENTER D
      DO 1000 ICNTD=1,NCNT
        ICNT(4) = ICNTD
C
C       CARTESIAN COORDINATES OF CENTER D
        XYZ(1,4) = COORD(1,ICNTD)
        XYZ(2,4) = COORD(2,ICNTD)
        XYZ(3,4) = COORD(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTERS INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTER CONTRIBUTIONS (DEFER TO COULOMB1)
      IF(MCNT.EQ.1) THEN
        GOTO 1001
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES (USE INDEX 2000)                C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KVALS(KC,ICNTC)
        IF(KQN(3).GT.0) THEN
          LQN(3) = KQN(3)
        ELSE
          LQN(3) =-KQN(3)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFUNCT(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = EXPSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KVALS(KD,ICNTD)
        IF(KQN(4).GT.0) THEN
          LQN(4) = KQN(4)
        ELSE
          LQN(4) =-KQN(4)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFUNCT(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = EXPSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| PROJECTIONS (INDEX 3000)                     C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ILIN.EQ.1) THEN
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) GOTO 3003
        GOTO 3001
      ENDIF
3003  CONTINUE
C
C**********************************************************************C
C     IDENTIFICATION OF ERI SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     CALCULATE BLOCK INDICES FOR {ABCD} COMBINATIONS
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ1.LT.IQ2) GOTO 3001
      IF(IQ3.LT.IQ4) GOTO 3001
      IF(IQL.LT.IQR) GOTO 3001
C
      IF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 1
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL = IQR
        ITSCF = 2
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 3
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 4
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 5
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL = IQR
        ITSCF = 6
      ELSE
C       ALL OTHER CASES GENERATED BY THE ABOVE, SO SKIP
        GOTO 3001
      ENDIF
C
C     READ IN FLAG VALUES FROM ISCF DATA BLOCK
      DO ISYM=1,11
        IFLG(ISYM) = ISCF(ISYM,ITSCF)
      ENDDO
C
C     INCLUDE SPECIAL CASES FOR MATCHING BLOCKS
      IF(IQ2.EQ.IQ3) THEN
C       IQ2 = IQ3
        IF(ITSCF.EQ.1.OR.ITSCF.EQ.3.OR.ITSCF.EQ.4) THEN
          IFLG( 9) = 1
        ENDIF
      ENDIF
C
      IF(ITSCF.EQ.1) THEN
        IF(IQ1.EQ.IQ3) THEN
C         IQ1 = IQ3
          IFLG(10) = 1
        ELSEIF(IQ2.EQ.IQ4) THEN
C         IQ2 = IQ4
          IFLG(11) = 1
        ENDIF
      ENDIF
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND B: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSHIFT
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NA1 = LARGE(ICNTA,KA,2*MA-1) + NADDAB
        NA2 = LARGE(ICNTA,KA,2*MA  ) + NADDAB
        NB1 = LARGE(ICNTB,KB,2*MB-1) + NADDAB
        NB2 = LARGE(ICNTB,KB,2*MB  ) + NADDAB
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR C AND D: T'T' = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSHIFT
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NC1 = LARGE(ICNTC,KC,2*MC-1) + NADDCD
        NC2 = LARGE(ICNTC,KC,2*MC  ) + NADDCD
        ND1 = LARGE(ICNTD,KD,2*MD-1) + NADDCD
        ND2 = LARGE(ICNTD,KD,2*MD  ) + NADDCD
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = (2*IT1+IT2)/3
C
C     STAGE 1: INCLUDE ONLY (LL|LL) REPULSION INTEGRALS
      IF(ILEV.EQ.1.AND.ITT.GT.1) THEN
        GOTO 4001
      ENDIF
C
C     STAGE 2: INCLUDE ONLY (LL|SS) AND (SS|LL) REPULSION INTEGRALS
      IF(ILEV.EQ.2.AND.ITT.GT.3) THEN
        GOTO 4001
      ENDIF
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      N2EB(MCNT,ITT) = N2EB(MCNT,ITT)+1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) TO CONSTRUCT GMAT/QMAT     C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL CPU_TIME(TI)
C
C     START OF PARALLEL REGION
C!$OMP PARALLEL DO COLLAPSE(2)
C!$OMP&  PRIVATE(RR,IBCH,IFLG)
C!$OMP&  SHARED(XYZ,KQN,MQN,EXPT,NBAS,ITN)
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
          IF(ITT.GT.1) THEN
            ITOG = 1
          ELSE
            ITOG = 0
          ENDIF
          ITOG=0
C
          CALL SCHWARZ(GDSC,SENS,TC2S)
C
C         UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
          N2EI(MCNT,ITT) = N2EI(MCNT,ITT)+NBAS(3)*NBAS(4)
          N2ES(MCNT,ITT) = N2ES(MCNT,ITT)+NBAS(3)*NBAS(4)-MAXN
C
C         CONDITIONAL TO SKIP THIS BATCH
          IF(IBCH.EQ.1) THEN
C
C           GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
            CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
C
C           MULTIPLY BY DENSITY ELEMENTS AND ADD TO GMAT/QMAT
            CALL CLMMAT(RR,IFLG,TCMC)
C
          ENDIF
C
        ENDDO
      ENDDO
C     END OF PARALLEL REGION
C!$OMP END PARALLEL DO
C
C     RECORD TIME AT END OF BATCH
      CALL CPU_TIME(TF)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + TF - TI
C
4001  CONTINUE
4000  CONTINUE
3001  CONTINUE
3000  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL MATRICES BY CONJUGATION.            C
C**********************************************************************C
C
C     LOOP OVER LOWER TRIANGLE OF EACH TT' BLOCK
      DO J=1,NDIM-NSHIFT
        DO I=1,J
C
C         SMALL-COMPONENT ADDRESSES
          K = I + NSHIFT
          L = J + NSHIFT
C
C         SKIP DIAGONAL PARTS OF EACH SUB-BLOCK
          IF(LABICN(I).NE.LABICN(J)) GOTO 400
          IF(LABKQN(I).NE.LABKQN(J)) GOTO 400
          IF(IABS(LABMQN(I)).NE.IABS(LABMQN(J))) GOTO 400
          GOTO 401
400       CONTINUE
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LL BLOCK
          GDIR(I,J) = GDIR(I,J) + DCONJG(GDIR(J,I))
          GDIR(J,I) =             DCONJG(GDIR(I,J))
          GXCH(I,J) = GXCH(I,J) + DCONJG(GXCH(J,I))
          GXCH(J,I) =             DCONJG(GXCH(I,J))
          QDIR(I,J) = QDIR(I,J) + DCONJG(QDIR(J,I))
          QDIR(J,I) =             DCONJG(QDIR(I,J))
          QXCH(I,J) = QXCH(I,J) + DCONJG(QXCH(J,I))
          QXCH(J,I) =             DCONJG(QXCH(I,J))
C
C         IF HMLTN = 'NORL' SKIP THE NEXT FEW CALCULATIONS
          IF(HMLTN.EQ.'NORL') GOTO 401
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SS BLOCK
          GDIR(K,L) = GDIR(K,L) + DCONJG(GDIR(L,K))
          GDIR(L,K) =             DCONJG(GDIR(K,L))
          GXCH(K,L) = GXCH(K,L) + DCONJG(GXCH(L,K))
          GXCH(L,K) =             DCONJG(GXCH(K,L))
          QDIR(K,L) = QDIR(K,L) + DCONJG(QDIR(L,K))
          QDIR(L,K) =             DCONJG(QDIR(K,L))
          QXCH(K,L) = QXCH(K,L) + DCONJG(QXCH(L,K))
          QXCH(L,K) =             DCONJG(QXCH(K,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LS BLOCK
          GXCH(I,L) = GXCH(I,L) + DCONJG(GXCH(L,I))
          GXCH(L,I) =             DCONJG(GXCH(I,L))
          QXCH(I,L) = QXCH(I,L) + DCONJG(QXCH(L,I))
          QXCH(L,I) =             DCONJG(QXCH(I,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SL BLOCK
          GXCH(K,J) = GXCH(K,J) + DCONJG(GXCH(J,K))
          GXCH(J,K) =             DCONJG(GXCH(K,J))
          QXCH(K,J) = QXCH(K,J) + DCONJG(QXCH(J,K))
          QXCH(J,K) =             DCONJG(QXCH(K,J))
C
401       CONTINUE
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS
      DO J=1,NDIM
        DO I=1,NDIM
          QDIR(I,J) = ACFF*QDIR(I,J)
          QXCH(I,J) = BCFF*QXCH(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                        EEEEEEEE RRRRRRR  IIII                        C
C                        EE       RR    RR  II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEE   RR    RR  II                         C
C                        EE       RRRRRRR   II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEEEE RR    RR IIII                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    XYZ(3,4)    - COORDINATES OF THE NUCLEAR CENTERS IN THIS BLOCK.   C
C    KQN(4)      - KQN RELATIVISTIC LABELS OF THE CENTERS.             C
C    MQN(4)      - |MQN| QUANTUM NUMBERS OF THE CENTERS.               C
C    NBAS(4)     - NUMBER OF FUNCTIONS IN THE BLOCK.                   C
C    EXPT(MBS,4) - LIST OF EXPONENTS IN THE BLOCK.                     C
C    IBAS,JBAS   - COMPONENT LABEL INDEX FOR AB BASIS FUNCTIONS.       C
C    ITN(2)      - COMPONENT OVERLAP (T,T') FOR EACH PAIR AB AND CD.   C
C                  ITN(I) = {LL,LS,SL,SS}.                             C
C  OUTPUT:                                                             C
C    RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
      CHARACTER*8 SHAPE
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MEQ),IABR21(MEQ),IABI11(MEQ),IABI21(MEQ)
      DIMENSION ICDR11(MEQ),ICDR21(MEQ),ICDI11(MEQ),ICDI21(MEQ)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ),ECD11(MB2,MEQ),
     &           EAB21(MB2,MEQ),ECD21(MB2,MEQ)
C
      SAVE EAB11,EAB21,IABR11,IABI11,IABR21,IABI21
      SAVE ECD11,ECD21,ICDR11,ICDI11,ICDR21,ICDI21
      SAVE RCTTFL,IRCTTFL
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GEOM/SHAPE
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      DATA ROOTPI5,SENS/17.4934183276248628D0,1.0D-10/
C
C     LINEAR MOLECULE SKIP CONDITION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.1.AND.ITN(IT).NE.4) THEN
          WRITE(6, *) 'In ERI: illegal component overlaps in ITN.'
          WRITE(7, *) 'In ERI: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS A, B, C, D
      DO N=1,4
        IF(KQN(N).LT.0) THEN
          LQN(N) =-KQN(N)-1
        ELSE
          LQN(N) = KQN(N)
        ENDIF
      ENDDO
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTORS FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ(AB)-COEFFICIENTS
      IF(ITN(1).EQ.1) THEN
        LAMAB = LQN(1)+LQN(2)
      ELSEIF(ITN(1).EQ.4) THEN
        LAMAB = LQN(1)+LQN(2)+2
      ENDIF
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ(CD)-COEFFICIENTS
      IF(ITN(2).EQ.1) THEN
        LAMCD = LQN(3)+LQN(4)
      ELSEIF(ITN(2).EQ.4) THEN
        LAMCD = LQN(3)+LQN(4)+2
      ENDIF
C
C     VRS MAXIMUM LAMBDA LEVEL FOR CONTRACTED R-INTEGRAL BATCH
      LAMABCD = LAMAB+LAMCD
C
C     VRS MAXIMUM LAMBDA LEVEL FOR RCTTFL SAVED LIST (ONLY IF MCNT.GT.2)
      IF(IERC.EQ.0.OR.HMLTN.EQ.'NORL') THEN
        LAMABCDFL = LAMABCD
      ELSEIF(IERC.EQ.1.AND.HMLTN.NE.'NORL') THEN
        IF(ILEV.EQ.1) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)
        ELSEIF(ILEV.EQ.2) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+2
        ELSEIF(ILEV.EQ.3) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+4
        ENDIF
      ENDIF
C
C     VRS TOTAL LENGTH OF EQ-COEFFICIENT LISTS AND R-INTEGRAL BATCH
      NTUVAB     = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD     = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD   = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
      NTUVABCDFL = (LAMABCDFL+1)*(LAMABCDFL+2)*(LAMABCDFL+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2) + JBAS
      EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(IEQS.EQ.1) THEN
        IF(ITN(1).EQ.1) THEN
          DO ITUV=1,NTUVAB
            IAD = IABLL + (ITUV-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
              EAB21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
            ENDDO
          ENDDO
        ELSEIF(ITN(1).EQ.4) THEN
          DO ITUV=1,NTUVAB
            IAD = IABSS + (ITUV-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
              EAB21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      IF(IEQS.EQ.0) THEN
        IF(ITN(1).EQ.1) THEN
          CALL EMAKELL(EAB11,EAB21,EXPT,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ELSEIF(ITN(1).EQ.4) THEN
          CALL EMAKESS(EAB11,EAB21,EXPT,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.1) THEN
        TELL = TELL + TDM2 - TDM1
      ELSEIF(ITN(1).EQ.4) THEN
        TESS = TESS + TDM2 - TDM1
      ENDIF
C
C     SCREENING: TEST E(AB| -) COLUMNS OF CARTESIAN INDEX (T ,U ,V )
      DO IAB=1,NTUVAB
C
C       Re{E(AB|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          SUM = SUM + DABS(DREAL(EAB11(M,IAB)))
          IF(SUM.GT.SENS) THEN
            IABR11(IAB) = 1
            GOTO 101
          ENDIF
        ENDDO
        IABR11(IAB) = 0
101     CONTINUE
C
C       Im{E(AB|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          SUM = SUM + DABS(DIMAG(EAB11(M,IAB)))
          IF(SUM.GT.SENS) THEN
            IABI11(IAB) = 1
            GOTO 102
          ENDIF
        ENDDO
        IABI11(IAB) = 0
102     CONTINUE
C
C       Re{E(AB|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          SUM = SUM + DABS(DREAL(EAB21(M,IAB)))
          IF(SUM.GT.SENS) THEN
            IABR21(IAB) = 1
            GOTO 103
          ENDIF
        ENDDO
        IABR21(IAB) = 0
103     CONTINUE
C
C       Im{E(AB|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          SUM = SUM + DABS(DIMAG(EAB21(M,IAB)))
          IF(SUM.GT.SENS) THEN
            IABI21(IAB) = 1
            GOTO 104
          ENDIF
        ENDDO
        IABI21(IAB) = 0
104     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(IEQS.EQ.1) THEN
        IF(ITN(2).EQ.1) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDLL + (ITUV-1)*MAXCD
            DO M=1,MAXCD
              ECD11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,5),E0LLFL(IAD+M,6))
              ECD21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,7),E0LLFL(IAD+M,8))
            ENDDO
          ENDDO
        ELSEIF(ITN(2).EQ.4) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDSS + (ITUV-1)*MAXCD
            DO M=1,MAXCD
              ECD11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,5),E0SSFL(IAD+M,6))
              ECD21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,7),E0SSFL(IAD+M,8))
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      IF(IEQS.EQ.0) THEN
        IF(ITN(2).EQ.1) THEN
          CALL EMAKELL(ECD11,ECD21,EXPT,XYZ,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ELSEIF(ITN(2).EQ.4) THEN
          CALL EMAKESS(ECD11,ECD21,EXPT,XYZ,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(2).EQ.1) THEN
        TELL = TELL + TDM2 - TDM1
      ELSEIF(ITN(2).EQ.4) THEN
        TESS = TESS + TDM2 - TDM1
      ENDIF
C
C     SCREENING: TEST E(CD| -) COLUMNS OF CARTESIAN INDEX (T',U',V')
      DO ICD=1,NTUVCD
C
C       Re{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(DREAL(ECD11(M,ICD)))
          IF(SUM.GT.SENS) THEN
            ICDR11(ICD) = 1
            GOTO 201
          ENDIF
        ENDDO
        ICDR11(ICD) = 0
201     CONTINUE
C
C       Im{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(DIMAG(ECD11(M,ICD)))
          IF(SUM.GT.SENS) THEN
            ICDI11(ICD) = 1
            GOTO 202
          ENDIF
        ENDDO
        ICDI11(ICD) = 0
202     CONTINUE
C
C       Re{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(DREAL(ECD21(M,ICD)))
          IF(SUM.GT.SENS) THEN
            ICDR21(ICD) = 1
            GOTO 203
          ENDIF
        ENDDO
        ICDR21(ICD) = 0
203     CONTINUE
C
C       Im{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          SUM = SUM + DABS(DIMAG(ECD21(M,ICD)))
          IF(SUM.GT.SENS) THEN
            ICDI21(ICD) = 1
            GOTO 204
          ENDIF
        ENDDO
        ICDI21(ICD) = 0
204     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL CPU_TIME(T2)
      TCEC = TCEC + T2 - T1
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) FROM SCRATCH OR READ-IN          C
C**********************************************************************C
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     READ FROM LOCAL RC(AB|CD) FILE
      IF(IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.0) THEN
C
        CALL CPU_TIME(T1)
C
C       STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
        IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCDFL
C
C       READ RC(AB|CD) INTEGRALS FROM THIS STARTING POINT
        DO N=1,MAXN
          DO IABCD=1,NTUVABCD
            IAD = IADRTT + (IMAP(N)-1)*NTUVABCDFL + IABCD
            RC(N,IABCD) = RCTTFL(IAD)
          ENDDO
        ENDDO
C
C       STARTING ADDRESS FOR SCREENING FLAGS
        IADSCR = (IJ-1)*NTUVABCDFL
C
C       READ SCREENING FLAGS FROM THIS STARTING POINT
        DO IABCD=1,NTUVABCD
          IAD = IADSCR + IABCD
          IRC(IABCD) = IRCTTFL(IAD)
        ENDDO
C
C       RECORD TIME SPENT READING R-INTEGRALS
        CALL CPU_TIME(T2)
        TCRR = TCRR+T2-T1
C
C       NORMALISATION FACTORS FOR THIS BATCH
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.1) THEN
              N   = N+1
              EKL = EXPT(KBAS,3)+EXPT(LBAS,4)
              EMX = DSQRT(EIJ+EKL)*EIJ*EKL
              PRE(N) = 2.0D0*ROOTPI5/EMX
            ENDIF
          ENDDO
        ENDDO
C
      ENDIF
C
C     CALCULATE FROM SCRATCH
      IF(IERC.EQ.0.OR.IRIJ(IBAS,JBAS).EQ.1) THEN
C
        CALL CPU_TIME(T1)
C
C       GAUSSIAN OVERLAP CENTER
        PX = (XYZ(1,1)*EXPT(IBAS,1)+XYZ(1,2)*EXPT(JBAS,2))/EIJ
        PY = (XYZ(2,1)*EXPT(IBAS,1)+XYZ(2,2)*EXPT(JBAS,2))/EIJ
        PZ = (XYZ(3,1)*EXPT(IBAS,1)+XYZ(3,2)*EXPT(JBAS,2))/EIJ
C
C       AUXILLIARY DATA FOR RMAKE ROUTINE
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF((IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.1)
     &                           .OR.(IERC.EQ.0.AND.ISCR(M).EQ.1)) THEN
              N   = N+1
              EKL = EXPT(KBAS,3)+EXPT(LBAS,4)
              EMX = DSQRT(EIJ+EKL)*EIJ*EKL
              APH(N) = EIJ*EKL/(EIJ+EKL)
              PRE(N) = 2.0D0*ROOTPI5/EMX
              QX = (XYZ(1,3)*EXPT(KBAS,3)+XYZ(1,4)*EXPT(LBAS,4))/EKL
              QY = (XYZ(2,3)*EXPT(KBAS,3)+XYZ(2,4)*EXPT(LBAS,4))/EKL
              QZ = (XYZ(3,3)*EXPT(KBAS,3)+XYZ(3,4)*EXPT(LBAS,4))/EKL
              PQ(N,1) = QX-PX
              PQ(N,2) = QY-PY
              PQ(N,3) = QZ-PZ
            ENDIF
          ENDDO
        ENDDO
C
C       EXTEND MAXN IF GENERATING A FULL SET OF INTEGRALS
        MAXN = MAXCD
C
C       GENERATE R-INTEGRALS
        CALL RMAKE(RC,PQ,APH,MAXN,LAMABCDFL)
C
C       SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
        DO IABCDFL=1,NTUVABCDFL
C
C         SUM OF RC(AB|CD) MAGNITUDES
          SUM = 0.0D0
          DO N=1,MAXN
            SUM = SUM + DABS(RC(N,IABCDFL))
            IF(SUM.GT.SENS) THEN
              IRC(IABCDFL) = 1
              GOTO 301
            ENDIF
          ENDDO
          IRC(IABCDFL) = 0
301       CONTINUE
C
        ENDDO
C
C       SAVE THIS SET TO APPROPRIATE CLASS ADDRESS
        IF(IERC.EQ.1) THEN
C
C         TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
          ILIM = IJ*NBAS(3)*NBAS(4)*NTUVABCDFL
C
          IF(ILIM.GT.20*MFL) THEN
C           OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
            WRITE(6, *) 'In ERI: RCTT words exceed allocated limit.'
            WRITE(7, *) 'In ERI: RCTT words exceed allocated limit.'
            GOTO 300
          ELSE
C           DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
            IRIJ(IBAS,JBAS) = 0
          ENDIF
C
C         STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
          IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCDFL

C         COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
          DO N=1,MAXN
            DO IABCDFL=1,NTUVABCDFL
              IAD = IADRTT + (N-1)*NTUVABCDFL + IABCDFL
              RCTTFL(IAD)  = RC(N,IABCDFL)
            ENDDO
          ENDDO
C
C         STARTING ADDRESS FOR SCREENING FLAGS
          IADSCR = (IJ-1)*NTUVABCDFL
C
C         COPY SCREENING MARKERS TO A SAVED LIST
          DO IABCDFL=1,NTUVABCDFL
            IAD = IADSCR + IABCDFL
            IRCTTFL(IAD) = IRC(IABCDFL)
          ENDDO
C
C         SHORTEN THE CURRENT RC LIST WITH IMAP FROM SCREENING
          M = 0
          N = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              IF(ISCR(M).EQ.1) THEN
                N      = N+1
                PRE(N) = PRE(M)
                DO IABCD=1,NTUVABCD
                  RC(N,IABCD) = RC(M,IABCD)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
C
        ENDIF
300     CONTINUE
C
        CALL CPU_TIME(T2)
        TCRM = TCRM+T2-T1
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.1.AND.ITN(2).EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITN(1).EQ.4.AND.ITN(2).EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ELSE
        TRLS = TRLS+TDM2-TDM1
      ENDIF
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     TIME AT START OF FIRST CONTRACTION
      CALL CPU_TIME(T1)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) PASSES SCREENING CONDITION
        IF(IABR11(IAB)+IABI11(IAB)+IABR21(IAB)+IABI21(IAB).EQ.0) THEN
          GOTO 401
        ENDIF
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO ICD=1,NTUVCD
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = INABCD(IVEC(IAB)+IVEC(ICD),JVEC(IAB)+JVEC(ICD),
     &                                             KVEC(IAB)+KVEC(ICD))
C
C         SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
          IF(IRC(IRABCD).EQ.0) GOTO 402
C
C         SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
          IF(ICDR11(ICD)+ICDI11(ICD)+ICDR21(ICD)+ICDI21(ICD).EQ.0) THEN
            GOTO 402
          ENDIF
C
C         CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
          IF(ILIN.EQ.1.AND.IABR11(IAB).EQ.0) GOTO 411
          IF(ICDR11(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                         + DREAL(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
411       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
          IF(ILIN.EQ.1.AND.IABI11(IAB).EQ.0) GOTO 412
          IF(ICDI11(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                         + DIMAG(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
412       CONTINUE
C
C         CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
          IF(ILIN.EQ.1.AND.IABR21(IAB).EQ.0) GOTO 413
          IF(ICDR21(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                         + DREAL(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
413       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
          IF(ILIN.EQ.1.AND.IABI21(IAB).EQ.0) GOTO 414
          IF(ICDI21(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                         + DIMAG(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
414       CONTINUE
C
C         SKIP POINT FOR RC(AB|CD) SCREENING
402       CONTINUE
C
C       END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
        ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION
      CALL CPU_TIME(T2)
      TCC1 = TCC1+T2-T1
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB = ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD = ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 1) =     PRE(N)*DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 4) = PCD*PRE(N)*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,16) = PABCD*DCONJG(RR(N, 1))
        RR(N,13) = PABCD*DCONJG(RR(N, 4))
      ENDDO
C
      IF(ILIN.EQ.1) GOTO 501
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 3) =     PRE(N)*DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 2) =-PCD*PRE(N)*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,14) =-PABCD*DCONJG(RR(N, 3))
        RR(N,15) =-PABCD*DCONJG(RR(N, 2))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 9) =     PRE(N)*DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = PCD*PRE(N)*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 8) =-PABCD*DCONJG(RR(N, 9))
        RR(N, 5) =-PABCD*DCONJG(RR(N,12))
      ENDDO
C
501   CONTINUE
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) =     PRE(N)*DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) =-PCD*PRE(N)*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 6) = PABCD*DCONJG(RR(N,11))
        RR(N, 7) = PABCD*DCONJG(RR(N,10))
      ENDDO
C
C     TIME AT END OF SECOND CONTRACTION
      CALL CPU_TIME(T3)
      TCC2 = TCC2+T3-T2
C
C**********************************************************************C
C     COULOMB INTEGRAL BATCH NOW FULLY CONSTRUCTED                     C
C**********************************************************************C
C
      RETURN
      END
C
C
      SUBROUTINE CLMMAT(RR,IFLG,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       CCCCCC  LL       MM       MM MM       MM    AA   TTTTTTTT      C
C      CC    CC LL       MMM     MMM MMM     MMM   AAAA     TT         C
C      CC       LL       MMMM   MMMM MMMM   MMMM  AA  AA    TT         C
C      CC       LL       MM MM MM MM MM MM MM MM AA    AA   TT         C
C      CC       LL       MM  MMM  MM MM  MMM  MM AAAAAAAA   TT         C
C      CC    CC LL       MM   M   MM MM   M   MM AA    AA   TT         C
C       CCCCCC  LLLLLLLL MM       MM MM       MM AA    AA   TT         C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMMAT MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF COULOMB MATRICES.     C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO ERI):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C    NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C    IFLG(11)   - INTEGRAL SYMMETRY FLAGS.                             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      DIMENSION IFLG(11),NBAS(4)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS...                                    C
C**********************************************************************C
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 101
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 101
C
            GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENC(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENC(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENC(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENC(NC2+KBAS,ND2+LBAS)
C
101         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 102
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 102
C
              GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENC(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENC(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENC(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENC(ND2+LBAS,NC2+KBAS)
C
102         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 103
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 103
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENC(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENC(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENC(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENC(NA2+IBAS,NB2+JBAS)
C
103         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 104
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 104
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENC(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENC(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NB2+JBAS,NA2+IBAS)
C
104         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 105
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 105
C
            GXCH(NA1+IBAS,ND1+LBAS) = GXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENC(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND2+LBAS) = GXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENC(NC2+KBAS,NB2+JBAS)
C
105         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 106
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 106
C
            GXCH(NA1+IBAS,NC1+KBAS) = GXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENC(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC2+KBAS) = GXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENC(ND2+LBAS,NB2+JBAS)
C
106         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 107
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 107
C
            GXCH(NB1+JBAS,ND1+LBAS) = GXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND2+LBAS) = GXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NC2+KBAS,NA2+IBAS)
C
107         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 108
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 108
C
            GXCH(NB1+JBAS,NC1+KBAS) = GXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENC(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC2+KBAS) = GXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENC(ND2+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENC(ND1+LBAS,NA1+IBAS)
C
108         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 109
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 109
C
            GXCH(NC1+KBAS,NB1+JBAS) = GXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENC(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB2+JBAS) = GXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENC(NA2+IBAS,ND2+LBAS)
C
109         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 110
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 110
C
            GXCH(NC1+KBAS,NA1+IBAS) = GXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENC(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA2+IBAS) = GXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NB2+JBAS,ND2+LBAS)
C
110         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 111
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 111
C
            GXCH(ND1+LBAS,NB1+JBAS) = GXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB2+JBAS) = GXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENC(NA2+IBAS,NC2+KBAS)
C
111         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ILIN.EQ.1) GOTO 5002
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 201
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 201
C
            GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENC(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENC(NC2+KBAS,ND1+LBAS)
C
            GDIR(NA1+IBAS,NB2+JBAS) = GDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENC(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENC(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENC(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENC(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB1+JBAS) = GDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENC(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENC(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENC(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENC(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,14)*DENC(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENC(NC2+KBAS,ND1+LBAS)
C
201         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 202
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 202
C
              GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENC(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENC(ND2+LBAS,NC1+KBAS)
C
              GDIR(NA1+IBAS,NB2+JBAS) = GDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENC(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENC(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENC(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENC(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB1+JBAS) = GDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENC(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENC(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENC(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,14)*DENC(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENC(ND2+LBAS,NC1+KBAS)
C
202         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 203
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 203
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENC(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENC(NA2+IBAS,NB1+JBAS)
C
            GDIR(NC1+KBAS,ND2+LBAS) = GDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENC(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENC(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENC(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENC(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND1+LBAS) = GDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENC(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENC(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENC(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENC(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 8)*DENC(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENC(NA2+IBAS,NB1+JBAS)
C
203         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 204
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 204
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NB2+JBAS,NA1+IBAS)
C
            GDIR(NC1+KBAS,ND2+LBAS) = GDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENC(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENC(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND1+LBAS) = GDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENC(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENC(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENC(NB2+JBAS,NA1+IBAS)
C
204         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 205
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 205
C
            GXCH(NA1+IBAS,ND1+LBAS) = GXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENC(NC2+KBAS,NB1+JBAS)
C
            GXCH(NA1+IBAS,ND2+LBAS) = GXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENC(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENC(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND1+LBAS) = GXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENC(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENC(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND2+LBAS) = GXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENC(NC2+KBAS,NB1+JBAS)
C
205         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 206
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 206
C
            GXCH(NA1+IBAS,NC1+KBAS) = GXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENC(ND2+LBAS,NB1+JBAS)
C
            GXCH(NA1+IBAS,NC2+KBAS) = GXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENC(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENC(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC1+KBAS) = GXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENC(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENC(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC2+KBAS) = GXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENC(ND2+LBAS,NB1+JBAS)
C
206         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 207
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 207
C
            GXCH(NB1+JBAS,ND1+LBAS) = GXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENC(NC2+KBAS,NA1+IBAS)
C
            GXCH(NB1+JBAS,ND2+LBAS) = GXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENC(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND1+LBAS) = GXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENC(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND2+LBAS) = GXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENC(NC2+KBAS,NA1+IBAS)
C
207         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 208
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 208
C
            GXCH(NB1+JBAS,NC1+KBAS) = GXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENC(ND2+LBAS,NA1+IBAS)
C
            GXCH(NB1+JBAS,NC2+KBAS) = GXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENC(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENC(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC1+KBAS) = GXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENC(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENC(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC2+KBAS) = GXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENC(ND2+LBAS,NA1+IBAS)
C
208         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 209
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 209
C
            GXCH(NC1+KBAS,NB1+JBAS) = GXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENC(NA2+IBAS,ND1+LBAS)
C
            GXCH(NC1+KBAS,NB2+JBAS) = GXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENC(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENC(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB1+JBAS) = GXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENC(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENC(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB2+JBAS) = GXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENC(NA2+IBAS,ND1+LBAS)
C
209         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 210
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 210
C
            GXCH(NC1+KBAS,NA1+IBAS) = GXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NB2+JBAS,ND1+LBAS)
C
            GXCH(NC1+KBAS,NA2+IBAS) = GXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA1+IBAS) = GXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENC(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENC(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA2+IBAS) = GXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NB2+JBAS,ND1+LBAS)
C
210         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 211
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 211
C
            GXCH(ND1+LBAS,NB1+JBAS) = GXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENC(NA2+IBAS,NC1+KBAS)
C
            GXCH(ND1+LBAS,NB2+JBAS) = GXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENC(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENC(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB1+JBAS) = GXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENC(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENC(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB2+JBAS) = GXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENC(NA2+IBAS,NC1+KBAS)
C
211         CONTINUE
          ENDDO
        ENDDO
      ENDIF

C
5002  CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS...                                      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5100
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 301
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 301
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,ND2+LBAS)
C
301         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 302
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 302
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NC2+KBAS)
C
302         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 303
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 303
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,NB2+JBAS)
C
303         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 304
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 304
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,NA2+IBAS)
C
304         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 305
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 305
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,NB2+JBAS)
C
305         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 306
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 306
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NB2+JBAS)
C
306         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 307
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 307
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NC2+KBAS,NA2+IBAS)
C
307         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 308
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 308
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENO(ND2+LBAS,NA2+IBAS)
C
308         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 309
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 309
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,ND2+LBAS)
C
309         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 310
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 310
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,ND2+LBAS)
C
310         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 311
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 311
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(NA2+IBAS,NC2+KBAS)
C
311         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ILIN.EQ.1) GOTO 5003
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 401
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 401
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,ND1+LBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,ND1+LBAS)
C
401        CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 402
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 402
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NC1+KBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NC1+KBAS)
C
402         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 403
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 403
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,NB1+JBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,NB1+JBAS)
C
403         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 404
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 404
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,NA1+IBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,NA1+IBAS)
C
404         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 405
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 405
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,ND2+LBAS) = QXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND1+LBAS) = QXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,NB1+JBAS)
C
405         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 406
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 406
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,NC2+KBAS) = QXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC1+KBAS) = QXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NB1+JBAS)
C
406         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 407
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 407
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NC2+KBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,ND2+LBAS) = QXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND1+LBAS) = QXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NC2+KBAS,NA1+IBAS)
C
407         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 408
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 408
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENO(ND2+LBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,NC2+KBAS) = QXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC1+KBAS) = QXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENO(ND2+LBAS,NA1+IBAS)
C
408         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 409
            N = N+1
            IF(IMTX(M,9).EQ.0) GOTO 409
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NB2+JBAS) = QXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB1+JBAS) = QXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,ND1+LBAS)
C
409         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 410
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 410
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NA2+IBAS) = QXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA1+IBAS) = QXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,ND1+LBAS)
C
410         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 411
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 411
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(NA2+IBAS,NC1+KBAS)
C
            QXCH(ND1+LBAS,NB2+JBAS) = QXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB1+JBAS) = QXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(NA2+IBAS,NC1+KBAS)
C
411         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     SKIP POINT FOR LINEAR BATCH
5003  CONTINUE
C     SKIPPING POINT FOR CLOSED SYSTEMS
5100  CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
      SUBROUTINE BREIT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT               C
C               BB    BB RR    RR EE        II     TT                  C
C               BB    BB RR    RR EE        II     TT                  C
C               BBBBBBB  RR    RR EEEEEE    II     TT                  C
C               BB    BB RRRRRRR  EE        II     TT                  C
C               BB    BB RR    RR EE        II     TT                  C
C               BBBBBBB  RR    RR EEEEEEEE IIII    TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT GENERATES ELECTRON INTERACTION INTEGRALS IN BATCHES AND       C
C  CALCULATES THE SCF BREIT MATRIX (B). INTEGRAL SYMMETRY IS PARTIALLY C
C  PARTIALLY EXPLOITED, BUT WITH ROOM FOR IMPROVEMENT.                 C
C  (GEOMETRIC SYMM, R-INT SYMM, E-COEFF SYMM).                         C
C -------------------------------------------------------------------- C
C  DFNOTE: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.  C
C          LOOK INTO OPEN SHELL EXTENSIONS AND CASES WITH ZERO DIRECT. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4  HMLTN
      CHARACTER*8  SHAPE
      CHARACTER*80 TITLE
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      DIMENSION GDSC(MDM,MDM),BDSC(MDM,MDM)
      DIMENSION BMAT(MDM,MDM)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-MKP:MKP,2*(MKP+1)*MKP),ICNT(4)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GEOM/SHAPE
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/SWRZ/GDSC,BDSC
      COMMON/T2EL/F2ES(5,7),T2ES(5,7),N2EB(5,7),N2EI(5,7),N2ES(5,7)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     SCREENING SENSITIVITY TOLERANCE
      SENS = 1.0D-12
C
C     OVERRIDE ISCF UNTIL INTEGRAL SYMMETRIES HAVE BEEN IDENTIFIED
      DO ITSCF=1,2
        DO ISYM=1,11
          ISCF(ISYM,ITSCF) = 1
        ENDDO
      ENDDO
C
C     SKIP CASES WHEN IQL=IQR
      ISCF( 3,2) = 0
      ISCF( 4,2) = 0
      ISCF( 9,2) = 0
      ISCF(10,2) = 0
      ISCF(11,2) = 0
C
C     SAVED BATCHES OF R(AB|CD) INTEGRALS IN ERI
      IF(IEQS.EQ.0) THEN
        IERC = 0
      ELSE
        IERC = 1
      ENDIF
C
C     LINEAR MOLECULE SHORTCUT OPTION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TWO-ELECTRON COMPONENT OVERLAP INDEX
      ITT = 5
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTERS
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTER
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KVALS(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
          IF(KAPPA.GT.0) THEN
            LQNN = KAPPA
          ELSE
            LQNN =-KAPPA-1
          ENDIF
          NFUN = NFUNCT(LQNN+1,ICT)
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER CENTER C
      DO 1000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER C
        XYZ(1,3) = COORD(1,ICNTC)
        XYZ(2,3) = COORD(2,ICNTC)
        XYZ(3,3) = COORD(3,ICNTC)
C
C     LOOP OVER CENTER D
      DO 1000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER D
        XYZ(1,4) = COORD(1,ICNTD)
        XYZ(2,4) = COORD(2,ICNTD)
        XYZ(3,4) = COORD(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTERS INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTER CONTRIBUTIONS (DEFER TO BREIT1)
C      IF(MCNT.EQ.1) THEN
C        GOTO 1001
C      ENDIF
C
C     SKIP MULTI-CENTER CONTRIBUTIONS IN STAGE 1
      IF(MCNT.NE.1.AND.ILEV.EQ.1) GOTO 1001
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES (USE INDEX 2000)                C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KVALS(KC,ICNTC)
        IF(KQN(3).GT.0) THEN
          LQN(3) = KQN(3)
        ELSE
          LQN(3) =-KQN(3)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFUNCT(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = EXPSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KVALS(KD,ICNTD)
        IF(KQN(4).GT.0) THEN
          LQN(4) = KQN(4)
        ELSE
          LQN(4) =-KQN(4)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFUNCT(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = EXPSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| PROJECTIONS (INDEX 3000)                     C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IEAB  = 1
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      IECD  = 1
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ILIN.EQ.1) THEN
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) GOTO 3003
        GOTO 3001
      ENDIF
3003  CONTINUE
C
C**********************************************************************C
C     IDENTIFICATION OF ERI SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     STARTING INDEX VALUES
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
C     IF(IQ1.LT.IQ2) GOTO 3001
C     IF(IQ3.LT.IQ4) GOTO 3001
C
      IF(IQL.GT.IQR) THEN
C       IQL > IQR
        ITSCF = 1
      ELSEIF(IQL.EQ.IQR) THEN
C       IQL = IQR
        ITSCF = 2
      ELSEIF(IQL.LT.IQR) THEN
C       IQL < IQR
        GOTO 3001
      ENDIF
C
C     READ IN FLAG VALUES FROM ISCF DATA BLOCK
      DO ISYM=1,11
        IFLG(ISYM) = ISCF(ISYM,ITSCF)
      ENDDO
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
C     NB! OPPOSITE PHASE AS IN THE LL/SS CASE SEEN IN SCF
      PAB1 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C     FURTHER DEFINE STARTING ADDRESSES FOR {ABCD} BASIS OVERLAPS
      NA1 = LARGE(ICNTA,KA,2*MA-1)
      NA2 = LARGE(ICNTA,KA,2*MA  )
      NB1 = LARGE(ICNTB,KB,2*MB-1) + NSHIFT
      NB2 = LARGE(ICNTB,KB,2*MB  ) + NSHIFT
      NC1 = LARGE(ICNTC,KC,2*MC-1)
      NC2 = LARGE(ICNTC,KC,2*MC  )
      ND1 = LARGE(ICNTD,KD,2*MD-1) + NSHIFT
      ND2 = LARGE(ICNTD,KD,2*MD  ) + NSHIFT
C
C     UPDATE COUNTER FOR NUMBER OF BLOCKS
      N2EB(MCNT,ITT) = N2EB(MCNT,ITT) + 1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) TO CONSTRUCT BMAT/WMAT     C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL CPU_TIME(TI)
C
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
          ITOG = 0
          CALL SCHWARZ(BDSC,SENS,TB2S)
C
C         UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
          N2EI(MCNT,ITT) = N2EI(MCNT,ITT)+NBAS(3)*NBAS(4)
          N2ES(MCNT,ITT) = N2ES(MCNT,ITT)+NBAS(3)*NBAS(4)-MAXN
C
C         CONDITIONAL TO SKIP THIS BATCH
          IF(IBCH.EQ.1) THEN
C
C           GENERATE A BATCH OF BREIT INTERACTION INTEGRALS
            CALL BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
C
C           MULTIPLY BY DENSITY ELEMENTS AND ADD TO BMAT/WMAT
            CALL BRTMAT(RR,IFLG,TBMC)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C     RECORD TIME AT END OF BATCH
      CALL CPU_TIME(TF)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + TF - TI
C
3001  CONTINUE
3000  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF BREIT MATRIX BY MATRIX CONJUGATION.     C
C**********************************************************************C
C
      DO I=1,NSHIFT
        DO J=NSHIFT+1,NDIM
          BDIR(J,I) = DCONJG(BDIR(I,J))
          BXCH(J,I) = DCONJG(BXCH(I,J))
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS (LIFTED FROM COULOMB)
C      DO J=1,NDIM
C        DO I=1,NDIM
C          WDIR(I,J) = ACFF*WDIR(I,J)
C          WXCH(I,J) = BCFF*WXCH(I,J)
C        ENDDO
C      ENDDO
C
      TITLE = 'BDIR_ARRAY'
C      CALL ARRYPLT(DREAL(BXCH),TITLE,NDIM)
C
      RETURN
      END
C
C
      SUBROUTINE BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          BBBBBBB IIII IIII                           C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB  II   II                            C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB IIII IIII                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    XYZ(3,4)    - COORDINATES OF THE NUCLEAR CENTERS IN THIS BLOCK.   C
C    KQN(4)      - KQN RELATIVISTIC LABELS OF THE CENTERS.             C
C    MQN(4)      - |MQN| QUANTUM NUMBERS OF THE CENTERS.               C
C    NBAS(4)     - NUMBER OF FUNCTIONS IN BLOCK.                       C
C    EXPT(MBS,4) - LIST OF EXPONENTS IN THE BLOCK.                     C
C    IBAS,JBAS   - COMPONENT LABEL INDEX FOR AB BASIS FUNCTIONS.       C
C  OUTPUT:                                                             C
C    RR(MB2,16) - BII'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
      CHARACTER*8 SHAPE
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MEQ,3),IABI11(MEQ,3),IABR21(MEQ,3),IABI21(MEQ,3)
      DIMENSION ICDR11(MEQ,3),ICDI11(MEQ,3),ICDR21(MEQ,3),ICDI21(MEQ,3)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
      DIMENSION T(MB2),IDX(3),JDX(3)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ,3),EAB21(MB2,MEQ,3),
     &           ECD11(MB2,MEQ,3),ECD21(MB2,MEQ,3)
C
      SAVE EAB11,EAB21,IABR11,IABI11,IABR21,IABI21
      SAVE ECD11,ECD21,ICDR11,ICDI11,ICD221,ICDI21
      SAVE RCTTFL,IRCTTFL
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GEOM/SHAPE
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      DATA ROOTPI5,SENS/17.4934183276248628D0,1.0D-10/
C
C     LINEAR MOLECULE SKIP CONDITION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      DO N=1,4
        IF(KQN(N).LT.0) THEN
         LQN(N) =-KQN(N)-1
        ELSE
         LQN(N) = KQN(N)
        ENDIF
      ENDDO
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTOR FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ-COEFFICIENT ADDRESSES
      LAMAB = LQN(1)+LQN(2)+1
      LAMCD = LQN(3)+LQN(4)+1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR CONTRACTED R-INTEGRAL BATCH
C     DFNOTE: APPEAR TO NEED EXTRA FACTOR OF 2. EXPLAIN?
      LAMABCD = LAMAB+LAMCD+2
C
C     VRS TOTAL LENGTH OF EQ-COEFFICIENT LISTS AND R-INTEGRAL BATCH
      NTUVAB   = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD   = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ = (IBAS-1)*NBAS(2) + JBAS
      EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
C
C     INITIALISE AND RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
      IF(IEQS.EQ.0) THEN
        CALL EMAKEB3(EAB11,EAB21,EXPT,XYZ,KQN,MQN,NBAS,IPHSAB,1,2)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVAB
          IAD = IABLS + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            EAB11(M,ITUV,1)=DCMPLX(EILSFL(IAD+M, 1),EILSFL(IAD+M, 2))
            EAB21(M,ITUV,1)=DCMPLX(EILSFL(IAD+M, 3),EILSFL(IAD+M, 4))
            EAB11(M,ITUV,2)=DCMPLX(EILSFL(IAD+M, 5),EILSFL(IAD+M, 6))
            EAB21(M,ITUV,2)=DCMPLX(EILSFL(IAD+M, 7),EILSFL(IAD+M, 8))
            EAB11(M,ITUV,3)=DCMPLX(EILSFL(IAD+M, 9),EILSFL(IAD+M,10))
            EAB21(M,ITUV,3)=DCMPLX(EILSFL(IAD+M,11),EILSFL(IAD+M,12))
          ENDDO
        ENDDO
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      TELS = TELS + TDM2 - TDM1
C
C     SCREENING PROCEDURE: NORM SUM OF E-COEFFICIENT LIST FOR EACH IAB
      DO ICMP=1,3
        DO IAB=1,NTUVAB
C
C         Re{E(AB|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            SUM = SUM + DABS(DREAL(EAB11(M,IAB,ICMP)))
            IF(SUM.GT.SENS) THEN
              IABR11(IAB,ICMP) = 1
              GOTO 101
            ENDIF
          ENDDO
          IABR11(IAB,ICMP) = 0
101       CONTINUE
C
C         Im{E(AB|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            SUM = SUM + DABS(DIMAG(EAB11(M,IAB,ICMP)))
            IF(SUM.GT.SENS) THEN
              IABI11(IAB,ICMP) = 1
              GOTO 102
            ENDIF
          ENDDO
          IABI11(IAB,ICMP) = 0
102       CONTINUE
C
C         Re{E(AB|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            SUM = SUM + DABS(DREAL(EAB21(M,IAB,ICMP)))
            IF(SUM.GT.SENS) THEN
              IABR21(IAB,ICMP) = 1
              GOTO 103
            ENDIF
          ENDDO
          IABR21(IAB,ICMP) = 0
103       CONTINUE
C
C         Im{E(AB|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            SUM = SUM + DABS(DIMAG(EAB21(M,IAB,ICMP)))
            IF(SUM.GT.SENS) THEN
              IABI21(IAB,ICMP) = 1
              GOTO 104
            ENDIF
          ENDDO
          IABI21(IAB,ICMP) = 0
104       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     GENERATE ELS(CD) COEFFICIENTS
      IF(IEQS.EQ.0) THEN
        CALL EMAKEB3(ECD11,ECD21,EXPT,XYZ,KQN,MQN,NBAS,IPHSCD,3,4)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVCD
          IAD = ICDLS + (ITUV-1)*MAXCD
          DO M=1,MAXCD
            ECD11(M,ITUV,1) = DCMPLX(EILSFL(IAD+M,13),EILSFL(IAD+M,14))
            ECD21(M,ITUV,1) = DCMPLX(EILSFL(IAD+M,15),EILSFL(IAD+M,16))
            ECD11(M,ITUV,2) = DCMPLX(EILSFL(IAD+M,17),EILSFL(IAD+M,18))
            ECD21(M,ITUV,2) = DCMPLX(EILSFL(IAD+M,19),EILSFL(IAD+M,20))
            ECD11(M,ITUV,3) = DCMPLX(EILSFL(IAD+M,21),EILSFL(IAD+M,22))
            ECD21(M,ITUV,3) = DCMPLX(EILSFL(IAD+M,23),EILSFL(IAD+M,24))
          ENDDO
        ENDDO
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      TELS = TELS + TDM2 - TDM1
C
C     SCREENING PROCEDURE: NORM SUM OF E-COEFFICIENT LIST FOR EACH ICD
      DO JCMP=1,3
        DO ICD=1,NTUVCD
C
C         Re{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(DREAL(ECD11(M,ICD,JCMP)))
            IF(SUM.GT.SENS) THEN
              ICDR11(ICD,JCMP) = 1
              GOTO 201
            ENDIF
          ENDDO
          ICDR11(ICD,JCMP) = 0
201       CONTINUE
C
C         Im{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(DIMAG(ECD11(M,ICD,JCMP)))
            IF(SUM.GT.SENS) THEN
              ICDI11(ICD,JCMP) = 1
              GOTO 202
            ENDIF
          ENDDO
          ICDI11(ICD,JCMP) = 0
202       CONTINUE
C
C         Re{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(DREAL(ECD21(M,ICD,JCMP)))
            IF(SUM.GT.SENS) THEN
              ICDR21(ICD,JCMP) = 1
              GOTO 203
            ENDIF
          ENDDO
          ICDR21(ICD,JCMP) = 0
203       CONTINUE
C
C         Im{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            SUM = SUM + DABS(DIMAG(ECD21(M,ICD,JCMP)))
            IF(SUM.GT.SENS) THEN
              ICDI21(ICD,JCMP) = 1
              GOTO 204
            ENDIF
          ENDDO
          ICDI21(ICD,JCMP) = 0
204       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL ASKED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL CPU_TIME(T2)
      TBEC = TBEC + T2 - T1
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) FROM SCRATCH OR READ-IN          C
C**********************************************************************C
C
C     FACTORS NEEDED IN BOTH CASES
C
C     GAUSSIAN OVERLAP CENTER
      PX = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF((IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.0.AND.ISCR(M).EQ.1)
     &       .OR.(IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.1)
     &       .OR.(IERC.EQ.0.AND.ISCR(M).EQ.1)) THEN
            N   = N+1
            EKL = EXPT(KBAS,3)+EXPT(LBAS,4)
            QX  = (XYZ(1,3)*EXPT(KBAS,3)+XYZ(1,4)*EXPT(LBAS,4))/EKL
            QY  = (XYZ(2,3)*EXPT(KBAS,3)+XYZ(2,4)*EXPT(LBAS,4))/EKL
            QZ  = (XYZ(3,3)*EXPT(KBAS,3)+XYZ(3,4)*EXPT(LBAS,4))/EKL
            APH(N)  = EIJ*EKL/(EIJ+EKL)
            PQ(N,1) = QX-PX
            PQ(N,2) = QY-PY
            PQ(N,3) = QZ-PZ
            EMX     = DSQRT(EIJ+EKL)*EIJ*EKL
            PRE(N)  = 2.0D0*ROOTPI5/EMX
          ENDIF
        ENDDO
      ENDDO
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     READ FROM LOCAL RC(AB|CD) FILE
      IF(IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.0) THEN
C
        CALL CPU_TIME(T1)
C
C       STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
        IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCD
C
C       READ RC(AB|CD) INTEGRALS FROM THIS STARTING POINT
        N = 0
        DO N=1,MAXN
          DO IABCD=1,NTUVABCD
            IAD = IADRTT + (IMAP(N)-1)*NTUVABCD + IABCD
            RC(N,IABCD) = RCTTFL(IAD)
          ENDDO
        ENDDO
C
C       STARTING ADDRESS FOR SCREENING FLAGS
        IADSCR = (IJ-1)*NTUVABCD
C
C       READ SCREENING FLAGS FROM THIS STARTING POINT
        DO IABCD=1,NTUVABCD
          IAD = IADSCR + IABCD
          IRC(IABCD) = IRCTTFL(IAD)
        ENDDO
C
C       RECORD TIME SPENT READING R-INTEGRALS
        CALL CPU_TIME(T2)
        TBRR = TBRR+T2-T1
C
      ENDIF
C
C     CALCULATE FROM SCRATCH
      IF(IERC.EQ.0.OR.IRIJ(IBAS,JBAS).EQ.1) THEN
C
        CALL CPU_TIME(T1)
C
C       GENERATE R-INTEGRALS
        CALL RMAKE(RC,PQ,APH,MAXN,LAMABCD)
C
C       SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
        DO IABCD=1,NTUVABCD
C
C         SUM OF RC(AB|CD) MAGNITUDES
          SUM = 0.0D0
          DO N=1,MAXN
            SUM = SUM + DABS(RC(N,IABCD))
            IF(SUM.GT.SENS) THEN
              IRC(IABCD) = 1
              GOTO 301
            ENDIF
          ENDDO
          IRC(IABCD) = 0
301       CONTINUE
C
        ENDDO
C
C       SAVE THIS SET TO APPROPRIATE CLASS ADDRESS
        IF(IERC.EQ.1) THEN
C
C         TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
          ILIM = IJ*NBAS(3)*NBAS(4)*NTUVABCD
C
          IF(ILIM.GT.20*MFL) THEN
C           OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
            WRITE(6, *) 'In BII: RCTT words exceed allocated limit.'
            WRITE(7, *) 'In BII: RCTT words exceed allocated limit.'
            GOTO 300
          ELSE
C           DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
            IRIJ(IBAS,JBAS) = 0
          ENDIF
C
C         STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
          IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCD

C         COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
          DO N=1,MAXN
            DO IABCD=1,NTUVABCD
              IAD = IADRTT + (N-1)*NTUVABCD + IABCD
              RCTTFL(IAD) = RC(N,IABCD)
            ENDDO
          ENDDO
C
C         STARTING ADDRESS FOR SCREENING FLAGS
          IADSCR = (IJ-1)*NTUVABCD
C
C         COPY SCREENING MARKERS TO A SAVED LIST
          DO IABCD=1,NTUVABCD
            IAD = IADSCR + IABCD
            IRCTTFL(IAD) = IRC(IABCD)
          ENDDO
C
C         SHORTEN THE CURRENT RC LIST WITH IMAP FROM SCREENING
          M = 0
          N = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              IF(ISCR(M).EQ.1) THEN
                N       = N+1
                APH(N)  = APH(M)
                PQ(N,1) = PQ(M,1)
                PQ(N,2) = PQ(M,2)
                PQ(N,3) = PQ(M,3)
                PRE(N)  = PRE(M)
                DO IABCD=1,NTUVABCD
                  RC(N,IABCD) = RC(M,IABCD)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
C
C         SHORTEN MAXN
          MAXN = N
C
        ENDIF
300     CONTINUE
C
        CALL CPU_TIME(T2)
        TBRM = TBRM+T2-T1
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL CPU_TIME(TDM2)
      TRBR = TRBR+TDM2-TDM1
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     LOOP OVER CARTESIAN INDEX ICMP FOR CENTER AB (USE INDEX 6000)
      DO 6000 ICMP=1,3
C
C     TIME AT START OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T1I)
C
C     CARTESIAN INDEX ICMP AS A VECTOR, IDX
      CALL NCART(IDX,ICMP)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) PASSES SCREENING CONDITION
        IF(IABR11(IAB,ICMP)+IABI11(IAB,ICMP)
     &                   +IABR21(IAB,ICMP)+IABI21(IAB,ICMP).EQ.0) THEN
          GOTO 401
        ENDIF
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO ICD=1,NTUVCD
C
C         SPECIAL CASE: CARTESIAN INDICES ARE EQUAL {-BXX, -BYY, -BZZ}
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = INABCD(IVEC(IAB)+IVEC(ICD),JVEC(IAB)+JVEC(ICD),
     &                                             KVEC(IAB)+KVEC(ICD))
C
C         SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
          IF(IRC(IRABCD).EQ.0) GOTO 402
C
C         SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
          IF(ICDR11(ICD,ICMP)+ICDI11(ICD,ICMP)
     &                   +ICDR21(ICD,ICMP)+ICDI21(ICD,ICMP).EQ.0) THEN
            GOTO 402
          ENDIF
C
C         CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
          IF(ILIN.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 411
          IF(ICDR11(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                    - DREAL(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
411       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
          IF(ILIN.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 412
          IF(ICDI11(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                    - DIMAG(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
412       CONTINUE
C
C         CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
          IF(ILIN.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 413
          IF(ICDR21(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                    - DREAL(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
413       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
          IF(ILIN.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 414
          IF(ICDI21(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                    - DIMAG(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
414       CONTINUE
C
C         SKIP POINT FOR RC(AB|CD) AND E(CD) SCREENING
402       CONTINUE
C
C         LOOP OVER CARTESIAN INDEX JCMP FOR CENTER CD
          DO JCMP=1,3
C
C           SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
            IF(ICDR11(ICD,JCMP)+ICDI11(ICD,JCMP)
     &                     +ICDR21(ICD,JCMP)+ICDI21(ICD,JCMP).EQ.0) THEN
              GOTO 403
            ENDIF
C
C           CARTESIAN INDEX JCMP AS A VECTOR, JDX
            CALL NCART(JDX,JCMP)
C
C           NEW ADDRESS DEPENDING ON JCMP CARTESIAN INDEX
            IF(JCMP.EQ.1) THEN
              RTP = DFLOAT(IVEC(IAB)+IVEC(ICD))
            ELSEIF(JCMP.EQ.2) THEN
              RTP = DFLOAT(JVEC(IAB)+JVEC(ICD))
            ELSEIF(JCMP.EQ.3) THEN
              RTP = DFLOAT(KVEC(IAB)+KVEC(ICD))
            ENDIF
C
C           FIRST CONTRIBUTION ADDRESS
            I1 = IVEC(IAB)+IVEC(ICD)+IDX(1)+JDX(1)
            J1 = JVEC(IAB)+JVEC(ICD)+IDX(2)+JDX(2)
            K1 = KVEC(IAB)+KVEC(ICD)+IDX(3)+JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR1 = INABCD(I1,J1,K1)
C
C           SECOND CONTRIBUTION ADDRESS
            I2 = IVEC(IAB)+IVEC(ICD)+IDX(1)
            J2 = JVEC(IAB)+JVEC(ICD)+IDX(2)
            K2 = KVEC(IAB)+KVEC(ICD)+IDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR2 = INABCD(I2,J2,K2)
C
C           THIRD CONTRIBUTION ADDRESS
            I3 = IVEC(IAB)+IVEC(ICD)+IDX(1)-JDX(1)
            J3 = JVEC(IAB)+JVEC(ICD)+IDX(2)-JDX(2)
            K3 = KVEC(IAB)+KVEC(ICD)+IDX(3)-JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
              IADR3 = INABCD(I3,J3,K3)
            ELSE
              IADR3 = 0
            ENDIF
C
C           SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
            IF(IADR3.NE.0) THEN
              IF(IRC(IADR1)+IRC(IADR2)+IRC(IADR3).EQ.0) GOTO 403
            ELSE
              IF(IRC(IADR1)+IRC(IADR2).EQ.0) GOTO 403
            ENDIF
C
C           PRE-FACTORS FOR THE UPCOMING CONTRACTION
            IF(IADR3.NE.0) THEN
              DO N=1,MAXN
                T1 = RC(N,IADR1)*0.5D0/APH(N)
                T2 = RC(N,IADR2)*PQ(N,JCMP)
                T3 = RC(N,IADR3)*RTP
                T(N) = T1-T2+T3
              ENDDO
            ELSEIF(ITHRD.EQ.0) THEN
              DO N=1,MAXN
                T1 = RC(N,IADR1)*0.5D0/APH(N)
                T2 = RC(N,IADR2)*PQ(N,JCMP)
                T(N) = T1-T2
              ENDDO           
            ENDIF
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ILIN.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 415
            IF(ICDR11(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABR11(N,IAB) = GABR11(N,IAB)
     &                            + DREAL(ECD11(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
415         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ILIN.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 416
            IF(ICDI11(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABI11(N,IAB) = GABI11(N,IAB)
     &                            + DIMAG(ECD11(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
416         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ILIN.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 417
            IF(ICDR21(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABR21(N,IAB) = GABR21(N,IAB)
     &                            + DREAL(ECD21(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
417         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ILIN.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 418
            IF(ICDI21(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABI21(N,IAB) = GABI21(N,IAB)
     &                            + DIMAG(ECD21(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
418         CONTINUE
C
C         SKIP POINT FOR E(CD) SCREENING
403       CONTINUE
C
C         END LOOP OVER CARTESIAN INDEX JCMP FOR CENTER CD
          ENDDO
C
C       END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
        ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T1F)
      TBC1 = TBC1+T1F-T1I
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB =-ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD =-ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)        (16 AND 13 LATER)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,1 ) = RR(N,1 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,4 ) = RR(N,4 ) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
      IF(ILIN.EQ.1) GOTO 501
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)        (14 AND 15 LATER)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,3 ) = RR(N,3 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,2 ) = RR(N,2 ) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)        ( 8 AND  5 LATER)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,9 ) = RR(N,9 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = RR(N,12) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
501   CONTINUE
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)        ( 6 AND  7 LATER)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) = RR(N,11) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) = RR(N,10) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     TIME AT END OF SECOND CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T2F)
      TBC2 = TBC2+T2F-T1F
C
C     END LOOP OVER CARTESIAN INDICES {IX,IY,IZ}
6000  CONTINUE
C
C     HALF OF THE RR ARRAY CAN BE GENERATED WITH PHASE RELATIONS
      DO N=1,MAXN
        RR(N,16) = PABCD*DCONJG(RR(N,1))
        RR(N,13) = PABCD*DCONJG(RR(N,4))
        RR(N,14) =-PABCD*DCONJG(RR(N,3))
        RR(N,15) =-PABCD*DCONJG(RR(N,2))
        RR(N,8 ) =-PABCD*DCONJG(RR(N,9 ))
        RR(N,5 ) =-PABCD*DCONJG(RR(N,12))
        RR(N,6 ) = PABCD*DCONJG(RR(N,11))
        RR(N,7 ) = PABCD*DCONJG(RR(N,10))
      ENDDO     
C
C**********************************************************************C
C     BREIT INTEGRAL BATCH NOW FULLY CONSTRUCTED                       C
C**********************************************************************C
C
C     INCLUDE THE OUTSIDE FACTOR OF (1/2) AND MOVE TO FULL ARRAY
      DO N=1,MAXN
        DO ITG=1,16
          RR(N,ITG) = 0.5D0*PRE(N)*RR(N,ITG)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BRTMAT(RR,IFLG,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        BBBBBBB  RRRRRRR TTTTTTTT MM       MM    AA   TTTTTTTT        C
C        BB    BB RR    RR   TT    MMM     MMM   AAAA     TT           C
C        BB    BB RR    RR   TT    MMMM   MMMM  AA  AA    TT           C
C        BBBBBBB  RR    RR   TT    MM MM MM MM AA    AA   TT           C
C        BB    BB RRRRRRR    TT    MM  MMM  MM AAAAAAAA   TT           C
C        BB    BB RR    RR   TT    MM   M   MM AA    AA   TT           C
C        BBBBBBB  RR    RR   TT    MM       MM AA    AA   TT           C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTMAT MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF BREIT MATRICES.       C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO ERI):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C    NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C    IFLG(11)   - INTEGRAL SYMMETRY FLAGS.                             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      DIMENSION IFLG(11),NBAS(4)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS... (NO DIRECT TERMS)                  C
C**********************************************************************C
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 105
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 105
C
            BXCH(NA1+IBAS,ND1+LBAS) = BXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENC(NC2+KBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,ND2+LBAS) = BXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENC(NC2+KBAS,NB2+JBAS)
C
105         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 106
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 106
C
            BXCH(NA1+IBAS,NC1+KBAS) = BXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENC(ND2+LBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,NC2+KBAS) = BXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENC(ND2+LBAS,NB2+JBAS)
C
106         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 107
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 107
C
            BXCH(NB1+JBAS,ND1+LBAS) = BXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NC2+KBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,ND2+LBAS) = BXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NC2+KBAS,NA2+IBAS)
C
107         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 108
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 108
C
            BXCH(NB1+JBAS,NC1+KBAS) = BXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENC(ND2+LBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,NC2+KBAS) = BXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENC(ND2+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENC(ND1+LBAS,NA1+IBAS)
C
108         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 109
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 109
C
            BXCH(NC1+KBAS,NB1+JBAS) = BXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENC(NA2+IBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NB2+JBAS) = BXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENC(NA2+IBAS,ND2+LBAS)
C
109         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 110
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 110
C
            BXCH(NC1+KBAS,NA1+IBAS) = BXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENC(NB2+JBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NA2+IBAS) = BXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NB2+JBAS,ND2+LBAS)
C
110         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 111
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 111
C
            BXCH(ND1+LBAS,NB1+JBAS) = BXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(NA2+IBAS,NC2+KBAS)
C
            BXCH(ND2+LBAS,NB2+JBAS) = BXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENC(NA2+IBAS,NC2+KBAS)
C
111         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ILIN.EQ.1) GOTO 5002
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 205
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 205
C
            BXCH(NA1+IBAS,ND1+LBAS) = BXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENC(NC2+KBAS,NB1+JBAS)
C
            BXCH(NA1+IBAS,ND2+LBAS) = BXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENC(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENC(NC2+KBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,ND1+LBAS) = BXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENC(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENC(NC2+KBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,ND2+LBAS) = BXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENC(NC2+KBAS,NB1+JBAS)
C
205         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 206
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 206
C
            BXCH(NA1+IBAS,NC1+KBAS) = BXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENC(ND2+LBAS,NB1+JBAS)
C
            BXCH(NA1+IBAS,NC2+KBAS) = BXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENC(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENC(ND2+LBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,NC1+KBAS) = BXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENC(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENC(ND2+LBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,NC2+KBAS) = BXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENC(ND2+LBAS,NB1+JBAS)
C
206         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 207
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 207
C
            BXCH(NB1+JBAS,ND1+LBAS) = BXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENC(NC2+KBAS,NA1+IBAS)
C
            BXCH(NB1+JBAS,ND2+LBAS) = BXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENC(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NC2+KBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,ND1+LBAS) = BXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENC(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NC2+KBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,ND2+LBAS) = BXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENC(NC2+KBAS,NA1+IBAS)
C
207         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 208
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 208
C
            BXCH(NB1+JBAS,NC1+KBAS) = BXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENC(ND2+LBAS,NA1+IBAS)
C
            BXCH(NB1+JBAS,NC2+KBAS) = BXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENC(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENC(ND2+LBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,NC1+KBAS) = BXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENC(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENC(ND2+LBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,NC2+KBAS) = BXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENC(ND2+LBAS,NA1+IBAS)
C
208         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 209
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 209
C
            BXCH(NC1+KBAS,NB1+JBAS) = BXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENC(NA2+IBAS,ND1+LBAS)
C
            BXCH(NC1+KBAS,NB2+JBAS) = BXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENC(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENC(NA2+IBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NB1+JBAS) = BXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENC(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENC(NA2+IBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NB2+JBAS) = BXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENC(NA2+IBAS,ND1+LBAS)
C
209         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 210
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 210
C
            BXCH(NC1+KBAS,NA1+IBAS) = BXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NB2+JBAS,ND1+LBAS)
C
            BXCH(NC1+KBAS,NA2+IBAS) = BXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NB2+JBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NA1+IBAS) = BXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENC(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENC(NB2+JBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NA2+IBAS) = BXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NB2+JBAS,ND1+LBAS)
C
210         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 211
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 211
C
            BXCH(ND1+LBAS,NB1+JBAS) = BXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENC(NA2+IBAS,NC1+KBAS)
C
            BXCH(ND1+LBAS,NB2+JBAS) = BXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENC(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENC(NA2+IBAS,NC2+KBAS)
C
            BXCH(ND2+LBAS,NB1+JBAS) = BXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENC(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENC(NA2+IBAS,NC2+KBAS)
C
            BXCH(ND2+LBAS,NB2+JBAS) = BXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENC(NA2+IBAS,NC1+KBAS)
C
211         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     SKIP POINT FOR LINEAR BATCH
5002  CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS... (NOTE: WILL NEED WDIR/WXCH INSTEAD)  C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5100
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 301
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 301
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,ND2+LBAS)
C
301         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 302
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 302
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NC2+KBAS)
C
302         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 303
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 303
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,NB2+JBAS)
C
303         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 304
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 304
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,NA2+IBAS)
C
304         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 305
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 305
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,NB2+JBAS)
C
305         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 306
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 306
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NB2+JBAS)
C
306         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 307
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 307
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NC2+KBAS,NA2+IBAS)
C
307         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 308
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 308
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENO(ND2+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENO(ND1+LBAS,NA1+IBAS)
C
308         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 309
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 309
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,ND2+LBAS)
C
309         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 310
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 310
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,ND2+LBAS)
C
310         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 311
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 311
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(NA2+IBAS,NC2+KBAS)
C
311         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ILIN.EQ.1) GOTO 5003
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 401
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 401
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,ND1+LBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,ND1+LBAS)
C
401         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 402
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 402
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NC1+KBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NC1+KBAS)
C
402         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 403
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 403
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,NB1+JBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,NB1+JBAS)
C
403         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 404
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 404
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,NA1+IBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,NA1+IBAS)
C
404         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 405
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 405
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,ND2+LBAS) = QXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND1+LBAS) = QXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,NB1+JBAS)
C
405         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 406
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 406
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,NC2+KBAS) = QXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC1+KBAS) = QXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NB1+JBAS)
C
406         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 407
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 407
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NC2+KBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,ND2+LBAS) = QXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND1+LBAS) = QXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NC2+KBAS,NA1+IBAS)
C
407         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 408
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 408
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENO(ND2+LBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,NC2+KBAS) = QXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC1+KBAS) = QXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENO(ND2+LBAS,NA1+IBAS)
C
408         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 409
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 409
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NB2+JBAS) = QXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB1+JBAS) = QXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,ND1+LBAS)
C
409         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 410
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 410
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NA2+IBAS) = QXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA1+IBAS) = QXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,ND1+LBAS)
C
410         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 411
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 411
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(NA2+IBAS,NC1+KBAS)
C
            QXCH(ND1+LBAS,NB2+JBAS) = QXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB1+JBAS) = QXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(NA2+IBAS,NC1+KBAS)
C
411         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     SKIP POINT FOR LINEAR BATCH
5003  CONTINUE
C     SKIPPING POINT FOR CLOSED SYSTEMS
5100  CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
      SUBROUTINE COULOMB1
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  CCCCCC   OOOOOO  UU    UU LL      OOOOOO  MM       MM BBBBBBB   11  C
C CC    CC OO    OO UU    UU LL     OO    OO MMM     MMM BB    BB 111  C
C CC       OO    OO UU    UU LL     OO    OO MMMM   MMMM BB    BB  11  C
C CC       OO    OO UU    UU LL     OO    OO MM MM MM MM BBBBBBB   11  C
C CC       OO    OO UU    UU LL     OO    OO MM  MMM  MM BB    BB  11  C
C CC    CC OO    OO UU    UU LL     OO    OO MM   M   MM BB    BB  11  C
C  CCCCCC   OOOOOO   UUUUUU  LLLLLLL OOOOOO  MM       MM BBBBBBB  1111 C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB1 CONSTRUCTS ALL ONE-CENTRE CONTRIBUTIONS TO THE MOLECULAR   C
C  MEAN-FIELD COULOMB MATRIX BY USING A RACAH ALGEBRA DECOMPOSITION    C
C  OF TWO-ELECTRON MATRIX ELEMENTS.                                    C
C -------------------------------------------------------------------- C
C  (THIS ROUTINE IS SIMILAR TO THE IN-LINE CONSTRUCTION OF MEAN-FIELD  C
C   ATOMIC COULOMB MATRIX IN HFSCF0, BUT WITH MQN STRUCTURE AS WELL.)  C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MNU=MKP+1
     &                                                          ,MAB=10)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),KQN(4),MQN(4),NBAS(4),LQN(4)
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
      DIMENSION RLL(MB2),RSL(MB2),RLS(MB2),RSS(MB2)
C
      COMPLEX*16 GLLLL,GLLSS,GSSLL,GSSSS
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/T2EL/F2ES(5,7),T2ES(5,7),N2EB(5,7),N2EI(5,7),N2ES(5,7)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
      COMMON/XBIJ/EIJ1(MAB),EIJ2(MAB),RNIJ(4),EI,EJ
      COMMON/XCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XMAT/XLLLL(MB2,MNU),XLLSS(MB2,MNU),
     &            XSSLL(MB2,MNU),XSSSS(MB2,MNU)
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
      DATA SENS/5.0D-9/
C
      CALL CPU_TIME(TBCH1)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTERS (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER ALL CENTERS
      DO 1000 ICNT=1,NCNT
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPE FOR A,B,C,D BLOCKS (USE INDEX 2000)  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNT)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNT)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNT)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNT)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2000 KC=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KVALS(KC,ICNT)
        IF(KQN(3).GT.0) THEN
          LQN(3) = KQN(3)
        ELSE
          LQN(3) =-KQN(3)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFUNCT(LQN(3)+1,ICNT)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = EXPSET(KBAS,LQN(3)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2000 KD=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KVALS(KD,ICNT)
        IF(KQN(4).GT.0) THEN
          LQN(4) = KQN(4)
        ELSE
          LQN(4) =-KQN(4)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFUNCT(LQN(4)+1,ICNT)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = EXPSET(LBAS,LQN(4)+1,ICNT)
        ENDDO
C
C**********************************************************************C
C     PREPARE INTERMEDIATE DATA FOR USE IN RABCD                       C
C**********************************************************************C
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C1 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+1)
      C3 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+3)
      C5 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+5)
      C7 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+7)
      C9 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+9)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
      V8 = 8.0D0
      VS = 1.6D1
C
      TI = DFLOAT(LQN(1)+KQN(1)+1)
      TJ = DFLOAT(LQN(2)+KQN(2)+1)
      TK = DFLOAT(LQN(3)+KQN(3)+1)
      TL = DFLOAT(LQN(4)+KQN(4)+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
C
C     ANGULAR COEFFICIENTS
      CALL CPU_TIME(T1)
      CALL ANGCLM1(DKAB,DKCD,KQN,LQN,NUS,NUF,NUI,NUNUM,ISEL)
      CALL CPU_TIME(T2)
      TC1B = TC1B+T2-T1
C
C     EXIT THIS COMBINATION IF NO CONTRIBUTING MULTIPOLES IN ANGLES
      IF(ISEL.EQ.0) GOTO 2001
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL CPU_TIME(T1)
      CALL PREPKL(LQN,KC,NBAS(3),KD,NBAS(4),ICNT)
      CALL CPU_TIME(T2)
      TC1B = TC1B+T2-T1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 3000)         C
C**********************************************************************C
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      IF(HMLTN.EQ.'NORL') THEN
        N2EB(1,1) = N2EB(1,1) + 1
      ELSE
        N2EB(1,1) = N2EB(1,1) + 1
        N2EB(1,2) = N2EB(1,2) + 1
        N2EB(1,3) = N2EB(1,3) + 1
        N2EB(1,4) = N2EB(1,4) + 1
      ENDIF
C
      DO 3000 IBAS=1,NBAS(1)
      DO 3000 JBAS=1,NBAS(2)
C
C       UPDATE COUNTER FOR NUMBER OF INTEGRALS
        IF(HMLTN.EQ.'NORL') THEN
          N2EI(1,1) = N2EI(1,1)+NBAS(3)*NBAS(4)
        ELSE
          N2EI(1,1) = N2EI(1,1)+NBAS(3)*NBAS(4)
          N2EI(1,2) = N2EI(1,2)+NBAS(3)*NBAS(4)
          N2EI(1,3) = N2EI(1,3)+NBAS(3)*NBAS(4)
          N2EI(1,4) = N2EI(1,4)+NBAS(3)*NBAS(4)
        ENDIF
C
C       GAUSSIAN EXPONENTS FOR THIS PAIR
        EI = EXPT(IBAS,1)
        EJ = EXPT(JBAS,2)
C
C       BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
        CALL CPU_TIME(T1)
        CALL PREPIJ(LQN)
        CALL CPU_TIME(T2)
        TC1B = TC1B+T2-T1
C
C       BATCH OF RADIAL INTEGRALS (EFFECTIVE INTERACTION STRENGTHS)
        CALL CPU_TIME(T1)
        CALL RABCD(KQN,LQN,NBAS(3)*NBAS(4))
        CALL CPU_TIME(T2)
        TC1R = TC1R+T2-T1
C
C**********************************************************************C
C     LOOP OVER |KQN| MAGNITUDES FOR A,B,C,D BLOCKS (USE INDEX 4000)   C
C**********************************************************************C
C
      DO 4000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
      DO 4000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
      DO 4000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      DO 4000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     TRANSFORM THE X(L) INTO G-SPINOR MATRIX ELEMENTS USING
C     THE TENSOR EXPANSION IN {L,Q}
C
C     LOOP OVER THE SIGNS OF |MQN| AND DETERMINE FOCK ADDRESSES
      DO 5000 ISGN1=1,2
        MMJA = MQN(1)*((-1)**ISGN1)
        IMJA = MQN(1)+ISGN1-1
C
      DO 5000 ISGN2=1,2
        MMJB = MQN(2)*((-1)**ISGN2)
        IMJB = MQN(2)+ISGN2-1
C
      DO 5000 ISGN3=1,2
        MMJC = MQN(3)*((-1)**ISGN3)
        IMJC = MQN(3)+ISGN3-1
C
      DO 5000 ISGN4=1,2
        MMJD = MQN(4)*((-1)**ISGN4)
        IMJD = MQN(4)+ISGN4-1
C
C     STARTING FOCK ADDRESS FOR EACH BASIS LIST
      NAL = LARGE(ICNT,KA,IMJA)
      NBL = LARGE(ICNT,KB,IMJB)
      NCL = LARGE(ICNT,KC,IMJC)
      NDL = LARGE(ICNT,KD,IMJD)
C
      NAS = LARGE(ICNT,KA,IMJA) + NSHIFT
      NBS = LARGE(ICNT,KB,IMJB) + NSHIFT
      NCS = LARGE(ICNT,KC,IMJC) + NSHIFT
      NDS = LARGE(ICNT,KD,IMJD) + NSHIFT
C
C     APPLY ANGULAR MQN SELECTION RULE
      IF(MMJA-MMJB.NE.MMJD-MMJC) GOTO 5001
C
C     RESET CONTRACTED RADIAL ARRAYS
      CALL CPU_TIME(T1)
      DO M=1,NBAS(3)*NBAS(4)
        RLL(M) = 0.0D0
        RLS(M) = 0.0D0
        RSL(M) = 0.0D0
        RSS(M) = 0.0D0
      ENDDO
C
C     ASSEMBLE INTEGRAL BY SUMMING OVER EXPANSION POWER L
      DO LTEN=1,NUNUM
C
C       ANGULAR COEFFICIENT
        ANGFAC = DKAB(LTEN,IMJA,IMJB)*DKCD(LTEN,IMJC,IMJD)
C
C       SCREENING OF INTEGRAL BASED ON ANGULAR COEFFICIENT
        IF(DABS(ANGFAC).LE.SENS) GOTO 5003
C
        IF(HMLTN.EQ.'NORL') THEN
C       NON-RELATIVISTIC HAMILTONIAN
C
          DO M=1,NBAS(3)*NBAS(4)
            RLL(M) = RLL(M) + ANGFAC*XLLLL(M,LTEN)
          ENDDO
C
        ELSE
C       RELATIVISTIC HAMILTONIAN
C
          DO M=1,NBAS(3)*NBAS(4)
            RLL(M) = RLL(M) + ANGFAC*XLLLL(M,LTEN)
            RLS(M) = RLS(M) + ANGFAC*XLLSS(M,LTEN)
            RSL(M) = RSL(M) + ANGFAC*XSSLL(M,LTEN)
            RSS(M) = RSS(M) + ANGFAC*XSSSS(M,LTEN)
          ENDDO
C
        ENDIF
C
C       SKIP POINT FOR ANGULAR SCREENING
5003    CONTINUE
C
      ENDDO
C
C     FULL-INTEGRAL CONSTRUCTION COMPLETE
      CALL CPU_TIME(T2)
      TC1F = TC1F+T2-T1
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO CLOSED-SHELL COULOMB MATRIX     C
C**********************************************************************C
C
      IF(HMLTN.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
C           DIRECT CONTRIBUTIONS
            GLLLL = RLL(M)*DENC(NCL+KBAS,NDL+LBAS)
            IF(ABS(GLLLL).GT.SENS) THEN
              GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS) + GLLLL
            ENDIF
C
C           EXCHANGE CONTRIBUTIONS
            GLLLL = RLL(M)*DENC(NCL+KBAS,NBL+JBAS)
            IF(ABS(GLLLL).GT.SENS) THEN
              GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS) + GLLLL
            ENDIF
C
          ENDDO
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
C           DIRECT CONTRIBUTIONS
            GLLLL = RLL(M)*DENC(NCL+KBAS,NDL+LBAS)
            IF(ABS(GLLLL).GT.SENS) THEN
              GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS) + GLLLL
            ENDIF
C
            GLLSS = RLS(M)*DENC(NCS+KBAS,NDS+LBAS)
            IF(ABS(GLLSS).GT.SENS) THEN
              GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS) + GLLSS
            ENDIF            
C
            GSSLL = RSL(M)*DENC(NCL+KBAS,NDL+LBAS)
            IF(ABS(GSSLL).GT.SENS) THEN
              GDIR(NAS+IBAS,NBS+JBAS) = GDIR(NAS+IBAS,NBS+JBAS) + GSSLL
            ENDIF
C
            GSSSS = RSS(M)*DENC(NCS+KBAS,NDS+LBAS)
            IF(ABS(GSSSS).GT.SENS) THEN
              GDIR(NAS+IBAS,NBS+JBAS) = GDIR(NAS+IBAS,NBS+JBAS) + GSSSS
            ENDIF
C
C           EXCHANGE CONTRIBUTIONS
            GLLLL = RLL(M)*DENC(NCL+KBAS,NBL+JBAS)
            IF(ABS(GLLLL).GT.SENS) THEN
              GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS) + GLLLL
            ENDIF
C
            GLLSS = RLS(M)*DENC(NCS+KBAS,NBL+JBAS)
            IF(ABS(GLLSS).GT.SENS) THEN
              GXCH(NAL+IBAS,NDS+LBAS) = GXCH(NAL+IBAS,NDS+LBAS) + GLLSS
            ENDIF
C
            GSSLL = RSL(M)*DENC(NCL+KBAS,NBS+JBAS)
            IF(ABS(GSSLL).GT.SENS) THEN
              GXCH(NAS+IBAS,NDL+LBAS) = GXCH(NAS+IBAS,NDL+LBAS) + GSSLL
            ENDIF
            
            GSSSS = RSS(M)*DENC(NCS+KBAS,NBS+JBAS)
            IF(ABS(GSSSS).GT.SENS) THEN
              GXCH(NAS+IBAS,NDS+LBAS) = GXCH(NAS+IBAS,NDS+LBAS) + GSSSS
            ENDIF
C
          ENDDO
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL COULOMB MATRIX       C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 6100
C
      IF(HMLTN.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
C           DIRECT CONTRIBUTIONS
            GLLLL = ACFF*RLL(M)*DENO(NCL+KBAS,NDL+LBAS)
            IF(ABS(GLLLL).GT.SENS) THEN
              QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS) + GLLLL
            ENDIF
C
C           EXCHANGE CONTRIBUTIONS
            GLLLL = BCFF*RLL(M)*DENO(NCL+KBAS,NBL+JBAS)
            IF(ABS(GLLLL).GT.SENS) THEN
              QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS) + GLLLL
            ENDIF
C
          ENDDO
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
C           DIRECT CONTRIBUTIONS
            GLLLL = ACFF*RLL(M)*DENO(NCL+KBAS,NDL+LBAS)
            IF(ABS(GLLLL).GT.SENS) THEN
              QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS) + GLLLL
            ENDIF
C
            GLLSS = ACFF*RLS(M)*DENO(NCS+KBAS,NDS+LBAS)
            IF(ABS(GLLSS).GT.SENS) THEN
              QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS) + GLLSS
            ENDIF            
C
            GSSLL = ACFF*RSL(M)*DENO(NCL+KBAS,NDL+LBAS)
            IF(ABS(GSSLL).GT.SENS) THEN
              QDIR(NAS+IBAS,NBS+JBAS) = QDIR(NAS+IBAS,NBS+JBAS) + GSSLL
            ENDIF
C
            GSSSS = ACFF*RSS(M)*DENO(NCS+KBAS,NDS+LBAS)
            IF(ABS(GSSSS).GT.SENS) THEN
              QDIR(NAS+IBAS,NBS+JBAS) = QDIR(NAS+IBAS,NBS+JBAS) + GSSSS
            ENDIF
C
C           EXCHANGE CONTRIBUTIONS
            GLLLL = BCFF*RLL(M)*DENO(NCL+KBAS,NBL+JBAS)
            IF(ABS(GLLLL).GT.SENS) THEN
              QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS) + GLLLL
            ENDIF
C
            GLLSS = BCFF*RLS(M)*DENO(NCS+KBAS,NBL+JBAS)
            IF(ABS(GLLSS).GT.SENS) THEN
              QXCH(NAL+IBAS,NDS+LBAS) = QXCH(NAL+IBAS,NDS+LBAS) + GLLSS
            ENDIF
C
            GSSLL = BCFF*RSL(M)*DENO(NCL+KBAS,NBS+JBAS)
            IF(ABS(GSSLL).GT.SENS) THEN
              QXCH(NAS+IBAS,NDL+LBAS) = QXCH(NAS+IBAS,NDL+LBAS) + GSSLL
            ENDIF
            
            GSSSS = BCFF*RSS(M)*DENO(NCS+KBAS,NBS+JBAS)
            IF(ABS(GSSSS).GT.SENS) THEN
              QXCH(NAS+IBAS,NDS+LBAS) = QXCH(NAS+IBAS,NDS+LBAS) + GSSSS
            ENDIF
C
          ENDDO
        ENDDO
C
      ENDIF
C
6100  CONTINUE
C
C     MATRIX MULTIPLICATION STEP COMPLETE
      CALL CPU_TIME(T3)
      TC1M = TC1M+T3-T2
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL ONE-CENTER CONTRIBUTIONS.           C
C**********************************************************************C
C
C     EARLY EXIT FOR MQN SELECTION RULES
5001  CONTINUE
C     END LOOP OVER ALL |MQN| SIGNS
5000  CONTINUE
C     END LOOP OVER ALL |MQN| MAGNITUDES
4000  CONTINUE
C     END LOOP OVER IBAS AND JBAS
3000  CONTINUE
C     EARLY EXIT FOR KQN SELECTION RULES
2001  CONTINUE
C     END LOOP OVER ALL KQNS
2000  CONTINUE
C     END LOOP OVER ATOMIC CENTERS
1000  CONTINUE
C
C     RECORD CPU TIME AT END OF BATCH AND ADD TO APPROPRIATE COUNTER
      CALL CPU_TIME(TBCH2)
      IF(HMLTN.EQ.'NORL') THEN
        T2ES(1,1) = T2ES(1,1) + TBCH2 - TBCH1
      ELSE
        T2ES(1,1) = T2ES(1,1) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,2) = T2ES(1,2) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,3) = T2ES(1,3) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,4) = T2ES(1,4) + 0.25D0*(TBCH2-TBCH1)
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BREIT1
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT 11              C
C             BB    BB RR    RR EE        II     TT   111              C
C             BB    BB RR    RR EE        II     TT    11              C
C             BBBBBBB  RR    RR EEEEEE    II     TT    11              C
C             BB    BB RRRRRRR  EE        II     TT    11              C
C             BB    BB RR    RR EE        II     TT    11              C
C             BBBBBBB  RR    RR EEEEEEEE IIII    TT   1111             C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT CONSTRUCTS ALL ONE-CENTRE CONTRIBUTIONS TO THE MOLECULAR      C
C  MEAN-FIELD BREIT MATRIX BY USING A RACAH ALGEBRA DECOMPOSITION      C
C  OF TWO-ELECTRON MATRIX ELEMENTS.                                    C
C -------------------------------------------------------------------- C
C  (THIS ROUTINE IS SIMILAR TO THE IN-LINE CONSTRUCTION OF MEAN-FIELD  C
C   ATOMIC BREIT MATRIX IN HFSCF0, BUT WITH MQN STRUCTURE AS WELL.)    C
C -------------------------------------------------------------------- C
C  DFNOTE: NOT COMPLETE! THIS IS JUST A COPY OF COULOMB1 RIGHT NOW.    C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MNU=MKP+1,
     &                                                           MAB=10)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),KQN(4),MQN(4),NBAS(4),LQN(4)
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
      DIMENSION RLL(MB2),RSL(MB2),RLS(MB2),RSS(MB2)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/T2EL/F2ES(5,7),T2ES(5,7),N2EB(5,7),N2EI(5,7),N2ES(5,7)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
      COMMON/XBIJ/EIJ1(MAB),EIJ2(MAB),RNIJ(4),EI,EJ
      COMMON/XCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XMAT/XLLLL(MB2,MNU),XLLSS(MB2,MNU),
     &            XSSLL(MB2,MNU),XSSSS(MB2,MNU)
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
      DATA SENS/1.0D-12/
C
      CALL CPU_TIME(TBCH1)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTERS (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER ALL CENTERS
      DO 1000 ICNT=1,NCNT
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPE FOR A,B,C,D BLOCKS (USE INDEX 2000)  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNT)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNT)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNT)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNT)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2000 KC=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KVALS(KC,ICNT)
        IF(KQN(3).GT.0) THEN
          LQN(3) = KQN(3)
        ELSE
          LQN(3) =-KQN(3)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFUNCT(LQN(3)+1,ICNT)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = EXPSET(KBAS,LQN(3)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2000 KD=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KVALS(KD,ICNT)
        IF(KQN(4).GT.0) THEN
          LQN(4) = KQN(4)
        ELSE
          LQN(4) =-KQN(4)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFUNCT(LQN(4)+1,ICNT)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = EXPSET(LBAS,LQN(4)+1,ICNT)
        ENDDO
C
C**********************************************************************C
C     PREPARE INTERMEDIATE DATA FOR USE IN RABCD                       C
C**********************************************************************C
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C1 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+1)
      C3 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+3)
      C5 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+5)
      C7 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+7)
      C9 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+9)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
      V8 = 8.0D0
      VS = 1.6D1
C
      TI = DFLOAT(LQN(1)+KQN(1)+1)
      TJ = DFLOAT(LQN(2)+KQN(2)+1)
      TK = DFLOAT(LQN(3)+KQN(3)+1)
      TL = DFLOAT(LQN(4)+KQN(4)+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
C
C     ANGULAR COEFFICIENTS
      CALL CPU_TIME(T1) 
C
      CALL ANGBRT1(DKAB,DKCD,KQN,LQN,NUS,NUF,NUI,NUNUM,ISEL)
      CALL CPU_TIME(T2)
      TC1B = TC1B+T2-T1
C
C     EXIT THIS COMBINATION IF NO CONTRIBUTING MULTIPOLES IN ANGLES
      IF(ISEL.EQ.0) GOTO 2001
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL CPU_TIME(T1)
      CALL PREPKL(LQN,KC,NBAS(3),KD,NBAS(4),ICNT)
      CALL CPU_TIME(T2)
      TC1B = TC1B+T2-T1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 3000)         C
C**********************************************************************C
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      N2EB(1,5) = N2EB(1,5) + 1
      N2EB(1,6) = N2EB(1,6) + 1
C
      DO 3000 IBAS=1,NBAS(1)
      DO 3000 JBAS=1,NBAS(2)
C
C       UPDATE COUNTER FOR NUMBER OF INTEGRALS
        N2EI(1,5) = N2EI(1,5)+NBAS(3)*NBAS(4)
        N2EI(1,6) = N2EI(1,6)+NBAS(3)*NBAS(4)
C
C       BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
        CALL CPU_TIME(T1)
        CALL PREPIJ(LQN)
        CALL CPU_TIME(T2)
        TC1B = TC1B+T2-T1
C
C       BATCH OF RADIAL INTEGRALS (EFFECTIVE INTERACTION STRENGTHS)
        CALL CPU_TIME(T1)
        CALL RABCD(KQN,LQN,NBAS(3)*NBAS(4))
        CALL CPU_TIME(T2)
        TC1R = TC1R+T2-T1
C
C**********************************************************************C
C     LOOP OVER |KQN| MAGNITUDES FOR A,B,C,D BLOCKS (USE INDEX 4000)   C
C**********************************************************************C
C
      DO 4000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
      DO 4000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
      DO 4000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      DO 4000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     TRANSFORM THE X(L) INTO G-SPINOR MATRIX ELEMENTS USING
C     THE TENSOR EXPANSION IN {L,Q}
C
C     LOOP OVER THE SIGNS OF |MQN| AND DETERMINE FOCK ADDRESSES
      DO 5000 ISGN1=1,2
        MMJA = MQN(1)*((-1)**ISGN1)
        IMJA = MQN(1)+ISGN1-1
C
      DO 5000 ISGN2=1,2
        MMJB = MQN(2)*((-1)**ISGN2)
        IMJB = MQN(2)+ISGN2-1
C
      DO 5000 ISGN3=1,2
        MMJC = MQN(3)*((-1)**ISGN3)
        IMJC = MQN(3)+ISGN3-1
C
      DO 5000 ISGN4=1,2
        MMJD = MQN(4)*((-1)**ISGN4)
        IMJD = MQN(4)+ISGN4-1
C
C     STARTING FOCK ADDRESS FOR EACH BASIS LIST
      NAL = LARGE(ICNT,KA,IMJA)
      NBL = LARGE(ICNT,KB,IMJB)
      NCL = LARGE(ICNT,KC,IMJC)
      NDL = LARGE(ICNT,KD,IMJD)
C
      NAS = LARGE(ICNT,KA,IMJA) + NSHIFT
      NBS = LARGE(ICNT,KB,IMJB) + NSHIFT
      NCS = LARGE(ICNT,KC,IMJC) + NSHIFT
      NDS = LARGE(ICNT,KD,IMJD) + NSHIFT
C
C     APPLY ANGULAR MQN SELECTION RULE
      IF(MMJA-MMJB.NE.MMJD-MMJC) GOTO 5001
C
C     RESET CONTRACTED RADIAL ARRAYS
      CALL CPU_TIME(T1)
      DO M=1,NBAS(3)*NBAS(4)
        RLL(M) = 0.0D0
        RLS(M) = 0.0D0
        RSL(M) = 0.0D0
        RSS(M) = 0.0D0
      ENDDO
C
C     ASSEMBLE INTEGRAL BY SUMMING OVER EXPANSION POWER L
      DO LTEN=1,NUNUM
C
C       ANGULAR COEFFICIENT
        ANGFAC = DKAB(LTEN,IMJA,IMJB)*DKCD(LTEN,IMJC,IMJD)
C
C       SCREENING OF INTEGRAL BASED ON ANGULAR COEFFICIENT
        IF(DABS(ANGFAC).LE.SENS) GOTO 5003
C
        DO M=1,NBAS(3)*NBAS(4)
          RLL(M) = RLL(M) + ANGFAC*XLLLL(M,LTEN)
          RLS(M) = RLS(M) + ANGFAC*XLLSS(M,LTEN)
          RSL(M) = RSL(M) + ANGFAC*XSSLL(M,LTEN)
          RSS(M) = RSS(M) + ANGFAC*XSSSS(M,LTEN)
        ENDDO
C
C       SKIP POINT FOR ANGULAR SCREENING
5003    CONTINUE
C
      ENDDO
C
C     FULL-INTEGRAL CONSTRUCTION COMPLETE
      CALL CPU_TIME(T2)
      TC1F = TC1F+T2-T1
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO CLOSED-SHELL COULOMB MATRIX     C
C -------------------------------------------------------------------- C
C  DFNOTE: NO BDIR CONTRIBUTIONS FOR CLOSED-SHELL SYSTEMS.             C
C**********************************************************************C
C
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         EXCHANGE CONTRIBUTIONS
          BXCH(NAL+IBAS,NDL+LBAS) = BXCH(NAL+IBAS,NDL+LBAS)
     &                    +              RLL(M)*DENC(NCL+KBAS,NBL+JBAS)
C
          BXCH(NAL+IBAS,NDS+LBAS) = BXCH(NAL+IBAS,NDS+LBAS)
     &                    +              RLS(M)*DENC(NCS+KBAS,NBL+JBAS)
C
          BXCH(NAS+IBAS,NDL+LBAS) = BXCH(NAS+IBAS,NDL+LBAS)
     &                    +              RSL(M)*DENC(NCL+KBAS,NBS+JBAS)

          BXCH(NAS+IBAS,NDS+LBAS) = BXCH(NAS+IBAS,NDS+LBAS)
     &                    +              RSS(M)*DENC(NCS+KBAS,NBS+JBAS)
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL COULOMB MATRIX       C
C -------------------------------------------------------------------- C
C  DFNOTE: THIS SHOULD BE WMAT, NOT BMAT.                              C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 6100
C
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         DIRECT CONTRIBUTIONS
          BDIR(NAL+IBAS,NBL+JBAS) = BDIR(NAL+IBAS,NBL+JBAS)
     &                    +         ACFF*RLL(M)*DENO(NCL+KBAS,NDL+LBAS)
     &                    +         ACFF*RLS(M)*DENO(NCS+KBAS,NDS+LBAS)
C
          BDIR(NAS+IBAS,NBS+JBAS) = BDIR(NAS+IBAS,NBS+JBAS)
     &                    +         ACFF*RSL(M)*DENO(NCL+KBAS,NDL+LBAS)
     &                    +         ACFF*RSS(M)*DENO(NCS+KBAS,NDS+LBAS)
C
C         EXCHANGE CONTRIBUTIONS
          BXCH(NAL+IBAS,NDL+LBAS) = BXCH(NAL+IBAS,NDL+LBAS)
     &                    +         BCFF*RLL(M)*DENO(NCL+KBAS,NBL+JBAS)
C
          BXCH(NAL+IBAS,NDS+LBAS) = BXCH(NAL+IBAS,NDS+LBAS)
     &                    +         BCFF*RLS(M)*DENO(NCS+KBAS,NBL+JBAS)
C
          BXCH(NAS+IBAS,NDL+LBAS) = BXCH(NAS+IBAS,NDL+LBAS)
     &                    +         BCFF*RSL(M)*DENO(NCL+KBAS,NBS+JBAS)

          BXCH(NAS+IBAS,NDS+LBAS) = BXCH(NAS+IBAS,NDS+LBAS)
     &                    +         BCFF*RSS(M)*DENO(NCS+KBAS,NBS+JBAS)
C
        ENDDO
      ENDDO
C
6100  CONTINUE
C
C     MATRIX MULTIPLICATION STEP COMPLETE
      CALL CPU_TIME(T3)
      TC1M = TC1M+T3-T2
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL ONE-CENTER CONTRIBUTIONS.           C
C**********************************************************************C
C
C     EARLY EXIT FOR MQN SELECTION RULES
5001  CONTINUE
C     END LOOP OVER ALL |MQN| SIGNS
5000  CONTINUE
C     END LOOP OVER ALL |MQN| MAGNITUDES
4000  CONTINUE
C     END LOOP OVER IBAS AND JBAS
3000  CONTINUE
C     EARLY EXIT FOR KQN SELECTION RULES
2001  CONTINUE
C     END LOOP OVER ALL KQNS
2000  CONTINUE
C     END LOOP OVER ATOMIC CENTERS
1000  CONTINUE
C
C     RECORD CPU TIME AT END OF BATCH AND ADD TO APPROPRIATE COUNTER
      CALL CPU_TIME(TBCH2)
      T2ES(1,5) = T2ES(1,5) + 0.50D0*(TBCH2-TBCH1)
      T2ES(1,6) = T2ES(1,6) + 0.50D0*(TBCH2-TBCH1)
C
      RETURN
      END
C
C
      SUBROUTINE RABCD(KQN,LQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             RRRRRRR     AA    BBBBBBB   CCCCCC  DDDDDDD              C
C             RR    RR   AAAA   BB    BB CC    CC DD    DD             C
C             RR    RR  AA  AA  BB    BB CC       DD    DD             C
C             RR    RR AA    AA BBBBBBB  CC       DD    DD             C
C             RRRRRRR  AAAAAAAA BB    BB CC       DD    DD             C
C             RR    RR AA    AA BB    BB CC    CC DD    DD             C
C             RR    RR AA    AA BBBBBBB   CCCCCC  DDDDDDD              C
C                                                                      C
C -------------------------------------------------------------------- C
C  RABCD EVALUATES THE EFFECTIVE INTERACTION STRENGTHS OF THE COULOMB  C
C  AND BREIT INTERACTIONS IN A G-SPINOR BASIS SET. THE ALGORITHM IS    C
C  SEGMENTED TO TAKE INTO ACCOUNT THE SIGNS OF KQN IN THE T=S CASE.    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=10)
C
      CHARACTER*4 HMLTN
C
      DIMENSION XK(MB2,2),XROOT(MB2),BETA(MB2),BTA1(MB2),
     &          BIN(MB2),TRM(MB2),KQN(4),LQN(4),IAA(2),IBB(2)
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/XBIJ/EIJ1(MAB),EIJ2(MAB),RNIJ(4),EI,EJ
      COMMON/XBKL/EK(MB2),EKL0(MB2),
     &            EL(MB2),EKL1(MB2,MAB),EKL2(MB2,MAB),RNKL(MB2,4),
     &            B1(MB2,MAB,MAB),B2(MB2,MAB,MAB)
      COMMON/XCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XMAT/XLLLL(MB2,MNU),XLLSS(MB2,MNU),
     &            XSSLL(MB2,MNU),XSSSS(MB2,MNU)
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XK(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TIJKL   = TIJ0+EKL0(M)
        XK(M,1) = TIJ0/TIJKL
        XK(M,2) = EKL0(M)/TIJKL
      ENDDO
C
C**********************************************************************C
C     BEGIN INLINE BETA FUNCTION CODE                                  C
C**********************************************************************C
C
C     GENERATE A MASTER TABLE OF INCOMPLETE BETA FUNCTIONS FOR THIS
C     BATCH OF RADIAL INTEGRALS. (THE SAME BATCH CAN BE USED
C     FOR BOTH THE COULOMB AND BREIT INTEGRALS)
C
      NVALS = (NUS(NUNUM)-NUS(1))/2 + 3
C
C     LOOP OVER EXPANSION TERMINALS FOR FIRST PAIR
      DO I1=1,NVALS
        NT1 = 2*(I1-1) + NUS(1)
        IAA(1) = LQN(1)+LQN(2)+NT1+1
        IAA(2) = LQN(3)+LQN(4)+NT1+1
C
C       LOOP OVER EXPANSION TERMINALS FOR SECOND PAIR
        DO I2=1,NVALS
          NT2 = 2*(I2-1) - NUS(NUNUM)
          IBB(1) = LQN(3)+LQN(4)+NT2
          IBB(2) = LQN(1)+LQN(2)+NT2
C
C         LOOP OVER BETA INTEGRAL COMBINATIONS
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA) + 0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X + 1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XK(M,IBETA)
                BIN(M) = 1.0D0 + TRM(M)
              ENDDO
              RA = RA + 1.0D0
              RB = RB + 1.0D0
              RC = RC + 1.0D0
              RD = RD + 1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XK(M,IBETA)
                  BIN(M) = BIN(M) + TRM(M)
                ENDDO
                RA = RA + 1.0D0
                RB = RB + 1.0D0
                RC = RC + 1.0D0
                RD = RD + 1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA) + 0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XK(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XK(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M) + X*TRM(M)
                    TRM(M) = TRM(M)*XK(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M) - 2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                B1(M,I1,I2) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                B2(M,I1,I2) = BETA(M)
              ENDDO
            ENDIF

          ENDDO

        ENDDO
      ENDDO
C
C**********************************************************************C
C     END INLINE BETA FUNCTION CODE                                    C
C**********************************************************************C
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     INITIATE LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        IF(HMLTN.NE.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
          E0000 = 1.0D0
          E1000 = EI
          E0100 = EJ
          E0010 = EK(M)
          E0001 = EL(M)
          E1100 = EI*EJ
          E1010 = EI*EK(M)
          E1001 = EI*EL(M)
          E0110 = EJ*EK(M)
          E0101 = EJ*EL(M)
          E0011 = EK(M)*EL(M)
          E1110 = EI*EJ*EK(M)
          E1101 = EI*EJ*EL(M)
          E1011 = EI*EK(M)*EL(M)
          E0111 = EJ*EK(M)*EL(M)
          E1111 = EI*EJ*EK(M)*EL(M)
C
        ENDIF
C
C       LOOP OVER THE TENSOR ORDERS OF THE COULOMB INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT CURRENT NU VALUE FROM THE NUS ARRAY
          NU = NUS(LTEN)
C
C         INDEX OFFSETS FOR TENSOR ORDER
          IQ1 = (-NUS(    1)+NU)/2
          IQ2 = (+NUS(NUNUM)-NU)/2
C
C**********************************************************************C
C     SPECIAL CASE: NON-RELATIVISTIC HAMILTONIAN                       C
C**********************************************************************C
C
          IF(HMLTN.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
C           BETA INTEGRALS WITH POWERS OF EXPONENTIALS
            B11 = EIJ1(IQ1+2)*EKL1(M,IQ2+2)*B1(M,IQ1+2,IQ2+2)
     &          + EIJ2(IQ2+2)*EKL2(M,IQ1+2)*B2(M,IQ1+2,IQ2+2)
C
C           EFFECTIVE INTERACTION STRENGTH FOR THIS TENSOR ORDER
            XLLLL(M,LTEN) = C5*B11
C
C           SKIP PAST THE RELATIVISTIC STAGES
            GOTO 999
C
          ENDIF
C
C**********************************************************************C
C     LARGER CASE: RELATIVISTIC HAMILTONIAN (T TERMS GIVE ZEROES)      C
C**********************************************************************C
C
C         BETA INTEGRALS WITH POWERS OF EXPONENTIALS
          B00 = EIJ1(IQ1+1)*EKL1(M,IQ2+1)*B1(M,IQ1+1,IQ2+1)
     &        + EIJ2(IQ2+1)*EKL2(M,IQ1+1)*B2(M,IQ1+1,IQ2+1)
          B01 = EIJ1(IQ1+1)*EKL1(M,IQ2+2)*B1(M,IQ1+1,IQ2+2)
     &        + EIJ2(IQ2+1)*EKL2(M,IQ1+2)*B2(M,IQ1+2,IQ2+1)
          B02 = EIJ1(IQ1+1)*EKL1(M,IQ2+3)*B1(M,IQ1+1,IQ2+3)
     &        + EIJ2(IQ2+1)*EKL2(M,IQ1+3)*B2(M,IQ1+3,IQ2+1)
          B10 = EIJ1(IQ1+2)*EKL1(M,IQ2+1)*B1(M,IQ1+2,IQ2+1)
     &        + EIJ2(IQ2+2)*EKL2(M,IQ1+1)*B2(M,IQ1+1,IQ2+2)
          B11 = EIJ1(IQ1+2)*EKL1(M,IQ2+2)*B1(M,IQ1+2,IQ2+2)
     &        + EIJ2(IQ2+2)*EKL2(M,IQ1+2)*B2(M,IQ1+2,IQ2+2)
          B12 = EIJ1(IQ1+2)*EKL1(M,IQ2+3)*B1(M,IQ1+2,IQ2+3)
     &        + EIJ2(IQ2+2)*EKL2(M,IQ1+3)*B2(M,IQ1+3,IQ2+2)
          B20 = EIJ1(IQ1+3)*EKL1(M,IQ2+1)*B1(M,IQ1+3,IQ2+1)
     &        + EIJ2(IQ2+3)*EKL2(M,IQ1+1)*B2(M,IQ1+1,IQ2+3)
          B21 = EIJ1(IQ1+3)*EKL1(M,IQ2+2)*B1(M,IQ1+3,IQ2+2)
     &        + EIJ2(IQ2+3)*EKL2(M,IQ1+2)*B2(M,IQ1+2,IQ2+3)
          B22 = EIJ1(IQ1+3)*EKL1(M,IQ2+3)*B1(M,IQ1+3,IQ2+3)
     &        + EIJ2(IQ2+3)*EKL2(M,IQ1+3)*B2(M,IQ1+3,IQ2+3)
C
C         EFFECTIVE INTERACTION STRENGTH XLLLL(M,LTEN)
          XLLLL(M,LTEN) = V1*T0000*E0000*C5*B11
C
C         EFFECTIVE INTERACTION STRENGTH XLLSS(M,LTEN)
          XLLSS(M,LTEN) = V4*T0000*E0011*C7*B12 - V2*T0001*E0010*C5*B11
     &                  - V2*T0010*E0001*C5*B11 + V1*T0011*E0000*C3*B10
C
C         EFFECTIVE INTERACTION STRENGTH XSSLL(M,LTEN)
          XSSLL(M,LTEN) = V4*T0000*E1100*C7*B21 - V2*T0100*E1000*C5*B11
     &                  - V2*T1000*E0100*C5*B11 + V1*T1100*E0000*C3*B01
C
C         EFFECTIVE INTERACTION STRENGTH XSSSS(M,LTEN)
          XSSSS(M,LTEN) = VS*T0000*E1111*C9*B22
     &                  - V8*T0001*E1110*C7*B21 - V8*T0010*E1101*C7*B21
     &                  - V8*T0100*E1011*C7*B12 - V8*T1000*E0111*C7*B12
     &                  + V4*T1100*E0011*C5*B02 + V4*T0011*E1100*C5*B20
     &                  + V4*T1001*E0110*C5*B11 + V4*T0110*E1001*C5*B11
     &                  + V4*T0101*E1010*C5*B11 + V4*T1010*E0101*C5*B11
     &                  - V2*T1101*E0010*C3*B01 - V2*T0111*E1000*C3*B10
     &                  - V2*T1110*E0001*C3*B01 - V2*T1011*E0100*C3*B10
     &                  + V1*T1111*E0000*C1*B00
C
C         SKIP POINT FOR NON-RELATIVISTIC HAMILTONIANS
999       CONTINUE
C
C       END LOOP OVER TENSOR ORDERS
        ENDDO
C
C     END LOOP OVER K,L BASIS FUNCTIONS
      ENDDO
C
C**********************************************************************C
C     NORMALISE ACCUMULATED INTEGRALS (DIRECT AND EXCHANGE)            C
C**********************************************************************C
C
      IF(HMLTN.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          T0LLLL = RNIJ(1)*RNKL(M,1)
          DO LTEN=1,NUNUM
            XLLLL(M,LTEN) = T0LLLL*XLLLL(M,LTEN)
          ENDDO
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          T0LLLL = RNIJ(1)*RNKL(M,1)
          T0LLSS = RNIJ(1)*RNKL(M,4)
          T0SSLL = RNIJ(4)*RNKL(M,1)
          T0SSSS = RNIJ(4)*RNKL(M,4)
          DO LTEN=1,NUNUM
            XLLLL(M,LTEN) = T0LLLL*XLLLL(M,LTEN)
            XLLSS(M,LTEN) = T0LLSS*XLLSS(M,LTEN)
            XSSLL(M,LTEN) = T0SSLL*XSSLL(M,LTEN)
            XSSSS(M,LTEN) = T0SSSS*XSSSS(M,LTEN)
          ENDDO
        ENDDO
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE PREPIJ(LQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          PPPPPPP  RRRRRRR  EEEEEEEE PPPPPPP  IIII    JJJJJ           C
C          PP    PP RR    RR EE       PP    PP  II       JJ            C
C          PP    PP RR    RR EE       PP    PP  II       JJ            C
C          PP    PP RR    RR EEEEEE   PP    PP  II       JJ            C
C          PPPPPPP  RRRRRRR  EE       PPPPPPP   II       JJ            C
C          PP       RR    RR EE       PP        II JJ    JJ            C
C          PP       RR    RR EEEEEEEE PP       IIII JJJJJJ             C
C                                                                      C
C -------------------------------------------------------------------- C
C  PREPIJ INITIALISES VARIABLES REQUIRED BY SUBROUTINE RABCD.          C
C  STRUCTURE SIMILAR TO RNORM0 ROUTINE, EXCEPT FOR ONLY ONE PAIR.      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=10)
C
      DIMENSION LQN(4)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/XBIJ/EIJ1(MAB),EIJ2(MAB),RNIJ(4),EI,EJ
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
      DATA TWOLOG/6.93147180559945309D-1/
C
C     NORMALISATION CONSTANTS FOR EXPONENT EI
      RLQN = DFLOAT(LQN(1))
      G1   = TWOLOG - GAMLOG(2*LQN(1)+3)
      G2   = TWOLOG - GAMLOG(2*LQN(1)+5)
      R1   = RLQN + 1.5D0
      R2   = RLQN + 0.5D0
C
      ELOG = DLOG(2.0D0*EI)
      RNLI = DEXP(0.5D0*(G1 + R1*ELOG))
      RNSI = DEXP(0.5D0*(G2 + R2*ELOG))
C
C     NORMALISATION CONSTANTS FOR EXPONENT EJ
      RLQN = DFLOAT(LQN(2))
      G1   = TWOLOG - GAMLOG(2*LQN(2)+3)
      G2   = TWOLOG - GAMLOG(2*LQN(2)+5)
      R1   = RLQN + 1.5D0
      R2   = RLQN + 0.5D0
C
      ELOG = DLOG(2.0D0*EJ)
      RNLJ = DEXP(0.5D0*(G1 + R1*ELOG))
      RNSJ = DEXP(0.5D0*(G2 + R2*ELOG))
C
C     COMPOSITE NORMALISATION CONSTANTS
      RNIJ(1) = RNLI*RNLJ
      RNIJ(2) = RNLI*RNSJ
      RNIJ(3) = RNSI*RNLJ
      RNIJ(4) = RNSI*RNSJ
C
C     NUMBER OF EIJ POWERS REQUIRED FOR COULOMB SUM
      NOVALS  = ((NUS(NUNUM)-NUS(1))/2) + 3
C
      IPOWER1 = LQN(1)+LQN(2)+NUS(    1)+1
      IPOWER2 = LQN(1)+LQN(2)-NUS(NUNUM)
C
C     SEED EXPONENT POWER
      EIJ0 = EI+EJ
      EIJR = DSQRT(EIJ0)
C
C     STARTING POINT FOR EIJ1 AND EIJ2
      EIJ1A = EIJR**(-IPOWER1)
      EIJ2A = EIJR**(-IPOWER2)
C
C     SAVE VALUES TO ARRAYS UP TO A FINAL VLAUE
      DO IPOWER=1,NOVALS
        EIJ1(IPOWER) = EIJ1A
        EIJ2(IPOWER) = EIJ2A
        EIJ1A = EIJ1A/EIJ0
        EIJ2A = EIJ2A/EIJ0
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE PREPKL(LQN,KC,NBASC,KD,NBASD,ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        PPPPPPP  RRRRRRR  EEEEEEEE PPPPPPP  KK    KK LL               C
C        PP    PP RR    RR EE       PP    PP KK   KK  LL               C
C        PP    PP RR    RR EE       PP    PP KK  KK   LL               C
C        PP    PP RR    RR EEEEEE   PP    PP KKKKK    LL               C
C        PPPPPPP  RRRRRRR  EE       PPPPPPP  KK  KK   LL               C
C        PP       RR    RR EE       PP       KK   KK  LL               C
C        PP       RR    RR EEEEEEEE PP       KK    KK LLLLLLLL         C
C                                                                      C
C -------------------------------------------------------------------- C
C  PREPKL INITIALISES VARIABLES REQUIRED BY SUBROUTINE RABCD.          C
C  STRUCTURE SIMILAR TO RNORM0 ROUTINE, EXCEPT OVERLAPS ARE DIFFERENT. C
C**********************************************************************C
      PARAMETER(MCT=6,MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=10)
C
      DIMENSION RNLC(MBS),RNSC(MBS),RNLD(MBS),RNSD(MBS)
      DIMENSION LQN(4)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/XBKL/EK(MB2),EKL0(MB2),
     &            EL(MB2),EKL1(MB2,MAB),EKL2(MB2,MAB),RNKL(MB2,4),
     &            B1(MB2,MAB,MAB),B2(MB2,MAB,MAB)
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
      DATA TWOLOG/6.93147180559945309D-1/
C
C     BLOCK LIST LENGTH
      MAXM = NBASC*NBASD
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST C
      RLQN = DFLOAT(LQN(3))
      G1   = TWOLOG - GAMLOG(2*LQN(3)+3)
      G2   = TWOLOG - GAMLOG(2*LQN(3)+5)
      R1   = RLQN + 1.5D0
      R2   = RLQN + 0.5D0
      DO KBAS=1,NBASC
        EKV        = EXPSET(KBAS,LQN(3)+1,ICNT)
        ELOG       = DLOG(2.0D0*EKV)
        RNLC(KBAS) = DEXP(0.5D0*(G1 + R1*ELOG))
        RNSC(KBAS) = DEXP(0.5D0*(G2 + R2*ELOG))
      ENDDO
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST D
      RLQN = DFLOAT(LQN(4))
      G1   = TWOLOG - GAMLOG(2*LQN(4)+3)
      G2   = TWOLOG - GAMLOG(2*LQN(4)+5)
      R1   = RLQN + 1.5D0
      R2   = RLQN + 0.5D0
      DO LBAS=1,NBASD
        ELV        = EXPSET(LBAS,LQN(4)+1,ICNT)
        ELOG       = DLOG(2.0D0*ELV)
        RNLD(LBAS) = DEXP(0.5D0*(G1 + R1*ELOG))
        RNSD(LBAS) = DEXP(0.5D0*(G2 + R2*ELOG))
      ENDDO
C
C     LIST OF EXPONENTS AND NORMALISATION COEFFICIENTS IN THE BLOCK
      M = 0
      DO KBAS=1,NBASC
        DO LBAS=1,NBASD
          M = M+1
          EK(M)     = EXPSET(KBAS,LQN(3)+1,ICNT)
          EL(M)     = EXPSET(LBAS,LQN(4)+1,ICNT)
          EKL0(M)   = EK(M)+EL(M)
          RNKL(M,1) = RNLC(KBAS)*RNLD(LBAS)
          RNKL(M,2) = RNLC(KBAS)*RNSD(LBAS)
          RNKL(M,3) = RNSC(KBAS)*RNLD(LBAS)
          RNKL(M,4) = RNSC(KBAS)*RNSD(LBAS)
        ENDDO
      ENDDO
C
C     NUMBER OF EKL POWERS REQUIRED FOR COULOMB SUM
      NOVALS  = ((NUS(NUNUM)-NUS(1))/2) + 3
C
      IPOWER1 = LQN(3)+LQN(4)-NUS(NUNUM)
      IPOWER2 = LQN(3)+LQN(4)+NUS(    1)+1
C
C     GAUSSIAN OVERLAPS TO ALL REQUIRED POWERS
      DO M=1,MAXM
C
C       SEED GAUSSIAN EXPONENT VALUE
        EKLR = DSQRT(EKL0(M))
C
C       STARTING POINT FOR EKL1 AND EKL2
        EKL1A = EKLR**(-IPOWER1)
        EKL2A = EKLR**(-IPOWER2)
        DO IPOWER=1,NOVALS
          EKL1(M,IPOWER) = EKL1A
          EKL2(M,IPOWER) = EKL2A
          EKL1A = EKL1A/EKL0(M)
          EKL2A = EKL2A/EKL0(M)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ANGCLM1(DKAB,DKCD,KQN,LQN,NUS,NUF,NUI,NUNUM,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       AA    NN    NN  GGGGGG   CCCCCC  LL       MM       MM  11      C
C      AAAA   NNN   NN GG    GG CC    CC LL       MMM     MMM 111      C
C     AA  AA  NNNN  NN GG       CC       LL       MMMM   MMMM  11      C
C    AA    AA NN NN NN GG       CC       LL       MM MM MM MM  11      C
C    AAAAAAAA NN  NNNN GG   GGG CC       LL       MM  MMM  MM  11      C
C    AA    AA NN   NNN GG    GG CC    CC LL       MM   M   MM  11      C
C    AA    AA NN    NN  GGGGGG   CCCCCC  LLLLLLLL MM       MM 1111     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGCLM1 PERFORMS THE ANGULAR ANALYSIS FOR THE EVALUATION OF TWO     C
C  ELECTRON INTEGRALS USING RACAH ALGEBRA TECHNIQUES. (OPEN-SHELL.)    C
C**********************************************************************C
      PARAMETER(MKP=9,MNU=MKP+1)
C
      DIMENSION KQN(4),LQN(4),JQN(4),NUS(MNU)
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
C
C**********************************************************************C
C     PARITY ANALYSIS: CHECK UNDERLYING LQN COMBINATIONS AND EXIT      C
C     IF THERE IS NO MULTIPOLE EXPANSION OF THE INTERACTION.           C
C**********************************************************************C
C
C     A AND B: LQN(1)+LQN(2) EVEN OR ODD
      IF(MOD(LQN(1)+LQN(2),2).EQ.0) THEN
        IPARAB = 1
      ELSE
        IPARAB = 0
      ENDIF
C
C     C AND D: LQN(3)+LQN(4) EVEN OR ODD
      IF(MOD(LQN(3)+LQN(4),2).EQ.0) THEN
        IPARCD = 1
      ELSE
        IPARCD = 0
      ENDIF
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.EQ.IPARCD) THEN
        ISEL = 1
      ELSE
        ISEL = 0
        RETURN
      ENDIF
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
      NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
      NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
C
C     JQN SELECTION RULE: TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUI.GT.NUF) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     FURTHER PARITY ANALYSIS: RUN OVER ALLOWED TENSOR ORDERS NU AND   C
C     SCREEN THOSE WHICH ARE NOT ALLOWED ON PARITY GROUNDS.            C
C**********************************************************************C
C
      NUNUM = 0
      DO NU=NUI,NUF
C
C       A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD
        IF(MOD(LQN(1)+LQN(2)+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
C       C AND D: LQN(3)+LQN(4)+NU EVEN OR ODD
        IF(MOD(LQN(3)+LQN(4)+NU,2).EQ.0) THEN
          IPARCD = 1
        ELSE
          IPARCD = 0
        ENDIF
C
C       LQN SELECTION RULE: WHEN SUM OF A AND B, C AND D EVEN
        IF(IPARAB.EQ.1.AND.IPARCD.EQ.1) THEN
C
C         INCREASE TOTAL NUMBER OF NU VALUES TO BE FACILITATED
          NUNUM = NUNUM+1
C
C         SAVE THIS PARTICULAR NU VALUE TO A LIST
          NUS(NUNUM) = NU
C
        ENDIF
C
      ENDDO
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, EXIT PROCEDURE
      IF(NUNUM.EQ.0) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C     RE-SET THE LOWER AND UPPER LIMITS OF THE EXPANSION
      NUI = NUS(    1)
      NUF = NUS(NUNUM)
C
C**********************************************************************C
C     ANGULAR FACTORS: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|      C
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.   C
C**********************************************************************C
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ODER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(1),-MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(1),+MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(1),-MJA,JQN(2),+MJB,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(1),+MJA,JQN(2),+MJB,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     THE ARGUMENTS OF DK COEFFICIENTS ARE REVERSED IN THE CASE OF THE
C     CD PAIRS IN ORDER TO ACCOMMODATE THE RELATION:
C               DK(J,M,J',M',L) = ((-1)^Q)*DK(J'M',J,M,L).
C
C     LOOP OVER MQN(C) AND MQN(D) VALUES
      DO MC=1,IABS(KQN(3))
        MJC = 2*MC-1
        DO MD=1,IABS(KQN(4))
          MJD = 2*MD-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ODER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKCD(LTEN,MJC  ,MJD  ) = DK(JQN(4),-MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD  ) = DK(JQN(4),-MJD,JQN(3),+MJC,NU)
            DKCD(LTEN,MJC  ,MJD+1) = DK(JQN(4),+MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD+1) = DK(JQN(4),+MJD,JQN(3),+MJC,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ANGBRT1(DKAB,DKCD,KQN,LQN,NUS,NUF,NUI,NUNUM,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          AA    NN    NN  GGGGGG  BBBBBBB  RRRRRRR TTTTTTTT 11        C
C         AAAA   NNN   NN GG    GG BB    BB RR    RR   TT   111        C
C        AA  AA  NNNN  NN GG       BB    BB RR    RR   TT    11        C
C       AA    AA NN NN NN GG       BBBBBBB  RR    RR   TT    11        C
C       AAAAAAAA NN  NNNN GG   GGG BB    BB RRRRRRR    TT    11        C
C       AA    AA NN   NNN GG    GG BB    BB RR    RR   TT    11        C
C       AA    AA NN    NN  GGGGGG  BBBBBBB  RR    RR   TT   1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGBRT1 PERFORMS THE ANGULAR ANALYSIS FOR THE EVALUATION OF TWO     C
C  ELECTRON INTEGRALS USING RACAH ALGEBRA TECHNIQUES. (OPEN-SHELL.)    C
C -------------------------------------------------------------------- C
C  DFNOTE: ACHTUNG! THIS IS JUST ANGCLM1 FOR NOW.                      C
C**********************************************************************C
      PARAMETER(MKP=9,MNU=MKP+1)
C
      DIMENSION KQN(4),LQN(4),JQN(4),NUS(MNU)
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
      DIMENSION EMAT(MNU,MKP+1,MKP+1,8)
C
C**********************************************************************C
C     PARITY ANALYSIS: CHECK UNDERLYING LQN COMBINATIONS AND EXIT      C
C     IF THERE IS NO MULTIPOLE EXPANSION OF THE INTERACTION.           C
C**********************************************************************C
C
C     A AND B: LQN(1)+LQN(2) EVEN OR ODD
      IF(MOD(LQN(1)+LQN(2),2).EQ.0) THEN
        IPARAB = 1
      ELSE
        IPARAB = 0
      ENDIF
C
C     C AND D: LQN(3)+LQN(4) EVEN OR ODD
      IF(MOD(LQN(3)+LQN(4),2).EQ.0) THEN
        IPARCD = 1
      ELSE
        IPARCD = 0
      ENDIF
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.EQ.IPARCD) THEN
        ISEL = 1
      ELSE
        ISEL = 0
        RETURN
      ENDIF
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
      NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
      NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
C
C     JQN SELECTION RULE: TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUI.GT.NUF) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     FURTHER PARITY ANALYSIS: RUN OVER ALLOWED TENSOR ORDERS NU AND   C
C     SCREEN THOSE WHICH ARE NOT ALLOWED ON PARITY GROUNDS.            C
C**********************************************************************C
C
      NUNUM = 0
      DO NU=NUI,NUF
C
C       A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD
        IF(MOD(LQN(1)+LQN(2)+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
C       C AND D: LQN(3)+LQN(4)+NU EVEN OR ODD
        IF(MOD(LQN(3)+LQN(4)+NU,2).EQ.0) THEN
          IPARCD = 1
        ELSE
          IPARCD = 0
        ENDIF
C
C       LQN SELECTION RULE: WHEN SUM OF A AND B, C AND D EVEN
        IF(IPARAB.EQ.1.AND.IPARCD.EQ.1) THEN
C
C         INCREASE TOTAL NUMBER OF NU VALUES TO BE FACILITATED
          NUNUM = NUNUM+1
C
C         SAVE THIS PARTICULAR NU VALUE TO A LIST
          NUS(NUNUM) = NU
C
        ENDIF
C
      ENDDO
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, EXIT PROCEDURE
      IF(NUNUM.EQ.0) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C     RE-SET THE LOWER AND UPPER LIMITS OF THE EXPANSION
      NUI = NUS(    1)
      NUF = NUS(NUNUM)
C
C**********************************************************************C
C     ANGULAR FACTORS: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|      C
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.   C
C**********************************************************************C
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ODER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(1),-MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(1),+MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(1),-MJA,JQN(2),+MJB,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(1),+MJA,JQN(2),+MJB,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     THE ARGUMENTS OF DK COEFFICIENTS ARE REVERSED IN THE CASE OF THE
C     CD PAIRS IN ORDER TO ACCOMMODATE THE RELATION:
C               DK(J,M,J',M',L) = ((-1)^Q)*DK(J'M',J,M,L).
C
C     LOOP OVER MQN(C) AND MQN(D) VALUES
      DO MC=1,IABS(KQN(3))
        MJC = 2*MC-1
        DO MD=1,IABS(KQN(4))
          MJD = 2*MD-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ODER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKCD(LTEN,MJC  ,MJD  ) = DK(JQN(4),-MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD  ) = DK(JQN(4),-MJD,JQN(3),+MJC,NU)
            DKCD(LTEN,MJC  ,MJD+1) = DK(JQN(4),+MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD+1) = DK(JQN(4),+MJD,JQN(3),+MJC,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BRCOEF1(SCOEFF,KA,KB,KC,KD,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      BBBBBBB  RRRRRRR   CCCCCC   OOOOOO  EEEEEEEE FFFFFFFF 11        C
C      BB    BB RR    RR CC    CC OO    OO EE       FF      111        C
C      BB    BB RR    RR CC       OO    OO EE       FF       11        C
C      BBBBBBB  RR    RR CC       OO    OO EEEEEE   FFFFFF   11        C
C      BB    BB RRRRRRR  CC       OO    OO EE       FF       11        C
C      BB    BB RR    RR CC    CC OO    OO EE       FF       11        C
C      BBBBBBB  RR    RR  CCCCCC   OOOOOO  EEEEEEEE FF      1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRCOEF0 EVALUATES THE INTERMEDIATE COEFFICIENTS OF THE BREIT        C
C  INTERACTION IN THE GENERAL CASE (TABLE 2 OF GRANT AND PYPER 1976).  C
C**********************************************************************C
      DIMENSION SCOEFF(8,2)
C
      RNU = DFLOAT(NU)
      RK1 = DFLOAT(KC-KA)
      RK2 = DFLOAT(KD-KB)
C
      IF(NU-1.GE.0) THEN
        B1 = DFLOAT(NU+1)/DFLOAT(2   *(2*NU+1))
        C1 =-DFLOAT(NU-2)/DFLOAT(2*NU*(2*NU+1))
        SCOEFF(1,1) = (RNU+RK1)*(B1+(C1*RK2))
        SCOEFF(2,1) = (RNU+RK2)*(B1+(C1*RK1))
        SCOEFF(3,1) = (RNU-RK1)*(B1-(C1*RK2))
        SCOEFF(4,1) = (RNU-RK2)*(B1-(C1*RK1))
        SCOEFF(5,1) =-(RNU+RK1)*(B1-(C1*RK2))
        SCOEFF(6,1) =-(RNU-RK2)*(B1+(C1*RK1))
        SCOEFF(7,1) =-(RNU-RK1)*(B1+(C1*RK2))
        SCOEFF(8,1) =-(RNU+RK2)*(B1-(C1*RK1))
      ELSE
        SCOEFF(1,1) = 0.0D0
        SCOEFF(2,1) = 0.0D0
        SCOEFF(3,1) = 0.0D0
        SCOEFF(4,1) = 0.0D0
        SCOEFF(5,1) = 0.0D0
        SCOEFF(6,1) = 0.0D0
        SCOEFF(7,1) = 0.0D0
        SCOEFF(8,1) = 0.0D0
      ENDIF
C
      IF(NU+1.GE.1) THEN
        B2 = DFLOAT(NU  )/DFLOAT(2       *(2*NU+3))
        C2 = DFLOAT(NU+3)/DFLOAT(2*(NU+1)*(2*NU+3))
        SCOEFF(1,2) = (B2+(C2*RK1))*( RK2-RNU-1.0D0)
        SCOEFF(2,2) = (B2+(C2*RK2))*( RK1-RNU-1.0D0)
        SCOEFF(3,2) = (B2-(C2*RK1))*(-RK2-RNU-1.0D0)
        SCOEFF(4,2) = (B2-(C2*RK2))*(-RK1-RNU-1.0D0)
        SCOEFF(5,2) =-(B2+(C2*RK1))*(-RK2-RNU-1.0D0)
        SCOEFF(6,2) =-(B2-(C2*RK2))*( RK1-RNU-1.0D0)
        SCOEFF(7,2) =-(B2-(C2*RK1))*( RK2-RNU-1.0D0)
        SCOEFF(8,2) =-(B2+(C2*RK2))*(-RK1-RNU-1.0D0)
      ELSE
        SCOEFF(1,2) = 0.0D0
        SCOEFF(2,2) = 0.0D0
        SCOEFF(3,2) = 0.0D0
        SCOEFF(4,2) = 0.0D0
        SCOEFF(5,2) = 0.0D0
        SCOEFF(6,2) = 0.0D0
        SCOEFF(7,2) = 0.0D0
        SCOEFF(8,2) = 0.0D0
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE TESTANG(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     TTTTTTTT EEEEEEEE SSSSSS TTTTTTTT   AA    NN    NN  GGGGGG       C
C        TT    EE      SS    SS   TT     AAAA   NNN   NN GG    GG      C
C        TT    EE      SS         TT    AA  AA  NNNN  NN GG            C
C        TT    EEEEEE   SSSSSS    TT   AA    AA NN NN NN GG            C
C        TT    EE            SS   TT   AAAAAAAA NN  NNNN GG   GGG      C
C        TT    EE      SS    SS   TT   AA    AA NN   NNN GG    GG      C
C        TT    EEEEEEEE SSSSSS    TT   AA    AA NN    NN  GGGGGG       C
C                                                                      C
C -------------------------------------------------------------------- C
C  TESTANG IS A ROUTINE THAT PRINTS A TABLE OF ANGULAR COEFFICIENTS,   C
C  DK(J M ,J'M') FOR AN ALLOWED NUMBER OF TENSOR POWERS K, AND ALL     C
C  COMBINATIONS OF JA, JB, MA, MB FOR GIVEN SYMMETRY TYPES KA, KB.     C
C -------------------------------------------------------------------- C
C  NOTE: MUST CALL 'FACTRLS' ROUTINE AT SOME POINT BEFORE THIS.        C
C        FACTORS ARE PRESENTED AS THEIR SQUARES (SIGNS RETAINED), WITH C
C        AN EXTRA OPTION TO MULTIPLY THEM AGAIN BY A FACTOR F(NU).     C
C**********************************************************************C
      PARAMETER(MKP=9,MNU=MKP+1)
C
      CHARACTER*4  HMLTN
C
      DIMENSION KQN(2),JQN(2),LQN(2)
      DIMENSION NUS(MNU),FMLT(MNU)
      DIMENSION BK(MNU)
      DIMENSION ELL(MNU),ESL(MNU),ESS(MNU),GSL(MNU)
      DIMENSION DKAB(MNU,MKP+1,MKP+1)
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     CALL FACTORIAL ROUTINE FOR USE IN SYM3J
      CALL FACTRLS
C
C     OVER-RIDE INPUT KQN VALUES
      KQN(1) =-1
      KQN(2) =-1
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE LQN VALUES
      DO I=1,2
        IF(KQN(I).LT.0) THEN
          LQN(I) =-KQN(I)-1
        ELSE
          LQN(I) = KQN(I)
        ENDIF
      ENDDO
C
C     ALLOWED TENSOR POWERS
      NUI = IABS(JQN(1)-JQN(2))/2
      NUF =     (JQN(1)+JQN(2))/2
      NUNUM = NUF-NUI+1
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, QUIT PROCEDURE
      IF(NUNUM.EQ.0) RETURN
C
C**********************************************************************C
C     CLOSED-SHELL COULOMB EXCHANGE TERMS, BK(JJ').                    C
C**********************************************************************C
C
C     LOOP OVER ALL TENSOR ORDERS ALLOWED BY TRIANGLE CONDITION
      LTEN = 0
      DO NU=NUI,NUF
C
C       TEST WHETHER 'LQNA+LQNB+NU' ODD OR EVEN
        IF(MOD(LQN(1)+LQN(2)+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.1) THEN
C       ONLY ANGULAR COEFFICIENTS OF EVEN PARITY ARE NON-ZERO
C
C         SAVE THIS TENSOR ORDER
          LTEN = LTEN+1
          NUS(LTEN) = NU
C
          IF(HMLTN.EQ.'NORL') THEN
            BK(LTEN) = 0.5D0*ABC000(LQN(1),LQN(2),NU)
          ELSE
            BK(LTEN) =      SYM3JSQ(JQN(1),JQN(2),NU)
          ENDIF
        ENDIF
C
      ENDDO
C
C     NUMBER OF SURVIVING TENSOR ORDERS
      NUNUM = LTEN
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' CLOSED COULOMB EXCHANGE COEFFICIENTS:'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
301   FORMAT(1X,A, 1(1X,F13.9))
302   FORMAT(1X,A, 2(1X,F13.9))
303   FORMAT(1X,A, 3(1X,F13.9))
304   FORMAT(1X,A, 4(1X,F13.9))
305   FORMAT(1X,A, 5(1X,F13.9))
306   FORMAT(1X,A, 6(1X,F13.9))
307   FORMAT(1X,A, 7(1X,F13.9))
308   FORMAT(1X,A, 8(1X,F13.9))
309   FORMAT(1X,A, 9(1X,F13.9))
310   FORMAT(1X,A,10(1X,F13.9))
311   FORMAT(1X,A,11(1X,F13.9))
312   FORMAT(1X,A,12(1X,F13.9))
313   FORMAT(1X,A,13(1X,F13.9))
314   FORMAT(1X,A,14(1X,F13.9))
C
      IF(NUNUM.EQ.1) THEN
        WRITE(*,301) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,302) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,303) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,304) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,305) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,306) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,307) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,308) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,309) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,310) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,311) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,312) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,313) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,314) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
C**********************************************************************C
C     CLOSED-SHELL BREIT EXCHANGE TERMS, EK(JJ') AND GK(JJ').          C
C**********************************************************************C
C
C     INITIALISE COEFFICIENT ARRAYS
      DO LTEN=1,NUF-NUI+1
        ELL(LTEN) = 0.0D0
        ESL(LTEN) = 0.0D0
        ESS(LTEN) = 0.0D0
        GSL(LTEN) = 0.0D0
      ENDDO
C
C     LOOP OVER ALL TENSOR ORDERS ALLOWED BY TRIANGLE CONDITION
      LTEN = 1
      DO NU=NUI,NUF
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JQN(1),JQN(2),NU)
C
C       FLOATING-POINT VERSIONS OF TENSOR ORDER AND KQN DIFFERENCE
        RU  = DFLOAT(NU)
        RK  = DFLOAT(KQN(2)-KQN(1))
        RP  = DFLOAT(KQN(1)+KQN(2))
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQN(1)+LQN(2)+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.0.AND.NU.NE.0) THEN
C       ANGULAR COEFFICIENTS OF ODD PARITY
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN) = ELL(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
          ESS(LTEN) = ESS(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
          ESL(LTEN) = ESL(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
C
        ELSEIF(IPARAB.EQ.1) THEN
C       ANGULAR COEFFICIENTS OF EVEN PARITY
C
C         DOWN-LADDER ENTRIES...
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         ADD TO ARRAY ELEMENTS ONLY IF EFFECTIVE TENSOR ORDER >= 0
          IF(NU-1.GE.0) THEN
            B1 = DFLOAT(NU+1)/DFLOAT(2*(2*NU-1))
            C1 =-DFLOAT(NU-2)/DFLOAT(2*(2*NU-1)*NU)
            ELL(LTEN) = ELL(LTEN) + RAW*((RU+RK)*(B1+C1*RK))
            ESL(LTEN) = ESL(LTEN) - RAW*((B1*RU)-(C1*RK*RK))
            ESS(LTEN) = ESS(LTEN) + RAW*((RU-RK)*(B1-C1*RK))
            GSL(LTEN) = GSL(LTEN) - RAW*(    RK *(B1-C1*RU))
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         UP-LADDER ENTRIES...
          NUS(LTEN) = NU+1
C
C         ADD TO ARRAY ELEMENTS ONLY IF EFFECTIVE TENSOR ORDER >= 1
          IF(NU+1.GE.1) THEN
            B2 = DFLOAT(NU  )/DFLOAT(2*(2*NU+3))
            C2 = DFLOAT(NU+3)/DFLOAT(2*(NU+1)*(2*NU+3))
            ELL(LTEN) = ELL(LTEN) + RAW*((RK-RU-1.0D0)*( B2+C2*RK))
            ESL(LTEN) = ESL(LTEN) + RAW*((B2*(RU+1.0D0))+C2*RK*RK)
            ESS(LTEN) = ESS(LTEN) - RAW*((RK+RU+1.0D0)*( B2-C2*RK))
            GSL(LTEN) = GSL(LTEN) + RAW*(C2*RK*(RU+1.0D0)+B2*RK)
          ENDIF
C
        ENDIF
C
      ENDDO
      
      NUNUM = LTEN
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' CLOSED BREIT EXCHANGE COEFFICIENTS:'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
      IF(NUNUM.EQ.1) THEN
        WRITE(*,301) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,302) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,303) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,304) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,305) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,306) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,307) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,308) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,309) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,310) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,311) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,312) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,313) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,314) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
C**********************************************************************C
C     GENERAL COULOMB TERMS, DK(J M ;J'M').                            C
C**********************************************************************C
C
C     RESTORE ORIGINAL TENSOR ORDER RANGE
      NUNUM = NUF-NUI+1
C
C     ASSIGN THE TENSOR POWERS TO A LIST
      LTEN = 0
      DO NU=NUI,NUF
        LTEN      = LTEN+1
        NUS(LTEN) = NU
      ENDDO
C
C     ANGULAR FACTORS: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.
C     REVERSE (JA,MA) WITH (JB,MB) INPUTS TO ACCOMMODATE THE RELATION:
C                DK(J,M,J',M',L) = ((-1)^Q)*DK(J'M',J,M,L).
C
C     ASSIGN PRE-FACTORS TO TENSOR POWERS
      DO LTEN=1,NUNUM
        FMLT(LTEN) = 1.0D0
      ENDDO
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ODER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(2),-MJB,JQN(1),-MJA,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(2),-MJB,JQN(1),+MJA,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(2),+MJB,JQN(1),-MJA,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(2),+MJB,JQN(1),+MJA,NU)
C
C            G1 = FMLT(LTEN)*DKAB(LTEN,MJA  ,MJB  )
C            G2 = FMLT(LTEN)*DKAB(LTEN,MJA+1,MJB  )
C            G3 = FMLT(LTEN)*DKAB(LTEN,MJA  ,MJB+1)
C            G4 = FMLT(LTEN)*DKAB(LTEN,MJA+1,MJB+1)
CC
CC           SQUARE THE RESULT BUT KEEP THE SIGN
C            F1 = DSIGN(1.0D0,G1)
C            F2 = DSIGN(1.0D0,G2)
C            F3 = DSIGN(1.0D0,G3)
C            F4 = DSIGN(1.0D0,G4)
CC
C            DKAB(LTEN,MJA  ,MJB  ) = F1*G1*G1
C            DKAB(LTEN,MJA+1,MJB  ) = F2*G2*G2
C            DKAB(LTEN,MJA  ,MJB+1) = F3*G3*G3
C            DKAB(LTEN,MJA+1,MJB+1) = F4*G4*G4
C
          ENDDO
C
C       END THE LOOP OVER MQN(A)
        ENDDO
C     END THE LOOP OVER MQN(B)
      ENDDO
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' GENERAL COULOMB COEFFICIENTS D^K(JA,MA;JB,MB):'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
101   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 1(9X,'K =',I2))
102   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 2(9X,'K =',I2))
103   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 3(9X,'K =',I2))
104   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 4(9X,'K =',I2))
105   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 5(9X,'K =',I2))
106   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 6(9X,'K =',I2))
107   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 7(9X,'K =',I2))
108   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 8(9X,'K =',I2))
109   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 9(9X,'K =',I2))
110   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',10(9X,'K =',I2))
111   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',11(9X,'K =',I2))
112   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',12(9X,'K =',I2))
113   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',13(9X,'K =',I2))
114   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',14(9X,'K =',I2))
C
C     LOOP OVER POSITIVE MQN(B) VALUES -- DESCENDING ORDER OF MAGNITUDE
      DO MB=IABS(KQN(2)),1,-1
        MJB = 2*MB-1
C       LOOP OVER POSITIVE MQN(A) -- DESCENDING ORDER OF MAGNITUDE
        DO MA=IABS(KQN(1)),1,-1
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
C       LOOP OVER POSITIVE MQN(A) -- ASCENDING ORDER OF MAGNITUDE
        DO MA=1,IABS(KQN(1))
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
        IF(MB.NE.1) WRITE(*,*) REPEAT('-',NLNES)
C     END THE LOOP OVER MQN(B)
      ENDDO
      WRITE(*,*) REPEAT('-',NLNES)
C     LOOP OVER NEGATIVE MQN(B) VALUES -- ASCENDING ORDER OF MAGNITUDE
      DO MB=1,IABS(KQN(2))
        MJB = 2*MB-1
C       LOOP OVER POSITIVE MQN(A) -- DESCENDING ORDER OF MAGNITUDE
        DO MA=IABS(KQN(1)),1,-1
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
C       LOOP OVER POSITIVE MQN(A) -- ASCENDING ORDER OF MAGNITUDE
        DO MA=1,IABS(KQN(1))
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
        IF(MB.NE.IABS(KQN(2))) WRITE(*,*) REPEAT('-',NLNES)
C     END THE LOOP OVER MQN(B)
      ENDDO
      WRITE(*,*) REPEAT('=',NLNES)
C
201   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 1(1X,F13.9))
202   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 2(1X,F13.9))
203   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 3(1X,F13.9))
204   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 4(1X,F13.9))
205   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 5(1X,F13.9))
206   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 6(1X,F13.9))
207   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 7(1X,F13.9))
208   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 8(1X,F13.9))
209   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 9(1X,F13.9))
210   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',10(1X,F13.9))
211   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',11(1X,F13.9))
212   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',12(1X,F13.9))
213   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',13(1X,F13.9))
214   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',14(1X,F13.9))
C
      RETURN
      END
C
C
      FUNCTION DK(JA,MA,JB,MB,L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          DDDDDDD  KK    KK                           C
C                          DD    DD KK   KK                            C
C                          DD    DD KK  KK                             C
C                          DD    DD KKKKK                              C
C                          DD    DD KK  KK                             C
C                          DD    DD KK   KK                            C
C                          DDDDDDD  KK    KK                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  DK EVALUATES THE ANGULAR COEFFICIENTS OF THE COULOMB INTERACTION,   C
C  ABSORBING THE ANGULAR DIAGRAM AND ANGULAR PARTS OF THE EFFECTIVE    C
C  INTERACTION STRENGTH TOGETHER. IT EVALUATES ALL PARTS THAT DEPEND   C
C  ON THE ANGULAR FACTOR AT THE INTERACTION VERTEX, ASSUMING THAT THE  C
C  PRIMITIVE RK-RADIAL INTEGRAL (AND NOT XK) IS THE REMAINDER.         C
C -------------------------------------------------------------------- C
C  INPUT CONVENTION: THE ANGULAR MOMENTA (JA,JB,MA,MB) SHOULD BE       C
C  SUPPLIED AS TWICE THEIR ACTUAL VALUES (THESE ARE ODD-HALF-INTEGER   C
C  ELECTRONIC VALUES) WHILE L AND IQ ARE THE **ACTUAL** VALUES OF THE  C
C  PHOTON PARAMETERS. THE SELECTION RULE IS THAT (MA+MB)/2+IQ=0.       C
C**********************************************************************C
C
C      CHOOSE IQ IN ACCORDANCE WITH PHOTON SELECTION RULE
       IQ = (MA-MB)/2
C
C      MQN PHASE TERM
       PHS = DFLOAT((-1)**((MA+1)/2))
C
C      CONVENTIONAL JQN SQUARE ROOT TERMS
       RTJ = DSQRT(DFLOAT((JA+1)*(JB+1)))
C
C      3J SYMBOL ASSOCIATED WITH ANGULAR MOMENTUM CONSERVATION
       SEL = SYM3J(JA,L,JB,+1,0,-1)
C
C      3J SYMBOL CONTAINING SPIN TERMS
       QMM = SYM3J(JA,L,JB,-MA,IQ,MB)
C
C      FINAL ANGULAR FACTOR
       DK = PHS*RTJ*SEL*QMM
C
       RETURN
       END
C
C
      FUNCTION SYM3J(JA,L,JB,MA,M,MB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            SSSSSS  YY    YY MM       MM  333333      JJJJJ           C
C           SS    SS YY    YY MMM     MMM 33    33       JJ            C
C           SS       YY    YY MMMM   MMMM       33       JJ            C
C            SSSSSS   YY  YY  MM MM MM MM    3333        JJ            C
C                 SS   YYYY   MM  MMM  MM       33       JJ            C
C           SS    SS    YY    MM   M   MM  33   33 JJ    JJ            C
C            SSSSSS     YY    MM       MM   33333   JJJJJJ             C
C                                                                      C
C -------------------------------------------------------------------- C
C  SYM3J EVALUATES A WIGNER 3-J SYMBOL,               / j  L  j'\      C
C  WHERE j=JA/2, j'=JB/2, m=MA/2 AND m'=MB/2,         \ m  M  m'/      C
C  BUT L AND M ARE THE ACTUAL VALUES. (BRINK AND SATCHLER {2.34}.)     C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:20),SFACT(0:20)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(IABS(M).GT.L) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(2*M+MA+MB.NE.0) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(IABS(MA).GT.JA.OR.IABS(MB).GT.JB) THEN
        SYM3J = 0.0D0
        RETURN
      ENDIF
C
C     OVERALL PHASE FACTOR (CONVERSION FROM CG-COEFF TO 3J-SYMBOL)
      IPS = (JA-MB)/2 - L
      PHS = DFLOAT((-1)**(IPS))
C
C     SYMMETRIC FACTOR INVOLVING VERTICAL PAIRS (j,m), (L,M), (j',m')
      SM1 = RFACT((JA+MA)/2)
      SM2 = RFACT((JA-MA)/2)
      SM3 = RFACT((JB-MB)/2)
      SM4 = RFACT((JB+MB)/2)
      SM5 = RFACT(  L +M   )
      SM6 = RFACT(  L -M   )
      SYM = DSQRT(SM1*SM2*SM3*SM4*SM5*SM6)
C
C     TRIANGULAR FACTOR, DELTA (j, L, j')
      TR1 = RFACT((JA-JB)/2+L  )
      TR2 = RFACT((JA+JB)/2-L  )
      TR3 = RFACT((JB-JA)/2+L  )
      TR4 = RFACT((JA+JB)/2+L+1)
      TRP = DSQRT(TR1*TR2*TR3/TR4)
C
C     LIMITS IN THE SUM OVER TENSOR ORDERS NU
      NUI = MAX0(L-(JB+MA)/2,M+(JA-JB)/2,  0)
      NUF = MIN0(  (JA-MA)/2,L+(JA-JB)/2,L+M)
C
C     SUM OVER ALLOWED TENSOR ORDERS NU
      XNU = 0.0D0
      DO NU=NUI,NUF
C
C       PHASE TERM FROM TENSOR ORDER
        PTN = DFLOAT((-1)**NU)
C
C       FACTORS INVOLVING TENSOR ORDER
        RD1 = RFACT((JA-MA)/2    -NU)
        RD2 = RFACT((JB+MA)/2-L  +NU)
        RD3 = RFACT((JB-JA)/2  -M+NU)
        RD4 = RFACT((JA-JB)/2+L  -NU)
        RD5 = RFACT(          L+M-NU)
        RD6 = RFACT(              NU)
        RDP = RD1*RD2*RD3*RD4*RD5*RD6
C
C       ADD THIS CONTRIBUTION TO THE 3J-SYMBOL
        XNU = XNU + PTN/RDP
C
      ENDDO
C
C     3-J SYMBOL IS A PRODUCT OF PHASE, SYMMETRIC FACTOR, TRIANGULAR
C     FACTOR AND THE SUM OVER ALLOWED NU TERMS
      SYM3J = PHS*TRP*SYM*XNU
C
      RETURN
      END
C
C
      SUBROUTINE COUPLE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         CCCCCC   OOOOOO  UU    UU PPPPPPP  LL       EEEEEEEE         C
C        CC    CC OO    OO UU    UU PP    PP LL       EE               C
C        CC       OO    OO UU    UU PP    PP LL       EE               C
C        CC       OO    OO UU    UU PP    PP LL       EEEEEE           C
C        CC       OO    OO UU    UU PPPPPPP  LL       EE               C
C        CC    CC OO    OO UU    UU PP       LL       EE               C
C         CCCCCC   OOOOOO   UUUUUU  PP       LLLLLLLL EEEEEEEE         C
C                                                                      C
C -------------------------------------------------------------------- C
C  COUPLE SPECIFIES THE OPEN-SHELL COUPLING MATRIX R:                  C
C               R = {S.D(O).Q + Q.D(O).S}  (RSCF 89)                   C
C  AND ADDS TO THE EXISTING DIRECT- AND EXCHANGE COULOMB/BREIT ARRAYS. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      COMPLEX*16 T1(MDM),T2(MDM),T3(MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/T2EL/F2ES(5,7),T2ES(5,7),N2EB(5,7),N2EI(5,7),N2ES(5,7)
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     LOOP OVER ARRAY COLUMNS J
      DO J=1,NDIM
C
C       RESET INTERMEDIATE COUNTERS T1 AND T2
        DO K=1,NDIM
          T1(K) = DCMPLX(0.0D0,0.0D0)
          T2(K) = DCMPLX(0.0D0,0.0D0)
C
C         PERFORM FIRST MATRIX CONTRACTION
          DO L=1,NDIM
            T1(K) = T1(K) + DENT(K,L)*QDIR(L,J) - DENT(K,L)*QDIR(L,J)
            T2(K) = T2(K) + DENT(K,L)*OVAP(L,J)
          ENDDO
C
C       AT THIS POINT, T1 AND T2 ARE COMPLETE FOR COLUMN J
        ENDDO
C
C       MULTIPLY THESE CONTRACTIONS APPROPRIATELY
        DO I=1,NDIM
          T3(I) = DCMPLX(0.0D0,0.0D0)
          DO K=1,NDIM
            T3(I) = T3(I) + T1(K)*OVAP(I,K)
     &                    + T2(K)*QDIR(I,K) - T2(K)*QXCH(I,K)
          ENDDO
        ENDDO
C
C       ADD THE PROJECTOR AND Q-MATRIX TO THE COULOMB MATRIX  (RSCF 91)
C       DO I=1,NDIM
C         FOCK(I,J) = FOCK(I,J) - QMAT(I,J) + T3(I)
C       ENDDO
C       DFNOTE: OKAY... SO I HAVE TO FIX ENERGY TERM
C
C       APPLY COUPLING TO ALL ROWS I OF THE JTH COLUMN OF QDIR/QXCH
        DO I=1,NDIM
          QDIR(I,J) = QDIR(I,J) - T3(I)
          QXCH(I,J) = QXCH(I,J) + T3(I)
        ENDDO
C
C     END LOOP OVER ARRAY COLUMNS J
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE SPARSITY(A,N,EPS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS  PPPPPPP     AA    RRRRRRR   SSSSSS IIII TTTTTTTT YY    YY  C
C  SS    SS PP    PP   AAAA   RR    RR SS    SS II     TT    YY    YY  C
C  SS       PP    PP  AA  AA  RR    RR SS       II     TT    YY    YY  C
C   SSSSSS  PP    PP AA    AA RR    RR  SSSSSS  II     TT     YY  YY   C
C        SS PPPPPPP  AAAAAAAA RRRRRRR        SS II     TT      YYYY    C
C  SS    SS PP       AA    AA RR    RR SS    SS II     TT       YY     C
C   SSSSSS  PP       AA    AA RR    RR  SSSSSS IIII    TT       YY     C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPARSITY APPLIES MATRIX SPARSITY CONDITIONS ON A COMPLEX-VALUED     C
C  ARRAY A OF DIMENSION N.                                             C
C**********************************************************************C
C
      COMPLEX*16 A(N,N)
C
C     LOOP OVER ALL MATRIX ELEMENTS
      DO I=1,NDIM
        DO J=1,NDIM
C
          X = DREAL(A(I,J))
          Y = DIMAG(A(I,J))
C
C         ELIMINATE ANY VANISHINGLY SMALL MATRIX ELEMENTS
          IF(DABS(X).LT.EPS) THEN
            X = 0.0D0
          ENDIF
          IF(DABS(Y).LT.EPS) THEN
            Y = 0.0D0
          ENDIF
C
C         ALSO ELMINATE ALL DIAGONAL IMAGINARY MATRIX ELEMENTS
          IF(I.EQ.J) THEN
            Y = 0.0D0
          ENDIF
C
C         TRANSFER ELEMENT BACK TO A MATRIX
          A(I,J) = DCMPLX(X,Y)
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE NCART(IVECT,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             NN    NN  CCCCCC     AA    RRRRRRR TTTTTTTT              C
C             NNN   NN CC    CC   AAAA   RR    RR   TT                 C
C             NNNN  NN CC        AA  AA  RR    RR   TT                 C
C             NN NN NN CC       AA    AA RR    RR   TT                 C
C             NN  NNNN CC       AAAAAAAA RRRRRRR    TT                 C
C             NN   NNN CC    CC AA    AA RR    RR   TT                 C
C             NN    NN  CCCCCC  AA    AA RR    RR   TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCART RETURNS THE CARTESIAN INDEX FROM THE INDEX VALUE IND.         C
C**********************************************************************C
C
      DIMENSION IVECT(3)
C
      IF(IND.EQ.1) THEN
        IVECT(1) = 1
        IVECT(2) = 0
        IVECT(3) = 0
      ELSEIF(IND.EQ.2) THEN
        IVECT(1) = 0
        IVECT(2) = 1
        IVECT(3) = 0
      ELSEIF(IND.EQ.3) THEN
        IVECT(1) = 0
        IVECT(2) = 0
        IVECT(3) = 1
      ELSE
        WRITE(6, *) 'In NCART: supplied index not valid',IND
        WRITE(7, *) 'In NCART: supplied index not valid',IND
        RETURN
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        NN    NN  CCCCCC  NN    NN TTTTTTTT RRRRRRR   SSSSSS          C
C        NNN   NN CC    CC NNN   NN    TT    RR    RR SS    SS         C
C        NNNN  NN CC       NNNN  NN    TT    RR    RR SS               C
C        NN NN NN CC       NN NN NN    TT    RR    RR  SSSSSS          C
C        NN  NNNN CC       NN  NNNN    TT    RRRRRRR        SS         C
C        NN   NNN CC    CC NN   NNN    TT    RR    RR SS    SS         C
C        NN    NN  CCCCCC  NN    NN    TT    RR    RR  SSSSSS          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCNTRS RETURNS NUMBER OF UNIQUE NUCLEAR CENTERS FROM INPUT VALUES.  C
C**********************************************************************C
C
C     STORE ICNTA IN FIRST PLACE
      NCNTRS = 1
C
C     CHECK ICNTB AGAINST STORED VALUES
      IF(ICNTB.NE.ICNTA) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTC AGAINST STORED VALUES
      IF(ICNTC.NE.ICNTA.AND.ICNTC.NE.ICNTB) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTD AGAINST STORED VALUES
      IF(ICNTD.NE.ICNTA.AND.ICNTD.NE.ICNTB.AND.ICNTD.NE.ICNTC) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ZPROJ(XYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            ZZZZZZZZ PPPPPPP  RRRRRRR   OOOOOO     JJJJJJ             C
C                 ZZ  PP    PP RR    RR OO    OO       JJ              C
C                ZZ   PP    PP RR    RR OO    OO       JJ              C
C               ZZ    PP    PP RR    RR OO    OO       JJ              C
C              ZZ     PPPPPPP  RRRRRRR  OO    OO       JJ              C
C             ZZ      PP       RR    RR OO    OO JJ    JJ              C
C            ZZZZZZZZ PP       RR    RR  OOOOOO   JJJJJJ               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZPROJ RETURNS THE SUM OF ABSOLUTE DIFFERENCES BETWEEN X AND Y       C
C  LOCATIONS OF FOUR SUPPLIED COORDINATES.                             C
C**********************************************************************C
C
       DIMENSION XYZ(3,4)
C
       ZPROJ = 0.0D0
C
       DO IX=1,2
         DO M=1,3
           DO N=M+1,4
             ZPROJ = ZPROJ + DABS(XYZ(IX,M)-XYZ(IX,N))
           ENDDO
         ENDDO
       ENDDO
C
       RETURN
       END
C
C**********************************************************************C
C ==================================================================== C
C   [6] MULTI-CONFIG: MANY-CENTER MULTICONFIG. SCF CALCULATIONS.       C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] MCSCF: MAIN ROUTINE FOR MULTI-CONFIGURATIONAL SCF CALCULATION. C
C**********************************************************************C
C
C
      SUBROUTINE MCSCF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           MM       MM  CCCCCC   SSSSSS   CCCCCC  FFFFFFFF            C
C           MMM     MMM CC    CC SS    SS CC    CC FF                  C
C           MMMM   MMMM CC       SS       CC       FF                  C
C           MM MM MM MM CC        SSSSSS  CC       FFFFFF              C
C           MM  MMM  MM CC             SS CC       FF                  C
C           MM   M   MM CC    CC SS    SS CC    CC FF                  C
C           MM       MM  CCCCCC   SSSSSS   CCCCCC  FF                  C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  MCSCF PERFORMS A MULTI-CONFIGURATIONAL SCF CALCULATION USING THE    C
C  APPROACH OF KNOWLES AND WERNER (1985,1988).                         C
C**********************************************************************C
C
      CHARACTER*4  HMLTN
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/TMCF/EMTY
C
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',20),'MULTI-CONFIGURATIONAL MOLECULAR SCF'
      WRITE(7, *) REPEAT(' ',20),'MULTI-CONFIGURATIONAL MOLECULAR SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     EQ-COEFFICIENTS IN COMMON ARRAYS
      IF(IEQS.EQ.1.AND.INEW.NE.0) THEN
        CALL EQFILE
      ENDIF
C
C     WARN USER THAT ROUTINE HASN'T BEEN WRITTEN YET
      WRITE(6, *) 'In BERTHA: MCSCF option not yet available.'
      WRITE(7, *) 'In BERTHA: MCSCF option not yet available.'
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [7] DMRG: DENSITY MATRIX RENORMALISATION GROUP CALCULATIONS.       C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] DMRG: DENSITY MATRIX RENORMALISATION GROUP CALCULATION.        C
C**********************************************************************C
C
C
      SUBROUTINE DMRG
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                DDDDDDD  MM       MM RRRRRRR   GGGGGG                 C
C                DD    DD MMM     MMM RR    RR GG    GG                C
C                DD    DD MMMM   MMMM RR    RR GG                      C
C                DD    DD MM MM MM MM RR    RR GG                      C
C                DD    DD MM  MMM  MM RRRRRRR  GG   GGG                C
C                DD    DD MM   M   MM RR    RR GG    GG                C
C                DDDDDDD  MM       MM RR    RR  GGGGGG                 C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  DMRG PERFORMS A CALCULATION BASED ON THE FORMALISM OF THE DENSITY   C
C  MATRIX RENORMALISATION GROUP.                                       C
C**********************************************************************C
C
      CHARACTER*4  HMLTN
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/TDMG/EMTY
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',20),'DENSITY MATRIX RENORMALISATION GROUP'
      WRITE(7, *) REPEAT(' ',20),'DENSITY MATRIX RENORMALISATION GROUP'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     EQ-COEFFICIENTS IN COMMON ARRAYS
      IF(IEQS.EQ.1.AND.INEW.NE.0) THEN
        CALL EQFILE
      ENDIF
C
C     WARN USER THAT ROUTINE HASN'T BEEN WRITTEN YET
      WRITE(6, *) 'In BERTHA: DMRG option not yet available.'
      WRITE(7, *) 'In BERTHA: DMRG option not yet available.'
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [8] MBPT: CORRELATION ENERGY CALCULATION ROUTINES.                 C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] MBPT: MAIN ROUTINE FOR MANY-BODY DIAGRAMMATIC P.T.             C
C   [B] MBPT1: ZERO- AND FIRST-ORDER ENERGY ANALYSIS.                  C
C   [C] MBPT2: SECOND-ORDER CORRELATION ENERGY ANALYSIS.               C
C**********************************************************************C
C
C
      SUBROUTINE MBPT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                MM       MM BBBBBBB  PPPPPPP  TTTTTTTT                C
C                MMM     MMM BB    BB PP    PP    TT                   C
C                MMMM   MMMM BB    BB PP    PP    TT                   C
C                MM MM MM MM BBBBBBB  PP    PP    TT                   C
C                MM  MMM  MM BB    BB PPPPPPP     TT                   C
C                MM   M   MM BB    BB PP          TT                   C
C                MM       MM BBBBBBB  PP          TT                   C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  MBPT PERFORMS MANY-BODY DIAGRAMMATIC EVALUATION ON A CONVERGED      C
C  MOLECULAR HARTREE-FOCK SOLUTION SPACE.                              C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9)

C
      CHARACTER*4 HMLTN
      CHARACTER*5 G2INT
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMPT/EMTY
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',21),'MANY-BODY PERTURBATION THEORY'
      WRITE(7, *) REPEAT(' ',21),'MANY-BODY PERTURBATION THEORY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     EQ-COEFFICIENTS IN COMMON ARRAYS
      IF(IEQS.EQ.1.AND.INEW.NE.0) THEN
        CALL EQFILE
      ENDIF
C
C     GENERATE DENSITY MATRIX
      IF(INEW.EQ.1) THEN
        CALL DENSTY
      ENDIF
C
C     RESTRICT SET OF OCCUPIED AND VIRTUAL STATES
      MINO = 1
      NUMO = NOCC
      MINV = NOCC+1
      NUMV = NVRT
C
C     LABEL THE TWO-BODY INTERACTION ('COULM' OR 'BREIT')
      G2INT = 'COULM'
C
C     SUMMARY OF INPUT CHOICES
      WRITE(6, *) 'First occupied orbital:     ',MINO
      WRITE(7, *) 'First occupied orbital:     ',MINO
      WRITE(6, *) 'Number of occupied orbitals:',NUMO
      WRITE(7, *) 'Number of occupied orbitals:',NUMO
      WRITE(6, *) 'First virtual orbital:      ',MINV
      WRITE(7, *) 'First virtual orbital:      ',MINV
      WRITE(6, *) 'Number of virtual orbitals: ',NUMV
      WRITE(7, *) 'Number of virtual orbitals: ',NUMV
      IF(G2INT.EQ.'COULM') THEN
        WRITE(6, *) '2-body interaction: Coulomb.'
        WRITE(7, *) '2-body interaction: Coulomb.'
      ELSEIF(G2INT.EQ.'BREIT') THEN
        WRITE(6, *) '2-body interaction: Breit.'
        WRITE(7, *) '2-body interaction: Breit.'
      ENDIF
C
C     CALL FIRST-ORDER MBPT ROUTINE
      CALL MBPT1(MINO,NUMO,G2INT)
C
C     CALL SECOND-ORDER MBPT ROUTINE
      CALL MBPT2(MINO,NUMO,MINV,NUMV,G2INT)
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TMPT)
      TTOT = TTOT-TDUM
C
      RETURN
      END
C
C
      SUBROUTINE MBPT1(MINO,NUMO,G2INT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              MM       MM BBBBBBB  PPPPPPP TTTTTTTT 11                C
C              MMM     MMM BB    BB PP    PP   TT   111                C
C              MMMM   MMMM BB    BB PP    PP   TT    11                C
C              MM MM MM MM BBBBBBB  PP    PP   TT    11                C
C              MM  MMM  MM BB    BB PPPPPPP    TT    11                C
C              MM   M   MM BB    BB PP         TT    11                C
C              MM       MM BBBBBBB  PP         TT   1111               C
C                                                                      C
C -------------------------------------------------------------------- C
C  MBPT1 EVALUATES ZERO- AND FIRST-ORDER ENERGIES FOR ALL OCCUPIED     C
C  SOLUTIONS TO A CONVERGED HARTREE-FOCK PROBLEM.                      C
C -------------------------------------------------------------------- C
C INPUT:                                                               C
C  MINO  - LOWEST OCCUPIED STATE TO ACCOUNT FOR. (FULL: 1)             C
C  NUMO  - NUMBER OF OCCUPIED STATES TO ACCOUNT FOR. (FULL: NOCC)      C
C  G2INT - NAME OF TWO-BODY OPERATOR ('COULM' OR 'BREIT').             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000)
C
      CHARACTER*4 HMLTN
      CHARACTER*5 G2INT
      CHARACTER*16 HMS
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-(MKP+1)/2:(MKP+1)/2,MKP)
      DIMENSION EAB1(NUMO,NUMO,6),EA1(NUMO,6)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 C(MDM,MDM)
      COMPLEX*16 B1(MBS*NUMO,8),B2(MBS*NUMO,8)
      COMPLEX*16 DB(MB2,NUMO*NUMO,4)
      COMPLEX*16 ADB1(MBS,NUMO*NUMO*NUMO,2),ADB2(MBS,NUMO*NUMO*NUMO,2)
      COMPLEX*16 CADB((NUMO+1)*NUMO*NUMO*NUMO/2)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           VUEH(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),BDIR(MDM,MDM),
     &           BXCH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/EIGN/EIGEN(MDM)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      IERC = 0
C
C     WARNINGS BASED ON INVALID HMLTN VS. G2INT COMBINATIONS
      IF(G2INT.EQ.'COULM') THEN
        IF(HMLTN.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT1: HMLTN = BARE but G2INT = COULM.'
          WRITE(7, *) 'In MBPT1: HMLTN = BARE but G2INT = COULM.'
        ENDIF
      ELSEIF(G2INT.EQ.'BREIT') THEN
        IF(HMLTN.EQ.'NORL') THEN
          WRITE(6, *) 'In MBPT1: HMLTN = NORL but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLTN = NORL but G2INT = BREIT.'
          RETURN
        ELSEIF(HMLTN.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT1: HMLTN = BARE but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLTN = BARE but G2INT = BREIT.'
        ELSEIF(HMLTN.EQ.'DHFR') THEN
          WRITE(6, *) 'In MBPT1: HMLTN = DHFR but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLTN = DHFR but G2INT = BREIT.'
        ELSEIF(HMLTN.EQ.'DHFP') THEN
          WRITE(6, *) 'In MBPT1: HMLTN = DHFP but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLTN = DHFP but G2INT = BREIT.'
        ENDIF
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLTN.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLTN.EQ.'NORL') THEN
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 1
          ITSTOP = 1
          ITSKIP = 1
        ENDIF
      ELSE
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 4
          ITSTOP = 1
          ITSKIP =-3
        ELSEIF(G2INT.EQ.'BREIT') THEN
          ITSTRT = 2
          ITSTOP = 3
          ITSKIP = 1        
        ENDIF
      ENDIF
C
C     INITIALISE TIME COUNTERS
      T1EL = 0.0D0
      TERI = 0.0D0
      TCN1 = 0.0D0
      TCN2 = 0.0D0
      TCN3 = 0.0D0
      TCN4 = 0.0D0
      TSUM = 0.0D0
C
      CALL CPU_TIME(TBEG)
C
C     CLEAR ENERGY COUNTERS
      DO N=1,6
        DO IOCCB=1,NUMO
          EA1(IOCCB,N) = 0.0D0
          DO IOCCA=1,NUMO
            EAB1(IOCCA,IOCCB,N) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     CLEAR THE ARRAY FOR (AR|BS) VALUES
      M = 0
      DO IOCCC=1,NUMO
        DO IOCCA=1,NUMO
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
              M = M+1
              CADB(M) = DCMPLX(0.0D0,0.0D0)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTERS
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTER
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KVALS(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ONE-BODY ENERGIES (INSIGNIFICANT COMPUTATIONAL COST)             C
C**********************************************************************C
C
C     RECORD TIME AT THE START OF THIS PROCESS
      CALL CPU_TIME(T1)
C
C     CALCULATE ONE-BODY MATRIX REPS
      CALL ONEEL
C
C     LOOP OVER ALL OCCUPIED ORBITAL PAIRS AND CONTRACT
      E1H = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         FOCK MATRIX ADDRESS FOR IOCCA AND IOCCB
          IA = MINO-1+IOCCA+NSHIFT
          IB = MINO-1+IOCCB+NSHIFT
C
C         ONE-BODY ENERGY
          TMP1 = 0.0D0
          TMP2 = 0.0D0
          IF(IOCCA.EQ.IOCCB) THEN
            DO J=1,NDIM
              DO I=1,NDIM
                TMP1 = TMP1 + DREAL(HNUC(I,J)*DCONJG(C(I,IA))*C(J,IA))
                TMP2 = TMP2 + DREAL(HKIN(I,J)*DCONJG(C(I,IA))*C(J,IA))
              ENDDO
            ENDDO
          ENDIF
          EAB1(IOCCA,IOCCB,1) = TMP1
          EAB1(IOCCA,IOCCB,2) = TMP2
          EAB1(IOCCA,IOCCB,3) = TMP1+TMP2
          E1H = E1H + EAB1(IOCCA,IOCCB,3)
C
        ENDDO
      ENDDO
C
C     RECORD TIME AT THE END OF THIS PROCESS
      CALL CPU_TIME(T2)
      T1EL = T1EL+T2-T1
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTERS A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 1000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPES A AND B (USE INDEX 2000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1, NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER |MQN| PROJECTIONS A AND B (INDEX 3000)                 C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     INDEX ASSIGNMENT
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ1.LT.IQ2) GOTO 3001
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS A AND B (INDEX 4000)          C
C**********************************************************************C
C
C     COMPONENT LABEL FOR A AND B: TT = LL(1) or SS(4) <- COULM
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSHIFT
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C**********************************************************************C
C     FOCK MATRIX STARTING ADDRESSES                                   C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LARGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LARGE(ICNTB,KB,2*MB-1) + NADDAB
C
      NA2 = LARGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LARGE(ICNTB,KB,2*MB  ) + NADDAB
C
C     CLEAR ARRAY FOR THE COMPLETED CONTRACTION OVER BLOCKS C AND D
      DO MDB=1,NUMO*NUMO
        DO MIJ=1,NBAS(1)*NBAS(2)
          DO IJSPIN=1,4
            DB(MIJ,MDB,IJSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTERS C AND D (USE INDEX 5000)                C
C**********************************************************************C
C
C     LOOP OVER CENTER C
      DO 5000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER C
        XYZ(1,3) = COORD(1,ICNTC)
        XYZ(2,3) = COORD(2,ICNTC)
        XYZ(3,3) = COORD(3,ICNTC)
C
C     LOOP OVER CENTER D
      DO 5000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER D
        XYZ(1,4) = COORD(1,ICNTD)
        XYZ(2,4) = COORD(2,ICNTD)
        XYZ(3,4) = COORD(3,ICNTD)
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPES C AND D (USE INDEX 6000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(C) VALUES
      DO 6000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KVALS(KC,ICNTC)
        IF(KQN(3).GT.0) THEN
          LQN(3) = KQN(3)
        ELSE
          LQN(3) =-KQN(3)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFUNCT(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = EXPSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 6000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KVALS(KD,ICNTD)
        IF(KQN(4).GT.0) THEN
          LQN(4) = KQN(4)
        ELSE
          LQN(4) =-KQN(4)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFUNCT(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = EXPSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER |MQN| PROJECTIONS C AND D (INDEX 7000)                 C
C**********************************************************************C
C
C     LOOP OVER |MQN(C)| VALUES
      DO 7000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 7000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     INDEX ASSIGNMENT
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ3.LT.IQ4) GOTO 7001
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS C AND D (INDEX 8000)          C
C**********************************************************************C
C
C     COMPONENT LABEL FOR C AND D: TT = LL(1) or SS(4) <- COULM
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 8000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSHIFT
        ENDIF
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C**********************************************************************C
C     FOCK MATRIX STARTING ADDRESSES                                   C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NC1 = LARGE(ICNTC,KC,2*MC-1) + NADDCD
      ND1 = LARGE(ICNTD,KD,2*MD-1) + NADDCD
C
      NC2 = LARGE(ICNTC,KC,2*MC  ) + NADDCD
      ND2 = LARGE(ICNTD,KD,2*MD  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 9000)         C
C**********************************************************************C
C
      DO 9000 IBAS=1,NBAS(1)
      DO 9000 JBAS=1,NBAS(2)
C
C     LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
      MIJ = (IBAS-1)*NBAS(2) + JBAS
C
C     RESET SCREENING COUNTERS
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
      ENDDO
C
C     BATCH OF ELECTRON INTERACTION INTEGRALS (IJ|KL) FOR FIXED (IJ)
      CALL CPU_TIME(T1)
      IF(G2INT.EQ.'COULM') THEN
        CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
      ELSEIF(G2INT.EQ.'BREIT') THEN
        CALL BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
      ENDIF
      CALL CPU_TIME(T2)
      TERI = TERI + T2 - T1
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (DIRECT)
      DO MKB=1,NBAS(3)*NUMO
        DO IJKSPIN=1,8
          B1(MKB,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (SWAP)
      DO MLB=1,NBAS(4)*NUMO
        DO IJLSPIN=1,8
          B2(MLB,IJLSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST CONTRACTION:                                               C
C     (IJ;T|KL;T') -> (IJ;T|KB;T')  AND  (IJ;T|LK;T') -> (IJ;T|LB;T')  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FIRST CONTRACTION (DIRECT): (IJ;T|KL;T') -> (IJ;T|KB;T')
C
C     LOOP OVER BASIS FUNCTIONS IN BLOCK C AND OCCUPIED STATES IOCCB
      DO KBAS=1,NBAS(3)
        DO IOCCB=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCB
          IB = MINO-1+IOCCB+NSHIFT
C
C         LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
          MKB = (KBAS-1)*NUMO + IOCCB
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK D AND CONTRACT OVER ERI
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|-B) = (--|--) + (--|-+)
            B1(MKB,1) = B1(MKB,1) +      RR(M, 1)*C(ND1+LBAS,IB)
     &                            +      RR(M, 2)*C(ND2+LBAS,IB)
C           (+-|-B) = (+-|--) + (+-|-+)
            B1(MKB,2) = B1(MKB,2) +      RR(M, 9)*C(ND1+LBAS,IB)
     &                            +      RR(M,10)*C(ND2+LBAS,IB)
C           (-+|-B) = (-+|--) + (-+|-+)
            B1(MKB,3) = B1(MKB,3) +      RR(M, 5)*C(ND1+LBAS,IB)
     &                            +      RR(M, 6)*C(ND2+LBAS,IB)
C           (++|-B) = (++|--) + (++|-+)
            B1(MKB,4) = B1(MKB,4) +      RR(M,13)*C(ND1+LBAS,IB)
     &                            +      RR(M,14)*C(ND2+LBAS,IB)
C           (--|+B) = (--|+-) + (--|++)
            B1(MKB,5) = B1(MKB,5) +      RR(M, 3)*C(ND1+LBAS,IB)
     &                            +      RR(M, 4)*C(ND2+LBAS,IB)
C           (+-|+B) = (+-|+-) + (+-|++)
            B1(MKB,6) = B1(MKB,6) +      RR(M,11)*C(ND1+LBAS,IB)
     &                            +      RR(M,12)*C(ND2+LBAS,IB)
C           (-+|+B) = (-+|+-) + (-+|++)
            B1(MKB,7) = B1(MKB,7) +      RR(M, 7)*C(ND1+LBAS,IB)
     &                            +      RR(M, 8)*C(ND2+LBAS,IB)
C           (++|+B) = (++|+-) + (++|++)
            B1(MKB,8) = B1(MKB,8) +      RR(M,15)*C(ND1+LBAS,IB)
     &                            +      RR(M,16)*C(ND2+LBAS,IB)
C
          ENDDO
        ENDDO
      ENDDO
C
C     FIRST CONTRACTION (SWAP): (IJ;T|LK;T') -> (IJ;T|LB;T')
      IF(IQ3.EQ.IQ4) GOTO 9100
C
C     LOOP OVER BASIS FUNCTIONS IN BLOCK D AND OCCUPIED STATES IOCCB
      DO LBAS=1,NBAS(4)
        DO IOCCB=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCB
          IB = MINO-1+IOCCB+NSHIFT
C
C         LIST ADDRESS FOR THIS LBAS,IOCCB COMBINATION
          MLB = (LBAS-1)*NUMO + IOCCB
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK C AND CONTRACT OVER ERI
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|+B) = PAB*{(--|B+)} = PAB*{(--|++) + ((--|-+))}
            B2(MLB,1) = B2(MLB,1) + PCD1*RR(M, 4)*C(NC1+KBAS,IB)
     &                            + PCD2*RR(M, 2)*C(NC2+KBAS,IB)
C
C           (+-|+B) = PAB*{(+-|B+)} = PAB*{(+-|++) + ((+-|-+))}
            B2(MLB,2) = B2(MLB,2) + PCD1*RR(M,12)*C(NC1+KBAS,IB)
     &                            + PCD2*RR(M,10)*C(NC2+KBAS,IB)
C
C           (-+|+B) = PAB*{(-+|B+)} = PAB*{(-+|++) + ((-+|-+))}
            B2(MLB,3) = B2(MLB,3) + PCD1*RR(M, 8)*C(NC1+KBAS,IB)
     &                            + PCD2*RR(M, 6)*C(NC2+KBAS,IB)
C
C           (++|+B) = PAB*{(++|B+)} = PAB*{(++|++) + ((++|-+))}
            B2(MLB,4) = B2(MLB,4) + PCD1*RR(M,16)*C(NC1+KBAS,IB)
     &                            + PCD2*RR(M,14)*C(NC2+KBAS,IB)
C
C           (--|-B) = PAB*{(--|B-)} = PAB*{(--|+-) + ((--|--))}
            B2(MLB,5) = B2(MLB,5) + PCD2*RR(M, 3)*C(NC1+KBAS,IB)
     &                            + PCD1*RR(M, 1)*C(NC2+KBAS,IB)
C
C           (+-|-B) = PAB*{(+-|B-)} = PAB*{(+-|+-) + ((+-|--))}
            B2(MLB,6) = B2(MLB,6) + PCD2*RR(M,11)*C(NC1+KBAS,IB)
     &                            + PCD1*RR(M, 9)*C(NC2+KBAS,IB)
C
C           (-+|-B) = PAB*{(-+|B-)} = PAB*{(-+|+-) + ((-+|--))}
            B2(MLB,7) = B2(MLB,7) + PCD2*RR(M, 7)*C(NC1+KBAS,IB)
     &                            + PCD1*RR(M, 5)*C(NC2+KBAS,IB)
C
C           (++|-B) = PAB*{(++|B-)} = PAB*{(++|+-) + ((++|--))}
            B2(MLB,8) = B2(MLB,8) + PCD2*RR(M,15)*C(NC1+KBAS,IB)
     &                            + PCD1*RR(M,13)*C(NC2+KBAS,IB)
C
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ3 = IQ4
9100  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN1 = TCN1 + T2 - T1
C
C**********************************************************************C
C     SECOND CONTRACTION:                                   ~          C
C     (IJ;T|KB;T') -> (IJ;T|DB)  AND  (IJ;T|LB;T') -> (IJ;T|DB)        C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     SECOND CONTRACTION (DIRECT): (IJ;T|KB) -> (IJ;T|DB)
C
C     LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
      DO IOCCB=1,NUMO
        DO IOCCD=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCD
          ID = MINO-1+IOCCD+NSHIFT
C
C         LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION IN B1
          MDB = (IOCCB-1)*NUMO + IOCCD
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK C AND CONTRACT OVER B1
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
            MKB = (KBAS-1)*NUMO + IOCCB
C
C           (--|DB) = (--|-B) + (--|+B)
            DB(MIJ,MDB,1) = DB(MIJ,MDB,1)
     &                    + B1(MKB,1)*DCONJG(C(NC1+KBAS,ID))
     &                    + B1(MKB,5)*DCONJG(C(NC2+KBAS,ID))
C
C           (-+|DB) = (-+|-B) + (-+|+B)
            DB(MIJ,MDB,2) = DB(MIJ,MDB,2)
     &                    + B1(MKB,3)*DCONJG(C(NC1+KBAS,ID))
     &                    + B1(MKB,7)*DCONJG(C(NC2+KBAS,ID))
C
C           (+-|DB) = (+-|-B) + (+-|+B)
            DB(MIJ,MDB,3) = DB(MIJ,MDB,3)
     &                    + B1(MKB,2)*DCONJG(C(NC1+KBAS,ID))
     &                    + B1(MKB,6)*DCONJG(C(NC2+KBAS,ID))
C
C           (++|DB) = (++|-B) + (++|+B)
            DB(MIJ,MDB,4) = DB(MIJ,MDB,4)
     &                    + B1(MKB,4)*DCONJG(C(NC1+KBAS,ID))
     &                    + B1(MKB,8)*DCONJG(C(NC2+KBAS,ID))
C
          ENDDO
        ENDDO
      ENDDO
C
C
C     SECOND CONTRACTION (SWAP): (IJ;T|LB) -> (IJ;T|DB)
      IF(IQ3.EQ.IQ4) GOTO 9200
C
C     LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
      DO IOCCB=1,NUMO
        DO IOCCD=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCD
          ID = MINO-1+IOCCD+NSHIFT
C
C         LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION IN B1
          MDB = (IOCCB-1)*NUMO + IOCCD
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK D AND CONTRACT OVER B2
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS LBAS,IOCCB COMBINATION
            MLB = (LBAS-1)*NUMO + IOCCB
C
C           (--|DB) = (--|+B) + (--|-B)
            DB(MIJ,MDB,1) = DB(MIJ,MDB,1)
     &                    + B2(MLB,1)*DCONJG(C(ND1+LBAS,ID))
     &                    + B2(MLB,5)*DCONJG(C(ND2+LBAS,ID))
C
C           (-+|DB) = (-+|+B) + (-+|-B)
            DB(MIJ,MDB,2) = DB(MIJ,MDB,2)
     &                    + B2(MLB,3)*DCONJG(C(ND1+LBAS,ID))
     &                    + B2(MLB,7)*DCONJG(C(ND2+LBAS,ID))
C
C           (+-|DB) = (+-|+B) + (+-|-B)
            DB(MIJ,MDB,3) = DB(MIJ,MDB,3)
     &                    + B2(MLB,2)*DCONJG(C(ND1+LBAS,ID))
     &                    + B2(MLB,6)*DCONJG(C(ND2+LBAS,ID))
C
C           (++|DB) = (++|+B) + (++|-B)
            DB(MIJ,MDB,4) = DB(MIJ,MDB,4)
     &                    + B2(MLB,4)*DCONJG(C(ND1+LBAS,ID))
     &                    + B2(MLB,8)*DCONJG(C(ND2+LBAS,ID))
C
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ3 = IQ4
9200  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN2 = TCN2 + T2 - T1
C
C     END LOOP OVER BASIS PAIR (IBAS,JBAS)
9000  CONTINUE
C
C     DB ARRAY NOW CONTAINS THE PARTIALLY-TRANSFORMED LIST: (IJ,DB)
8000  CONTINUE
7001  CONTINUE
7000  CONTINUE
6000  CONTINUE
5000  CONTINUE
C
C**********************************************************************C
C     THIRD CONTRACTION:                                               C
C     (IJ;T|DB) -> (IA;T|DB)  AND  (JI;T|DB) -> (JA;T|DB)              C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     THIRD CONTRACTION (DIRECT): (IJ;T|DB) -> (IA;T|DB)
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (DIRECT)
      DO MADB=1,NUMO*NUMO*NUMO
        DO IBAS=1,NBAS(1)
          DO ISPIN=1,2
            ADB1(IBAS,MADB,ISPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSHIFT
C
C       LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
        DO IOCCB=1,IOCCA
          DO IOCCD=1,NUMO
C
C           LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
            MDB = (IOCCB-1)*NUMO+IOCCD
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
            MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C           LOOP OVER BASIS FUNCTIONS IN A AND B, CONTRACT OVER DB
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-A|DB) = (--|DB) + (-+|DB)
                ADB1(IBAS,MADB,1) = ADB1(IBAS,MADB,1)
     &                      +      DB(MIJ,MDB,1)*C(NB1+JBAS,IA)
     &                      +      DB(MIJ,MDB,2)*C(NB2+JBAS,IA)
C               (+A|DB) = (+-|DB) + (++|DB)
                ADB1(IBAS,MADB,2) = ADB1(IBAS,MADB,2)
     &                      +      DB(MIJ,MDB,3)*C(NB1+JBAS,IA)
     &                      +      DB(MIJ,MDB,4)*C(NB2+JBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     THIRD CONTRACTION (SWAP): (JI;T|DB) -> (JA;T|DB)
      IF(IQ1.EQ.IQ2) GOTO 4100
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (SWAP)
      DO MADB=1,NUMO*NUMO*NUMO
        DO JBAS=1,NBAS(2)
          DO JSPIN=1,2
            ADB2(JBAS,MADB,JSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSHIFT
C
C       LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
        DO IOCCB=1,IOCCA
          DO IOCCD=1,NUMO
C
C           LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
            MDB = (IOCCB-1)*NUMO+IOCCD
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
            MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C           LOOP OVER BASIS FUNCTIONS IN A AND B, CONTRACT OVER DB
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (+A|DB) = PCD*{(+A|DB)} = PCD*{(++|DB) + (-+|DB)}
                ADB2(JBAS,MADB,1) = ADB2(JBAS,MADB,1)
     &                      + PAB1*DB(MIJ,MDB,4)*C(NA1+IBAS,IA)
     &                      + PAB2*DB(MIJ,MDB,2)*C(NA2+IBAS,IA)
C               (-A|DB) = PCD*{(-A|DB)} = PCD*{(+-|DB) + (--|DB)}
                ADB2(JBAS,MADB,2) = ADB2(JBAS,MADB,2)
     &                      + PAB2*DB(MIJ,MDB,3)*C(NA1+IBAS,IA)
     &                      + PAB1*DB(MIJ,MDB,1)*C(NA2+IBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ1 = IQ2
4100  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN3 = TCN3 + T2 - T1
C
C**********************************************************************C
C     FOURTH CONTRACTION:                      ~                       C
C     (IA;T|DB) -> (CA|DB)  AND  (JA;T|DB) -> (CA|DB)                  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOURTH CONTRACTION (DIRECT): (IA;T|DB) -> (CA|DB)
C
C     LOOP OVER OCCUPIED STATES IOCCA AND IOCCC
      DO IOCCA=1,NUMO
        DO IOCCC=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCC
          IC = MINO-1+IOCCC+NSHIFT
C
C         LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
C
C             LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
              MDB = (IOCCB-1)*NUMO + IOCCD
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
              MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C             LIST ADDRESS FOR THIS IOCCC,IOCCA AND THE ABOVE MDB
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + MDB
C
C             LOOP OVER BASIS FUNCTIONS IN BLOCK A, CONTRACT OVER ADB1
              DO IBAS=1,NBAS(1)
C
C               (CA|DB) = (-A|DB) + (+A|DB)
                CADB(MCADB) = CADB(MCADB)
     &                      + ADB1(IBAS,MADB,1)*DCONJG(C(NA1+IBAS,IC))
     &                      + ADB1(IBAS,MADB,2)*DCONJG(C(NA2+IBAS,IC))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C                                              ~
C     FOURTH CONTRACTION (SWAP): (JA;T|DB) -> (CA|DB)
      IF(IQ1.EQ.IQ2) GOTO 4200
C
C     LOOP OVER OCCUPIED STATES IOCCA AND IOCCC
      DO IOCCA=1,NUMO
        DO IOCCC=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCC
          IC = MINO-1+IOCCC+NSHIFT
C
C         LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
C
C             LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
              MDB = (IOCCB-1)*NUMO + IOCCD
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
              MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C             LIST ADDRESS FOR THIS IOCCC,IOCCA AND THE ABOVE MDB
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + MDB
C
C             LOOP OVER BASIS FUNCTIONS IN BLOCK B, CONTRACT OVER ACB2
              DO JBAS=1,NBAS(2)
C
C               (CA|DB) = (+A|DB) + (-A|DB)
                CADB(MCADB) = CADB(MCADB)
     &                      + ADB2(JBAS,MADB,1)*DCONJG(C(NB1+JBAS,IC))
     &                      + ADB2(JBAS,MADB,2)*DCONJG(C(NB2+JBAS,IC))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
4200  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN4 = TCN4 + T2 - T1
C
C     ALL CONTRIBUTIONS FROM THIS CLASS (A,B,C,D) NOW ACCOUNTED FOR
4000  CONTINUE
3001  CONTINUE
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER PAIR CORRELATION ENERGY FROM (CA|DB)      C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOR EACH IOCCA,IOCCB PAIR, SUM OVER IVRTR AND IVRTS CONTRIBUTIONS
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCA=1,NUMO
        DO IOCCC=1,NUMO
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTR,IOCCB,IVRTS
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + (IOCCB-1)*NUMO + IOCCD
C
              IF(IOCCA.EQ.IOCCC.AND.IOCCB.EQ.IOCCD) THEN
                EAB1(IOCCA,IOCCB,4) = DREAL(CADB(MCADB))
              ENDIF
              
              IF(IOCCB.EQ.IOCCC.AND.IOCCA.EQ.IOCCD) THEN
                EAB1(IOCCA,IOCCB,5) =-DREAL(CADB(MCADB))
              ENDIF
C
C             ADD TO DIRECT AND EXCHANGE BINS
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     FILL IN THE OTHER HALF OF THE ARRAY AND CALCULATE TOTALS
      E1D = 0.0D0
      E1X = 0.0D0
      E1S = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         INTERMEDIATE VALUES
          EAB1DIR = EAB1(IOCCA,IOCCB,4)
          EAB1XCH = EAB1(IOCCA,IOCCB,5)
          EAB1SUM = EAB1DIR + EAB1XCH
C
C         PUT THESE INTO EAB1 AND ADD CONTRIBUTION TO E1
          EAB1(IOCCA,IOCCB,6) = EAB1SUM
          IF(IOCCA.NE.IOCCB) THEN
            EAB1(IOCCB,IOCCA,4) = EAB1DIR
            EAB1(IOCCB,IOCCA,5) = EAB1XCH
            EAB1(IOCCB,IOCCA,6) = EAB1SUM
            E1D = E1D +       EAB1DIR
            E1X = E1X +       EAB1XCH
            E1S = E1S +       EAB1SUM
          ELSE
            E1D = E1D + 0.5D0*EAB1DIR
            E1X = E1X + 0.5D0*EAB1XCH
            E1S = E1S + 0.5D0*EAB1SUM
          ENDIF
        ENDDO
      ENDDO
C
C     WRITE RESULTS OF EAB ENERGIES TO AN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT1.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NUMO
        DO IOCCB=1,NUMO
          WRITE(8, *) (EAB1(IOCCA,IOCCB,N),N=1,6)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER SINGLE ORBITAL ENERGY                     C
C**********************************************************************C
C
C     FOR EACH IOCCA, SUM OVER THE IOCCB CONTRIBUTIONS
      DO IOCCA=1,NUMO
        DO N=1,6
          EA1(IOCCA,N) = 0.0D0
          DO IOCCB=1,NUMO
            EA1(IOCCA,N) = EA1(IOCCA,N) + EAB1(IOCCA,IOCCB,N)
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TSUM = TSUM + T2 - T1
C
C**********************************************************************C
C     TERMINAL OUTPUT SUMMARY                                          C
C**********************************************************************C
C
C     MBPT1 PAIRWISE SUMMARY
20    FORMAT(1X,A,9X,A,9X,A,9X,A,10X,A)
21    FORMAT(' (',I2,',',I2,')',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'MBPT1 pairwise summary'
      WRITE(7, *) REPEAT(' ',25),'MBPT1 pairwise summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) '( a, b)','E1H(ab)','E1J(ab)','E1K(ab)','E1G(ab)'
      WRITE(7,20) '( a, b)','E1H(ab)','E1J(ab)','E1K(ab)','E1G(ab)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        DO IOCCB=1,IOCCA
          IBNUM = IOCCB+MINO-1
          WRITE(6,21) IANUM,IBNUM,(EAB1(IOCCA,IOCCB,N),N=3,6)
          WRITE(7,21) IANUM,IBNUM,(EAB1(IOCCA,IOCCB,N),N=3,6)
        ENDDO
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 SINGLE-PARTICLE SUMMARY
30    FORMAT(1X,A,10X,A,10X,A,10X,A,10X,A)
31    FORMAT('  ',I2,'    ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',21),'MBPT1 single particle summary'
      WRITE(7, *) REPEAT(' ',21),'MBPT1 single particle summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) '  a    ','E1H(a)','E1J(a)','E1K(a)',' E1G(a)'
      WRITE(7,30) '  a    ','E1H(a)','E1J(a)','E1K(a)',' E1G(a)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        WRITE(6,31) IANUM,(EA1(IOCCA,N),N=3,6)
        WRITE(7,31) IANUM,(EA1(IOCCA,N),N=3,6)
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 TOTAL FIRST-ORDER INTERACTION
32    FORMAT(' total  ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',19),'MBPT1 first order molecular energy'
      WRITE(7, *) REPEAT(' ',19),'MBPT1 first order molecular energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,32) E1H,E1D,E1X,E1S
      WRITE(7,32) E1H,E1D,E1X,E1S
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 LABOUR ANALYSIS
      CALL CPU_TIME(TFIN)
      TTOT = TFIN - TBEG
      TOTH = TTOT - (T1EL + TERI + TCN1 + TCN2 + TSUM)

40    FORMAT(1X,A,15X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',26),'MBPT1 labour analysis'
      WRITE(7, *) REPEAT(' ',26),'MBPT1 labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6,40) 'One-body terms - EH(A,B)                 ',HMS(T1EL)
      WRITE(7,40) 'One-body terms - EH(A,B)                 ',HMS(T1EL)
      WRITE(6,40) 'ERI construction - (IJ|KL)               ',HMS(TERI)
      WRITE(7,40) 'ERI construction - (IJ|KL)               ',HMS(TERI)
      WRITE(6,40) '1st contraction  - (IJ|KB)               ',HMS(TCN1)
      WRITE(7,40) '1st contraction  - (IJ|KB)               ',HMS(TCN1)
      WRITE(6,40) '2nd contraction  - (IJ|BB) and (IJ|AB)   ',HMS(TCN2)
      WRITE(7,40) '2nd contraction  - (IJ|BB) and (IJ|AB)   ',HMS(TCN2)
      WRITE(6,40) '3rd contraction  - (IA|BB) and (IA|AB)   ',HMS(TCN3)
      WRITE(7,40) '3rd contraction  - (IA|BB) and (IA|AB)   ',HMS(TCN3)
      WRITE(6,40) '4th contraction  - (AA|BB) and (BA|AB)   ',HMS(TCN4)
      WRITE(7,40) '4th contraction  - (AA|BB) and (BA|AB)   ',HMS(TCN4)
      WRITE(6,40) 'Other                                    ',HMS(TOTH)
      WRITE(7,40) 'Other                                    ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,40) 'Total MBPT1 time                         ',HMS(TTOT)
      WRITE(7,40) 'Total MBPT1 time                         ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE MBPT2(MINO,NUMO,MINV,NUMV,G2INT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            MM       MM BBBBBBB  PPPPPPP TTTTTTTT 222222              C
C            MMM     MMM BB    BB PP    PP   TT   22    22             C
C            MMMM   MMMM BB    BB PP    PP   TT         22             C
C            MM MM MM MM BBBBBBB  PP    PP   TT       22               C
C            MM  MMM  MM BB    BB PPPPPPP    TT     22                 C
C            MM   M   MM BB    BB PP         TT   22                   C
C            MM       MM BBBBBBB  PP         TT   22222222             C
C                                                                      C
C -------------------------------------------------------------------- C
C  MBPT2 CALCULATES SECOND-ORDER PAIR CORRELATION CORRECTIONS OVER A   C
C  USER-SPECIFIED TWO-BODY OPERATOR. IT USES A RELATIVISTIC ADAPTION   C
C  OF THE DIRECT MP2 ALGORITHM OF HEAD-GORDON, POPLE AND FRISCH (1988).C
C  THIS IS NOT MOLLER-PLESSET PERTURBATION THEORY, SO CALL IT MBPT2.   C
C  ELECTRON REPULATION INTEGRALS ARE GENERATED ONCE, AT THE EXPENSE OF C
C  ADDITIONAL MEMORY STORAGE -- THEY ARE CONTRACTED IN FOUR STEPS.     C
C  THIS ALGORITHM EXPLOITS SYMMETRIES BETWEEN (A,B) AND (C,D) IN THE   C
C  INTEGRALS (AB|CD), BUT NOT THE SWAP (AB|CD)<->(CD|AB). STRUCTURE    C
C  MIMICS THAT OF 'COULOMB', BUT DOES NOT IMPLEMENT SELECTION RULES.   C
C  CONTRACTION ADDRESSES ARE CALCULATED EXPLICITLY RATHER THAN JUST    C
C  WITH UPDATING COUNTERS -- THIS IS TO GUIDE THE USER IN TRACKING.    C
C -------------------------------------------------------------------- C
C INPUT:                                                               C
C  MINO  - LOWEST OCCUPIED STATE TO ACCOUNT FOR. (FULL: 1)             C
C  NUMO  - NUMBER OF OCCUPIED STATES TO ACCOUNT FOR. (FULL: NOCC)      C
C  MINV  - LOWEST VIRTUAL STATE TO ACCOUNT FOR. (FULL: NOCC+1)         C
C  NUMV  - NUMBER OF VIRTUAL STATES TO ACCOUNT FOR. (FULL: NVRT)       C
C  G2INT - NAME OF TWO-BODY OPERATOR ('COULM' OR 'BREIT').             C
C -------------------------------------------------------------------- C
C NOTE: LOOP STRUCTURE NOT LIKE COULOMB -- MUST CONTRACT C AND D ASAP. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000)
C
      CHARACTER*4 HMLTN
      CHARACTER*5 G2INT
      CHARACTER*16 HMS
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-(MKP+1)/2:(MKP+1)/2,MKP)
      DIMENSION EAB2(NUMO,NUMO,6),EA2(NUMO,6)
C
      COMPLEX*16 C(MDM,MDM),RR(MB2,16)
      COMPLEX*16 B(MBS*NUMO,8),SB(MB2,NUMO*NUMV,4)
      COMPLEX*16 ASB1(MBS,NUMO*NUMO*NUMV,2),ASB2(MBS,NUMO*NUMO*NUMV,2)
      COMPLEX*16 RASB((NUMO+1)*NUMO*NUMV*NUMV/2)
C
      COMMON/COEF/C
      COMMON/EIGN/EIGEN(MDM)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      IERC = 0
C
C     WARNINGS BASED ON INVALID HMLTN VS. G2INT COMBINATIONS
      IF(G2INT.EQ.'COULM') THEN
        IF(HMLTN.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT2: HMLTN = BARE but G2INT = COULM.'
          WRITE(7, *) 'In MBPT2: HMLTN = BARE but G2INT = COULM.'
        ENDIF
      ELSEIF(G2INT.EQ.'BREIT') THEN
        IF(HMLTN.EQ.'NORL') THEN
          WRITE(6, *) 'In MBPT2: HMLTN = NORL but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLTN = NORL but G2INT = BREIT.'
          RETURN
        ELSEIF(HMLTN.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT2: HMLTN = BARE but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLTN = BARE but G2INT = BREIT.'
        ELSEIF(HMLTN.EQ.'DHFR') THEN
          WRITE(6, *) 'In MBPT2: HMLTN = DHFR but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLTN = DHFR but G2INT = BREIT.'
        ELSEIF(HMLTN.EQ.'DHFP') THEN
          WRITE(6, *) 'In MBPT2: HMLTN = DHFP but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLTN = DHFP but G2INT = BREIT.'
        ENDIF
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLTN.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLTN.EQ.'NORL') THEN
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 1
          ITSTOP = 1
          ITSKIP = 1
        ENDIF
      ELSE
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 4
          ITSTOP = 1
          ITSKIP =-3
        ELSEIF(G2INT.EQ.'BREIT') THEN
          ITSTRT = 2
          ITSTOP = 3
          ITSKIP = 1        
        ENDIF
      ENDIF
C
C     INITIALISE TIME COUNTERS
      TERI = 0.0D0
      TCN1 = 0.0D0
      TCN2 = 0.0D0
      TCN3 = 0.0D0
      TCN4 = 0.0D0
      TSUM = 0.0D0
C
      CALL CPU_TIME(TBEG)
C
C     IMPORT MBPT1 PAIR RESULTS FOR E1(ab)
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT1.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NUMO
        DO IOCCB=1,NUMO
          READ(8, *) Q1,Q2,Q3,(EAB2(IOCCA,IOCCB,N),N=1,3)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C     CLEAR THE REMAINDER OF THE CORRELATION PAIR ENERGY VALUES
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
          DO N=4,6
            EAB2(IOCCA,IOCCB,N) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     CLEAR THE ARRAY FOR (AR|BS) VALUES
      M = 0
      DO IVRTR=1,NUMV
        DO IOCCA=1,NUMO
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
              M = M+1
              RASB(M) = DCMPLX(0.0D0,0.0D0)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTERS
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTER
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KVALS(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS TT(AB) (USE INDEX 1000)       C
C**********************************************************************C
C
C     COMPONENT LABEL FOR A AND B: TT = LL(1) or SS(4) <- COULM
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 1000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSHIFT
        ENDIF
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF A (USE INDEX 2000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     INDEX ASSIGNMENT
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON A
      NA1 = LARGE(ICNTA,KA,2*MA-1) + NADDAB
      NA2 = LARGE(ICNTA,KA,2*MA  ) + NADDAB
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF B (USE INDEX 3000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTER B
      DO 3000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(B) VALUES
      DO 3000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1, NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     INDEX ASSIGNMENT
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON B
      NB1 = LARGE(ICNTB,KB,2*MB-1) + NADDAB
      NB2 = LARGE(ICNTB,KB,2*MB  ) + NADDAB
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
      IEAB = 1
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ1.LT.IQ2) GOTO 3001
C
C     CLEAR ARRAY FOR SECOND CONTRACTION (KL->SB)
      DO MSB=1,NUMO*NUMV
        DO MIJ=1,NBAS(1)*NBAS(2)
          DO IJSPIN=1,4
            SB(MIJ,MSB,IJSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) (INDEX 4000)               C
C**********************************************************************C
C
      DO 4000 IBAS=1,NBAS(1)
      DO 4000 JBAS=1,NBAS(2)
C
C     LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
      MIJ = (IBAS-1)*NBAS(2) + JBAS
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS TT(CD) (USE INDEX 5000)       C
C**********************************************************************C
C
C     COMPONENT LABEL FOR C AND D: TT = LL(1) or SS(4) <- COULM
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 5000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSHIFT
        ENDIF
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF C (USE INDEX 6000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTER C
      DO 6000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER C
        XYZ(1,3) = COORD(1,ICNTC)
        XYZ(2,3) = COORD(2,ICNTC)
        XYZ(3,3) = COORD(3,ICNTC)
C
C     LOOP OVER KQN(C) VALUES
      DO 6000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KVALS(KC,ICNTC)
        IF(KQN(3).GT.0) THEN
          LQN(3) = KQN(3)
        ELSE
          LQN(3) =-KQN(3)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFUNCT(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = EXPSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER |MQN(C)| VALUES
      DO 6000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     INDEX ASSIGNMENT
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON C
      NC1 = LARGE(ICNTC,KC,2*MC-1) + NADDCD
      NC2 = LARGE(ICNTC,KC,2*MC  ) + NADDCD
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (L->B)
      DO MKB=1,NBAS(3)*NUMO
        DO IJKSPIN=1,8
          B(MKB,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF D (USE INDEX 7000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTER D
      DO 7000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER D
        XYZ(1,4) = COORD(1,ICNTD)
        XYZ(2,4) = COORD(2,ICNTD)
        XYZ(3,4) = COORD(3,ICNTD)
C
C     LOOP OVER KQN(D) VALUES
      DO 7000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KVALS(KD,ICNTD)
        IF(KQN(4).GT.0) THEN
          LQN(4) = KQN(4)
        ELSE
          LQN(4) =-KQN(4)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFUNCT(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = EXPSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C     LOOP OVER |MQN(D)| VALUES
      DO 7000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     INDEX ASSIGNMENT
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON D
      ND1 = LARGE(ICNTD,KD,2*MD-1) + NADDCD
      ND2 = LARGE(ICNTD,KD,2*MD  ) + NADDCD
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C     FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
      IECD = 1
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     ALL LOOPS NOW COMPLETE -- GENERATE BATCH OF ERIs AND CONTRACT    C
C**********************************************************************C
C
C     RESET SCREENING COUNTERS
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
      ENDDO

C     BATCH OF ELECTRON INTERACTION INTEGRALS (IJ|KL) FOR FIXED (IJ)
      CALL CPU_TIME(T1)
      IF(G2INT.EQ.'COULM') THEN
        CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
      ELSEIF(G2INT.EQ.'BREIT') THEN
        CALL BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
      ENDIF
      CALL CPU_TIME(T2)
      TERI = TERI + T2 - T1
C
C**********************************************************************C
C     FIRST CONTRACTION:                                               C
C     (IJ;T|KL;T') -> (IJ;T|KB;T')  AND  (IJ;T|LK;T') -> (IJ;T|LB;T')  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FIRST CONTRACTION (DIRECT): (IJ;T|KL;T') -> (IJ;T|KB;T')
C
C     LOOP OVER BASIS FUNCTIONS IN BLOCK C AND OCCUPIED STATES IOCCB
      DO KBAS=1,NBAS(3)
        DO IOCCB=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCB
          IB = MINO-1+IOCCB+NSHIFT
C
C         LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
          MKB = (KBAS-1)*NUMO + IOCCB
C
C         CONTRACT OVER ALL LBAS IN BLOCK D
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|-B) = (--|--) + (--|-+)
            B(MKB,1) = B(MKB,1) + RR(M, 1)*C(ND1+LBAS,IB)
     &                          + RR(M, 2)*C(ND2+LBAS,IB)
C
C           (+-|-B) = (+-|--) + (+-|-+)
            B(MKB,2) = B(MKB,2) + RR(M, 9)*C(ND1+LBAS,IB)
     &                          + RR(M,10)*C(ND2+LBAS,IB)
C
C           (-+|-B) = (-+|--) + (-+|-+)
            B(MKB,3) = B(MKB,3) + RR(M, 5)*C(ND1+LBAS,IB)
     &                          + RR(M, 6)*C(ND2+LBAS,IB)
C
C           (++|-B) = (++|--) + (++|-+)
            B(MKB,4) = B(MKB,4) + RR(M,13)*C(ND1+LBAS,IB)
     &                          + RR(M,14)*C(ND2+LBAS,IB)
C
C           (--|+B) = (--|+-) + (--|++)
            B(MKB,5) = B(MKB,5) + RR(M, 3)*C(ND1+LBAS,IB)
     &                          + RR(M, 4)*C(ND2+LBAS,IB)
C
C           (+-|+B) = (+-|+-) + (+-|++)
            B(MKB,6) = B(MKB,6) + RR(M,11)*C(ND1+LBAS,IB)
     &                          + RR(M,12)*C(ND2+LBAS,IB)
C
C           (-+|+B) = (-+|+-) + (-+|++)
            B(MKB,7) = B(MKB,7) + RR(M, 7)*C(ND1+LBAS,IB)
     &                          + RR(M, 8)*C(ND2+LBAS,IB)
C
C           (++|+B) = (++|+-) + (++|++)
            B(MKB,8) = B(MKB,8) + RR(M,15)*C(ND1+LBAS,IB)
     &                          + RR(M,16)*C(ND2+LBAS,IB)
C
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TCN1 = TCN1 + T2 - T1
C
C     FIRST CONTRACTION COMPLETE FOR THIS (IBAS,JBAS) - END LOOP OVER D
7000  CONTINUE
C
C**********************************************************************C
C     SECOND CONTRACTION:                                              C
C     (IJ;T|KB;T') -> (IJ;T|SB)                                        C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     SECOND CONTRACTION (DIRECT): (IJ;T|KB;T') -> (IJ;T|SB;T')
C
C     LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
      DO IOCCB=1,NUMO
        DO IVRTS=1,NUMV
C
C         FOCK MATRIX ADDRESS FOR IVRTS
          IS = MINV-1+IVRTS+NSHIFT
C
C         LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION IN B1
          MSB = (IOCCB-1)*NUMV + IVRTS
C
C         CONTRACT OVER ALL KBAS IN BLOCK C
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
            MKB = (KBAS-1)*NUMO + IOCCB
C
C           (--|SB) = (--|-B) + (--|+B)
            SB(MIJ,MSB,1) = SB(MIJ,MSB,1)
     &                                + B(MKB,1)*DCONJG(C(NC1+KBAS,IS))
     &                                + B(MKB,5)*DCONJG(C(NC2+KBAS,IS))
C
C           (-+|SB) = (-+|-B) + (-+|+B)
            SB(MIJ,MSB,2) = SB(MIJ,MSB,2)
     &                                + B(MKB,3)*DCONJG(C(NC1+KBAS,IS))
     &                                + B(MKB,7)*DCONJG(C(NC2+KBAS,IS))
C
C           (+-|SB) = (+-|-B) + (+-|+B)
            SB(MIJ,MSB,3) = SB(MIJ,MSB,3)
     &                                + B(MKB,2)*DCONJG(C(NC1+KBAS,IS))
     &                                + B(MKB,6)*DCONJG(C(NC2+KBAS,IS))
C
C           (++|SB) = (++|-B) + (++|+B)
            SB(MIJ,MSB,4) = SB(MIJ,MSB,4)
     &                    + B(MKB,4)*DCONJG(C(NC1+KBAS,IS))
     &                    + B(MKB,8)*DCONJG(C(NC2+KBAS,IS))
C
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TCN2 = TCN2 + T2 - T1
C
C     SECOND CONTRACTION COMPLETE FOR THIS (IBAS,JBAS) - END LOOP OVER C
6000  CONTINUE
5000  CONTINUE
C
C     SECOND CONTRACTION COMPLETE FOR ALL (IBAS,JBAS)
4000  CONTINUE
C
C**********************************************************************C
C     THIRD CONTRACTION:                                               C
C     (IJ;T|SB) -> (IA;T|SB)  AND  (JI;T|SB) -> (JA;T|SB)              C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     THIRD CONTRACTION (DIRECT): (IJ;T|SB) -> (IA;T|SB)
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (DIRECT)
      DO MASB=1,NUMV*NUMO*NUMO
        DO IBAS=1,NBAS(1)
          DO ISPIN=1,2
            ASB1(IBAS,MASB,ISPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSHIFT
C
C       LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
        DO IOCCB=1,IOCCA
          DO IVRTS=1,NUMV
C
C           LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
            MSB = (IOCCB-1)*NUMV+IVRTS
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
            MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C           CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-A|SB) = (--|SB) + (-+|SB)
                ASB1(IBAS,MASB,1) = ASB1(IBAS,MASB,1)
     &                              +      SB(MIJ,MSB,1)*C(NB1+JBAS,IA)
     &                              +      SB(MIJ,MSB,2)*C(NB2+JBAS,IA)
C
C               (+A|SB) = (+-|SB) + (++|SB)
                ASB1(IBAS,MASB,2) = ASB1(IBAS,MASB,2)
     &                              +      SB(MIJ,MSB,3)*C(NB1+JBAS,IA)
     &                              +      SB(MIJ,MSB,4)*C(NB2+JBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     THIRD CONTRACTION (SWAP): (JI;T|SB) -> (JA;T|SB)
      IF(IQ1.EQ.IQ2) GOTO 4100
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (SWAP)
      DO MASB=1,NUMV*NUMO*NUMO
        DO JBAS=1,NBAS(2)
          DO JSPIN=1,2
            ASB2(JBAS,MASB,JSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSHIFT
C
C       LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
        DO IOCCB=1,IOCCA
          DO IVRTS=1,NUMV
C
C           LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
            MSB = (IOCCB-1)*NUMV+IVRTS
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
            MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C           CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (+A|SB) = PCD*{(+A|SB)} = PCD*{(++|SB) + (-+|SB)}
                ASB2(JBAS,MASB,1) = ASB2(JBAS,MASB,1)
     &                              + PAB1*SB(MIJ,MSB,4)*C(NA1+IBAS,IA)
     &                              + PAB2*SB(MIJ,MSB,2)*C(NA2+IBAS,IA)
C
C               (-A|SB) = PCD*{(-A|SB)} = PCD*{(+-|SB) + (--|SB)}
                ASB2(JBAS,MASB,2) = ASB2(JBAS,MASB,2)
     &                              + PAB2*SB(MIJ,MSB,3)*C(NA1+IBAS,IA)
     &                              + PAB1*SB(MIJ,MSB,1)*C(NA2+IBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ1 = IQ2
4100  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN3 = TCN3 + T2 - T1
C
C**********************************************************************C
C     FOURTH CONTRACTION:                      ~                       C
C     (IA;T|SB) -> (RA|SB)  AND  (JA;T|SB) -> (RA|SB)                  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOURTH CONTRACTION (DIRECT): (IA;T|SB) -> (RA|SB)
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESS FOR IVRTR
          IR = MINV-1+IVRTR+NSHIFT
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
C
C             LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
              MSB = (IOCCB-1)*NUMV + IVRTS
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
              MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C             LIST ADDRESS FOR THIS IVRTR,IOCCA AND THE ABOVE MSB
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTR-1)*NUMV*IOCCA + MSB
C
C             CONTRACT OVER ALL IBAS IN BLOCK A
              DO IBAS=1,NBAS(1)
C
C               (RA|SB) = (-A|SB) + (+A|SB)
                RASB(MRASB) = RASB(MRASB)
     &                       + ASB1(IBAS,MASB,1)*DCONJG(C(NA1+IBAS,IR))
     &                       + ASB1(IBAS,MASB,2)*DCONJG(C(NA2+IBAS,IR))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C                                              ~
C     FOURTH CONTRACTION (SWAP): (JA;T|SB) -> (RA|SB)
      IF(IQ1.EQ.IQ2) GOTO 4200
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESS FOR IVRTR
          IR = MINV-1+IVRTR+NSHIFT
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
C
C             LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
              MSB = (IOCCB-1)*NUMV+IVRTS
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
              MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C             LIST ADDRESS FOR THIS IVRTR,IOCCA AND THE ABOVE MSB
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTR-1)*NUMV*IOCCA + MSB
C
C             CONTRACT OVER ALL JBAS IN BLOCK B
              DO JBAS=1,NBAS(2)
C
C               (PA|SB) = (+A|SB) + (-A|SB)
                RASB(MRASB) = RASB(MRASB)
     &                       + ASB2(JBAS,MASB,1)*DCONJG(C(NB1+JBAS,IR))
     &                       + ASB2(JBAS,MASB,2)*DCONJG(C(NB2+JBAS,IR))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
4200  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN4 = TCN4 + T2 - T1
C
C     ALL CONTRIBUTIONS FROM THIS CLASS (A,B,C,D) NOW ACCOUNTED FOR
3001  CONTINUE
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER PAIR CORRELATION ENERGY                   C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOR EACH IOCCA,IOCCB PAIR, SUM OVER IVRTR AND IVRTS CONTRIBUTIONS
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESSES
          IA = MINO-1+IOCCA+NSHIFT
          IR = MINV-1+IVRTR+NSHIFT
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
C
C             FOCK MATRIX ADDRESSES
              IB = MINO-1+IOCCB+NSHIFT
              IS = MINV-1+IVRTS+NSHIFT
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTR,IOCCB,IVRTS
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTR-1)*NUMV*IOCCA + (IOCCB-1)*NUMV + IVRTS
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTS,IOCCB,IVRTR
              MSARB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTS-1)*NUMV*IOCCA + (IOCCB-1)*NUMV + IVRTR
C
C             NUMERATOR FOR DIRECT AND EXCHANGE CONTRIBUTIONS
              RNUMD = DREAL(RASB(MRASB)*DCONJG(RASB(MRASB)))
              RNUMX =-DREAL(RASB(MRASB)*DCONJG(RASB(MSARB)))
C
C             DENOMINATOR FOR BOTH CONTRIBUTIONS
              EABRS = EIGEN(IA) + EIGEN(IB) - EIGEN(IR) - EIGEN(IS)
C
C             ADD TO DIRECT AND EXCHANGE BINS
              EAB2(IOCCA,IOCCB,4) = EAB2(IOCCA,IOCCB,4) + RNUMD/EABRS
              EAB2(IOCCA,IOCCB,5) = EAB2(IOCCA,IOCCB,5) + RNUMX/EABRS
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     FILL IN THE OTHER HALF OF THE ARRAY AND CALCULATE TOTALS
      E1S = 0.0D0
      E2D = 0.0D0
      E2X = 0.0D0
      E2S = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         INTERMEDIATE VALUES
          EAB1TOT = EAB2(IOCCA,IOCCB,3)
          EAB2DIR = EAB2(IOCCA,IOCCB,4)
          EAB2XCH = EAB2(IOCCA,IOCCB,5)
          EAB2SUM = EAB2DIR + EAB2XCH
C
C         PUT THESE INTO EAB2 AND ADD CONTRIBUTION TO E2
          EAB2(IOCCA,IOCCB,6) = EAB2SUM
          IF(IOCCA.NE.IOCCB) THEN
            EAB2(IOCCB,IOCCA,3) = EAB1TOT
            EAB2(IOCCB,IOCCA,4) = EAB2DIR
            EAB2(IOCCB,IOCCA,5) = EAB2XCH
            EAB2(IOCCB,IOCCA,6) = EAB2SUM
            E1S = E1S +       EAB1TOT
            E2D = E2D +       EAB2DIR
            E2X = E2X +       EAB2XCH
            E2S = E2S +       EAB2SUM
          ELSE
            E1S = E1S + 0.5D0*EAB1TOT
            E2D = E2D + 0.5D0*EAB2DIR
            E2X = E2X + 0.5D0*EAB2XCH
            E2S = E2S + 0.5D0*EAB2SUM
          ENDIF
        ENDDO
      ENDDO
C
C     WRITE RESULTS OF EAB ENERGIES TO AN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT2.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NOCC
        DO IOCCB=1,NOCC
          WRITE(8, *) (EAB2(IOCCA,IOCCB,N),N=1,6)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER SINGLE ORBITAL ENERGY                     C
C**********************************************************************C
C
C     FOR EACH IOCCA, SUM OVER THE IOCCB CONTRIBUTIONS
      DO IOCCA=1,NUMO
        DO N=1,6
          EA2(IOCCA,N) = 0.0D0
          DO IOCCB=1,NUMO
            EA2(IOCCA,N) = EA2(IOCCA,N) + EAB2(IOCCA,IOCCB,N)
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TSUM = TSUM + T2 - T1
C
C**********************************************************************C
C     TERMINAL OUTPUT SUMMARY                                          C
C**********************************************************************C
C
C     MBPT2 PAIRWISE SUMMARY
20    FORMAT(1X,A,9X,A,9X,A,9X,A,9X,A)
21    FORMAT(' (',I2,',',I2,')',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'MBPT2 pairwise summary'
      WRITE(7, *) REPEAT(' ',25),'MBPT2 pairwise summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) '( a, b)','E1G(ab)','E2J(ab)','E2K(ab)','E2G(ab)'
      WRITE(7,20) '( a, b)','E1G(ab)','E2J(ab)','E2K(ab)','E2G(ab)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        DO IOCCB=1,IOCCA
          IBNUM = IOCCB+MINO-1
          WRITE(6,21) IANUM,IBNUM,(EAB2(IOCCA,IOCCB,N),N=3,6)
          WRITE(7,21) IANUM,IBNUM,(EAB2(IOCCA,IOCCB,N),N=3,6)
        ENDDO
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 SINGLE-PARTICLE SUMMARY
30    FORMAT(1X,A,10X,A,10X,A,10X,A,10X,A)
31    FORMAT('  ',I2,'    ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',21),'MBPT2 single particle summary'
      WRITE(7, *) REPEAT(' ',21),'MBPT2 single particle summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) '  a    ','E1G(a)','E2J(a)','E2K(a)',' E2G(a)'
      WRITE(7,30) '  a    ','E1G(a)','E2J(a)','E2K(a)',' E2G(a)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        WRITE(6,31) IANUM,(EA2(IOCCA,N),N=3,6)
        WRITE(7,31) IANUM,(EA2(IOCCA,N),N=3,6)
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 TOTAL SECOND ORDER CORRELATION ENERGY
32    FORMAT(' total  ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',17),'MBPT2 second order correlation energy'
      WRITE(7, *) REPEAT(' ',17),'MBPT2 second order correlation energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,32) E1S,E2D,E2X,E2S
      WRITE(7,32) E1S,E2D,E2X,E2S
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 LABOUR ANALYSIS
      CALL CPU_TIME(TFIN)
      TTOT = TFIN - TBEG
      TOTH = TTOT - (TERI + TCN1 + TCN2 + TCN3 + TCN4 + TSUM)

40    FORMAT(1X,A,24X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',26),'MBPT2 labour analysis'
      WRITE(7, *) REPEAT(' ',26),'MBPT2 labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6,40) 'ERI construction - (IJ|KL)      ',HMS(TERI)
      WRITE(7,40) 'ERI construction - (IJ|KL)      ',HMS(TERI)
      WRITE(6,40) '1st contraction  - (IJ|KB)      ',HMS(TCN1)
      WRITE(7,40) '1st contraction  - (IJ|KB)      ',HMS(TCN1)
      WRITE(6,40) '2nd contraction  - (IJ|SB)      ',HMS(TCN2)
      WRITE(7,40) '2nd contraction  - (IJ|SB)      ',HMS(TCN2)
      WRITE(6,40) '3rd contraction  - (IA|SB)      ',HMS(TCN3)
      WRITE(7,40) '3rd contraction  - (IA|SB)      ',HMS(TCN3)
      WRITE(6,40) '4th contraction  - (RA|SB)      ',HMS(TCN4)
      WRITE(7,40) '4th contraction  - (RA|SB)      ',HMS(TCN4)
      WRITE(6,40) 'Virtual orbital sum - E2(A,B)   ',HMS(TSUM)
      WRITE(7,40) 'Virtual orbital sum - E2(A,B)   ',HMS(TSUM)
      WRITE(6,40) 'Other                           ',HMS(TOTH)
      WRITE(7,40) 'Other                           ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,40) 'Total MBPT2 time                ',HMS(TTOT)
      WRITE(7,40) 'Total MBPT2 time                ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [9] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] PT1BODY: MAIN ROUTINE FOR MOLECULAR EXPECTATION VALUES.        C
C   [B] PROPRTY: MOLECULAR EXPECTATION VALUE FROM DENSITY MATRIX.      C
C   [B] RS1: SET OF 1ST ORDER MOLECULAR MATRIX ELEMENTS AND E(2).      C
C   [C] RS2: SET OF 2ND ORDER MOLECULAR MATRIX ELEMENTS AND E(3).      C
C -------------------------------------------------------------------- C
C   [D] MULLIKN: MULLIKEN POPULATION ANALYSIS ON CONVERGED SOLUTION.   C
C   [E] ELCMNPL: MOLECULAR ELECTRIC MONOPOLE MOMENT ANALYSIS.          C
C   [F] ELCDIPL: MOLECULAR ELECTRIC DIPOLE MOMENT ANALYSIS.            C
C   [G] ELCQDPL: MOLECULAR ELECTRIC QUADRUPOLE MOMENT ANALYSIS.        C
C   [H] MAGDIPL: MOLECULAR MAGNETIC DIPOLE MOMENT ANALYSIS.            C
C   [I] MAGQDPL: MOLECULAR MAGNETIC QUADRUPOLE MOMENT ANALYSIS.        C
C   [J] STRKEFF: STARK EFFECT ANALYSIS, GIVEN ELECTRIC FIELD E.        C
C   [K] ZMANEFF: ZEEMAN EFFECT ANALYSIS, GIVEN MAGNETIC FIELD B.       C
C   [L] GTENSOR: MAGNETIC G-TENSOR CALCULATION.                        C
C   [M] HYPFINE: HYPERFINE INTERACTION ANALYSIS, GIVEN NUCLEAR MOMENT. C
C   [K] EEDMSML: ATOM-CENTERED PT-ODD EDM OPERATOR (WITH E-FIELD).     C
C   [J] EEDMEFF: ONE-BODY EFFECTIVE PT-ODD EDM OPERATOR.               C
C   [N] SCLPTEN: SCALAR PT-ODD ELECTRON-NUCLEAR INTERACTION ANALYSIS.  C
C   [O] VECPTEN: VECTOR PT-ODD ELECTRON-NUCLEAR INTERACTION ANALYSIS.  C
C   [P] PVIOLTN: P-ODD EFFECTIVE OPERATOR ANALYSIS.                    C
C   [Q] BETADCY: CORRECTIONS DUE TO THE NUCLEAR DECAY OF A CENTER.     C
C -------------------------------------------------------------------- C
C   [R] VMNPOLE: BASIS MONOPOLE MOMENT MATRIX OVER SIGMA_Q.            C
C   [S] VDIPOLE: BASIS DIPOLE MOMENT MATRIX OVER SIGMA_Q AND IX.       C
C   [T] VQDPOLE: BASIS QUADRUPOLE MOMENT MATRIX OVER SIGMA_Q, IX, JX.  C
C   [U] VEFIELD: BASIS ELECTRIC FIELD MATRIX OVER SIGMA_Q AND IX.      C
C   [V] VKNETIC: BASIS RELATIVISTIC KINETIC OVERLAP MATRIX.            C
C   [W] VLPLACE: BASIS NON-RELATIVISTIC KINETIC OVERLAP MATRIX.        C
C   [X] VNCATRC: BASIS NUCLEAR ATTRACTION OVERLAP MATRIX.              C
C**********************************************************************C
C
C
      SUBROUTINE PT1BODY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      PPPPPPP TTTTTTTT  11  BBBBBBB   OOOOOO  DDDDDDD  YY    YY       C
C      PP    PP   TT    111  BB    BB OO    OO DD    DD YY    YY       C
C      PP    PP   TT     11  BB    BB OO    OO DD    DD  YY  YY        C
C      PP    PP   TT     11  BBBBBBB  OO    OO DD    DD   YYYY         C
C      PPPPPPP    TT     11  BB    BB OO    OO DD    DD    YY          C
C      PP         TT     11  BB    BB OO    OO DD    DD    YY          C
C      PP         TT    1111 BBBBBBB   OOOOOO  DDDDDDD     YY          C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  PT1BODY CALCULATES MATRIX ELEMENTS AND ENERGY CORRECTIONS GIVEN A   C
C  HARTREE-FOCK CALCULATION AND SET OF COEFFICIENTS AND ENERGIES.      C
C -------------------------------------------------------------------- C
C  EQFILE ONLY GENERATES ELL0, ESS0 AND MAYBE ELSI, AND IN GENERAL     C
C  THESE CALCULATIONS REQUIRE ETT'Q, SO GENERATE AS NEEDED INSTEAD.    C
C -------------------------------------------------------------------- C
C  BASIS OVERLAP MATRIX ELEMENTS AVAILABLE:                            C
C  (u,T|s_q|v,T')     - VMNPOLE(VIJ,IQ)      - DIRECT OVERLAP          C
C  (u,T|s.x|v,T')     - VDIPOLE(VIJ,IQ,IX)   - ELECTRIC DIPOLE MOMENT  C
C  (u,T|s.x.x'|v,T')  - VQDPOLE(VIJ,IQ,IX,JX)- ELECTRIC QUADRUPOLE     C
C  (u,T|s.x/r^3|v,T') - VEFIELD(VIJ,IQ,IX)   - E FIELD/B DIPOLE        C
C  (u,T|s.p|v,T')     - VKNETIC(VIJ)         - KINETIC                 C
C  (u,T|lap|v,T')     - VLPLACE(VIJ)         - NON-REL KINETIC         C
C  (u,T|nuc|v,T')     - VNCATRC(VIJ)         - NUCLEAR ATTRACTION      C
C**********************************************************************C
C
      CHARACTER*4  HMLTN
      CHARACTER*7  HMINT(10)
      CHARACTER*16 HMS
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/PT1B/NHMINT,HMINT
      COMMON/TPRP/EMTY
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     IF READING IN PREVIOUS SOLUTION, CALCULATE MOLECULAR DENSITY
      IF(INEW.EQ.1) THEN
        CALL DENSTY
      ENDIF
C
C     EQ-COEFF AND R-INT TIME INITIALISATION
      TELL = 0.0D0
      TESS = 0.0D0
      TELS = 0.0D0
C
C     LOOP OVER ALL REQUESTED INTERACTION HAMILTONIANS
      DO N=1,NHMINT

C       PRINT A TITLE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) 'One-body H_{int} = ',HMINT(N)
        WRITE(7, *) 'One-body H_{int} = ',HMINT(N)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
        IF(HMINT(N).EQ.'MULLIKN') THEN
          CALL MULLIKN(6)
        ELSEIF(HMINT(N).EQ.'ELCMNPL') THEN
          CALL ELCMNPL
        ELSEIF(HMINT(N).EQ.'ELCDIPL') THEN
          CALL ELCDIPL
        ELSEIF(HMINT(N).EQ.'ELCQDPL') THEN
          CALL ELCQDPL
        ELSEIF(HMINT(N).EQ.'MAGDIPL') THEN
          CALL MAGDIPL
        ELSEIF(HMINT(N).EQ.'MAGQDPL') THEN
          CALL MAGQDPL
        ELSEIF(HMINT(N).EQ.'STRKEFF') THEN
          CALL STRKEFF
        ELSEIF(HMINT(N).EQ.'ZMANEFF') THEN
          CALL ZMANEFF
        ELSEIF(HMINT(N).EQ.'GTENSOR') THEN
          CALL GTENSOR
        ELSEIF(HMINT(N).EQ.'HYPFINE') THEN
          CALL HYPFINE
        ELSEIF(HMINT(N).EQ.'EEDMSML') THEN
          CALL EEDMSML
        ELSEIF(HMINT(N).EQ.'EEDMEFF') THEN
          CALL EEDMEFF
        ELSEIF(HMINT(N).EQ.'SCLPTEN') THEN
          CALL SCLPTEN
        ELSEIF(HMINT(N).EQ.'VECPTEN') THEN
          CALL VECPTEN
        ELSEIF(HMINT(N).EQ.'PVIOLTN') THEN
          CALL PVIOLTN
        ELSEIF(HMINT(N).EQ.'BETADCY') THEN
          ICNT = 1
          ZDCY = 2.0D0
          CALL BETADCY(ICNT,ZDCY)
        ELSE
          WRITE(6, *) 'In PT1BODY: this operator is not available.'
          WRITE(7, *) 'In PT1BODY: this operator is not available.'
        ENDIF
C
C     END LOOP OVER INTERACTION HAMILTONIANS
      ENDDO
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TPRP)
      TPRP = TPRP-TDUM
C
20    FORMAT(1X,A,37X,A)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Time in EMAKE (LL):',HMS(TELL)
      WRITE(7,20) 'Time in EMAKE (LL):',HMS(TELL)
      WRITE(6,20) 'Time in EMAKE (SS):',HMS(TESS)
      WRITE(7,20) 'Time in EMAKE (SS):',HMS(TESS)
      WRITE(6,20) 'Time in EMAKE (LS):',HMS(TELS)
      WRITE(7,20) 'Time in EMAKE (LS):',HMS(TELS)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE PROPRTY(TOT,BLL,BSS,BLS,BSL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP  RRRRRRR   OOOOOO  PPPPPPP  RRRRRRR TTTTTTTT YY    YY    C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT    YY    YY    C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT     YY  YY     C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT      YYYY      C
C     PPPPPPP  RRRRRRR  OO    OO PPPPPPP  RRRRRRR    TT       YY       C
C     PP       RR    RR OO    OO PP       RR    RR   TT       YY       C
C     PP       RR    RR  OOOOOO  PP       RR    RR   TT       YY       C
C                                                                      C
C -------------------------------------------------------------------- C
C  PROPRTY CALCULATES A MOLECULAR EXPECTATION VALUE OVER THE DENSITY   C
C  MATRIX AND BASIS FUNCTION OVERLAPS IN THE B ARRAYS.                 C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 SUMLL,SUMSS,SUMLS,SUMSL,TOT
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 BLL(MDM,MDM),BSS(MDM,MDM),BLS(MDM,MDM),BSL(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE COUNTER ARRAYS FOR BASIS OVERLAP CONTRIBUTIONS
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      SUMLS = DCMPLX(0.0D0,0.0D0)
      SUMSL = DCMPLX(0.0D0,0.0D0)

C     LOOP OVER ALL BASIS FUNCTIONS
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          SUMLL = SUMLL + BLL(I,J)*DENT(I       ,J       )
          IF(HMLTN.EQ.'NORL') GOTO 100
          SUMSS = SUMSS + BSS(I,J)*DENT(I+NSHIFT,J+NSHIFT)
          SUMLS = SUMLS + BLS(I,J)*DENT(I       ,J+NSHIFT)
          SUMSL = SUMSL + BSL(I,J)*DENT(I+NSHIFT,J       )
100       CONTINUE
        ENDDO
      ENDDO
C
C     MOLECULAR EXPECTATION VALUE
      TOT = SUMLL + SUMSS + SUMLS + SUMSL
C
      RETURN
      END
C
C
      SUBROUTINE RS1(V1,E2,BLL,BSS,BLS,BSL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                        RRRRRRR   SSSSSS   11                         C
C                        RR    RR SS    SS 111                         C
C                        RR    RR SS        11                         C
C                        RR    RR  SSSSSS   11                         C
C                        RRRRRRR        SS  11                         C
C                        RR    RR SS    SS  11                         C
C                        RR    RR  SSSSSS  1111                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  RS1 ASSEMBLES AN ARRAY OF MOLECULAR MATRIX ELEMENTS FROM THE BASIS  C
C  FUNCTION OVERLAPS IN BTT BY FIRST-ORDER RAYLEIGH-SCHRODINGER THEORY.C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 SUMLL,SUMSS,SUMLS,SUMSL,TMP
      COMPLEX*16 C(MDM,MDM)
      COMPLEX*16 BLL(MDM,MDM),BSS(MDM,MDM),BLS(MDM,MDM),BSL(MDM,MDM)
      COMPLEX*16 V1(MDM,MDM),E2(MDM)
C
      COMMON/COEF/C
      COMMON/EIGN/EIGEN(MDM)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     TOLERANCE VALUE FOR VANISHING MATRIX ELEMENTS
      TOL = 1.0D-10
C
C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
      DO IOCC=1,NDIM
        DO JOCC=1,NDIM
C
C         INITIALISE COUNTER ARRAYS FOR BASIS OVERLAP CONTRIBUTIONS
          SUMLL = DCMPLX(0.0D0,0.0D0)
          SUMSS = DCMPLX(0.0D0,0.0D0)
          SUMLS = DCMPLX(0.0D0,0.0D0)
          SUMSL = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FOCK MATRIX ADDRESSES
          DO I=1,NDIM-NSHIFT
            DO J=1,NDIM-NSHIFT
C
              K = I+NSHIFT
              L = J+NSHIFT
C
C             LARGE AND SMALL CONTRIBUTIONS
              SUMLL = SUMLL + DCONJG(C(I,IOCC))*C(J,JOCC)*BLL(I,J)
              IF(HMLTN.EQ.'NORL') GOTO 100
              SUMSS = SUMSS + DCONJG(C(K,IOCC))*C(L,JOCC)*BSS(I,J)
              SUMLS = SUMLS + DCONJG(C(I,IOCC))*C(L,JOCC)*BLS(I,J)
              SUMSL = SUMSL + DCONJG(C(K,IOCC))*C(J,JOCC)*BSL(I,J)
100           CONTINUE
C
            ENDDO
          ENDDO
C
C         SAVE SUMS TO MATRIX
          V1(IOCC,JOCC) = SUMLL + SUMSS + SUMLS + SUMSL
C
C         VANISHING MATRIX ELEMENTS
          TMP1 = DREAL(V1(IOCC,JOCC))
          TMP2 = DIMAG(V1(IOCC,JOCC))
          IF(DABS(TMP1).LT.TOL) THEN
            TMP1 = 0.0D0
          ENDIF
          IF(DABS(TMP2).LT.TOL) THEN
            TMP2 = 0.0D0
          ENDIF
          V1(IOCC,JOCC) = DCMPLX(TMP1,TMP2)
C
        ENDDO
      ENDDO
C
C     CALCULATE ENERGY(2) CORRECTION FOR EACH ORBITAL
      DO IOCC=1,NDIM
        TMP = DCMPLX(0.0D0,0.0D0)
        DO JOCC=1,NDIM
          IF(JOCC.EQ.IOCC) GOTO 50
          IF(DABS(EIGEN(IOCC)-EIGEN(JOCC)).LT.1.0D-12) GOTO 50
          RN = DREAL(DCONJG(V1(IOCC,JOCC))*V1(IOCC,JOCC))
          RD = EIGEN(IOCC) - EIGEN(JOCC)
          TMP = TMP + RN/RD
50        CONTINUE
        ENDDO
        E2(IOCC) = TMP
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RS2(V1,V2,E3)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                      RRRRRRR   SSSSSS   222222                       C
C                      RR    RR SS    SS 22    22                      C
C                      RR    RR SS             22                      C
C                      RR    RR  SSSSSS      22                        C
C                      RRRRRRR        SS   22                          C
C                      RR    RR SS    SS 22                            C
C                      RR    RR  SSSSSS  22222222                      C
C                                                                      C
C -------------------------------------------------------------------- C
C  RS2 APPLIES 2ND ORDER RAYLEIGH-SCHRODINGER PERTURBATION THEORY TO A C
C  SET OF 1ST ORDER MATRIX ELEMENTS IN V1, AND OUTPUTS RESULTS TO V2.  C
C -------------------------------------------------------------------- C
C  DUE TO THE 2-FOLD MQN SYMMETRY, EITHER APPLY DEGENERATE RSPT OR     C
C  SIMPLY IGNORE THE RELEVANT PAIR ORBITAL.                            C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E3(MDM)
C
      COMMON/EIGN/EIGEN(MDM)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     TOLERANCE VALUE FOR VANISHING MATRIX ELEMENTS
      TOL = 1.0D-10
C
C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
      DO IOCC=1,NDIM
        DO JOCC=1,NDIM
C
C         APPLY 2ND ORDER RSPT
          V1(IOCC,JOCC) = DCMPLX(0.0D0,0.0D0)
C
C         VANISHING MATRIX ELEMENTS
          TMP1 = DREAL(V2(IOCC,JOCC))
          TMP2 = DIMAG(V2(IOCC,JOCC))
          IF(DABS(TMP1).LT.TOL) THEN
            TMP1 = 0.0D0
          ENDIF
          IF(DABS(TMP2).LT.TOL) THEN
            TMP2 = 0.0D0
          ENDIF
          V2(IOCC,JOCC) = DCMPLX(TMP1,TMP2)
C
        ENDDO
      ENDDO
C
C     THIRD ORDER ENERGY CORRECTION
      DO IOCC=1,NDIM
        E3(IOCC) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MULLIKN(IVIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM UU    UU LL       LL       IIII KK    KK NN    NN    C
C     MMM     MMM UU    UU LL       LL        II  KK   KK  NNN   NN    C
C     MMMM   MMMM UU    UU LL       LL        II  KK  KK   NNNN  NN    C
C     MM MM MM MM UU    UU LL       LL        II  KKKKK    NN NN NN    C
C     MM  MMM  MM UU    UU LL       LL        II  KK  KK   NN  NNNN    C
C     MM   M   MM UU    UU LL       LL        II  KK   KK  NN   NNN    C
C     MM       MM  UUUUUU  LLLLLLLL LLLLLLLL IIII KK    KK NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  MULLIKN CALCULATES A MULLIKEN POPULATION ANALYSIS ON A DIATOMIC     C
C  SYSTEM, AS DESCRIBED IN:                                            C
C  (*) J.Chem.Phys., 23: 1833, 1841, 2338, 2343 (1955).                C
C  (*) J.Chem.Phys., 36: 3428 (1962).                                  C
C -------------------------------------------------------------------- C
C  CONTRIBUTIONS FOR EACH ORBITAL ARE GROUPED BY ATOMIC CENTER, KQN    C
C  SYMMETRY AND MQN. ANY CHARGE DENSITY OTHER THAN THIS IS IN 'BRD'.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE IN LIST.             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*2 ELMNT(120),ELA
      CHARACTER*4 HMLTN
C
      DIMENSION FRC(MDM,MCT,MKP,(MKP+1)/2,3)
      DIMENSION BRD(MDM,3),TOT(MDM,3),RHO(MCT,3)
C
      COMPLEX*16 C(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/MDLV/ELMNT
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE COUNTER MATRICES
      DO IOCC=1,NOCC+IVIR
        DO ICNT=1,NCNT
          DO IKAP=1,NKAP(ICNT)
            IKQN = KVALS(IKAP,ICNT)
            NMV  = IABS(IKQN)
            DO IMV=1,NMV
              DO IT=1,3
                FRC(IOCC,ICNT,IKAP,IMV,IT) = 0.0D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO IT=1,3
          BRD(IOCC,IT) = 0.0D0
          TOT(IOCC,IT) = 0.0D0
        ENDDO
      ENDDO
      DO ICNT=1,NCNT
        DO IT=1,3
          RHO(ICNT,IT) = 0.0D0
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRICES
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     LOOP OVER OCCUPIED ORBITALS
      DO IOCC=1,NOCC+IVIR
C
C       IGNORE NEGATIVE SPECTRUM
        MOCC = IOCC + NSHIFT
C
C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
        DO I=1,NDIM-NSHIFT
          IS = I+NSHIFT
          ICNT = LABICN(I)
          IKQN = LABKQN(I)
          IMQN = IABS(LABMQN(I))
          IF(IKQN.LT.0) THEN
            IKAP =-2*IKQN-1
          ELSE
            IKAP = 2*IKQN
          ENDIF
          IMV = (IMQN+1)/2
          DO J=1,NDIM-NSHIFT
            JS = J+NSHIFT
            JCNT = LABICN(J)
            JKQN = LABKQN(J)
            JMQN = IABS(LABMQN(J))
C
C           LARGE AND SMALL CONTRIBUTIONS
            EL = DREAL(DCONJG(C(I ,MOCC))*C(J ,MOCC)*OLAPLL(I,J))
            ES = DREAL(DCONJG(C(IS,MOCC))*C(JS,MOCC)*OLAPSS(I,J))
C
C           UPDATE CHARGE ON CENTER ICNT (OCCUPIED ORBITALS ONLY)
            IF(IOCC.LE.NOCC) THEN
              RHO(ICNT,1) = RHO(ICNT,1) + EL
              RHO(ICNT,2) = RHO(ICNT,2) + ES
              RHO(ICNT,3) = RHO(ICNT,3) + EL + ES
            ENDIF

C           DECIDE WHERE TO PUT CONTRIBUTION
            IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
              FRC(IOCC,ICNT,IKAP,IMV,1) = FRC(IOCC,ICNT,IKAP,IMV,1) + EL
              FRC(IOCC,ICNT,IKAP,IMV,2) = FRC(IOCC,ICNT,IKAP,IMV,2) + ES
              FRC(IOCC,ICNT,IKAP,IMV,3) = FRC(IOCC,ICNT,IKAP,IMV,1)
     &                                  + FRC(IOCC,ICNT,IKAP,IMV,2)
            ELSE
              BRD(IOCC,1) = BRD(IOCC,1) + EL
              BRD(IOCC,2) = BRD(IOCC,2) + ES
              BRD(IOCC,3) = BRD(IOCC,3) + EL + ES
            ENDIF
C
          ENDDO
C
        ENDDO
C
C       TOTAL OCCUPANCIES
        DO ICNT=1,NCNT
            DO IKAP=1,NKAP(ICNT)
              IKQN = KVALS(IKAP,ICNT)
              NMV  = IABS(IKQN)
              DO IMV=1,NMV
                TOT(IOCC,1) = TOT(IOCC,1) + FRC(IOCC,ICNT,IKAP,IMV,1)
                TOT(IOCC,2) = TOT(IOCC,2) + FRC(IOCC,ICNT,IKAP,IMV,2)
                TOT(IOCC,3) = TOT(IOCC,3) + FRC(IOCC,ICNT,IKAP,IMV,3)
              ENDDO
            ENDDO
        ENDDO
        TOT(IOCC,1) = TOT(IOCC,1) + BRD(IOCC,1)
        TOT(IOCC,2) = TOT(IOCC,2) + BRD(IOCC,2)
        TOT(IOCC,3) = TOT(IOCC,3) + BRD(IOCC,3)
C
C     END LOOP OVER OCCUPIED ORBITALS
      ENDDO
C
C     RESULTS: CHARGES ON EACH CENTER
20    FORMAT(1X,'Total charge on center ',I2,' = ',F15.10)
21    FORMAT(1X,'Total charge on molecule  = ',F15.10)
      WRITE(6, *) 'Mulliken population analysis:'
      WRITE(7, *) 'Mulliken population analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      SUM = 0.0D0
      DO ICNT=1,NCNT
        WRITE(6,20) ICNT,ZNUC(ICNT)-RHO(ICNT,3)
        WRITE(7,20) ICNT,ZNUC(ICNT)-RHO(ICNT,3)
        SUM = SUM + ZNUC(ICNT)-RHO(ICNT,3)
      ENDDO
      WRITE(6,21) SUM
      WRITE(7,21) SUM
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     RESULTS: DIRAC BASIS DECOMPOSITION FOR EACH ORBITAL
22    FORMAT(' Orb.',2X,'Cent.',2X,'KQN',3X,'|MQN|',10X,
     &                                   'Q(L)',13X,'Q(S)',11X,'Q(TOT)')
23    FORMAT(1X,I3,2X,I2,'(',A,')',3X,I2,3X,I2,'/2',4X,F11.8,6X,
     &                                                   F11.8,6X,F11.8)
24    FORMAT(1X,I3,3X,I2,'(',A,')',2X,I2,3X,I2,'/2',4X,F11.8,6X,
     &                                                   F11.8,6X,F11.8)
25    FORMAT(1X,I3,3X,A ,15X,F11.8,6X,F11.8,6X,F11.8)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6,22)
      WRITE(7,22)
      DO IOCC=1,NOCC+IVIR
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        IF(IOCC.EQ.NOCC+1) THEN
          WRITE(6, *) 'Virtual orbitals (not actually occupied):'
          WRITE(7, *) 'Virtual orbitals (not actually occupied):'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF
        DO ICNT=1,NCNT
          ELA = ELMNT(IZNUC(ICNT))
          DO IKAP=1,NKAP(ICNT)
            IKQN = KVALS(IKAP,ICNT)
            NMV  = IABS(IKQN)
            DO IMV=1,NMV
              IF(FRC(IOCC,ICNT,IKAP,IMV,3).GT.1.0D-9) THEN
                IF(NCNT.LT.10) THEN
                  WRITE(6,23) IOCC,ICNT,ELA,KVALS(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                  WRITE(7,23) IOCC,ICNT,ELA,KVALS(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                ELSE
                  WRITE(6,24) IOCC,ICNT,ELA,KVALS(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                  WRITE(7,24) IOCC,ICNT,ELA,KVALS(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                ENDIF
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        WRITE(6,25) IOCC,'Polar.',(BRD(IOCC,IT),IT=1,3)
        WRITE(7,25) IOCC,'Polar.',(BRD(IOCC,IT),IT=1,3)
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,25) IOCC,'Total ',(TOT(IOCC,IT),IT=1,3)
        WRITE(7,25) IOCC,'Total ',(TOT(IOCC,IT),IT=1,3)
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ELCMNPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE LL       CCCCCC  MM       MM NN    NN PPPPPPP  LL         C
C   EE       LL      CC    CC MMM     MMM NNN   NN PP    PP LL         C
C   EE       LL      CC       MMMM   MMMM NNNN  NN PP    PP LL         C
C   EEEEEE   LL      CC       MM MM MM MM NN NN NN PP    PP LL         C
C   EE       LL      CC       MM  MMM  MM NN  NNNN PPPPPPP  LL         C
C   EE       LL      CC    CC MM   M   MM NN   NNN PP       LL         C
C   EEEEEEEE LLLLLLLL CCCCCC  MM       MM NN    NN PP       LLLLLLLL   C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCMNPL PERFORMS A DIRECT OVERLAP ANALYSIS.                         C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'Direct overlap analysis:'
      WRITE(7, *) 'Direct overlap analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Occupation number = ',DREAL(E1)
      WRITE(7,20) 'Occupation number = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCMNPL_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCMNPL_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE ELCDIPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       EEEEEEEE LL       CCCCCC  DDDDDDD IIII PPPPPPP  LL             C
C       EE       LL      CC    CC DD    DD II  PP    PP LL             C
C       EE       LL      CC       DD    DD II  PP    PP LL             C
C       EEEEEE   LL      CC       DD    DD II  PP    PP LL             C
C       EE       LL      CC       DD    DD II  PPPPPPP  LL             C
C       EE       LL      CC    CC DD    DD II  PP       LL             C
C       EEEEEEEE LLLLLLLL CCCCCC  DDDDDDD IIII PP       LLLLLLLL       C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCDIPL PERFORMS A MOLECULAR ELECTRIC DIPOLE ANALYSIS.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 EX1,EY1,EZ1
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM),
     &           VX2(MDM,MDM),VY2(MDM,MDM),VZ2(MDM,MDM),
     &           EX2(MDM),EY2(MDM),EZ2(MDM),EX3(MDM),EY3(MDM),EZ3(MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM),
     &           EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE ELECTRIC DIPOLE BASIS FUNCTION OVERLAPS
      CALL VDIPOLE(DXLL,1,1,1,1,2)
      CALL VDIPOLE(DYLL,1,2,2,1,2)
      CALL VDIPOLE(DZLL,1,3,3,1,2)
C
      CALL VDIPOLE(DXSS,4,1,1,1,2)
      CALL VDIPOLE(DYSS,4,2,2,1,2)
      CALL VDIPOLE(DZSS,4,3,3,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(EX1,DXLL,DXSS,EMPTY,EMPTY)
      CALL PROPRTY(EY1,DYLL,DYSS,EMPTY,EMPTY)
      CALL PROPRTY(EZ1,DZLL,DZSS,EMPTY,EMPTY)
C
      RMUX = 0.5D0*(ZNUC(2)-ZNUC(1))*(COORD(1,2)-COORD(1,1))-DREAL(EX1)
      RMUY = 0.5D0*(ZNUC(2)-ZNUC(1))*(COORD(2,2)-COORD(2,1))-DREAL(EY1)
      RMUZ = 0.5D0*(ZNUC(2)-ZNUC(1))*(COORD(3,2)-COORD(3,1))-DREAL(EZ1)
      RMUX = RMUX*0.529D0*4.8D0
      RMUY = RMUY*0.529D0*4.8D0
      RMUZ = RMUZ*0.529D0*4.8D0
C
      WRITE(6, *) 'Electric dipole moment overlap analysis:'
      WRITE(7, *) 'Electric dipole moment overlap analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,3X,'(',F13.8,',',F13.8,',',F13.8,')')
      WRITE(6,20) 'Dipole moment = ',DREAL(EX1),DREAL(EY1),DREAL(EZ1)
      WRITE(7,20) 'Dipole moment = ',DREAL(EX1),DREAL(EY1),DREAL(EZ1)
      WRITE(6,20) 'Debye units   = ',RMUX,RMUY,RMUZ
      WRITE(7,20) 'Debye units   = ',RMUX,RMUY,RMUZ
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(VX1,EX2,DXLL,DXSS,EMPTY,EMPTY)
      CALL RS1(VY1,EY2,DYLL,DYSS,EMPTY,EMPTY)
      CALL RS1(VZ1,EZ2,DZLL,DZSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_ELCDIPL_X1.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_ELCDIPL_Y1.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_ELCDIPL_Z1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) EX2(IOCC),(VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) EY2(IOCC),(VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) EZ2(IOCC),(VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(VX1,VX2,EX3)
      CALL RS2(VY1,VY2,EY3)
      CALL RS2(VZ1,VZ2,EZ3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_ELCDIPL_X2.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_ELCDIPL_Y2.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_ELCDIPL_Z2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) EX3(IOCC),(VX2(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) EY3(IOCC),(VY2(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) EZ3(IOCC),(VZ2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
      RETURN
      END
C
C
      SUBROUTINE ELCQDPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    EEEEEEEE LL       CCCCCC   QQQQQQ   DDDDDDD  PPPPPPP  LL          C
C    EE       LL      CC    CC QQ    QQ  DD    DD PP    PP LL          C
C    EE       LL      CC       QQ    QQ  DD    DD PP    PP LL          C
C    EEEEEE   LL      CC       QQ    QQ  DD    DD PP    PP LL          C
C    EE       LL      CC       QQ   QQQ  DD    DD PPPPPPP  LL          C
C    EE       LL      CC    CC QQ    QQ  DD    DD PP       LL          C
C    EEEEEEEE LLLLLLLL CCCCCC   QQQQQQ Q DDDDDDD  PP       LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCQDPL PERFORMS A MOLECULAR ELECTRIC QUADRUPOLE ANALYSIS.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM),C(MDM,MDM)
      COMPLEX*16 QXXLL(MDM,MDM),QYYLL(MDM,MDM),QZZLL(MDM,MDM),
     &           QXYLL(MDM,MDM),QYZLL(MDM,MDM),QZXLL(MDM,MDM),
     &           QXXSS(MDM,MDM),QYYSS(MDM,MDM),QZZSS(MDM,MDM),
     &           QXYSS(MDM,MDM),QYZSS(MDM,MDM),QZXSS(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     GENERATE ELECTRIC QUADRUPOLE OVERLAPS
      CALL VQDPOLE(QXXLL,1,0,1,1,1,2)
      CALL VQDPOLE(QYYLL,1,0,2,2,1,2)
      CALL VQDPOLE(QZZLL,1,0,3,3,1,2)
      CALL VQDPOLE(QXYLL,1,0,1,2,1,2)
      CALL VQDPOLE(QYZLL,1,0,2,3,1,2)
      CALL VQDPOLE(QZXLL,1,0,3,1,1,2)
C
      CALL VQDPOLE(QXXSS,4,0,1,1,1,2)
      CALL VQDPOLE(QYYSS,4,0,2,2,1,2)
      CALL VQDPOLE(QZZSS,4,0,3,3,1,2)
      CALL VQDPOLE(QXYSS,4,0,1,2,1,2)
      CALL VQDPOLE(QYZSS,4,0,2,3,1,2)
      CALL VQDPOLE(QZXSS,4,0,3,1,1,2)
C
      RETURN
      END
C
C
      SUBROUTINE MAGDIPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM    AA     GGGGGG  DDDDDDD IIII PPPPPPP  LL           C
C     MMM     MMM   AAAA   GG    GG DD    DD II  PP    PP LL           C
C     MMMM   MMMM  AA  AA  GG       DD    DD II  PP    PP LL           C
C     MM MM MM MM AA    AA GG       DD    DD II  PP    PP LL           C
C     MM  MMM  MM AAAAAAAA GG   GGG DD    DD II  PPPPPPP  LL           C
C     MM   M   MM AA    AA GG    GG DD    DD II  PP       LL           C
C     MM       MM AA    AA  GGGGGG  DDDDDDD IIII PP       LLLLLLLL     C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGDIPL PERFORMS A MOLECULAR MAGNETIC DIPOLE ANALYSIS.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM),C(MDM,MDM)
      COMPLEX*16 DPXLL(MDM,MDM),DPYLL(MDM,MDM),DPZLL(MDM,MDM),
     &           DPXSS(MDM,MDM),DPYSS(MDM,MDM),DPZSS(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     GENERATE MAGNETIC DIPOLE OVERLAPS
      CALL VDIPOLE(DPXLL,1,1,2,1,2)
      CALL VDIPOLE(DPYLL,1,2,3,1,2)
      CALL VDIPOLE(DPZLL,1,3,1,1,2)
C
      CALL VDIPOLE(DPXLL,4,1,2,1,2)
      CALL VDIPOLE(DPYLL,4,2,3,1,2)
      CALL VDIPOLE(DPZLL,4,3,1,1,2)
C
      RETURN
      END
C
C
      SUBROUTINE MAGQDPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  MM       MM    AA     GGGGGG   QQQQQQ   DDDDDDD  PPPPPPP  LL        C
C  MMM     MMM   AAAA   GG    GG QQ    QQ  DD    DD PP    PP LL        C
C  MMMM   MMMM  AA  AA  GG       QQ    QQ  DD    DD PP    PP LL        C
C  MM MM MM MM AA    AA GG       QQ    QQ  DD    DD PP    PP LL        C
C  MM  MMM  MM AAAAAAAA GG   GGG QQ   QQQ  DD    DD PPPPPPP  LL        C
C  MM   M   MM AA    AA GG    GG QQ    QQ  DD    DD PP       LL        C
C  MM       MM AA    AA  GGGGGG   QQQQQQ Q DDDDDDD  PP       LLLLLLLL  C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGQDPL PERFORMS A MOLECULAR MAGNETIC QUADRUPOLE ANALYSIS.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM),C(MDM,MDM)
      COMPLEX*16 QXXLL(MDM,MDM),QYYLL(MDM,MDM),QZZLL(MDM,MDM),
     &           QXYLL(MDM,MDM),QYZLL(MDM,MDM),QZXLL(MDM,MDM),
     &           QXXSS(MDM,MDM),QYYSS(MDM,MDM),QZZSS(MDM,MDM),
     &           QXYSS(MDM,MDM),QYZSS(MDM,MDM),QZXSS(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     GENERATE MAGNETIC QUADRUPOLE OVERLAPS
      CALL VQDPOLE(QXXLL,1,0,1,1,1,2)
      CALL VQDPOLE(QYYLL,1,0,2,2,1,2)
      CALL VQDPOLE(QZZLL,1,0,3,3,1,2)
      CALL VQDPOLE(QXYLL,1,0,1,2,1,2)
      CALL VQDPOLE(QYZLL,1,0,2,3,1,2)
      CALL VQDPOLE(QZXLL,1,0,3,1,1,2)
C
      CALL VQDPOLE(QXXSS,4,0,1,1,1,2)
      CALL VQDPOLE(QYYSS,4,0,2,2,1,2)
      CALL VQDPOLE(QZZSS,4,0,3,3,1,2)
      CALL VQDPOLE(QXYSS,4,0,1,2,1,2)
      CALL VQDPOLE(QYZSS,4,0,2,3,1,2)
      CALL VQDPOLE(QZXSS,4,0,3,1,1,2)
C
      RETURN
      END
C
C
      SUBROUTINE STRKEFF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS TTTTTTTT RRRRRRR  KK    KK EEEEEEEE FFFFFFFF FFFFFFFF    C
C     SS    SS   TT    RR    RR KK   KK  EE       FF       FF          C
C     SS         TT    RR    RR KK  KK   EE       FF       FF          C
C      SSSSSS    TT    RR    RR KKKKK    EEEEEE   FFFFFF   FFFFFF      C
C           SS   TT    RRRRRRR  KK  KK   EE       FF       FF          C
C     SS    SS   TT    RR    RR KK   KK  EE       FF       FF          C
C      SSSSSS    TT    RR    RR KK    KK EEEEEEEE FF       FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  STRKEFF PERFORMS A STARK EFFECT ANALYSIS, GIVEN APPLIED ELECTRIC    C
C  FIELD (EX,EY,EZ).                                                   C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'Stark effect analysis:'
      WRITE(7, *) 'Stark effect analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_STRKEFF_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_STRKEFF_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE ZMANEFF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   ZZZZZZZZ MM       MM    AA    NN    NN EEEEEEEE FFFFFFFF FFFFFFFF  C
C        ZZ  MMM     MMM   AAAA   NNN   NN EE       FF       FF        C
C       ZZ   MMMM   MMMM  AA  AA  NNNN  NN EE       FF       FF        C
C      ZZ    MM MM MM MM AA    AA NN NN NN EEEEEE   FFFFFF   FFFFFF    C
C     ZZ     MM  MMM  MM AAAAAAAA NN  NNNN EE       FF       FF        C
C    ZZ      MM   M   MM AA    AA NN   NNN EE       FF       FF        C
C   ZZZZZZZZ MM       MM AA    AA NN    NN EEEEEEEE FF       FF        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZMANEFF PERFORMS A ZEEMAN EFFECT ANALYSIS, GIVEN APPLIED MAGNETIC   C
C  FIELD (BX,BY,BZ).                                                   C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'Zeeman effect analysis:'
      WRITE(7, *) 'Zeeman effect analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ZMANEFF_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ZMANEFF_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE GTENSOR
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     GGGGGG TTTTTTTT EEEEEEEE NN    NN  SSSSSS   OOOOOO  RRRRRRR      C
C    GG    GG   TT    EE       NNN   NN SS    SS OO    OO RR    RR     C
C    GG         TT    EE       NNNN  NN SS       OO    OO RR    RR     C
C    GG         TT    EEEEEE   NN NN NN  SSSSSS  OO    OO RR    RR     C
C    GG   GGG   TT    EE       NN  NNNN       SS OO    OO RRRRRRR      C
C    GG    GG   TT    EE       NN   NNN SS    SS OO    OO RR    RR     C
C     GGGGGG    TT    EEEEEEEE NN    NN  SSSSSS   OOOOOO  RR    RR     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GTENSOR CALCULATES THE MAGNETIC G-TENSOR OF A MOLECULE.             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'G-tensor analysis:'
      WRITE(7, *) 'G-tensor analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_GTENSOR_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_GTENSOR_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE HYPFINE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      HH    HH YY    YY PPPPPPP  FFFFFFFF IIII NN    NN EEEEEEEE      C
C      HH    HH YY    YY PP    PP FF        II  NNN   NN EE            C
C      HH    HH YY    YY PP    PP FF        II  NNNN  NN EE            C
C      HHHHHHHH  YY  YY  PP    PP FFFFFF    II  NN NN NN EEEEEE        C
C      HH    HH   YYYY   PPPPPPP  FF        II  NN  NNNN EE            C
C      HH    HH    YY    PP       FF        II  NN   NNN EE            C
C      HH    HH    YY    PP       FF       IIII NN    NN EEEEEEEE      C
C                                                                      C
C -------------------------------------------------------------------- C
C  HYPFINE PERFORMS A HYPERFINE EFFECT ANALYSIS, GIVEN A MAGNETIC      C
C  NUCLEAR MOMENT.                                                     C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'Hyperfine interaction analysis:'
      WRITE(7, *) 'Hyperfine interaction analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_HYPFINE_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_HYPFINE_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE EEDMSML
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C EEEEEEEE EEEEEEEE DDDDDDD  MM       MM  SSSSSS  MM       MM LL       C
C EE       EE       DD    DD MMM     MMM SS    SS MMM     MMM LL       C
C EE       EE       DD    DD MMMM   MMMM SS       MMMM   MMMM LL       C
C EEEEEE   EEEEEE   DD    DD MM MM MM MM  SSSSSS  MM MM MM MM LL       C
C EE       EE       DD    DD MM  MMM  MM       SS MM  MMM  MM LL       C
C EE       EE       DD    DD MM   M   MM SS    SS MM   M   MM LL       C
C EEEEEEEE EEEEEEEE DDDDDDD  MM       MM  SSSSSS  MM       MM LLLLLLLL C
C                                                                      C
C -------------------------------------------------------------------- C
C  EEDMSML PERFORMS AN ATOM-CENTERED PT-ODD ELECTRON EDM ANALYSIS,     C
C  USING THE SMALL-SMALL OVERLAP AND ELECTRIC FIELD OPERATOR.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'Atom-centered PT-odd EDM operator analysis:'
      WRITE(7, *) 'Atom-centered PT-odd EDM operator analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_EEDMSML_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_EEDMSML_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE EEDMEFF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE EEEEEEEE DDDDDDD  MM       MM EEEEEEEE FFFFFFFF FFFFFFFF  C
C   EE       EE       DD    DD MMM     MMM EE       FF       FF        C
C   EE       EE       DD    DD MMMM   MMMM EE       FF       FF        C
C   EEEEEE   EEEEEE   DD    DD MM MM MM MM EEEEEE   FFFFFF   FFFFFF    C
C   EE       EE       DD    DD MM  MMM  MM EE       FF       FF        C
C   EE       EE       DD    DD MM   M   MM EE       FF       FF        C
C   EEEEEEEE EEEEEEEE DDDDDDD  MM       MM EEEEEEEE FF       FF        C
C                                                                      C
C -------------------------------------------------------------------- C
C  EEDMEFF PERFORMS ONE-BODY EFFECTIVE ELECTRON EDM ANALYSIS.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'One-body effective PT-odd EDM operator analysis:'
      WRITE(7, *) 'One-body effective PT-odd EDM operator analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_EEDMEFF_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_EEDMEFF_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE SCLPTEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS   CCCCCC  LL       PPPPPPP TTTTTTTT EEEEEEEE NN    NN    C
C     SS    SS CC    CC LL       PP    PP   TT    EE       NNN   NN    C
C     SS       CC       LL       PP    PP   TT    EE       NNNN  NN    C
C      SSSSSS  CC       LL       PP    PP   TT    EEEEEE   NN NN NN    C
C           SS CC       LL       PPPPPPP    TT    EE       NN  NNNN    C
C     SS    SS CC    CC LL       PP         TT    EE       NN   NNN    C
C      SSSSSS   CCCCCC  LLLLLLLL PP         TT    EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  SCLPTEN SCALAR PT-ODD ELECTRON-NUCLEUS INTERACTION ANALYSIS.        C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'Scalar PT-odd electron-nuclear operator analysis:'
      WRITE(7, *) 'Scalar PT-odd electron-nuclear operator analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_SCLPTEN_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_SCLPTEN_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE VECPTEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV EEEEEEEE  CCCCCC  PPPPPPP TTTTTTTT EEEEEEEE NN    NN     C
C    VV    VV EE       CC    CC PP    PP   TT    EE       NNN   NN     C
C    VV    VV EE       CC       PP    PP   TT    EE       NNNN  NN     C
C    VV    VV EEEEEE   CC       PP    PP   TT    EEEEEE   NN NN NN     C
C     VV  VV  EE       CC       PPPPPPP    TT    EE       NN  NNNN     C
C      VVVV   EE       CC    CC PP         TT    EE       NN   NNN     C
C       VV    EEEEEEEE  CCCCCC  PP         TT    EEEEEEEE NN    NN     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VECPTEN VECTOR PT-ODD ELECTRON-NUCLEUS INTERACTION ANALYSIS.        C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'Vector PT-odd electron-nuclear operator analysis:'
      WRITE(7, *) 'Vector PT-odd electron-nuclear operator analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_VECPTEN_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_VECPTEN_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE PVIOLTN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       PPPPPPP  VV    VV IIII OOOOOO  LL      TTTTTTTT NN    NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NNN   NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NNNN  NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NN NN NN       C
C       PPPPPPP   VV  VV   II OO    OO LL         TT    NN  NNNN       C
C       PP         VVVV    II OO    OO LL         TT    NN   NNN       C
C       PP          VV    IIII OOOOOO  LLLLLLLL   TT    NN    NN       C
C                                                                      C
C -------------------------------------------------------------------- C
C  PVIOLTN PERFORMS A P-PODD EFFECTIVE OPERATOR ANALYSIS.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VMNPOLE(OLAPLL,1,0,1,2)
      CALL VMNPOLE(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'P-odd effective operator analysis:'
      WRITE(7, *) 'P-odd effective operator analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1)
      WRITE(7,20) 'Molecular property = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,OLAPLL,OLAPSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PVIOLTN_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PVIOLTN_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE BETADCY(ICNT,ZDCY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     BBBBBBB  EEEEEEEE TTTTTTTT   AA    DDDDDDD   CCCCCC  YY    YY    C
C     BB    BB EE          TT     AAAA   DD    DD CC    CC YY    YY    C
C     BB    BB EE          TT    AA  AA  DD    DD CC        YY  YY     C
C     BBBBBBB  EEEEEE      TT   AA    AA DD    DD CC         YYYY      C
C     BB    BB EE          TT   AAAAAAAA DD    DD CC          YY       C
C     BB    BB EE          TT   AA    AA DD    DD CC    CC    YY       C
C     BBBBBBB  EEEEEEEE    TT   AA    AA DDDDDDD   CCCCCC     YY       C
C                                                                      C
C -------------------------------------------------------------------- C
C  BETADCY TAKES THE RADIOACTIVE DECAY PROCESS IN WHICH ATOMIC CENTER  C
C  ICNT LOSES AN AMOUNT OF CHARGE ZDCY, AND PERFORMS AN ANALYSIS.      C
C -------------------------------------------------------------------- C
C  AT A FIRST PASS, GENERATE ONLY NUCLEAR ATTRACTION MATRIX ELEMENTS   C
C  DUE TO THE NEW CHARGE ON CENTER ICNT AND DON'T CHANGE ANY RADII.    C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION XYZ(3)
C
      COMPLEX*16 E1
      COMPLEX*16 V1(MDM,MDM),V2(MDM,MDM),E2(MDM),E3(MDM)
      COMPLEX*16 VNUCLL(MDM,MDM),VNUCSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     ADJUST NUCLEAR CHARGE OF CENTER ICNT
      DO IX=1,3
        XYZ(IX) = COORD(IX,ICNT)
      ENDDO
C
C     NEW NUCLEAR CHARGE OF DECAYED CENTER
      ZNEW = ZNUC(ICNT)-ZDCY
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
C     DFNOTE: THIS ACTUALLY GENERATES MATRIX ELEMENTS FOR ALL ATOMIC
C             CENTERS IN THE MOLECULE. MIGHT BE WORTH CALCULATING
C             MATRIX ELEMENTS OVER ICNT FROM SCRATCH HERE INSTEAD.
      CALL VNCATRC(VNUCLL,1,0,1,2)
      CALL VNCATRC(VNUCSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,VNUCLL,VNUCSS,EMPTY,EMPTY)
C
      WRITE(6, *) 'Direct overlap analysis:'
      WRITE(7, *) 'Direct overlap analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE ENERGY DIFFERENCE EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Energy difference = ',DREAL(E1)
      WRITE(7,20) 'Energy difference = ',DREAL(E1)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RS1(V1,E2,VNUCLL,VNUCSS,EMPTY,EMPTY)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_BETADCY_1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E2(IOCC),(V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     SECOND ORDER INTERACTION ELEMENTS
      CALL RS2(V1,V2,E3)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_BETADCY_2.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) E3(IOCC),(V2(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE VMNPOLE(VIJ,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  VV    VV MM       MM NN    NN PPPPPPP   OOOOOO  LL       EEEEEEEE   C
C  VV    VV MMM     MMM NNN   NN PP    PP OO    OO LL       EE         C
C  VV    VV MMMM   MMMM NNNN  NN PP    PP OO    OO LL       EE         C
C  VV    VV MM MM MM MM NN NN NN PP    PP OO    OO LL       EEEEEE     C
C   VV  VV  MM  MMM  MM NN  NNNN PPPPPPP  OO    OO LL       EE         C
C    VVVV   MM   M   MM NN   NNN PP       OO    OO LL       EE         C
C     VV    MM       MM NN    NN PP        OOOOOO  LLLLLLLL EEEEEEEE   C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMNPOLE CONSTRUCTS A MATRIX OF (u,T|SIG_Q|v,T') OVERLAP INTEGRALS   C
C  OVER ALL BASIS FUNCTION PAIRS, AND SAVES THE RESULT TO VIJ.         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4 HMLTN
C
      COMPLEX*16 TMP(MBS,MBS,4)
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM),STR(MDM,MDM)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSHIFT
        DO J=1,NDIM-NSHIFT
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CONDITION
      IF(HMLTN.EQ.'NORL'.AND.ITT.GT.1) GOTO 100
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     IMPLEMENT ANY AVAILABLE SELECTION RULES HERE                     C
C**********************************************************************C
C
C     SELECTION RULES TO BE MADE BASED ON GEOMETRIC SYMMETRY,
C     ATOMIC COORDINATES AND QUANTUM NUMBER PAIRS. THE IDEA IS TO
C     SKIP CALCULATIONS THAT SHOULD PRODUCE NO OR NEGLIGIBLE EFFECT.
      IF(NCNT.LE.2) THEN
        IF(MQN(1).NE.MQN(2)) GOTO 2000
      ENDIF
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS           C
C     OF (MA,MB). FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE          C
C     ORDERED                                                          C
C     11: = (-|MQN(A)|,-|MQN(B)|)                                      C
C     12: = (-|MQN(A)|,+|MQN(B)|)                                      C
C     21: = (+|MQN(A)|,-|MQN(B)|)                                      C
C     22: = (+|MQN(A)|,+|MQN(B)|)                                      C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LARGE(ICNTA,KA,MJA  )
      IL2 = LARGE(ICNTA,KA,MJA+1)
      JL1 = LARGE(ICNTB,KB,MJB  )
      JL2 = LARGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      FASE = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXM = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELLQ COEFFICIENTS (IPHS = +1)
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL + TDM2 - TDM1
C     GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS + TDM2 - TDM1
C     GENERATE ELS1 COEFFICIENTS
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS + TDM2 - TDM1
      ELSE
        WRITE(6, *) 'In OVERLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In OVERLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ    = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT  = DSQRT(PI/EIJ)**3
          TMP(IBAS,JBAS,1) = EROOT*E11(M,1)
          TMP(IBAS,JBAS,3) = EROOT*E21(M,1)
          TMP(IBAS,JBAS,2) =-FASE*DCONJG(TMP(IBAS,JBAS,3))
          TMP(IBAS,JBAS,4) = FASE*DCONJG(TMP(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF THE OVERLAP MATRIX FOR THIS BLOCK OF   C
C     BASIS FUNCTIONS -- NOW OVERLAY THE RESULTS INTO VIJ.             C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LARGE(ICNTA,KA,MJA  )
      IL2 = LARGE(ICNTA,KA,MJA+1)
      JL1 = LARGE(ICNTB,KB,MJB  )
      JL2 = LARGE(ICNTB,KB,MJB+1)
C
C     ASSEMBLE TEMPORARY BLOCK INTO OVERLAP ARRAY
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VIJ(IL1+IBAS,JL1+JBAS) = TMP(IBAS,JBAS,1)
            VIJ(IL1+IBAS,JL2+JBAS) = TMP(IBAS,JBAS,2)
            VIJ(IL2+IBAS,JL1+JBAS) = TMP(IBAS,JBAS,3)
            VIJ(IL2+IBAS,JL2+JBAS) = TMP(IBAS,JBAS,4)
            VIJ(JL1+JBAS,IL1+IBAS) = DCONJG(VIJ(IL1+IBAS,JL1+JBAS))
            VIJ(JL2+JBAS,IL1+IBAS) = DCONJG(VIJ(IL1+IBAS,JL2+JBAS))
            VIJ(JL1+JBAS,IL2+IBAS) = DCONJG(VIJ(IL2+IBAS,JL1+JBAS))
            VIJ(JL2+JBAS,IL2+IBAS) = DCONJG(VIJ(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VIJ(IL1+IBAS,JL1+JBAS) = TMP(IBAS,JBAS,1)
            VIJ(IL1+IBAS,JL2+JBAS) = TMP(IBAS,JBAS,2)
            VIJ(IL2+IBAS,JL1+JBAS) = TMP(IBAS,JBAS,3)
            VIJ(IL2+IBAS,JL2+JBAS) = TMP(IBAS,JBAS,4)
            VIJ(JL1+JBAS,IL1+IBAS) = DCONJG(VIJ(IL1+IBAS,JL1+JBAS))
            VIJ(JL2+JBAS,IL1+IBAS) = DCONJG(VIJ(IL1+IBAS,JL2+JBAS))
            VIJ(JL1+JBAS,IL2+IBAS) = DCONJG(VIJ(IL2+IBAS,JL1+JBAS))
            VIJ(JL2+JBAS,IL2+IBAS) = DCONJG(VIJ(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
2000  CONTINUE
C
C     ESLQ[MU,NU;T,U,V] = ELSQ[NU,MU;T,U,V]*.
      IF(ITT.EQ.3) THEN
C       TRANSFER ITT=2 VIJ CASE TO A STORAGE ARRAY
        DO I=1,NDIM-NSHIFT
          DO J=1,NDIM-NSHIFT
            STR(I,J) = VIJ(I,J)
          ENDDO
        ENDDO
C       TRANSPOSE AND COMPLEX CONJUGATE
        DO I=1,NDIM-NSHIFT
          DO J=1,NDIM-NSHIFT
            VIJ(I,J) = DCONJG(STR(J,I))
          ENDDO
        ENDDO
      ENDIF
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VDIPOLE(VIJ,ITT,IQ,IX,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       VV    VV DDDDDDD IIII PPPPPPP   OOOOOO  LL      EEEEEEEE       C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EE             C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EE             C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EEEEEE         C
C        VV  VV  DD    DD II  PPPPPPP  OO    OO LL      EE             C
C         VVVV   DD    DD II  PP       OO    OO LL      EE             C
C          VV    DDDDDDD IIII PP        OOOOOO  LLLLLLL EEEEEEEE       C
C                                                                      C
C -------------------------------------------------------------------- C
C  VDIPOLE CONSTRUCTS A MATRIX OF (u,T|SIG_Q.X|v,T') OVERLAP INTEGRALS C
C  OVER ALL BASIS FUNCTION PAIRS, AND SAVES THE RESULT TO VIJ.         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    IX    = {1,2,3}   -> {X,Y,Z} CARTESIAN WEIGHTING FACTOR.          C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION RC(MB2,MRC),APH(MB2),CP(MB2,3),PNC(MB2)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CONDITION
      IF(HMLTN.EQ.'NORL'.AND.ITT.GT.1) GOTO 100
C
C     CENTER OF MASS COORDINATES
      CX = 0.0D0
      CY = 0.0D0
      CZ = 0.0D0
      CM = 0.0D0
      DO N=1,NCNT
        CX = CX + AMASS(N)*COORD(1,N)
        CY = CY + AMASS(N)*COORD(2,N)
        CZ = CZ + AMASS(N)*COORD(3,N)
        CM = CM + AMASS(N)
      ENDDO
      CX = CX/CM
      CY = CY/CM
      CZ = CZ/CM
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2)=KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO IBAS=1,NBAS(2)
          EXPT(IBAS,2) = EXPSET(IBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS           C
C     OF (MA,MB). FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE          C
C     ORDERED                                                          C
C     11: = (-|MQN(A)|,-|MQN(B)|)                                      C
C     12: = (-|MQN(A)|,+|MQN(B)|)                                      C
C     21: = (+|MQN(A)|,-|MQN(B)|)                                      C
C     22: = (+|MQN(A)|,+|MQN(B)|)                                      C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      FASE = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXM = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL + TDM2 - TDM1
C
C     GAUSSIAN OVERLAP CENTERS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
          PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
          PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
          PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
          CP(M,1) = PX - CX
          CP(M,2) = PY - CY
          CP(M,3) = PZ - CZ
        ENDDO
      ENDDO
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
C
C     BEGIN AN IF STATEMENT FOR LQN PAIRS
C     IF ONE OR MORE OF THE LQNS IS NONZERO
      IF(NTUVLL.GT.1) THEN
        IADR1 = NTUVLL-1
        IADR2 = NTUVLL
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            EIJ    = EXPT(IBAS,1)+EXPT(JBAS,2)
            EROOT  = DSQRT(PI/EIJ)**3
            SLL(IBAS,JBAS,1) = EROOT*(E11(M,IADR1)+CP(M,3)*E11(M,IADR2))
            SLL(IBAS,JBAS,3) = EROOT*(E21(M,IADR1)+CP(M,3)*E21(M,IADR2))
            SLL(IBAS,JBAS,2) =-FASE*DCONJG(SLL(IBAS,JBAS,3))
            SLL(IBAS,JBAS,4) = FASE*DCONJG(SLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
C     IF BOTH LQNS ARE ZERO
      ELSE
        IADR2 = NTUVLL
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            EIJ    = EXPT(IBAS,1)+EXPT(JBAS,2)
            EROOT  = DSQRT(PI/EIJ)**3
            SLL(IBAS,JBAS,1) = EROOT*CP(M,3)*E11(M,IADR2)
            SLL(IBAS,JBAS,3) = EROOT*CP(M,3)*E21(M,IADR2)
            SLL(IBAS,JBAS,2) =-FASE*DCONJG(SLL(IBAS,JBAS,3))
            SLL(IBAS,JBAS,4) = FASE*DCONJG(SLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
C     END IF STATEMENT OVER LQN PAIRS
      ENDIF
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS + TDM2 - TDM1
C
C     GAUSSIAN OVERLAP CENTERS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
          PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
          PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
          PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
          CP(M,1) = PX - CX
          CP(M,2) = PY - CY
          CP(M,3) = PZ - CZ
        ENDDO
      ENDDO
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
C
C     BEGIN AN IF STATEMENT FOR LQN PAIRS
C     IF ONE OR MORE OF THE LQNS IS NONZERO
      IF(NTUVSS.GT.1) THEN
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            IADR1 = NTUVSS-1
            IADR2 = NTUVSS
            M = M+1
            EIJ     = EXPT(IBAS,1)+EXPT(JBAS,2)
            EROOT   = DSQRT(PI/EIJ)**3
            SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
            SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
            SSS(IBAS,JBAS,2) =-FASE*DCONJG(SSS(IBAS,JBAS,3))
            SSS(IBAS,JBAS,4) = FASE*DCONJG(SSS(IBAS,JBAS,1))
          ENDDO
        ENDDO
C     IF BOTH LQNS ARE ZERO
      ELSE
        IADR2 = NTUVSS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            EIJ    = EXPT(IBAS,1)+EXPT(JBAS,2)
            EROOT  = DSQRT(PI/EIJ)**3
            SLL(IBAS,JBAS,1) = EROOT*(E11(M,IADR1)+CP(M,3)*E11(M,IADR2))
            SLL(IBAS,JBAS,3) = EROOT*(E21(M,IADR1)+CP(M,3)*E21(M,IADR2))
            SLL(IBAS,JBAS,2) =-FASE*DCONJG(SLL(IBAS,JBAS,3))
            SLL(IBAS,JBAS,4) = FASE*DCONJG(SLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
C     END IF STATEMENT OVER LQN PAIRS
      ENDIF
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF THE OVERLAP MATRIX FOR THIS BLOCK OF   C
C     BASIS FUNCTIONS -- NOW OVERLAY THE RESULTS INTO VIJ.             C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LARGE(ICNTA,KA,MJA  )
      IL2 = LARGE(ICNTA,KA,MJA+1)
      JL1 = LARGE(ICNTB,KB,MJB  )
      JL2 = LARGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1 + NSHIFT
      IS2 = IL2 + NSHIFT
      JS1 = JL1 + NSHIFT
      JS2 = JL2 + NSHIFT
C
C     LL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VIJ(IL1+IBAS,JL1+JBAS) = SLL(IBAS,J,1)
            VIJ(IL1+IBAS,JL2+JBAS) = SLL(IBAS,J,2)
            VIJ(IL2+IBAS,JL1+JBAS) = SLL(IBAS,J,3)
            VIJ(IL2+IBAS,JL2+JBAS) = SLL(IBAS,J,4)
            VIJ(JL1+JBAS,IL1+IBAS) = DCONJG(VIJ(IL1+IBAS,JL1+JBAS))
            VIJ(JL2+JBAS,IL1+IBAS) = DCONJG(VIJ(IL1+IBAS,JL2+JBAS))
            VIJ(JL1+JBAS,IL2+IBAS) = DCONJG(VIJ(IL2+IBAS,JL1+JBAS))
            VIJ(JL2+JBAS,IL2+IBAS) = DCONJG(VIJ(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VIJ(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            VIJ(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            VIJ(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            VIJ(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            VIJ(JL1+JBAS,IL1+IBAS) = DCONJG(VIJ(IL1+IBAS,JL1+JBAS))
            VIJ(JL2+JBAS,IL1+IBAS) = DCONJG(VIJ(IL1+IBAS,JL2+JBAS))
            VIJ(JL1+JBAS,IL2+IBAS) = DCONJG(VIJ(IL2+IBAS,JL1+JBAS))
            VIJ(JL2+JBAS,IL2+IBAS) = DCONJG(VIJ(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SS BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VIJ(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            VIJ(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            VIJ(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            VIJ(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            VIJ(JS1+JBAS,IS1+IBAS) = DCONJG(VIJ(IS1+IBAS,JS1+JBAS))
            VIJ(JS2+JBAS,IS1+IBAS) = DCONJG(VIJ(IS1+IBAS,JS2+JBAS))
            VIJ(JS1+JBAS,IS2+IBAS) = DCONJG(VIJ(IS2+IBAS,JS1+JBAS))
            VIJ(JS2+JBAS,IS2+IBAS) = DCONJG(VIJ(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=J,NBAS(1)
            VIJ(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            VIJ(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            VIJ(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            VIJ(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            VIJ(JS1+JBAS,IS1+IBAS) = DCONJG(VIJ(IS1+IBAS,JS1+JBAS))
            VIJ(JS2+JBAS,IS1+IBAS) = DCONJG(VIJ(IS1+IBAS,JS2+JBAS))
            VIJ(JS1+JBAS,IS2+IBAS) = DCONJG(VIJ(IS2+IBAS,JS1+JBAS))
            VIJ(JS2+JBAS,IS2+IBAS) = DCONJG(VIJ(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
2000  CONTINUE
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VQDPOLE(VIJ,ITT,IQ,IX,JX,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV  QQQQQQ   DDDDDDD  PPPPPPP   OOOOOO  LL      EEEEEEEE    C
C    VV    VV QQ    QQ  DD    DD PP    PP OO    OO LL      EE          C
C    VV    VV QQ    QQ  DD    DD PP    PP OO    OO LL      EE          C
C    VV    VV QQ    QQ  DD    DD PP    PP OO    OO LL      EEEEEE      C
C     VV  VV  QQ   QQQ  DD    DD PPPPPPP  OO    OO LL      EE          C
C      VVVV   QQ    QQ  DD    DD PP       OO    OO LL      EE          C
C       VV     QQQQQQ Q DDDDDDD  PP        OOOOOO  LLLLLLL EEEEEEEE    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VQDPOLE CONSTRUCTS A MATRIX OF (u,T|SIG_Q.X.X'|v,T') OVERLAP        C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    IX    = {1,2,3}   -> {X,Y,Z} FIRST CARTESIAN WEIGHTING FACTOR.    C
C    JX    = {1,2,3}   -> {X,Y,Z} SECOND CARTESIAN WEIGHTING FACTOR.   C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CONDITION
      IF(HMLTN.EQ.'NORL'.AND.ITT.GT.1) GOTO 100
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VEFIELD(VIJ,ITT,IQ,IX,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      VV    VV EEEEEEEE FFFFFFFF IIII EEEEEEEE LL       DDDDDDD       C
C      VV    VV EE       FF        II  EE       LL       DD    DD      C
C      VV    VV EE       FF        II  EE       LL       DD    DD      C
C      VV    VV EEEEEE   FFFFFF    II  EEEEEE   LL       DD    DD      C
C       VV  VV  EE       FF        II  EE       LL       DD    DD      C
C        VVVV   EE       FF        II  EE       LL       DD    DD      C
C         VV    EEEEEEEE FF       IIII EEEEEEEE LLLLLLLL DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  VEFIELD CONSTRUCTS A MATRIX OF (u,T|SIG.X/R^3|v,T') OVERLAP         C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    IX    = {1,2,3}   -> {X,Y,Z} CARTESIAN WEIGHTING FACTOR.          C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CONDITION
      IF(HMLTN.EQ.'NORL'.AND.ITT.GT.1) GOTO 100
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VKNETIC(VIJ,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      VV    VV KK    KK NN    NN EEEEEEEE TTTTTTTT IIII CCCCCC        C
C      VV    VV KK   KK  NNN   NN EE          TT     II CC    CC       C
C      VV    VV KK  KK   NNNN  NN EE          TT     II CC             C
C      VV    VV KKKKK    NN NN NN EEEEEE      TT     II CC             C
C       VV  VV  KK  KK   NN  NNNN EE          TT     II CC             C
C        VVVV   KK   KK  NN   NNN EE          TT     II CC    CC       C
C         VV    KK    KK NN    NN EEEEEEEE    TT    IIII CCCCCC        C
C                                                                      C
C -------------------------------------------------------------------- C
C  VKNETIC CONSTRUCTS A MATRIX OF (u,T|SIG.X|v,T') OVERLAP             C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CONDITION
      IF(HMLTN.EQ.'NORL'.AND.ITT.GT.1) GOTO 100
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VLPLACE(VIJ,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV LL       PPPPPPP  LL          AA     CCCCCC  EEEEEEEE    C
C    VV    VV LL       PP    PP LL         AAAA   CC    CC EE          C
C    VV    VV LL       PP    PP LL        AA  AA  CC       EE          C
C    VV    VV LL       PP    PP LL       AA    AA CC       EEEEEE      C
C     VV  VV  LL       PPPPPPP  LL       AAAAAAAA CC       EE          C
C      VVVV   LL       PP       LL       AA    AA CC    CC EE          C
C       VV    LLLLLLLL PP       LLLLLLLL AA    AA  CCCCCC  EEEEEEEE    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VLPLACE CONSTRUCTS A MATRIX OF (u,T|GRAD^2|v,T') OVERLAP            C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CONDITION
      IF(HMLTN.EQ.'NORL'.AND.ITT.GT.1) GOTO 100
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VNCATRC(VIJ,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC     AA   TTTTTTTT RRRRRRR   CCCCCC      C
C    VV    VV NNN   NN CC    CC   AAAA     TT    RR    RR CC    CC     C
C    VV    VV NNNN  NN CC        AA  AA    TT    RR    RR CC           C
C    VV    VV NN NN NN CC       AA    AA   TT    RR    RR CC           C
C     VV  VV  NN  NNNN CC       AAAAAAAA   TT    RRRRRRR  CC           C
C      VVVV   NN   NNN CC    CC AA    AA   TT    RR    RR CC    CC     C
C       VV    NN    NN  CCCCCC  AA    AA   TT    RR    RR  CCCCCC      C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCATRC CONSTRUCTS A MATRIX OF (u,T|nuc|v,T') OVERLAP               C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CONDITION
      IF(HMLTN.EQ.'NORL'.AND.ITT.GT.1) GOTO 100
C
100   CONTINUE
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [10] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] FIELDS: CALCULATE AMPLITUDES, FIELDS AND POTENTIALS.           C
C   [B] ARRYPLT: EXPORT ARRAY TO EXTERNAL DATA FILE AND PLOT.          C
C   [C] ORBCOEF: PRINT LIST OF EXPANSION COEFFICIENTS FOR AN ORBITAL.  C
C   [D] AMPLTDE: PLOT A DIRAC SPINOR AMPLITUDE ALONG ONE DIRECTION.    C
C   [E] J4EQSUM: PLOT 4-CURRENT ALONG ONE DIRECTION FOR ORBITAL PAIR.  C
C   [F] J4DIRCT: PLOT 4-CURRENT ALONG ONE DIRECTION FOR ORBITAL PAIR.  C
C   [G] POTENTL: PLOT 4-POTENTIAL ALONG ONE DIRECTION FOR ORBITAL PAIR.C
C   [H] ELCTRCF: PLOT E FIELD ALONG ONE DIRECTION FOR ORBITAL PAIR.    C
C   [I] MAGNTCF: PLOT B FIELD ALONG ONE DIRECTION FOR ORBITAL PAIR.    C
C   [J] GNUMAKE: GENERATE A GNUPLOT MAKE FILE FOR A DATA SET.          C
C   [K] CLEBSCH: CLEBSCH-GORDON COEFFICIENT FOR KQN,MQN.               C
C   [L] SPHHRM: VALUE OF Y_L^M AT TWO GIVEN ANGLES.                    C
C   [M] PLGNDR: RETURNS AN ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).    C
C   [N] NFACT: INTEGER RESULT OF FACTORIAL N!                          C
C**********************************************************************C
C
C
      SUBROUTINE FIELDS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          FFFFFFFF IIII EEEEEEEE LL       DDDDDDD   SSSSSS            C
C          FF        II  EE       LL       DD    DD SS    SS           C
C          FF        II  EE       LL       DD    DD SS                 C
C          FFFFFF    II  EEEEEE   LL       DD    DD  SSSSSS            C
C          FF        II  EE       LL       DD    DD       SS           C
C          FF        II  EE       LL       DD    DD SS    SS           C
C          FF       IIII EEEEEEEE LLLLLLLL DDDDDDD   SSSSSS            C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  FIELDS CALCULATES AMPLITUDES, EM FIELDS AND POTENTIALS, STORES IN   C
C  EXTERNAL DATA FILES AND PLOTS WHEN CALLED.                          C
C -------------------------------------------------------------------- C
C  EQFILE ONLY GENERATES ELL0, ESS0 AND MAYBE ELSI, AND IN GENERAL     C
C  THESE CALCULATIONS REQUIRE ETT'Q, SO GENERATE AS NEEDED INSTEAD.    C
C -------------------------------------------------------------------- C
C  FOR NOW PLOTS ARE GENERATED ALONG ONE DIRECTION ONLY, AND FOR IORB  C
C  AND JORB ORBITAL PAIRS. CAN EXTEND TO SURFACE AND DENSITY PLOTS, AS C
C  WELL AS OVERALL MOLECULAR AMPLITUDES AND FIELDS.                    C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9)
C
      CHARACTER*7  PTYPE(10)
      CHARACTER*16 HMS
C
      COMMON/PLOT/NPTYPE,PTYPE
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TPLT/EMTY
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     EQ-COEFF AND R-INT TIME INITIALISATION
      TELL = 0.0D0
      TESS = 0.0D0
      TELS = 0.0D0
C
C     LOOP OVER NUMBER OF REQUESTED FIELD PLOTS
      DO N=1,NPTYPE
C
C      PRINT A TITLE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) 'Plot for PTYPE = ',PTYPE(N)
        WRITE(7, *) 'Plot for PTYPE = ',PTYPE(N)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
        IF(PTYPE(N).EQ.'ORBCOEF') THEN
          CALL ORBCOEF(NSHIFT+5)
        ELSEIF(PTYPE(N).EQ.'AMPLTDE') THEN
          CALL AMPLTDE(NSHIFT+1)
        ELSEIF(PTYPE(N).EQ.'J4EQSUM') THEN
          CALL J4EQSUM(NSHIFT+1,NSHIFT+1)
        ELSEIF(PTYPE(N).EQ.'J4DIRCT') THEN
          CALL J4DIRCT(NSHIFT+1,NSHIFT+1)
        ELSEIF(PTYPE(N).EQ.'POTENTL') THEN
          CALL POTENTL(NSHIFT+1,NSHIFT+1)
        ELSEIF(PTYPE(N).EQ.'ELCTRCF') THEN
          CALL ELCTRCF(NSHIFT+1,NSHIFT+1)
        ELSEIF(PTYPE(N).EQ.'MAGNTCF') THEN
          CALL MAGNTCF(NSHIFT+1,NSHIFT+1)
        ELSE
          WRITE(6, *) 'In FIELDS: plotting option is not available.'
          WRITE(7, *) 'In FIELDS: plotting option is not available.'
        ENDIF
C
C     END LOOP OVER FIELD PLOTS
      ENDDO
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TPLT)
      TPLT = TPLT-TDUM
C
20    FORMAT(1X,A,37X,A)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Time in EMAKE (LL):',HMS(TELL)
      WRITE(7,20) 'Time in EMAKE (LL):',HMS(TELL)
      WRITE(6,20) 'Time in EMAKE (SS):',HMS(TESS)
      WRITE(7,20) 'Time in EMAKE (SS):',HMS(TESS)
      WRITE(6,20) 'Time in EMAKE (LS):',HMS(TELS)
      WRITE(7,20) 'Time in EMAKE (LS):',HMS(TELS)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ARRYPLT(ARRAY,TITLE,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       AA    RRRRRRR  RRRRRRR  YY    YY PPPPPPP  LL      TTTTTTTT     C
C      AAAA   RR    RR RR    RR YY    YY PP    PP LL         TT        C
C     AA  AA  RR    RR RR    RR YY    YY PP    PP LL         TT        C
C    AA    AA RR    RR RR    RR  YY  YY  PP    PP LL         TT        C
C    AAAAAAAA RRRRRRR  RRRRRRR    YYYY   PPPPPPP  LL         TT        C
C    AA    AA RR    RR RR    RR    YY    PP       LL         TT        C
C    AA    AA RR    RR RR    RR    YY    PP       LLLLLLLL   TT        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ARRYPLT EXPORTS AN ARRAY TO AN EXTERNAL DATA FILE AND PLOTS IT.     C
C**********************************************************************C
      PARAMETER(MDM=1200)
C
      CHARACTER*80 TITLE
C
      DIMENSION ARRAY(MDM,MDM)
C
C     PRINT TO EXTERNAL DATA FILE
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//".dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (ARRAY(I,J),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
      XEND = DFLOAT(NDIM)-0.5D0
      YEND = DFLOAT(NDIM)-0.5D0
C
C     WRITE GNUPLOT MAKE FILE
      OPEN(UNIT=9,FILE='plots/'//TRIM(TITLE)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(TITLE)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(TITLE)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf size 4,4'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(TITLE)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') 'load "plots/pals/rdylgn.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A,F6.1,A)') 'set xrange [-0.5:',XEND,']'
      WRITE(9,'(A,F6.1,A)') 'set yrange [-0.5:',YEND,'] reverse'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(TITLE)//'.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(TITLE)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(TITLE)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE ORBCOEF(IORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      OOOOOO  RRRRRRR  BBBBBBB   CCCCCC   OOOOOO  EEEEEEE FFFFFFF     C
C     OO    OO RR    RR BB    BB CC    CC OO    OO EE      FF          C
C     OO    OO RR    RR BB    BB CC       OO    OO EE      FF          C
C     OO    OO RR    RR BBBBBBB  CC       OO    OO EEEEE   FFFFF       C
C     OO    OO RRRRRRR  BB    BB CC       OO    OO EE      FF          C
C     OO    OO RR    RR BB    BB CC    CC OO    OO EE      FF          C
C      OOOOOO  RR    RR BBBBBBB   CCCCCC   OOOOOO  EEEEEEE FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ORBCOEF PRINTS OUT THE EXPANSION COEFFICIENTS FOR IORB, GROUPED     C
C  BY QUANTUM NUMBERS OF BASIS FUNCTIONS.                              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*2 ELMNT(120),ELA
C
      COMPLEX*16 C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/MDLV/ELMNT
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     HEADER FOR COEFFICIENT LIST
20    FORMAT(1X,'****************',A,I3,'  ****************')
21    FORMAT(1X,'Center ',I2,4X,'(',A,')',5X,'#fns = ',I2,6X,'KQN =',
     &                           I2,6X,'LQN = ',I1,6X,'MQN =',A,I1,'/2')
22    FORMAT(1X,'IADD',9X,'Exponent',10X,A,7X,A)
23    FORMAT(1X,I4,4X,ES13.6,10X,ES17.10,7X,ES17.10)
      WRITE(6,20) '  Expansion coefficients for IORB =',IORB
      WRITE(7,20) '  Expansion coefficients for IORB =',IORB
C
      I = IORB
C
C     LOOP OVER ATOMIC CENTERS
      DO ICNT=1,NCNT
C
C       SAVE ELEMENT LABEL
        ELA = ELMNT(IZNUC(ICNT))
C
C       LOOP OVER ALL MQNS FOR THIS CENTER
        MMAX = LMAX(ICNT)+1
        DO IM=1,MMAX
C
C         MAGNITUDE OF THIS MQN
          MQN = 2*IM-1
C
C         MQN < 0: LOOP OVER ALL KQN WITH THIS |MQN|
          DO IK=MQN,NKAP(ICNT)
C
C           LARGE-COMPONENT ADDRESS OFFSET
            IAD = LARGE(ICNT,IK,MQN  )
C
C           LQN AND KQN VALUES
            IF(MOD(IK,2).EQ.0) THEN
              KQN = IK/2
              LQN = KQN
            ELSE
              KQN =-(IK+1)/2
              LQN =-KQN-1
            ENDIF
C
C           NUMBER OF BASIS FUNCTIONS FOR THIS LQN
            NBAS = NFUNCT(LQN+1,ICNT)
C
C           ATOMIC ADDRESS DETAILS
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,21) ICNT,ELA,NBAS,KQN,LQN,'-',MQN
            WRITE(7,21) ICNT,ELA,NBAS,KQN,LQN,'-',MQN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(7,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
C
C           LIST THE EXPONENTS AND CORRESPONDING EXP. COEFFS
            DO IBAS=1,NBAS
              CL = DREAL(C(IAD+IBAS       ,IORB))
              CS = DREAL(C(IAD+IBAS+NSHIFT,IORB))
              WRITE(6,23) IAD+IBAS,EXPSET(IBAS,LQN+1,ICNT),CL,CS
              WRITE(7,23) IAD+IBAS,EXPSET(IBAS,LQN+1,ICNT),CL,CS
            ENDDO
          ENDDO
C
C         MQN > 0: LOOP OVER ALL KQN WITH THIS |MQN|
          DO IK=MQN,NKAP(ICNT)
C
C           LARGE-COMPONENT ADDRESS OFFSET
            IAD = LARGE(ICNT,IK,MQN+1)
C
C           LQN AND KQN VALUES
            IF(MOD(IK,2).EQ.0) THEN
              KQN = IK/2
              LQN = KQN
            ELSE
              KQN =-(IK+1)/2
              LQN =-KQN-1
            ENDIF
C
C           NUMBER OF BASIS FUNCTIONS FOR THIS LQN
            NBAS = NFUNCT(LQN+1,ICNT)
C
C           ATOMIC ADDRESS DETAILS
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,21) ICNT,ELA,NBAS,KQN,LQN,'+',MQN
            WRITE(7,21) ICNT,ELA,NBAS,KQN,LQN,'+',MQN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(7,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
C
C           LIST THE EXPONENTS AND CORRESPONDING EXP. COEFFS
            DO IBAS=1,NBAS
              CL = DREAL(C(IAD+IBAS       ,IORB))
              CS = DREAL(C(IAD+IBAS+NSHIFT,IORB))
              WRITE(6,23) IAD+IBAS,EXPSET(IBAS,LQN+1,ICNT),CL,CS
              WRITE(7,23) IAD+IBAS,EXPSET(IBAS,LQN+1,ICNT),CL,CS
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE AMPLTDE(IORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      AA    MM       MM PPPPPPP  LL      TTTTTTTT DDDDDDD  EEEEEEEE   C
C     AAAA   MMM     MMM PP    PP LL         TT    DD    DD EE         C
C    AA  AA  MMMM   MMMM PP    PP LL         TT    DD    DD EE         C
C   AA    AA MM MM MM MM PP    PP LL         TT    DD    DD EEEEEE     C
C   AAAAAAAA MM  MMM  MM PPPPPPP  LL         TT    DD    DD EE         C
C   AA    AA MM   M   MM PP       LL         TT    DD    DD EE         C
C   AA    AA MM       MM PP       LLLLLLLL   TT    DDDDDDD  EEEEEEEE   C
C                                                                      C
C -------------------------------------------------------------------- C
C  AMPLTDE GENERATES A DATA SET AND GNUPLOT MAKE FILE FOR THE DIRAC    C
C  SPINOR AMPLITUDE OF ORBITAL IORB, ALONG THE Z-AXIS.                 C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      DIMENSION PSI(4)
C
      COMPLEX*16 C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLTN//'_'//'AMPLTDE'
      TITLE  = 'AMPLTDE'//' for '//TRIM(MOLCL)//' of type '//HMLTN
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{/Symbol y}(z)'
      KEY(1) = '{/Symbol y}^{L}_{u}(z)'
      KEY(2) = '{/Symbol y}^{L}_{d}(z)'
      KEY(3) = '{/Symbol y}^{S}_{u}(z)'
      KEY(4) = '{/Symbol y}^{S}_{d}(z)'
C
      I = IORB
C
C     DATA PLOTTING DETAILS
      NP = 1000
      Z0 = 0.0D0
      ZF = 5.0D0
      HS = (ZF-Z0)/NP
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C     BEGIN LOOP OVER ALL DATA POINTS
      DO IP=0,NP
C
C       SPECIFY CARTESIAN COORDINATES
        X = 0.0D0
        Y = 0.0D0
        Z = Z0 + HS*IP
C
C       DFNOTE: THIS IS DUMMY CODE JUST TO GET A DATA FILE
        PSI(1) = 1.0D0
        PSI(2) = Z*Z
        PSI(3) = DCOS(Z)
        PSI(4) = DEXP(-Z)

        WRITE(8, *) Z,(PSI(I),I=1,4)
C
C     CLOSE LOOP OVER DATA POINTS
      ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNUMAKE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE J4EQSUM(IORB,JORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      JJJJJ    44   EEEEEEEE  QQQQQQ    SSSSSS  UU    UU MM       MM  C
C        JJ    44    EE       QQ    QQ  SS    SS UU    UU MMM     MMM  C
C        JJ   44     EE       QQ    QQ  SS       UU    UU MMMM   MMMM  C
C        JJ  44 44   EEEEEE   QQ    QQ   SSSSSS  UU    UU MM MM MM MM  C
C        JJ 44444444 EE       QQ   QQQ        SS UU    UU MM  MMM  MM  C
C  JJ    JJ     44   EE       QQ    QQ  SS    SS UU    UU MM   M   MM  C
C   JJJJJJ      44   EEEEEEEE  QQQQQQ Q  SSSSSS   UUUUUU  MM       MM  C
C                                                                      C
C -------------------------------------------------------------------- C
C  J4EQSUM CREATES A PLOT OF THE 4-CURRENT OVERLAP BETWEEN IORB AND    C
C  JORB BY USE OF THE EQ-COEFFICIENTS AND GAUSSIAN PRODUCT THEOREM.    C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      COMPLEX*16 C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLTN//'_'//'J4EQSUM'
      TITLE  = 'J4EQSUM'//' for '//TRIM(MOLCL)//' of type '//HMLTN
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{j}_{/Symbol u}(z)'
      KEY(1) = '{/Symbol r}(z)'
      KEY(2) = 'j_{x}(z)'
      KEY(3) = 'j_{y}(z)'
      KEY(4) = 'j_{z}(z)'
C
      I = IORB
      J = JORB
C
C     DATA PLOTTING DETAILS
      NP = 1000
      Z0 = 0.0D0
      ZF = 5.0D0
      HS = (ZF-Z0)/NP
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C     BEGIN LOOP OVER ALL DATA POINTS
      DO IP=0,NP
C
C       SPECIFY CARTESIAN COORDINATES
        X = 0.0D0
        Y = 0.0D0
        Z = Z0 + HS*IP
C
C     CLOSE LOOP OVER DATA POINTS
      ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNUMAKE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE J4DIRCT(IORB,JORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       JJJJJ    44   DDDDDDD IIII RRRRRRR  EEEEEEEE CCCCCC TTTTTTTT   C
C         JJ    44    DD    DD II  RR    RR EE      CC    CC   TT      C
C         JJ   44     DD    DD II  RR    RR EE      CC         TT      C
C         JJ  44 44   DD    DD II  RR    RR EEEEEE  CC         TT      C
C         JJ 44444444 DD    DD II  RRRRRRR  EE      CC         TT      C
C   JJ    JJ     44   DD    DD II  RR    RR EE      CC    CC   TT      C
C    JJJJJJ      44   DDDDDDD IIII RR    RR EEEEEEEE CCCCCC    TT      C
C                                                                      C
C -------------------------------------------------------------------- C
C  J4DIRCT CREATES A PLOT OF THE 4-CURRENT OVERLAP BETWEEN IORB AND    C
C  JORB BY DIRECT MULTIPLICATION OF GAUSSIANS AND SPHERICAL SPINORS.   C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      COMPLEX*16 C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLTN//'_'//'J4DIRCT'
      TITLE  = 'J4DIRCT'//' for '//TRIM(MOLCL)//' of type '//HMLTN
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{j}_{/Symbol u}(z)'
      KEY(1) = '{/Symbol r}(z)'
      KEY(2) = 'j_{x}(z)'
      KEY(3) = 'j_{y}(z)'
      KEY(4) = 'j_{z}(z)'
C
      I = IORB
      J = JORB
C
C     DATA PLOTTING DETAILS
      NP = 1000
      Z0 = 0.0D0
      ZF = 5.0D0
      HS = (ZF-Z0)/NP
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C     BEGIN LOOP OVER ALL DATA POINTS
      DO IP=0,NP
C
C       SPECIFY CARTESIAN COORDINATES
        X = 0.0D0
        Y = 0.0D0
        Z = Z0 + HS*IP
C
C     CLOSE LOOP OVER DATA POINTS
      ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNUMAKE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE POTENTL(IORB,JORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP   OOOOOO TTTTTTTT EEEEEEEE NN    NN TTTTTTTT LL          C
C     PP    PP OO    OO   TT    EE       NNN   NN    TT    LL          C
C     PP    PP OO    OO   TT    EE       NNNN  NN    TT    LL          C
C     PP    PP OO    OO   TT    EEEEEE   NN NN NN    TT    LL          C
C     PPPPPPP  OO    OO   TT    EE       NN  NNNN    TT    LL          C
C     PP       OO    OO   TT    EE       NN   NNN    TT    LL          C
C     PP        OOOOOO    TT    EEEEEEEE NN    NN    TT    LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  POTENTL CREATES A PLOT OF THE 4-POTENTIAL OVERLAP BETWEEN IORB AND  C
C  JORB BY USE OF THE EQ-COEFFICIENTS AND BOYS INTEGRALS.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      COMPLEX*16 C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLTN//'_'//'POTENTL'
      TITLE  = 'POTENTL'//' for '//TRIM(MOLCL)//' of type '//HMLTN
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{A}_{/Symbol u}(z)'
      KEY(1) = '{/Symbol f}(z)'
      KEY(2) = 'A_{x}(z)'
      KEY(3) = 'A_{y}(z)'
      KEY(4) = 'A_{z}(z)'
C
      I = IORB
      J = JORB
C
C     DATA PLOTTING DETAILS
      NP = 1000
      Z0 = 0.0D0
      ZF = 5.0D0
      HS = (ZF-Z0)/NP
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C     BEGIN LOOP OVER ALL DATA POINTS
      DO IP=0,NP
C
C       SPECIFY CARTESIAN COORDINATES
        X = 0.0D0
        Y = 0.0D0
        Z = Z0 + HS*IP
C
C     CLOSE LOOP OVER DATA POINTS
      ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNUMAKE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE ELCTRCF(IORB,JORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     EEEEEEEE LL       CCCCCC TTTTTTTT RRRRRRR   CCCCCC  FFFFFFFF     C
C     EE       LL      CC    CC   TT    RR    RR CC    CC FF           C
C     EE       LL      CC         TT    RR    RR CC       FF           C
C     EEEEEE   LL      CC         TT    RR    RR CC       FFFFFF       C
C     EE       LL      CC         TT    RRRRRRR  CC       FF           C
C     EE       LL      CC    CC   TT    RR    RR CC    CC FF           C
C     EEEEEEEE LLLLLLLL CCCCCC    TT    RR    RR  CCCCCC  FF           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCTRCF CREATES A PLOT OF THE ELECTRIC FIELD OVERLAP BETWEEN IORB   C
C  AND JORB BY USE OF THE EQ-COEFFICIENTS AND BOYS INTEGRALS.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      COMPLEX*16 C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLTN//'_'//'ELCTRCF'
      TITLE  = 'ELCTRCF'//' for '//TRIM(MOLCL)//' of type '//HMLTN
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{E}_{i}(z)'
      KEY(1) = 'E_{x}(z)'
      KEY(2) = 'E_{y}(z)'
      KEY(3) = 'E_{z}(z)'
      KEY(4) = '|E|(z)'
C
      I = IORB
      J = JORB
C
C     DATA PLOTTING DETAILS
      NP = 1000
      Z0 = 0.0D0
      ZF = 5.0D0
      HS = (ZF-Z0)/NP
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C     BEGIN LOOP OVER ALL DATA POINTS
      DO IP=0,NP
C
C       SPECIFY CARTESIAN COORDINATES
        X = 0.0D0
        Y = 0.0D0
        Z = Z0 + HS*IP
C
C     CLOSE LOOP OVER DATA POINTS
      ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNUMAKE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE MAGNTCF(IORB,JORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   MM       MM    AA     GGGGGG  NN    NN TTTTTTTT CCCCCC  FFFFFFFF   C
C   MMM     MMM   AAAA   GG    GG NNN   NN    TT   CC    CC FF         C
C   MMMM   MMMM  AA  AA  GG       NNNN  NN    TT   CC       FF         C
C   MM MM MM MM AA    AA GG       NN NN NN    TT   CC       FFFFFF     C
C   MM  MMM  MM AAAAAAAA GG   GGG NN  NNNN    TT   CC       FF         C
C   MM   M   MM AA    AA GG    GG NN   NNN    TT   CC    CC FF         C
C   MM       MM AA    AA  GGGGGG  NN    NN    TT    CCCCCC  FF         C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGNTCF CREATES A PLOT OF THE MAGNETIC FIELD OVERLAP BETWEEN IORB   C
C  AND JORB BY USE OF THE EQ-COEFFICIENTS AND BOYS INTEGRALS.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=6,MKP=9)
C
      CHARACTER*4  HMLTN
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      COMPLEX*16 C(MDM,MDM)
C
      COMMON/COEF/C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLTN//'_'//'MAGNTCF'
      TITLE  = 'MAGNTCF'//' for '//TRIM(MOLCL)//' of type '//HMLTN
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{B}_{i}(z)'
      KEY(1) = 'B_{x}(z)'
      KEY(2) = 'B_{y}(z)'
      KEY(3) = 'B_{z}(z)'
      KEY(4) = '|B|(z)'
C
      I = IORB
      J = JORB
C
C     DATA PLOTTING DETAILS
      NP = 1000
      Z0 = 0.0D0
      ZF = 5.0D0
      HS = (ZF-Z0)/NP
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C     BEGIN LOOP OVER ALL DATA POINTS
      DO IP=0,NP
C
C       SPECIFY CARTESIAN COORDINATES
        X = 0.0D0
        Y = 0.0D0
        Z = Z0 + HS*IP
C
C     CLOSE LOOP OVER DATA POINTS
      ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNUMAKE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE GNUMAKE(XOUT,TITLE,XAXIS,YAXIS,NDAT,KEY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   GGGGGG  NN    NN UU    UU MM       MM    AA    KK    KK EEEEEEEE   C
C  GG    GG NNN   NN UU    UU MMM     MMM   AAAA   KK   KK  EE         C
C  GG       NNNN  NN UU    UU MMMM   MMMM  AA  AA  KK  KK   EE         C
C  GG       NN NN NN UU    UU MM MM MM MM AA    AA KKKKK    EEEEEE     C
C  GG   GGG NN  NNNN UU    UU MM  MMM  MM AAAAAAAA KK  KK   EE         C
C  GG    GG NN   NNN UU    UU MM   M   MM AA    AA KK   KK  EE         C
C   GGGGGG  NN    NN  UUUUUU  MM       MM AA    AA KK    KK EEEEEEEE   C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNUMAKE IS A CONTROLLING ROUTINE THAT GENERATES A GNUPLOT MAKE FILE C
C  FOR A SET OF DATA POINTS.                                           C
C**********************************************************************C
C
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(NDAT)
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(XOUT)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot raw data'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ENDIF
      ENDDO
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf enhance font "palatino,10"'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(XOUT)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A)') 'set xlabel "'//TRIM(XAXIS)//'"'
      WRITE(9,'(A)') 'set ylabel "'//TRIM(YAXIS)//'"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plotting range'
      WRITE(9,'(A)') 'xmin = GPVAL_X_MIN'
      WRITE(9,'(A)') 'xmax = GPVAL_X_MAX'
      WRITE(9,'(A)') 'ymin = GPVAL_Y_MIN'
      WRITE(9,'(A)') 'ymax = GPVAL_Y_MAX'
      WRITE(9,'(A)') 'set xrange [xmin:xmax] noreverse nowriteback'
      WRITE(9,'(A)') 'set yrange [ymin:ymax] noreverse nowriteback'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Grid style'
      WRITE(9,'(A)') 'set style line 102 lc rgb"#808080" lt 0 lw 1'
      WRITE(9,'(A)') 'set grid back ls 102'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ENDIF
      ENDDO
      CLOSE(UNIT=9)
C
      WRITE(6, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot."'
      WRITE(7, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot."'
C
      RETURN
      END
C
C
      FUNCTION CLEBSCH(KQN,MQN,NSGN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     CCCCCC  LL       EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C    CC       LL       EE       BB    BB SS       CC       HH    HH    C
C    CC       LL       EEEEEE   BBBBBBB   SSSSSS  CC       HHHHHHHH    C
C    CC       LL       EE       BB    BB       SS CC       HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C     CCCCCC  LLLLLLLL EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C                                                                      C
C -------------------------------------------------------------------- C
C     CLEBSCH DETERMINES A CLEBSCH-GORDON COEFFICIENT FOR KQN,MQN.     C
C -------------------------------------------------------------------- C
C     KQN IS FINE BUT MQN IS DOUBLE THE ACTUAL VALUE, AND NSGN IS      C
C     THE PARITY NUMBER.                                               C
C**********************************************************************C
C
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
C
      T1 = 2.0D0*LQN + 1.0D0 + MQN*NSGN
      T2 = 4.0D0*LQN + 2.0D0

      CLEBSCH = DSQRT(T1/T2)
C
      RETURN
      END
C
C
      FUNCTION SPHHRM(THETA,PHI,L,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        SSSSSS  PPPPPPP  HH    HH HH    HH RRRRRRR  MM       MM       C
C       SS    SS PP    PP HH    HH HH    HH RR    RR MMM     MMM       C
C       SS       PP    PP HH    HH HH    HH RR    RR MMMM   MMMM       C
C        SSSSSS  PP    PP HHHHHHHH HHHHHHHH RR    RR MM MM MM MM       C
C             SS PPPPPPP  HH    HH HH    HH RRRRRRR  MM  MMM  MM       C
C       SS    SS PP       HH    HH HH    HH RR    RR MM   M   MM       C
C        SSSSSS  PP       HH    HH HH    HH RR    RR MM       MM       C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPHHRM RETURNS A COMPLEX*16 SPHERICAL HARMONIC Y_L^M (THETA,PHI).   C
C -------------------------------------------------------------------- C
C  PARAMETERS:                                                         C
C   INPUT  THETA - ZENITH ANGLE (FROM POSITIVE Z DOWN).                C
C          PHI   - AZIMUTH ANGLE (FROM POSITIVE X TOWARD POSITIVE Y).  C
C          L     - ORBITAL QUANTUM NUMBER (0,1,...).                   C
C          M     - MAGNETIC QUANTUM NUMBER (-L,...,0,...,+L).          C
C  OUTPUT  SPHHRM - DOUBLE COMPLEX NUMBER.                             C
C**********************************************************************C
C
      COMPLEX*16 SPHHRM
C
      DATA PI/3.1415926535897932D0/
C
C     FOR CONDON-SHORTLEY PHASE CONVENTION
      MTEMP = M
      IF(M.LT.0) THEN
        M  =-M
        IP =(-1)**M
      ENDIF
C
      DEN = 4.0D0*PI*NFACT(L+M)
      FCT = NFACT(L-M)*(2.0D0*L+1.0D0)/DEN
      FCT = DSQRT(FCT)
      AZR = DCOS(M*PHI)
      AZI = DSIN(M*PHI)
      ARG = DCOS(THETA)
      PLM = PLGNDR(L,M,ARG)
C
      IF(M.GE.0) THEN
        SPHHRM = DCMPLX(   FCT*PLM*AZR,    FCT*PLM*AZI)
      ELSEIF(M.LT.0) THEN
        SPHHRM = DCMPLX(IP*FCT*PLM*AZR,-IP*FCT*PLM*AZI)
      ENDIF

      M = MTEMP
C
      RETURN
      END
C
C
      FUNCTION PLGNDR(L,M,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        PPPPPPP  LL       GGGGGG  NN    NN DDDDDDD  RRRRRRR           C
C        PP    PP LL      GG    GG NNN   NN DD    DD RR    RR          C
C        PP    PP LL      GG    GG NNNN  NN DD    DD RR    RR          C
C        PP    PP LL      GG       NN NN NN DD    DD RR    RR          C
C        PPPPPPP  LL      GG   GGG NN  NNNN DD    DD RRRRRRR           C
C        PP       LL      GG    GG NN   NNN DD    DD RR    RR          C
C        PP       LLLLLLLL GGGGGG  NN    NN DDDDDDD  RR    RR          C
C                                                                      C
C -------------------------------------------------------------------- C
C  PLGNDR RETURNS AN ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).          C
C -------------------------------------------------------------------- C
C  PARAMETERS:                                                         C
C   INPUT  X - ARGUMENT WITH -1 <= X <= 1.                             C
C          L - ORBITAL QUANTUM NUMBER (0,1,...).                       C
C          M - MAGNETIC QUANTUM NUMBER (0,...,+L).                     C
C  OUTPUT  PLGNDR - ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).           C
C**********************************************************************C
C
C     CHECK VALIDITY OF ARGUMENTS
      IF(M.LT.0) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - M < 0.'
        WRITE(7, *) 'In PLGNDR: bad argument - M < 0.'
        STOP
      ELSEIF(M.GT.L) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - L < M: ',L,'<',M
        WRITE(7, *) 'In PLGNDR: bad argument - L < M: ',L,'<',M
        STOP
      ELSEIF(DABS(X).GT.1) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - X NOTIN [-1,+1].'
        WRITE(7, *) 'In PLGNDR: bad argument - X NOTIN [-1,+1].'
        STOP
      ENDIF
C
C     COMPUTE P^M_M (X)
      PMM = 1.0D0
      IF(M.GT.0) THEN
        SOMX2 = DSQRT((1.0D0-X)*(1.0D0+X))
        FACT  = 1.0D0
        DO I=1,M
          PMM  =-PMM*FACT*SOMX2
          FACT = FACT + 2.0D0
        ENDDO
      ENDIF
C
C     APPLY RECURRENCE RELATION UNTIL WE HAVE P^M_L
      IF(L.EQ.M) THEN
        PLGNDR = PMM
      ELSE
        PMMP1 = X*PMM*(2*M+1)
        IF(L.EQ.M+1) THEN
C         COMPUTE P^M_M+1
          PLGNDR = PMMP1
        ELSE
C         COMPUTE P^M_L, L>M+1
          DO LL=M+2,L
            LLM   = LL-M
            PLL   = (X*(2*LL-1)*PMMP1-(LL+M-1)*PMM)/LLM
            PMM   = PMMP1
            PMMP1 = PLL
          ENDDO
          PLGNDR = PLL
        ENDIF
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION NFACT(N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             NN    NN FFFFFFFF   AA     CCCCCC  TTTTTTTT              C
C             NNN   NN FF        AAAA   CC    CC    TT                 C
C             NNNN  NN FF       AA  AA  CC          TT                 C
C             NN NN NN FFFFFF  AA    AA CC          TT                 C
C             NN  NNNN FF      AAAAAAAA CC          TT                 C
C             NN   NNN FF      AA    AA CC    CC    TT                 C
C             NN    NN FF      AA    AA  CCCCCC     TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  NFACT(N) RETURNS THE INTEGER RESTULT OF THE FACTORIAL N!.           C
C**********************************************************************C
      PARAMETER(NMAX=30)
C
C     CHECK THAT ARGUMENT IS VALID
      IF(N.LT.0) THEN
        WRITE(6, *) 'In NFACT: negative input number.',N
        WRITE(7, *) 'In NFACT: negative input number.',N
        STOP
      ELSEIF(N.GT.NMAX) THEN
        WRITE(6, *) 'In NFACT: N too large. N = ',N
        WRITE(7, *) 'In NFACT: N too large. N = ',N
        STOP
      ENDIF
C
C     FACTORIAL AS A PRODUCT OF INTEGERS
      NFACT = 1
      DO M=1,N
        NFACT = M*NFACT
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [11] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] RMAKE: BATCH OF R-INTEGRALS FOR BASIS FUNCTION OVERLAPS.       C
C   [B] WMAKE: BATCH OF W-INTEGRALS FOR BASIS FUNCTION OVERLAPS.       C
C   [C] FUNFM: LIST OF BOYS INTEGRALS FOR USE IN RMAKE.                C
C   [D] BOYSGEN: OUTPUT DATA FILE WITH FAMILY OF BOYS FUNCTIONS.       C
C   [E] HCOEFF: HERMITE POLYNOMIAL COEFFICIENT FOR USE IN WMAKE.       C
C   [F] HGTF: ARRAY OF HGTFS EVAULATED AT (X,Y,Z).                     C
C   [G] HERMITE: EVALUATION OF H_I (P,X) BY RECURRENCE.                C
C**********************************************************************CC
C
      SUBROUTINE RMAKE(RC,QP,APH,MAXM,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           RRRRRRR  MM       MM    AA    KK    KK EEEEEEEE            C
C           RR    RR MMM     MMM   AAAA   KK   KK  EE                  C
C           RR    RR MMMM   MMMM  AA  AA  KK  KK   EE                  C
C           RR    RR MM MM MM MM AA    AA KKKKK    EEEEEE              C
C           RRRRRRR  MM  MMM  MM AAAAAAAA KK  KK   EE                  C
C           RR    RR MM   M   MM AA    AA KK   KK  EE                  C
C           RR    RR MM       MM AA    AA KK    KK EEEEEEEE            C
C                                                                      C
C -------------------------------------------------------------------- C
C  RMAKE GENERATES A COMPLETE SET OF R-INTEGRALS REQUIRED IN THE       C
C  FINITE SUM REPRESENTATION OF A MULTI-CENTER GAUSSIAN OVERLAP.       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MLM=26,MKP=9,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION FS(MB2,MLM),APH(MB2),QP(MB2,3),RC(MB2,MRC),RC2(MB2,MRC)
      DIMENSION F1(MB2,MLM),F2(MB2,MLM),F3(MB2,MLM),F4(MB2,MLM)
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2),
     &          I1(MB2),I2(MB2),I3(MB2),I4(MB2)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C
C**********************************************************************C
C     THE FIRST STEP OF THIS ROUTINE IS TO EVALUATE THE REQUIRED       C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
      N1 = 0
      N2 = 0
      N3 = 0
      N4 = 0
C
C     FOR EACH PAIR OF BASIS FUNCTIONS (EXPONENTS EI AND EJ IN 'M'),
C     DETERMINE THE BEST WAY TO EVALUATE THE BOYS FUNCTION
      DO M=1,MAXM
C
        X = APH(M)*(QP(M,1)*QP(M,1)+QP(M,2)*QP(M,2)+QP(M,3)*QP(M,3))
C
C       CASE 1: IF X IS ALMOST ZERO (SO WHEN Q=P OR EIJ<<1)
        IF(X.LE.1.0D-11) THEN
          N1     = N1+1
          X1(N1) = X
          I1(N1) = M
C
C       CASE 2: IF X IS SMALLER THAN 17.0D0
        ELSEIF(X.GT.1.0D-11.AND.X.LE.17.0D0) THEN
          N2     = N2+1
          X2(N2) = X
          I2(N2) = M
C
C       CASE 3: IF X IS SMALLER THAN 30.0D0
        ELSEIF(X.GT.17.0D0.AND.X.LE.30.0D0) THEN
          N3     = N3+1
          X3(N3) = X
          I3(N3) = M
C
C       CASE 4: IF X IS LARGER THAN 30.0D0
        ELSE
          N4     = N4+1
          X4(N4) = X
          I4(N4) = M
        ENDIF
C
      ENDDO
C
C     EVALUATE THE BOYS INTEGRALS -- A BATCH FOR EACH ITYPE
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS X=0.0D0.
C     THE VALUE OF THIS FUNCTION IS 2N+1 (DONE IN FUNFM).
      IF(N1.GT.0) THEN
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO K=1,LAM+1
          DO M=1,N1
            FS(I1(M),K) = F1(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=17.0D0.
C     EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C     AND RECURRENCE IN DIRECTION OF DECREASING M.
      IF(N2.GT.0) THEN
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO K=1,LAM+1
          DO M=1,N2
            FS(I2(M),K) = F2(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=30.0D0.
C     EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      IF(N3.GT.0) THEN
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO K=1,LAM+1
          DO M=1,N3
            FS(I3(M),K) = F3(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 4: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=30.0D0.
C     EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      IF(N4.GT.0) THEN
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO K=1,LAM+1
          DO M=1,N4
            FS(I4(M),K) = F4(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     THE SECOND STEP OF THIS ROUTINE IS TO EVALUATE THE ACTUAL        C
C     R-COEFFICIENTS, BASED ON THE CORRESPONDING BOYS FUNCTIONS.       C
C**********************************************************************C
C
C     CONSTRUCT TOP LEVEL (FOR MAXIMUM LAM VALUE)
      DO M=1,MAXM
        RC(M,1)=((-2.0D0*APH(M))**(LAM))*FS(M,LAM+1)
      ENDDO
C
C     MINIMUM LEVEL ILEV BASED ON LAM VALUE
      IF(MOD(LAM,2).EQ.0) THEN
       ITUVMIN = 1
      ELSE
       ITUVMIN = 2
      ENDIF
C
C     INITIALISE ITUV COUNTER (RELATES TO # CARTESIAN INDICES FOR lam)
      ITUV=-1
C
C     MAIN LOOP: LEVEL 'ILEV' STARTING AT LAM-1 AND WORKING BACKWARDS
      DO ILEV=LAM-1,ITUVMIN,-2
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT = DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = INABCD(IT+1,IU  ,IV  )
              N2 = INABCD(IT  ,IU+1,IV  )
              N3 = INABCD(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILEV
            ENDDO
          ENDDO
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
        DO M=1,MAXM
          RC2(M,1) = ((-2.0D0*APH(M))**(ILEV))*FS(M,ILEV+1)
        ENDDO
C
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT=DFLOAT(IT)
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = INABCD(IT+1,IU  ,IV  )
              N2 = INABCD(IT  ,IU+1,IV  )
              N3 = INABCD(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                DO M=1,MAXM
                 RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                 RC(M,N2) =-QP(M,2)*RC2(M,K1)
                 RC(M,N3) =-QP(M,3)*RC2(M,K1)
               ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILEV
            ENDDO
          ENDDO
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXM
          RC(M,1) = ((-2.0D0*APH(M))**(ILEV-1))*FS(M,ILEV)
        ENDDO
C
      ENDDO
C
C
C     AN ADDITIONAL LOOP OVER ADDRESSES (WHEN LAM IS ODD)
      IF(MOD(LAM,2).EQ.1) THEN
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT=DFLOAT(IT)
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = INABCD(IT+1,IU  ,IV  )
              N2 = INABCD(IT  ,IU+1,IV  )
              N3 = INABCD(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILEV
            ENDDO
          ENDDO
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXM
          RC2(M,1) = FS(M,1)
        ENDDO
C
C       MOVE THE RC2 ARRAY INTO RC
C
        ITMAX = (LAM+1)*(LAM+2)*(LAM+3)/6
        DO IT=1,ITMAX
          DO M=1,MAXM
            RC(M,IT) = RC2(M,IT)
          ENDDO
        ENDDO
C
C     END IF STATEMENT FOR THE ODD LAM CASE
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE WMAKE(WC,RP,APH,MAXM,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         WW         WW MM       MM    AA    KK    KK EEEEEEEE         C
C         WW         WW MMM     MMM   AAAA   KK   KK  EE               C
C         WW         WW MMMM   MMMM  AA  AA  KK  KK   EE               C
C         WW    W    WW MM MM MM MM AA    AA KKKKK    EEEEEE           C
C          WW  WWW  WW  MM  MMM  MM AAAAAAAA KK  KK   EE               C
C           WWWW WWWW   MM   M   MM AA    AA KK   KK  EE               C
C            WW   WW    MM       MM AA    AA KK    KK EEEEEEEE         C
C                                                                      C
C -------------------------------------------------------------------- C
C  FOR A PARTICULAR BLOCK OF BASIS FUNCTION OVERLAPS, MAKE THE W       C
C  FUNCTIONS W(APH,RP;A,B,C) AS A FUNCTION OF (X,Y,Z) -- THIS          C
C  COMES TO THE POTENTIAL FROM A HGTF OVERLAP CHARGE SOURCE.           C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MLM=30,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION FS(MB2,MLM),APH(MB2),RP(MB2,3),WC(MB2,MRC)
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2),
     &          I1(MB2),I2(MB2),I3(MB2),I4(MB2)
      DIMENSION F1(MB2,MLM),F2(MB2,MLM),F3(MB2,MLM),F4(MB2,MLM)
      DIMENSION H(0:MKP-1,0:(MKP-1)/2,3)
C
      COMMON/ACCSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
      DATA PI/3.141592653589793D0/
C
C**********************************************************************C
C     THE FIRST STEP OF THIS ROUTINE IS TO EVALUATE THE REQUIRED       C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
C
      N1 = 0
      N2 = 0
      N3 = 0
      N4 = 0
C
C     FOR EACH PAIR OF BASIS FUNCTIONS (EXPONENTS EI AND EJ IN 'M'),
C     DETERMINE THE BEST WAY TO EVALUATE THE BOYS FUNCTION
      DO M=1,MAXM
C       X = EIJ*(P-C)^2
        X = APH(M)*(RP(M,1)*RP(M,1)+RP(M,2)*RP(M,2)+RP(M,3)*RP(M,3))
C       CASE 1: IF X IS ALMOST ZERO (SO WHEN Q=P OR EIJ<<1)
        IF(X.LE.1.00D-11) THEN
          N1     = N1 + 1
          X1(N1) = X
          I1(N1) = M
C       CASE 2: IF X IS SMALLER THAN X=17.0D0
        ELSEIF(X.GT.1.00D-11.AND.X.LE.1.70D+01) THEN
          N2     = N2 + 1
          X2(N2) = X
          I2(N2) = M
C       CASE 3: IF X IS SMALLER THAN ABOUT 30.0D0
        ELSEIF(X.GT.1.70D+01.AND.X.LE.3.00D+01) THEN
          N3     = N3 + 1
          X3(N3) = X
          I3(N3) = M
C       CASE 4: IF X IS LARGER THAN ABOUT 30.0D0
        ELSE
          N4     = N4 + 1
          X4(N4) = X
          I4(N4) = M
        ENDIF
      ENDDO
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS X=0.0D0.
C     THE VALUE OF THIS FUNCTION IS 2N+1 (DONE IN FUNFM).
      IF(N1.NE.0) THEN
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO JJ=1,LAM+1
          DO M=1,N1
            FS(I1(M),JJ) = F1(M,JJ)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=17.0D0.
C     EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C     AND RECURRENCE IN DIRECTION OF DECREASING M.
      IF(N2.NE.0) THEN
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO JJ=1,LAM+1
          DO M=1,N2
            FS(I2(M),JJ) = F2(M,JJ)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=30.0D0.
C     EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      IF(N3.NE.0) THEN
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO JJ=1,LAM+1
          DO M=1,N3
            FS(I3(M),JJ) = F3(M,JJ)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 4: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=30.0D0.
C     EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      IF(N4.NE.0) THEN
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO JJ=1,LAM+1
          DO M=1,N4
            FS(I4(M),JJ) = F4(M,JJ)
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     THE SECOND STEP OF THIS SUBROUTINE IS TO EVALUATE THE ACTUAL     C
C     W-FUNCTIONS, BASED ON THE CORRESPONDING BOYS INTEGRALS.          C
C**********************************************************************C
C
C     INITIALISE THE WC ARRAY
      DO M=1,MAXM
        DO ITUV=1,LAM
          WC(M,ITUV) = 0.0D0
        ENDDO
      ENDDO
C
C     NUMBER OF ADDRESSES IADD FOR LAM VALUE
      NTUV = ((LAM+1)*(LAM+2)*(LAM+3))/6
C
C     LOOP OVER BASIS FUNCTION PAIRS
      DO M=1,MAXM
C
C       GENERATE ALL NECESSARY HERMITE POLYNOMIALS FOR LATER REFERENCE
        DO ILAM=0,LAM
C         TOTAL NUMBER OF TERMS IN HERMITE EXPANSION
          NTERMS = (ILAM-MOD(ILAM,2))/2
          DO N=0,NTERMS
            H(ILAM,N,1) = HCOEFF(APH(M),RP(M,1),ILAM,N)
            H(ILAM,N,2) = HCOEFF(APH(M),RP(M,2),ILAM,N)
            H(ILAM,N,3) = HCOEFF(APH(M),RP(M,3),ILAM,N)
          ENDDO
        ENDDO
C
C       START A LOOP THAT RUNS OVER ALL COMBINATIONS ITUV={T,U,V}
        DO ITUV=1,NTUV
C
C         ESTABLISH PARAMETERS T,U,V AND LAM FOR THIS VALUE ITUV
          IT   = IVEC(ITUV)
          IU   = JVEC(ITUV)
          IV   = KVEC(ITUV)
          ILAM = LAMVEC(ITUV)
C
C         FOR GIVEN ITUV, START THREE NESTED LOOPS FOR X,Y,Z DECOMP.
          STORE = 0.0D0
          DO IA=0,(IT-MOD(IT,2))/2
            IPOW = (IT + MOD(IT,2))/2 + IA
            DO IB=0,(IU-MOD(IU,2))/2
              JPOW = (IU + MOD(IU,2))/2 + IB
              DO IC=0,(IV-MOD(IV,2))/2
                KPOW = (IV + MOD(IV,2))/2 + IC
C
C               PRODUCT OF HERMITE EXPANSION COEFFICIENTS
                HTMS = H(IT,IA,1)*H(IU,IB,2)*H(IV,IC,3)
C
C               BOYS FUNCTION OF RELEVANT INDEX NBOYS
                NBOYS = IPOW + JPOW + KPOW
                FBOYS = FS(M,NBOYS+1)
C               ADD TO W FUNCTION BIN THE RELEVANT PRODUCT
                STORE = STORE + HTMS*FBOYS
C
              ENDDO
            ENDDO
          ENDDO
C
C         MULTIPLY RESULT BY 2*PI/LAM
          WC(M,ITUV) = 2.0D0*PI*STORE/APH(M)
C
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE FUNFM(FM,T,N,LAM,ITYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           FFFFFFFF UU    UU NN    NN FFFFFFFF MM       MM            C
C           FF       UU    UU NNN   NN FF       MMM     MMM            C
C           FF       UU    UU NNNN  NN FF       MMMM   MMMM            C
C           FFFFFF   UU    UU NN NN NN FFFFFF   MM MM MM MM            C
C           FF       UU    UU NN  NNNN FF       MM  MMM  MM            C
C           FF       UU    UU NN   NNN FF       MM   M   MM            C
C           FF        UUUUUU  NN    NN FF       MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  FUNFM EVALUATES INTEGRAL [INT_{0}^{1} U^{2M} EXP(-T*U^{2}) dU]      C
C  FOR VARIABLE T > 0 FOR ALL ORDERS 0 < M < LAM.                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITYPE = 1 - SPECIAL CASE X = 0.0D0.                               C
C    ITYPE = 2 - POWER SERIES AND REVERSE RECURRENCE.                  C
C                (ONLY MSER TERMS WILL BE USED, SO USE MUST SUPPLY A   C
C                 VALUE APPROPRIATE TO THE MAX VALUE OF X IN BATCH).   C
C    ITYPE = 3 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C    ITYPE = 4 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C                ALL TERMS DEPENDING ON EXP(-X) ARE OMITTED TO AVOID   C
C                NUMERICAL UNDERFLOW PROBLEMS. MSER NOT REQUIRED.      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MLM=26,MSER=60)
C
      DIMENSION FM(MB2,MLM),T(MB2),TLAM(MB2),TT2(MB2),
     &          TXP(MB2),TRT(MB2)
C
      DATA PIROOT,A0,B0/8.862269254527580D-1,4.994501191201870D-1,
     &                                       4.551838436668326D-1/
C
C**********************************************************************C
C     ITYPE = 1: SPECIAL CASE FOR T = 0.0D0                            C
C**********************************************************************C
C
      IF(ITYPE.EQ.1) THEN
        DO K=1,LAM+1
          MVAL  = K-1
          VALUE = 1.0D0/DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,K) = VALUE
          ENDDO
        ENDDO
        RETURN
C
C**********************************************************************C
C     ITYPE = 2: POWER SERIES EVALUATION                               C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.2) THEN
C
C       INITIALIZE THE POWER SERIES FOR M = LAM
        DO M=1,N
          TXP(M)      = DEXP(-T(M))
          TT2(M)      = 2.0D0*T(M)
          TLAM(M)     = 1.0D0
          FM(M,LAM+1) = 1.0D0
        ENDDO
C
C       LOOP OVER TERMS IN THE POWER SERIES
        DO K=1,MSER
          DLAM = DFLOAT(2*(LAM+K)+1)
          DO M=1,N
            TLAM(M)     = TLAM(M)*(TT2(M)/DLAM)
            FM(M,LAM+1) = FM(M,LAM+1) + TLAM(M)
          ENDDO
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DEN = DFLOAT((2*LAM)+1)
        DO M=1,N
          FM(M,LAM+1) = FM(M,LAM+1)*TXP(M)/DEN
        ENDDO
C
C       NOW COMPLETE TABLE BY BACKWARDS RECURRENCE
        DO I=1,LAM
          MIND  = LAM-I+1
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND) = (TT2(M)*FM(M,MIND+1) + TXP(M))/COEFF
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 3: ASYMPTOTIC EXPANSION WITH VERY LARGE ARGUMENT.        C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.3) THEN
C
C       INITIALIZE THE ASYMPTOTIC EXPANSION
        DO M=1,N
          TXP(M) = DEXP(-T(M))
          TT2(M) = 2.0D0*T(M)
          TRT(M) = DSQRT(T(M))
        ENDDO
C
C       SEED VALUES
        DO M=1,N
          FM(M,1) = A0/(B0+T(M))
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DO M=1,N
          FM(M,1) = (PIROOT/TRT(M)) - (TXP(M)*FM(M,1))
        ENDDO
C
C       NOW COMPLETE TABLE BY FORWARD RECURRENCE
        DO MIND=1,LAM
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND+1) = (COEFF*FM(M,MIND) - TXP(M))/TT2(M)
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 4: ASYMPTOTIC EXPANSION WITH VERY LARGE ARGUMENT         C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.4) THEN
C
C     INITIALIZE THE ASYMPTOTIC EXPANSION
      DO M=1,N
        TT2(M)  = 2.0D0*T(M)
        FM(M,1) = PIROOT/DSQRT(T(M))
      ENDDO
C
C     NOW COMPLETE TABLE BY FORWARD RECURRENCE
      DO MIND=1,LAM
        MVAL  = MIND-1
        COEFF = DFLOAT(MVAL+MVAL+1)
        DO M=1,N
          FM(M,MIND+1) = (COEFF*FM(M,MIND))/TT2(M)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ITYPE OUT OF RANGE: INVALID INPUT TO FUNFM                       C
C**********************************************************************C
C
      ELSE
91      FORMAT(2X,'In FUNFM: invalid type (must be 1-4)',I4)
        WRITE(6,91) ITYPE
        WRITE(7,91) ITYPE
        STOP
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BOYSGEN(LAMBDA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB   OOOOOO  YY    YY  SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C    BB    BB OO    OO YY    YY SS    SS GG    GG EE       NNN   NN    C
C    BB    BB OO    OO  YY  YY  SS       GG       EE       NNNN  NN    C
C    BBBBBBB  OO    OO   YYYY    SSSSSS  GG       EEEEEE   NN NN NN    C
C    BB    BB OO    OO    YY          SS GG   GGG EE       NN  NNNN    C
C    BB    BB OO    OO    YY    SS    SS GG    GG EE       NN   NNN    C
C    BBBBBBB   OOOOOO     YY     SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  BOYSGEN PRODUCES A DATA FILE WHICH CONTAINS A FAMILY OF BOYS        C
C  FUNCTIONS OVER A SPECIFIED REGION, GIVEN A MAXIMUM FAMILY           C
C  PARAMETER DETERMINED BY LAMBDA.                                     C
C**********************************************************************C
      PARAMETER (MBS=26,MB2=MBS*MBS,MLM=30)
C
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2)
      DIMENSION F1(MB2,MLM),F2(MB2,MLM),F3(MB2,MLM),
     &          F4(MB2,MLM),FS(MB2,MLM)
C
C     EVALUATION PARAMETERS
      NTOT = 400
      XMIN = 0.00D0
      XMAX = 4.00D1
      HSTP = (XMAX-XMIN)/NTOT
C
C**********************************************************************C
C     THE FIRST STEP OF THIS SUBROUTINE IS TO EVALUATE THE REQUIRED    C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAMBDA.         C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
      OPEN(UNIT=8,FILE='plots/boysfunction.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO NX=0,NTOT
C
      X = XMIN + HSTP*NX
C
C     DETERMINE THE BEST WAY TO EVALUATE THE BOYS FUNCTION
      IF(X.LE.1.00D-11) THEN
C     CASE 0: ARGUMENT OF THE BOYS FUNCTION IS X = 0.
C             THE VALUE OF THIS FUNCTION IS (2N+1).
        N1     = 1
        X1(N1) = X
        CALL FUNFM(F1,X1,N1,LAMBDA,1)
        DO JJ=1,LAMBDA+1
          FS(N1,JJ) = F1(N1,JJ)
        ENDDO
      ELSEIF(X.GT.1.00D-11.AND.X.LE.1.70D+01) THEN
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=17.
C             EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C             AND RECURRENCE IN DIRECTION OF DECREASING M.
        N2     = 1
        X2(N2) = X
        CALL FUNFM(F2,X2,N2,LAMBDA,2)
        DO JJ=1,LAMBDA+1
          FS(N2,JJ) = F2(N2,JJ)
        ENDDO
      ELSEIF(X.GT.1.70D+01.AND.X.LE.3.00D+01) THEN
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
        N3     = 1
        X3(N3) = X
        CALL FUNFM(F3,X3,N3,LAMBDA,3)
        DO JJ=1,LAMBDA+1
          FS(N3,JJ) = F3(N3,JJ)
        ENDDO
      ELSE
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
        N4     = 1
        X4(N4) = X
        CALL FUNFM(F4,X4,N4,LAMBDA,4)
        DO JJ=1,LAMBDA+1
          FS(N4,JJ) = F4(N4,JJ)
        ENDDO
      ENDIF
C
      WRITE(8, *) X,(FS(1,L),L=1,LAMBDA+1)
C
      ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      FUNCTION HCOEFF(P,X,LAM,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        HH    HH  CCCCCC   OOOOOO  EEEEEEEE FFFFFFFF FFFFFFFF         C
C        HH    HH CC    CC OO    OO EE       FF       FF               C
C        HH    HH CC       OO    OO EE       FF       FF               C
C        HHHHHHHH CC       OO    OO EEEEEE   FFFFFF   FFFFFF           C
C        HH    HH CC       OO    OO EE       FF       FF               C
C        HH    HH CC    CC OO    OO EE       FF       FF               C
C        HH    HH  CCCCCC   OOOOOO  EEEEEEEE FF       FF               C
C                                                                      C
C -------------------------------------------------------------------- C
C  HCOEFF DETERMINES THE NTH COEFFICIENT OF A HERMITE POLYNOMIAL       C
C  EXPANSION FOR H_LAM (P,X) FOR USE BY THE W FUNCTIONS, WHICH IN      C
C  TURN GENERATES THE POTENTIAL OF A WAVE FUNCTION.                    C
C**********************************************************************C
      PARAMETER (LAMMAX=40)
C
      IF(LAM.LT.0) THEN
        WRITE(6, *) 'In HCOEFF: index less than zero. LAM = ',LAM
        WRITE(7, *) 'In HCOEFF: index less than zero. LAM = ',LAM
        STOP
      ENDIF
C
      IF(LAM.GT.LAMMAX) THEN
        WRITE(6, *) 'In HCOEFF: index greater than max. LAM = ',LAM
        WRITE(6, *) 'In HCOEFF: index greater than max. LAM = ',LAM
        STOP
      ENDIF
C
C     EVALUATE SOME QUANTITIES COMMON TO BOTH CLASSES
      NPRE  = NFACT(LAM)
      NPOW  = (LAM - MOD(LAM,2))/2 - N
      TOP   = (-P)**(NPOW)
      NDEN2 = NFACT(NPOW)
      NOTHR = 2*N + MOD(LAM,2)
      NDEN1 = NFACT(NOTHR)
      TRM   = 2.0D0*P*X
      POLY  = TRM**NOTHR
C
      ND12   = NDEN1*NDEN2
      HCOEFF = NPRE*TOP*POLY/ND12
C
      RETURN
      END
C
C
      SUBROUTINE HGTF(HABC,XYZEVAL,XYZ,EXL,KAPPA,NBAS,I1,I2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 HH    HH  GGGGGG  TTTTTTTT FFFFFFFF                  C
C                 HH    HH GG    GG    TT    FF                        C
C                 HH    HH GG          TT    FF                        C
C                 HHHHHHHH GG          TT    FFFFFF                    C
C                 HH    HH GG   GGG    TT    FF                        C
C                 HH    HH GG    GG    TT    FF                        C
C                 HH    HH  GGGGGG     TT    FF                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTF GENERATES AN ARRAY OF HGTF FUNCTIONS EVALUATED AT A SET OF     C
C  COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM TO       C
C  TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A        C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTER, RP.     C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION RLOC(3,2),EXL(MBS,4),KAPPA(4),NBAS(4)
      DIMENSION XYZEVAL(3),XYZ(3,4)
C
C     TRANSFER KAPPA TO LOCAL LQNS
      IF(KAPPA(I1).LT.0) THEN
        LQN1 =-KAPPA(I1)-1
      ELSE
        LQN1 = KAPPA(I1)
      ENDIF
C
      IF(KAPPA(I2).LT.0) THEN
        LQN2 =-KAPPA(I2)-1
      ELSE
        LQN2 = KAPPA(I2)
      ENDIF
C
C     DETERMINE THE NUMBER OF PAIRS IN THIS BLOCK
      MAXM  = NBAS(I1)*NBAS(I2)
C
C     ASSUME MAXIMAL CASE (NECESSARY FOR SS OVERLAP)
      LAMBDA = LQN1 + LQN2 + 2
      NTUV   = ((LAMBDA+1)*(LAMBDA+2)*(LAMBDA+3))/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(I1)
        EXPA = EXL(IBAS,I1)
        DO JBAS=1,NBAS(I2)
          M    = M + 1
          EXPB = EXL(JBAS,I2)
C         SUM OF EXPONENTS
          PAB  = EXPA + EXPB
C         HGTF CENTER COORDINATES
          PX = (EXPA*XYZ(1,I1) + EXPB*XYZ(1,I2))/PAB
          PY = (EXPA*XYZ(2,I1) + EXPB*XYZ(2,I2))/PAB
          PZ = (EXPA*XYZ(3,I1) + EXPB*XYZ(3,I2))/PAB
C         COORDINATES WRT LOCAL ORIGIN
          RPX = XYZEVAL(1) - PX
          RPY = XYZEVAL(2) - PY
          RPZ = XYZEVAL(3) - PZ
C         GAUSSIAN COMPONENT OF HGTF
          GSS  = DEXP(-PAB*(RPX*RPX + RPY*RPY + RPZ*RPZ))
          DO ITUV=1,NTUV
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            HALPH = HERMITE(PAB,RPX,IVEC(ITUV))
            HBETA = HERMITE(PAB,RPY,JVEC(ITUV))
            HGAMA = HERMITE(PAB,RPZ,KVEC(ITUV))
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = HALPH*HBETA*HGAMA*GSS
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION HERMITE(P,X,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    HH    HH EEEEEEEE RRRRRRR  MM       MM IIII TTTTTTTT EEEEEEEE     C
C    HH    HH EE       RR    RR MMM     MMM  II     TT    EE           C
C    HH    HH EE       RR    RR MMMM   MMMM  II     TT    EE           C
C    HHHHHHHH EEEEEE   RR    RR MM MM MM MM  II     TT    EEEEEE       C
C    HH    HH EE       RRRRRRR  MM  MMM  MM  II     TT    EE           C
C    HH    HH EE       RR    RR MM   M   MM  II     TT    EE           C
C    HH    HH EEEEEEEE RR    RR MM       MM IIII    TT    EEEEEEEE     C
C                                                                      C
C -------------------------------------------------------------------- C
C  HERMITE EVALUATES HERMITE POLYNOMIAL H_I (P,X) BY RECURRENCE.       C
C**********************************************************************C
      PARAMETER (IMAX=40)
C
      IF(I.LT.0) THEN
        WRITE(6, *) 'In HERMITE: index less than zero. I = ',I
        WRITE(7, *) 'In HERMITE: index less than zero. I = ',I
        STOP
      ENDIF
C
      IF(I.GT.IMAX) THEN
        WRITE(6, *) 'In HERMITE: index greater than max. I = ',I
        WRITE(7, *) 'In HERMITE: index greater than max. I = ',I
        STOP
      ENDIF
C
C     NEED FIRST TWO VALUES TO ESTABLISH RECURRENCE RELATION
      TEMP1 = 1.0D0
      TEMP2 = 2.0D0*P*X
C
      IF(I.EQ.0) THEN
        HERMITE = TEMP1
      ELSEIF(I.EQ.1) THEN
        HERMITE = TEMP2
      ELSEIF(I.GT.1) THEN
        DO N=2,I
          TEMP3 = 2.0D0*P*(X*TEMP2 - (N-1)*TEMP1)
          TEMP1 = TEMP2
          TEMP2 = TEMP3
        ENDDO
        HERMITE = TEMP2
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [12] E-COEFFS: FINITE BASIS OVERLAP SPIN STRUCTURE FACTORS.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] EQFILE: MAIN ROUTINE FOR BUILDING A GLOBAL FILE OF EQ-COEFFS.  C
C   [B] ESETLL: CONSTRUCT AND SAVE ALL ELL0 COEFFICIENTS EXTERNALLY.   C
C   [C] ESETSS: CONSTRUCT AND SAVE ALL ESS0 COEFFICIENTS EXTERNALLY.   C
C   [D] ESETLS: CONSTRUCT AND SAVE ALL ELSQ COEFFICIENTS EXTERNALLY.   C
C   [E] EMAKELL: GENERATE A COMPLETE BLOCK OF EQLL COEFFICIENTS.       C
C   [F] EMAKESS: GENERATE A COMPLETE BLOCK OF EQSS COEFFICIENTS.       C
C   [G] EMAKELS: GENERATE A COMPLETE BLOCK OF EQLS COEFFICIENTS.       C
C   [H] EQLL: A RAW BLOCK OF EQLL COEFFICIENTS FOR EMAKELL.            C
C   [I] EQSS: A RAW BLOCK OF EQSS COEFFICIENTS FOR EMAKESS.            C
C   [J] EQLS: A RAW BLOCK OF EQLS COEFFICIENTS FOR EMAKELS.            C
C   [K] ESGTF: SET OF ES-COEFFS OVER SPHERICAL HARMONICS AND HGTFS.    C
C   [L] VRS: EXPANSION COEFFS IN HGTF OVERLAPS, CALLED IN ESGTF.       C
C   [M] STEPLM: SIMULTANEOUS INCREASE IN (L,M) FOR USE IN VRS.         C
C   [N] STEPL: INCREMENT IN L FOR USE IN VRS.                          C
C   [O] STEPN: INCREMENT IN N FOR USE IN VRS.                          C
C   [P] RNLL: A BLOCK OF LL NORMALISATION COEFFS.                      C
C   [Q] RNSS: A BLOCK OF SS NORMALISATION COEFFS.                      C
C   [R] RNLS: A BLOCK OF LS NORMALISATION COEFFS.                      C
C   [S] DNORM: NORM FOR A REAL OR COMPLEX PART OF EQ-COEFF LIST.       C
C**********************************************************************C
C
C
      SUBROUTINE EQFILE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          EEEEEEEE  QQQQQQ   FFFFFFFF IIII LL       EEEEEEEE          C
C          EE       QQ    QQ  FF        II  LL       EE                C
C          EE       QQ    QQ  FF        II  LL       EE                C
C          EEEEEE   QQ    QQ  FFFFFF    II  LL       EEEEEE            C
C          EE       QQ   QQQ  FF        II  LL       EE                C
C          EE       QQ    QQ  FF        II  LL       EE                C
C          EEEEEEEE  QQQQQQ Q FF       IIII LLLLLLLL EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQFILE CONSTRUCTS A SET OF COMMON ARRAYS FOR ALL REQUIRED EQTT      C
C  COEFFICIENTS IN A CALCULATION THAT RESTS WITHIN QED.                C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=6,MKP=9,MFL=10000000)
C
      CHARACTER*4 HMLTN
C
      DIMENSION NLL(0:MKP),NSS(0:MKP),NLS(0:MKP)
C
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TRLL,TRSS,TRLS,TRBR
C
C**********************************************************************C
C     LOOP OVER FOCK BLOCK AND COUNT ALL REQUIRED EQ-WORDS.            C
C**********************************************************************C
C
C     INITIALISE MAXIMUM LAMBDA
      LAMMX = 0
C
C     INITIALISE TOTAL COEFFICIENT COUNTERS
      NADE0LL =  0
      NADE0SS =  0
      NADEILS =  0
C
C     INITIALISE COEFFICIENT COUNTERS FOR LAMBDA CLASS
      DO ILAM=0,MKP
        NLL(ILAM) = 0
        NSS(ILAM) = 0
        NLS(ILAM) = 0
      ENDDO
C
C     LOOP OVER CENTERS A AND B
      DO ICNTA=1,NCNT
        DO ICNTB=1,NCNT
C
C         LOOP OVER KQNA VALUES
          DO KA=1,NKAP(ICNTA)
C
C           QUANTUM NUMBERS FOR BLOCK A
            IF(KVALS(KA,ICNTA).GT.0) THEN
              LQNA = KVALS(KA,ICNTA)
            ELSE
              LQNA =-KVALS(KA,ICNTA)-1
            ENDIF
            NBASA = NFUNCT(LQNA+1,ICNTA)
C
C           LOOP OVER KQNB VALUES
            DO KB=1,NKAP(ICNTB)
C
C             QUANTUM NUMBERS FOR BLOCK B
              IF(KVALS(KB,ICNTB).GT.0) THEN
                LQNB = KVALS(KB,ICNTB)
              ELSE
                LQNB =-KVALS(KB,ICNTB)-1
              ENDIF
              NBASB = NFUNCT(LQNB+1,ICNTB)
C
C             LOOP OVER |MQNA| VALUES
              DO MA=1,IABS(KVALS(KA,ICNTA))
                MJA = 2*MA-1
C
C               LOOP OVER |MQNB| VALUES
                DO MB=1,IABS(KVALS(KB,ICNTB))
                  MJB = 2*MB-1
C
C                 NUMBER OF BASIS FUNCTION OVERLAPS
                  MAXAB = NBASA*NBASB
C
C                 CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
                  LAMAB  = LQNA+LQNB
                  NTUVLL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
                  NTUVSS = (LAMAB+3)*(LAMAB+4)*(LAMAB+5)/6
                  NTUVLS = (LAMAB+2)*(LAMAB+3)*(LAMAB+4)/6
C
C                 UPDATE LARGEST LAMBDA VALUE
                  IF(LAMAB.GT.LAMMX) THEN
                    LAMMX = LAMAB
                  ENDIF
C
C                 INCREASE NUMBER OF WORDS FOR THIS LAMBDA VALUE
                  NLL(LAMAB  ) = NLL(LAMAB  ) + NTUVLL*MAXAB
                  NSS(LAMAB+2) = NSS(LAMAB+2) + NTUVSS*MAXAB
                  NLS(LAMAB+1) = NLS(LAMAB+1) + NTUVLS*MAXAB*3
C
C                 INCREASE TOTAL NUMBER OF WORDS
                  NADE0LL =  NADE0LL + NTUVLL*MAXAB
                  NADE0SS =  NADE0SS + NTUVSS*MAXAB
                  NADEILS =  NADEILS + NTUVLS*MAXAB*3
C
C               END LOOPS OVER |MQNA| AND |MQNB|
                ENDDO
              ENDDO
C
C           END LOOPS OVER KQNA AND KQNB
            ENDDO
          ENDDO
C
C       END LOOPS OVER ICNTA AND ICNTB
        ENDDO
      ENDDO
C
C     DOUBLE LOOP OVER FOCK BLOCK COMPLETE
C
C**********************************************************************C
C     SUMMARY OF WORD ANALYSIS                                         C
C**********************************************************************C
C
C     SECTION TITLE
20    FORMAT(1X,A,4X,A,4X,A,6X,A,4X,A,8X,A,6X,A)
21    FORMAT(1X,A,8X,I2,4X,I5,3X,I9,7X,I2,3X,I10,5X,F10.3)
22    FORMAT(1X,A,20X,I10,12X,I10,5X,F10.3)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',22),'E-coefficient word analysis'
      WRITE(7, *) REPEAT(' ',22),'E-coefficient word analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) 'Type','Lambda','Terms','Length','Mult.',
     &            'Words','Size (MB)'
      WRITE(7,20) 'Type','Lambda','Terms','Length','Mult.',
     &            'Words','Size (MB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     INITIALISE OVERALL WORD COUNTER AND SIZE COUNTER
      NADETOT = 0
      NWRDTOT = 0
      SPCETOT = 0.0D0
C
C     E0LL ANALYSIS
      DO ILAM=0,LAMMX
        IF(NLL(ILAM).EQ.0) GOTO 200
        NTUVLL = (ILAM+1)*(ILAM+2)*(ILAM+3)/6
        SPCELL = NLL(ILAM)*8*8.0D-6
        WRITE(6,21) 'E0LL',ILAM,NTUVLL,NLL(ILAM),8,NLL(ILAM)*8,SPCELL
        WRITE(7,21) 'E0LL',ILAM,NTUVLL,NLL(ILAM),8,NLL(ILAM)*8,SPCELL
        NADETOT = NADETOT + NLL(ILAM)
        NWRDTOT = NWRDTOT + NLL(ILAM)*8
        SPCETOT = SPCETOT + SPCELL
200     CONTINUE
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      IF(HMLTN.EQ.'NORL') GOTO 100
C
C     E0SS ANALYSIS
      DO ILAM=2,LAMMX+2
        IF(NSS(ILAM).EQ.0) GOTO 210
        NTUVSS = (ILAM+1)*(ILAM+2)*(ILAM+3)/6
        SPCESS = NSS(ILAM)*8*8.0D-6
        WRITE(6,21) 'E0SS',ILAM,NTUVSS,NSS(ILAM),8,NSS(ILAM)*8,SPCESS
        WRITE(7,21) 'E0SS',ILAM,NTUVSS,NSS(ILAM),8,NSS(ILAM)*8,SPCESS
        NADETOT = NADETOT + NSS(ILAM)
        NWRDTOT = NWRDTOT + NSS(ILAM)*8
        SPCETOT = SPCETOT + SPCESS
210     CONTINUE
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      IF(HMLTN.EQ.'BARE'.OR.HMLTN.EQ.'DHFR') GOTO 100
C
C     EILS ANALYSIS
      DO ILAM=1,LAMMX+1
        IF(NLS(ILAM).EQ.0) GOTO 220
        NTUVLS = (ILAM+1)*(ILAM+2)*(ILAM+3)/6
        SPCELS = NSS(ILAM)*24*8.0D-6
        WRITE(6,21) 'EILS',ILAM,NTUVLS,NLS(ILAM),24,NLS(ILAM)*24,SPCELS
        WRITE(7,21) 'EILS',ILAM,NTUVLS,NLS(ILAM),24,NLS(ILAM)*24,SPCELS
        NADETOT = NADETOT + NLS(ILAM)
        NWRDTOT = NWRDTOT + NLS(ILAM)*24
        SPCETOT = SPCETOT + SPCELS
220     CONTINUE
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
100   CONTINUE
C
C     SUMMARY OF TOTALS
      WRITE(6,22) 'Total',NADETOT,NWRDTOT,SPCETOT
      WRITE(7,22) 'Total',NADETOT,NWRDTOT,SPCETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     OPTION WHEN NUMBER OF WORDS EXCEEDS ALLOCATED SIZE LIMIT
      IF(NADE0LL.GT.MFL) THEN
        WRITE(6, *) 'In EQFILE: E0LL words exceed allocated limit.'
        WRITE(7, *) 'In EQFILE: E0LL words exceed allocated limit.'
        GOTO 150
      ENDIF
C
      IF(HMLTN.NE.'NORL') THEN
        IF(NADE0SS.GT.MFL) THEN
          WRITE(6, *) 'In EQFILE: E0SS words exceed allocated limit.'
          WRITE(7, *) 'In EQFILE: E0SS words exceed allocated limit.'
          GOTO 150
        ENDIF
      ENDIF
C
      IF(HMLTN.EQ.'DHFB'.OR.HMLTN.EQ.'DHFP'.OR.HMLTN.EQ.'DHFQ') THEN
        IF(NADEILS.GT.MFL) THEN
          WRITE(6, *) 'In EQFILE: EILS words exceed allocated limit.'
          WRITE(7, *) 'In EQFILE: EILS words exceed allocated limit.'
          GOTO 150
        ENDIF
      ENDIF

C     SIZE LIMITS ARE ALL OK -- SKIP TO BATCH GENERATION
      GOTO 250
C
C     ONE OF THE CLASSES EXCEEDS WORD LIMIT
150   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     HAVE TO GENERATE E COEFFICIENTS BY BATCH
      WRITE(6, *) 'In EQFILE: E-coefficients to be generated by batch.'
      WRITE(7, *) 'In EQFILE: E-coefficients to be generated by batch.'
C
C     FLIP THE EQ-GENERATION TOGGLE AND EXIT
      IEQS = 0
      GOTO 300
C
250   CONTINUE
C
C**********************************************************************C
C     GENERATE COMPLETE BATCH OF EQ-COEFFS                             C
C**********************************************************************C
C
C     SECTION TITLE
      WRITE(6, *) REPEAT(' ',18),'Generating E-coefficient data files'
      WRITE(7, *) REPEAT(' ',18),'Generating E-coefficient data files'
C
C     E0LL COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL ESETLL
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLTN.EQ.'NORL') GOTO 300
C
C     E0SS COEFFICIENTS
      CALL ESETSS
      CALL CPU_TIME(TDM3)
      TESS = TELL+TDM3-TDM2
C
      IF(HMLTN.EQ.'BARE'.OR.HMLTN.EQ.'DHFR') GOTO 300
C
C     EILS COEFFICIENTS
      CALL ESETLS
      CALL CPU_TIME(TDM4)
      TELS = TELS+TDM4-TDM3
C
300   CONTINUE
C
C     END OF SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE ESETLL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS  EEEEEEEE TTTTTTTT LL       LL               C
C         EE      SS    SS EE          TT    LL       LL               C
C         EE      SS       EE          TT    LL       LL               C
C         EEEEEE   SSSSSS  EEEEEE      TT    LL       LL               C
C         EE            SS EE          TT    LL       LL               C
C         EE      SS    SS EE          TT    LL       LL               C
C         EEEEEEEE SSSSSS  EEEEEEEE    TT    LLLLLLLL LLLLLLLL         C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESETLL CONSTRUCTS ALL ELL0 COEFFICIENTS FOR A SYSTEM WITH CALLS TO  C
C  EMAKELL AND SAVES THEM TO AN EXTERNAL DATA FILE.                    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS           C
C     OF (MA,MB). FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE          C
C     ORDERED                                                          C
C     11: = (-|MQN(A)|,-|MQN(B)|)                                      C
C     12: = (-|MQN(A)|,+|MQN(B)|)                                      C
C     21: = (+|MQN(A)|,-|MQN(B)|)                                      C
C     22: = (+|MQN(A)|,+|MQN(B)|)                                      C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)
      NTUVLL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ELL0(AB) COEFFICIENTS
      CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ELL0(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLL
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0LLFL(IAD+M,1) = DREAL(E11(M,ITUV))
          E0LLFL(IAD+M,2) = DIMAG(E11(M,ITUV))
          E0LLFL(IAD+M,3) = DREAL(E21(M,ITUV))
          E0LLFL(IAD+M,4) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     GENERATE ELL0(CD) COEFFICIENTS
      CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,-1,1,2,0)
C
C     WRITE ELL0(CD) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLL
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0LLFL(IAD+M,5) = DREAL(E11(M,ITUV))
          E0LLFL(IAD+M,6) = DIMAG(E11(M,ITUV))
          E0LLFL(IAD+M,7) = DREAL(E21(M,ITUV))
          E0LLFL(IAD+M,8) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLL*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ESETSS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS  EEEEEEEE TTTTTTTT  SSSSSS   SSSSSS          C
C         EE      SS    SS EE          TT    SS    SS SS    SS         C
C         EE      SS       EE          TT    SS       SS               C
C         EEEEEE   SSSSSS  EEEEEE      TT     SSSSSS   SSSSSS          C
C         EE            SS EE          TT          SS       SS         C
C         EE      SS    SS EE          TT    SS    SS SS    SS         C
C         EEEEEEEE SSSSSS  EEEEEEEE    TT     SSSSSS   SSSSSS          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESETSS CONSTRUCTS ALL ESS0 COEFFICIENTS FOR A SYSTEM WITH CALLS TO  C
C  EMAKESS AND SAVES THEM TO AN EXTERNAL DATA FILE.                    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS           C
C     OF (MA,MB). FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE          C
C     ORDERED                                                          C
C     11: = (-|MQN(A)|,-|MQN(B)|)                                      C
C     12: = (-|MQN(A)|,+|MQN(B)|)                                      C
C     21: = (+|MQN(A)|,-|MQN(B)|)                                      C
C     22: = (+|MQN(A)|,+|MQN(B)|)                                      C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ESS0(AB) COEFFICIENTS
      CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ESS0(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVSS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0SSFL(IAD+M,1) = DREAL(E11(M,ITUV))
          E0SSFL(IAD+M,2) = DIMAG(E11(M,ITUV))
          E0SSFL(IAD+M,3) = DREAL(E21(M,ITUV))
          E0SSFL(IAD+M,4) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     GENERATE ESS0(CD) COEFFICIENTS
      CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,-1,1,2,0)
C
C     WRITE ESS0(CD) TO THE MAIN ARRAY
      DO ITUV=1,NTUVSS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0SSFL(IAD+M,5) = DREAL(E11(M,ITUV))
          E0SSFL(IAD+M,6) = DIMAG(E11(M,ITUV))
          E0SSFL(IAD+M,7) = DREAL(E21(M,ITUV))
          E0SSFL(IAD+M,8) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVSS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ESETLS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS  EEEEEEEE TTTTTTTT LL       SSSSSS           C
C         EE      SS    SS EE          TT    LL      SS    SS          C
C         EE      SS       EE          TT    LL      SS                C
C         EEEEEE   SSSSSS  EEEEEE      TT    LL       SSSSSS           C
C         EE            SS EE          TT    LL            SS          C
C         EE      SS    SS EE          TT    LL      SS    SS          C
C         EEEEEEEE SSSSSS  EEEEEEEE    TT    LLLLLLLL SSSSSS           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESETLS CONSTRUCTS ALL ESS0 COEFFICIENTS FOR A SYSTEM WITH CALLS TO  C
C  EMAKELS AND SAVES THEM TO AN EXTERNAL DATA FILE.                    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
C
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTERS A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTER A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS           C
C     OF (MA,MB). FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE          C
C     ORDERED                                                          C
C     11: = (-|MQN(A)|,-|MQN(B)|)                                      C
C     12: = (-|MQN(A)|,+|MQN(B)|)                                      C
C     21: = (+|MQN(A)|,-|MQN(B)|)                                      C
C     22: = (+|MQN(A)|,+|MQN(B)|)                                      C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+1
      NTUVLS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IADILS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ELSI(AB) COEFFICIENTS
      CALL EMAKEB3(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2)
C
C     WRITE ELSI(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          EILSFL(IAD+M, 1) = DREAL(E11(M,ITUV,1))
          EILSFL(IAD+M, 2) = DIMAG(E11(M,ITUV,1))
          EILSFL(IAD+M, 3) = DREAL(E21(M,ITUV,1))
          EILSFL(IAD+M, 4) = DIMAG(E21(M,ITUV,1))
          EILSFL(IAD+M, 5) = DREAL(E11(M,ITUV,2))
          EILSFL(IAD+M, 6) = DIMAG(E11(M,ITUV,2))
          EILSFL(IAD+M, 7) = DREAL(E21(M,ITUV,2))
          EILSFL(IAD+M, 8) = DIMAG(E21(M,ITUV,2))
          EILSFL(IAD+M, 9) = DREAL(E11(M,ITUV,3))
          EILSFL(IAD+M,10) = DIMAG(E11(M,ITUV,3))
          EILSFL(IAD+M,11) = DREAL(E21(M,ITUV,3))
          EILSFL(IAD+M,12) = DIMAG(E21(M,ITUV,3))
        ENDDO
      ENDDO
C
C     GENERATE ELSI(CD) COEFFICIENTS
      CALL EMAKEB3(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,-1,1,2)
C
C     WRITE ELSI(CD) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          EILSFL(IAD+M,13) = DREAL(E11(M,ITUV,1))
          EILSFL(IAD+M,14) = DIMAG(E11(M,ITUV,1))
          EILSFL(IAD+M,15) = DREAL(E21(M,ITUV,1))
          EILSFL(IAD+M,16) = DIMAG(E21(M,ITUV,1))
          EILSFL(IAD+M,17) = DREAL(E11(M,ITUV,2))
          EILSFL(IAD+M,18) = DIMAG(E11(M,ITUV,2))
          EILSFL(IAD+M,19) = DREAL(E21(M,ITUV,2))
          EILSFL(IAD+M,20) = DIMAG(E21(M,ITUV,2))
          EILSFL(IAD+M,21) = DREAL(E11(M,ITUV,3))
          EILSFL(IAD+M,22) = DIMAG(E11(M,ITUV,3))
          EILSFL(IAD+M,23) = DREAL(E21(M,ITUV,3))
          EILSFL(IAD+M,24) = DIMAG(E21(M,ITUV,3))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE LL      LL         C
C   EE       MMM     MMM   AAAA   KK   KK  EE       LL      LL         C
C   EE       MMMM   MMMM  AA  AA  KK  KK   EE       LL      LL         C
C   EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   LL      LL         C
C   EE       MM  MMM  MM AAAAAAAA KK  KK   EE       LL      LL         C
C   EE       MM   M   MM AA    AA KK   KK  EE       LL      LL         C
C   EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE LLLLLLL LLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKELL GENERATES BLOCKS OF SPHERICAL SPINOR E-COEFFICIENTS BY      C
C  CONTRACTING ON THE E-COEFFICIENTS FOR SCALAR SGTFS, USING A         C
C  DEVELOPMENT OF THE ALGORITHM OF V.R.SAUNDERS.                       C
C -------------------------------------------------------------------- C
C  H.M.QUINEY THE UNIVERSITY OF MELBOURNE (2008).                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXL(MBS,2),COORD(3,2),KQNLAB(2),MQNLAB(2),NFLAB(2)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
C     DETERMINE LQNS FROM KQNS
      IF(KQN(I1).GT.0) THEN
        LA = KQN(I1)
      ELSE
        LA =-KQN(I1)-1
      ENDIF
      IF(KQN(I2).GT.0) THEN
        LB = KQN(I2)
      ELSE
        LB =-KQN(I2)-1
      ENDIF
C
C     SUMMATION TERMINATES AT LAM = LA + LB FOR LL PAIRS
      LAMAB = LA + LB
C
C     KAPPA LABELS AND NUMBER OF FUNCTIONS ON A GIVEN CENTER
      KQNLAB(1) = KQN(I1)
      KQNLAB(2) = KQN(I2)
      NFLAB(1)  = NBAS(I1)
      NFLAB(2)  = NBAS(I2)
C
C     CARTESIAN COORDINATES OF EACH CENTER
      DO I=1,3
        COORD(I,1) = XYZ(I,I1)
        COORD(I,2) = XYZ(I,I2)
      ENDDO
C
C     BASIS SET EXPONENTS FOR CENTER A
      DO IBAS=1,NFLAB(1)
       EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
C     BASIS SET EXPONENTS FOR CENTER B
      DO JBAS=1,NFLAB(2)
       EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQNLAB(1) =-MQN(I1)
      MQNLAB(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E11,EXL,COORD,KQNLAB,MQNLAB,NFLAB,IQ)
C
C     MULTIPLY ELL0 BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      ITUV=0
      DO MTUV=0,LAMAB
        PHASE = DFLOAT((IPHS)**(MTUV))
        DO MDUM=1,((MTUV+1)*(MTUV+2))/2
          ITUV = ITUV+1
          DO M=1,NFLAB(1)*NFLAB(2)
            E11(M,ITUV) = E11(M,ITUV)*PHASE
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQNLAB(1) = MQN(I1)
      MQNLAB(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E21,EXL,COORD,KQNLAB,MQNLAB,NFLAB,IQ)
C
C     MULTIPLY ELL0 BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      ITUV=0
      DO MTUV=0,LAMAB
        PHASE = DFLOAT((IPHS)**(MTUV))
        DO MDUM=1,((MTUV+1)*(MTUV+2))/2
          ITUV = ITUV+1
          DO M=1,NFLAB(1)*NFLAB(2)
            E21(M,ITUV) = E21(M,ITUV)*PHASE
          ENDDO
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE SSSSSS   SSSSSS    C
C   EE       MMM     MMM   AAAA   KK   KK  EE      SS    SS SS    SS   C
C   EE       MMMM   MMMM  AA  AA  KK  KK   EE      SS       SS         C
C   EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   SSSSSS   SSSSSS    C
C   EE       MM  MMM  MM AAAAAAAA KK  KK   EE            SS       SS   C
C   EE       MM   M   MM AA    AA KK   KK  EE      SS    SS SS    SS   C
C   EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE SSSSSS   SSSSSS    C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKESS GENERATES BLOCKS OF SPHERICAL SPINOR E-COEFFICIENTS BY      C
C  CONTRACTING ON THE E-COEFFICIENTS FOR SCALAR SGTFS, USING A         C
C  DEVELOPMENT OF THE ALGORITHM OF V.R.SAUNDERS.                       C
C -------------------------------------------------------------------- C
C  H.M.QUINEY THE UNIVERSITY OF MELBOURNE (2008).                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXL(MBS,2),COORD(3,2),KQNLAB(2),MQNLAB(2),NFLAB(2)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
C     DETERMINE LQNS FROM KQNS
      IF(KQN(I1).GT.0) THEN
        LA = KQN(I1)
      ELSE
        LA =-KQN(I1)-1
      ENDIF
      IF(KQN(I2).GT.0) THEN
        LB = KQN(I2)
      ELSE
        LB =-KQN(I2)-1
      ENDIF
C
C     SUMMATION TERMINATES AT LAMAB = LA + LB + 2 FOR SS PAIRS
      LAMAB = LA + LB + 2
C
C     KAPPA LABELS AND NUMBER OF FUNCTIONS ON A GIVEN CENTER
      KQNLAB(1) = KQN(I1)
      KQNLAB(2) = KQN(I2)
      NFLAB(1)  = NBAS(I1)
      NFLAB(2)  = NBAS(I2)
C
C     CARTESIAN COORDINATES OF EACH CENTER
      DO I=1,3
        COORD(I,1) = XYZ(I,I1)
        COORD(I,2) = XYZ(I,I2)
      ENDDO
C
C     BASIS SET EXPONENTS FOR CENTER A
      DO IBAS=1,NFLAB(1)
        EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
C     BASIS SET EXPONENTS FOR CENTER B
      DO JBAS=1,NFLAB(2)
        EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQNLAB(1) =-MQN(I1)
      MQNLAB(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E11,EXL,COORD,KQNLAB,MQNLAB,NFLAB,IQ)
C
C     MULTIPLY ESS0 BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      ITUV=0
      DO MTUV=0,LAMAB
        PHASE = DFLOAT((IPHS)**(MTUV))
        DO MDUM=1,((MTUV+1)*(MTUV+2))/2
          ITUV = ITUV+1
          DO M=1,NFLAB(1)*NFLAB(2)
            E11(M,ITUV) = E11(M,ITUV)*PHASE
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQNLAB(1) = MQN(I1)
      MQNLAB(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E21,EXL,COORD,KQNLAB,MQNLAB,NFLAB,IQ)
C
C     MULTIPLY ESS0 BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      ITUV=0
      DO MTUV=0,LAMAB
        PHASE = DFLOAT((IPHS)**(MTUV))
        DO MDUM=1,((MTUV+1)*(MTUV+2))/2
         ITUV = ITUV+1
          DO M=1,NFLAB(1)*NFLAB(2)
            E21(M,ITUV) = E21(M,ITUV)*PHASE
          ENDDO
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY SIMPLE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE LL      SSSSSS     C
C   EE       MMM     MMM   AAAA   KK   KK  EE       LL     SS    SS    C
C   EE       MMMM   MMMM  AA  AA  KK  KK   EE       LL     SS          C
C   EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   LL      SSSSSS     C
C   EE       MM  MMM  MM AAAAAAAA KK  KK   EE       LL           SS    C
C   EE       MM   M   MM AA    AA KK   KK  EE       LL     SS    SS    C
C   EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE LLLLLLL SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKELS GENERATES BLOCKS OF SPHERICAL SPINOR E-COEFFICIENTS BY      C
C  CONTRACTING ON THE E-COEFFICIENTS FOR VECTOR SGTFS, USING A         C
C  DEVELOPMENT OF THE ALGORITHM OF V.R.SAUNDERS.                       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXL(MBS,2),COORD(3,2),KQNLAB(2),MQNLAB(2),NFLAB(2)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
C     DETERMINE LQNS FROM KQNS
      IF(KQN(I1).GT.0) THEN
        LA = KQN(I1)
      ELSE
        LA =-KQN(I1)-1
      ENDIF
      IF(KQN(I2).GT.0) THEN
        LB = KQN(I2)
      ELSE
        LB =-KQN(I2)-1
      ENDIF
C
C     THE SUMMATION TERMINATES AT LAMAB = LA + LB + 1 FOR LS PAIRS
      LAMAB = LA + LB + 1
C
C     KAPPA LABELS AND NUMBER OF FUNCTIONS ON A GIVEN CENTER
      KQNLAB(1) = KQN(I1)
      KQNLAB(2) = KQN(I2)
      NFLAB(1)  = NBAS(I1)
      NFLAB(2)  = NBAS(I2)
C
C     CARTESIAN COORDINATES OF EACH CENTER
      DO I=1,3
        COORD(I,1) = XYZ(I,I1)
        COORD(I,2) = XYZ(I,I2)
      ENDDO
C
C     BASIS SET EXPONENTS FOR CENTER A
      DO IBAS=1,NFLAB(1)
       EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
C     BASIS SET EXPONENTS FOR CENTER B
      DO JBAS=1,NFLAB(2)
       EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQNLAB(1) =-MQN(I1)
      MQNLAB(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E11,EXL,COORD,KQNLAB,MQNLAB,NFLAB,IQ)
C
C     MULTIPLY ELSQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      ITUV = 0
      DO MTUV=0,LAMAB
        PHASE = DFLOAT((IPHS)**(MTUV))
        DO MDUM=1,(MTUV+1)*(MTUV+2)/2
         ITUV = ITUV+1
           DO M=1,NFLAB(1)*NFLAB(2)
             E11(M,ITUV) = E11(M,ITUV)*PHASE
           ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQNLAB(1) = MQN(I1)
      MQNLAB(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E21,EXL,COORD,KQNLAB,MQNLAB,NFLAB,IQ)
C
C     MULTIPLY ELSQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      ITUV = 0
      DO MTUV=0,LAMAB
        PHASE = DFLOAT((IPHS)**(MTUV))
        DO MDUM=1,(MTUV+1)*(MTUV+2)/2
          ITUV = ITUV + 1
          DO M=1,NFLAB(1)*NFLAB(2)
            E21(M,ITUV) = E21(M,ITUV)*PHASE
          ENDDO
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EMAKEB3(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE BBBBBBB   333333    C
C  EE       MMM     MMM   AAAA   KK   KK  EE       BB    BB 33    33   C
C  EE       MMMM   MMMM  AA  AA  KK  KK   EE       BB    BB       33   C
C  EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   BBBBBBB    33333    C
C  EE       MM  MMM  MM AAAAAAAA KK  KK   EE       BB    BB       33   C
C  EE       MM   M   MM AA    AA KK   KK  EE       BB    BB 33    33   C
C  EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE BBBBBBB   333333    C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKEC3 GENERATES A VECTOR LIST OF E-COEFFICIENTS FOR A BATCH OF    C
C  BREIT INTERACTION INTEGRALS USING A DEVELOPMENT OF THE ALGORITHM OF C
C  V.R.SAUNDERS.                                                       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXL(MBS,2),COORD(3,2),KQNLAB(2),MQNLAB(2),NFLAB(2)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
C
C     DETERMINE LQNS FROM KQNS
      IF(KQN(I1).GT.0) THEN
        LA = KQN(I1)
      ELSE
        LA =-KQN(I1)-1
      ENDIF
      IF(KQN(I2).GT.0) THEN
        LB = KQN(I2)
      ELSE
        LB =-KQN(I2)-1
      ENDIF
C
C     THE SUMMATION TERMINATES AT LAMAB = LA + LB + 1 FOR LS PAIRS
      LAMAB = LA + LB + 1
C
C     KAPPA LABELS AND NUMBER OF FUNCTIONS ON A GIVEN CENTER
      KQNLAB(1) = KQN(I1)
      KQNLAB(2) = KQN(I2)
      NFLAB(1)  = NBAS(I1)
      NFLAB(2)  = NBAS(I2)
C
C     CARTESIAN COORDINATES OF EACH CENTER
      DO I=1,3
        COORD(I,1) = XYZ(I,I1)
        COORD(I,2) = XYZ(I,I2)
      ENDDO
C
C     BASIS SET EXPONENTS FOR CENTER A
      DO IBAS=1,NFLAB(1)
       EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
C     BASIS SET EXPONENTS FOR CENTER B
      DO JBAS=1,NFLAB(2)
       EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQNLAB(1) =-MQN(I1)
      MQNLAB(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS3(E11,EXL,COORD,KQNLAB,MQNLAB,NFLAB)
C
C     MULTIPLY ELSQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      ITUV = 0
      DO MTUV=0,LAMAB
        PHASE = DFLOAT((IPHS)**(MTUV))
        DO MDUM=1,(MTUV+1)*(MTUV+2)/2
         ITUV = ITUV+1
           DO M=1,NFLAB(1)*NFLAB(2)
             DO IQ=1,3
               E11(M,ITUV,IQ) = PHASE*E11(M,ITUV,IQ)
             ENDDO
           ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQNLAB(1) = MQN(I1)
      MQNLAB(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS3(E21,EXL,COORD,KQNLAB,MQNLAB,NFLAB)
C
C     MULTIPLY ELSQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      ITUV = 0
      DO MTUV=0,LAMAB
        PHASE = DFLOAT((IPHS)**(MTUV))
        DO MDUM=1,(MTUV+1)*(MTUV+2)/2
          ITUV = ITUV + 1
          DO M=1,NFLAB(1)*NFLAB(2)
            DO IQ=1,3
               E21(M,ITUV,IQ) = PHASE*E21(M,ITUV,IQ)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EQLL(ELL,EXL,COORD,KQN,MQN,NBAS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                EEEEEEEE  QQQQQQ    LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EEEEEE  QQ      QQ  LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EEEEEEEE  QQQQQQ QQ LLLLLLLL LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLL EVALUATES THE EQ-COEFFICIENTS FOR LARGE-LARGE CHARGE OVERLAP   C
C  OF G-SPINOR FUNCTIONS FOR ALL PAULI MATRICES IQ = {0,1,2,3}.        C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION NBAS(2),KQN(2),JQN(2),LQN(2),MQN(2),LLAB(2),MLAB(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),TEMP(MB2),COORD(3,2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELL(MB2,MEQ),ESG(MB2,MEQ)
C
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THRESHOLD FOR CG-SCREENING PROCESS
      SENS = 1.0D-10
C
C     TOTAL ANGULAR MOMENTUM QUANTUM NUMBER
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
      RJ10   = DFLOAT(2*JQN(1))
      RJ20   = DFLOAT(2*JQN(2))
      RJ12   = DFLOAT(2*(JQN(1)+2))
      RJ22   = DFLOAT(2*(JQN(2)+2))
C
C     MAP KAPPA QUANTUM NUMBERS ONTO LQN QUANTUM NUMBERS, AND
C     CALCULATE THE APPROPRIATE CLEBSCH GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
        CAU    = DSQRT(DFLOAT(JQN(1)+MQN(1))/RJ10)
        CAL    = DSQRT(DFLOAT(JQN(1)-MQN(1))/RJ10)
      ELSE
        LQN(1) = KQN(1)
        CAU    =-DSQRT(DFLOAT(JQN(1)+2-MQN(1))/RJ12)
        CAL    = DSQRT(DFLOAT(JQN(1)+2+MQN(1))/RJ12)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
        CBU    = DSQRT(DFLOAT(JQN(2)+MQN(2))/RJ20)
        CBL    = DSQRT(DFLOAT(JQN(2)-MQN(2))/RJ20)
      ELSE
        LQN(2) = KQN(2)
        CBU    =-DSQRT(DFLOAT(JQN(2)+2-MQN(2))/RJ22)
        CBL    = DSQRT(DFLOAT(JQN(2)+2+MQN(2))/RJ22)
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTER
      MAXM = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     INITIALIZE COMMON GEOMETRICAL INFORMATION                        C
C -------------------------------------------------------------------- C
C     RKAB.EQ.1 -> INCORPORATE RKAB(M) INTO COEFFICIENTS               C
C     RKAB.NE.1 -> SET ALL RKAB(M) = (1.0D0,0.0D0)                     C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTERS A AND B
      AB2 = (COORD(1,1)-COORD(1,2))**2 + (COORD(2,1)-COORD(2,2))**2
     &                                 + (COORD(3,1)-COORD(3,2))**2
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        EXPA = EXL(IBAS,1)
        DO JBAS=1,NBAS(2)
          EXPB    = EXL(JBAS,2)
          M       = M + 1
          PAB     = EXPA + EXPB
          PX      = (EXPA*COORD(1,1) + EXPB*COORD(1,2))/PAB
          PY      = (EXPA*COORD(2,1) + EXPB*COORD(2,2))/PAB
          PZ      = (EXPA*COORD(3,1) + EXPB*COORD(3,2))/PAB
          P(M)    = PAB
          P2(M)   = PAB*2.0D0
          P22(M)  = P2(M)*P2(M)
          PAX(M)  = PX - COORD(1,1)
          PAY(M)  = PY - COORD(2,1)
          PAZ(M)  = PZ - COORD(3,1)
          PBX(M)  = PX - COORD(1,2)
          PBY(M)  = PY - COORD(2,2)
          PBZ(M)  = PZ - COORD(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXPA*EXPB*AB2)/PAB)
        ENDDO
      ENDDO
C
C     INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
      LAM  = LQN(1)+LQN(2)
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     INITIALIZE THE COEFFICIENTS TO ZERO
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ELL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS FROM MQN PAIRS                      C
C**********************************************************************C
C
C     BASIS PAIR LQNS
      LLAB(1) = LQN(1)
      LLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR SIGMA_0,Z
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
        CLEBSCH = CAU*CBU
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELLQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         FIRST CONTRIBUTION TO SIGMA_0
          IF(IQ.EQ.0) THEN
            DO ITUV=1,NTUV
              DO M=1,MAXM
                ELL(M,ITUV) = ELL(M,ITUV) + CLEBSCH*ESG(M,ITUV)
              ENDDO
            ENDDO
          ENDIF
C
C         FIRST CONTRIBUTION TO SIGMA_Z
          IF(IQ.EQ.3) THEN
            DO ITUV=1,NTUV
              DO M=1,MAXM
                ELL(M,ITUV) = ELL(M,ITUV) + CLEBSCH*ESG(M,ITUV)
              ENDDO
            ENDDO
          ENDIF
C
        ENDIF
C
C >>    TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
        CLEBSCH = CAL*CBL
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELLQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         SECOND CONTRIBUTION TO SIGMA_0
          IF(IQ.EQ.0) THEN
            DO ITUV=1,NTUV
              DO M=1,MAXM
                ELL(M,ITUV) = ELL(M,ITUV) + CLEBSCH*ESG(M,ITUV)
              ENDDO
            ENDDO
          ENDIF
C
C         SECOND CONTRIBUTION TO SIGMA_0
          IF(IQ.EQ.3) THEN
            DO ITUV=1,NTUV
              DO M=1,MAXM
                ELL(M,ITUV) = ELL(M,ITUV) - CLEBSCH*ESG(M,ITUV)
              ENDDO
            ENDDO
          ENDIF
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X,Y
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
        CLEBSCH = CAU*CBL
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELLQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         FIRST CONTRIBUTION TO SIGMA_X
          IF(IQ.EQ.1) THEN
            DO ITUV=1,NTUV
              DO M=1,MAXM
                ELL(M,ITUV) = ELL(M,ITUV) + CLEBSCH*ESG(M,ITUV)
              ENDDO
            ENDDO
          ENDIF
C
C         FIRST CONTRIBUTION TO SIGMA_Y
          IF(IQ.EQ.2) THEN
            DO ITUV=1,NTUV
              DO M=1,MAXM
                ELL(M,ITUV) = ELL(M,ITUV) - CLEBSCH*ESG(M,ITUV)
              ENDDO
            ENDDO
          ENDIF
C
        ENDIF
C
C >>    TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
        CLEBSCH = CAL*CBU
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELLQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         SECOND CONTRIBUTION TO SIGMA_X
          IF(IQ.EQ.1) THEN
            DO ITUV=1,NTUV
              DO M=1,MAXM
                ELL(M,ITUV) = ELL(M,ITUV) + CLEBSCH*ESG(M,ITUV)
              ENDDO
            ENDDO
          ENDIF
C
C         SECOND CONTRIBUTION TO SIGMA_Y
          IF(IQ.EQ.2) THEN
            DO ITUV=1,NTUV
              DO M=1,MAXM
                ELL(M,ITUV) = ELL(M,ITUV) + CLEBSCH*ESG(M,ITUV)
              ENDDO
            ENDDO
          ENDIF
C
        ENDIF
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     GENERATE LARGE-LARGE NORMALISATION CONSTANTS
      CALL RNLL(RNORM,EXL,LQN,NBAS)
C
C     PRODUCT OF NORMALISATION CONSTANTS
      M=0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M       = M+1
          TEMP(M) = RNORM(IBAS,1)*RNORM(JBAS,2)
        ENDDO
      ENDDO
C
C     MULTIPLY CONSTANTS BY THE ELL0 COEFFICIENTS
C     REMEMBER THAT SIGMA_Y NEEDS AN EXTRA FACTOR OF i
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ELL(M,ITUV) = TEMP(M)*ELL(M,ITUV)
          IF(IQ.EQ.2) THEN
            ELL(M,ITUV) = ELL(M,ITUV)*CONE
          ENDIF
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE EQSS(ESS,EXL,COORD,KQN,MQN,NBAS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS   SSSSSS                  C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EE      QQ      QQ SS       SS                       C
C                 EEEEEE  QQ      QQ  SSSSSS   SSSSSS                  C
C                 EE      QQ      QQ       SS       SS                 C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS   SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSS EVALUATES THE EQ-COEFFICIENTS FOR SMALL-SMALL CHARGE OVERLAP   C
C  OF G-SPINOR FUNCTIONS FOR ALL PAULI MATRICES IQ = {0,1,2,3}.        C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION NBAS(2),KQN(2),JQN(2),LQN(2),MQN(2),LLAB(2),MLAB(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),TEMP(MB2),COORD(3,2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THRESHOLD FOR CG-SCREENING PROCESS
      SENS = 1.0D-10
C
C     TOTAL ANGULAR MOMENTUM QUANTUM NUMBER
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
      RJ10   = DFLOAT(2*JQN(1))
      RJ20   = DFLOAT(2*JQN(2))
      RJ12   = DFLOAT(2*(JQN(1)+2))
      RJ22   = DFLOAT(2*(JQN(2)+2))
C
C     MAP KAPPA QUANTUM NUMBERS ONTO LQN QUANTUM NUMBERS
C     CALCULATE THE APPROPRIATE CLEBSCH GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
        CAU    =-DSQRT(DFLOAT(JQN(1)+2-MQN(1))/RJ12)
        CAL    = DSQRT(DFLOAT(JQN(1)+2+MQN(1))/RJ12)
      ELSE
        LQN(1) = KQN(1)
        CAU    = DSQRT(DFLOAT(JQN(1)+MQN(1))/RJ10)
        CAL    = DSQRT(DFLOAT(JQN(1)-MQN(1))/RJ10)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
        CBU    =-DSQRT(DFLOAT(JQN(2)+2-MQN(2))/RJ22)
        CBL    = DSQRT(DFLOAT(JQN(2)+2+MQN(2))/RJ22)
      ELSE
        LQN(2) = KQN(2)
        CBU    = DSQRT(DFLOAT(JQN(2)+MQN(2))/RJ20)
        CBL    = DSQRT(DFLOAT(JQN(2)-MQN(2))/RJ20)
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTER
      MAXM = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     INITIALIZE COMMON GEOMETRICAL INFORMATION                        C
C -------------------------------------------------------------------- C
C     RKAB.EQ.1 -> INCORPORATE RKAB(M) INTO COEFFICIENTS               C
C     RKAB.NE.1 -> SET ALL RKAB(M) = (1.0D0,0.0D0)                     C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTERS A AND B
      AB2 = (COORD(1,1)-COORD(1,2))**2 + (COORD(2,1)-COORD(2,2))**2
     &                                 + (COORD(3,1)-COORD(3,2))**2
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        EXPA = EXL(IBAS,1)
        DO JBAS=1,NBAS(2)
          M       = M + 1
          EXPB    = EXL(JBAS,2)
          PAB     = EXPA + EXPB
          PX      = (EXPA*COORD(1,1) + EXPB*COORD(1,2))/PAB
          PY      = (EXPA*COORD(2,1) + EXPB*COORD(2,2))/PAB
          PZ      = (EXPA*COORD(3,1) + EXPB*COORD(3,2))/PAB
          P(M)    = PAB
          P2(M)   = PAB*2.0D0
          P22(M)  = P2(M)*P2(M)
          PAX(M)  = PX - COORD(1,1)
          PAY(M)  = PY - COORD(2,1)
          PAZ(M)  = PZ - COORD(3,1)
          PBX(M)  = PX - COORD(1,2)
          PBY(M)  = PY - COORD(2,2)
          PBZ(M)  = PZ - COORD(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXPA*EXPB*AB2)/PAB)
        ENDDO
      ENDDO
C
C     MAXIMAL INDEX SUMMATION TERMINAL USED IN THIS ROUTINE
      LAM  = LQN(1)+LQN(2)+2
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     INITIALIZE THE COEFFICIENTS TO ZERO
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ESS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(1).LT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.AND.KQN(2).LT.0) THEN
C
C       BASIS PAIR LQNS
        LLAB(1) = LQN(1)+1
        LLAB(2) = LQN(2)+1
C
C       TERMS 11 AND 22 ARE ONLY NECESSARY FOR SIGMA_0,Z
        IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>      TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_0
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF

        ENDIF
C
C       TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X,Y
        IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>      TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
      ENDIF
C
C**********************************************************************C
C     CASE 2: KQN(1).LT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.AND.KQN(2).GT.0) THEN
C
C       BASIS PAIR LQNS
        LLAB(1) = LQN(1)+1
        LLAB(2) = LQN(2)-1
C
C       TERMS 11 AND 22 ARE ONLY NECESSARY FOR SIGMA_0,Z
        IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>      TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(2)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM,MAXM,2)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)+2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(2)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM,MAXM,2)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)+2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M + 1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
C       TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X,Y
        IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>      TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(2)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M + 1
                TEMP(M) = PREFAC*EXL(IBAS,1)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=0,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+1
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM-1,MAXM,2)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=0,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(2)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=0,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+1
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM-1,MAXM,2)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M + 1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=0,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
      ENDIF
C
C**********************************************************************C
C     CASE 3: KQN(1).GT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.AND.KQN(2).LT.0) THEN
C
C       BASIS PAIR LQNS
        LLAB(1) = LQN(1)-1
        LLAB(2) = LQN(2)+1
C
C       TERMS 11 AND 22 ARE ONLY NECESSARY FOR SIGMA_0,Z
        IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>      TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(1)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM,MAXM,1)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)+2
            NTUV  = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(1)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM,MAXM,1)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)+2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M + 1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
C       TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X,Y
        IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>      TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(1)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=0,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+1
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM-1,MAXM,1)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=0,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(1)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=0,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+1
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM-1,MAXM,1)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M       = M + 1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=0,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
      ENDIF
C
C**********************************************************************C
C     CASE 4: KQN(1).GT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.AND.KQN(2).GT.0) THEN
C
C       BASIS PAIR LQNS
        LLAB(1) = LQN(1)-1
        LLAB(2) = LQN(2)-1
C
C       TERMS 11 AND 22 ARE ONLY NECESSARY FOR SIGMA_0,Z
        IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>      TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)-2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = DFLOAT((2*LQN(1)+1)*(2*LQN(2)+1))*CLEBSCH
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + PREFAC*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + PREFAC*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE FOR THE A CENTER
            CALL STEPN(ESG,ENSG,LAM,MAXM,1)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            NTUV  = (LAM+3)*(LAM+4)*(LAM+5)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(2)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=1,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=1,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE FOR THE B CENTER
            CALL STEPN(ESG,ENSG,LAM,MAXM,2)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(1)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            NTUV  = (LAM+3)*(LAM+4)*(LAM+5)/6
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE INDEX N IN ENSG ARRAY (CURRENTLY WITH [N=0,N'=1])
C           BY ONE ON THE A CENTER, SO THAT IT OVERWRITES ESG VALUES AND
C           PROVIDES ES-COEFFICIENTS WITH [N=1,N'=1]. (LAM -> LAM + 2)
            CALL STEPN(ENSG,ESG,LAM+2,MAXM,1)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            NTUV  = (LAM+5)*(LAM+6)*(LAM+7)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=1,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=1,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)-2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = DFLOAT((2*LQN(1)+1)*(2*LQN(2)+1))*CLEBSCH
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + PREFAC*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - PREFAC*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE FOR THE A CENTER
            CALL STEPN(ESG,ENSG,LAM,MAXM,1)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            NTUV  = (LAM+3)*(LAM+4)*(LAM+5)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(2)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=1,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=1,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE FOR THE B CENTER
            CALL STEPN(ESG,ENSG,LAM,MAXM,2)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            NTUV  = (LAM+3)*(LAM+4)*(LAM+5)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(1)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE INDEX N IN ENSG ARRAY (CURRENTLY WITH [N=0,N'=1])
C           BY ONE ON THE A CENTER, SO THAT IT OVERWRITES ESG VALUES AND
C           PROVIDES ES-COEFFICIENTS WITH [N=1,N'=1]. (LAM -> LAM + 2)
            CALL STEPN(ENSG,ESG,LAM+2,MAXM,1)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            NTUV  = (LAM+5)*(LAM+6)*(LAM+7)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=1,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=1,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
C       TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X,Y
        IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>      TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = DFLOAT((2*LQN(1)+1)*(2*LQN(2)+1))*CLEBSCH
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=0,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + PREFAC*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - PREFAC*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE THE INDEX N BY ONE FOR THE A CENTER FOR [N=1,N'=0]
            CALL STEPN(ESG,ENSG,LAM-2,MAXM,1)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(2)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=1,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=1,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE THE INDEX N BY ONE FOR THE B CENTER FOR [N=0,N'=1]
            CALL STEPN(ESG,ENSG,LAM-2,MAXM,2)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(1)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=0,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+4
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE INDEX N IN ENSG ARRAY (CURRENTLY WITH [N=0,N'=1])
C           BY ONE ON THE A CENTER, SO THAT IT OVERWRITES ESG VALUES AND
C           PROVIDES ES-COEFFICIENTS WITH [N=1,N'=1]. (LAM -> LAM + 2)
            CALL STEPN(ENSG,ESG,LAM-4,MAXM,1)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=1,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=1,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ESS0
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = DFLOAT((2*LQN(1)+1)*(2*LQN(2)+1))*CLEBSCH
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=0,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + PREFAC*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + PREFAC*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE THE INDEX N BY ONE FOR THE A CENTER
            CALL STEPN(ESG,ENSG,LAM-2,MAXM,1)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(2)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=1,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=1,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+2
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE THE INDEX N BY ONE FOR THE B CENTER
            CALL STEPN(ESG,ENSG,LAM-2,MAXM,2)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*DFLOAT(2*LQN(1)+1)*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=0,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)+4
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCREASE INDEX N IN ENSG ARRAY (CURRENTLY WITH [N=0,N'=1])
C           BY ONE ON THE A CENTER, SO THAT IT OVERWRITES ESG VALUES AND
C           PROVIDES ES-COEFFICIENTS WITH [N=1,N'=1]. (LAM -> LAM + 2)
            CALL STEPN(ENSG,ESG,LAM-4,MAXM,1)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC = 4.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(IBAS,1)*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=1,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=1,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ESS(M,ITUV) = ESS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     GENERATE SMALL-SMALL NORMALISATION CONSTANTS
      CALL RNSS(RNORM,EXL,LQN,NBAS)
C
C     MAXIMAL INDEX SUMMATION TERMINAL USED IN THIS ROUTINE
      LAM  = LQN(1)+LQN(2)+4
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     PRODUCT OF NORMALISATION CONSTANTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M       = M + 1
          TEMP(M) = RNORM(IBAS,1)*RNORM(JBAS,2)
        ENDDO
      ENDDO
C
C     BRING THESE COEFFICIENTS INTO THE ESSQ VALUES AND ALSO FACTOR i
C     REMEMBER THAT SIGMA_Y NEEDS AN EXTRA FACTOR OF i
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ESS(M,ITUV) = TEMP(M)*ESS(M,ITUV)
          IF(IQ.EQ.2) THEN
            ESS(M,ITUV) = ESS(M,ITUV)*CONE
          ENDIF
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE EQLS(ELS,EXL,COORD,KQN,MQN,NBAS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                EEEEEEEE  QQQQQQ    LL       SSSSSS                   C
C                EE       QQ    QQ   LL      SS    SS                  C
C                EE      QQ      QQ  LL      SS                        C
C                EEEEEE  QQ      QQ  LL       SSSSSS                   C
C                EE      QQ      QQ  LL            SS                  C
C                EE       QQ    QQ   LL      SS    SS                  C
C                EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLS EVALUATES THE EQ-COEFFICIENTS FOR LARGE-SMALL CHARGE OVERLAP   C
C  OF G-SPINOR FUNCTIONS FOR ALL PAULI MATRICES IQ = {0,1,2,3}.        C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION NBAS(2),KQN(2),JQN(2),LQN(2),MQN(2),LLAB(2),MLAB(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),TEMP(MB2),COORD(3,2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     SET CLEBSCH-GORDAN SENSITIVITY
      SENS = 1.0D-10
C
C     TOTAL ANGULAR MOMENTUM QUANTUM NUMBER
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
      RJ10   = DFLOAT(2*JQN(1))
      RJ20   = DFLOAT(2*JQN(2))
      RJ12   = DFLOAT(2*(JQN(1)+2))
      RJ22   = DFLOAT(2*(JQN(2)+2))
C
C     MAP KAPPA QUANTUM NUMBERS ONTO LQN QUANTUM NUMBERS
C     CALCULATE THE APPROPRIATE CLEBSCH GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
        CAU    = DSQRT(DFLOAT(JQN(1)+MQN(1))/RJ10)
        CAL    = DSQRT(DFLOAT(JQN(1)-MQN(1))/RJ10)
      ELSE
        LQN(1) = KQN(1)
        CAU    =-DSQRT(DFLOAT(JQN(1)+2-MQN(1))/RJ12)
        CAL    = DSQRT(DFLOAT(JQN(1)+2+MQN(1))/RJ12)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
        CBU    =-DSQRT(DFLOAT(JQN(2)+2-MQN(2))/RJ22)
        CBL    = DSQRT(DFLOAT(JQN(2)+2+MQN(2))/RJ22)
      ELSE
        LQN(2) = KQN(2)
        CBU    = DSQRT(DFLOAT(JQN(2)+MQN(2))/RJ20)
        CBL    = DSQRT(DFLOAT(JQN(2)-MQN(2))/RJ20)
      ENDIF
C
C     DETERMINE THE NUMBER OF PAIRS IN THIS BLOCK
      MAXM = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     INITIALIZE COMMON GEOMETRICAL INFORMATION                        C
C -------------------------------------------------------------------- C
C     RKAB.EQ.1 -> INCORPORATE RKAB(M) INTO COEFFICIENTS               C
C     RKAB.NE.1 -> SET ALL RKAB(M) = (1.0D0,0.0D0)                     C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTERS A AND B
      AB2 = (COORD(1,1)-COORD(1,2))**2 + (COORD(2,1)-COORD(2,2))**2
     &                                 + (COORD(3,1)-COORD(3,2))**2
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        EXPA = EXL(IBAS,1)
        DO JBAS=1,NBAS(2)
          M       = M + 1
          EXPB    = EXL(JBAS,2)
          PAB     = EXPA + EXPB
          PX      = (EXPA*COORD(1,1) + EXPB*COORD(1,2))/PAB
          PY      = (EXPA*COORD(2,1) + EXPB*COORD(2,2))/PAB
          PZ      = (EXPA*COORD(3,1) + EXPB*COORD(3,2))/PAB
          P(M)    = PAB
          P2(M)   = PAB*2.0D0
          P22(M)  = P2(M)*P2(M)
          PAX(M)  = PX - COORD(1,1)
          PAY(M)  = PY - COORD(2,1)
          PAZ(M)  = PZ - COORD(3,1)
          PBX(M)  = PX - COORD(1,2)
          PBY(M)  = PY - COORD(2,2)
          PBZ(M)  = PZ - COORD(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXPA*EXPB*AB2)/PAB)
        ENDDO
      ENDDO
C
C     MAXIMAL INDEX SUMMATION TERMINAL USED IN THIS ROUTINE
C     WHY IS THIS +3 AND NOT +1?
      LAM  = LQN(1)+LQN(2)+3
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     INITIALIZE THE COEFFICIENTS TO ZERO
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ELS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).LT.0) THEN
C
C       BASIS PAIR LQNS
        LLAB(1) = LQN(1)
        LLAB(2) = LQN(2)+1
C
C       TERMS 11 AND 22 ARE ONLY NECESSARY FOR SIGMA_0,Z
        IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>      TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
          CLEBSCH = CAU*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)+1
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_0
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
          CLEBSCH = CAL*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LLAB(1)+LLAB(2)
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
C       TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X,Y
        IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>      TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER-LOWER PRODUCT)
          CLEBSCH = CAU*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)+1
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) - TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
          ENDIF
C
C >>      TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER-UPPER PRODUCT)
          CLEBSCH = CAL*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)+1
            NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
C**********************************************************************C
C     CASE 2: KQN(2).GT.0                                              C
C**********************************************************************C
C
      ELSE
C
C       BASIS PAIR LQNS
        LLAB(1) = LQN(1)
        LLAB(2) = LQN(2)-1
C
C       TERMS 11 AND 22 ARE ONLY NECESSARY FOR SIGMA_0,Z
        IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>      TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER-UPPER PRODUCT)
          CLEBSCH = CAU*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = LAM*(LAM+1)*(LAM+2)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            FACTOR = DFLOAT(2*LQN(2)+1)*CLEBSCH
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + FACTOR*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + FACTOR*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM-1,MAXM,2)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER-LOWER PRODUCT)
          CLEBSCH = CAL*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = LAM*(LAM+1)*(LAM+2)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            FACTOR = DFLOAT(2*LQN(2)+1)*CLEBSCH
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=0]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + FACTOR*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) - FACTOR*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM,MAXM,2)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_0 FOR [N=0,N'=1]
            IF(IQ.EQ.0) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
            IF(IQ.EQ.3) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
C
C       TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X,Y
        IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>      TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)-1)/2
          MLAB(2) = (MQN(2)+1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER-LOWER PRODUCT)
          CLEBSCH = CAU*CBL
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = LAM*(LAM+1)*(LAM+2)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            FACTOR = DFLOAT(2*LQN(2)+1)*CLEBSCH
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=0,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + FACTOR*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) - FACTOR*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM-1,MAXM,2)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           FIRST CONTRIBUTION TO SIGMA_X FOR [N=0,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           FIRST CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) - TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
C
C >>      TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C         BASIS PAIR MQNS
          MLAB(1) = (MQN(1)+1)/2
          MLAB(2) = (MQN(2)-1)/2
C
C         DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER-UPPER PRODUCT)
          CLEBSCH = CAL*CBU
C
C         IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
          IF(DABS(CLEBSCH).GE.SENS) THEN
C
C           GENERATE THE ES-COEFFICIENTS
            CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = LAM*(LAM+1)*(LAM+2)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            FACTOR = DFLOAT(2*LQN(2)+1)*CLEBSCH
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=0,N'=0]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + FACTOR*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=0]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + FACTOR*ESG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           INCREASE THE INDEX N BY ONE
            CALL STEPN(ESG,ENSG,LAM-1,MAXM,2)
C
C           INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
            LAM  = LQN(1)+LQN(2)
            NTUV = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C           INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
            PREFAC =-2.0D0*CLEBSCH
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                TEMP(M) = PREFAC*EXL(JBAS,2)
              ENDDO
            ENDDO
C
C           SECOND CONTRIBUTION TO SIGMA_X FOR [N=0,N'=1]
            IF(IQ.EQ.1) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
C           SECOND CONTRIBUTION TO SIGMA_Y FOR [N=0,N'=1]
            IF(IQ.EQ.2) THEN
              DO ITUV=1,NTUV
                DO M=1,MAXM
                  ELS(M,ITUV) = ELS(M,ITUV) + TEMP(M)*ENSG(M,ITUV)
                ENDDO
              ENDDO
            ENDIF
C
          ENDIF
        ENDIF
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
      CALL RNLS(RNORM,EXL,LQN,NBAS)
C
C     MAXIMAL INDEX SUMMATION TERMINAL USED IN THIS ROUTINE
      LAM  = LQN(1)+LQN(2)+3
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE THE LS NORMALISATION FACTORS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          TEMP(M) = RNORM(IBAS,1)*RNORM(JBAS,2)
        ENDDO
      ENDDO
C
C     BRING THESE COEFFICIENTS INTO THE ELSQ VALUES AND ALSO FACTOR i
C     REMEMBER THAT SIGMA_Y NEEDS AN EXTRA FACTOR OF i
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ELS(M,ITUV) = TEMP(M)*ELS(M,ITUV)*CONE
          IF(IQ.EQ.2) THEN
            ELS(M,ITUV) = ELS(M,ITUV)*CONE
          ENDIF
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE EQLS3(ELS,EXL,COORD,KQN,MQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            EEEEEEEE  QQQQQQ    LL       SSSSSS   333333              C
C            EE       QQ    QQ   LL      SS    SS 33    33             C
C            EE      QQ      QQ  LL      SS             33             C
C            EEEEEE  QQ      QQ  LL       SSSSSS    33333              C
C            EE      QQ      QQ  LL            SS       33             C
C            EE       QQ    QQ   LL      SS    SS 33    33             C
C            EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS   333333              C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLS EVALUATES THE EQ-COEFFICIENTS FOR LARGE-SMALL CHARGE OVERLAP   C
C  OF G-SPINOR FUNCTIONS FOR ALL PAULI MATRICES IQ = {0,1,2,3}.        C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION NBAS(2),KQN(2),JQN(2),LQN(2),MQN(2),LLAB(2),MLAB(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),TEMP(MB2),COORD(3,2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELS(MB2,MEQ,3),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
      DATA SENS/1.0D-10/
C
C     IMAGINARY UNIT
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     TOTAL ANGULAR MOMENTUM QUANTUM NUMBER
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
      RJ10   = DFLOAT(2*JQN(1))
      RJ20   = DFLOAT(2*JQN(2))
      RJ12   = DFLOAT(2*(JQN(1)+2))
      RJ22   = DFLOAT(2*(JQN(2)+2))
C
C     MAP KAPPA QUANTUM NUMBERS ONTO LQN QUANTUM NUMBERS
C     CALCULATE THE APPROPRIATE CLEBSCH GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
        CAU    = DSQRT(DFLOAT(JQN(1)+MQN(1))/RJ10)
        CAL    = DSQRT(DFLOAT(JQN(1)-MQN(1))/RJ10)
      ELSE
        LQN(1) = KQN(1)
        CAU    =-DSQRT(DFLOAT(JQN(1)+2-MQN(1))/RJ12)
        CAL    = DSQRT(DFLOAT(JQN(1)+2+MQN(1))/RJ12)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
        CBU    =-DSQRT(DFLOAT(JQN(2)+2-MQN(2))/RJ22)
        CBL    = DSQRT(DFLOAT(JQN(2)+2+MQN(2))/RJ22)
      ELSE
        LQN(2) = KQN(2)
        CBU    = DSQRT(DFLOAT(JQN(2)+MQN(2))/RJ20)
        CBL    = DSQRT(DFLOAT(JQN(2)-MQN(2))/RJ20)
      ENDIF
C
C     DETERMINE THE NUMBER OF PAIRS IN THIS BLOCK
      MAXM  = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     INITIALIZE COMMON GEOMETRICAL INFORMATION                        C
C -------------------------------------------------------------------- C
C     RKAB.EQ.1 -> INCORPORATE RKAB(M) INTO COEFFICIENTS               C
C     RKAB.NE.1 -> SET ALL RKAB(M) = (1.0D0,0.0D0)                     C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTERS A AND B
      AB2 = (COORD(1,1)-COORD(1,2))**2 + (COORD(2,1)-COORD(2,2))**2
     &                                 + (COORD(3,1)-COORD(3,2))**2
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        EXPA = EXL(IBAS,1)
        DO JBAS=1,NBAS(2)
          M       = M + 1
          EXPB    = EXL(JBAS,2)
          PAB     = EXPA + EXPB
          PX      = (EXPA*COORD(1,1) + EXPB*COORD(1,2))/PAB
          PY      = (EXPA*COORD(2,1) + EXPB*COORD(2,2))/PAB
          PZ      = (EXPA*COORD(3,1) + EXPB*COORD(3,2))/PAB
          P(M)    = PAB
          P2(M)   = PAB*2.0D0
          P22(M)  = P2(M)*P2(M)
          PAX(M)  = PX - COORD(1,1)
          PAY(M)  = PY - COORD(2,1)
          PAZ(M)  = PZ - COORD(3,1)
          PBX(M)  = PX - COORD(1,2)
          PBY(M)  = PY - COORD(2,2)
          PBZ(M)  = PZ - COORD(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXPA*EXPB*AB2)/PAB)
        ENDDO
      ENDDO
C
C     MAXIMAL INDEX SUMMATION TERMINAL USED IN THIS ROUTINE
      LAM  = LQN(1)+LQN(2)+1
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     INITIALIZE THE COEFFICIENTS TO ZERO
      DO IQ=1,3
        DO ITUV=1,NTUV
          DO M=1,MAXM
            ELS(M,ITUV,IQ) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).LT.0) THEN
C
C       BASIS PAIR LQNS
        LLAB(1) = LQN(1)
        LLAB(2) = LQN(2)+1
C
C >>    TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER PRODUCT)
        CLEBSCH = CAU*CBU
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)+1
          NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          M = 0
          PREFAC =-2.0D0*CLEBSCH
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              TEMP(M) = PREFAC*EXL(JBAS,2)
            ENDDO
          ENDDO
C
C         FIRST CONTRIBUTION TO SIGMA_Z
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,3) = ELS(M,ITUV,3) + TEMP(M)*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER PRODUCT)
        CLEBSCH = CAL*CBL
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LLAB(1)+LLAB(2)
          NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          M = 0
          PREFAC =-2.0D0*CLEBSCH
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              TEMP(M) = PREFAC*EXL(JBAS,2)
            ENDDO
          ENDDO
C
C         SECOND CONTRIBUTION TO SIGMA_Z
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,3) = ELS(M,ITUV,3) - TEMP(M)*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C       TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X AND SIGMA_Y
C
C >>    TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER-LOWER PRODUCT)
        CLEBSCH = CAU*CBL
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)+1
          NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          M = 0
          PREFAC =-2.0D0*CLEBSCH
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              TEMP(M) = PREFAC*EXL(JBAS,2)
            ENDDO
          ENDDO
C
C         FIRST CONTRIBUTION TO SIGMA_X AND SIGMA_Y
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,1) = ELS(M,ITUV,1) + TEMP(M)*ESG(M,ITUV)
              ELS(M,ITUV,2) = ELS(M,ITUV,2) - TEMP(M)*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER-UPPER PRODUCT)
        CLEBSCH = CAL*CBU
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)+1
          NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          M = 0
          PREFAC =-2.0D0*CLEBSCH
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              TEMP(M) = PREFAC*EXL(JBAS,2)
            ENDDO
          ENDDO
C
C         SECOND CONTRIBUTION TO SIGMA_X AND SIGMA_Y
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,1) = ELS(M,ITUV,1) + TEMP(M)*ESG(M,ITUV)
              ELS(M,ITUV,2) = ELS(M,ITUV,2) + TEMP(M)*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C**********************************************************************C
C     CASE 2: KQN(2).GT.0                                              C
C**********************************************************************C
C
      ELSE
C
C       BASIS PAIR LQNS
        LLAB(1) = LQN(1)
        LLAB(2) = LQN(2)-1
C
C       TERMS 11 AND 22 ARE ONLY NECESSARY FOR SIGMA_0,Z
C
C >>    TERM 11: (M-1/2, M'-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER-UPPER PRODUCT)
        CLEBSCH = CAU*CBU
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)
          NTUV = LAM*(LAM+1)*(LAM+2)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          FACTOR = DFLOAT(2*LQN(2)+1)*CLEBSCH
C
C         FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,3) = ELS(M,ITUV,3) + FACTOR*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE
          CALL STEPN(ESG,ENSG,LAM-1,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)
          NTUV = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          M = 0
          PREFAC =-2.0D0*CLEBSCH
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              TEMP(M) = PREFAC*EXL(JBAS,2)
            ENDDO
          ENDDO
C
C         FIRST CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,3) = ELS(M,ITUV,3) + TEMP(M)*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (M+1/2, M'+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER-LOWER PRODUCT)
        CLEBSCH = CAL*CBL
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)
          NTUV = LAM*(LAM+1)*(LAM+2)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          FACTOR = DFLOAT(2*LQN(2)+1)*CLEBSCH
C
C         SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=0]
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,3) = ELS(M,ITUV,3) - FACTOR*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE
          CALL STEPN(ESG,ENSG,LAM,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)
          NTUV = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          M = 0
          PREFAC =-2.0D0*CLEBSCH
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              TEMP(M) = PREFAC*EXL(JBAS,2)
            ENDDO
          ENDDO
C
C         SECOND CONTRIBUTION TO SIGMA_Z FOR [N=0,N'=1]
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,3) = ELS(M,ITUV,3) - TEMP(M)*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C       TERMS 12 AND 21 ARE ONLY NECESSARY FOR SIGMA_X,Y
C
C >>    TERM 12: (M-1/2, M'+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (UPPER-LOWER PRODUCT)
        CLEBSCH = CAU*CBL
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)
          NTUV = LAM*(LAM+1)*(LAM+2)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          FACTOR = DFLOAT(2*LQN(2)+1)*CLEBSCH
C
C         FIRST CONTRIBUTION TO SIGMA_X AND SIGMA_Y FOR [N=0,N'=0]
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,1) = ELS(M,ITUV,1) + FACTOR*ESG(M,ITUV)
              ELS(M,ITUV,2) = ELS(M,ITUV,2) - FACTOR*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE
          CALL STEPN(ESG,ENSG,LAM-1,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)
          NTUV = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          M = 0
          PREFAC =-2.0D0*CLEBSCH
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              TEMP(M) = PREFAC*EXL(JBAS,2)
            ENDDO
          ENDDO
C
C         FIRST CONTRIBUTION TO SIGMA_X AND SIGMA_Y FOR [N=0,N'=1]
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,1) = ELS(M,ITUV,1) + TEMP(M)*ENSG(M,ITUV)
              ELS(M,ITUV,2) = ELS(M,ITUV,2) - TEMP(M)*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (M+1/2, M'-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQNS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       DEFINE PRODUCT OF CLEBSCH-GORDON FACTORS (LOWER-UPPER PRODUCT)
        CLEBSCH = CAL*CBU
C
C       IF THE CG COEFFICIENT IS LARGE ENOUGH, CALCULATE ELSQ
        IF(DABS(CLEBSCH).GE.SENS) THEN
C
C         GENERATE THE ES-COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)
          NTUV = LAM*(LAM+1)*(LAM+2)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          FACTOR = DFLOAT(2*LQN(2)+1)*CLEBSCH
C
C         SECOND CONTRIBUTION TO SIGMA_X AND SIGMA_Y FOR [N=0,N'=0]
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,1) = ELS(M,ITUV,1) + FACTOR*ESG(M,ITUV)
              ELS(M,ITUV,2) = ELS(M,ITUV,2) + FACTOR*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE
          CALL STEPN(ESG,ENSG,LAM-1,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM  = LQN(1)+LQN(2)
          NTUV = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C         INCORPORATE KINETIC BALANCE CONTRACTION COEFFICIENTS
          M = 0
          PREFAC =-2.0D0*CLEBSCH
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              TEMP(M) = PREFAC*EXL(JBAS,2)
            ENDDO
          ENDDO
C
C         SECOND CONTRIBUTION TO SIGMA_X AND SIGMA_Y FOR [N=0,N'=1]
          DO ITUV=1,NTUV
            DO M=1,MAXM
              ELS(M,ITUV,1) = ELS(M,ITUV,1) + TEMP(M)*ENSG(M,ITUV)
              ELS(M,ITUV,2) = ELS(M,ITUV,2) + TEMP(M)*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
      CALL RNLS(RNORM,EXL,LQN,NBAS)
C
C     MAXIMAL INDEX SUMMATION TERMINAL USED IN THIS ROUTINE
      LAM  = LQN(1)+LQN(2)+3
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE THE LS NORMALISATION FACTORS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          TEMP(M) = RNORM(IBAS,1)*RNORM(JBAS,2)
        ENDDO
      ENDDO
C
C     BRING THESE COEFFICIENTS INTO THE ELSQ VALUES AND ALSO FACTOR i
C     REMEMBER THAT SIGMA_Y NEEDS AN EXTRA FACTOR OF i
      DO IQ=1,3
        DO ITUV=1,NTUV
          DO M=1,MAXM
            ELS(M,ITUV,IQ) = CONE*TEMP(M)*ELS(M,ITUV,IQ)
            IF(IQ.EQ.2) THEN
              ELS(M,ITUV,IQ) = CONE*ELS(M,ITUV,IQ)
            ENDIF
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ESGTF(ESG,LQN,MQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              EEEEEEEE SSSSSS   GGGGGG TTTTTTTT FFFFFFFF              C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EE      SS       GG         TT    FF                    C
C              EEEEEE   SSSSSS  GG         TT    FFFFFF                C
C              EE            SS GG   GGG   TT    FF                    C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EEEEEEEE SSSSSS   GGGGGG    TT    FF                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESGTF CONSTRUCTS THE EXPANSION COEFFICIENTS OF THE OVERLAP DENSITY  C
C  OF TWO SPHERICAL HARMONIC FUNCTIONS IN AN AUXILIARY HGTF BASIS.     C
C                                                                      C
C  THE OVERLAP DENSITY IS DEFINED BY Y*[L,M]Y[L',M'], WHERE Y[L,M] ARE C
C  SPHERICAL HARMONICS FOLLOWING THE CONDON-SHORTLEY PHASE CONVENTION. C
C                                                                      C
C  THE REQUIRED COEFFICIENTS ARE GENERATED BY A CALL TO VRS, WHICH IS  C
C  CONSTRUCTED ACCORDING TO THE RECURRENCE RELATIONS DEFINED BY        C
C  V.R.SAUNDERS. THE OUTPUT OF VRS IS THEN ADJUSTED TO INCLUDE THE     C
C  ANGULAR NORMALISATION CONSTANTS, AS WELL AS A PHASE FACTOR TO       C
C  CONVERT FROM THE SCHIFF TO THE CONDON-SHORTLEY PHASE CONVENTION.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C     LQN(I) - TARGET LQN VALUES ON CENTERS A AND B.                   C
C     MQN(I) - TARGET MQN VALUES ON CENTERS A AND B.                   C
C -------------------------------------------------------------------- C
C  H.M.QUINEY THE UNIVERSITY OF MELBOURNE (2008).                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION FACT(MKP),LQN(2),MQN(2),MQNLAB(2)
C
      COMPLEX*16 ESG(MB2,MEQ)
C
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
      PI4 = 8.0D0*DASIN(1.0D0)
C
C     CALCULATE THE FACTORIAL FUNCTIONS
      LMAX = MAX(LQN(1),LQN(2))
      FACT(1) = 1.0D0
      DO M=1,2*LMAX
        FACT(M+1) = FACT(M)*DFLOAT(M)
      ENDDO
C
C     VRS IS CALLED WITH THE SIGN OF MQN(1) REVERSED
C     TO AFFECT COMPLEX CONJUGATION, ALONG WITH THE REQUISITE
C     PHASE, WHICH IS CALCULATED LATER.
      MQNLAB(1) =-MQN(1)
      MQNLAB(2) = MQN(2)
C
C     TRAP CASES FOR WHICH |MQN| EXCEEDS LQN (COULD BE CALLED BUT
C     WITH A ZERO MULTIPLICATIVE CONSTANT)
      IF(IABS(MQN(1)).GT.LQN(1).OR.IABS(MQN(2)).GT.LQN(2)) THEN
        LAMAB = LQN(1)+LQN(2)
        NTUV  = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
        DO ITUV=1,NTUV
          DO M=1,MAXM
            ESG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
        RETURN
      ELSE
        CALL VRS(ESG,LQN,MQNLAB,MAXM)
      ENDIF
C
C     IMPORT L AND BASIS PAIR MQNS
      L1 = LQN(1)
      L2 = LQN(2)
      M1 = IABS(MQN(1))
      M2 = IABS(MQN(2))
C
C     SPECIFY THE UPPER TERMINAL ON SUMMATION, AND CG COEFFICIENTS
      LAM    = LQN(1) + LQN(2)
      PREFAC = DFLOAT((2*L1+1)*(2*L2+1))
      PREFAC = PREFAC*FACT(L1-M1+1)/FACT(L1+M1+1)
      PREFAC = PREFAC*FACT(L2-M2+1)/FACT(L2+M2+1)
      PREFAC = DSQRT(PREFAC)
C     PHASE  = (-1.0D0)**(M1+M2+MQN(2))
      PHASE  = (-1.0D0)**((MQN(1)+MQN(2)+M1+M2)/2)
      PREFAC = PREFAC*PHASE/PI4
C
C     THERE ARE NTUV TOTAL TERMS IN THE SUM OVER A,B,C
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ESG(M,ITUV) = PREFAC*ESG(M,ITUV)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE VRS(ESG,LQN,MQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                      VV    VV RRRRRRR   SSSSSS                       C
C                      VV    VV RR    RR SS    SS                      C
C                      VV    VV RR    RR SS                            C
C                      VV    VV RR    RR  SSSSSS                       C
C                       VV  VV  RRRRRRR        SS                      C
C                        VVVV   RR    RR SS    SS                      C
C                         VV    RR    RR  SSSSSS                       C
C                                                                      C
C -------------------------------------------------------------------- C
C  VRS EVALUATES THE EXPANSION COEFFICIENTS OF THE OVERLAP CHARGE      C
C  DENSITY OF SGTFS IN AN AUXILIARY HGTF. COEFFICIENTS ARE EVALUATED   C
C  USING THE RECURRENCE RELATIONS DEFINED BY VIC SAUNDERS IN:          C
C                                                                      C
C  V.R.SAUNDERS,"MOLECULAR INTEGRALS FOR GAUSSIAN-TYPE FUNCTIONS",     C
C  METHODS OF COMPUTATIONAL MOLECULAR PHYSICS, ED G.H.F.DIERCKSEN AND  C
C  S.WILSON, pp 1-26, REIDEL PUBLISHING, DORDRECHT (1983).             C
C                                                                      C
C  THE E-COEFFS IN THIS PROCEDURE ARE FOR AN UN-NORMALISED SGTF.       C
C  THE COEFFICIENTS ARE DETERMINED ACCORDING TO THE SAME RULES AS      C
C  DEFINED IN THE ABOVE ARTICLE. CONSEQUENTLY, IT SHOULD BE NOTED THAT C
C  THE COEFFICIENTS ARE THOSE OF SPHERICAL HARMONIC FUNCTIONS THAT ARE C
C    (*) UN-NORMALISED                                                 C
C    (*) SATISFY THE SCHIFF PHASE CONVENTION                           C
C                                                                      C
C  THE OUTLINE FOR THE GENERATION OF E-COEFFICIENTS IS TAKEN FROM p16  C
C  OF THE ABOVE ARTICLE. EQUATION NUMBERS ARE GIVEN IN COMMENTS.       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C     LQN(I) - TARGET LQN VALUES ON CENTERS A AND B.                   C
C     MQN(I) - TARGET MQN VALUES ON CENTERS A AND B.                   C
C -------------------------------------------------------------------- C
C  H.M.QUINEY THE UNIVERSITY OF MELBOURNE (2008).                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,ITUVRS=716,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=ML2*2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION NBAS(2),LQN(2),MQN(2)
C
      COMPLEX*16 ESG(MB2,MEQ),ETEMP(MB2*MRC)
C
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     IMPORT LQN AND BASIS PAIR MQNS FOR LOCAL USE
      LQNA = LQN(1)
      LQNB = LQN(2)
      MQNA = MQN(1)
      MQNB = MQN(2)
      LMAX = LQNA + LQNB
C
C     CHECK THAT LMAX IS WITHIN THE BOUNDS OF MKP
      IF(LMAX.GT.MKP+1) THEN
        WRITE(6,20) LMAX,MKP+1
        WRITE(7,20) LMAX,MKP+1
        STOP
      ENDIF
20    FORMAT(2X,'Required value of LAMBDA = ',I3/
     &       2X,'Maximum allowed value of LAMBDA = ',I3//
     &       2X,'Reset MKP and recompile: terminating...'/)
C
C      SET INITIAL VALUES TO E[0,0;0,0;0,0,0,0] = RKAB
       DO M=1,MB2*MRC
         ETEMP(M) = DCMPLX(0.0D0,0.0D0)
       ENDDO
C
       DO M=1,MAXM
         ETEMP(M) = DCMPLX(RKAB(M),0.0D0)
       ENDDO
C
C      STEP 1:
C      GENERATE E[|MQNA|,MQNA;0,0] FROM E[0,0;0,0] USING
C      SIMULTANEOUS STEP OF LQN AND MQN ON CENTER A
       ISTART = 0
       LAM    = 0
       IF(IABS(MQNA).NE.0) THEN
         CALL STEPLM(ETEMP,LAM,ISTART,MQNA,MAXM,1)
       ENDIF
C
C      STEP 2:
C      GENERATE E[LQNA,MQNA;0,0] FROM E[|MQNA|,MQNA;0,0]
C      USING THE STEP OF LQN ONLY ON CENTER A
       IF(LQNA.GT.IABS(MQNA)) THEN
         CALL STEPL(ETEMP,LAM,ISTART,LQNA,MQNA,MAXM,1)
       ENDIF
C
C      STEP 3:
C      GENERATE E[LQNA,MQNA;|MQNB|,MQNB] FROM E[LQNA,MQNA;0,0]
C      USING SIMULTANEOUS STEP OF LQN AND MQN ON CENTER B
       IF(IABS(MQNB).GT.0) THEN
         CALL STEPLM(ETEMP,LAM,ISTART,MQNB,MAXM,2)
       ENDIF
C
C      STEP 4:
C      GENERATE E[LQNA,MQNA;LQNB,MQNB] FROM E[LQNA,MQNA;|MQNB|,MQNB]
C      USING THE STEP OF LQN ONLY ON CENTER B
       IF(LQNB.GT.IABS(MQNB)) THEN
         CALL STEPL(ETEMP,LAM,ISTART,LQNB,MQNB,MAXM,2)
       ENDIF
C
C      STEP 5:
C      COPY FINAL BLOCK OF ENTRIES AS THE REQUIRED OUTPUT
       ISTART0 = ISTART
       NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
C
       K = 0
       DO ITUV=1,NTUV
         DO M=1,MAXM
           K = K+1
           ESG(M,ITUV) = ETEMP(ISTART0+K)
         ENDDO
       ENDDO
C
       RETURN
       END
C
C
      SUBROUTINE STEPLM(ETEMP,LAM,ISTART,MQN,MAXM,ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL       MM       MM        C
C       SS    SS   TT    EE       PP    PP LL       MMM     MMM        C
C       SS         TT    EE       PP    PP LL       MMMM   MMMM        C
C        SSSSSS    TT    EEEEEE   PP    PP LL       MM MM MM MM        C
C             SS   TT    EE       PPPPPPP  LL       MM  MMM  MM        C
C       SS    SS   TT    EE       PP       LL       MM   M   MM        C
C        SSSSSS    TT    EEEEEEEE PP       LLLLLLLL MM       MM        C
C                                                                      C
C -------------------------------------------------------------------- C
C   SIMULTANEOUSLY INCREMENT/DECREMENT QUANTUM NUMBERS (LQN,MQN):      C
C               E[L, L;IT,IU,IV] -> E[L+1,L+1;IT,IU,IV]                C
C               E[L,-L;IT,IU,IV] -> E[L+1,L-1;IT,IU,IV]                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    P2(M) - CONTAINS VALUES OF P*2, P=SUM OF EXPONENTS.               C
C    PX(M) - GEOMETRICAL VALUES OF X(M)-COORD(ICNT,X).                 C
C    PY(M) - GEOMETRICAL VALUES OF Y(M)-COORD(ICNT,Y).                 C
C    MAXM  - NUMBER OF EXPONENT/DENSITY PAIRS.                         C
C    LAM   - LENGTH OF THE INPUT HGTF EXPANSION.                       C
C    LQN   - L-QUANTUM NUMBER OF THE CENTER TO BE INCREMENTED.         C
C    ICNT  - CENTER TO STEP UP.                                        C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION PX(MB2),PY(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(*)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IMPORT GEOMETRICAL VALUES FOR CENTER OF INTEREST
      DO M=1,MAXM
        IF(ICNT.EQ.1) THEN
          PX(M) = PAX(M)
          PY(M) = PAY(M)
        ELSEIF(ICNT.EQ.2) THEN
          PX(M) = PBX(M)
          PY(M) = PBY(M)
        ENDIF
      ENDDO
C
C     MAIN LOOP: FOR EACH M-QUANTUM NUMBER ON THIS CENTER
      DO 100 MVAL=0,IABS(MQN)-1
C
C**********************************************************************C
C     COMPUTE THE BLOCK INDICES. THE RECURRENCE WILL RUN OVER          C
C     (LAM+1)*(LAM+2)*(LAM+3)/6 VALUES AND WILL GENERATE               C
C     (LAM+2)*(LAM+3)*(LAM+4)/6 VALUES IN THE NEXT LAYER               C
C**********************************************************************C
C
      RL1     = DFLOAT(2*IABS(MVAL)+1)
      NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
      ISTART1 = ISTART
      ISTART2 = ISTART1+NTUV*MAXM
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C          I0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                            C
C          I1-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                            C
C          I2-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                            C
C          I3-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                            C
C          I4-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                            C
C          I5-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                            C
C**********************************************************************C
C
C     INCREMENT THE M-QUANTUM NUMBER IF MQN > 0
      IF(MQN.GT.0) THEN
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART1 + (INABCD(IT  ,IU  ,IV)-1)*MAXM
              I1 = ISTART2 + (INABCD(IT  ,IU  ,IV)-1)*MAXM
              I2 = ISTART2 + (INABCD(IT+1,IU  ,IV)-1)*MAXM
              I3 = ISTART2 + (INABCD(IT  ,IU+1,IV)-1)*MAXM
C
              DO M=1,MAXM
                 T1 = RL1/P2(M)
                 TX = RL1*PX(M)
                 TY = RL1*PY(M)
                 ETEMP(I1+M) = ETEMP(I1+M) + TX*ETEMP(I0+M)
     &                                     + TY*ETEMP(I0+M)*CONE
                 ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                 ETEMP(I3+M) = ETEMP(I3+M) + T1*ETEMP(I0+M)*CONE
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.NE.0) THEN
                I4 = ISTART2 + (INABCD(IT-1,IU,IV)-1)*MAXM
                RT = DFLOAT(IT)
                FACTOR = RT*RL1
                DO M=1,MAXM
                  ETEMP(I4+M) = ETEMP(I4+M) + FACTOR*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.NE.0) THEN
                I5 = ISTART2 + (INABCD(IT,IU-1,IV)-1)*MAXM
                RU = DFLOAT(IU)
                FACTOR = RL1*RU
                DO M=1,MAXM
                  ETEMP(I5+M) = ETEMP(I5+M) + FACTOR*ETEMP(I0+M)*CONE
                ENDDO
              ENDIF
C
C           END OF LOOPS OVER HGTF INDICES
            ENDDO
          ENDDO
        ENDDO
C
C     DECREMENT THE M-QUANTUM NUMBER IF MQN < 0
      ELSE
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C          ISTART0 LABELS THE PREVIOUS LQN VALUE                       C
C          ISTART1 LABELS THE CURRENT  LQN VALUE                       C
C          ISTART2 LABELS THE NEXT     LQN VALUE                       C
C -------------------------------------------------------------------- C
C          I0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                            C
C          I1-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                            C
C          I2-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                            C
C          I3-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                            C
C          I4-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                            C
C          I5-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                            C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART1 + (INABCD(IT  ,IU  ,IV)-1)*MAXM
              I1 = ISTART2 + (INABCD(IT  ,IU  ,IV)-1)*MAXM
              I2 = ISTART2 + (INABCD(IT+1,IU  ,IV)-1)*MAXM
              I3 = ISTART2 + (INABCD(IT  ,IU+1,IV)-1)*MAXM
C
              DO M=1,MAXM
                T1 = RL1/P2(M)
                TX = RL1*PX(M)
                TY = RL1*PY(M)
                ETEMP(I1+M) = ETEMP(I1+M) + TX*ETEMP(I0+M)
     &                                    - TY*ETEMP(I0+M)*CONE
                ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                ETEMP(I3+M) = ETEMP(I3+M) - T1*ETEMP(I0+M)*CONE
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.NE.0) THEN
                I4 = ISTART2 + (INABCD(IT-1,IU  ,IV  )-1)*MAXM
                RT = DFLOAT(IT)
                FACTOR = RT*RL1
                DO M=1,MAXM
                  ETEMP(I4+M) = ETEMP(I4+M) + FACTOR*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.NE.0) THEN
                I5 = ISTART2 + (INABCD(IT  ,IU-1,IV  )-1)*MAXM
                RU = DFLOAT(IU)
                FACTOR = RL1*RU
                DO M=1,MAXM
                  ETEMP(I5+M) = ETEMP(I5+M) - FACTOR*ETEMP(I0+M)*CONE
                ENDDO
              ENDIF
C
C             END OF LOOPS OVER HGTF INDICES
            ENDDO
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     END OF LOOP OVER MQN COUNTER. UPDATE THE VALUE OF LAM, AND       C
C     THE COUNTER THAT KEEPS TRACK OF THE BLOCKS OF E-COEFFICIENTS     C
C**********************************************************************C
C
      ISTART = ISTART + NTUV*MAXM
      LAM    = LAM + 1
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE STEPL(ETEMP,LAM,ISTART,LQN,MQN,MAXM,ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL                    C
C             SS    SS   TT    EE       PP    PP LL                    C
C             SS         TT    EE       PP    PP LL                    C
C              SSSSSS    TT    EEEEEE   PP    PP LL                    C
C                   SS   TT    EE       PPPPPPP  LL                    C
C             SS    SS   TT    EE       PP       LL                    C
C              SSSSSS    TT    EEEEEEEE PP       LLLLLLLL              C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE LQN, STARTING AT E[L, L] OR E[L,-L].                  C
C -------------------------------------------------------------------- C
C  NOTE THAT THE FIRST APPLICATION OF EQ(64a) CAN ONLY MAP             C
C  E[L,L] -> E[L+1,M] OR E[L,-L] -> E[L+1,-L] AND IS TREATED SEP'TLY.  C
C  SUBSEQUENT STEPS MAP {E[L,L], E[L-1,L]} -> E[L+1,L].                C
C  FINAL APPLICATION OF THIS RULE GENERATES E[LMAX,L;0,0;T,U,V].       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(*)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IMPORT GEOMETRICAL VALUES FOR CENTER OF INTEREST
      DO M=1,MAXM
        IF(ICNT.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(ICNT.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C**********************************************************************C
C      THE FIRST STEP IS ALWAYS PERFORMED. IT MAPS THE INDEX SETS      C
C      E[MQN+1,MQN] <- E[MQN1,MQN1] FROM THE DATA OBTAINED IN STEPLM.  C
C**********************************************************************C
C
C     IF STEPL IS ENTERED WITH LQN.LE.|MQN| CONTROL IS RETURNED
C     AND NO COUNTERS ARE UPDATED
      IF(LQN.LE.IABS(MQN)) RETURN
C
      NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
      ISTART1 = ISTART
      ISTART2 = ISTART1 + NTUV*MAXM
      RFACT1  = DFLOAT(2*IABS(MQN)+1)
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C       I0-> E[MQN  ,MQN;IT  ,IU  ,IV  ]                               C
C       I1-> E[MQN+1,MQN;IT  ,IU  ,IV  ]                               C
C       I2-> E[MQN+1,MQN;IT  ,IU  ,IV+1]                               C
C       I3-> E[MQN+1,MQN;IT  ,IU  ,IV-1]                               C
C**********************************************************************C
C
C     LOOP OVER THE HGTF INDICES OF THE SEED LAYER
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
            I0 = ISTART1 + (INABCD(IT  ,IU  ,IV  )-1)*MAXM
            I1 = ISTART2 + (INABCD(IT  ,IU  ,IV  )-1)*MAXM
            I2 = ISTART2 + (INABCD(IT  ,IU  ,IV+1)-1)*MAXM
            DO M=1,MAXM
              TZ = RFACT1*PZ(M)
              TP = RFACT1/P2(M)
              ETEMP(I1+M) = ETEMP(I1+M) + TZ*ETEMP(I0+M)
              ETEMP(I2+M) = ETEMP(I2+M) + TP*ETEMP(I0+M)
            ENDDO
            IF(IV.GE.1) THEN
              I3 = ISTART2 + (INABCD(IT  ,IU  ,IV-1)-1)*MAXM
              FACTOR = RFACT1*DFLOAT(IV)
              DO M=1,MAXM
                ETEMP(I3+M) = ETEMP(I3+M) + ETEMP(I0+M)*FACTOR
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDDO
C
C     UPDATE LAM INDEX AND BLOCK LOCATOR
      ISTART0 = ISTART
      ISTART  = ISTART + NTUV*MAXM
      LAM     = LAM + 1
C
      IF(LQN.EQ.IABS(MQN)+1) RETURN
C
C**********************************************************************C
C     SECOND AND SUBSEQUENT STEPS IN THIS RECURRENCE INVOLVE THREE     C
C     LAYERS OF COEFFICIENTS:                                          C
C     E[LQN1+1,MQN1] <- {E[LQN1,MQN1],E[LQN-1,MQN1]}                   C
C**********************************************************************C
C
      DO LQN1=IABS(MQN)+1,LQN-1
        RL1M1   = DFLOAT(LQN1-IABS(MQN)+1)
        RFACT1  = DFLOAT(2*LQN1+1)/RL1M1
        NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
        ISTART1 = ISTART
        ISTART2 = ISTART + MAXM*NTUV
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C     I0-> E[LQN  ,MQN;IT  ,IU  ,IV  ]                                 C
C     I1-> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                 C
C     I2-> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                 C
C     I3-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                 C
C**********************************************************************C
C
C       THE FIRST LOOP OVER ITUV INCLUDES ALL HGTF INDICES ON THE
C       LAYER CORRESPONDING TO THE CURRENT VALUE OF LQN1
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART1 + (INABCD(IT  ,IU  ,IV  )-1)*MAXM
              I1 = ISTART2 + (INABCD(IT  ,IU  ,IV  )-1)*MAXM
              I2 = ISTART2 + (INABCD(IT  ,IU  ,IV+1)-1)*MAXM
              DO M=1,MAXM
                TZ = RFACT1*PZ(M)
                TP = RFACT1/P2(M)
                ETEMP(I1+M) = ETEMP(I1+M) + TZ*ETEMP(I0+M)
                ETEMP(I2+M) = ETEMP(I2+M) + TP*ETEMP(I0+M)
              ENDDO
              IF(IV.GE.1) THEN
                I3 = ISTART2 + (INABCD(IT  ,IU  ,IV-1)-1)*MAXM
                FACTOR = RFACT1*DFLOAT(IV)
                DO M=1,MAXM
                  ETEMP(I3+M) = ETEMP(I3+M) + ETEMP(I0+M)*FACTOR
                ENDDO
              ENDIF
            ENDDO
          ENDDO
        ENDDO
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C     I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                                C
C     I1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                                C
C     I2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                                C
C     I3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                                C
C     I4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                                C
C     I5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                                C
C     I6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                C
C     I7 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                C
C     I8 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                                C
C     I9 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                                C
C     I10-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                C
C     I11-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                                C
C     I12-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                                C
C     I13-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                                C
C**********************************************************************C
C
C       THE SECOND LOOP OVER ITUV INCLUDES ALL HGTF INDICES ON THE
C       LAYER CORRESPONDING TO (LQN1-1)
        RFACT1 =-DFLOAT(LQN1+IABS(MQN))/DBLE(LQN1-IABS(MQN)+1)
        DO IOUTER=0,LAM-1
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART0+(INABCD(IT  ,IU  ,IV  )-1)*MAXM
              I1 = ISTART2+(INABCD(IT+2,IU  ,IV  )-1)*MAXM
              I2 = ISTART2+(INABCD(IT  ,IU+2,IV  )-1)*MAXM
              I3 = ISTART2+(INABCD(IT  ,IU  ,IV+2)-1)*MAXM
              I4 = ISTART2+(INABCD(IT+1,IU  ,IV  )-1)*MAXM
              I5 = ISTART2+(INABCD(IT  ,IU+1,IV  )-1)*MAXM
              I6 = ISTART2+(INABCD(IT  ,IU  ,IV+1)-1)*MAXM
              I7 = ISTART2+(INABCD(IT  ,IU  ,IV  )-1)*MAXM
              TI = DFLOAT(2*(IT+IU+IV)+3)
              DO M=1,MAXM
                T1 = RFACT1/P22(M)
                T0 = RFACT1/P(M)
                TX = T0*PX(M)
                TY = T0*PY(M)
                TZ = T0*PZ(M)
                TT = RFACT1*(PP(M)+TI/P2(M))
                ETEMP(I1+M) = ETEMP(I1+M) + T1*ETEMP(I0+M)
                ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                ETEMP(I3+M) = ETEMP(I3+M) + T1*ETEMP(I0+M)
                ETEMP(I4+M) = ETEMP(I4+M) + TX*ETEMP(I0+M)
                ETEMP(I5+M) = ETEMP(I5+M) + TY*ETEMP(I0+M)
                ETEMP(I6+M) = ETEMP(I6+M) + TZ*ETEMP(I0+M)
                ETEMP(I7+M) = ETEMP(I7+M) + TT*ETEMP(I0+M)
              ENDDO
              IF(IT.GE.1) THEN
                I8 = ISTART2 + (INABCD(IT-1,IU  ,IV  )-1)*MAXM
                T1 = RFACT1*DFLOAT(2*IT)
                DO M=1,MAXM
                  TX = T1*PX(M)
                  ETEMP(I8+M) = ETEMP(I8+M) + TX*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IU.GE.1) THEN
                I9 = ISTART2 + (INABCD(IT  ,IU-1,IV  )-1)*MAXM
                T1 = RFACT1*DFLOAT(2*IU)
                DO M=1,MAXM
                  TY = T1*PY(M)
                  ETEMP(I9+M) = ETEMP(I9+M) + TY*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IV.GE.1) THEN
                I10 = ISTART2 + (INABCD(IT  ,IU  ,IV-1)-1)*MAXM
                T1  = RFACT1*DFLOAT(2*IV)
                DO M=1,MAXM
                  TZ = T1*PZ(M)
                  ETEMP(I10+M) = ETEMP(I10+M) + TZ*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IT.GE.2) THEN
                I11 = ISTART2 + (INABCD(IT-2,IU  ,IV  )-1)*MAXM
                T1  = RFACT1*DFLOAT(IT*(IT-1))
                DO M=1,MAXM
                  ETEMP(I11+M) = ETEMP(I11+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IU.GE.2) THEN
                I12 = ISTART2 + (INABCD(IT  ,IU-2,IV  )-1)*MAXM
                T1  = RFACT1*DFLOAT(IU*(IU-1))
                DO M=1,MAXM
                  ETEMP(I12+M) = ETEMP(I12+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IV.GE.2) THEN
                I13 = ISTART2 + (INABCD(IT  ,IU  ,IV-2)-1)*MAXM
                T1  = RFACT1*DFLOAT(IV*(IV-1))
                DO M=1,MAXM
                  ETEMP(I13+M) = ETEMP(I13+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
        ENDDO
C
C       END OF LOOP OVER LQN1 FOR FIXED MQN
C
        LAM     = LAM+1
        ISTART0 = ISTART
        ISTART  = ISTART + MAXM*NTUV
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE STEPN(ESG,ENSG,LAM,MAXM,ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  NN    NN              C
C             SS    SS   TT    EE       PP    PP NNN   NN              C
C             SS         TT    EE       PP    PP NNNN  NN              C
C              SSSSSS    TT    EEEEEE   PP    PP NN NN NN              C
C                   SS   TT    EE       PPPPPPP  NN  NNNN              C
C             SS    SS   TT    EE       PP       NN   NNN              C
C              SSSSSS    TT    EEEEEEEE PP       NN    NN              C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE NQN, E[NQN,LQN,MQN] -> E[NQN+1,LQN,MQN].              C
C                                                                      C
C  NOTE THAT STEPN WILL ONLY PERFORM A SINGLE STEP IN NQN. IT USES AS  C
C  INPUT A SET OF PROCESSED E-COEFFICIENTS FROM VRS (ESGTFR,ESGTFI)    C
C  AND OUTPUTS THE INCREMENTED SET (ENSGTFR,ENSGTFI).                  C
C -------------------------------------------------------------------- C
C  LAM IS THE EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE INPUT COEFFS.    C
C  THE EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE OUTPUT COEFFS IS LAM+2. C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/GSPR/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     IMPORT GEOMETRICAL VALUES FOR CENTER OF INTEREST
      DO M=1,MAXM
        IF(ICNT.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(ICNT.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C     SET THE TARGET COEFFICIENTS TO ZERO, TAKING INTO ACCOUNT THE
C     INCREMENT OF LAM BY TWO UNITS IN THE TARGET
      NTUV = (LAM+3)*(LAM+4)*(LAM+5)/6
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ENSG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C                          INDEX MAPPINGS                              C
C -------------------------------------------------------------------- C
C     I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                                C
C     I1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                                C
C     I2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                                C
C     I3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                                C
C     I4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                                C
C     I5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                                C
C     I6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                C
C     I7 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                C
C     I8 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                                C
C     I9 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                                C
C     I10-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                C
C     I11-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                                C
C     I12-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                                C
C     I13-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                                C
C**********************************************************************C
C
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
            I0 = INABCD(IT  ,IU  ,IV  )
            I1 = INABCD(IT+2,IU  ,IV  )
            I2 = INABCD(IT  ,IU+2,IV  )
            I3 = INABCD(IT  ,IU  ,IV+2)
            I4 = INABCD(IT+1,IU  ,IV  )
            I5 = INABCD(IT  ,IU+1,IV  )
            I6 = INABCD(IT  ,IU  ,IV+1)
            I7 = INABCD(IT  ,IU  ,IV  )
C
            TT = DFLOAT((2*(IT+IU+IV))+3)
            DO M=1,MAXM
              T0 = 1.0D0/P22(M)
              TX = PX(M)/P(M)
              TY = PY(M)/P(M)
              TZ = PZ(M)/P(M)
              TP = PP(M) + TT/P2(M)
              ENSG(M,I1) = ENSG(M,I1) + T0*ESG(M,I0)
              ENSG(M,I2) = ENSG(M,I2) + T0*ESG(M,I0)
              ENSG(M,I3) = ENSG(M,I3) + T0*ESG(M,I0)
              ENSG(M,I4) = ENSG(M,I4) + TX*ESG(M,I0)
              ENSG(M,I5) = ENSG(M,I5) + TY*ESG(M,I0)
              ENSG(M,I6) = ENSG(M,I6) + TZ*ESG(M,I0)
              ENSG(M,I7) = ENSG(M,I7) + TP*ESG(M,I0)
            ENDDO
C
            IF(IT.GE.1) THEN
              RT2 = DFLOAT(2*IT)
              I8  = INABCD(IT-1,IU  ,IV  )
              DO M=1,MAXM
                T0 = PX(M)*RT2
                ENSG(M,I8) = ENSG(M,I8) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IU.GE.1) THEN
              RU2 = DFLOAT(2*IU)
              I9   = INABCD(IT  ,IU-1,IV  )
              DO M=1,MAXM
                T0 = PY(M)*RU2
                ENSG(M,I9) = ENSG(M,I9) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IV.GE.1) THEN
              RV2 = DFLOAT(2*IV)
              I10 = INABCD(IT  ,IU  ,IV-1)
              DO M=1,MAXM
                T0 = PZ(M)*RV2
                ENSG(M,I10) = ENSG(M,I10) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IT.GE.2) THEN
              RT2 = DFLOAT(IT*(IT-1))
              I11 = INABCD(IT-2,IU  ,IV  )
              DO M=1,MAXM
                ENSG(M,I11) = ENSG(M,I11) + RT2*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IU.GE.2) THEN
              RU2 = DFLOAT(IU*(IU-1))
              I12  = INABCD(IT  ,IU-2,IV  )
              DO M=1,MAXM
                ENSG(M,I12) = ENSG(M,I12) + RU2*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IV.GE.2) THEN
              RV2 = DFLOAT(IV*(IV-1))
              I13 = INABCD(IT  ,IU  ,IV-2)
              DO M=1,MAXM
                ENSG(M,I13) = ENSG(M,I13) + RV2*ESG(M,I0)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNLL(RNORM,EXPT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN LL       LL                        C
C                 RR    RR NNN   NN LL       LL                        C
C                 RR    RR NNNN  NN LL       LL                        C
C                 RR    RR NN NN NN LL       LL                        C
C                 RRRRRRR  NN  NNNN LL       LL                        C
C                 RR    RR NN   NNN LL       LL                        C
C                 RR    RR NN    NN LLLLLLLL LLLLLLLL                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNLL GENERATES THE LARGE-LARGE SGTF NORMALISATION CONSTANTS.        C
C**********************************************************************C
      PARAMETER(MBS=26)
C
      DIMENSION RNORM(MBS,2),EXPT(MBS,2),LQN(2),NBAS(2)
      DATA PI,TWOLOG/3.1415926535897932D0,6.93147180559945309D-1/
C
      DO ICNT=1,2
        T1  = DSQRT(PI)
        F1  = 0.5D0
        GML = DLOG(T1)
        DO M=2,LQN(ICNT)+2
          GML = GML+DLOG(F1)
          F1  = F1 + 1.0D0
        ENDDO
        RLA = DFLOAT(LQN(ICNT))
        GA1 = TWOLOG - GML
        RA1 = RLA + 1.50D0
        DO M=1,NBAS(ICNT)
          ELOG          = DLOG(2.0D0*EXPT(M,ICNT))
          RNORM(M,ICNT) = DEXP(0.5D0*(GA1 + RA1*ELOG))
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNSS(RNORM,EXPT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN  SSSSSS   SSSSSS                   C
C                 RR    RR NNN   NN SS    SS SS    SS                  C
C                 RR    RR NNNN  NN SS       SS                        C
C                 RR    RR NN NN NN  SSSSSS   SSSSSS                   C
C                 RRRRRRR  NN  NNNN       SS       SS                  C
C                 RR    RR NN   NNN SS    SS SS    SS                  C
C                 RR    RR NN    NN  SSSSSS   SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNSS GENERATES THE SMALL-SMALL SGTF NORMALISATION CONSTANTS.        C
C**********************************************************************C
      PARAMETER(MBS=26)
C
      DIMENSION RNORM(MBS,2),EXPT(MBS,2),LQN(2),NBAS(2)
      DATA PI,TWOLOG/3.1415926535897932D0,6.93147180559945309D-1/
C
      DO ICNT=1,2
        T1  = DSQRT(PI)
        F1  = 0.5D0
        GML = DLOG(T1)
        DO M=2,LQN(ICNT)+3
          GML = GML+DLOG(F1)
          F1  = F1+1.0D0
        ENDDO
        RLA = DFLOAT(LQN(ICNT))
        GA1 = TWOLOG - GML
        RA1 = RLA + 0.50D0
        DO M=1,NBAS(ICNT)
          ELOG           = DLOG(2.0D0*EXPT(M,ICNT))
          RNORM(M,ICNT) = DEXP(0.5D0*(GA1 + RA1*ELOG))
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNLS(RNORMLS,EXPT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN LL       SSSSSS                    C
C                 RR    RR NNN   NN LL      SS    SS                   C
C                 RR    RR NNNN  NN LL      SS                         C
C                 RR    RR NN NN NN LL       SSSSSS                    C
C                 RRRRRRR  NN  NNNN LL            SS                   C
C                 RR    RR NN   NNN LL      SS    SS                   C
C                 RR    RR NN    NN LLLLLLLL SSSSSS                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNLS GENERATES THE LARGE-SMALL SGTF NORMALISATION CONSTANTS.        C
C**********************************************************************C
      PARAMETER(MBS=26)
C
      DIMENSION RNORMLS(MBS,2),EXPT(MBS,2),LQN(2),NBAS(2)
      DATA PI,TWOLOG/3.1415926535897932D0,6.93147180559945309D-1/
C
      T1L  = DSQRT(PI)
      F1L  = 0.5D0
      GMLL = DLOG(T1L)
C
      DO M=2,LQN(1)+2
        GMLL = GMLL+DLOG(F1L)
        F1L  = F1L + 1.0D0
      ENDDO
C
      RLAL = DFLOAT(LQN(1))
      GA1L = TWOLOG - GMLL
      RA1L = RLAL + 1.5D0
C
      DO M=1,NBAS(1)
        ELOGL        = DLOG(2.0D0*EXPT(M,1))
        RNORMLS(M,1) = DEXP(0.5D0*(GA1L + RA1L*ELOGL))
      ENDDO
C
      T1S  = DSQRT(PI)
      F1S  = 0.5D0
      GMLS = DLOG(T1S)
C
      DO M=2,LQN(2)+3
        GMLS = GMLS + DLOG(F1S)
        F1S  = F1S + 1.0D0
      ENDDO
C
      RLAS = DFLOAT(LQN(2))
      GA1S = TWOLOG - GMLS
      RA1S = RLAS + 0.5D0
C
      DO M=1,NBAS(2)
        ELOGS        = DLOG(2.0D0*EXPT(M,2))
        RNORMLS(M,2) = DEXP(0.5D0*(GA1S+RA1S*ELOGS))
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DNORM(NMAX,ECFF,ICMP,SCL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           DDDDDDD  NN    NN  OOOOOO  RRRRRRR  MM       MM            C
C           DD    DD NNN   NN OO    OO RR    RR MMM     MMM            C
C           DD    DD NNNN  NN OO    OO RR    RR MMMM   MMMM            C
C           DD    DD NN NN NN OO    OO RR    RR MM MM MM MM            C
C           DD    DD NN  NNNN OO    OO RRRRRRR  MM  MMM  MM            C
C           DD    DD NN   NNN OO    OO RR    RR MM   M   MM            C
C           DDDDDDD  NN    NN  OOOOOO  RR    RR MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DNORM CALCULATES A SCALE NORM FOR A REAL OR COMPLEX PART OF A LIST  C
C  ECFF OF LENGTH NMAX, AND STORES THE RESULT IN SCL.                  C
C**********************************************************************C
C
      DIMENSION ECMP(NMAX)
C
      COMPLEX*16 ECFF(NMAX)
C
C     IMPORT EITHER THE REAL OR COMPLEX COMPONENT FROM ECFF
      DO N=1,NMAX
        IF(ICMP.EQ.1) THEN
          ECMP(N) = DREAL(ECFF(N))
        ELSEIF(ICMP.EQ.2) THEN
          ECMP(N) = DIMAG(ECFF(N))
        ELSE
          WRITE(6, *) 'In DNORM: choose component 1 or 2.'
          WRITE(7, *) 'In DNORM: choose component 1 or 2.'
        ENDIF
      ENDDO
C
C     INITIATE LOOP OVER ELEMENTS OF ECMP
      SSQ = 1.0D0
      SCL = 0.0D0
      DO N=1,NMAX
        IF(ECMP(N).NE.0.0D0) THEN
          ABN = DABS(ECMP(N))
          IF(SCL.LT.ABN) THEN
            SSQ = 1.0D0 + SSQ*(SCL/ABN)**2
          ELSE
            SSQ = SSQ   +     (ABN/SCL)**2
          ENDIF
        ENDIF
      ENDDO
      SCL = SCL*DSQRT(SSQ)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [13] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] SCHWARZ: APPROXIMATES UPPER BOUND OF BLOCK OF COULOMB INTS.    C
C   [B] SELFCLM: GENERATES ARRAY OF COULOMB SELF-OVERLAPS.             C
C   [C] SELFBRT: GENERATES ARRAY OF BREIT SELF-OVERLAPS.               C
C**********************************************************************C
C
C
      SUBROUTINE SCHWARZ(GDIR,SENS,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS   CCCCCC  HH    HH WW         WW    AA    RRRRRRR  ZZZZZZZZ C
C  SS    SS CC    CC HH    HH WW         WW   AAAA   RR    RR      ZZ  C
C  SS       CC       HH    HH WW         WW  AA  AA  RR    RR     ZZ   C
C   SSSSSS  CC       HHHHHHHH WW    W    WW AA    AA RR    RR    ZZ    C
C        SS CC       HH    HH  WW  WWW  WW  AAAAAAAA RRRRRRR    ZZ     C
C  SS    SS CC    CC HH    HH   WWWW WWWW   AA    AA RR    RR  ZZ      C
C   SSSSSS   CCCCCC  HH    HH    WW   WW    AA    AA RR    RR ZZZZZZZZ C
C                                                                      C
C -------------------------------------------------------------------- C
C  SCHWARZ APPROXIMATES THE UPPER BOUND TO A BLOCK OF TWO-ELECTRON     C
C  INTEGRALS AND ITS CONTRIBUTION TO THE GDIR/GXCH MATRIX.             C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    GDIR - FULL ARRAY OF PAIR-WISE MATRIX ELEMENTS.                   C
C    SENS - SENSITIVITY LIMIT FOR MAXIMUM FOCK MATRIX CONTRIBUTION.    C
C    TADD - TIME TAKEN TO RUN THIS ROUTINE.                            C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4 HMLTN
C
      DIMENSION GDIR(MDM,MDM)
      DIMENSION R(8),D(4)
      DIMENSION NBAS(4)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/DENS/DENC,DENO,DENT
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C     RESET SCREENING COUNTERS
      IBCH = 1
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
        DO ISYM=1,11
          IMTX(M,ISYM) = 1
        ENDDO
      ENDDO
      MAXN = NBAS(3)*NBAS(4)
C
C     IF TOGGLE SWITCHED OFF, DO NOT SCREEN
      IF(ITOG.EQ.0) GOTO 99
C
C     FIND LARGEST UPPER BOUND AND DENSITY PRODUCT FOR EACH M
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         DIRECT INTEGRALS
          R(1) = GDIR(NA1+IBAS,NB1+JBAS)
          R(2) = GDIR(NA1+IBAS,NB2+JBAS)
          R(3) = GDIR(NA2+IBAS,NB1+JBAS)
          R(4) = GDIR(NA2+IBAS,NB2+JBAS)
          R(5) = GDIR(NC1+KBAS,ND1+LBAS)
          R(6) = GDIR(NC1+KBAS,ND2+LBAS)
          R(7) = GDIR(NC2+KBAS,ND1+LBAS)
          R(8) = GDIR(NC2+KBAS,ND2+LBAS)
C
C         LARGEST OF THE DIRECT INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 1 AND IFLG = 2
          D(1) = ABS(DENT(NC1+KBAS,ND1+LBAS))
          D(2) = ABS(DENT(NC1+KBAS,ND2+LBAS))
          D(3) = ABS(DENT(NC2+KBAS,ND1+LBAS))
          D(4) = ABS(DENT(NC2+KBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 1) = 0
            IMTX(M, 2) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 3 AND IFLG = 4
          D(1) = ABS(DENT(NA1+IBAS,NB1+JBAS))
          D(2) = ABS(DENT(NA1+IBAS,NB2+JBAS))
          D(3) = ABS(DENT(NA2+IBAS,NB1+JBAS))
          D(4) = ABS(DENT(NA2+IBAS,NB2+JBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 3) = 0
            IMTX(M, 4) = 0
          ENDIF
C
C         EXCHANGE INTEGRALS (FIRST TYPE)
          R(1) = GDIR(NB1+JBAS,NC1+KBAS)
          R(2) = GDIR(NB1+JBAS,NC2+KBAS)
          R(3) = GDIR(NB2+JBAS,NC1+KBAS)
          R(4) = GDIR(NB2+JBAS,NC2+KBAS)
          R(5) = GDIR(NA1+IBAS,ND1+LBAS)
          R(6) = GDIR(NA1+IBAS,ND2+LBAS)
          R(7) = GDIR(NA2+IBAS,ND1+LBAS)
          R(8) = GDIR(NA2+IBAS,ND2+LBAS)
C
C         LARGEST OF THE EXCHANGE INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 8 AND IFLG = 9
          D(1) = ABS(DENT(NA1+IBAS,ND1+LBAS))
          D(2) = ABS(DENT(NA1+IBAS,ND2+LBAS))
          D(3) = ABS(DENT(NA2+IBAS,ND1+LBAS))
          D(4) = ABS(DENT(NA2+IBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 8) = 0
            IMTX(M, 9) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 5
          D(1) = ABS(DENT(NB1+JBAS,NC1+KBAS))
          D(2) = ABS(DENT(NB1+JBAS,NC2+KBAS))
          D(3) = ABS(DENT(NB2+JBAS,NC1+KBAS))
          D(4) = ABS(DENT(NB2+JBAS,NC2+KBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 5) = 0
          ENDIF
C
C         EXCHANGE INTEGRALS (SECOND TYPE)
          R(1) = GDIR(NB1+JBAS,ND1+LBAS)
          R(2) = GDIR(NB1+JBAS,ND2+LBAS)
          R(3) = GDIR(NB2+JBAS,ND1+LBAS)
          R(4) = GDIR(NB2+JBAS,ND2+LBAS)
          R(5) = GDIR(NA1+IBAS,NC1+KBAS)
          R(6) = GDIR(NA1+IBAS,NC2+KBAS)
          R(7) = GDIR(NA2+IBAS,NC1+KBAS)
          R(8) = GDIR(NA2+IBAS,NC2+KBAS)
C
C         LARGEST OF THE EXCHANGE INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 7 AND IFLG = 11
          D(1) = ABS(DENT(NA1+IBAS,NC1+KBAS))
          D(2) = ABS(DENT(NA1+IBAS,NC2+KBAS))
          D(3) = ABS(DENT(NA2+IBAS,NC1+KBAS))
          D(4) = ABS(DENT(NA2+IBAS,NC2+KBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 7) = 0
            IMTX(M,11) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 6 AND IFLG = 10
          D(1) = ABS(DENT(NB1+JBAS,ND1+LBAS))
          D(2) = ABS(DENT(NB1+JBAS,ND2+LBAS))
          D(3) = ABS(DENT(NB2+JBAS,ND1+LBAS))
          D(4) = ABS(DENT(NB2+JBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 6) = 0
            IMTX(M,10) = 0
          ENDIF
C
C         SCREEN THIS BATCH M
          ISCR(M) = 0
          GOTO 1001
C
C         SCREENING FAILED FOR THIS BATCH
1000      CONTINUE
          N = N+1
          IMAP(N) = M
          ISCR(M) = 1
C
1001      CONTINUE
C
        ENDDO
      ENDDO
C
C     NUMBER OF INTEGRALS TO CALCULATE
      MAXN = N
C
C     NONE OF THE ELEMENTS WERE ABOVE SENSITIVITY LIMIT
      IF(N.EQ.0) THEN
        IBCH = 0
      ENDIF
C
C     SKIP POINT WHEN SCREENING COUNTER SWITCHED OFF
99    CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
      SUBROUTINE SELFCLM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  EEEEEEEE LL       FFFFFFFF  CCCCCC  LL       MM       MM  C
C   SS    SS EE       LL       FF       CC    CC LL       MMM     MMM  C
C   SS       EE       LL       FF       CC       LL       MMMM   MMMM  C
C    SSSSSS  EEEEEE   LL       FFFFFF   CC       LL       MM MM MM MM  C
C         SS EE       LL       FF       CC       LL       MM  MMM  MM  C
C   SS    SS EE       LL       FF       CC    CC LL       MM   M   MM  C
C    SSSSSS  EEEEEEEE LLLLLLLL FF        CCCCCC  LLLLLLLL MM       MM  C
C                                                                      C
C -------------------------------------------------------------------- C
C  SELFCLM GENERATES DIAGONAL COULOMB INTERACTION ELEMENTS FOR LATER   C
C  USE IN THE SCHWARZ INEQUALITY IN SCREENING PROCEDURES.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000)
C
      CHARACTER*4 HMLTN
      CHARACTER*80 TITLE
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION GDSC(MDM,MDM),BDSC(MDM,MDM)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/SWRZ/GDSC,BDSC
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      IERC = 0
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLTN.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLTN.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDSC(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTERS (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER CENTER C
      DO 1100 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTER C'
        XYZ(1,3) = COORD(1,ICNTC)
        XYZ(2,3) = COORD(2,ICNTC)
        XYZ(3,3) = COORD(3,ICNTC)
C
        IF(ICNTC.NE.ICNTA) GOTO 1101
C
C     LOOP OVER CENTER D
      DO 1200 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTER D'
        XYZ(1,4) = COORD(1,ICNTD)
        XYZ(2,4) = COORD(2,ICNTD)
        XYZ(3,4) = COORD(3,ICNTD)
C
        IF(ICNTD.NE.ICNTB) GOTO 1201
C
C**********************************************************************C
C     LOOP OVER ALL KQNS (INDEX 2000)                                  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2100 KC=1,NKAP(ICNTC)
C
        IF(KC.NE.KA) GOTO 2101
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KVALS(KC,ICNTC)
        IF(KQN(3).GT.0) THEN
          LQN(3) = KQN(3)
        ELSE
          LQN(3) =-KQN(3)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFUNCT(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = EXPSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2200 KD=1,NKAP(ICNTD)
C
        IF(KD.NE.KB) GOTO 2201
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KVALS(KD,ICNTD)
        IF(KQN(4).GT.0) THEN
          LQN(4) = KQN(4)
        ELSE
          LQN(4) =-KQN(4)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFUNCT(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = EXPSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| VALUES (INDEX 3000)                          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3100 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      IF(MC.NE.MA) GOTO 3101
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3200 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
      IF(MD.NE.MB) GOTO 3201
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND C: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSHIFT
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR B AND D: TT = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSHIFT
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = (2*IT1+IT2)/3
C
C**********************************************************************C
C     MATRIX ADDRESS ALLOCATION                                        C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LARGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LARGE(ICNTB,KB,2*MB-1) + NADDCD
C
      NA2 = LARGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LARGE(ICNTB,KB,2*MB  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B.                     C
C     INCLUDE A BATCH OF ELECTRON REPULSION INTEGRALS INTO GMAT/QMAT.  C
C     NO EFFORT HAS BEEN MADE TO UTILISE INTEGRAL SYMMETRY BECAUSE     C
C     ROUTINE TAKES ALMOST NO TIME TO RUN AND IS NEEDED ONLY ONCE.     C
C**********************************************************************C
C
C     LOOP OVER ELEMENTS OF FOCK MATRIX BLOCK
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         RESET SCREENING COUNTERS
          DO M=1,NBAS(3)*NBAS(4)
            IMAP(M) = M
            ISCR(M) = 1
          ENDDO
C
C         GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
          CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
C
C         MOST OF THIS ERI WORK IS WASTED -- WANT IBAS=KBAS, JBAS=LBAS.
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
C
C             NOTE THAT (--|--) = (++|++) AND (-+|-+) = (+-|+-)
              IF(IBAS.EQ.KBAS.AND.JBAS.EQ.LBAS) THEN
                GDSC(NA1+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M, 1)))
                GDSC(NA1+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M, 6)))
                GDSC(NA2+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M,11)))
                GDSC(NA2+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M,16)))
              ENDIF
C
C           END LOOP OVER KBAS AND LBAS
            ENDDO
          ENDDO
C
C         END LOOP OVER IBAS AND JBAS
        ENDDO
      ENDDO
C
C     END LOOP OVER COMPONENT OVERLAPS
4000  CONTINUE
C     END LOOP OVER |MQN| VALUES
3201  CONTINUE
3200  CONTINUE
3101  CONTINUE
3100  CONTINUE
3000  CONTINUE
C     END LOOP OVER KQNS
2201  CONTINUE
2200  CONTINUE
2101  CONTINUE
2100  CONTINUE
2000  CONTINUE
C     END LOOP OVER CENTERS
1201  CONTINUE
1200  CONTINUE
1101  CONTINUE
1100  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     SELF-COULOMB MATRIX COMPLETE.                                    C
C**********************************************************************C
C
      TITLE = 'GDSC_ARRAY'
C     CALL ARRYPLT(GDSC,TITLE,NDIM)

      RETURN
      END
C
C
      SUBROUTINE SELFBRT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS  EEEEEEEE LL       FFFFFFFF BBBBBBB  RRRRRRR TTTTTTTT    C
C     SS    SS EE       LL       FF       BB    BB RR    RR   TT       C
C     SS       EE       LL       FF       BB    BB RR    RR   TT       C
C      SSSSSS  EEEEEE   LL       FFFFFF   BBBBBBB  RR    RR   TT       C
C           SS EE       LL       FF       BB    BB RRRRRRR    TT       C
C     SS    SS EE       LL       FF       BB    BB RR    RR   TT       C
C      SSSSSS  EEEEEEEE LLLLLLLL FF       BBBBBBB  RR    RR   TT       C
C                                                                      C
C -------------------------------------------------------------------- C
C  SELFBRT GENERATES DIAGONAL BREIT INTERACTION ELEMENTS FOR LATER     C
C  USE IN THE SCHWARZ INEQUALITY IN SCREENING PROCEDURES.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=6,MKP=9,MFL=10000000)
C
      CHARACTER*4 HMLTN
      CHARACTER*80 TITLE
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION GDSC(MDM,MDM),BDSC(MDM,MDM)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/PRMS/CV,HMLTN,ITREE,IMOL,INEW,IEQS,IERC,IPAR,ICOR,ILEV
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SPEC/EXPSET(MBS,MKP,MCT),COORD(3,MCT),ZNUC(MCT),AMASS(MCT),
     &            CNUC(MCT),PNUC,LARGE(MCT,MKP,MKP+1),NFUNCT(MKP,MCT),
     &            KVALS(MKP,MCT),IZNUC(MCT),IQNUC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSHIFT,NOCC,NVRT
      COMMON/SWRZ/GDSC,BDSC
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      IERC = 0
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLTN.NE.'DHFP'.AND.HMLTN.NE.'DHFB'.AND.HMLTN.NE.'DHFQ') THEN
        RETURN
      ELSE
        ITSTRT = 2
        ITSTOP = 3
        ITSKIP = 1
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDSC(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTERS (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER CENTER A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER A
        XYZ(1,1) = COORD(1,ICNTA)
        XYZ(2,1) = COORD(2,ICNTA)
        XYZ(3,1) = COORD(3,ICNTA)
C
C     LOOP OVER CENTER B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTER B
        XYZ(1,2) = COORD(1,ICNTB)
        XYZ(2,2) = COORD(2,ICNTB)
        XYZ(3,2) = COORD(3,ICNTB)
C
C     LOOP OVER CENTER C
      DO 1100 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTER C'
        XYZ(1,3) = COORD(1,ICNTC)
        XYZ(2,3) = COORD(2,ICNTC)
        XYZ(3,3) = COORD(3,ICNTC)
C
        IF(ICNTC.NE.ICNTA) GOTO 1101
C
C     LOOP OVER CENTER D
      DO 1200 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTER D'
        XYZ(1,4) = COORD(1,ICNTD)
        XYZ(2,4) = COORD(2,ICNTD)
        XYZ(3,4) = COORD(3,ICNTD)
C
        IF(ICNTD.NE.ICNTB) GOTO 1201
C
C**********************************************************************C
C     LOOP OVER ALL KQNS (INDEX 2000)                                  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KVALS(KA,ICNTA)
        IF(KQN(1).GT.0) THEN
          LQN(1) = KQN(1)
        ELSE
          LQN(1) =-KQN(1)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFUNCT(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = EXPSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KVALS(KB,ICNTB)
        IF(KQN(2).GT.0) THEN
          LQN(2) = KQN(2)
        ELSE
          LQN(2) =-KQN(2)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFUNCT(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = EXPSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2100 KC=1,NKAP(ICNTC)
C
        IF(KC.NE.KA) GOTO 2101
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KVALS(KC,ICNTC)
        IF(KQN(3).GT.0) THEN
          LQN(3) = KQN(3)
        ELSE
          LQN(3) =-KQN(3)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFUNCT(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = EXPSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2200 KD=1,NKAP(ICNTD)
C
        IF(KD.NE.KB) GOTO 2201
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KVALS(KD,ICNTD)
        IF(KQN(4).GT.0) THEN
          LQN(4) = KQN(4)
        ELSE
          LQN(4) =-KQN(4)-1
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFUNCT(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = EXPSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| VALUES (INDEX 3000)                          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3100 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      IF(MC.NE.MA) GOTO 3101
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3200 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
      IF(MD.NE.MB) GOTO 3201
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND C: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.2) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSHIFT
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR B AND D: TT = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.2) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSHIFT
        ENDIF
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1

C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = (2*IT1+IT2)/3
C
C**********************************************************************C
C     MATRIX ADDRESS ALLOCATION                                        C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LARGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LARGE(ICNTB,KB,2*MB-1) + NADDCD
C
      NA2 = LARGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LARGE(ICNTB,KB,2*MB  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B.                     C
C     INCLUDE A BATCH OF ELECTRON REPULSION INTEGRALS INTO BMAT.       C
C     NO EFFORT HAS BEEN MADE TO UTILISE INTEGRAL SYMMETRY BECAUSE     C
C     ROUTINE TAKES ALMOST NO TIME TO RUN AND IS NEEDED ONLY ONCE.     C
C**********************************************************************C
C
C     LOOP OVER ELEMENTS OF FOCK MATRIX BLOCK
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         RESET SCREENING COUNTERS
          DO M=1,NBAS(3)*NBAS(4)
            IMAP(M) = M
            ISCR(M) = 1
          ENDDO
C
C         GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
          CALL BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
C
C         MOST OF THIS ERI WORK IS WASTED -- WANT IBAS=KBAS, JBAS=LBAS.
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
C
C             NOTE THAT (--|++) = (++|--) AND (-+|+-) = (+-|-+)
              IF(IBAS.EQ.KBAS.AND.JBAS.EQ.LBAS) THEN
                BDSC(NA1+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M, 4)))
                BDSC(NA1+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M, 7)))
                BDSC(NA2+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M,10)))
                BDSC(NA2+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M,13)))
              ENDIF
C
C           END LOOP OVER KBAS AND LBAS
            ENDDO
          ENDDO
C
C         END LOOP OVER IBAS AND JBAS
        ENDDO
      ENDDO
C
C     END LOOP OVER COMPONENT OVERLAPS
4000  CONTINUE
C     END LOOP OVER |MQN| VALUES
3201  CONTINUE
3200  CONTINUE
3101  CONTINUE
3100  CONTINUE
3000  CONTINUE
C     END LOOP OVER KQNS
2201  CONTINUE
2200  CONTINUE
2101  CONTINUE
2100  CONTINUE
2000  CONTINUE
C     END LOOP OVER CENTERS
1201  CONTINUE
1200  CONTINUE
1101  CONTINUE
1100  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     SELF-BREIT MATRIX COMPLETE.                                      C
C**********************************************************************C
C
      DO I=1,NSHIFT
        DO J=1,I
          BDSC(J,I) = BDSC(I,J)
        ENDDO
      ENDDO
C
      TITLE = 'BDSC_ARRAY'
C      CALL ARRYPLT(BDSC,TITLE,NDIM)
C
      RETURN
      END
