      PROGRAM BERTHA
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         BBBBBBB  EEEEEEEE RRRRRRR TTTTTTTT HH    HH    AA            C
C         BB    BB EE       RR    RR   TT    HH    HH   AAAA           C
C         BB    BB EE       RR    RR   TT    HH    HH  AA  AA          C
C         BBBBBBB  EEEEEE   RR    RR   TT    HHHHHHHH AA    AA         C
C         BB    BB EE       RRRRRRR    TT    HH    HH AAAAAAAA         C
C         BB    BB EE       RR    RR   TT    HH    HH AA    AA         C
C         BBBBBBB  EEEEEEEE RR    RR   TT    HH    HH AA    AA         C
C                                                                      C
C                 (THE PROGRAM FORMERLY KNOWN AS...)                   C
C                                                                      C
C     SSSSSS  WW         WW IIII RRRRRRR  LL      EEEEEEEE SSSSSS      C
C    SS    SS WW         WW  II  RR    RR LL      EE      SS    SS     C
C    SS       WW         WW  II  RR    RR LL      EE      SS           C
C     SSSSSS  WW    W    WW  II  RR    RR LL      EEEEEE   SSSSSS      C
C          SS WW   WWW   WW  II  RRRRRRR  LL      EE            SS     C
C    SS    SS  WW WW WW WW   II  RR    RR LL      EE      SS    SS     C
C     SSSSSS    WW     WW   IIII RR    RR LLLLLLL EEEEEEEE SSSSSS      C
C                                                                      C
C -------------------------------------------------------------------- C
C        A RELATIVISTIC MOLECULAR ELECTRONIC STRUCTURE PROGRAM         C
C            BASED ON THE ANALYTIC FINITE BASIS SET METHOD.            C
C                                                                      C
C                 H.M.QUINEY, H.SKAANE (OXFORD, 1996)                  C
C                       D. FLYNN (UNIMELB, 2019)                       C
C -------------------------------------------------------------------- C
C                          HAMILTONIANS (HMLT)                         C
C                          -------------------                         C
C ▶ 'NORL' NON-RELATIVISTIC HAMILTONIAN (PAULI EQUATION).              C
C ▶ 'BARE' BARE NUCLEUS DIRAC HAMILTONIAN (NO ELECTRON INTERACTION).   C
C ▶ 'DHFR' DIRAC-COULOMB HAMILTONIAN.                                  C
C ▶ 'DHFP' DIRAC-COULOMB HAMILTONIAN (+1ST ORDER BREIT).               C
C ▶ 'DHFB' DIRAC-COULOMB-BREIT HAMILTONIAN.                            C
C ▶ 'DHFQ' DIRAC-COULOMB-BREIT HAMILTONIAN WITH LEADING-ORDER QED.     C
C -------------------------------------------------------------------- C
C                   CALCULATION TREE OPTIONS (TREE)                    C
C                   -------------------------------                    C
C  HFSCF: HARTREE-FOCK SCF CALCULATION.                                C
C  MBPT2: MANY-BODY DIAGRAMMATIC PERTURBATION THEORY.                  C
C  MCSCF: MULTI-CONFIGURATIONAL SCF CALCULATION.                       C
C  EXPVL: CALCULATION OF MOLECULAR EXPECTATION VALUES.                 C
C  PLOTS: VISUALS (ELECTROMAGNETIC FIELDS, POTENTIALS, FORM FACTORS).  C
C -------------------------------------------------------------------- C
C                          TABLE OF CONTENTS                           C
C                          -----------------                           C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C   [4] ATOMIC HARTREE-FOCK: AVERAGE OF CONFIG. ATOMIC SCF.            C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTRE HARTREE-FOCK SCF.          C
C   [6] ONE-CENTRE ROUTINES: ATOMIC INTEGRALS FOR MOLECULAR PURPOSES.  C
C   [7] MULTI-CONFIG: MANY-CENTRE MULTICONFIG. SCF CALCULATIONS.       C
C   [8] MBPT: CORRELATION ENERGY CALCULATION ROUTINES.                 C
C   [9] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C  [10] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C  [11] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C  [12] EQ-COEFFS: FINITE BASIS OVERLAP SPIN STRUCTURE FACTORS.        C
C  [13] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C  [14] QED: UEHLING ROUTINE DEVELOPMENT.                              C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/TCPU/TTOT,TATM,TSCF,TMPT,TMCF,TPRP,TPLT
C
C     START OF BERTHA RUN-TIME
      CALL CPU_TIME(T0)
C
C     READ DATA FROM USER-SPECIFIED INPUT FILE
      CALL CARDIN
C
C     OPEN FILE FOR TERMINAL RECORD
      OPEN(UNIT=7,FILE=TRIM(OUTFL)//'.out',STATUS='UNKNOWN')
C
C     PRINT SUMMARY OF INPUT DATA
      CALL INPUT
C
C     PRINT MEMORY ALLOCATION SUMMARY
      CALL MEMORY
C
C     INTER-ATOMIC ANGLES AND NUCLEAR REPULSION ENERGY
      CALL NUCGEOM
C
C     NUCLEAR POTENTIALS
      CALL NUCCHRG
C
C     FOCK MATRIX SYMMETRY TYPE INDICES
      CALL FOCKIND
C
C     CARTESIAN EXPANSION INDICES FOR BASIS FUNCTION OVERLAP PAIRS
      CALL CARTIND
C
C     ATOMIC HARTREE-FOCK SCF ROUTINE
      CALL CPU_TIME(T1)
      IF(.NOT.READIN) THEN
        CALL ATOMIC
      ENDIF
      CALL CPU_TIME(T2)
      TATM = T2-T1
C
C     MOLECULAR HARTREE-FOCK SCF ROUTINE
      IF(TREE.EQ.'HFSCF'.OR..NOT.READIN) THEN
       IF(SHAPE.NE.'ATOMIC') THEN
          CALL HFSCF
       ENDIF
      ENDIF
      CALL CPU_TIME(T3)
      TSCF = T3-T2
C
C     MANY-BODY DIAGRAMMATIC PERTURBATION THEORY
      IF(TREE.EQ.'MBPT2') THEN
        CALL MBPT
      ENDIF
      CALL CPU_TIME(T4)
      TMPT = T4-T3
C
C     MULTI-CONFIGURATIONAL SELF-CONSISTENT FIELD CALCULATION
      IF(TREE.EQ.'MCSCF') THEN
        CALL MCSCF
      ENDIF
      CALL CPU_TIME(T5)
      TMCF = T5-T4
C
C     ONE-BODY HAMILTONIAN INTERACTIONS FROM A CONVERGED SOLUTION
      IF(TREE.EQ.'EXPVL') THEN
        CALL PT1BODY
      ENDIF
      CALL CPU_TIME(T6)
      TPRP = T6-T5
C
C     ELECTROMAGNETIC FIELDS AND POTENTIALS
      IF(TREE.EQ.'PLOTS') THEN
        CALL FIELDS
      ENDIF
      CALL CPU_TIME(T7)
      TPLT = T7-T6
C
C     END OF BERTHA RUN-TIME
      TTOT = T7-T0
C
C     PRINT SUMMARY OF OUTPUT DATA
      CALL OUTPUT
C
C     CLOSE FILE FOR TERMINAL RECORD
      CLOSE(UNIT=7)
C
C     SUCCESSFUL EXIT
      END PROGRAM
C
C
C**********************************************************************C
C ==================================================================== C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] CARDIN: READ MOLECULAR DATA FROM A USER-SPECIFIED FILE.        C
C   [B] INPUT: WRITE A SUMMARY OF DATA INPUT OPTIONS TO TERMINAL.      C
C   [C] MEMORY: WRITE A SUMMARY OF MEMORY REQUIREMENTS OF BIG ARRAYS.  C
C   [D] OUTPUT: WRITE A SUMMARY OF TOTAL CALCULATION STATS/DATA.       C
C   [E] PHYSPRM: PHYSICAL CONSTANTS, TRANSCENDENTALS AND ELEMENT NAMES.C
C   [F] GAMGEN: LIST OF GAMMA FUNCTIONS FOR INT AND HALF-INT ARGS.     C
C   [G] FACTRL: LIST OF FACTORIALS AND DOUBLE FACTORIALS.              C
C**********************************************************************C
C
C
      SUBROUTINE CARDIN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            CCCCCC     AA    RRRRRRR  DDDDDDD IIII NN    NN           C
C           CC    CC   AAAA   RR    RR DD    DD II  NNN   NN           C
C           CC        AA  AA  RR    RR DD    DD II  NNNN  NN           C
C           CC       AA    AA RR    RR DD    DD II  NN NN NN           C
C           CC       AAAAAAAA RRRRRRR  DD    DD II  NN  NNNN           C
C           CC    CC AA    AA RR    RR DD    DD II  NN   NNN           C
C            CCCCCC  AA    AA RR    RR DDDDDDD IIII NN    NN           C
C                                                                      C
C                          INPUT ROUTINE FOR                           C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  CARDIN READS AND PREPARES DATA FROM A USER-SPECIFIED INPUT FILE.    C
C  THIS IS ALSO WHERE ATOMIC ELEMENT NAMES AND CV ARE SPECIFIED.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C     INCLUDE 'omp_lib.h'
C
      CHARACTER*1  DUMLIN
      CHARACTER*5  NMDL
      CHARACTER*6  CNFG
      CHARACTER*7  HMINT(10),PTYPE(10)
      CHARACTER*9  BTYP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FILL/NCNF(MCT,0:MEL,MKP+1),NLVL(MCT,0:MEL),CNFG(MCT)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(3),SHLV,ILEV
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/PLOT/NPTYPE,PTYPE
      COMMON/PT1B/NHMINT,HMINT
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     GENERATE SOME MATHEMATICAL LISTS
      CALL FACTRL
      CALL GAMGEN
C
C     MANUAL CHOICES
      EQFILE = .TRUE.
      OPENMP = .FALSE.
C
C**********************************************************************C
C     MOLECULE NAME AND CALCULATION TYPE                               C
C**********************************************************************C
C
C     MOLECULE OUTPUT STRING
      READ(5, *) DUMLIN
      READ(5, *) MOLCL
C
C     CALCULATION TREE: HFSCF, MBPT2, MCSCF, EXPVL, PLOTS
      READ(5, *) DUMLIN
      READ(5, *) TREE
C
C     CALCULATION TREE CHECK -- IF UNKNOWN, EXIT.
      IF(TREE.NE.'HFSCF'.AND.TREE.NE.'MBPT2'.AND.TREE.NE.'MCSCF'.AND.
     &   TREE.NE.'EXPVL'.AND.TREE.NE.'PLOTS') THEN
        WRITE(6, *) 'In CARDIN: invalid calculation tree. ',TREE
        WRITE(7, *) 'In CARDIN: invalid calculation tree. ',TREE
        STOP
      ENDIF
C
C     HAMILTONIAN: NORL, BARE, DHFR, DHFP, DHFB OR DHFQ
10    FORMAT(A4)
      READ(5, *) DUMLIN
      READ(5,10) HMLT
C
C     HAMILTONIAN CHECK -- IF UNKNOWN, EXIT.
      IF(HMLT.NE.'NORL'.AND.HMLT.NE.'BARE'.AND.HMLT.NE.'DHFR'.AND.
     &   HMLT.NE.'DHFP'.AND.HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
        WRITE(6, *) 'In CARDIN: unknown HMLT value. HMLT = ',HMLT
        WRITE(7, *) 'In CARDIN: unknown HMLT value. HMLT = ',HMLT
        STOP
      ENDIF
C
C     WAVE FUNCTION FILE NAME
      WFNFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'.wfn'
C
C     OUTPUT FILE NAME
      OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_'//TREE
C
C     CONTINUING CALCULATION: READ-IN (TRUE), NEW START (FALSE)
      READ(5, *) DUMLIN
      READ(5, *) READIN
C
C**********************************************************************C
C     ATOMIC CENTRES AND BASIS FUNCTIONS                               C
C**********************************************************************C
C
C     NUMBER OF ATOMIC CENTRES
      READ(5, *) DUMLIN
      READ(5, *) NCNT
C
C     CHECK THAT NCNT CAN BE SUPPORTED BY SYSTEM PARAMETERS
      IF(NCNT.GT.MCT) THEN
        WRITE(6, *) 'In CARDIN: number of centres exceeds MCT.',MCT
        WRITE(7, *) 'In CARDIN: number of centres exceeds MCT.',MCT
        STOP
      ENDIF
C
C     INITIALISE MAXIMUM LQN AND DIMENSION COUNTERS
      LBIG = 0
      NDIM = 0
C
C     LOOP OVER ATOMIC CENTRES
      DO IZ=1,NCNT
C
C       CARTESIAN COORDINATES OF THIS CENTRE
        READ(5, *) DUMLIN
        READ(5, *) DUMLIN
        READ(5, *) (BXYZ(J,IZ),J=1,3)
C
C       NUCLEUS: MODEL, CHARGE, MASS
        READ(5, *) DUMLIN
        READ(5, *) NMDL(IZ),ZNUC(IZ),ANUC(IZ)
C
C       CHECK THAT NUCLEAR MODEL IS ALLOWED
        IF(NMDL(IZ).NE.'POINT'.AND.NMDL(IZ).NE.'GAUSS'.AND.
     &     NMDL(IZ).NE.'FERMI'.AND.NMDL(IZ).NE.'UNIFM') THEN
          WRITE(6, *) 'In CARDIN: illegal nuclear model.',NMDL(IZ)
          WRITE(7, *) 'In CARDIN: illegal nuclear model.',NMDL(IZ)
          STOP
        ENDIF
C
C       ATOMIC BASIS: TYPE AND LMAX
        READ(5, *) DUMLIN
        READ(5, *) BTYP,LMAX
C
C       CHECK THAT BASIS TYPE IS ALLOWED
        IF(BTYP.NE.'GEOMETRIC'.AND.BTYP.NE.'OPTIMISED') THEN
          WRITE(6, *) 'In CARDIN: illegal basis type.',BTYP
          WRITE(7, *) 'In CARDIN: illegal basis type.',BTYP
          STOP
        ENDIF
C
C       NUMBER OF KAPPA VALUES FOR THIS ATOM
        NKAP(IZ) = 2*LMAX+1
C
C       CHECK THAT LMAX CAN BE SUPPORTED BY SYSTEM PARAMETERS
        IF(2*LMAX+1.GT.MKP) THEN
          WRITE(6, *) 'In CARDIN: LMAX runs outside MKP storage.'
          WRITE(7, *) 'In CARDIN: LMAX runs outside MKP storage.'
          STOP
        ENDIF
C
C       ELECTRON CONFIGURATION CHOICE AND NUCLEAR ELECTRONIC CHARGE
        READ(5, *) DUMLIN
        READ(5, *) CNFG(IZ),IQNC(IZ)
C
C       CHECK THAT CNFG IS ALLOWED
        IF(CNFG(IZ).NE.'AUFBAU'.AND.CNFG(IZ).NE.'MANUAL') THEN
          WRITE(6, *) 'In CARDIN: illegal CNFG option.',CNFG(IZ)
          WRITE(7, *) 'In CARDIN: illegal CNFG option.',CNFG(IZ)
          STOP
        ENDIF
C
C       IF FILLING IS MANUAL, IMPORT ATOMIC ELECTRON CONFIGURATION
        IF(CNFG(IZ).EQ.'MANUAL') THEN
          READ(5, *) DUMLIN
          DO L=0,LMAX
            READ(5, *) NLVL(IZ,L),(NCNF(IZ,L,N),N=1,NLVL(IZ,L))
          ENDDO
        ENDIF
C
C       UPDATE OVERALL MAXIMUM OCCURRING LQN
        IF(LMAX.GT.LBIG) LBIG = LMAX
C
C       GEOMETRIC BASIS FUNCTIONS
        IF(BTYP.EQ.'GEOMETRIC') THEN
C
C         TITLE FILLER
          READ(5, *) DUMLIN
C
C         GENERATE THE EVEN TEMPERED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX
C
C           READ GENERATING PARAMETERS A, B AND NFNC
            READ(5, *) ALPH,BETA,NFNC(LQN,IZ)
C
C           GENERATE NFNC BASIS EXPONENTS USING VARIABLE ZETA
            ZETA = ALPH
            DO IBAS=1,NFNC(LQN,IZ)
              BEXL(IBAS,LQN,IZ) = ZETA
              ZETA = ZETA*BETA
            ENDDO
C
C           CHECK THAT NFNC CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN,IZ).GT.MBS) THEN
              NOOPS = NFNC(LQN,IZ)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
          ENDDO
C
C       OPTIMISED EXPONENTS FROM A RECORDED LIST
        ELSEIF(BTYP.EQ.'OPTIMISED') THEN
C
C         TITLE FILLER
          READ(5, *) DUMLIN
C
C         READ IN THE OPTIMISED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX
C
C           READ NUMBER OF BASIS FUNCTIONS
            READ(5, *) NFNC(LQN,IZ)
C
C           CHECK THAT THIS CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN,IZ).GT.MBS) THEN
              NOOPS = NFNC(LQN,IZ)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
C           READ BASIS EXPONENTS FROM A LIST
            DO IBAS=1,NFNC(LQN,IZ)
              READ(5, *) BEXL(IBAS,LQN,IZ)
            ENDDO
C
          ENDDO
C
C       END IF STATEMENT FOR TYPE OF BASIS FUNCTION
        ENDIF
C
C       LOOP OVER ALL LQNS IN THIS CENTRE AND ADD TO FOCK DIMENSION
        DO LQN=0,LMAX
C
C         EXTEND DIMENSION OF FOCK MATRIX
          NDIM = NDIM + 4*(2*LQN+1)*NFNC(LQN,IZ)
C
C         ASSIGN KQN VALUES
          IF(LQN.NE.0) THEN
            KAPA(2*LQN  ,IZ) = LQN
          ENDIF
          KAPA(2*LQN+1,IZ) =-LQN-1
C
        ENDDO
C
C     END LOOP OVER ATOMIC CENTRES
      ENDDO
C
C     TOTAL DIMENSION DEPENDING ON CHOICE OF HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
        NDIM = NDIM/2
        NSKP = 0
      ELSE
        NSKP = NDIM/2
      ENDIF
C
C     CHECK THAT SYSTEM PARAMETERS CAN SUPPORT NDIM
      IF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        WRITE(7, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        STOP
      ENDIF
C
C**********************************************************************C
C     CLOSED/OPEN SHELL DETAILS                                        C
C**********************************************************************C
C
C     NUMBER OF CLOSED- AND OPEN-SHELL ORBITALS AND OPEN SHELL ELECTRONS
      READ(5, *) DUMLIN
      READ(5, *) NCLS,NOPN,NOELEC
C
C     TOTAL NUMBER OF 'OCCUPIED' AND 'VIRTUAL' ORBITALS IN SYSTEM
      NOCC = NCLS+NOPN
      NVRT = NDIM-NSKP-NOCC
C
C     INVALID CHOICE OF NOPN
      IF(NOPN.LT.0) THEN
C
        WRITE(6, *) 'In CARDIN: invalid value NOPN.',NOPN
        WRITE(7, *) 'In CARDIN: invalid value NOPN.',NOPN
C
C     CLOSED-SHELL MOLECULAR CONFIGURATION
      ELSEIF(NOPN.EQ.0) THEN
C
C       LABEL THE CLOSED-SHELL ELECTRON ORBITALS
        DO JCL=1,NCLS
          ICLS(JCL) = JCL
        ENDDO
C
C     OPEN-SHELL MOLECULAR CONFIGURATION
      ELSEIF(NOPN.GT.0) THEN
C
C       FRACTIONAL OCCUPANCY OF THE OPEN-SHELL ORBITALS
        FOPN = DFLOAT(NOELEC)/DFLOAT(NOPN)
C
C       SYMMETRY-ADAPTED CONFIGURATION OF OPEN-SHELL ORBITALS
        READ(5, *) DUMLIN
        READ(5, *) ACFF,BCFF,(IOPN(M),M=1,NOPN)
C
C       LABEL THE CLOSED-SHELL ELECTRON ORBITALS
        JCL = 1
        JOP = 1
        DO JCOUNT=1,NOCC
C
C         APPLY LABEL TO EACH ORBITAL
          IF(JCOUNT.NE.IOPN(JOP)) THEN
            ICLS(JCL) = JCOUNT
            JCL = JCL + 1
          ELSE
            JOP = JOP + 1
          ENDIF
C
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     LEVEL SHIFTING AND INTEGRAL INCLUSION STARTING POINT             C
C**********************************************************************C
C
C     LEVEL SHIFT PARAMETER FOR EACH INTEGRAL STAGE (SKAANE 4.4.3)
      READ(5, *) DUMLIN
      READ(5, *) (SHLEV(N),N=1,3)
C
C     STARTING STAGE OF INTEGRAL INCLUSION LEVEL (1-3)
      READ(5, *) DUMLIN
      READ(5, *) ILEV
C
C     REASONS TO CHANGE THE INTEGRAL INCLUSION LEVEL
      IF(HMLT.EQ.'NORL') THEN
        ILEV = 1
      ENDIF
C
      IF(NCNT.EQ.1.OR.READIN) THEN
        ILEV = 3
      ENDIF
C
C     IMPLEMENT THE STARTING SHIFT FACTOR
      IF(ILEV.GE.1.AND.ILEV.LE.3) THEN
        SHLV = SHLEV(ILEV)
      ELSE
        WRITE(6, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        WRITE(7, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        STOP
      ENDIF
C
C**********************************************************************C
C     NON-HF CALCULATION DETAILS                                       C
C**********************************************************************C
C
C     EXPECTATION VALUE CALCULATIONS: ORTHGNL,MAGDIPL ETC
      IF(TREE.EQ.'EXPVL') THEN
C
C       READ NUMBER OF EXPECTATION VALUES
        READ(5, *) DUMLIN
        READ(5, *) NHMINT
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NHMINT.LT.1.OR.NHMINT.GT.10) THEN
          WRITE(6, *) 'In CARDIN: invalid number of expectation values.'
          WRITE(7, *) 'In CARDIN: invalid number of expectation values.'
          STOP
        ENDIF
C
C       READ IN EACH INTERACTION HAMILTONIAN
        DO N=1,NHMINT
          READ(5, *) HMINT(N)
        ENDDO
C
      ENDIF
C
C     DATA PLOTTING: AMPLITUDES, EM FIELDS AND POTENTIALS
      IF(TREE.EQ.'PLOTS') THEN
C
C       READ NUMBER OF PLOT TYPES
        READ(5, *) DUMLIN
        READ(5, *) NPTYPE
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NPTYPE.LT.1.OR.NPTYPE.GT.10) THEN
          WRITE(6, *) 'In CARDIN: invalid number of plot types.'
          WRITE(7, *) 'In CARDIN: invalid number of plot types.'
          STOP
        ENDIF
C
C       READ IN EACH PLOT TYPE
        DO N=1,NPTYPE
          READ(5, *) PTYPE(N)
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     READ IN ANY EXTERNAL DATA FILES                                  C
C**********************************************************************C
C
C     READ IN A WAVE FUNCTION FILE IF PROMPTED
      IF(READIN) THEN
        OPEN(UNIT=8,FILE=WFNFL,STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          READ(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE INPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               IIII NN    NN PPPPPPP  UU    UU TTTTTTTT               C
C                II  NNN   NN PP    PP UU    UU    TT                  C
C                II  NNNN  NN PP    PP UU    UU    TT                  C
C                II  NN NN NN PP    PP UU    UU    TT                  C
C                II  NN  NNNN PPPPPPP  UU    UU    TT                  C
C                II  NN   NNN PP       UU    UU    TT                  C
C               IIII NN    NN PP        UUUUUU     TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  INPUT PRINTS MOLECULAR DATA INPUT OPTIONS TO THE TERMINAL.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/TMMD/TMMDS(9)
      COMMON/TSCF/TSCFS(34)
C
C     INITIALISE TIME COUNTERS
      DO NT=1,34
        TSCFS(NT) = 0.0D0
      ENDDO
C
      DO NT=1,9
        TMMDS(NT) = 0.0D0
      ENDDO
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',30),'INPUT SUMMARY'
      WRITE(7, *) REPEAT(' ',30),'INPUT SUMMARY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     TITLE FOR INPUT OPTIONS
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',21),'Calculation tree and data files'
      WRITE(7, *) REPEAT(' ',21),'Calculation tree and data files'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     CALCULATION TREE
      IF(TREE.EQ.'HFSCF') THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',43),'Hartree-Fock'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',43),'Hartree-Fock'
      ELSEIF(TREE.EQ.'MBPT2') THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',50),'MBPT2'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',50),'MBPT2'
      ELSEIF(TREE.EQ.'MCSCF') THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',50),'MCSCF'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',50),'MCSCF'
      ELSEIF(TREE.EQ.'EXPVL') THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',44),'Expct. vals'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',44),'Expct. vals'
      ELSEIF(TREE.EQ.'PLOTS') THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',47),'Plotting'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',47),'Plotting'
      ENDIF
C
C     PRINT THE HAMILTONIAN OPTION
      WRITE(6, *) 'Hamiltonian type:',REPEAT(' ',51),HMLT
      WRITE(7, *) 'Hamiltonian type:',REPEAT(' ',51),HMLT
C
C     CONFIRM SOLUTION SPACE DIMENSION OR EXIT
      IF(NDIM.LE.MDM) THEN
        WRITE(6, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
        WRITE(7, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
      ELSEIF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        WRITE(7, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        STOP
      ENDIF
C
C     NEW START OR READ IN HFSCF EXPANSION COEFFICIENTS
      IF(READIN) THEN
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
      ELSE
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
      ENDIF
C
C     EQ-COEFFICIENT CALCULATION
      IF(EQFILE) THEN
        WRITE(6, *) 'Eq-coefficients:',REPEAT(' ',44),'Save to file'
        WRITE(7, *) 'Eq-coefficients:',REPEAT(' ',44),'Save to file'
      ELSE
        WRITE(6, *) 'Eq-coefficients:',REPEAT(' ',48),'By batch'
        WRITE(7, *) 'Eq-coefficients:',REPEAT(' ',48),'By batch'
      ENDIF
C
C     OPENMP PARALLEL OPTION
      IF(OPENMP) THEN
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(6, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),NPRCSR
        WRITE(7, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),NPRCSR
      ELSE
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
      ENDIF
C
C     SECTION FOR FILE NAMES
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     PRINT INPUT FILE NAME
      LF = LEN(TRIM(MOLCL))
      WRITE(6, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
      WRITE(7, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
C
C     PRINT FILE OUTPUT NAMES
      LN = LEN(TRIM(OUTFL))
      WRITE(6, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
      WRITE(7, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
C
C     RECORD TIME AT BEGINNING OF CALCULATION
      CALL CPU_TIME(TBEG)
      CALL TIMENOW(STAMP)
      WRITE(6, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
      WRITE(7, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
C
C     END OF INPUT SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE MEMORY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RRRRRRR  YY    YY      C
C     MMM     MMM EE       MMM     MMM OO    OO RR    RR YY    YY      C
C     MMMM   MMMM EE       MMMM   MMMM OO    OO RR    RR  YY  YY       C
C     MM MM MM MM EEEEEE   MM MM MM MM OO    OO RR    RR   YYYY        C
C     MM  MMM  MM EE       MM  MMM  MM OO    OO RRRRRRR     YY         C
C     MM   M   MM EE       MM   M   MM OO    OO RR    RR    YY         C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RR    RR    YY         C
C                                                                      C
C -------------------------------------------------------------------- C
C  MEMORY SUMMARISES THE SIZE AND MEMORY REQUIREMENTS OF BIG ARRAYS.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      INTEGER*16 NCMEM,NDMEM,NEMEM,NMMEM,NRMEM,NTMEM
      INTEGER*16 NHMEM
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
C
C     TITLE FOR MEMORY SUMMARY
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Approx. system memory allocation'
      WRITE(7, *) REPEAT(' ',20),'Approx. system memory allocation'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     APPROXIMATE THE MEMORY STORAGE ALLOCATION
      NCMEM = 2*SIZE(COEF)
      NDMEM = 2*SIZE(DENC) + 2*SIZE(DENO) + 2*SIZE(DENT)
      NEMEM = SIZE(E0LLFL) + SIZE(E0SSFL) + SIZE(EILSFL)
      NHMEM = 20*MFL
      NMMEM = 2*SIZE(FOCK) + 2*SIZE(OVLP) + 2*SIZE(HNUC) + 2*SIZE(HKIN)
     &      + 2*SIZE(GDIR) + 2*SIZE(GXCH) + 2*SIZE(BDIR) + 2*SIZE(BXCH)
     &      + 2*SIZE(VUEH) + 2*SIZE(QDIR) + 2*SIZE(QXCH) + 2*SIZE(QDIR) 
     &      + 2*SIZE(QXCH) + 2*SIZE(CPLE)
      NTMEM = NCMEM + NDMEM + NEMEM + NHMEM + NMMEM
C
C     SIZES (IN GIGABYTES)
      SCMEM = NCMEM*8.0D-9
      SDMEM = NDMEM*8.0D-9
      SEMEM = NEMEM*8.0D-9
      SHMEM = NHMEM*8.0D-9
      SMMEM = NMMEM*8.0D-9
      STMEM = NTMEM*8.0D-9
C
20    FORMAT(1X,A,4X,A,19X,A,9X,A)
21    FORMAT(1X,A,6X,A,5X,I12,9X,F9.5)
      WRITE(6,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(7,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(7,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(6,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(7,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(6,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(7,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(6,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(7,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(6,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(7,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) '    ','Total                      ',NTMEM,STMEM
      WRITE(7,21) '    ','Total                      ',NTMEM,STMEM
C
C     END OF MEMORY SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE OUTPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  UU    UU TTTTTTTT PPPPPPP  UU    UU TTTTTTTT        C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PPPPPPP  UU    UU    TT           C
C         OO    OO UU    UU    TT    PP       UU    UU    TT           C
C          OOOOOO   UUUUUU     TT    PP        UUUUUU     TT           C
C                                                                      C
C                      EXIT SUMMARY ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  OUTPUT PRINTS A SUMMARY OF TOTAL CALCULATION DATA TO TERMINAL.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
C
      COMMON/TCPU/TTOT,TATM,TSCF,TMPT,TMCF,TPRP,TPLT
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',30),'OUTPUT SUMMARY'
      WRITE(7, *) REPEAT(' ',30),'OUTPUT SUMMARY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME AT BERTHA EXIT
      CALL TIMENOW(STAMP)
C
C     PRINT TABLE OF DATA
20    FORMAT(1X,A,26X,A)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',28),'CPU time summary'
      WRITE(7, *) REPEAT(' ',28),'CPU time summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(.NOT.READIN) THEN
        WRITE(6,20) 'Atomic Hartree-Fock SCF:      ',HMS(TATM)
        WRITE(7,20) 'Atomic Hartree-Fock SCF:      ',HMS(TATM)
      ENDIF
      IF(.NOT.READIN.OR.TREE.EQ.'HFSCF') THEN
        WRITE(6,20) 'Molecular Hartree-Fock SCF:   ',HMS(TSCF)
        WRITE(7,20) 'Molecular Hartree-Fock SCF:   ',HMS(TSCF)
      ELSEIF(TREE.EQ.'MBPT2') THEN
        WRITE(6,20) 'Many-body perturbation theory:',HMS(TMPT)
        WRITE(7,20) 'Many-body perturbation theory:',HMS(TMPT)
      ELSEIF(TREE.EQ.'MCSCF') THEN
        WRITE(6,20) 'Multi-configurational SCF:    ',HMS(TMCF)
        WRITE(7,20) 'Multi-configurational SCF:    ',HMS(TMCF)
      ELSEIF(TREE.EQ.'EXPVL') THEN
        WRITE(6,20) 'Property calculation:         ',HMS(TPRP)
        WRITE(7,20) 'Property calculation:         ',HMS(TPRP)
      ELSEIF(TREE.EQ.'PLOTS') THEN
        WRITE(6,20) 'Plotting:                     ',HMS(TPLT)
        WRITE(7,20) 'Plotting:                     ',HMS(TPLT)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(7,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     SUCCESSFUL EXIT MESSAGE
      WRITE(6, *)
      WRITE(7, *)
      WRITE(6, *) 'Successful BERTHA exit at:',REPEAT(' ',26),STAMP
      WRITE(7, *) 'Successful BERTHA exit at:',REPEAT(' ',26),STAMP
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      RETURN
      END
C
C
      BLOCK DATA PHYSPRM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  PPPPPPP  HH    HH YY    YY  SSSSSS  PPPPPPP  RRRRRRR  MM       MM   C  
C  PP    PP HH    HH YY    YY SS    SS PP    PP RR    RR MMM     MMM   C
C  PP    PP HH    HH YY    YY SS       PP    PP RR    RR MMMM   MMMM   C
C  PP    PP HHHHHHHH  YY  YY   SSSSSS  PP    PP RR    RR MM MM MM MM   C
C  PPPPPPP  HH    HH   YYYY         SS PPPPPPP  RRRRRRR  MM  MMM  MM   C
C  PP       HH    HH    YY    SS    SS PP       RR    RR MM   M   MM   C
C  PP       HH    HH    YY     SSSSSS  PP       RR    RR MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  BLOCK DATA FOR PHYSICAL CONSTANTS, CALCULATED TRANSCENDENTALS AND   C
C  PERIODIC TABLE ELEMENT NAMES.                                       C
C**********************************************************************C
C
      CHARACTER*2 ELMT(120)
C
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     PERIODIC TABLE ELEMENT NAMES
      DATA ELMT/'H' ,'He','Li','Be','B' ,'C' ,'N' ,'O' ,'F' ,'Ne',
     &          'Na','Mg','Al','Si','P' ,'S' ,'Cl','Ar','K' ,'Ca',
     &          'Sc','Ti','V' ,'Cr','Mn','Fe','Co','Ni','Cu','Zn',
     &          'Ga','Ge','As','Se','Br','Kr','Rb','Sr','Y' ,'Zr',
     &          'Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
     &          'Sb','Te','I' ,'Xe','Cs','Ba','La','Ce','Pr','Nd',
     &          'Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
     &          'Lu','Hf','Ta','W' ,'Re','Os','Ir','Pt','Au','Hg',
     &          'Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th',
     &          'Pa','U' ,'Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
     &          'Md','No','Lr','Rf','Db','Sg','Bh','Hs','Mt','Ds',
     &          'Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og','Ue','Un'/
C
C     PI AND ROOTS
      DATA PI,PI12,PI32,PI52/3.1415926535897932D0,1.7724538509055160D0,
     &                       5.5683279968317078D0,1.7493418327624863D1/
C
C     NATURAL LOGARITHM DATA
      DATA PILG,TWLG,THLG/1.1447298858494002D0,0.6931471805599453D0,
     &                                         1.0986122886681097D0/
C
C     NATURAL CONSTANTS
      DATA EULR/0.5772156649015329D0/
C
C     OTHER ROOTS
      DATA TW12/1.4142135623730950D0/
C
C     SPEED OF LIGHT (CODATA 2018 MEASUREMENT - UNCERTAINTY 0.000000021)
c     DATA CV/137.035999084D0/
C
C     SPEED OF LIGHT (CODATA 2010 MEASUREMENT)
c     DATA CV/137.0359990D0/
C
C     SPEED OF LIGHT (CODATA 1999 MEASUREMENT)
C     DATA CV/137.03599976D0/
C
C     SPEED OF LIGHT (USED IN HAAKON'S THESIS)
      DATA CV/137.0359898D0/
C
C     RELATIVE ELECTRON, MUON AND TAUON MASSES (ATOMIC UNITS)
      DATA EMSS,UMSS,TMSS/1.0000D0,206.7683D0,3477.1429D0/
C
C     RATIO OF PROTON MASS TO ELECTRON MASS AND PROTON RADIUS (IN fm)
      DATA PMSS,PRAD/1836.153D0,0.842D0/
C
C     COMPTON WAVELENGTH (1.0D0/CV)
      DATA CMPW/7.297353064D-3/
C
C     FREE ELECTRON G-FACTOR
      DATA GFREE/2.0023193043622D0/
C
C     FERMI COUPLING CONSTANT (IN eV^-2)
C     DATA GFRMI/1.1663787D-23/
C
C     FERMI COUPLING CONSTANT (IN a.u. -- USED IN HAAKON'S THESIS)
C     DATA GFRMI/2.22D-14/
C
C     FERMI COUPLING CONSTANT (IN a.u.)
      DATA GFRMI/2.22255D-14/
C
C     WEINBERG MIXING ANGLE SIN(θ_W)^2
      DATA WEIN/0.23120D0/
C
C     CONVERSION FACTOR: HARTREE TO HZ
      DATA CHZ/6.579684D+15/
C
C     CONVERSION FACTOR: BOHR RADIUS TO FM
      DATA CFM/5.29177211D+4/
C
C     CONVERSION FACTOR: ELECTRON CHARGE ANGSTROM TO DEBYE (eÅ -> D)
      DATA CDB/2.54174623D+0/
C
C     http://www.fileformat.info/info/unicode/font/gnu_unifont/grid.htm
C     https://coolsymbol.com/
C     WRITE(6,*) 'αβγδεζηθικλμνξοπρϱςστυφχψω'
C     WRITE(6,*) 'ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ  ΣΤΥΦΧΨΩ'
C     WRITE(6,*) 'ⅈℵℎℏℓℒℋℛℐℜℑℕℙℚℝℤℂ℘'
C     WRITE(6,*) '×·∕−±∓≠∞—–…≪≫≤≥'
C     WRITE(6,*) '⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘'
C     WRITE(6,*) 'π∞Σ√∛'∜∫∬∭∮∯∰∀∂∃∄∅∆∇∈∉∋∌∎∏∐∑'
C     WRITE(6,*) '∗∝∠∡∢∧∨∩∪∴∵∶∷∼∽∿⊕⊖⊗⊘⊙⊚⊛⊜⊝␢Å'
C     WRITE(6,*) '‗‘’‚‛“”„‟•‣❛❜❝❞¿'
C     WRITE(6,*) '✓✔✗✘☓√☑☐☒☼❄❆♤♠♧♣♡♥♢♦'
C     WRITE(6,*) '¢$€£¥®™☎⌨✁✂✎✏✐§☛'
C     WRITE(6,*) '↕↖↗↘↙↚↛↥↦↧↰↱↲↳↴↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇠⇡⇢⏎▶➔➘➙➚➛➜➞↵⇑⇓'
C     WRITE(6,*) '★☆✡✦✧✩✪✰✢✣✤✥✱✲✳✴✵✶✷✸✹✺✻✼✽✾✿❀❁❂❃❇❈❉❊❋❄❆❅≛'
C
      END
C
C
      SUBROUTINE GAMGEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG     AA    MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C       GG    GG   AAAA   MMM     MMM GG    GG EE       NNN   NN       C
C       GG        AA  AA  MMMM   MMMM GG       EE       NNNN  NN       C
C       GG       AA    AA MM MM MM MM GG       EEEEEE   NN NN NN       C
C       GG   GGG AAAAAAAA MM  MMM  MM GG   GGG EE       NN  NNNN       C
C       GG    GG AA    AA MM   M   MM GG    GG EE       NN   NNN       C
C        GGGGGG  AA    AA MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMGEN EVALUATES INTEGER/HALF-INTEGER GAMMA VALUES AND THEIR LOGS.  C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ GAMLOG(N) = DLOG(GAMMA(N/2))                                      C
C  ▶ GAMHLF(N) = GAMMA(N/2)                                            C
C**********************************************************************C
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     STARTING VALUES
      GAMLOG(1) = PILG*0.5D0
      GAMLOG(2) = 0.0D0
      GAMHLF(1) = PI12
      GAMHLF(2) = 1.0D0
C
C     SEED VALUES FOR INCREMENT
      F1 = 0.5D0
      F2 = 1.0D0
C
C     FILL TABLE VALUES
      DO N=4,300,2
        GAMLOG(N-1) = GAMLOG(N-3)+DLOG(F1)
        GAMLOG(N  ) = GAMLOG(N-2)+DLOG(F2)
        GAMHLF(N-1) = GAMHLF(N-3)*F1
        GAMHLF(N  ) = GAMHLF(N-2)*F2
        F1 = F1+1.0D0
        F2 = F2+1.0D0
      ENDDO
C
      RETURN
      END
C
C
       SUBROUTINE FACTRL
       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         FFFFFFFF   AA     CCCCCC TTTTTTTT RRRRRRR  LL                C
C         FF        AAAA   CC    CC   TT    RR    RR LL                C
C         FF       AA  AA  CC         TT    RR    RR LL                C 
C         FFFFFF  AA    AA CC         TT    RR    RR LL                C
C         FF      AAAAAAAA CC         TT    RRRRRRR  LL                C
C         FF      AA    AA CC    CC   TT    RR    RR LL                C
C         FF      AA    AA  CCCCCC    TT    RR    RR LLLLLLLL          C
C                                                                      C
C -------------------------------------------------------------------- C
C  FACTRL GENERATES A SET OF N! AND N!! AS REAL NUMBERS.               C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ RFACT - REGULAR FACTORIALS, RFACT(N) = N!                         C
C  ▶ SFACT - SEMI-FACTORIALS,    SFACT(N) = N!!                        C
C**********************************************************************C
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
      RFACT(0) = 1.0D0
      RFACT(1) = 1.0D0
      SFACT(0) = 1.0D0
      SFACT(1) = 1.0D0
      DO I=2,80
        RNUMBER  = DFLOAT(I)
        RFACT(I) = RNUMBER*RFACT(I-1)
        SFACT(I) = RNUMBER*SFACT(I-2)
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] NUCCHRG: NUCLEAR CHARGE DISTRIBUTION DETAILS.                  C
C   [B] VNFERMI: NORMALISED FERMI NUCLEAR POTENTIAL AT RADIUS R.       C
C   [C] POLYLOG: THE POLYLOGARITHM OF NEGATIVE EXPONENTIAL ARGUMENT.   C
C   [D] NUCGEOM: BOND DISTANCES AND NUCLEAR REPULSION ENERGY.          C
C   [E] FOCKIND: CALCULATE ADDRESSES OF FOCK MATRIX FOR BASIS QN'S.    C
C   [F] CARTIND: GENERATES INDICES FOR EQ-COEFFS AND R-INTEGRALS.      C
C   [G] AUFBAU: DETERMINES GROUND STATE ATOMIC ELECTRON CONFIG.        C
C   [H] SPECTRM0: ATOMIC SPECTRUM W/ EIGENVALUES AND RADIAL MOMENTS.   C
C   [I] SPECTRM: MOLECULAR SPECTRUM W/ EIGENVALUES AND TERM SYMBOLS.   C
C   [J] LLAB: GIVES THE CHARACTER CORRESPONDING TO LQN VALUE LQN.      C
C   [K] ROTATE: PERFORM TWO EULER ROTATIONS ON ALL ATOMIC CENTRES.     C
C   [L] MMPROD: PRODUCT OF TWO SQUARE ARRAYS OF DOUBLES.               C
C   [M] MVPROD: PRODUCT OF A SQUARE MATRIX AND VECTOR OF DOUBLES.      C
C   [N] HMS: RETURNS A QUOTED TIME IN SECONDS AS 'MIN-SEC'.            C
C   [O] MS: RETURNS A QUOTED TIME IN SECONDS AS 'HR-MIN-SEC'.          C
C   [P] TIMENOW: RETURNS A DATE STRING FOR THE CPU TIME.               C
C**********************************************************************C
C
C
      SUBROUTINE NUCCHRG
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   CCCCCC  HH    HH RRRRRRR   GGGGGG     C
C    NNN   NN UU    UU CC    CC CC    CC HH    HH RR    RR GG    GG    C
C    NNNN  NN UU    UU CC       CC       HH    HH RR    RR GG          C
C    NN NN NN UU    UU CC       CC       HHHHHHHH RR    RR GG          C
C    NN  NNNN UU    UU CC       CC       HH    HH RRRRRRR  GG   GGG    C
C    NN   NNN UU    UU CC    CC CC    CC HH    HH RR    RR GG    GG    C
C    NN    NN  UUUUUU   CCCCCC   CCCCCC  HH    HH RR    RR  GGGGGG     C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCCHRG CONTROLS THE CHARGE POTENTIALS THAT APPLY TO EACH NUCLEAR   C
C  CENTRE, GIVEN A RANGE OF NUCLEAR CHARGE MODELS AND QED OPTIONS.     C
C -------------------------------------------------------------------- C
C  ▶ NCOUL = 0 (POINT), NCOUL = 1 (GAUSS), NCOUL > 1 (FERMI).          C
C  ▶ NUEHL > 20 (UEHLING FOR WHICHEVER NUCLEAR CHARGE MODEL.)          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*2 ELMT(120)
      CHARACTER*5 NMDL
      CHARACTER*7 ORDER
C
      DIMENSION NCOUL(MCT),NUEHL(MCT)
      DIMENSION RSQ(MCT),RZER(MCT),QPOL(MCT)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BQED/RUEH(MCT,3),FUEH(MCT,MFT),XUEH(MCT,MFT),NUEH(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/MDLV/ELMT
C
C     TOGGLE FOR MORE DETAILED SUMMARIES (0 FOR OFF, 1 FOR ON)
      IWRT = 0
C
C     NUMBER OF FITTING FUNCTIONS FOR COULOMB PROCEDURE
      DO IZ=1,NCNT
        IF(NMDL(IZ).EQ.'POINT'.OR.NMDL(IZ).EQ.'GAUSS') THEN
          NCOUL(IZ) = 1
        ELSEIF(NMDL(IZ).EQ.'UNIFM'.OR.NMDL(IZ).EQ.'FERMI') THEN
          NCOUL(IZ) = 10
        ELSE
          WRITE(6, *) 'In NUCCHRG: invalid charge model. ',NMDL(IZ)
          WRITE(7, *) 'In NUCCHRG: invalid charge model. ',NMDL(IZ)
        ENDIF
      ENDDO
C
C     NUCLEAR COULOMB POTENTIAL BEST-FIT PROCEDURE
      DO IZ=1,NCNT
        CALL NUCCOUL(IZ,NCOUL(IZ),IWRT,RSQ(IZ))
      ENDDO
C
C     WRITE RESULTS OF COULOMB BEST-FIT PROCEDURE
21    FORMAT(26X,A)
22    FORMAT(1X,A,2X,'|',3X,A,4X,A,5X,A,1X,'|',1X,A,3X,A,3X,A)
23    FORMAT(1X,I2,' (',A,')',1X,'|',5X,I3,4X,F8.4,5X,F6.4,1X,'|',
     &                                             4X,I2,7X,A,2X,F10.8)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,21) 'Nuclear charge summary'
      WRITE(7,21) 'Nuclear charge summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,22) 'Centre','Z (e)','A (m_p+)','R (fm)',
     &            'N_fit','Potential','R-squared'
      WRITE(7,22) 'Centre','Z (e)','A (m_p+)','R (fm)',
     &            'N_fit','Potential','R-squared'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IZ=1,NCNT
        IZNC = INT(ZNUC(IZ))
        WRITE(6,23) IZ,ELMT(IZNC),IZNC,ANUC(IZ),RNUC(IZ)*CFM,NNUC(IZ),
     &                                                 NMDL(IZ),RSQ(IZ)
        WRITE(7,23) IZ,ELMT(IZNC),IZNC,ANUC(IZ),RNUC(IZ)*CFM,NNUC(IZ),
     &                                                 NMDL(IZ),RSQ(IZ)
      ENDDO
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      IF(HMLT.NE.'DHFQ') RETURN
C
C     NUMBER OF FITTING FUNCTIONS FOR UEHLING PROCEDURE
      DO IZ=1,NCNT
        NUEHL(IZ) = 26
      ENDDO
C
C     NUCLEAR UEHLING POTENTIAL BEST-FIT PROCEDURE
      DO IZ=1,NCNT
        CALL NUCUEHL(IZ,NUEHL(IZ),IWRT,RSQ(IZ),RZER(IZ),QPOL(IZ))
      ENDDO
C
C     WRITE RESULTS OF UEHLING BEST-FIT PROCEDURE
31    FORMAT(19X,A)
32    FORMAT(1X,A,2X,'|',2X,A,5X,A,5X,A,1X,'|',1X,A,3X,A,3X,A)
33    FORMAT(1X,I2,' (',A,')',1X,'|',2X,F6.4,5X,F7.4,3X,F8.4,1X,'|',
     &                                             4X,I2,5X,A,2X,F10.8)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,31) 'Nuclear vacuum polarisation summary'
      WRITE(7,31) 'Nuclear vacuum polarisation summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C     Q± IS POLARISED CHARGE, R0 IS LOCATION OF ZERO, R IS RMS RADIS
      WRITE(6,32) 'Centre','Q± (e)','R0 (fm)','R (fm)',
     &            'N_fit','Potential','R-squared'
      WRITE(7,32) 'Centre','Q± (e)','R0 (e)','R (fm)',
     &            'N_fit','Potential','R-squared'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IZ=1,NCNT
        IZNC = INT(ZNUC(IZ))
        RU12 = DSQRT(RUEH(IZ,2))
        ORDER = 'Uehling'
C       ORDER = 'W/Kroll'
        WRITE(6,33) IZ,ELMT(IZNC),ZNUC(IZ)*QPOL(IZ),RZER(IZ)*CFM,
     &                                  RU12*CFM,NUEH(IZ),ORDER,RSQ(IZ)
        WRITE(7,33) IZ,ELMT(IZNC),ZNUC(IZ)*QPOL(IZ),RZER(IZ)*CFM,
     &                                  RU12*CFM,NUEH(IZ),ORDER,RSQ(IZ)
      ENDDO
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE NUCCOUL(IZ,NFT,IWRT,RSQBIG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   CCCCCC   OOOOOO  UU    UU LL          C
C    NNN   NN UU    UU CC    CC CC    CC OO    OO UU    UU LL          C
C    NNNN  NN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN NN NN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN  NNNN UU    UU CC       CC       OO    OO UU    UU LL          C
C    NN   NNN UU    UU CC    CC CC    CC OO    OO UU    UU LL          C
C    NN    NN  UUUUUU   CCCCCC   CCCCCC   OOOOOO   UUUUUU  LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCCOUL EVALUATES THE DETAILS OF NFT GAUSSIAN NUCLEAR FUNCTIONS     C
C  FOR EACH CENTRE IN THE MOLECULE, SO AS TO BEST FIT THE FERMI MODEL. C
C  EXPONENTS XNUC ARE SELECTED MANUALLY, AND FRACTIONS FNUC CALCULATED.C
C -------------------------------------------------------------------- C
C  MATCHING CRITERIA AVAILABLE FOR GAUSSIAN AMPLITUDES:                C
C   ▶ TOTAL NORMALISED CHARGE OF UNITY <R^0>.                          C
C   ▶ SECOND MOMENT <R^2> SAME AS EMPIRICAL FORMULA OR AVAILABLE DATA. C
C   ▶ ANY OTHER INTEGER MOMENT CAN BE MATCHED WITH FERMI MODEL.        C
C   ▶ ANY OTHER REAL VALUED MOMENT (K > -3) CAN BE MATCHED WITH DATA.  C
C   ▶ FORCED AGREEMENT WITH FERMI POTENTIAL VFERMI(R) AT ANY RADIUS R. C
C**********************************************************************C
      INCLUDE 'parameters.h'
      PARAMETER(NPTS=1000,NTRY=1000)
C
      CHARACTER*5  NMDL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      DIMENSION CFMI(MCT)
      DIMENSION RADS(0:NPTS),POTENTIALS(4,0:NPTS)
      DIMENSION PAC(11),RAC(11),PRC(11),PLG(11)
      DIMENSION RF(-2:8),RG(-2:8),R0(-2:8),RU(-2:8)
      DIMENSION VU(0:NPTS),VF(0:NPTS),VG(0:NPTS),V0(0:NPTS)
C
      DIMENSION X(NFT,NFT),Z(NFT),Y(NFT)
      DIMENSION IPIV(NFT)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     NUMBER OF FITTING FUNCTIONS
      NNUC(IZ) = NFT
C
C     NUCLEAR RADIUS
      IF(INT(ZNUC(IZ)).EQ.1) THEN
C       PROTON HAS A VERY SMALL RADIUS (IN FM)
        RFM = PRAD
      ELSEIF(ZNUC(IZ).GT.1.0D0.AND.ZNUC(IZ).LT.90.0D0) THEN
C       EMPIRICAL FORMULA FOR NUCLEAR RMS RADIUS IF Z < 90 (IN FM)
        RFM = 0.836D0*(ANUC(IZ)**(1.0D0/3.0D0)) + 0.57D0
      ELSE
C       EMPIRICAL FORMULA FOR NUCLEAR RMS RADIUS IF Z > 90 (IN FM)
        RFM = 0.770D0*(ANUC(IZ)**(1.0D0/3.0D0)) + 0.98D0
      ENDIF
C
C     CONVERT RESULT TO ATOMIC UNITS
      RNUC(IZ) = RFM/CFM
C
C     POINT-NUCLEUS MODEL
      IF(NMDL(IZ).EQ.'POINT') THEN
        RNUC(IZ) = 0.0D0
        RSQBIG   = 1.0D0
        GOTO 20
      ENDIF
C
C     GAUSSIAN MODEL
      IF(NMDL(IZ).EQ.'GAUSS') THEN
        FNUC(IZ,1) = 1.0D0
        XNUC(IZ,1) = 1.5D0/(RNUC(IZ)*RNUC(IZ))
        RSQBIG     = 1.0D0
        GOTO 20
      ENDIF
C
C**********************************************************************C
C     UNIFORM NUCLEAR MODEL DETAILS.                                   C
C**********************************************************************C
C
C     HAVEN'T DONE THIS YET. SKIP AHEAD TO FERMI.
C
C**********************************************************************C
C     FERMI NUCLEAR MODEL DETAILS.                                     C
C**********************************************************************C
C
C     FERMI SKIN THICKNESS AND HALF-DENSITY PARAMETERS (IN A0)
      TFMI(IZ) = 2.30D0/CFM
      AFMI(IZ) = 0.25D0*TFMI(IZ)/THLG
      CFMI(IZ) = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &         - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
      CFMI(IZ) = DSQRT(CFMI(IZ))
C
C     CHECK WHETHER FERMI MODEL IS POSSIBLE
      EPS = DSQRT(1.4D0)*PI*0.25D0*TFMI(IZ)/THLG
      IF(EPS.GT.RNUC(IZ)) THEN
        NNUC(IZ)   = 1
        FNUC(IZ,1) = 1.0D0
        XNUC(IZ,1) = 1.5D0/(RNUC(IZ)*RNUC(IZ))
        RSQBIG     = 1.0D0
        NMDL(IZ)   = 'GAUSS'
        GOTO 20
      ENDIF
C
C     THESE PARAMETERS MAKE FOR NEATER EXPRESSIONS
      PST = 1.0D0
      RST = 1.0D0
      DO I=1,11
        PST = PST*PI*AFMI(IZ)/CFMI(IZ)
        RST = RST*AFMI(IZ)/CFMI(IZ)
        PAC(I) = PST
        RAC(I) = RST
        PLG(I) = POLYLOG(I,-1.0D0/RAC(1))
      ENDDO
C
C     FERMI MODEL NORMALISATION CONSTANT RHO0
      RHO0 = 1.0D0 + PAC(2) - 6.0D0*RAC(3)*PLG(3)
      RHO0 = 3.0D0/(RHO0*4.0D0*PI*(CFMI(IZ)**3))
C
C     FERMI NORMALISATION CHARGE DENSITY
      DO I=1,11
        PRC(I) = 4.0D0*PI*RHO0*(CFMI(IZ)**(I))/DFLOAT(I)
      ENDDO
C
C     FERMI MODEL RADIAL MOMENTS
      RF(-2) = PRC(1)*(1.0D0 - RAC(1)*PLG(1))
      RF(-1) = PRC(2)*(1.0D0 + PAC(2)/3.0D0 + 2.0D0*RAC(2)*PLG(2))
      RF( 0) = PRC(3)*(1.0D0 + PAC(2) - 6.0D0*RAC(3)*PLG(3))
      RF( 1) = PRC(4)*(1.0D0 + 2.0D0*PAC(2) + 7.0D0*PAC(4)/15.0D0
     &       + 24.0D0*RAC(4)*PLG(4))
      RF( 2) = PRC(5)*(1.0D0 + 10.0D0*PAC(2)/3.0D0
     &       + 7.0D0*PAC(4)/3.0D0 - 120.0D0*RAC(5)*PLG(5))
      RF( 3) = PRC(6)*(1.0D0 + 5.0D0*PAC(2) + 7.0D0*PAC(4)
     &       + 31.0D0*PAC(6)/21.0D0 + 720.0D0*RAC(6)*PLG(6))
      RF( 4) = PRC(7)*(1.0D0 + 7.0D0*PAC(2) + 49.0D0*PAC(4)/3.0D0
     &       + 31.0D0*PAC(6)/3.0D0 - 5040.0D0*RAC(7)*PLG(7))
      RF( 5) = PRC(8)*(1.0D0 + 28.0D0*PAC(2) + 98.0D0*PAC(4)/3.0D0
     &       + 124.0D0*PAC(6)/3.0D0 + 127.0D0*PAC(8)/15.0D0 
     &       + 40320.0D0*RAC(8)*PLG(8))
      RF( 6) = PRC(9)*(1.0D0 + 12.0D0*PAC(2) + 294.0D0*PAC(4)/5.0D0
     &       + 124.0D0*PAC(6)/3.0D0 + 381.0D0*PAC(8)
     &       - 362880.0D0*RAC(9)*PLG(9))
      RF( 7) = PRC(10)*(1.0D0 + 150.0D0*PAC(2) + 98.0D0*PAC(4)
     &       + 310.0D0*PAC(6) + 381.0D0*PAC(8)  + 2555.0D0*PAC(10)
     &       + 3628800.0D0*RAC(10)*PLG(10))
      RF( 8) = PRC(11)*(1.0D0 + 55.0D0*PAC(2) + 154.0D0*PAC(4)
     &       + 682.0D0*PAC(6) + 1397.0D0*PAC(8) + 2555.0D0*PAC(10)
     &       - 39916800.0D0*RAC(11)*PLG(11))
C
C     SAVE THE FERMI POTENTIAL VALUES
      DO IPTS=0,NPTS
        R = 5.0D0*DFLOAT(IPTS)*RNUC(IZ)/DFLOAT(NPTS)
        VF(IPTS) = VNFERMI(R,CFMI(IZ),TFMI(IZ))
      ENDDO
C
C     SET UP MATRIX EQUATIONS FOR FERMI DISTRIBUTION (TO BE MATCHED)
      Y(1) = 1.0D0
      Y(2) = RF(2)
      ITG = 3
      DO IFT=3,NNUC(IZ)
        R = 2.0D0*DFLOAT(IFT-ITG)*RNUC(IZ)/DFLOAT(NNUC(IZ)-ITG)
        Y(IFT) = VNFERMI(R,CFMI(IZ),TFMI(IZ))
      ENDDO
C
C**********************************************************************C
C     GIVEN GEOMETRIC BETA AND NNUC(IZ)=NFT, FIND OPTIMAL ALPHA VALUE. C
C**********************************************************************C
C
      RSQBIG = 0.0D0
      ITRYBG = 0
C
      DO ITRY=0,NTRY
C
C       SET OF GAUSSIAN EXPONENTS (SEARCH WITHIN A BETA WINDOW)
        XI0 = 0.50D0 + 0.25D0*DFLOAT(ITRY)/DFLOAT(NTRY)
        XI  = XI0/(RNUC(IZ)**2)
        DO IFT=1,NNUC(IZ)
          XNUC(IZ,IFT) = XI
          XI = 1.5D0*XI
        ENDDO
C
C       RESET FERMI Z MATRIX
        DO IFT=1,NNUC(IZ)
          Z(IFT) = Y(IFT)
        ENDDO
C
C       SET UP MATRIX EQUATIONS FOR SET OF FITTING GAUSSIANS
C
C       FIRST EQUATION ASSERTS NORMALISATION
        DO JFT=1,NNUC(IZ)
          X(1,JFT) = 1.0D0
        ENDDO
C
C       SECOND EQUATION ASSERTS R^2 VALUE
        DO JFT=1,NNUC(IZ)
          X(2,JFT) = 1.5D0/XNUC(IZ,JFT)
        ENDDO
C
C       ALL OTHER EQUATIONS MATCH TO THE FERMI NUCLEUS
        DO IFT=3,NNUC(IZ)
C
C         MATCHING RADIUS: LINEAR GRID BETWEEN 0.0D0 AND 2.0D0*RNUC(IZ)
          R = 2.0D0*DFLOAT(IFT-ITG)*RNUC(IZ)/DFLOAT(NNUC(IZ)-ITG)
C
C         ERF(R)/R POTENTIALS AT THIS RADIUS
          DO JFT=1,NNUC(IZ)
            X(IFT,JFT) = VNGAUSS(R,XNUC(IZ,JFT),1.0D0)
          ENDDO
C
        ENDDO
C
C       SOLVE THE MATRIX EQUATION X.A = Z FOR AMLPITUDES A
        CALL DGESV(NNUC(IZ),1,X,NNUC(IZ),IPIV,Z,NNUC(IZ),INFO)
C
C       TRANSFER THE X VALUES TO FRACTIONAL ARRAY
        DO IFT=1,NNUC(IZ)
          FNUC(IZ,IFT) = Z(IFT)
        ENDDO
C
C       BEST-FIT GAUSSIAN POTENTIAL
        DO IPTS=0,NPTS
          R = 5.0D0*DFLOAT(IPTS)*RNUC(IZ)/DFLOAT(NPTS)
          VG(IPTS) = 0.0D0
          DO IFT=1,NNUC(IZ)
            VG(IPTS) = VG(IPTS) + VNGAUSS(R,XNUC(IZ,IFT),FNUC(IZ,IFT))
          ENDDO
        ENDDO
C
C       AVERAGE EVALUATED POTENTIAL OVER ALL RADII
        YB = 0.0D0
        DO IPTS=0,NPTS
          YB = YB + VG(IPTS)
        ENDDO
        YB = YB/DFLOAT(NPTS+1)
C
C       BITS AND PIECES FOR THE R-SQUARED VALUE
        SRES = 0.0D0
        STOT = 0.0D0
        DO IPTS=0,NPTS
          SRES = SRES + (VG(IPTS)-VF(IPTS))**2
          STOT = STOT + (VG(IPTS)-YB      )**2
        ENDDO
C
C       DECIDE WHETHER THIS IS THE BEST FIT SO FAR
        RSQ = 1.0D0 - SRES/STOT
        IF(RSQ.GT.RSQBIG) THEN
          ITRYBG = ITRY
          RSQBIG = RSQ
        ENDIF
C
      ENDDO
C
C**********************************************************************C
C     END OF BEST-FIT DETERMINATION -- NOW IMPLEMENT THE BEST ALPHA.   C
C**********************************************************************C
C
C     SET OF GAUSSIAN EXPONENTS
      XI0 = 0.50D0 + 0.25D0*DFLOAT(ITRYBG)/DFLOAT(NTRY)
      XI  = XI0/(RNUC(IZ)**2)
      DO IFT=1,NNUC(IZ)
        XNUC(IZ,IFT) = XI
        XI = 1.5D0*XI
      ENDDO
C
C     RESET FERMI Z MATRIX
      DO IFT=1,NNUC(IZ)
        Z(IFT) = Y(IFT)
      ENDDO
C
C     SET UP MATRIX EQUATIONS FOR SET OF FITTING GAUSSIANS
C
C     FIRST EQUATION ASSERTS NORMALISATION
      DO JFT=1,NNUC(IZ)
        X(1,JFT) = 1.0D0
      ENDDO
C
C     SECOND EQUATION ASSERTS R^2 VALUE
      DO JFT=1,NNUC(IZ)
        X(2,JFT) = 1.5D0/XNUC(IZ,JFT)
      ENDDO
C
C     ALL OTHER EQUATIONS MATCH TO THE FERMI NUCLEUS
      DO IFT=3,NNUC(IZ)
C
C       MATCHING RADIUS: LINEAR GRID BETWEEN 0.0D0 AND 2.0D0*RNUC(IZ)
        R = 2.0D0*DFLOAT(IFT-ITG)*RNUC(IZ)/DFLOAT(NNUC(IZ)-ITG)
C
C       ERF(R)/R POTENTIALS AT THIS RADIUS
        DO JFT=1,NNUC(IZ)
          X(IFT,JFT) = VNGAUSS(R,XNUC(IZ,JFT),1.0D0)
        ENDDO
C
      ENDDO
C
C     SOLVE THE MATRIX EQUATION X.A = Z FOR AMLPITUDES A
      CALL DGESV(NNUC(IZ),1,X,NNUC(IZ),IPIV,Z,NNUC(IZ),INFO)
C
C     TRANSFER THE X VALUES TO FRACTIONAL ARRAY
      DO IFT=1,NNUC(IZ)
        FNUC(IZ,IFT) = Z(IFT)
      ENDDO
C
C     QUIT HERE IF NO WRITTEN RESULTS ARE REQUIRED
      IF(IWRT.EQ.0) GOTO 20
C
C     WRITE THE BEST-FIT SOLUTION
35    FORMAT(1X,A,I2)
36    FORMAT(1X,A,F10.8,1X,A)
37    FORMAT(1X,A,I2,A,F10.5,A,F8.5,A)
      WRITE(6, *) ''
      WRITE(7, *) ''
      WRITE(6,35) 'Nuclear gaussian basis set for IZ = ',IZ
      WRITE(7,35) 'Nuclear gaussian basis set for IZ = ',IZ
      WRITE(6,36) 'Here ξ0 = 3/2R_n^2 and R_n  = ',RNUC(IZ),'a0'
      WRITE(7,36) 'Here ξ0 = 3/2R_n^2 and R_n  = ',RNUC(IZ),'a0'
      WRITE(6,36) 'Least-squares best fit: R^2 = ',RSQBIG
      WRITE(7,36) 'Least-squares best fit: R^2 = ',RSQBIG
      WRITE(6, *) REPEAT('-',45)
      WRITE(7, *) REPEAT('-',45)
      DO IFT=1,NNUC(IZ)
        XMULT = 2.0D0*RNUC(IZ)*RNUC(IZ)*XNUC(IZ,IFT)/3.0D0
        WRITE(6,37) 'Gaussian ',IFT,': ',FNUC(IZ,IFT),'*exp(-',XMULT,
     &                                                       ' ξ0 r^2)'
        WRITE(7,37) 'Gaussian ',IFT,': ',FNUC(IZ,IFT),'*exp(-',XMULT,
     &                                                       ' ξ0 r^2)'
      ENDDO
      WRITE(6, *) REPEAT('-',45)
      WRITE(7, *) REPEAT('-',45)
C
C**********************************************************************C
C     RADIAL MOMENTS FOR THIS AND OTHER MODELS.                        C
C**********************************************************************C
C
C     SINGLE GAUSSIAN NUCLEAR CHARGE
      DO I=-2,8
        FC1 = 4.0D0/PI12
        FC2 = (2.0D0/3.0D0)**(0.5D0*I)
        FC3 = RNUC(IZ)**I
        FC4 = GAMHLF(5+I)
        FC5 = 3.0D0+I
        R0(I) = FC1*FC2*FC3*FC4/FC5
      ENDDO
C
C     UNIFORMLY-CHARGED NUCLEUS
      DO I=-2,8
        FC1 = 3.0D0
        FC2 = (5.0D0/3.0D0)**(0.5D0*I)
        FC3 = RNUC(IZ)**I
        FC5 = 3.0D0+I
        RU(I) = FC1*FC2*FC3/FC5
      ENDDO
C
C     FINITE SET OF GAUSSIANS
      DO I=-2,8
        RG(I) = 0.0D0
        DO IFT=1,NNUC(IZ)
          XI  = XNUC(IZ,IFT)
          FC  = FNUC(IZ,IFT)
          FC1 = FC*2.0D0/PI12
          FC2 = GAMHLF(3+I)
          FC3 = XI**(0.5D0*I)
          RG(I) = RG(I) + FC1*FC2/FC3
        ENDDO
      ENDDO
C
C     CREATE TABLE FOR THE MOMENTS
49    FORMAT(2X,A,7X,A,12X,A,12X,A,12X,A)
52    FORMAT(2X,'<r^',I2,'>^1/',I2,4(2X,ES16.8))
53    FORMAT(2X,'<r^',I2,'>',5X,4(2X,ES16.8))
      WRITE(6, *) ''
      WRITE(7, *) ''
      WRITE(6,49) 'Moment (fm or e)','Gauss0','Unifrm',' Fermi','Bestft'
      WRITE(7,49) 'Moment (fm or e)','Gauss0','Unifrm',' Fermi','Bestft'
      WRITE(6, *) REPEAT('-',84)
      WRITE(7, *) REPEAT('-',84)
      CF = 1.0D0/(CFM**2)
      DO I=-2,8
        IF(I.NE.0) THEN
          RU(I) = (RU(I)*CF)**(1.0D0/DFLOAT(I))
          RF(I) = (RF(I)*CF)**(1.0D0/DFLOAT(I))
          RG(I) = (RG(I)*CF)**(1.0D0/DFLOAT(I))
          R0(I) = (R0(I)*CF)**(1.0D0/DFLOAT(I))
          WRITE(6,52) I,I,R0(I),RU(I),RF(I),RG(I)
          WRITE(7,52) I,I,R0(I),RU(I),RF(I),RG(I)
        ELSE
          RU(I) = RU(I)*CF
          RF(I) = RF(I)*CF
          RG(I) = RG(I)*CF
          R0(I) = R0(I)*CF
          WRITE(6,53) I,  R0(I),RU(I),RF(I),RG(I)
          WRITE(7,53) I,  R0(I),RU(I),RF(I),RG(I)
        ENDIF
        CF = CF*CFM
      ENDDO
      WRITE(6, *) REPEAT('-',84)
      WRITE(7, *) REPEAT('-',84)
      WRITE(6, *) ''
      WRITE(7, *) ''
C
C**********************************************************************C
C     SCALAR POTENTIALS FOR THIS AND OTHER MODELS.                     C
C**********************************************************************C
C
C     POTENTIALS FOR ALL EXACT NUCLEAR MODELS
      DO IPTS=0,NPTS
C
C       RADIAL VALUE
        R = 5.0D0*DFLOAT(IPTS)*RNUC(IZ)/DFLOAT(NPTS)
C
C       FERMI POTENTIAL
        VF(IPTS) = VNFERMI(R,CFMI(IZ),TFMI(IZ))
C
C       SINGLE GAUSSIAN POTENTIAL
        V0(IPTS) = VNGAUSS(R,1.5D0/(RNUC(IZ)*RNUC(IZ)),1.0D0)
C
C       UNIFORM POTENTIAL
        IF(R.LT.DSQRT(5.0D0/3.0D0)*RNUC(IZ)) THEN
          CU = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
          VU(IPTS) = 0.5D0*(3.0D0 - (R/CU)**2)/CU
        ELSE
          VU(IPTS) = 1.0D0/R
        ENDIF
C
C       FINITE SET OF GAUSSIANS
        VG(IPTS) = 0.0D0
        DO IFT=1,NNUC(IZ)
          VG(IPTS) = VG(IPTS) + VNGAUSS(R,XNUC(IZ,IFT),FNUC(IZ,IFT))
        ENDDO
C
C       WRITE ALL THIS INTO A BIG ARRAY
        RADS(IPTS) = R/RNUC(IZ)
        POTENTIALS(1,IPTS) = VU(IPTS)
        POTENTIALS(2,IPTS) = VF(IPTS)
        POTENTIALS(3,IPTS) = VG(IPTS)
        POTENTIALS(4,IPTS) = V0(IPTS)
C
      ENDDO
C
C     CREATE A TABLE FOR THE POTENTIALS
50    FORMAT(1X,F8.4,'R',3X,F20.10,2X,F20.10,2X,F20.10)
51    FORMAT(2X,A,13X,A,11X,A,11X,A)
      WRITE(6,51) 'Radius r','V_Fermi(r)','V_GaussN(r)','V_Gauss0(r)'
      WRITE(7,51) 'Radius r','V_Fermi(r)','V_GaussN(r)','V_Gauss0(r)'
      WRITE(6, *) REPEAT('-',76)
      WRITE(7, *) REPEAT('-',76)
      DO IPTS=0,NPTS
        R = 5.0D0*DFLOAT(IPTS)*RNUC(IZ)/DFLOAT(NPTS)
        WRITE(6,50) R/RNUC(IZ),VF(IPTS),VG(IPTS),V0(IPTS)
        WRITE(7,50) R/RNUC(IZ),VF(IPTS),VG(IPTS),V0(IPTS)
      ENDDO
      WRITE(6, *) REPEAT('-',76)
      WRITE(7, *) REPEAT('-',76)
C
C     FILE NAME AND TITLES
      XOUT   = 'Potentials'
      TITLE  = 'Potentials'
      XAXIS  = 'r/RNUC'
      YAXIS  = '-V(r)/Z'
      KEY(1) = 'Uniform'
      KEY(2) = 'Fermi'
      KEY(3) = 'Gauss(N)'
      KEY(4) = 'Gauss(1)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) RADS(IPTS),(ABS(POTENTIALS(ITP,IPTS)),ITP=1,4)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
20    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE NUCUEHL(IZ,NFT,IWRT,RSQBIG,RZER,QPOL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC  UU    UU EEEEEEEE HH    HH LL          C
C    NNN   NN UU    UU CC    CC UU    UU EE       HH    HH LL          C
C    NNNN  NN UU    UU CC       UU    UU EE       HH    HH LL          C
C    NN NN NN UU    UU CC       UU    UU EEEEEE   HHHHHHHH LL          C
C    NN  NNNN UU    UU CC       UU    UU EE       HH    HH LL          C
C    NN   NNN UU    UU CC    CC UU    UU EE       HH    HH LL          C
C    NN    NN  UUUUUU   CCCCCC   UUUUUU  EEEEEEEE HH    HH LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCUEHL GENERATES A BEST-FIT GAUSSIAN SET FOR THE UEHLING POTENTIAL C
C  ARISING FROM NUCLEUS IZ, USING NFT TOTAL GAUSSIANS.                 C
C -------------------------------------------------------------------- C
C  MATCHING CRITERIA AVAILABLE FOR GAUSSIAN AMPLITUDES:                C
C   ▶ RADIAL ARGUMENTS SCALED BY NUCLEAR RMS RADIUS RNUC(IZ).          C
C   ▶ UEHLING POTENTIAL FIRST SCALED TO R*R*V(R).                      C
C   ▶ ZEROTH MOMENT SATISFIED AUTOMATICALLY BUT SECOND MOMENT ENFORCED.C
C   ▶ POTENTIAL MATCHED TO NFT POINTS, FROM 3.0D0*RNUC TO 200.0D0*RNUC.C
C   ▶ MATCHING POINTS ARE EXPONENTIALLY SPACED.                        C
C   ▶ GAUSSIAN EXPONENTS FROM MODIFIED GEOMETRIC SERIES WITH THE SAME  C
C     BETA AND GAMMA, BUT ALPHA IS SCALED BY RNUC*RNUC.                C
C   ▶ WHEN THIS IS COMPLETE, POTENTIAL V(R) NEAR R=0.0D0 IS AUGMENTED  C
C     WITH SOME MORE GAUSSIANS WITH LARGER EXPONENTS IF V(R) IS NEEDED.C
C**********************************************************************C
      INCLUDE 'parameters.h'
      PARAMETER(NPTS=6000)
C
      CHARACTER*2 ELMT(120)
      CHARACTER*3  ATRM
      CHARACTER*5  NMDL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(2)
C
      DIMENSION XS(0:NLW),Y2S(0:NLW),D2S(0:NLW),Y1S(0:NLW),D1S(0:NLW),
     &          XB(0:NUP),Y2B(0:NUP),D2B(0:NUP)
      DIMENSION VF(0:NPTS),VG(0:NPTS),RU(0:NPTS)
      DIMENSION X(NFT,NFT),Z(NFT),Y(NFT),RM(NFT),IPIV(NFT)
      DIMENSION RHO(0:NSRC)
      DIMENSION POL(0:NPTS),RK(-2:5)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BQED/RUEH(MCT,3),FUEH(MCT,MFT),XUEH(MCT,MFT),NUEH(MCT)
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/UEHQ/RAD(0:NRAD),VVAC(MCT,0:NRAD),RORI,RMID,RMAX,NLIN,NEXP
C
C     MULTIPLIER FOR COMPTON WAVELENGTH (USE FOR MUON OR TAUON FIELD)
      CMPF = CMPW/1.0D0
C
C     CHECK THAT THERE ARE ENOUGH FITTING FUNCTIONS
      IF(NFT.LT.15) THEN
        WRITE(6, *) 'In NUCUEHL: need more fitting functions. NFT =',NFT
        WRITE(7, *) 'In NUCUEHL: need more fitting functions. NFT =',NFT
        STOP
      ELSEIF(NFT+1.GT.MFT) THEN
        WRITE(6, *) 'In NUCUEHL: too many fitting functions. NFT =',NFT
        WRITE(7, *) 'In NUCUEHL: too many fitting functions. NFT =',NFT
        STOP
      ENDIF
C
C     NUMBER OF FITTING FUNCTIONS
      NUEH(IZ) = NFT
C
C     ZEROTH, SECOND AND FOURTH MOMENTS OF POLARISED CHARGE DENSITY
      RUEH(IZ,1) = 0.0D0
      RUEH(IZ,2) = 2.0D0*CMPF*CMPF/(5.0D0*PI*CV)
      RUEH(IZ,3) = 4.0D0*CMPF*CMPF*RNUC(IZ)*RNUC(IZ)/(3.0D0*PI*CV) 
     &           + 6.0D0*CMPF*CMPF*CMPF*CMPF/(7.0D0*PI*CV)
C
C**********************************************************************C
C     GENERATE AND IMPORT THE INTERPOLATED CHI FUNCTIONS               C
C**********************************************************************C
C
C     GENERATE UEHLING ANCILLIARY FUNCTIONS AND WRITE TO FILE
C     CALL CHIGEN
C
C     IMPORT SPLINE DATA FOR X*CHI_1(X) GIVEN 0 <= X <= XSPL
      OPEN(UNIT=50,FILE='chi1x.dat',STATUS='UNKNOWN')
      REWIND(UNIT=50)
      READ(50,*) XSPL
      DO N=0,NLW
        READ(50,*) XS(N),Y1S(N),D1S(N)
      ENDDO
      CLOSE(UNIT=50)
C
C     IMPORT SPLINE DATA FOR CHI_2(X) GIVEN 0 <= X <= XSPL
      OPEN(UNIT=52,FILE='chi2_small.dat',STATUS='UNKNOWN')
      REWIND(UNIT=52)
      READ(52,*) XSPL
      DO N=0,NLW
        READ(52,*) XS(N),Y2S(N),D2S(N)
      ENDDO
      CLOSE(UNIT=52)
C
C     IMPORT SPLINE DATA FOR CHI_2(X) GIVEN X >= XSPL
      OPEN(UNIT=53,FILE='chi2_big.dat',STATUS='UNKNOWN')
      REWIND(UNIT=53)
      READ(53,*) XSPL
      DO N=0,NUP
        READ(53,*) XB(N),Y2B(N),D2B(N)
      ENDDO
      CLOSE(UNIT=53)
C
C**********************************************************************C
C     INTEGRATION PARAMETERS AND UEHLING POTENTIAL AT THE ORIGIN       C
C**********************************************************************C
C
C     SEARCH FOR CHARGE RADIUS SMAX FOR WHICH RHO(SMAX) < 1.0D-16
      SMAX = 0.0D0
60    SMAX = SMAX + 0.1D0/CFM
      PMAX = SMAX*RHONUC(IZ,SMAX)
      IF(DABS(PMAX).GT.1.0D-16) GOTO 60
C
C     SOURCE CHARGE STEP SIZE
      HS = SMAX/DFLOAT(NSRC)
C
C     EVALUATE CHARGE DENSITY ON UNIFORMLY-SPACED GRID
      DO M=0,NSRC
        S = HS*DFLOAT(M)
        RHO(M) = RHONUC(IZ,S)
      ENDDO
C
C     UEHLING POTENTIAL ORIGIN VALUE
      V0 = 0.0D0
      DO M=1,NSRC
C
C       SOURCE CHARGE RADIUS
        S  = HS*DFLOAT(M)
C
C       X*CHI_1(X) VALUE (ARGUMENT WILL ALWAYS BE LESS THAN 0.6D0)
        X0 = 2.0D0*S/CMPF
        CALL SPLNINT(XS,Y1S,D1S,X0,C0,NLW)
C
C       CONTRIBUTION TO INTEGRAND
        V0 = V0 + EXTINT11(RHO(M)*C0,M,NSRC)
C
      ENDDO
C
C     MULTIPLICATIVE FACTORS FOR VUEH(0)
      V0 = 5.0D0*HS*V0/2.99376D+5
      V0 =-4.0D0*CMPF*V0/(3.0D0*CV)
C
C**********************************************************************C
C     UEHLING POTENTIAL VALUES ON THE TESTING GRID.                    C
C**********************************************************************C
C
C     UEHLING POTENTIAL SAMPLING VALUES (FOR R-SQUARED CALCULATION)
      RLIM = 250.0D0
C
C     STORE R*R*V(R) ON THE UNIFORM GRID IN VF(0:NPTS)
      RU(0) = 0.0D0
      VF(0) = 0.0D0
C
      DO IPTS=1,NPTS
C
C       RADIUS ON UNIFORM SCALE
        R = RLIM*DFLOAT(IPTS)*RNUC(IZ)/DFLOAT(NPTS)
C
C       STORE FOR LATER
        RU(IPTS) = R
C
C       INITIALISE POTENTIAL VALUE
        VF(IPTS) = 0.0D0
C
C       INTEGRATE OVER CHARGE SOURCE
        DO M=0,NSRC
C
C         SOURCE RADIUS
          S  = HS*DFLOAT(M)
C
C         CHI FUNCTION ARGUMENTS
          XM = 2.0D0*DABS(R-S)/CMPF
          XP = 2.0D0*DABS(R+S)/CMPF
C
C         COMPONENTS OF INTEGRAND
          IF(0.5D0*(XM+XP).LT.XSPL) THEN
            CALL SPLNINT(XS,Y2S,D2S,XM,CM,NLW)
            CALL SPLNINT(XS,Y2S,D2S,XP,CP,NLW)    
          ELSE
            CALL SPLNINT(XB,Y2B,D2B,XM,CM,NUP)
            CALL SPLNINT(XB,Y2B,D2B,XP,CP,NUP)
          ENDIF
C
C         PERFORM THE MAPPING CHI(X) = SPLINE(X)*EXP(-X)
          CM = CM*DEXP(-XM)
          CP = CP*DEXP(-XP)
C
C         CONTRIBUTION TO INTEGRAND
          VF(IPTS) = VF(IPTS) + EXTINT11(S*RHO(M)*(CM-CP),M,NSRC)
C
        ENDDO
C
C       INTEGRATION WEIGHTING FACTORS
        VF(IPTS) = 5.0D0*HS*VF(IPTS)/2.99376D+5
C
C       OTHER FACTORS NEEDED FOR V(R)
        VF(IPTS) =-2.0D0*CMPF*VF(IPTS)/(3.0D0*CV*R)
C
      ENDDO
C
C**********************************************************************C
C     UEHLING POTENTIAL VALUES ON THE MATCHING GRID.                   C
C**********************************************************************C
C
C     FIRST CONDITION MATCHES RMS RADIUS
      Y(1) = RUEH(IZ,2)
C
C     SECOND CONDITION MATCHES FOURTH RADIAL MOMENT
      Y(2) = RUEH(IZ,3)
C
C     DIVIDE NFT POINTS INTO DIRECT AND WEIGHTED REGIONS
      NDCT = (NFT)/4
      NWGT = NFT-NDCT-2
C
C     UEHLING POTENTIAL MATCHING VALUES
      R0 = 0.0D0
      RC = 3.0D0
      RN = 200.0D0
      HD = (RC-R0)/DFLOAT(NDCT)
      HW = DLOG(RN/RC)/DFLOAT(NWGT-1)
C
C     RADIAL MATCHING POINTS
      DO IDCT=1,NDCT
        RM(IDCT     ) = RNUC(IZ)*(R0 + DFLOAT(IDCT-1)*HD)
      ENDDO
      DO IWGT=1,NWGT
        RM(IWGT+NDCT) = RNUC(IZ)*RC*DEXP(DFLOAT(IWGT-1)*HW)
      ENDDO
C
C     STORE R*R*V(R) MATCHING VALUES IN Y(NFT) -- MATRIX EQN SOLUTIONS
      Y(3) = V0
C
      DO IFT=4,NFT
C
C       RADIAL MATCHING POINT
        R = RM(IFT-2)
C
C       INITIALISE VALUE FOR THE POTENTIAL HERE
        Y(IFT) = 0.0D0
C
C       INTEGRATE OVER CHARGE SOURCE
        DO M=0,NSRC
C
C         SET SOURCE RADIUS
          S  = HS*DFLOAT(M)
C
C         CHI FUNCTION ARGUMENTS
          XM = 2.0D0*DABS(R-S)/CMPF
          XP = 2.0D0*DABS(R+S)/CMPF
C
C         COMPONENTS OF INTEGRAND
          IF(0.5D0*(XM+XP).LT.XSPL) THEN
            CALL SPLNINT(XS,Y2S,D2S,XM,CM,NLW)
            CALL SPLNINT(XS,Y2S,D2S,XP,CP,NLW)
          ELSE
            CALL SPLNINT(XB,Y2B,D2B,XM,CM,NUP)
            CALL SPLNINT(XB,Y2B,D2B,XP,CP,NUP)
          ENDIF
C
C         PERFORM THE MAPPING CHI(X) = SPLINE(X)*EXP(-X)
          CM = CM*DEXP(-XM)
          CP = CP*DEXP(-XP)
C
C         CONTRIBUTION TO INTEGRAND
          Y(IFT) = Y(IFT) + EXTINT11(S*RHO(M)*(CM-CP),M,NSRC)
C
        ENDDO
C
C       INTEGRATION WEIGHTING FACTORS
        Y(IFT) = 5.0D0*HS*Y(IFT)/2.99376D+5
C
C       OTHER FACTORS AND UEHLING POTENTIAL V(R)
        Y(IFT) =-2.0D0*CMPF*Y(IFT)/(3.0D0*CV*R)
C
C       DATA POINTS IN THE WEIGHTED REGION MUST BE MULTIPLIED BY R*R
        IF(IFT-2.GT.NDCT) THEN
          Y(IFT) = R*R*Y(IFT)
        ENDIF
C
      ENDDO
C
C**********************************************************************C
C     GIVEN MODIFIED GEOMETRIC SET OF NFT PARAMETERS, FIND BEST ALPHA. C
C**********************************************************************C
C
C     GEOMETRIC PARAMETER SEARCH DETAILS
      ALPH = 2.00D-5
      BETA = 1.60D+0
      GAMA = 0.21D+0
C
C     NUMBER OF INCREMENTS IN SEARCH
      NAF = 1200
C
C     INITIALISE BEST-FIT R-SQUARED AND INDEX FOR ALPHA
      RSQBIG = 0.0D0
      IABG   = 0
C
C     ITERATE OVER ALPHA SEARCH
      DO IA=0,NAF
C
C       TRIAL ALPHA PARAMETER AND FROZEN BETA PARAMETER
        AF = ALPH*(1.0D0 + 3.0D0*DFLOAT(IA)/DFLOAT(NAF))/(RNUC(IZ)**2)
        BF = BETA
C
C       STORE GEOMETRIC SET OF PARAMETERS IN XUEH
        XI = AF
        DO IFT=1,NFT
          XUEH(IZ,IFT) = XI
          RT = DFLOAT(IFT)/DFLOAT(NFT+1)
          XI = BF*XI*(1.0D0 + GAMA*RT*RT)
        ENDDO
C
C       TRANSFER MATCHING VALUES V(R) AND R*R*V(R) INTO Z VECTOR
        DO IFT=1,NFT
          Z(IFT) = Y(IFT)
        ENDDO
C
C       SET UP MATRIX EQUATIONS FOR SET OF FITTING GAUSSIANS
C
C       MATCH THE SECOND MOMENT
        DO JFT=1,NFT
          RAT = PI/XUEH(IZ,JFT)
          X(1,JFT) =-6.0D0*RAT*DSQRT(RAT)/(4.0D0*PI)
        ENDDO
C
C       MATCH THE FOURTH MOMENT
        DO JFT=1,NFT
          RAT = PI/XUEH(IZ,JFT)
          X(2,JFT) =-30.0D0*RAT*DSQRT(RAT)/(4.0D0*PI*XUEH(IZ,JFT))
        ENDDO
C
C       MATCH THE POTENTIAL ITSELF
        DO IFT=3,NFT
C
C         MATCHING RADIUS
          R = RM(IFT-2)
C
C         GAUSSIAN POTENTIALS AT THIS RADIUS
          DO JFT=1,NFT
            IF(IFT-2.LE.NDCT) THEN
              X(IFT,JFT) =     DEXP(-XUEH(IZ,JFT)*R*R)
            ELSE
              X(IFT,JFT) = R*R*DEXP(-XUEH(IZ,JFT)*R*R)
            ENDIF
          ENDDO
C
        ENDDO
C
C       SOLVE THE MATRIX EQUATION X.A = Z FOR AMLPITUDES A
        CALL DGESV(NFT,1,X,NFT,IPIV,Z,NFT,INFO)
C
C       TRANSFER AMPLITUDES VALUES INTO FUEH ARRAY
        DO IFT=1,NFT
          FUEH(IZ,IFT) = Z(IFT)
        ENDDO
C
C       BEST-FIT GAUSSIAN POTENTIAL VALUES ACROSS UNIFORM GRID
        DO IPTS=0,NPTS
C
C         RADIUS ON UNIFORM SCALE
          R = RU(IPTS)
C
C         INITIALISE BEST-FIT POTENTIAL AT THIS RADIUS
          VG(IPTS) = 0.0D0
          DO IFT=1,NFT
            VG(IPTS) = VG(IPTS) + FUEH(IZ,IFT)*DEXP(-XUEH(IZ,IFT)*R*R)
          ENDDO
C
        ENDDO
C
C       AVERAGE POTENTIAL VALUE
        YB = 0.0D0
        DO IPTS=0,NPTS
          YB = YB + VG(IPTS)
        ENDDO
        YB = YB/DFLOAT(NPTS+1)
C
C       PREPARATION FOR R-SQUARED VALUE
        SRES = 0.0D0
        STOT = 0.0D0
        DO IPTS=0,NPTS
          SRES = SRES + RU(IPTS)*RU(IPTS)*(VG(IPTS)-VF(IPTS))**2
          STOT = STOT + RU(IPTS)*RU(IPTS)*(VG(IPTS)-YB      )**2
        ENDDO
C
C       R-SQUARED VALUE AND BEST-FIT CHECK
        RSQ = 1.0D0 - SRES/STOT
        IF(RSQ.GT.RSQBIG) THEN
          IABG   = IA
          RSQBIG = RSQ
        ENDIF
C
      ENDDO
C
C     IF NO SOLUTION CAN BE FOUND, ALERT THE USER
      IF(RSQBIG.LT.0.0D0) THEN
        WRITE(6, *) 'In NUCUEHL: best-fit search failed. IZ =',IZ
        WRITE(7, *) 'In NUCUEHL: best-fit search failed. IZ =',IZ
        STOP
      ENDIF
C
C**********************************************************************C
C     BEST-FIT ALPHA HAS NOW BEEN FOUND -- RESTORE THESE RESULTS.      C
C**********************************************************************C
C
C     BEST-FIT VALUES FOR ALPHA, BETA AND GAMMA
      AF = ALPH*(1.0D0 + 3.0D0*DFLOAT(IABG)/DFLOAT(NAF))
      BF = BETA
      GF = GAMA
C
C     STORE GEOMETRIC SET OF PARAMETERS IN XUEH
      XI = AF/(RNUC(IZ)**2)
      DO IFT=1,NFT
        XUEH(IZ,IFT) = XI
        RT = DFLOAT(IFT)/DFLOAT(NFT+1)
        XI = BF*XI*(1.0D0 + GF*RT*RT)
      ENDDO
C
C     TRANSFER MATCHING VALUES V(R) AND R*R*V(R) INTO Z VECTOR
      DO IFT=1,NFT
        Z(IFT) = Y(IFT)
      ENDDO
C
C     SET UP MATRIX EQUATIONS FOR SET OF FITTING GAUSSIANS
C
C     MATCH THE SECOND MOMENT
      DO JFT=1,NFT
        RAT = PI/XUEH(IZ,JFT)
        X(1,JFT) =-6.0D0*RAT*DSQRT(RAT)/(4.0D0*PI)
      ENDDO
C
C     MATCH THE FOURTH MOMENT
      DO JFT=1,NFT
        RAT = PI/XUEH(IZ,JFT)
        X(2,JFT) =-30.0D0*RAT*DSQRT(RAT)/(4.0D0*PI*XUEH(IZ,JFT))
      ENDDO
C
C     MATCH THE POTENTIAL ITSELF
      DO IFT=3,NFT
C
C       MATCHING RADIUS
        R = RM(IFT-2)
C
C       GAUSSIAN POTENTIALS AT THIS RADIUS
        DO JFT=1,NFT
          IF(IFT-2.LE.NDCT) THEN
            X(IFT,JFT) =     DEXP(-XUEH(IZ,JFT)*R*R)
          ELSE
            X(IFT,JFT) = R*R*DEXP(-XUEH(IZ,JFT)*R*R)
          ENDIF
        ENDDO
C
      ENDDO
C
C     SOLVE THE MATRIX EQUATION X.A = Z FOR AMLPITUDES A
      CALL DGESV(NFT,1,X,NFT,IPIV,Z,NFT,INFO)
C
C     TRANSFER AMPLITUDES VALUES INTO FUEH ARRAY
      DO IFT=1,NFT
        FUEH(IZ,IFT) = Z(IFT)
      ENDDO
C
C**********************************************************************C
C     RESULTS: RADIAL MOMENTS                                          C
C**********************************************************************C
C
C     UEHLING RADIAL MOMENTS (IN HARTREE)
      DO K=-2,5
        BIN = 0.0D0
        DO IFT=1,NFT
          FR = FUEH(IZ,IFT)
          XI = XUEH(IZ,IFT)
          XR = XI**(K+1)
          BIN = BIN-FR*DFLOAT(K)*GAMHLF(K+3)/DSQRT(XR)
        ENDDO
        RK(K) = BIN
      ENDDO
C
C**********************************************************************C
C     RESULTS: POLARISATION CHARGE DENSITY                             C
C**********************************************************************C
C
C     VACUUM POLARISATION CHARGE DENSITY
      DO IPTS=0,NPTS
C
C       RADIUS R
        R = RU(IPTS)
C
C       INTIALISE CHARGE COUNTER
        Q = 0.0D0
        DO IFT=1,NFT
          FR = FUEH(IZ,IFT)
          XI = XUEH(IZ,IFT)
          Q  = Q + 2.0D0*FR*XI*R*R*(3.0D0-2.0D0*R*R*XI)*DEXP(-XI*R*R)
        ENDDO
        POL(IPTS) = Q
C
      ENDDO
C
C     LOCATION OF CHARGE ZERO (LINE OF BEST FIT BETWEEN TWO POINTS)
      RZER = 0.0D0
      DO IPTS=NPTS,0,-1
        IF(POL(IPTS).LT.0.0D0) THEN
          PD   = POL(IPTS)-POL(IPTS-1)
          RZER = (RU(IPTS-1)*POL(IPTS)-RU(IPTS)*POL(IPTS-1))/PD
          GOTO 51
        ENDIF
      ENDDO
51    CONTINUE
C
C     INTEGRATED POLARISED CHARGE UP TO THIS ZERO
      QPOL = 0.0D0
      DO IFT=1,NFT
        FR = FUEH(IZ,IFT)
        XI = XUEH(IZ,IFT)
        QPOL = QPOL - 2.0D0*(RZER**3)*XI*FR*DEXP(-XI*RZER*RZER)
      ENDDO
C
C**********************************************************************C
C     PRINT RESULTS IF PROMPTED                                        C
C**********************************************************************C
C
C     SKIP OUTPUT SECTION UNLESS PROMPTED
      IF(IWRT.EQ.0) GOTO 20
C
C     SOLUTION SET
35    FORMAT(1X,A,I2,A,I3,A,A,A)
36    FORMAT(1X,A,F11.9,1X,A)
37    FORMAT(1X,A,F12.10,A,F6.4,A,F6.4)
38    FORMAT(1X,A,I2,A,F12.7,A,F10.7,A)
      WRITE(6, *) ''
      WRITE(7, *) ''
      WRITE(6,35) 'Uehling best-fit for centre IZ = ',IZ,
     &                  '  (',INT(ANUC(IZ)),'^',ELMT(INT(ZNUC(IZ))),')'
      WRITE(7,35) 'Uehling best-fit for centre IZ = ',IZ,
     &                  '  (',INT(ANUC(IZ)),'^',ELMT(INT(ZNUC(IZ))),')'
      WRITE(6, *) REPEAT('-',45)
      WRITE(7, *) REPEAT('-',45)
      WRITE(6,36) 'Here ξ0 = 1/R_n^2  and  R_n  = ',RNUC(IZ),'a0'
      WRITE(7,36) 'Here ξ0 = 1/R_n^2  and  R_n  = ',RNUC(IZ),'a0'
      WRITE(6,36) '                               ',RNUC(IZ)*CFM,'fm'
      WRITE(7,36) '                               ',RNUC(IZ)*CFM,'fm'
      WRITE(6, *) REPEAT('-',45)
      WRITE(7, *) REPEAT('-',45)
      WRITE(6,37) 'α = ',AF,' ξ0,  β = ',BF,',  γ = ',GF
      WRITE(7,37) 'α = ',AF,' ξ0,  β = ',BF,',  γ = ',GF
      WRITE(6, *) REPEAT('-',45)
      WRITE(7, *) REPEAT('-',45)
      WRITE(6,36) 'Least-squares best fit:     R^2 = ',RSQBIG
      WRITE(7,36) 'Least-squares best fit:     R^2 = ',RSQBIG
      WRITE(6, *) REPEAT('-',45)
      WRITE(7, *) REPEAT('-',45)
      DO IFT=1,NFT
        FR = FUEH(IZ,IFT)
        XI = RNUC(IZ)*RNUC(IZ)*XUEH(IZ,IFT)
        WRITE(6,38) 'f_',IFT,'(r): ',FR,'*exp(-',XI,' ξ0 r^2)'
        WRITE(7,38) 'f_',IFT,'(r): ',FR,'*exp(-',XI,' ξ0 r^2)'
      ENDDO
C
      WRITE(6, *) REPEAT('-',45)
      WRITE(7, *) REPEAT('-',45)
C
C     LOCATION OF CHARGE ZERO
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('-',28)
      WRITE(7, *) REPEAT('-',28)
      WRITE(6, *) 'Charge zero        :',RZER*CFM,' fm'
      WRITE(7, *) 'Charge zero        :',RZER*CFM,' fm'
      WRITE(6, *) 'Charge polarisation:',QPOL
      WRITE(7, *) 'Charge polarisation:',QPOL
      WRITE(6, *) REPEAT('-',28)
      WRITE(7, *) REPEAT('-',28)
C
C     RADIAL MOMENT RESULTS
40    FORMAT(1X,A,I2,4X,ES18.11)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('-',28)
      WRITE(7, *) REPEAT('-',28)
      WRITE(6, *) 'Radial moments (fm^-K):'
      WRITE(7, *) 'Radial moments (fm^-K):'
      WRITE(6, *) REPEAT('-',28)
      WRITE(7, *) REPEAT('-',28)
      DO K=-2,5
        WRITE(6,40) 'K = ',K,RK(K)*(CFM**K)
        WRITE(7,40) 'K = ',K,RK(K)*(CFM**K)
      ENDDO
      WRITE(6, *) REPEAT('-',28)
      WRITE(7, *) REPEAT('-',28)
C
C**********************************************************************C
C     BEST-FIT UEHLING POTENTIAL ON THE TESTING GRID.                  C
C**********************************************************************C
C
C     THIS TAKES TIME -- SKIP UNLESS YOU WANT QUADRATURE/PLOTTING
      GOTO 20
C
C     BEST-FIT GAUSSIAN POTENTIAL VALUES ACROSS UNIFORM GRID
      DO IPTS=0,NPTS
C
C       RADIUS ON UNIFORM SCALE
        R = RU(IPTS)
C
C       INITIALISE BEST-FIT POTENTIAL AT THIS RADIUS
        VG(IPTS) = 0.0D0
        DO IFT=1,NFT
          VG(IPTS) = VG(IPTS) + FUEH(IZ,IFT)*DEXP(-XUEH(IZ,IFT)*R*R)
        ENDDO
C
      ENDDO
C
C**********************************************************************C
C     EXACT UEHLING POTENTIAL (WEIGHTED BY R*R) ON COMPOSITE GRID.     C
C**********************************************************************C
C
C     NUMBER OF DATA POINTS IN UNIFORMLY-SPACED AND EXPONENTIAL REGION
      NLIN = NRAD/10 - MOD(NRAD/10,10)
      NEXP = NRAD-NLIN
C
C     GENERATE RADIAL GRID (LINEAR FROM FEMTOMETERS, EXPONENTIAL IN AU)
      RORI =  0.0D0/CFM
      RMID = 10.0D0/CFM
      RMAX =  0.5D0
C
      HL = (RMID-RORI)/DFLOAT(NLIN)
      HE = DLOG(RMAX/RMID)/DFLOAT(NEXP)
C
      DO N=0,NLIN
        RAD(N) = RORI + HL*DFLOAT(N)
      ENDDO
C
      DO N=0,NEXP
        RAD(N+NLIN) = RMID*DEXP(HE*DFLOAT(N))
      ENDDO
C
C     ORIGIN VALUE IS A SPECIAL CASE
      VVAC(IZ,0) = 0.0D0
C
C     VALUE OF R*R*V(R) AT EACH OF THESE RADII
      DO N=1,NRAD
C
C       RADIUS R AND INITIALISE COUNTER FOR POTENTIAL
        R = RAD(N)
C
C       INTIALISE POTENTIAL COUNTER
        V = 0.0D0
C
C       INTEGRATE OVER CHARGE SOURCE
        DO M=0,NSRC
C
C         SET SOURCE RADIUS
          S  = HS*DFLOAT(M)
C
C         CHI FUNCTION ARGUMENTS
          XM = 2.0D0*DABS(R-S)/CMPF
          XP = 2.0D0*DABS(R+S)/CMPF
C
C         COMPONENTS OF INTEGRAND
          IF(0.5D0*(XM+XP).LT.XSPL) THEN
            CALL SPLNINT(XS,Y2S,D2S,XM,CM,NLW)
            CALL SPLNINT(XS,Y2S,D2S,XP,CP,NLW)    
          ELSE
            CALL SPLNINT(XB,Y2B,D2B,XM,CM,NUP)
            CALL SPLNINT(XB,Y2B,D2B,XP,CP,NUP)
          ENDIF
C
C         PERFORM THE MAPPING CHI(X) = SPLINE(X)*EXP(-X)
          CM = CM*DEXP(-XM)
          CP = CP*DEXP(-XP)
C
C         CONTRIBUTION TO INTEGRAND
          V = V + EXTINT11(S*RHO(M)*(CM-CP),M,NSRC)
C
        ENDDO
C
C       INTEGRATION WEIGHTING FACTORS
        V = 5.0D0*HS*V/2.99376D+5
C
C       OTHER FACTORS AND FINAL VALUE R*R*V(R)
        VVAC(IZ,N) =-2.0D0*CMPF*R*V/(3.0D0*CV)
C
      ENDDO
C
C**********************************************************************C
C     PLOTTING SECTION                                                 C
C**********************************************************************C
C
C     NAME TAG FOR PDF DOCUMENTS
      IF(INT(ANUC(IZ)).LT.10) THEN
        WRITE(ATRM,'(A,I1)') '00',INT(ANUC(IZ))
      ELSEIF(INT(ANUC(IZ)).LT.100) THEN
        WRITE(ATRM,'(A,I2)') '0',INT(ANUC(IZ))
      ELSE
        WRITE(ATRM,'(I3)') INT(ANUC(IZ))
      ENDIF
C
C     DETAILS COMMON TO ALL PLOTS
      XAXIS  = 'r/RNUC'
      KEY(1) = 'Exact Uehling'
      KEY(2) = 'Best fit'
C
C     UNIFORM GRID VALUES R*R*V(R)
      XOUT   = 'Uehling-uniform'//TRIM(ATRM)
      TITLE  = 'Uehling r^{2}*V(r) on uniform grid'
      YAXIS  = 'r^{2}*V(r)/Z'
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
      DO IPTS=0,NPTS
        R = RU(IPTS)
        WRITE(8, *) R/RNUC(IZ),R*R*VF(IPTS),R*R*VG(IPTS)
      ENDDO
      CLOSE(UNIT=8)
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,2,KEY)
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
C     CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
C     NUMERICAL EVALUATION FOR V(R)
      XOUT   = 'Uehling-pointwise'//TRIM(ATRM)
      TITLE  = 'Uehling V(r) on piecewise grid'
      YAXIS  = 'V(r)/Z'
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
      DO N=0,NRAD
        R = RAD(N)
        IF(R/RNUC(IZ).GT.5.0D0) GOTO 123
C       TRUE UEHLING POTENTIAL
        IF(N.EQ.0) THEN
          VTR = V0
        ELSE
          VTR = VVAC(IZ,N)/(R*R)
        ENDIF
C       APPROXIMATE VALUES
        V = 0.0D0
        DO IFT=1,NFT
          V = V + FUEH(IZ,IFT)*DEXP(-XUEH(IZ,IFT)*R*R)
        ENDDO
        WRITE(8, *) R*cfm,VTR,V
      ENDDO
123   CONTINUE
      CLOSE(UNIT=8)
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,2,KEY)
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
C     CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
C     UNIFORM GRID VALUES R*R*V(R)
      XOUT   = 'Uehling-charge'//TRIM(ATRM)
      TITLE  = 'Uehling rho(r) on uniform grid'
      YAXIS  = 'rho(r)/Z'
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
      DO IPTS=0,NPTS/25
        R = RU(IPTS)
        WRITE(8, *) R/rnuc(iz),0.0d0,POL(IPTS)
      ENDDO
      CLOSE(UNIT=8)
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,2,KEY)
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
20    CONTINUE
C
      RETURN
      END
C
C
      FUNCTION VNGAUSS(R,XI,FRAC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  GGGGGG     AA    UU    UU  SSSSSS   SSSSSS     C
C    VV    VV NNN   NN GG    GG   AAAA   UU    UU SS    SS SS    SS    C
C    VV    VV NNNN  NN GG        AA  AA  UU    UU SS       SS          C
C    VV    VV NN NN NN GG       AA    AA UU    UU  SSSSSS   SSSSSS     C
C     VV  VV  NN  NNNN GG   GGG AAAAAAAA UU    UU       SS       SS    C
C      VVVV   NN   NNN GG    GG AA    AA UU    UU SS    SS SS    SS    C
C       VV    NN    NN  GGGGGG  AA    AA  UUUUUU   SSSSSS   SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNGAUSS EVALUATES THE ARISING FROM ONE TERM IN THE SET OF GAUSSIAN  C
C  DISTRIBUTIONS AT A PARTICULAR RADIUS R.                             C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      IF(R.LT.1.0D-10) THEN
        XR2 = XI*R*R
        V0  = 2.0D0-2.0D0*XR2/3.0D0+XR2*XR2/5.0D0-XR2*XR2*XR2/21.0D0
        VNGAUSS = -V0*DSQRT(XI)/PI12
      ELSE
        VNGAUSS = -DERF(DSQRT(XI)*R)/R
      ENDIF
C
C     FINAL VALUE FOR THE POTENTIAL
      VNGAUSS = FRAC*VNGAUSS
C
      RETURN
      END
C
C
      FUNCTION RHONUC(IZ,R)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        RRRRRRR  HH    HH  OOOOOO  NN    NN UU    UU  CCCCCC          C
C        RR    RR HH    HH OO    OO NNN   NN UU    UU CC    CC         C
C        RR    RR HH    HH OO    OO NNNN  NN UU    UU CC               C
C        RR    RR HHHHHHHH OO    OO NN NN NN UU    UU CC               C
C        RRRRRRR  HH    HH OO    OO NN  NNNN UU    UU CC               C
C        RR    RR HH    HH OO    OO NN   NNN UU    UU CC    CC         C
C        RR    RR HH    HH  OOOOOO  NN    NN  UUUUUU   CCCCCC          C
C                                                                      C
C -------------------------------------------------------------------- C
C  RHONUC EVALUATES THE VALUE OF THE NORMALISED NUCLEAR CHARGE DENSITY C
C  FOR NUCLEUS IZ AT RADIUS R, BASED ON A NUCLEAR CHARGE MODEL.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5  NMDL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     RADIUS MUST BE NON-NEGATIVE
      IF(R.LT.0.0D0) THEN
        WRITE(6, *) 'In RHONUC: radius R must be non-negative. R = ',R
        WRITE(7, *) 'In RHONUC: radius R must be non-negative. R = ',R
        STOP
      ENDIF
C
C     REASONS TO USE GAUSSIAN NUCLEAR CHARGE MODEL
      EPS = DSQRT(1.4D0)*PI*0.25D0*TFMI(IZ)/THLG
      IF(NNUC(IZ).EQ.1.OR.EPS.GT.RNUC(IZ)) THEN
C
C       NORMALISATION FACTOR
        YN = XNUC(IZ,1)*DSQRT(XNUC(IZ,1))/(PI*PI12)
        RHONUC = YN*DEXP(-R*R*XNUC(IZ,1))
        RETURN
C
      ENDIF
C
C     THESE PARAMETERS MAKE FOR NEATER EXPRESSIONS
      A  = AFMI(IZ)
      C = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &  - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
      C = DSQRT(C)
      U  = A/C
      C3 = C*C*C
C
C     NORMALISATION CONSTANT
      Y1 = 1.0D0
      Y2 = PI*PI*U*U
      Y3 =-6.0D0*U*U*U*POLYLOG(3,-1.0D0/U)
      YN = 1.0D0/(Y1+Y2+Y3)
      YN = 3.0D0*YN/(4.0D0*PI*C3)
C
C     EXACT FERMI DENSITY FORMULA
      PR = 1.0D0 + DEXP((R-C)/A)
      RHONUC = YN/PR
c
c     new solution
      b = dsqrt(5.0d0/3.0d0)*RNUC(IZ)
      if(r.le.b) then
        rhonuc = 0.75d0/(pi*b*b*b)
      else
        rhonuc = 0.0d0
      endif
C
      RETURN
      END
C
C
      FUNCTION VNFERMI(R,C,T)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN FFFFFFFF EEEEEEEE RRRRRRR  MM       MM IIII     C
C    VV    VV NNN   NN FF       EE       RR    RR MMM     MMM  II      C
C    VV    VV NNNN  NN FF       EE       RR    RR MMMM   MMMM  II      C
C    VV    VV NN NN NN FFFFFF   EEEEEE   RR    RR MM MM MM MM  II      C
C     VV  VV  NN  NNNN FF       EE       RRRRRRR  MM  MMM  MM  II      C
C      VVVV   NN   NNN FF       EE       RR    RR MM   M   MM  II      C
C       VV    NN    NN FF       EEEEEEEE RR    RR MM       MM IIII     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNFERMI EVALUATES THE NORMALISED SCALAR POTENTIAL ARISING FROM THE  C
C  TWO-PARAMETER FERMI NUCLEAR CHARGE DISTRIBUTION AT RADIUS R, GIVEN  C
C  HALF-DENSITY RADIUS C AND THE NUCLEAR SKIN THICKNESS T.             C
C  THE POTENTIAL IS EVALUATED IN CASES DEPENDING ON R AND C, AND       C
C  INVOLVES THE USE OF AN AUXILLIARY FUNCTION POLYLOG AS WELL.         C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     RADIUS MUST BE NON-NEGATIVE
      IF(R.LT.0.0D0) THEN
        WRITE(6, *) 'In VNFERMI: radius R must be non-negative. R = ',R
        WRITE(7, *) 'In VNFERMI: radius R must be non-negative. R = ',R
        STOP
      ENDIF
C
C     WARN THE USER IF C<A BUT DON'T STOP
      IF(C.LT.0.25D0*T/THLG) THEN
        WRITE(6, *) 'In VNFERMI: A/C > 1 so expressions diverge.'
        WRITE(7, *) 'In VNFERMI: A/C > 1 so expressions diverge.'
      ENDIF
C
C     THESE PARAMETERS MAKE FOR NEATER EXPRESSIONS
      A   = 0.25D0*T/THLG
      PIA = PI*A
      QAC = A/C
      PAC = PI*A/C
      C3  = C*C*C
C
C     NORMALISATION CONSTANT
      Y1 = 1.0D0
      Y2 = PAC*PAC
      Y3 = 6.0D0*POLYLOG(3,-C/A)*(QAC**3)
      YN = 1.0D0/(Y1+Y2-Y3)
C
C     POTENTIAL DEPENDS ON RADIUS
      IF(R.LE.C) THEN
        V1 = 1.5D0/C
        V2 = 0.5D0*R*R/C3
        V3 = 0.5D0*PIA*PIA/C3
        V4 = 3.0D0*A*A*POLYLOG(2,(R-C)/A)/C3
        IF(R.LT.1.0D-10) THEN
          V5 = (6.0D0*A*A*POLYLOG(2,-C/A) + 3.0D0*A*R*POLYLOG(1,-C/A)
     &                                        + R*R*POLYLOG(0,-C/A))/C3
          V6 = 0.0D0
        ELSE
          V5 = 6.0D0*(QAC**3)*POLYLOG(3,(R-C)/A)/R
          V6 = 6.0D0*(QAC**3)*POLYLOG(3,  -C /A)/R
        ENDIF
        VR = V1-V2+V3-V4+V5-V6
      ELSEIF(R.GT.C) THEN
        V1 = 1.0D0
        V2 = PAC*PAC
        V3 = 0.0D0
        V4 = 3.0D0*R*A*A*POLYLOG(2,-(R-C)/A)/C3
        V5 = 6.0D0*(QAC**3)*POLYLOG(3,-(R-C)/A)
        V6 = 6.0D0*(QAC**3)*POLYLOG(3,   -C /A)
        VR = (V1+V2+V3+V4+V5-V6)/R
      ENDIF
C
C     FINAL VALUE OF POTENTIAL
      VNFERMI =-YN*VR
C
      RETURN
      END
C
C
      FUNCTION POLYLOG(K,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP   OOOOOO  LL      YY    YY LL       OOOOOO   GGGGGG      C
C     PP    PP OO    OO LL      YY    YY LL      OO    OO GG    GG     C
C     PP    PP OO    OO LL      YY    YY LL      OO    OO GG           C
C     PP    PP OO    OO LL       YY  YY  LL      OO    OO GG           C
C     PPPPPPP  OO    OO LL        YYYY   LL      OO    OO GG   GGG     C
C     PP       OO    OO LL         YY    LL      OO    OO GG    GG     C
C     PP        OOOOOO  LLLLLLLL   YY    LLLLLLLL OOOOOO   GGGGGG      C
C                                                                      C
C -------------------------------------------------------------------- C
C  POLYLOG EVALUATES THE POLYLOGARITHM FUNCTION OF ORDER K AND         C
C  ARGUMENT -DEXP(X) USING A TRUNCATED SERIES EXPANSION OF LENGTH NTR. C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
C     TRUNCATION OPTION SHOULD BE GREATER THAN 1
      IF(NTR.LE.1) THEN
        WRITE(6, *) 'In POLYLOG: series trunction too low. NTR = ',NTR
        WRITE(7, *) 'In POLYLOG: series trunction too low. NTR = ',NTR
        STOP
      ENDIF
C
C     ARGUMENT X MUST BE NEGATIVE
      IF(X.GT.0.0D0) THEN
        WRITE(6, *) 'In POLYLOG: argument X must be negative. X = ',X
        WRITE(7, *) 'In POLYLOG: argument X must be negative. X = ',X
        STOP
      ENDIF
C
C     INITIAL VALUES
      PHS = 1.0D0
      VAL = 0.0D0
      DO N=1,NTR
        PHS =-PHS
        RNK = DFLOAT(N)**K
        VAL = VAL + PHS*DEXP(X*N)/RNK
      ENDDO
C
C     VALUE OF POLYLOG
      POLYLOG = VAL
C
      RETURN
      END
C
C
      SUBROUTINE NUCGEOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  NN    NN UU    UU  CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C  NNN   NN UU    UU CC    CC GG    GG EE       OO    OO MMM     MMM   C
C  NNNN  NN UU    UU CC       GG       EE       OO    OO MMMM   MMMM   C
C  NN NN NN UU    UU CC       GG       EEEEEE   OO    OO MM MM MM MM   C
C  NN  NNNN UU    UU CC       GG   GGG EE       OO    OO MM  MMM  MM   C
C  NN   NNN UU    UU CC    CC GG    GG EE       OO    OO MM   M   MM   C
C  NN    NN  UUUUUU   CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCGEOM TRANSLATES AND ROTATES A MOLECULE IN A WAY THAT IS BEST     C
C  SUITED TO EFFICIENT COMPUTATION, IDENTIFIES MOLECULAR SHAPE AND     C
C  BOND DISTANCES, AND CALCULATES NUCLEAR REPULSION ENERGY.            C
C -------------------------------------------------------------------- C
C  ▶ THE TSYM PACKAGE (WERNER 1996) CAN BE DIRECTLY IMPLEMENTED HERE - C
C    IT PERFORMS POINT GROUP SYMMETRY ANALYSIS. THIS ALLOWS A BLOCK    C
C    STRUCTURE ACCORDING TO IRREPS FOR THE HAMILTONIAN MATRIX (FASTER).C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*2 ELMT(120),ELA,ELB,ELC
      CHARACTER*5 NMDL
      CHARACTER*8 SPCES
C
      DIMENSION XYZ(3,MCT),DIST(MCT),CENT(3),IZAD(MCT,3)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EUEH
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',19),'NUCLEAR COORDINATES AND POTENTIALS'
      WRITE(7, *) REPEAT(' ',19),'NUCLEAR COORDINATES AND POTENTIALS'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     UNCOMMENT THIS FLAG TO DISABLE ROTATION/TRANSLATION
C     GOTO 500
C
C**********************************************************************C
C     IDENTIFY LARGEST ATOMIC CENTRES                                  C
C**********************************************************************C
C
C     IDENTIFY THE THREE LARGEST NUCLEAR CHARGES
      LZ1 = 0
      LZ2 = 0
      LZ3 = 0
      DO N=1,NCNT
        IZ = INT(ZNUC(N))
        IF(IZ.GT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = LZ1
          LZ1 = IZ
        ELSEIF(IZ.GT.LZ2.AND.IZ.LT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = IZ
        ELSEIF(IZ.GT.LZ3.AND.IZ.LT.LZ2) THEN
          LZ3 = IZ
        ENDIF
      ENDDO
C
C     COUNT CENTRES WITH TOP THREE NUCLEAR CHARGES
      NZ1 = 0
      NZ2 = 0
      NZ3 = 0
      DO N=1,NCNT
        IZ = INT(ZNUC(N))
        IF(IZ.EQ.LZ1) THEN
          NZ1 = NZ1 + 1
          IZAD(NZ1,1) = N
        ELSEIF(IZ.EQ.LZ2) THEN
          NZ2 = NZ2 + 1
          IZAD(NZ2,2) = N
        ELSEIF(IZ.EQ.LZ3) THEN
          NZ3 = NZ3 + 1
          IZAD(NZ3,3) = N
        ENDIF
      ENDDO
C
C     DESIGNATE SPECIES OF MOLECULE
      IF(NZ2.EQ.0) THEN
        SPCES = 'HOMONUC.'
      ELSE
        SPCES = 'HTRONUC.'
      ENDIF
C
C**********************************************************************C
C     TRANSLATION: ORIGIN COINCIDES WITH CENTRE OF ALL HEAVY ATOMS     C
C**********************************************************************C
C
C     CALCULATE CENTRE OF ALL CHARGES LZ1
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ1
          CENT(I) = CENT(I) + BXYZ(I,IZAD(N,1))
        ENDDO
        CENT(I) = CENT(I)/NZ1
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     TRANSLATE MOLECULE BY CENT(I) AND CALCULATE DISTANCE TO ORIGIN
      DO N=1,NCNT
        DO I=1,3
          XYZ(I,N) = BXYZ(I,N) - CENT(I)
        ENDDO
        DIST(N) = DSQRT(XYZ(1,N)**2 + XYZ(2,N)**2 + XYZ(3,N)**2)
      ENDDO
C
C     ALERT THE USER IF TRANSLATION WAS SUBSTANTIAL
      IF(DCNT.GT.1.0D-4) THEN
        WRITE(6, *) 'In NUCGEOM: molecule has been translated.'
        WRITE(7, *) 'In NUCGEOM: molecule has been translated.'
      ENDIF
C
C     ONE-CENTRE (MUST BE ATOMIC)
      IF(NCNT.EQ.1) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'ATOMIC'
C
C       NO ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     FIRST ROTATION: FIX ON A ROTATION CENTRE AND ROTATE TO Z-AXIS.   C
C**********************************************************************C
C
C     IF AN LZ1 CENTRE IS ON Z-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(3,N))
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 200
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTRE THAT DOES NOT LIE ON ORIGIN
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        IF(DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 35
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTRE ALREADY ON
C     THE Z-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ2.
C
C     VECTOR CENTRE OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ2 IS ON Z-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DABS(CENT(3))
      IF(DABS(X).LT.1.0D-4.AND.DCNT.GT.1.0D-4) THEN
        GOTO 200
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON ORIGIN, FIX ON AN LZ2 NOT ON THE ORIGIN
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          IF(DIST(N).GT.1.0D-4) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 35
          ENDIF
        ENDDO
      ENDIF
C
C     LZ1 AND LZ2 ALWAYS SUFFICIENT TO DEFINE A Z ORIENTATION
C
C     SKIP POINT (ROTATION CENTRE HAS BEEN IDENTIFIED)
35    CONTINUE
C
C     CALCULATE FIRST ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
C     BETA  IS ROTATION ANGLE FROM (X,Z) TO (0,Z')
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      BETA  = DACOS(CENT(3)/DCNT)
      CALL ROTATE(XYZ,NCNT,ALPHA,BETA)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Z-AXIS ROTATION NECESSARY
200   CONTINUE
C
C     TWO-CENTRE (MUST BE DIATOMIC)
      IF(NCNT.EQ.2) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'DIATOMIC'
C
C       NO FURTHER ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     SECOND ROTATION: FIX ON A ROTATION CENTRE AND ROTATE TO Y-AXIS.  C
C**********************************************************************C
C
C     CHECK WHETHER MOLECULE IS LINEAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2 + XYZ(2,N)**2
        IF(TEST.GT.1.0D-6) GOTO 40
      ENDDO
      SHAPE = 'LINEAR'
      GOTO 300
40    CONTINUE
C
C     IF AN LZ1 CENTRE IS ON YZ-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DSQRT(XYZ(2,N)**2 + XYZ(3,N)**2)
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 300
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTRE THAT DOES NOT LIE ON ORIGIN OR Z-AXIS
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(2,N))
        IF(DABS(X).GT.1.0D-4.AND.DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 50
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTRE ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ2.
C
C     IF THERE ARE NO LZ2 CENTRES, SKIP ROTATION
      IF(NZ2.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTRE OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ2 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTRE OF LZ2 IS NOT ON Y-AXIS, MAKE IT THE CENTRE
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ2 CENTRE ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ3.
C
C     IF THERE ARE NO LZ3 CENTRES, SKIP ROTATION
      IF(NZ3.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTRE OF ALL LZ3
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ3
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ3
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ3 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTRE OF LZ3 IS NOT ON Y-AXIS, MAKE IT THE CENTRE
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTRE OF LZ3 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTRE OF LZ3 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     SKIP POINT (ROTATION CENTRE HAS BEEN IDENTIFIED)
50    CONTINUE

C     CALCULATE ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      CALL ROTATE(XYZ,NCNT,ALPHA,0.0D0)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Y-AXIS ROTATION NECESSARY
300   CONTINUE
C
C     IF MOLECULE ALREADY HAS LABEL, SKIP
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                                      SHAPE.EQ.'LINEAR') GOTO 400
C
C     CHECK WHETHER MOLECULE IS PLANAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2
        IF(TEST.GT.1.0D-6) GOTO 60
      ENDDO
      SHAPE = 'PLANAR'
60    CONTINUE
C
C     NO MOLECULAR SYMMETRY
      SHAPE = 'NOSYMM'
C
400   CONTINUE
C
C     TRANSFER ALL TEMPORARY COORDINATES TO THE COMMON ARRAY
      DO N=1,NCNT
        DO I=1,3
          BXYZ(I,N) = XYZ(I,N)
        ENDDO
      ENDDO
C
C     ROTATION/TRANSLATION SKIP
500   CONTINUE
C
C**********************************************************************C
C     MOLECULAR GEOMETRY, BOND DISTANCES AND NUCLEAR REPULSION ENERGY  C
C**********************************************************************C
C
C     ATOMIC COORDINATES
20    FORMAT(13X,A)
21    FORMAT(1X,A,12X,A,14X,A,14X,A)
22    FORMAT(1X,I2,' (',A,') ',6X,F16.10,5X,F16.10,5X,F16.10)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) '  Molecular geometry A: Cartesian coordinates'
      WRITE(7,20) '  Molecular geometry A: Cartesian coordinates'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,21) 'Centre','x-coord','y-coord','z-coord'
      WRITE(7,21) 'Centre','x-coord','y-coord','z-coord'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IZ=1,NCNT
        ELA = ELMT(INT(ZNUC(IZ)))
        WRITE(6,22) IZ,ELA,BXYZ(1,IZ),BXYZ(2,IZ),BXYZ(3,IZ)
        WRITE(7,22) IZ,ELA,BXYZ(1,IZ),BXYZ(2,IZ),BXYZ(3,IZ)
      ENDDO
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     BOND ANGLES AND DISTANCES
30    FORMAT(21X,A)
31    FORMAT(1X,A,6X,A,12X,A,12X,A)
32    FORMAT(1X,A,2X,A,7X,F14.6)
33    FORMAT(40X,A,2X,A,2X,A,9X,F14.6)
      IF(NCNT.EQ.1) THEN
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
      ELSEIF(NCNT.GT.1) THEN
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'Molecular geometry B: R-matrix'
        WRITE(7,30) 'Molecular geometry B: R-matrix'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,31) 'C1  C2','Bond length (Å)','C1  C2  C3',
     &                                                    'Angle (deg)'
        WRITE(7,31) 'C1  C2','Bond length (Å)','C1  C2  C3',
     &                                                    'Angle (deg)'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
C
        ICNT = 1
        DO JCNT=2,NCNT
          ELA = ELMT(INT(ZNUC(ICNT)))
          ELB = ELMT(INT(ZNUC(JCNT)))
          R1X = BXYZ(1,JCNT) - BXYZ(1,ICNT)
          R1Y = BXYZ(2,JCNT) - BXYZ(2,ICNT)
          R1Z = BXYZ(3,JCNT) - BXYZ(3,ICNT)
          D1  = DSQRT(R1X*R1X + R1Y*R1Y + R1Z*R1Z)
          WRITE(6,32) ELA,ELB,D1
          WRITE(7,32) ELA,ELB,D1
C
          DO KCNT=2,JCNT-1
            ELA = ELMT(INT(ZNUC(ICNT)))
            ELB = ELMT(INT(ZNUC(JCNT)))
            ELC = ELMT(INT(ZNUC(KCNT)))
            R2X = BXYZ(1,KCNT) - BXYZ(1,ICNT)
            R2Y = BXYZ(2,KCNT) - BXYZ(2,ICNT)
            R2Z = BXYZ(3,KCNT) - BXYZ(3,ICNT)
            D2  = DSQRT(R2X*R2X + R2Y*R2Y + R2Z*R2Z)
            SP  = (R1X*R2X + R1Y*R2Y + R1Z*R2Z)
            D12 = D1*D2
            DEG = 180.0D0/PI
            ANG = DEG*DACOS(SP/D12)
            WRITE(6,33) ELB,ELA,ELC,ANG
            WRITE(7,33) ELB,ELA,ELC,ANG
          ENDDO
          IF(JCNT.NE.NCNT) THEN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
          ENDIF
        ENDDO
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
        DO ICNT=1,NCNT
          DO JCNT=1,ICNT-1
            SEP  = DSQRT((BXYZ(1,ICNT) - BXYZ(1,JCNT))**2
     #                  +(BXYZ(2,ICNT) - BXYZ(2,JCNT))**2
     #                  +(BXYZ(3,ICNT) - BXYZ(3,JCNT))**2)
            EPNT = ZNUC(ICNT)*ZNUC(JCNT)/SEP
C
CC          TODO: MAKE SURE THIS IS RIGHT -- UPDATED WITH FERMI CHARGE
CC          THIS CODE INCLUDES GAUSSIAN CHARGE STRUCTURE EFFECTS,
CC          BUT CORRECTIONS EXCEED DOUBLE FLOAT ACCURACY LIMITS...
C           EERF = 0.0D0
C           DO IFT=1,NNUC(ICNT)
C             DO JFT=1,NNUC(JCNT)
C               EPRD = XNUC(ICNT,IFT)*XNUC(JCNT,JFT)
C               ESUM = XNUC(ICNT,IFT)+XNUC(JCNT,JFT)
C               EGAU = DSQRT(EPRD/ESUM)*SEP
C               EERF = EERF + FNUC(ICNT,IFT)*FNUC(JCNT,JFT)*DERF(EGAU)
C             ENDDO
C           ENDDO
C           ESEP = EPNT*EERF
C
            ESEP = EPNT
            ENUC = ENUC + ESEP

          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FOCKIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       FFFFFFFF OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C       FF      OO    OO CC    CC KK   KK   II  NNN   NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NNNN  NN DD    DD      C
C       FFFFFF  OO    OO CC       KKKKK     II  NN NN NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NN  NNNN DD    DD      C
C       FF      OO    OO CC    CC KK   KK   II  NN   NNN DD    DD      C
C       FF       OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  FOCKIND ASSIGNS INDICES FOR FOCK MATRIX BLOCKS DEPENDING ON BASIS   C
C  NUMBERS IZ, KQN AND MQN QUANTUM NUMBERS OF EACH BASIS FUNCTION.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
C
C     QUANTUM NUMBER LABELS
      ILST = 0
      DO IZ=1,NCNT
        DO IMV=0,MEL
          MQN = 2*IMV+1
C
C         LABEL MQN<0 BLOCKS
          DO KA=1,NKAP(IZ)
            KQN = KAPA(KA,IZ)
            IF(KQN.GT.0) THEN
              LQN = KQN
            ELSE
              LQN =-KQN-1
            ENDIF
            NBAS  = NFNC(LQN,IZ)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LRGE(IZ,KA,MQN) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = IZ
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) =-MQN
              ENDDO
              ILST = ILST+NBAS
            ENDIF
          ENDDO
C
C         LABEL MQN>0 BLOCKS
          DO KA=1,NKAP(IZ)
            KQN = KAPA(KA,IZ)
            IF(KQN.GT.0) THEN
              LQN = KQN
            ELSE
              LQN =-KQN-1
            ENDIF
            NBAS  = NFNC(LQN,IZ)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LRGE(IZ,KA,MQN+1) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = IZ
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) = MQN
              ENDDO
              ILST = ILST + NBAS
            ENDIF
          ENDDO

        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE CARTIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        CCCCCC     AA    RRRRRRR TTTTTTTT IIII NN    NN DDDDDDD       C
C       CC    CC   AAAA   RR    RR   TT     II  NNN   NN DD    DD      C
C       CC        AA  AA  RR    RR   TT     II  NNNN  NN DD    DD      C
C       CC       AA    AA RR    RR   TT     II  NN NN NN DD    DD      C
C       CC       AAAAAAAA RRRRRRR    TT     II  NN  NNNN DD    DD      C
C       CC    CC AA    AA RR    RR   TT     II  NN   NNN DD    DD      C
C        CCCCCC  AA    AA RR    RR   TT    IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  CARTIND GENERATES INDICES FOR EQ-COEFFICIENTS AND R-INTEGRALS.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     LOOP OVER ALL (A,B,C) SO THAT A+B+C=LAM AND APPLY ORDERED ADDRESS
C     (USE T, U AND V AS INTERMEDIATE COUNTERS RESPECTIVELY)
      N = 0
      DO LAM=0,ML4
        DO IT=0,LAM
          DO IU=0,LAM
            DO IV=0,LAM
C
C             TEST WHETER A+B+C=LAM
              IF(IT+IU+IV.NE.LAM) GOTO 10
C
C             UPDATE ADDRESS
              N = N+1
C
C             CARTESIAN INDICES (A,B,C) AND LAM VALUE FOR THIS ADDRESS
              IA(N) = IT
              IB(N) = IU
              IC(N) = IV
              ILAM(N) = LAM
C
C             GLOBAL ADDRESS FOR THIS (A,B,C) INDEX
              IABC(IT,IU,IV) = N
C
C             SKIP POINT FOR (A,B,C) THAT DO NOT ADD TO LAM
10            CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE AUFBAU(IZNC,IQNC,NORB,NOCC,LMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            AA    UU    UU FFFFFFF BBBBBBB     AA    UU    UU         C
C           AAAA   UU    UU FF      BB    BB   AAAA   UU    UU         C
C          AA  AA  UU    UU FF      BB    BB  AA  AA  UU    UU         C
C         AA    AA UU    UU FFFFF   BBBBBBB  AA    AA UU    UU         C
C         AAAAAAAA UU    UU FF      BB    BB AAAAAAAA UU    UU         C
C         AA    AA UU    UU FF      BB    BB AA    AA UU    UU         C
C         AA    AA  UUUUUU  FF      BBBBBBB  AA    AA  UUUUUU          C
C                                                                      C
C -------------------------------------------------------------------- C
C  AUFBAU DETERMINES THE GROUND STATE ELECTRONIC CONFIGURATION OF AN   C
C  ATOM WITH IQNC ELECTRONS. LIMITS ON # ELECTRONS IN THE ATOM:        C
C -------------------------------------------------------------------- C
C  LMAX |  0    1    2    3    4    5 |   OR IN GENERAL FOR LMAX,      C
C  NMAX |  4   20   56  120  220  364 |   NMAX = (2L+2)(2L+3)(2L+4)/6. C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ LMAX IS THE HIGHEST LQN REQUIRED TO DESCRIBE THE GROUND STATE     C
C  ▶ NOCC SAVES THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS      C
C  ▶ NORB SAVES THE NUMBER OF ELECTRONS IN OF TYPE LQN IN SHELL N      C
C  PARAMETERS:                                                         C
C  ▶ IORD STORES THE LQN OF ORBITALS IN ORDER OF HYDROGENIC ENERGY     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION NORB(0:MEL,MKP+1),NOCC(0:MEL),IORD((MEL+1)*(MEL+2))
C
C     INITIALISE THE OCCUPIED NQN SHELL COUNTER FOR EACH LQN
      DO LQN=0,MEL
        NOCC(LQN) = 0
      ENDDO
C
C     RECORD LQNS AS THEY APPEAR IN A FULL AUFBAU COUNT UP TO LMAX
      ICT = 0
C
C     EACH LQN AS THE HIGHEST
      DO LHIGH=0,MEL
C
C       GET TWO DIAGONAL STRIKES FOR THIS LHIGH
        DO MDIAG=1,2
C
C         GO BACKWARDS FROM THIS LQN DOWN TO ZERO AND RECORD LQN
          DO LQN=LHIGH,0,-1
            ICT = ICT + 1
            IORD(ICT) = LQN
          ENDDO
C
        ENDDO
C
      ENDDO
C
C     INITIALISE THE MAX LQN COUNTER
      LMAX = 0
C
C     INITIALISE THE NUMBER OF ELECTRONS LEFT TO FILL ORBITALS WITH
      ILEFT = IQNC
C
C     INITIALISE LOOP OVER ORBITALS
      DO M=1,(MEL+1)*(MEL+2)
C
C       EXIT IF THERE ARE NO ELECTRONS LEFT TO COUNT
        IF(ILEFT.EQ.0) GOTO 20
C
C       THE LQN OF THIS ORBITAL IS STORED IN IORD
        LQN = IORD(M)
C
C       UPDATE THE MAX LQN COUNTER IF NECESSARY
        IF(LQN.GT.LMAX) THEN
          LMAX = LQN
        ENDIF
C
C       ADD TO THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS
        NOCC(LQN) = NOCC(LQN)+1
C
C       DETERMINE NO. OF ELECTRONS REQ'D TO FULLY OCCUPY THIS SUBSHELL
        IFULL = 4*LQN + 2
C
C       BEGIN IF STATEMENT TO DETERMINE THE SUBSHELL OCCUPATION
        IF(ILEFT.GT.IFULL) THEN
C
C         IF THERE ARE MORE ELECTRONS LEFT THAN IFULL, FILL THE SUBSHELL
          NORB(LQN,NOCC(LQN)) = IFULL
          ILEFT = ILEFT-IFULL
C
        ELSE
C
C         OTHERWISE, LEAVE ALL REMAINING ELECTRONS IN THIS NSHELL
          NORB(LQN,NOCC(LQN)) = ILEFT
          GOTO 20
C
C       END THE NSHELL IF STATEMENT
        ENDIF
C
C     END LOOP OVER ATOMIC ORBITALS
      ENDDO
20    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE SPECTRM0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  PPPPPPP   CCCCCC TTTTTTTT RRRRRRR  MM       MM  000000    C
C   SS    SS PP    PP CC    CC   TT    RR    RR MMM     MMM 00   000   C
C   SS       PP    PP CC         TT    RR    RR MMMM   MMMM 00  0000   C
C    SSSSSS  PP    PP CC         TT    RR    RR MM MM MM MM 00 00 00   C
C         SS PPPPPPP  CC         TT    RRRRRRR  MM  MMM  MM 0000  00   C
C   SS    SS PP       CC    CC   TT    RR    RR MM   M   MM 000   00   C
C    SSSSSS  PP        CCCCCC    TT    RR    RR MM       MM  000000    C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPECTRM0 SUMMARISES RESULTS OF THE AVERAGE-OVER-CONFIGURATION       C
C  ATOMIC HARTREE-FOCK SOLUTIONS IN THE USUAL DIRAC BASIS, WITH SOME   C
C  RADIAL EXPECTATION VALUES FOR EACH DEGENERATE ENERGY LEVEL.         C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*1 LLAB,CHS
      CHARACTER*2 ELMT(120),ELNM
      CHARACTER*5 NMDL
      CHARACTER*6 CNFG
C
      COMPLEX*16 COEF(MDM,MDM)
C
      DIMENSION QA(MKP),NUMOCC(0:MEL),NORB(0:MEL,MKP+1)
      DIMENSION PLTN(MCT,MKP+1,MKP),IGLB(MCT,MKP+1,MKP)
      DIMENSION RRA(MBD,MBD),RRB(MBD,MBD),RRC(MBD,MBD),
     &          RRD(MBD,MBD),RRE(MBD,MBD)
      
      DIMENSION EXL(MBS)
      DIMENSION RGLB(MCT,MKP+1,MKP,5)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FILL/NCNF(MCT,0:MEL,MKP+1),NLVL(MCT,0:MEL),CNFG(MCT)
      COMMON/MDLV/ELMT
      COMMON/OCPD/IOCPN(MDM),IOCCM0,IOCTP(MCT,MKP,MKP+1,MKP+1)
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C**********************************************************************C
C     SORTING SECTION: FIND ADDRESSES FOR USUAL ATOMIC ORDER           C
C**********************************************************************C
C
C     COUNTER FOR OCCUPIED ORBITALS
      IOCCML = 0
C
C     LOOP OVER NUCLEAR CENTRES IN THE MOLECULE
      DO IZ=1,NCNT
C
C       IMPORT ATOMIC CHARGE DETAILS
        IZNV = INT(ZNUC(IZ))
        ELNM = ELMT(IZNV)
        ICRG = IQNC(IZ)
        MLQN = (NKAP(IZ)-1)/2
C
C       INITIALISE THE ORBITAL FILLING ARRAY
        DO LQN=0,MEL
          DO NQN=1,MKP+1
            NORB(LQN,NQN) = 0
          ENDDO
        ENDDO
C
C       READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
        IF(CNFG(IZ).EQ.'MANUAL') THEN
          LMXCONF = MLQN
          DO LQN=0,LMXCONF
            NUMOCC(LQN) = NLVL(IZ,LQN)
            DO NQN=1,NLVL(IZ,LQN)
              NORB(LQN,NQN) = NCNF(IZ,LQN,NQN)
            ENDDO
          ENDDO
        ELSEIF(CNFG(IZ).EQ.'AUFBAU') THEN
          CALL AUFBAU(IZNV,ICRG,NORB,NUMOCC,LMXCONF)
        ELSE
          WRITE(6, *) 'In SPECTRM0: invalid configuration choice.'
          WRITE(7, *) 'In SPECTRM0: invalid configuration choice.'
        ENDIF
C
C       LOOP OVER LQNS
        DO LQN=0,LMXCONF
C
C         RECORD LQNA VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
          NBAS = NFNC(LQN,IZ)
          DO IBAS=1,NBAS
            EXL(IBAS) = BEXL(IBAS,LQN,IZ)
          ENDDO
C
C         FRACTIONAL SUBSHELL OCCUPANCY
          DO NQN=1,NUMOCC(LQN)
            QA(NQN) = DFLOAT(NORB(LQN,NQN))/DFLOAT(4*LQN+2)
          ENDDO
C
C         POSITIVE KQN CHOICE (APPLIES ONLY FOR LQN>0)
C
          IF(LQN.EQ.0.OR.HMLT.EQ.'NORL') GOTO 110
C
C         CALCULATE BATCH OF <1/R>, <R> AND INTEGRALS
          CALL MOMNT0(RRA,EXL, LQN  ,NBAS,-2)
          CALL MOMNT0(RRB,EXL, LQN  ,NBAS,-1)
          CALL MOMNT0(RRC,EXL, LQN  ,NBAS, 1)
          CALL MOMNT0(RRD,EXL, LQN  ,NBAS, 2)
          CALL MOMNT0(RRE,EXL, LQN  ,NBAS, 3)
C
C         LOOP OVER |MQN| CHOICES FOR THIS KQN
          DO MQN=1,LQN
C
C           LOOP OVER LISTED NQNS
            DO NQN=1,NUMOCC(LQN)
C
C             SKIP THIS STEP IF ORBITAL IS UNOCCUPIED
              IF(NORB(LQN,NQN).EQ.0) GOTO 101
C
C             SPHERICAL SYMMETRY: FOCUS ON FIRST MQN ONLY
              IF(MQN.EQ.1) THEN
C
C               ADDRESS AND AVERAGE OCCUPATION
                IGLB(IZ,NQN+LQN,2*LQN  ) = IOCPN(IOCCML+1)
                PLTN(IZ,NQN+LQN,2*LQN  ) = QA(NQN)
C
C               FOCK MATRIX ADDRESSES
                IL = LRGE(IZ,2*LQN  ,MQN)
                IS = LRGE(IZ,2*LQN  ,MQN)+NSKP
C
C               COEFFICIENT MATRIX OFFSET
                MOCC = IOCPN(IOCCML+1)+NSKP
C
C               RADIAL MOMENTS
                RA = 0.0D0
                RB = 0.0D0
                RC = 0.0D0
                RD = 0.0D0
                RE = 0.0D0
                DO IBAS=1,NBAS
                  DO JBAS=1,NBAS
C
C                   LARGE-COMPONENT OFFSETS
                    IA = IL+IBAS
                    JA = IL+JBAS
C
C                   SMALL-COMPONENT OFFSETS
                    IB = IS+IBAS
                    JB = IS+JBAS
C
                    KBAS = IBAS+NBAS
                    LBAS = JBAS+NBAS
C
                    RA = RA+COEF(IA,MOCC)*COEF(JA,MOCC)*RRA(IBAS,JBAS)
     &                     +COEF(IB,MOCC)*COEF(JB,MOCC)*RRA(KBAS,LBAS)
                    RB = RB+COEF(IA,MOCC)*COEF(JA,MOCC)*RRB(IBAS,JBAS)
     &                     +COEF(IB,MOCC)*COEF(JB,MOCC)*RRB(KBAS,LBAS)
                    RC = RC+COEF(IA,MOCC)*COEF(JA,MOCC)*RRC(IBAS,JBAS)
     &                     +COEF(IB,MOCC)*COEF(JB,MOCC)*RRC(KBAS,LBAS)
                    RD = RD+COEF(IA,MOCC)*COEF(JA,MOCC)*RRD(IBAS,JBAS)
     &                     +COEF(IB,MOCC)*COEF(JB,MOCC)*RRD(KBAS,LBAS)
                    RE = RE+COEF(IA,MOCC)*COEF(JA,MOCC)*RRE(IBAS,JBAS)
     &                     +COEF(IB,MOCC)*COEF(JB,MOCC)*RRE(KBAS,LBAS)
C
                  ENDDO
                ENDDO
                RGLB(IZ,NQN+LQN,2*LQN  ,1) = RA/QA(NQN)
                RGLB(IZ,NQN+LQN,2*LQN  ,2) = RB/QA(NQN)
                RGLB(IZ,NQN+LQN,2*LQN  ,3) = RC/QA(NQN)
                RGLB(IZ,NQN+LQN,2*LQN  ,4) = RD/QA(NQN)
                RGLB(IZ,NQN+LQN,2*LQN  ,5) = RE/QA(NQN)
C
              ENDIF
C
C             UPDATE NUMBER OF OCCUPIED PAIRS
              IOCCML = IOCCML+2
C
C             SKIP STEP FOR UNOCCUPIED ORBITALS
101           CONTINUE
C
C           END LOOP OVER LISTED NQNS
            ENDDO
C
          ENDDO
C
110       CONTINUE
C
C         NEGATIVE KQN CHOICE
C
C         CALCULATE BATCH OF <1/R>, <R> AND INTEGRALS
          CALL MOMNT0(RRA,EXL,-LQN-1,NBAS,-2)
          CALL MOMNT0(RRB,EXL,-LQN-1,NBAS,-1)
          CALL MOMNT0(RRC,EXL,-LQN-1,NBAS, 1)
          CALL MOMNT0(RRD,EXL,-LQN-1,NBAS, 2)
          CALL MOMNT0(RRE,EXL,-LQN-1,NBAS, 3)
C
C         LOOP OVER |MQN| CHOICES
          DO MQN=1,LQN+1
C
C           LOOP OVER LISTED NQNS
            DO NQN=1,NUMOCC(LQN)
C
C             SKIP THIS STEP IF ORBITAL IS UNOCCUPIED
              IF(NORB(LQN,NQN).EQ.0) GOTO 102
C
C             SPHERICAL SYMMETRY: FOCUS ON FIRST MQN ONLY
              IF(MQN.EQ.1) THEN
C
C               ADDRESS AND AVERAGE OCCUPATION
                IGLB(IZ,NQN+LQN,2*LQN+1) = IOCPN(IOCCML+1)
                PLTN(IZ,NQN+LQN,2*LQN+1) = QA(NQN)
C
C               FOCK MATRIX ADDRESSES
                IL = LRGE(IZ,2*LQN+1,MQN)
                IS = LRGE(IZ,2*LQN+1,MQN)+NSKP
C
C               COEFFICIENT MATRIX OFFSET
                MOCC = IOCPN(IOCCML+1)+NSKP
C
C               RADIAL MOMENTS
                RA = 0.0D0
                RB = 0.0D0
                RC = 0.0D0
                RD = 0.0D0
                RE = 0.0D0
                DO IBAS=1,NBAS
                  DO JBAS=1,NBAS
C
C                   LARGE-COMPONENT OFFSETS
                    IA = IL+IBAS
                    JA = IL+JBAS
C
C                   SMALL-COMPONENT OFFSETS
                    IB = IS+IBAS
                    JB = IS+JBAS
C
                    KBAS = IBAS+NBAS
                    LBAS = JBAS+NBAS
C
                    RA = RA + COEF(IA,MOCC)*COEF(JA,MOCC)*RRA(IBAS,JBAS)
                    RB = RB + COEF(IA,MOCC)*COEF(JA,MOCC)*RRB(IBAS,JBAS)
                    RC = RC + COEF(IA,MOCC)*COEF(JA,MOCC)*RRC(IBAS,JBAS)
                    RD = RD + COEF(IA,MOCC)*COEF(JA,MOCC)*RRD(IBAS,JBAS)
                    RE = RE + COEF(IA,MOCC)*COEF(JA,MOCC)*RRE(IBAS,JBAS)
C
                    IF(HMLT.EQ.'NORL') GOTO 115
C
                    RA = RA + COEF(IB,MOCC)*COEF(JB,MOCC)*RRA(KBAS,LBAS)
                    RB = RB + COEF(IB,MOCC)*COEF(JB,MOCC)*RRB(KBAS,LBAS)
                    RC = RC + COEF(IB,MOCC)*COEF(JB,MOCC)*RRC(KBAS,LBAS)
                    RD = RD + COEF(IB,MOCC)*COEF(JB,MOCC)*RRD(KBAS,LBAS)
                    RE = RE + COEF(IB,MOCC)*COEF(JB,MOCC)*RRE(KBAS,LBAS)
C
115                 CONTINUE
C
                  ENDDO
                ENDDO
                RGLB(IZ,NQN+LQN,2*LQN+1,1) = RA/QA(NQN)
                RGLB(IZ,NQN+LQN,2*LQN+1,2) = RB/QA(NQN)
                RGLB(IZ,NQN+LQN,2*LQN+1,3) = RC/QA(NQN)
                RGLB(IZ,NQN+LQN,2*LQN+1,4) = RD/QA(NQN)
                RGLB(IZ,NQN+LQN,2*LQN+1,5) = RE/QA(NQN)
C
              ENDIF
C
C             UPDATE NUMBER OF OCCUPIED PAIRS
              IOCCML = IOCCML+2
C
C             SKIP STEP FOR UNOCCUPIED ORBITALS
102           CONTINUE
C
C           END LOOP OVER LISTED NQNS
            ENDDO
C
          ENDDO
C
C         NON-RELATIVISTIC SPECIAL CASE: ALSO FILL IN THE +KQN BLOCK
          IF(HMLT.EQ.'NORL'.AND.LQN.GE.1) THEN
C
C           LOOP OVER |MQN| CHOICES
            DO MQN=1,LQN
C
C             LOOP OVER LISTED NQNS
              DO NQN=1,NUMOCC(LQN)
C
C               SKIP THIS STEP IF ORBITAL IS UNOCCUPIED
                IF(NORB(LQN,NQN).GT.0) THEN
                  IOCCML = IOCCML+2
                ENDIF
C
              ENDDO
C
            ENDDO
C
          ENDIF
C
C       END LOOP OVER LQNS
        ENDDO
C
C     END LOOP OVER NUCLEAR CENTRES
      ENDDO     
C
C**********************************************************************C
C     PRINT SPECTRUM                                                   C
C**********************************************************************C
C
C     PRINT TITLE TO TERMINAL/FILE
20    FORMAT(1X,'Z  | nl',8X,'Energy (au)',2X,'Degcy',4X,
     &                          'Frac |',4X,'<1/r>',7X,'<r>',5X,'<r^2>')
21    FORMAT(1X,A,1X,'|',I2,A,A,1X,F17.10,5X,I2,3X,F5.3,' |',
     &                                                    F9.5,2(F10.5))
C
      WRITE(6, *) REPEAT(' ',29),'Atomic summary'
      WRITE(7, *) REPEAT(' ',29),'Atomic summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20)
      WRITE(7,20)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     LOOP OVER NUCLEAR CENTRES IN THE MOLECULE
      DO IZ=1,NCNT
C
C       IMPORT ATOMIC CHARGE DETAILS
        IZNV = INT(ZNUC(IZ))
        ELNM = ELMT(IZNV)
        ICRG = IQNC(IZ)
C
C       INITIALISE THE ORBITAL FILLING ARRAY
        DO LQN=0,MEL
          DO NQN=1,MKP+1
            NORB(LQN,NQN) = 0
          ENDDO
        ENDDO
C
C       READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
        IF(CNFG(IZ).EQ.'MANUAL') THEN
          LMXCONF = (NKAP(IZ)-1)/2
          DO L=0,LMXCONF
            NUMOCC(L) = NLVL(IZ,L)
            DO N=1,NLVL(IZ,L)
              NORB(L,N) = NCNF(IZ,L,N)
            ENDDO
          ENDDO
        ELSEIF(CNFG(IZ).EQ.'AUFBAU') THEN
          CALL AUFBAU(IZNV,ICRG,NORB,NUMOCC,LMXCONF)
        ELSE
          WRITE(6, *) 'In SPECTRM0: invalid configuration choice.'
          WRITE(7, *) 'In SPECTRM0: invalid configuration choice.'
        ENDIF
C
C       LOOP OVER ORBITALS IN THE USUAL AUFBAU ORDER
        DO NQN=1,MKP
          DO LQN=0,NQN-1
C
            IF(LQN.GT.MEL) GOTO 150
            IF(NORB(LQN,NQN-LQN).EQ.0) GOTO 150
C
C           POSITIVE KQN CHOICE (APPLIES ONLY FOR LQN>0)
            IF(LQN.EQ.0.OR.HMLT.EQ.'NORL') GOTO 120
C
C           SYMMETRY LABEL
            CHS = '-'
C
C           DEGENERACY
            IDGN = 2*LQN
C
C           IDENTIFY THE RIGHT INDEX AND PROPERTIES
            MOCC = IGLB(IZ,NQN,2*LQN  )+NSKP
            FRAC = PLTN(IZ,NQN,2*LQN  )
            RAVA = RGLB(IZ,NQN,2*LQN  ,1)
            RAVB = RGLB(IZ,NQN,2*LQN  ,2)
            RAVC = RGLB(IZ,NQN,2*LQN  ,3)
            RAVD = RGLB(IZ,NQN,2*LQN  ,4)
            RAVE = RGLB(IZ,NQN,2*LQN  ,5)
C
C           OUTPUT TO TERMINAL
            WRITE(6,21) ELNM,NQN,LLAB(LQN),CHS,EIGN(MOCC),IDGN,FRAC,
     &                                                  RAVB,RAVC,RAVD
            WRITE(7,21) ELNM,NQN,LLAB(LQN),CHS,EIGN(MOCC),IDGN,FRAC,
     &                                                  RAVB,RAVC,RAVD
C
120         CONTINUE
C
C           NEGATIVE KQN CHOICE (APPLIES ONLY FOR LQN>0)
C
C           SYMMETRY LABEL IF NEEDED
            IF(LQN.EQ.0.OR.HMLT.EQ.'NORL') THEN
              CHS = ' '
            ELSE
              CHS = '+'
            ENDIF
C
C           DEGENERACY
            IF(HMLT.EQ.'NORL') THEN
              IDGN = 4*LQN+2
            ELSE
              IDGN = 2*LQN+2
            ENDIF
C
C           IDENTIFY THE RIGHT INDEX AND PROPERTIES
            MOCC = IGLB(IZ,NQN,2*LQN+1)+NSKP
            FRAC = PLTN(IZ,NQN,2*LQN+1)
            RAVA = RGLB(IZ,NQN,2*LQN+1,1)
            RAVB = RGLB(IZ,NQN,2*LQN+1,2)
            RAVC = RGLB(IZ,NQN,2*LQN+1,3)
            RAVD = RGLB(IZ,NQN,2*LQN+1,4)
            RAVE = RGLB(IZ,NQN,2*LQN+1,5)
C
C           OUTPUT TO TERMINAL
            WRITE(6,21) ELNM,NQN,LLAB(LQN),CHS,EIGN(MOCC),IDGN,FRAC,
     &                                                  RAVB,RAVC,RAVD
            WRITE(7,21) ELNM,NQN,LLAB(LQN),CHS,EIGN(MOCC),IDGN,FRAC,
     &                                                  RAVB,RAVC,RAVD
C
150         CONTINUE
C
          ENDDO
C
        ENDDO
C
C       DELIMETER BETWEEN NUCLEAR CENTRES
        IF(IZ.NE.NCNT) THEN
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF

C     END LOOP OVER NUCLEAR CENTRES
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE SPECTRM(IBND,IVIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  PPPPPPP  EEEEEEEE  CCCCCC TTTTTTTT RRRRRRR  MM       MM   C
C   SS    SS PP    PP EE       CC    CC   TT    RR    RR MMM     MMM   C
C   SS       PP    PP EE       CC         TT    RR    RR MMMM   MMMM   C
C    SSSSSS  PP    PP EEEEEE   CC         TT    RR    RR MM MM MM MM   C
C         SS PPPPPPP  EE       CC         TT    RRRRRRR  MM  MMM  MM   C
C   SS    SS PP       EE       CC    CC   TT    RR    RR MM   M   MM   C
C    SSSSSS  PP       EEEEEEEE  CCCCCC    TT    RR    RR MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPECTRM SUMMARISES THE ENERGY LEVELS OF AN SCF ITERATION, USING     C
C  ATOMIC TERM SYMBOLS, ATOMIC CENTRES AND FRACTIONAL POPULATIONS.     C
C  IT ALSO APPLIES SYMMETRY LABELS TO EACH STATE AND SORTS MQN M'FOLDS.C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IBND - NUMBER OF BOUND ORBITALS TO INCLUDE.                       C
C  ▶ IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE.                     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*1 CHL,LLAB
      CHARACTER*5 NMDL
      CHARACTER*2 ELMT(120),ELA
C
      DIMENSION FRAC(MDM,MCT,MKP,MKP+1),NPR(MCT,MKP,MKP+1)
      DIMENSION ICNLST(MDM),KQNLST(MDM),MQNLST(MDM),NQNLST(MDM),
     &          POPLST(MDM)
C
      COMPLEX*16 CTEMP,ROT1,ROT2
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     RE-CALCULATE OVERLAP FOR NEW CALCULATION RUN
      IF(.NOT.READIN) THEN
        CALL OVRLP
      ENDIF
C
C     SENSITIVITY TOLERANCE PARAMETER
      EPS = 1.0D-16
C
C     INITIALISE COUNTER ARRAYS
      DO IZ=1,NCNT
        DO IKAP=1,NKAP(IZ)
          IKQN = KAPA(IKAP,IZ)
          IF(IKQN.LT.0) THEN
            ILQN =-IKQN-1
          ELSE
            ILQN = IKQN
          ENDIF
          NMV = 2*IABS(IKQN)
          DO IMV=1,NMV
            DO IOCC=1,IBND+IVIR
              FRAC(IOCC,IZ,IKAP,IMV) = 0.0D0
            ENDDO
            NPR(IZ,IKAP,IMV) = ILQN
          ENDDO
        ENDDO
      ENDDO
C
C     INTERNAL ROTATION BETWEEN PAIRS OF STATES
      DO IPAIR=1,NDIM-NSKP,2
C
C       SKIP NEGATIVE ENERGY SPECTRUM
        MPAIR = IPAIR+NSKP
C
C       TEMPORARY LARGE VALUE
        RLRG = 10.0D+10
C
C       INITIAL INCREMENTAL RADIAN (SWEEP OVER ALL POSSIBLE ANGLES)
        RINC = PI/180.0D0
C
C       SEARCH FOR STARTING POINT BY SWEEPING ANGLES 0 <= φ < PI
        DO NPHI=0,179
C
C         CALCULATE ROTATION ANGLE AND COS/SIN TRANSFORMATIONS
          PHI  = RINC*DFLOAT(NPHI)
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
            ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
            OLAP = OLAP + CDABS(ROT1)*CDABS(ROT2)
          ENDDO
C
C         FIND PHI WHICH RESULTS IN SMALLEST SUM OF PRODUCTS
          IF(OLAP.LT.RLRG) THEN
            PHI0 = PHI
            RLRG = OLAP
          ENDIF
        ENDDO
C
C       NEW STARTING ROTATION ANGLE BASED ON THE ABOVE SEARCH
        PHI  = PHI0 - RINC
        SOLD = 1.0D+11
C
C       SWEEP THROUGH INCREMENTAL ANGLES AND SEARCH AGAIN
        DO NPHI=1,4000
          PHI  = PHI + RINC
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
            ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
            OLAP = OLAP + ABS(CONJG(ROT1)*(ROT2))
          ENDDO
C
C         IF THE NEW VALUE IS BELOW A TOLERANCE, FINISH.
          IF(DABS(OLAP-SOLD).LT.EPS) GOTO 1
C
C         IF SUM OF COEFFICIENT PRODUCTS IS BIGGER THAN COUNTER, REFINE.
          IF(OLAP.GT.SOLD) THEN
            RINC =-RINC/10.0D0
          ENDIF
C
C         DECREASE COUNTER VALUE
          SOLD = OLAP
C
        ENDDO
1       CONTINUE
C
C       PERFORM THE ACTUAL ROTATION USING THE BEST SOLUTION PHI
        CPHI = DCOS(PHI)
        SPHI = DSIN(PHI)
        DO I=1,NDIM
C
          ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
          ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
C
          COEF(I,MPAIR  ) = ROT1
          COEF(I,MPAIR+1) = ROT2
C
        ENDDO
C
      ENDDO
C
C     CALCULATE FRACTIONAL OCCUPATION FOR EACH SOLUTION VECTOR
C
C     LOOP OVER OCCUPIED ORBITALS
      DO IOCC=1,IBND+IVIR
C
C       IGNORE NEGATIVE SPECTRUM
        MOCC = IOCC+NSKP
C
C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
        DO I=1,NDIM-NSKP
          IS = I+NSKP
          ICNT = LABICN(I)
          IKQN = LABKQN(I)
          IMQN = LABMQN(I)
          IF(IKQN.LT.0) THEN
            IKAP =-2*IKQN-1
          ELSE
            IKAP = 2*IKQN
          ENDIF
          IF(IMQN.LT.0) THEN
            IMV = IABS(IMQN)
          ELSE
            IMV = IMQN+1
          ENDIF
C
          DO J=1,NDIM-NSKP
            JS = J+NSKP
            JCNT = LABICN(J)
            JKQN = LABKQN(J)
            JMQN = LABMQN(J)
C
C           LARGE AND SMALL CONTRIBUTIONS
            TMP = DREAL(DCONJG(COEF(I ,MOCC))*COEF(J ,MOCC)*OVLP(I ,J ))
     &          + DREAL(DCONJG(COEF(IS,MOCC))*COEF(JS,MOCC)*OVLP(IS,JS))
C
C           DECIDE WHERE TO PUT CONTRIBUTION
            IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
              FRAC(IOCC,ICNT,IKAP,IMV) = FRAC(IOCC,ICNT,IKAP,IMV) + TMP
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     IDENTIFY CONVENTIONAL DIRAC QUANTUM NUMBERS BASED ON FRAC.
C
C     LOOP OVER POSITIVE ENERGY SPECTRUM IN PAIRS
      DO IOCC=1,NDIM-NSKP
C
C       SEARCH FOR HIGHEST POPULATED ATOMIC STATE
        PLTN = 0.0D0
        DO ICNT=1,NCNT
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            NMV  = 2*IABS(IKQN)
            DO IMV=1,NMV
              IF(FRAC(IOCC,ICNT,IKAP,IMV).GT.PLTN) THEN
                PLTN = FRAC(IOCC,ICNT,IKAP,IMV)
                KCNT = ICNT
                KKQN = IKQN
                KKAP = IKAP
                KMV  = IMV
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        NPR(KCNT,KKAP,KMV) = NPR(KCNT,KKAP,KMV)+1
C
C       APPLY DIRAC LABELS ACCORDING TO HIGHEST POPULATED STATE
        NQNLST(IOCC) = NPR(KCNT,KKAP,KMV)
        ICNLST(IOCC) = KCNT
        KQNLST(IOCC) = KKQN
        POPLST(IOCC) = FRAC(IOCC,KCNT,KKAP,KMV)
        IF(MOD(KMV,2).EQ.1) THEN
          MQNLST(IOCC) =-KMV
        ELSE
          MQNLST(IOCC) = KMV-1
        ENDIF
C
C     END LOOP OVER ORBITALS
      ENDDO
C
C     SORTING: ORGANISE POSITIVE-ENERGY SOLUTIONS IN MQN PAIRS
C
      IF(NCNT.EQ.1) THEN
C
C       LOOP OVER ALL STATES
        DO IOCC=1,NDIM-NSKP
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MOCC = IOCC+NSKP
C
C         IDENTIFY KQN OF STATE
          IKQN = KQNLST(IOCC)
C
C         FOR THIS KQN VALUE, SEARCH NEXT 2*|KQN| ENTRIES AND ORDER
C
        ENDDO
C
      ELSEIF(NCNT.GT.1) THEN
C
C       LOOP OVER PAIRS OF STATES
        DO IPAIR=1,NDIM-NSKP,2
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MPAIR = IPAIR+NSKP
C
C         NO NEED TO SWAP IF MQN OF THE FIRST STATE IS NEGATIVE
          IF(MQNLST(IPAIR).LT.0) GOTO 100
C
C         SWAP EIGENVALUES, EXPANSION COEFFICIENTS AND MQN VALUES
          ETEMP         = EIGN(MPAIR+1)
          EIGN(MPAIR+1) = EIGN(MPAIR  )
          EIGN(MPAIR  ) = ETEMP
C
          DO I=1,NDIM
            CTEMP           = COEF(I,MPAIR+1)
            COEF(I,MPAIR+1) = COEF(I,MPAIR  )
            COEF(I,MPAIR  ) = CTEMP
          ENDDO
C
          MTEMP           = MQNLST(IPAIR+1)
          MQNLST(IPAIR+1) = MQNLST(IPAIR  )
          MQNLST(IPAIR  ) = MTEMP
C
          PTEMP           = POPLST(IPAIR+1)
          POPLST(IPAIR+1) = POPLST(IPAIR  )
          POPLST(IPAIR  ) = PTEMP
C
C         SKIP POINT FOR ALREADY-SORTED PAIRS
100       CONTINUE
C
        ENDDO
C
      ENDIF
C
C     PRINT TITLE TO TERMINAL/FILE
20    FORMAT(1X,'Orb.',2X,'Centre',4X,'Term sym.',3X,'m_j',14X,
     &                                    'Energy (au)',6X,'Population')
21    FORMAT(1X,I3,2X,I2,' (',A,')',4X,I2,A,'_',I1,'/2',4X,I2,'/2',7X,
     &                                                  F18.12,6X,F10.8)
C
      WRITE(6,20)
      WRITE(7,20)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     SUMMARISE RESULTS
      DO IOCC=1,IBND+IVIR
C
        MOCC = IOCC+NSKP
C
        ICNT = ICNLST(IOCC)
        INQN = NQNLST(IOCC)
        IKQN = KQNLST(IOCC)
        IMQN = MQNLST(IOCC)
        ELA  = ELMT(INT(ZNUC(ICNT)))
        IF(IKQN.LT.0) THEN
          ILQN =-IKQN-1
        ELSE
          ILQN = IKQN
        ENDIF
        CHL  = LLAB(ILQN)
        IJQN = 2*IABS(IKQN)-1

        IF(IOCC.LE.IBND) THEN
          PLTN = POPLST(IOCC)
        ELSE
          PLTN = 0.0D0
        ENDIF
C
        IF(HMLT.EQ.'NORL') THEN
          PLTN = 0.5D0*PLTN
        ENDIF
C
C       OUTPUT TO TERMINAL
        WRITE(6,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGN(MOCC),PLTN
        WRITE(7,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGN(MOCC),PLTN
        IF(IOCC.EQ.IBND.AND.IVIR.NE.0) THEN
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF
C
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ROTATE(XYZ,NCNT,ALPHA,BETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          RRRRRRR   OOOOOO TTTTTTTT   AA   TTTTTTTT EEEEEEEE          C
C          RR    RR OO    OO   TT     AAAA     TT    EE                C
C          RR    RR OO    OO   TT    AA  AA    TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EEEEEE            C
C          RRRRRRR  OO    OO   TT   AAAAAAAA   TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EE                C
C          RR    RR  OOOOOO    TT   AA    AA   TT    EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ROTATE PERFORMS TWO ROTATIONS ON ALL ATOMIC CENTRES, FIRST SO THAT  C
C  Y DOES NOT CHANGE, AND THEN SO THAT Z DOES NOT CHANGE.              C
C**********************************************************************C
C
      DIMENSION XYZ(3,NCNT),V(3),W(3)
      DIMENSION AR(3,3),BR(3,3),RR(3,3)
C
C     INITIALISE MATRICES
      DO I=1,3
        DO J=1,3
          AR(I,J) = 0.0D0
          BR(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     FIX ALL VALUES OF Z AND ROTATE BY ALPHA
      AR(3,3) = 1.0D0
      AR(1,1) = DCOS(ALPHA)
      AR(2,2) = DCOS(ALPHA)
      AR(1,2) = DSIN(ALPHA)
      AR(2,1) =-DSIN(ALPHA)
C
C     FIX ALL VALUES OF Y AND ROTATE BY BETA
      BR(2,2) = 1.0D0
      BR(1,1) = DCOS(BETA)
      BR(3,3) = DCOS(BETA)
      BR(3,1) = DSIN(BETA)
      BR(1,3) =-DSIN(BETA)
C
C     EVALUATE OVERALL ROTATION MATRIX
      CALL MMPROD(BR,AR,RR,3)
C
C     ROTATE ALL VECTORS IN XYZ
      DO N=1,NCNT
        DO I=1,3
          V(I) = XYZ(I,N)
        ENDDO
        CALL MVPROD(RR,V,W,3)
        DO I=1,3
          XYZ(I,N) = W(I)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MMPROD(A,B,X,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM MM       MM PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD       C
C     MMM     MMM MMM     MMM PP    PP RR    RR OO    OO DD    DD      C
C     MMMM   MMMM MMMM   MMMM PP    PP RR    RR OO    OO DD    DD      C
C     MM MM MM MM MM MM MM MM PP    PP RR    RR OO    OO DD    DD      C
C     MM  MMM  MM MM  MMM  MM PPPPPPP  RRRRRRR  OO    OO DD    DD      C
C     MM   M   MM MM   M   MM PP       RR    RR OO    OO DD    DD      C
C     MM       MM MM       MM PP       RR    RR  OOOOOO  DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  MMPROD CALCULATES THE PRODUCT OF TWO SQUARE, DOUBLE-PRECISION       C
C  MATRIX ARRAYS OF DIMENSION N, AND OUTPUTS THE RESULT INTO X.        C
C**********************************************************************C
C
      DIMENSION A(N,N),B(N,N),X(N,N)
C
C     INITIALISE X MATRIX
      DO I=1,N
        DO J=1,N
          X(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          DO K=1,N
            X(I,J) = X(I,J) + A(I,K)*B(K,J)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MVPROD(A,V,W,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       MM       MM VV    VV PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD        C
C       MMM     MMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MMMM   MMMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM MM MM MM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM  MMM  MM  VV  VV  PPPPPPP  RRRRRRR  OO    OO DD    DD       C
C       MM   M   MM   VVVV   PP       RR    RR OO    OO DD    DD       C
C       MM       MM    VV    PP       RR    RR  OOOOOO  DDDDDDD        C
C                                                                      C
C -------------------------------------------------------------------- C
C  MVPROD CALCULATES THE PRODUCT OF A SQUARE MATRIX OF DIMENSION N     C
C  AND A VECTOR OF DIMENSION N, AND OUTPUTS THE RESULT INTO W.         C
C**********************************************************************C
C
      DIMENSION A(N,N),V(N),W(N)
C
C     INITIALISE W MATRIX
      DO I=1,N
        W(I) = 0.0D0
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          W(I) = W(I) + A(I,J)*V(J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION MS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          MM       MM  SSSSSS                         C
C                          MMM     MMM SS    SS                        C
C                          MMMM   MMMM SS                              C
C                          MM MM MM MM  SSSSSS                         C
C                          MM  MMM  MM       SS                        C
C                          MM   M   MM SS    SS                        C
C                          MM       MM  SSSSSS                         C
C                                                                      C
C -------------------------------------------------------------------- C
C   MS RETURNS A QUOTED TIME IN SECONDS USING 'MIN-SEC' FORMAT.        C
C**********************************************************************C
      CHARACTER*4 MINUTES
      CHARACTER*7 SECONDS
      CHARACTER*11 MS
C
C     INITIALISE COUNTERS
      NMIN = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PRINT THE MINUTE
      IF(NMIN.EQ.0) THEN
        WRITE(MINUTES,'(A)') '    '
      ELSE
        WRITE(MINUTES,'(I3,A)') NMIN,'m'
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F4.2,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F4.2,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(MS,'(A,A)') MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      FUNCTION HMS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                     HH    HH MM       MM  SSSSSS                     C
C                     HH    HH MMM     MMM SS    SS                    C
C                     HH    HH MMMM   MMMM SS                          C
C                     HHHHHHHH MM MM MM MM  SSSSSS                     C
C                     HH    HH MM  MMM  MM       SS                    C
C                     HH    HH MM   M   MM SS    SS                    C
C                     HH    HH MM       MM  SSSSSS                     C
C                                                                      C
C -------------------------------------------------------------------- C
C   HMS RETURNS A QUOTED TIME IN SECONDS USING 'HR-MIN-SEC' FORMAT.    C
C**********************************************************************C
      CHARACTER*4 HOURS,MINUTES
      CHARACTER*8 SECONDS
      CHARACTER*16 HMS
C
C     INITIALISE COUNTERS
      NMIN = 0
      NHRS = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0 <= NMIN < 60
      DO WHILE (NMIN.GE.60)
        NMIN = NMIN - 60
        NHRS = NHRS + 1
      ENDDO
C
C     PRINT THE HOUR
      IF(NHRS.EQ.0) THEN
        WRITE(HOURS,'(A)') '    '
      ELSE
        WRITE(HOURS,'(I3,A)') NHRS,'h'
      ENDIF
C
C     PRINT THE MINUTE
      IF(NHRS.EQ.0) THEN
        IF(NMIN.EQ.0) THEN
          WRITE(MINUTES,'(1X,A)') '   '
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ELSEIF(NHRS.NE.0) THEN
        IF(NMIN.LT.10) THEN
          WRITE(MINUTES,'(1X,I1,I1,A)') 0,NMIN,'m'
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F5.3,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F5.3,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(HMS,'(A,A,A)') HOURS//MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      SUBROUTINE TIMENOW(STAMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  TTTTTTTT IIII MM       MM EEEEEEEE NN    NN  OOOOOO  WW         WW  C
C     TT     II  MMM     MMM EE       NNN   NN OO    OO WW         WW  C
C     TT     II  MMMM   MMMM EE       NNNN  NN OO    OO WW         WW  C
C     TT     II  MM MM MM MM EEEEEE   NN NN NN OO    OO WW    W    WW  C
C     TT     II  MM  MMM  MM EE       NN  NNNN OO    OO WW   WWW   WW  C
C     TT     II  MM   M   MM EE       NN   NNN OO    OO  WW WW WW WW   C
C     TT    IIII MM       MM EEEEEEEE NN    NN  OOOOOO    WW     WW    C
C                                                                      C
C -------------------------------------------------------------------- C
C  TIMENOW CREATES A DATE STRING SPECIFYING CPU TIME WHEN CALLED.      C
C**********************************************************************C
      CHARACTER*5  ZONE
      CHARACTER*8  DATE
      CHARACTER*10 TIME
      CHARACTER*20 STAMP
C
      DIMENSION IVL(8)
C
C     CALL TIME AND DATE ROUTINE
      CALL DATE_AND_TIME(DATE,TIME,ZONE,IVL)
C
C     PRINT THE DAY
      IF(IVL(3).LT.10) THEN
        WRITE(STAMP,'(1X,I1,I1,A)') 0,IVL(3),'/'
      ELSE
        WRITE(STAMP,'(1X,I2,A)') IVL(3),'/'
      ENDIF
C
C     PRINT THE MONTH
      IF(IVL(2).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(2),'/'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(2),'/'
      ENDIF
C
C     PRINT THE YEAR
      WRITE(STAMP,'(A,I4)') TRIM(STAMP),IVL(1)
C
C     PRINT THE HOUR
      IF(IVL(5).LT.10) THEN
        WRITE(STAMP,'(A,A,I1,I1,A)') TRIM(STAMP),' ',0,IVL(5),':'
      ELSE
        WRITE(STAMP,'(A,A,I2,A)') TRIM(STAMP),' ',IVL(5),':'
      ENDIF
C
C     PRINT THE MINUTE
      IF(IVL(6).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(6),':'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(6),':'
      ENDIF
C
C     PRINT THE SECOND
      IF(IVL(7).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1)') TRIM(STAMP),0,IVL(7)
      ELSE
        WRITE(STAMP,'(A,I2)') TRIM(STAMP),IVL(7)
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] DENSTY0: GENERATES CLOSED- AND OPEN-SHELL MOLECULAR DENSITY.   C
C   [B] DENSTY: GENERATES CLOSED- AND OPEN-SHELL MOLECULAR DENSITY.    C
C   [C] LEVSHFT: APPLIES A LEVEL SHIFT TO OCCUPIED ORBITALS IN FOCK.   C
C   [D] ENERGIES: USE DENSITY MATRIX TO CALCULATE ENERGY TERMS.        C
C   [E] DIIS: DIRECT INVERSION OF THE ITERATIVE SUBSPACE.              C
C**********************************************************************C
C
C
      SUBROUTINE DENSTY0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    DDDDDDD  EEEEEEEE NN    NN  SSSSSS TTTTTTTT YY    YY  000000      C
C    DD    DD EE       NNN   NN SS    SS   TT    YY    YY 00   000     C
C    DD    DD EE       NNNN  NN SS         TT     YY  YY  00  0000     C
C    DD    DD EEEEEE   NN NN NN  SSSSSS    TT      YYYY   00 00 00     C
C    DD    DD EE       NN  NNNN       SS   TT       YY    0000  00     C
C    DD    DD EE       NN   NNN SS    SS   TT       YY    000   00     C
C    DDDDDDD  EEEEEEEE NN    NN  SSSSSS    TT       YY     000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSTY0 IS A STARTING DENSITY ROUTINE FOR USE ONLY WHEN READIN =.F. C
C  THIS IS BECAUSE 'ATOMIC' CALCULATES AVERAGE OVER SHELL OCCUPANCIES. C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMPLEX*16 SUM
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/OCPD/IOCPN(MDM),IOCCM0,IOCTP(MCT,MKP,MKP+1,MKP+1)
      COMMON/SHLL/ALPH,BETA,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     CONSTRUCT THE CLOSED-SHELL AND TOTAL DENSITY ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,IOCCM0
            IOCAD = IOCPN(IOCC)
            SUM = SUM + DCONJG(COEF(I,IOCAD+NSKP))*COEF(J,IOCAD+NSKP)
          ENDDO
          DENC(I,J) = SUM
          DENO(I,J) = 0.0D0
          DENT(I,J) = DENC(I,J) + DENO(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DENSTY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS TTTTTTTT YY    YY         C
C         DD    DD EE       NNN   NN SS    SS   TT    YY    YY         C
C         DD    DD EE       NNNN  NN SS         TT     YY  YY          C
C         DD    DD EEEEEE   NN NN NN  SSSSSS    TT      YYYY           C
C         DD    DD EE       NN  NNNN       SS   TT       YY            C
C         DD    DD EE       NN   NNN SS    SS   TT       YY            C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS    TT       YY            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSTY GENERATES DENSITY MATRICES FROM THE EXPANSION COEFFS COEF.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMPLEX*16 SUM
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/SHLL/ALPH,BETA,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     MAKE CLOSED-SHELL DENSITY AND EMPTY OPEN-SHELL DENSITY (RSCF 81)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NCLS
            ICL = ICLS(IOCC)
            SUM = SUM +      DCONJG(COEF(I,ICL+NSKP))*COEF(J,ICL+NSKP)
          ENDDO
          DENC(I,J) = SUM
          DENT(I,J) = DENC(I,J)
          DENO(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
      IF(NOPN.EQ.0) GOTO 100
C
C     MAKE THE OPEN-SHELL DENSITY (RSCF 82)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NOPN
            IOP = IOPN(IOCC)
            SUM = SUM + FOPN*DCONJG(COEF(I,IOP+NSKP))*COEF(J,IOP+NSKP)
          ENDDO
          DENO(I,J) = SUM
          DENT(I,J) = DENT(I,J) + DENO(I,J)
        ENDDO
      ENDDO
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE LEVSHFT(SHLV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   LL       EEEEEEEE VV      VV  SSSSSS  HH    HH FFFFFFFF TTTTTTTT   C
C   LL       EE       VV      VV SS    SS HH    HH FF          TT      C
C   LL       EE       VV      VV SS       HH    HH FF          TT      C
C   LL       EEEEEE    VV    VV   SSSSSS  HHHHHHHH FFFFFF      TT      C
C   LL       EE         VV  VV         SS HH    HH FF          TT      C
C   LL       EE          VVVV    SS    SS HH    HH FF          TT      C
C   LLLLLLLL EEEEEEEE     VV      SSSSSS  HH    HH FF          TT      C
C                                                                      C
C -------------------------------------------------------------------- C
C  LEVSHFT APPLIES A LEVEL SHIFT OF SHLV TO UNOCCUPIED ORBITALS IN THE C
C  FOCK MATRIX.                                                        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMPLEX*16 A(MDM),SUM
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGC/COEF
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
C
C     LOOP OVER ALL NON-OCCUPIED POSITIVE-ENERGY (I.E., VIRTUAL) OCCS
      DO IVIR=NSKP+NOCC+1,NDIM
C
C       LIST OF FOCK ADDRESSES WITH 'I' WITH AN AMOUNT FROM EACH IVIR
        DO I=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO J=1,NDIM
            SUM = SUM + OVLP(I,J)*COEF(J,IVIR)
          ENDDO
          A(I) = SUM
        ENDDO
C
C       ADD A LEVEL SHIFT'S WORTH OF INTERACTION ENERGY TO ALL FOCK(I,J)
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = FOCK(I,J) + SHLV*A(I)*DCONJG(A(J))
          ENDDO
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ENRGIES
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE NN    NN EEEEEEEE RRRRRRR   GGGGGG IIII EEEEEEEE SSSSSS   C
C   EE       NNN   NN EE       RR    RR GG    GG II  EE      SS    SS  C
C   EE       NNNN  NN EE       RR    RR GG       II  EE      SS        C
C   EEEEEE   NN NN NN EEEEEE   RR    RR GG       II  EEEEEE   SSSSSS   C
C   EE       NN  NNNN EE       RRRRRRR  GG   GGG II  EE            SS  C
C   EE       NN   NNN EE       RR    RR GG    GG II  EE      SS    SS  C
C   EEEEEEEE NN    NN EEEEEEEE RR    RR  GGGGGG IIII EEEEEEEE SSSSSS   C
C                                                                      C
C -------------------------------------------------------------------- C
C  ENRGIES CALCULATES INTERACTION ENERGIES OF THE CURRENT DENSITY      C
C  MATRIX OVER OCCUPIED SPINORS WITH THE MATRIX REP OF OPERATORS.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMPLEX*16 ETMP(12)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EUEH
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ALPH,BETA,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     INITIALISE MOLECULAR ENERGY COUNTERS
      DO N=1,12
        ETMP(N) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP( 1) = ETMP( 1) +       DENT(I,J)*HNUC(I,J)
          ETMP( 2) = ETMP( 2) +       DENT(I,J)*HKIN(I,J)
          ETMP( 3) = ETMP( 3) +       DENT(I,J)*VUEH(I,J)
          ETMP( 4) = ETMP( 4) + 0.5D0*DENT(I,J)*GDIR(I,J)
          ETMP( 5) = ETMP( 5) + 0.5D0*DENT(I,J)*GXCH(I,J)
          ETMP( 6) = ETMP( 6) + 0.5D0*DENT(I,J)*BDIR(I,J)
          ETMP( 7) = ETMP( 7) + 0.5D0*DENT(I,J)*BXCH(I,J)
          ETMP( 8) = ETMP( 8) + 0.5D0*DENT(I,J)*QDIR(I,J)
     &                        + 0.5D0*DENO(I,J)*QDIR(I,J)*(FOPN-1.0D0)
          ETMP( 9) = ETMP( 9) + 0.5D0*DENT(I,J)*QXCH(I,J)
     &                        + 0.5D0*DENO(I,J)*QXCH(I,J)*(FOPN-1.0D0)
          ETMP(10) = ETMP(10) + 0.5D0*DENT(I,J)*WDIR(I,J)
     &                        + 0.5D0*DENO(I,J)*WDIR(I,J)*(FOPN-1.0D0)
          ETMP(11) = ETMP(11) + 0.5D0*DENT(I,J)*WXCH(I,J)
     &                        + 0.5D0*DENO(I,J)*WXCH(I,J)*(FOPN-1.0D0)
          ETMP(12) = ETMP(12) +       DENT(I,J)*FOCK(I,J)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EHNC = DREAL(ETMP( 1))
      EHKN = DREAL(ETMP( 2))
      EUEH = DREAL(ETMP( 3))
      EGDR = DREAL(ETMP( 4))
      EGXC = DREAL(ETMP( 5))
      EBDR = DREAL(ETMP( 6))
      EBXC = DREAL(ETMP( 7))
      EQDR = DREAL(ETMP( 8))
      EQXC = DREAL(ETMP( 9))
      EWDR = DREAL(ETMP(10))
      EWXC = DREAL(ETMP(11))
      EDHF = DREAL(ETMP(12))
C
C     ADD ALL CONTRIBUTIONS TO THE TOTAL ENERGY
      EONE = EHNC+EHKN
      ECLG = EGDR-EGXC
      ECLQ = EQDR-EQXC
      EBRG = EBDR-EBXC
      EBRQ = EWDR-EWXC
      ETOT = 0.5D0*EONE + 0.5D0*EDHF - ECLQ - EBRQ
C
      RETURN
      END
C
C
      SUBROUTINE DIIS(NMLEV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                      DDDDDDD IIII IIII SSSSSS                        C
C                      DD    DD II   II SS    SS                       C
C                      DD    DD II   II SS                             C
C                      DD    DD II   II  SSSSSS                        C
C                      DD    DD II   II       SS                       C
C                      DD    DD II   II SS    SS                       C
C                      DDDDDDD IIII IIII SSSSSS                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  DIIS EMPLOYS THE DIRECT INVERSION OF THE ITERATIVE SUBSPACE METHOD  C
C  AS PROPOSED BY PULAY (1982), WHEN APPROPRIATE TO DO SO.             C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      CHARACTER*80 TITLE
C
      DIMENSION WKR(LWK),BTEMP(MDM,MDM)
C
      COMPLEX*16 WKC(LWK)
      COMPLEX*16 EVEC(MDM,MDM),AORT(MDM,MDM)
      COMPLEX*16 ETM1(MDM,MDM),ETM2(MDM,MDM)
      COMPLEX*16 ERRM(MDM,MDM,MSV),FCKM(MDM,MDM,MSV)
      COMPLEX*16 BMAT(MSV,MSV),DMAT(1,MSV),RK(3*MSV)
      COMPLEX*16 CVEC(MSV),ZVEC(MSV),YVEC(1)
      COMPLEX*16 BMI,BMN,CTOT
C
      COMMON/ORTH/ERRM,FCKM,AORT
      COMMON/LSQR/BMAT,DMAT,CVEC,ZVEC,YVEC,ITDIIS
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
C
C**********************************************************************C
C     STEP 0: PREPARE ORTHOGONAL BASIS TRANSFORMATION                  C
C**********************************************************************C
C
      IF(NMLEV.EQ.1) THEN
C
        DO I=1,NDIM
          DO J=1,NDIM
            AORT(I,J) = 1.0D0/DSQRT(ABS(OVLP(I,J)))
            IF(ABS(OVLP(I,J)).LT.1.0D-14) THEN
C              WRITE(*,*) I,J,OVLP(I,J),AORT(I,J)
            ENDIF
          ENDDO
        ENDDO
C
C       INITIALISE SOME COUNTERS AND MATRICES
        ITDIIS = 0
C
        DO M=1,MSV
          CVEC(M) = DCMPLX(0.0D0,0.0D0)
          DO N=1,MSV
            BMAT(M,N) = DCMPLX(0.0D0,0.0D0)
          ENDDO
          DMAT(1,M) = DCMPLX(1.0D0,0.0D0)
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     STEP 1: CONSTRUCT ERROR VECTOR                                   C
C**********************************************************************C
C
C     VECTOR E IN PULAY (1982) EQ. 4
      DO I=1,NDIM
        DO J=1,NDIM
          ETM1(I,J) = DCMPLX(0.0D0,0.0D0)
          ETM2(I,J) = DCMPLX(0.0D0,0.0D0)
          DO K=1,NDIM
            ETM1(I,J) = ETM1(I,J) + DCONJG(DENT(I,K))*OVLP(K,J)
            ETM2(I,J) = ETM2(I,J) + DCONJG(DENT(I,K))*FOCK(K,J)
          ENDDO
        ENDDO
      ENDDO
      
      DO I=1,NDIM
        DO J=1,NDIM
         EVEC(I,J) = DCMPLX(0.0D0,0.0D0)
         DO K=1,NDIM
           EVEC(I,J) = EVEC(I,J) + FOCK(I,K)*ETM1(K,J)
     &                           - OVLP(I,K)*ETM2(K,J)
         ENDDO
        ENDDO
      ENDDO
C
C     TRANSFORM TO ORTHOGONAL BASIS
      goto 111
      DO I=1,NDIM
        DO J=1,NDIM
          ETM1(I,J) = DCMPLX(0.0D0,0.0D0)
          DO K=1,NDIM
            ETM1(I,J) = EVEC(I,K)*AORT(K,J)
          ENDDO
        ENDDO
      ENDDO
C
      DO I=1,NDIM
        DO J=1,NDIM
          EVEC(I,J) = DCMPLX(0.0D0,0.0D0)
          DO K=1,NDIM
            EVEC(I,J) = DCONJG(AORT(I,K))*ETM1(K,J)
          ENDDO
        ENDDO
      ENDDO
111   continue
C
C     FIND LARGEST ABSOLUTE MATRIX ELEMENT IN ERROR ARRAY
      EBIG = 0.0D0
      DO I=1,NDIM
        DO J=1,NDIM
          IF(ABS(EVEC(I,J)).GT.EBIG) EBIG = ABS(EVEC(I,J))
        ENDDO
      ENDDO
C
C     STAY IN PASSIVE MODE UNTIL EBIG FALLS UNDER THRESHOLD
      write(*,*) '>>>>>>>>>>>>>>>>',ebig
      IF(EBIG.GT.0.1D+00) RETURN
c      RETURN
C
C**********************************************************************C
C     STEP 2: ADD TO B MATRIX                                          C
C**********************************************************************C
C
C     INCREASE DIIS COUNTER
      ITDIIS = ITDIIS+1
C
C     ARRAY LOCATION
      KLC = MOD(ITDIIS,MSV)
      IF(KLC.EQ.0) KLC = MSV
C
C     DIMENSION OF SOLUTION SPACE
      KSS = MIN(ITDIIS,MSV)
C      
      write(*,*) 'heregoes',ITDIIS,KLC,KSS,NMLEV
C
C     STORE ERROR MATRIX AND CURRENT FOCK MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          ERRM(I,J,KLC) = EVEC(I,J)
          FCKM(I,J,KLC) = FOCK(I,J)
        ENDDO
      ENDDO
C
C     FROBENIUS INNER PRODUCTS BETWEEN ERROR MATRICES
      DO M=1,KSS
        DO N=1,KSS
          BMI = DCMPLX(0.0D0,0.0D0)
          DO I=1,NDIM
            DO J=1,NDIM
              BMI = BMI + DCONJG(ERRM(I,J,M))*ERRM(I,J,N)
            ENDDO
          ENDDO
          BMAT(M,N) = BMI
          BMAT(N,M) = DCONJG(BMI)
        ENDDO
      ENDDO
C
      TITLE = 'DIIS-MATRIX'
      DO I=1,KSS
        DO J=1,KSS
          BTEMP(I,J) = DREAL(BMAT(I,J))
        ENDDO
      ENDDO
      CALL GNUMTRX(BTEMP,TITLE,KSS)
C
C     ZERO-VECTOR FOR LEAST-SQUARES MINIMISATION ROUTINE
      DO M=1,KSS
        ZVEC(M) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     C-VECTOR SUM CONSTRAINT
      DO M=1,KSS
        DMAT(1,M) = DCMPLX(1.0D0,0.0D0)
      ENDDO
      YVEC(1) = DCMPLX(1.0D0,0.0D0)
C
      CALL ZGGLSE(KSS,KSS,1,BMAT,MSV,DMAT,1,ZVEC,YVEC,CVEC,WKC,LWK,INF)
      IF(INF.NE.0) THEN
        WRITE(6, *) 'In DIIS: eigenvalue solver ZGGLSE failed.',INF
        WRITE(7, *) 'In DIIS: eigenvalue solver ZGGLSE failed.',INF
      ENDIF
C
C     PRINT THE SUM OF BEST-FIT PARAMETERS
      CTOT = DCMPLX(0.0D0,0.0D0)
      DO M=1,KSS
        CTOT = CTOT + CVEC(M)
        WRITE(*,*) m,cvec(m)
      ENDDO
      WRITE(*,*) '*********************************'
      WRITE(*,*) KLC,CTOT
C
C**********************************************************************C
C     STEP 3: REPLACE CURRENT FOCK MATRIX                              C
C**********************************************************************C
C
      DO I=1,NDIM
        DO J=1,NDIM
          FOCK(I,J) = DCMPLX(0.0D0,0.0D0)
          DO M=1,KSS
            FOCK(I,J) = FOCK(I,J) + CVEC(M)*FCKM(I,J,M)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [4] ATOMIC HARTREE-FOCK: SINGLE-CENTRE SCF CALCULATIONS.           C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] ATOMIC: MAIN ROUTNE FOR ATOMIC SCF CALCULATIONS.               C
C   [B] ATOM1E: HYDROGENIC ATOMIC SOLVER (ONE-BODY ONLY, SO NO SCF.)   C
C   [C] HFSCF0: ATOMIC SCF ROUTINE (AVERAGE OF CONFIGURATION MODEL.)   C
C -------------------------------------------------------------------- C
C   [A] OVRLP0: GENERATES ATOMIC OVERLAP MATRIX FOR A GIVEN KQN.       C
C   [B] ONEEL0: GENERATES ATOMIC ONE-ELECTRON MATRIX (ALL HAMILS).     C
C   [C] KINTC0: GENERATES ATOMIC KINETIC MATRIX FOR A GIVEN KQN.       C
C   [D] PNTNC0: GENERATES ATOMIC POINT-NUCLEAR MATRIX FOR A GIVEN KQN. C
C   [E] UNINC0: GENERATES ATOMIC UNIFORM-NUCLEAR MATRIX   "         ". C
C   [F] GSSNC0: GENERATES ATOMIC GAUSSIAN-NUCLEAR MATRIX  "         ". C
C   [G] NCOLP0: GENERATES ATOMIC NUCLEAR OVERLAP MATRIX (GAUSSIAN).    C
C   [H] MOMNT0: GENERATES ATOMIC RADIAL INTEGRALS FOR A GIVEN KQN.     C
C   [I] VACPL0: GENERATES ATOMIC NUCLEAR VACUUM POLARISATION MATRIX.   C
C   [J] COULM0: ATOMIC MEAN-FIELD COULOMB MATRIX (BETA INTEGRALS).     C
C   [K] RKCLM0: BATCH OF ATOMIC COULOMB INTERACTION INTEGRALS.         C
C   [L] BREIT0: CONSTRUCTION OF ATOMIC BREIT INTERACTION MATRIX.       C
C   [M] RKBRT0: BATCH OF ATOMIC BREIT INTERACTION INTEGRALS.           C
C -------------------------------------------------------------------- C
C   [A] ERFINT0: INTEGRAL OVER A GAUSSIAN AND ERROR FUNCTION.          C
C   [B] UEHINT0: CALCULATES AN ATOMIC UEHLING INTEGRAL.                C
C   [C] ANGCLM0: ATOMIC ANGULAR COULOMB COEFFICIENTS.                  C
C   [D] ANGBRT0: ATOMIC ANGULAR BREIT COEFFICIENTS.                    C
C   [E] BRCOEF0: EXCHANGE MAGNETIC COEFFICIENTS FOR CLOSED-SHELL BREIT.C
C   [F] ANGSQLS: SQUARE OF A WIGNER-3J SYMBOL (LS COUPLING).           C
C   [G] ANGSQJJ: SQUARE OF A WIGNER-3J SYMBOL (JJ COUPLING).           C
C   [H] IJSET0: BASIS SET INTERMEDIATES FOR IJ-PAIRS IN RKCLM0/RKBRT0. C
C   [I] KLSET0: BASIS SET INTERMEDIATES FOR KL-PAIRS IN RKCLM0/RKBRT0. C
C   [J] RNORM0: GENERATE BATCHES OF ALL TT' NORMALISATION FACTORS.     C
C   [N] GAMLWR: LOWER INCOMPLETE GAMMA FUNCTION gamma(A,X).            C
C   [O] GAMUPR: UPPER INCOMPLETE GAMMA FUNCTION GAMMA(A,X).            C
C   [P] VMOMNT: EVEN MOMENTS OF THE FERMI NUCLEAR CHARGE.              C
C   [Q] VNFERMI: NORMALISED FERMI POTENTIAL EVALUATED AT RADIUS R.     C
C   [R] POLYLOG: EVALUATE POLYLOG FUNCTION OF A PARTICULAR ARGUMENT.   C
C**********************************************************************C
C
C
      SUBROUTINE ATOMIC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             AA   TTTTTTTT OOOOOO  MM       MM IIII CCCCCC            C
C            AAAA     TT   OO    OO MMM     MMM  II CC    CC           C
C           AA  AA    TT   OO    OO MMMM   MMMM  II CC                 C
C          AA    AA   TT   OO    OO MM MM MM MM  II CC                 C
C          AAAAAAAA   TT   OO    OO MM  MMM  MM  II CC                 C
C          AA    AA   TT   OO    OO MM   M   MM  II CC    CC           C
C          AA    AA   TT    OOOOOO  MM       MM IIII CCCCCC            C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  ATOMIC PERFORMS A SINGLE-CENTRE SCF PROCEDURE FOR EACH ATOM IN THE  C
C  MOLECULE AND ASSEMBLES AN INITIAL COEFFICIENT MATRIX.               C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EUEH
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/OCPD/IOCPN(MDM),IOCCM0,IOCTP(MCT,MKP,MKP+1,MKP+1)
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/TATM/TTOT
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',26),'ATOMIC HARTREE-FOCK SCF'
      WRITE(7, *) REPEAT(' ',26),'ATOMIC HARTREE-FOCK SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME AT START OF ATOMIC CALCULATION
      CALL CPU_TIME(TDUM)
C
C     INITIALISE MOLECULAR MATRICES AND RADIAL EXPECTATION VALUES
      DO I=1,NDIM
        DO J=1,NDIM
          COEF(I,J) = DCMPLX(0.0D0,0.0D0)
          OVLP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     INITIALISE OCCUPATION COUNTER
      IOCCM0 = 0
C
C     SPECIAL EXIT FOR ZERO- AND ONE-ELECTRON PROBLEMS
      IF(NOCC.EQ.0) THEN
        WRITE(6, *) 'There are no electrons! Skip ATOMIC.'
        WRITE(7, *) 'There are no electrons! Skip ATOMIC.'
        RETURN
      ELSEIF(NOCC.EQ.1.AND.NCNT.EQ.1) THEN
        CALL ATOM1E(NCNT)
        CALL DENSTY0
        CALL SPECTRM0
        GOTO 300
      ENDIF
C
C     HARTREE-FOCK SCF PROCEDURE FOR EACH ISOLATED ATOM
      DO IZ=1,NCNT
C
C       AVERAGE-OVER-CONFIGURATION ATOMIC SCF PROCEDURE
        CALL HFSCF0(IZ)
C
C       PERTURBATIVE BREIT INTERACTION
        IF(HMLT.EQ.'DHFP') THEN
          CALL G2PAIR0(IZ,1,'BREIT')
        ENDIF
C
C       PERTURBATIVE COULOMB INTERACTION
C       CALL G2PAIR0(IZ,3,'COULM')
C
      ENDDO
C
C     GENERATE DENSITY MATRIX
      CALL DENSTY0
C
C     PRODUCE SPECTRUM SUMMARY
      CALL SPECTRM0
C
C     MOLECULAR ENERGIES
20    FORMAT(1X,A,31X,F21.12)
      WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) 'Source',REPEAT(' ',60),'Energy'
      WRITE(7, *) 'Source',REPEAT(' ',60),'Energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Nucleus-nucleus  (N)',ENUC
      WRITE(7,20) 'Nucleus-nucleus  (N)',ENUC
      WRITE(6,20) 'One-electron     (H)',EONE
      WRITE(7,20) 'One-electron     (H)',EONE
      IF(HMLT.EQ.'BARE') GOTO 202
      WRITE(6,20) 'Coulomb (closed) (G)',ECLG
      WRITE(7,20) 'Coulomb (closed) (G)',ECLG
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 202
      WRITE(6,20) 'Breit (closed)   (B)',EBRG
      WRITE(7,20) 'Breit (closed)   (B)',EBRG
      IF(HMLT.NE.'DHFQ') GOTO 202
      WRITE(6,20) 'Uehling          (U)',EUEH
      WRITE(7,20) 'Uehling          (U)',EUEH
202   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Molecule total   (F)',ETOT
      WRITE(7,20) 'Molecule total   (F)',ETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
300   CONTINUE
C
C     SAVE EIGENVECTORS TO OUTPUT FILE
      OPEN(UNIT=8,FILE=TRIM(WFNFL),STATUS='UNKNOWN')
      REWIND(UNIT=10)
      DO I=1,NDIM
        WRITE(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
C     TIME TAKEN FOR ATOMIC CALCULATION
      CALL CPU_TIME(TTOT)
      TTOT = TTOT - TDUM
C
C     DATE AND TIME AT END OF ITERATION
      CALL TIMENOW(STAMP)
C
C     CALCULATION TIME
30    FORMAT(1X,A,26X,A)
      WRITE(6,30) 'Total atomic SCF time         ',HMS(TTOT)
      WRITE(7,30) 'Total atomic SCF time         ',HMS(TTOT)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Time at end of calculation',STAMP
      WRITE(7,30) 'Time at end of calculation',STAMP
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE ATOM1E(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             AA   TTTTTTTT OOOOOO  MM       MM  11  EEEEEEEE          C
C            AAAA     TT   OO    OO MMM     MMM 111  EE                C
C           AA  AA    TT   OO    OO MMMM   MMMM  11  EE                C
C          AA    AA   TT   OO    OO MM MM MM MM  11  EEEEEE            C
C          AAAAAAAA   TT   OO    OO MM  MMM  MM  11  EE                C
C          AA    AA   TT   OO    OO MM   M   MM  11  EE                C
C          AA    AA   TT    OOOOOO  MM       MM 1111 EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ATOM1E CALCUATES THE SOLUTION TO A ONE-ELECTRON ATOMIC PROBLEM.     C
C  THERE IS NO NEED FOR AVERAGE-OVER CONFIGURATION TREATMENT HERE, SO  C
C  RESULTS ARE STORED IN THE MASTER LIST OF A SINGLE ORBITAL.          C
C  ALL SOLUTIONS OF THE EIGENVALUE PROBLEM ARE EXPORTED TO COEF.       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ - ATOMIC CENTRE INDEX                                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*1 LLAB,QSGN
      CHARACTER*2 ELMT(120),ELNM
      CHARACTER*5 NMDL
      CHARACTER*6 CNFG
      CHARACTER*8 ZWRT,QWRT,EWRT
C
      DIMENSION O2(MBD,MBD),H2(MBD,MBD),C2(MBD,MBD),
     &          T2(MBD,MBD),V2(MBD,MBD),U2(MBD,MBD)
      DIMENSION W2(MBD),T(LWK0),EXL(MBS)
      DIMENSION NORB(0:MEL,MKP+1),NUMOCC(0:MEL)
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/BQED/RUEH(MCT,3),FUEH(MCT,MFT),XUEH(MCT,MFT),NUEH(MCT)
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FILL/NCNF(MCT,0:MEL,MKP+1),NLVL(MCT,0:MEL),CNFG(MCT)
      COMMON/MDLV/ELMT
      COMMON/OCPD/IOCPN(MDM),IOCCM0,IOCTP(MCT,MKP,MKP+1,MKP+1)
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     TEMPORARY ELECTRON MASS MODIFIER (DECOUPLES NUCLEAR MOTION)
      XMSS = EMSS
      EMSS = (XMSS*PMSS*ANUC(IZ))/(XMSS+PMSS*ANUC(IZ))
C
C     IMPORT ATOMIC CHARGE DETAILS
      IZNV = INT(ZNUC(IZ))
      ELNM = ELMT(IZNV)
      ICRG = IQNC(IZ)
      MLQN =(NKAP(IZ)-1)/2
C
C     CONVERT IZNV AND ICRG TO STRINGS AND WRITE TITLE
      IF(IZNV.LT.10) THEN
        WRITE(ZWRT,'(A,I1)') 'Z = ',IZNV
      ELSEIF(IZNV.LT.100) THEN
        WRITE(ZWRT,'(A,I2)') 'Z = ',IZNV
      ELSE
        WRITE(ZWRT,'(A,I3)') 'Z = ',IZNV
      ENDIF
C
      IF(IZNV-ICRG.LT.10) THEN
        WRITE(QWRT,'(A,I2)') 'Q = ',IZNV-ICRG
      ELSEIF(IZNV.LT.100) THEN
        WRITE(QWRT,'(A,I3)') 'Q = ',IZNV-ICRG
      ELSE
        WRITE(QWRT,'(A,I4)') 'Q = ',IZNV-ICRG
      ENDIF
C
      IF(IZNV-ICRG.GT.0) THEN
        QSGN = '+'
      ELSEIF(IZNV-ICRG.LT.0) THEN
        QSGN = '-'
      ENDIF
C
      ICMD = IABS(IZNV-ICRG)
      IF(IZNV-ICRG.EQ.0) THEN
        WRITE(EWRT,'(A,A,A)') '(',TRIM(ELNM),')'
      ELSEIF(ICMD.EQ.1) THEN
        WRITE(EWRT,'(A,A,A,A,A)') '(',TRIM(ELNM),'^',QSGN,')'
      ELSEIF(ICMD.LT.10) THEN
        WRITE(EWRT,'(A,A,A,I1,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSEIF(ICMD.LT.100) THEN
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSE
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ENDIF
C
C     PRINT TITLE SUMMARY FOR THIS ATOM
20    FORMAT(17X,'Centre',I3,':',3X,A,3X,A,3X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) IZ,ZWRT,QWRT,EWRT
      WRITE(7,20) IZ,ZWRT,QWRT,EWRT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
      IF(CNFG(IZ).EQ.'MANUAL') THEN
        LMXCONF = (NKAP(IZ)-1)/2
        DO L=0,LMXCONF
          NUMOCC(L) = NLVL(IZ,L)
          DO N=1,NLVL(IZ,L)
            NORB(L,N) = NCNF(IZ,L,N)
          ENDDO
        ENDDO
      ELSEIF(CNFG(IZ).EQ.'AUFBAU') THEN
        CALL AUFBAU(IZNV,ICRG,NORB,NUMOCC,LMXCONF)
      ELSE
        WRITE(6, *) 'In ATOM1E: invalid configuration choice.'
        WRITE(7, *) 'In ATOM1E: invalid configuration choice.'
      ENDIF
C
C     CHECK WHETHER THERE ARE SUFFICIENT BASIS FUNCTION TYPES
      IF(MLQN.LT.LMXCONF) THEN
        WRITE(6, *) 'In ATOM1E: insufficient angular types in basis.'
        WRITE(7, *) 'In ATOM1E: insufficient angular types in basis.'
        WRITE(6, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        WRITE(7, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        STOP
      ENDIF
C
C     PRINT ATOMIC CONFIGURATION
30    FORMAT(1X,A,4X,F16.14)
31    FORMAT(1X,A,2X,A,1X,'|',2X'NSHELL ',12(2X,I2))
32    FORMAT(1X,'LQN = ',I1,2X,I3,2X,'|'1X,' OCC(',A,'):',A,12(2X,I2))
C
      WRITE(6, *) 'Reduced electron (orbiter) mass = ',EMSS
      WRITE(7, *) 'Reduced electron (orbiter) mass = ',EMSS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      IF(CNFG(IZ).EQ.'MANUAL') THEN
        WRITE(6,31) 'Manual:','#fns',(N,N=1,12)
        WRITE(7,31) 'Manual:','#fns',(N,N=1,12)
      ELSEIF(CNFG(IZ).EQ.'AUFBAU') THEN
        WRITE(6,31) 'Aufbau:','#fns',(N,N=1,12)
        WRITE(7,31) 'Aufbau:','#fns',(N,N=1,12)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO L=0,(NKAP(IZ)-1)/2
        WRITE(6,32) L,NFNC(L,IZ),LLAB(L),
     &                        REPEAT(' ',L*4),(NORB(L,J),J=1,NUMOCC(L))
        WRITE(7,32) L,NFNC(L,IZ),LLAB(L),
     &                        REPEAT(' ',L*4),(NORB(L,J),J=1,NUMOCC(L))
      ENDDO
C
C     RESULTS FOR EACH ITERATION
40    FORMAT(1X,A,10X,A,10X,A,13X,A,11X,A)
41    FORMAT(I3,2X,F15.6,2X,F15.6,2X,F18.6,4X,ES12.5)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(7,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C**********************************************************************C
C     ONE-BODY PROBLEM: ICRG = 1. (NO COULOMB ENERGY.)                 C
C**********************************************************************C
C
C     IDENTIFY LQN AND NQN FOR OCCUPIED ELECTRON
      DO L=0,LMXCONF
        DO N=1,NUMOCC(L)
          IF(NORB(L,N).EQ.1) THEN
            LQN = L
            NQN = N
          ENDIF
        ENDDO
      ENDDO
C
C     RELATIVISTIC QUANTUM NUMBER
      KQN =-LQN-1
C     KQN = LQN
C
C     MAGNETIC NUMBER (DOUBLE THE ACTUAL VALUE)
      MQNA =-1
C
C     CORRESPONDING FOCK ADDRESS FOR THIS KQN
      IF(KQN.LT.0) THEN
        KADD =-2*KQN-1
      ELSE
        KADD = 2*KQN
      ENDIF
C
C     CORRESPONDING FOCK ADDRESS FOR THIS MQN
      IF(MQNA.LT.0) THEN
        MADD =-MQNA
      ELSE
        MADD = MQNA+1
      ENDIF
C
C     EFFECTIVE AND AVERAGE OCCUPATION NUMBERS FOR THIS KQN ORBITAL
C     A CLOSED SUBSHELL (NQN,LQN) CONTAINS NCLS ELECTRONS
      IF(HMLT.EQ.'NORL') THEN
        NCLS = 4*LQN+2
      ELSE
        NCLS = 2*IABS(KQN)
      ENDIF
C
C     CORRESPONDING FOCK ADDRESS FOR THIS KQN
      IF(KQN.LT.0) THEN
        KADD =-2*KQN-1
      ELSE
        KADD = 2*KQN
      ENDIF
C
C     IMPORT BASIS FUNCTION EXPONENTS
      NBAS = NFNC(LQN,IZ)
      DO IBAS=1,NBAS
        EXL(IBAS) = BEXL(IBAS,LQN,IZ)
      ENDDO
C
C     MATRIX DIMENSIONS FOR THIS LQN BLOCK
      IF(HMLT.EQ.'NORL') THEN
        NBLC = 0
      ELSE
        NBLC = NBAS
      ENDIF
      NMAT = NBAS+NBLC
C
C     CLEAR HAMILTONIAN AND OVERLAP ARRAYS
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
          O2(IBAS,JBAS) = 0.0D0
          H2(IBAS,JBAS) = 0.0D0
          T2(IBAS,JBAS) = 0.0D0
          V2(IBAS,JBAS) = 0.0D0
          U2(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     GENERATE OVERLAP, KINETIC AND NUCLEAR ATTRACTION MATRICES
      CALL OVRLP0(O2   ,EXL   ,KQN,NBAS)
      CALL ONEEL0(T2,V2,EXL,IZ,KQN,NBAS)
C     CALL KINTC0(T2   ,EXL   ,KQN,NBAS)
C     CALL PNTNC0(   V2,EXL,IZ,KQN,NBAS)
C     CALL GSSNC0(   V2,EXL,IZ,KQN,NBAS)
C     CALL UNINC0(   V2,EXL,IZ,KQN,NBAS)
C     CALL FMINC0(   V2,EXL,IZ,KQN,NBAS)
C     CALL GSMNC0(   V2,EXL,IZ,KQN,NBAS)
C
C     GENERATE NUCLEAR VACUUM POLARISATION MATRIX
      IF(HMLT.EQ.'DHFQ') THEN
        CALL VACPL0(U2,EXL,IZ,KQN,NBAS)
      ENDIF
C
C     ONE-ELECTRON HAMILTONIAN MATRIX AND WORKING EIGENVECTOR MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
          H2(IBAS,JBAS) = T2(IBAS,JBAS)+V2(IBAS,JBAS)+U2(IBAS,JBAS)
          C2(IBAS,JBAS) = H2(IBAS,JBAS)
        ENDDO
      ENDDO
C
C     DIAGONALISE MATRIX (THIS NEEDS LAPACK LIBRARY)
      CALL DSYGV(1,'V','U',NMAT,C2,MBD,O2,MBD,W2,T,LWK0,INFO)
      IF(INFO.NE.0) THEN
        WRITE(6, *) 'In ATOM1E: eigenvalue solver DSYGV failed.',INFO
        WRITE(7, *) 'In ATOM1E: eigenvalue solver DSYGV failed.',INFO
        STOP
      ENDIF
C
C     NON-RELATIVISTIC CASE
      IF(HMLT.EQ.'NORL') THEN
C
C       FOCK MATRIX ADDRESSES
        IL = LRGE(IZ,KADD,MADD)
C
C       INCREASE NUMBER OF ELECTRONS IN SYSTEM
        IOCCM0 = IOCCM0+1
        IOCPN(IOCCM0) = NQN
C
C       LOOP OVER SOLUTIONS OF EIGENVALUE EQUATION
        DO IBAS=1,NBAS
C
C         COPY ENERGY EIGENVALUES TO MASTER LIST
          EIGN(NSKP+IBAS) = W2(NBLC+IBAS)
C
C         LOOP OVER BASIS FUNCTIONS
          DO JBAS=1,NBAS
C
C           SPINOR COEFFICIENT FOR THIS BASIS FUNCTION
            CLP = H2(JBAS     ,NBLC+IBAS)
C
C           COPY INTO MASTER COEFFICIENT LIST
            COEF(IL+JBAS,NSKP+IBAS) = DCMPLX(CLP,0.0D0)
C
          ENDDO
C
        ENDDO
C
C     RELATIVISTIC CASE
      ELSE
C
C       FOCK MATRIX ADDRESSES
        IL = LRGE(IZ,KADD,MADD)
        IS = LRGE(IZ,KADD,MADD)+NSKP
C
C       INCREASE NUMBER OF ELECTRONS IN SYSTEM
        IOCCM0 = IOCCM0+1
        IOCPN(IOCCM0) = NQN
C
C       LOOP OVER SOLUTIONS OF EIGENVALUE EQUATION
        DO IBAS=1,NBAS
C
C         COPY ENERGY EIGENVALUES TO MASTER LIST
          EIGN(NSKP+IBAS) = W2(NBLC+IBAS)
          EIGN(     IBAS) = W2(     IBAS)
C
C         LOOP OVER BASIS FUNCTIONS
          DO JBAS=1,NBAS
C
C           SPINOR COEFFICIENT FOR THIS BASIS FUNCTION
            CLP = H2(JBAS     ,NBLC+IBAS)
            CLN = H2(JBAS     ,     IBAS)
            CSP = H2(JBAS+NBLC,NBLC+IBAS)
            CSN = H2(JBAS+NBLC,     IBAS)
C
C           COPY INTO MASTER COEFFICIENT LIST
            COEF(IL+JBAS,NSKP+IBAS) = DCMPLX(CLP,0.0D0)
            COEF(IL+JBAS,     IBAS) = DCMPLX(CLN,0.0D0)
            COEF(IS+JBAS,NSKP+IBAS) = DCMPLX(CSP,0.0D0)
            COEF(IS+JBAS,     IBAS) = DCMPLX(CSN,0.0D0)
C
          ENDDO
C
        ENDDO
C        
      ENDIF
C
C     ONE- AND TWO-BODY ENERGIES
      EH = W2(NBLC+NQN)
C
C     ONE-BODY ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          M = M+1
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBLC
          LBAS = JBAS+NBLC
C
          DLL = H2(IBAS,NBLC+NQN)*H2(JBAS,NBLC+NQN)
          DSL = H2(KBAS,NBLC+NQN)*H2(JBAS,NBLC+NQN)
          DSS = H2(KBAS,NBLC+NQN)*H2(LBAS,NBLC+NQN)
C
C         KINETIC ENERGY: LL BLOCK
          IF(HMLT.EQ.'NORL') THEN
C
            EK = EK + T2(IBAS,JBAS)*DLL
C
C         KINETIC ENERGY: SL BLOCK
          ELSE
C
            EK = EK + 2.0D0*T2(KBAS,JBAS)*DSL
C
          ENDIF          
C
C         NUCLEAR ATTRACTION
          EN = EN + V2(IBAS,JBAS)*DLL + V2(KBAS,LBAS)*DSS
C
C         VACUUM POLARISATION: LL BLOCK
          EU = EU + U2(IBAS,JBAS)*DLL + U2(KBAS,LBAS)*DSS
C
        ENDDO
      ENDDO
C
      E1 = EK+EN
      EG = 0.0D0
      EB = 0.0D0
      ENEW = EH
C
C     WRITE RESULT
      WRITE(6,41) 1,EH,0.0D0,ENEW,1.0D0
      WRITE(7,41) 1,EH,0.0D0,ENEW,1.0D0
C
C     STUPID RATIO THAT GRASP USES
      EVRL = (ENEW-EK)/EK
C
C**********************************************************************C
C     WRITTEN SUMMARY                                                  C
C**********************************************************************C
C
C     SUMMARY OF ENERGY CONTRIBUTIONS
50    FORMAT(1X,A,24X,F19.12)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,50) 'Electron kinetic energy      ',EK
      WRITE(7,50) 'Electron kinetic energy      ',EK
      WRITE(6,50) 'Nuclear attraction energy    ',EN
      WRITE(7,50) 'Nuclear attraction energy    ',EN
      WRITE(6,50) 'Two-electron energy (Coulomb)',EG
      WRITE(7,50) 'Two-electron energy (Coulomb)',EG
      IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 500
      WRITE(6,50) 'Two-electron energy (Breit)  ',EB
      WRITE(7,50) 'Two-electron energy (Breit)  ',EB
      IF(HMLT.NE.'DHFQ') GOTO 500
      WRITE(6,50) 'Uehling energy               ',EU
      WRITE(7,50) 'Uehling energy               ',EU
500   CONTINUE
      WRITE(6,50) 'Total energy                 ',ENEW
      WRITE(7,50) 'Total energy                 ',ENEW
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,50) 'Virial nuclear/kinetic ratio ',EVRL
      WRITE(7,50) 'Virial nuclear/kinetic ratio ',EVRL
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
C
C     CONVERT BACK TO ORIGINAL ELECTRON MASS
      EMSS = XMSS
C
      RETURN
      END
C
C
      SUBROUTINE HFSCF0(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          HH    HH FFFFFFFF SSSSSS   CCCCCC  FFFFFFFF 000000          C
C          HH    HH FF      SS    SS CC    CC FF      00   000         C
C          HH    HH FF      SS       CC       FF      00  0000         C
C          HHHHHHHH FFFFFF   SSSSSS  CC       FFFFFF  00 00 00         C
C          HH    HH FF            SS CC       FF      0000  00         C
C          HH    HH FF      SS    SS CC    CC FF      000   00         C
C          HH    HH FF       SSSSSS   CCCCCC  FF       000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  HFSCF PERFORMS AN ATOMIC SINGLE-DETERMINANT ITERATIVE SELF-         C
C  CONSISTENT FIELD PROCEDURE OVER THE USER-SPECIFIED HAMILTONIAN.     C
C  USES THE CLOSED-SHELL AVERAGE OF CONFIGURATION MODEL, WITH SUBSHELL C
C  OCCUPATIONS DETERMINED EITHER MANUALLY OR BY THE AUFBAU ROUTINE.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ - ATOMIC CENTRE INDEX                                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*1 LLAB,QSGN
      CHARACTER*2 ELMT(120),ELNM
      CHARACTER*5 NMDL
      CHARACTER*6 CNFG
      CHARACTER*8 ZWRT,QWRT,EWRT
C
      DIMENSION QE(MKP),QA(MKP)
      DIMENSION W1(MBD),W2(MBD),T(LWK0)
      DIMENSION O1(MBD,MBD),H1(MBD,MBD),C1(MBD,MBD),
     &          T1(MBD,MBD),V1(MBD,MBD),U1(MBD,MBD),
     &          O2(MBD,MBD),H2(MBD,MBD),C2(MBD,MBD),
     &          T2(MBD,MBD),V2(MBD,MBD),U2(MBD,MBD)
      DIMENSION DENLL(MB2,MKP),DFNLL(MB2,MKP),
     &          DENSL(MB2,MKP),DFNSL(MB2,MKP),
     &          DENSS(MB2,MKP),DFNSS(MB2,MKP),
     &          DENLS(MB2,MKP),DFNLS(MB2,MKP)
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/ATMB/B11(MBD,MBD),B21(MBD,MBD),B12(MBD,MBD),B22(MBD,MBD)
      COMMON/ATMC/G11(MBD,MBD),G21(MBD,MBD),G12(MBD,MBD),G22(MBD,MBD)
      COMMON/ATMD/DLL1(MB2),DSL1(MB2),DSS1(MB2),DLS1(MB2),
     &            DLL2(MB2),DSL2(MB2),DSS2(MB2),DLS2(MB2)
      COMMON/AUFB/NORB(0:MEL,MKP+1),NUMOCC(0:MEL),LMXCONF
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EUEH
      COMMON/FILL/NCNF(MCT,0:MEL,MKP+1),NLVL(MCT,0:MEL),CNFG(MCT)
      COMMON/MDLV/ELMT
      COMMON/OCPD/IOCPN(MDM),IOCCM0,IOCTP(MCT,MKP,MKP+1,MKP+1)
C
C     CONVERGENCE TOLERANCE VALUE
      IF(HMLT.EQ.'NORL') THEN
        ENRGTOL = 5.0D-12
      ELSE
        ENRGTOL = 5.0D-13
      ENDIF
C
C     IMPORT ATOMIC CHARGE DETAILS
      IZNV = INT(ZNUC(IZ))
      ELNM = ELMT(IZNV)
      ICRG = IQNC(IZ)
      MLQN =(NKAP(IZ)-1)/2
C
C     CONVERT IZNV AND ICRG TO STRINGS AND WRITE TITLE
      IF(IZNV.LT.10) THEN
        WRITE(ZWRT,'(A,I1)') 'Z = ',IZNV
      ELSEIF(IZNV.LT.100) THEN
        WRITE(ZWRT,'(A,I2)') 'Z = ',IZNV
      ELSE
        WRITE(ZWRT,'(A,I3)') 'Z = ',IZNV
      ENDIF
C
      IF(IZNV-ICRG.LT.10) THEN
        WRITE(QWRT,'(A,I2)') 'Q = ',IZNV-ICRG
      ELSEIF(IZNV.LT.100) THEN
        WRITE(QWRT,'(A,I3)') 'Q = ',IZNV-ICRG
      ELSE
        WRITE(QWRT,'(A,I4)') 'Q = ',IZNV-ICRG
      ENDIF
C
      IF(IZNV-ICRG.GT.0) THEN
        QSGN = '+'
      ELSEIF(IZNV-ICRG.LT.0) THEN
        QSGN = '-'
      ENDIF
C
      ICMD = IABS(IZNV-ICRG)
      IF(IZNV-ICRG.EQ.0) THEN
        WRITE(EWRT,'(A,A,A)') '(',TRIM(ELNM),')'
      ELSEIF(ICMD.EQ.1) THEN
        WRITE(EWRT,'(A,A,A,A,A)') '(',TRIM(ELNM),'^',QSGN,')'
      ELSEIF(ICMD.LT.10) THEN
        WRITE(EWRT,'(A,A,A,I1,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSEIF(ICMD.LT.100) THEN
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSE
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ENDIF
C
C     PRINT TITLE SUMMARY FOR THIS ATOM
20    FORMAT(17X,'Centre',I3,':',3X,A,3X,A,3X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) IZ,ZWRT,QWRT,EWRT
      WRITE(7,20) IZ,ZWRT,QWRT,EWRT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
      IF(CNFG(IZ).EQ.'MANUAL') THEN
        LMXCONF = MLQN
        DO LQN=0,LMXCONF
          NUMOCC(LQN) = NLVL(IZ,LQN)
          DO NQN=1,NLVL(IZ,LQN)
            NORB(LQN,NQN) = NCNF(IZ,LQN,NQN)
          ENDDO
        ENDDO
      ELSEIF(CNFG(IZ).EQ.'AUFBAU') THEN
        CALL AUFBAU(IZNV,ICRG,NORB,NUMOCC,LMXCONF)
      ELSE
        WRITE(6, *) 'In HFSCF0: invalid configuration choice.'
        WRITE(7, *) 'In HFSCF0: invalid configuration choice.'
      ENDIF
C
C     IDENTIFY THE HIGHEST OCCUPIED SHELL
      NMAX = 1
      DO LQN=0,LMXCONF
        IF(NUMOCC(LQN).GT.NMAX) THEN
          NMAX = NUMOCC(LQN)
        ENDIF
      ENDDO
C
C     CHECK WHETHER THERE ARE SUFFICIENT BASIS FUNCTION TYPES
      IF(MLQN.LT.LMXCONF) THEN
        WRITE(6, *) 'In HFSCF0: insufficient angular types in basis.'
        WRITE(7, *) 'In HFSCF0: insufficient angular types in basis.'
        WRITE(6, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        WRITE(7, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        STOP
      ENDIF
C
C     PRINT ATOMIC CONFIGURATION
30    FORMAT(1X,A,2X,A,1X,'|',2X'NSHELL ',12(2X,I2))
31    FORMAT(1X,'LQN = ',I1,2X,I3,2X,'|'1X,' OCC(',A,'):',A,12(2X,I2))
C
      IF(CNFG(IZ).EQ.'MANUAL') THEN
        WRITE(6,30) 'Manual:','#fns',(N,N=1,12)
        WRITE(7,30) 'Manual:','#fns',(N,N=1,12)
      ELSEIF(CNFG(IZ).EQ.'AUFBAU') THEN
        WRITE(6,30) 'Aufbau:','#fns',(N,N=1,12)
        WRITE(7,30) 'Aufbau:','#fns',(N,N=1,12)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LQN=0,MLQN
        WRITE(6,31) LQN,NFNC(LQN,IZ),LLAB(LQN),
     &                   REPEAT(' ',LQN*4),(NORB(LQN,J),J=1,NUMOCC(LQN))
        WRITE(7,31) LQN,NFNC(LQN,IZ),LLAB(LQN),
     &                   REPEAT(' ',LQN*4),(NORB(LQN,J),J=1,NUMOCC(LQN))
      ENDDO
C
C     RESULTS FOR EACH ITERATION
40    FORMAT(1X,A,10X,A,10X,A,13X,A,11X,A)
41    FORMAT(I3,2X,F15.6,2X,F15.6,2X,F18.6,4X,ES12.5)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(7,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     INITIALISE A STORAGE BIN FOR PREVIOUS ATOMIC ENERGY
      EPRV = 0.0D0
C
C**********************************************************************C
C     ZERO-BODY PROBLEM: ICRG = 0. (NO ELECTRONS AROUND CENTRE.)       C
C**********************************************************************C
C
      IF(ICRG.EQ.0) THEN
C
C       NO OCCUPYING ELECTRON -> NO EIGENVALUE NEEDED
C
        EH = 0.0D0
        EG = 0.0D0
        EB = 0.0D0
        ENEW = EH-EG-EB

        WRITE(6,41) 1,EH,EG,ENEW,1.0D0
        WRITE(7,41) 1,EH,EG,ENEW,1.0D0
C
        GOTO 1001
C
C**********************************************************************C
C     ONE-BODY PROBLEM: ICRG = 1. (NO COULOMB ENERGY.)                 C
C**********************************************************************C
C
      ELSEIF(ICRG.EQ.1) THEN
C
C       IMPORT ORDERED ELECTRON OCCUPATION NUMBER
        IOCCML = IOCCM0
C
C       IDENTIFY LQNA AND NSHELL FOR OCCUPIED ELECTRON
        DO LQN=0,LMXCONF
          DO NQN=1,NUMOCC(LQN)
            IF(NORB(LQN,NQN).EQ.1) THEN
              LQNA   = LQN
              NSHELL = NQN
            ENDIF
          ENDDO
        ENDDO
C
C       EFFECTIVE AND AVERAGE OCCUPATION NUMBERS FOR THIS KQNA ORBITAL
C       A CLOSED SUBSHELL (NSHELL,LQNA) CONTAINS NCLS ELECTRONS
        NCLS = 4*LQNA+2
C
C       EFFECTIVE OCCUPANCY FOR ONE ELECTRON IN THIS LQNA SUBSHELL
        QF = DSQRT(1.0D0/DFLOAT(NCLS))
C
C       IMPORT BASIS FUNCTION EXPONENTS
        NBASA = NFNC(LQNA,IZ)
        DO IBAS=1,NBASA
          EXLA(IBAS) = BEXL(IBAS,LQNA,IZ)
        ENDDO
C
C       MATRIX DIMENSIONS FOR THIS LQNA BLOCK
        IF(HMLT.EQ.'NORL') THEN
          NBLC = 0
        ELSE
          NBLC = NBASA
        ENDIF
        NMAT = NBASA+NBLC
C
C       LOOP OVER KAPPA NUMBERS FOR THIS LQNA
        DO KQN=LQNA,LQNA+1
C
C         KQNA VALUE AND FOCK MATRIX STARTING ADDRESS
          IF(KQN.EQ.LQNA) THEN
            KQNA = KQN
            KADD = 2*KQN
          ELSE
            KQNA =-KQN
            KADD = 2*KQN-1
          ENDIF
C
C         IGNORE POSITIVE-SYMMETRY CASE WHEN LQNA=0
          IF(KQNA.EQ.0) GOTO 123
C
C         CLEAR HAMILTONIAN AND OVERLAP ARRAYS
          DO IBAS=1,NMAT
            DO JBAS=1,NMAT
              O1(IBAS,JBAS) = 0.0D0
              H1(IBAS,JBAS) = 0.0D0
              C1(IBAS,JBAS) = 0.0D0
              T1(IBAS,JBAS) = 0.0D0
              V1(IBAS,JBAS) = 0.0D0
              U1(IBAS,JBAS) = 0.0D0
            ENDDO
          ENDDO
C
C         GENERATE OVERLAP, KINETIC AND NUCLEAR ATTRACTION MATRICES
          CALL OVRLP0(O1   ,EXLA   ,KQNA,NBASA)
C         CALL ONEEL0(T1,V1,EXLA,IZ,KQNA,NBASA)
          CALL KINTC0(T1   ,EXLA   ,KQNA,NBASA)
C         CALL PNTNC0(   V1,EXLA,IZ,KQNA,NBASA)
C         CALL GSSNC0(   V1,EXLA,IZ,KQNA,NBASA)
C         CALL UNINC0(   V1,EXLA,IZ,KQNA,NBASA)
C         CALL FMINC0(   V1,EXLA,IZ,KQNA,NBASA)
          CALL GSMNC0(   V1,EXLA,IZ,KQNA,NBASA)
C
C         GENERATE NUCLEAR VACUUM POLARISATION MATRIX
          IF(HMLT.EQ.'DHFQ') THEN
            CALL VACPL0(U1,EXLA,IZ,KQNA,NBASA)
          ENDIF
C
C         HAMILTONIAN MATRIX AND WORKING EIGENVECTOR MATRIX
          DO IBAS=1,NMAT
            DO JBAS=1,NMAT
              H1(IBAS,JBAS) = T1(IBAS,JBAS)+V1(IBAS,JBAS)+U1(IBAS,JBAS)
              C1(IBAS,JBAS) = H1(IBAS,JBAS)
            ENDDO
          ENDDO
C
C         DIAGONALISE MATRIX (THIS NEEDS LAPACK LIBRARY)
          CALL DSYGV(1,'V','U',NMAT,C1,MBD,O1,MBD,W1,T,LWK0,INF)
          IF(INF.NE.0) THEN
            WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INF
            WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INF
            STOP
          ENDIF
C
C         BEGIN LOOP OVER ALL MQN VALUES
          DO IMVAL=1,IABS(KQNA)
C
C           FOCK MATRIX STARTING ADDRESS
            IL1 = LRGE(IZ,KADD,2*IMVAL-1)
            IL2 = LRGE(IZ,KADD,2*IMVAL  )
            IF(HMLT.NE.'NORL') THEN
              IS1 = LRGE(IZ,KADD,2*IMVAL-1)+NSKP
              IS2 = LRGE(IZ,KADD,2*IMVAL  )+NSKP
            ENDIF
C
C           LOOP OVER ALL SOLUTIONS OF EIGENVALUE PROBLEM
            DO IBAS=1,NBASA
C
C             COPY ENERGY EIGENVALUES TO MASTER LIST
              EIGN(NSKP+IL1+IBAS) = W1(NBLC+IBAS)
              EIGN(NSKP+IL2+IBAS) = W1(NBLC+IBAS)
              IF(HMLT.NE.'NORL') THEN
                EIGN(     IL1+IBAS) = W1(     IBAS)
                EIGN(     IL2+IBAS) = W1(     IBAS)
              ENDIF
C
C             LOOP OVER BASIS FUNCTIONS
              DO JBAS=1,NBASA
C
C               SPINOR COEFFICIENT FOR THIS BASIS FUNCTION
                CLP = QF*C1(     JBAS,NBLC+IBAS)
                IF(HMLT.NE.'NORL') THEN
                  CSP = QF*C1(NBLC+JBAS,NBLC+IBAS)
                  CLN = QF*C1(     JBAS,     IBAS)
                  CSN = QF*C1(NBLC+JBAS,     IBAS)
                ENDIF
C
C               COPY INTO MASTER COEFFICIENT LIST
                COEF(IL1+JBAS,NSKP+IL1+IBAS) = DCMPLX(CLP,0.0D0)
                COEF(IL2+JBAS,NSKP+IL2+IBAS) = DCMPLX(CLP,0.0D0)
                IF(HMLT.NE.'NORL') THEN
                  COEF(IS1+JBAS,NSKP+IL1+IBAS) = DCMPLX(CSP,0.0D0)
                  COEF(IS2+JBAS,NSKP+IL2+IBAS) = DCMPLX(CSP,0.0D0)
                  COEF(IL1+JBAS,     IL1+IBAS) = DCMPLX(CLN,0.0D0)
                  COEF(IL2+JBAS,     IL2+IBAS) = DCMPLX(CLN,0.0D0)
                  COEF(IS1+JBAS,     IL1+IBAS) = DCMPLX(CSN,0.0D0)
                  COEF(IS2+JBAS,     IL2+IBAS) = DCMPLX(CSN,0.0D0)
                ENDIF
C
              ENDDO
C
            ENDDO
C        
          ENDDO
C
C         IDENTIFY ADDRESS LOCATIONS OF OCCUPIED STATES (MQN MANIFOLD)
          DO ISUB=1,2*IABS(KQNA)
            IOCPN(IOCCML+ISUB) = LRGE(IZ,KADD,ISUB)+NSHELL
            IOCTP(IZ,KADD,ISUB,NSHELL) = IOCPN(IOCCML+ISUB)
          ENDDO
C
C         INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (NCLS AT A TIME)
          IOCCML = IOCCML+2*IABS(KQNA)
C
123       CONTINUE
C
C       END LOOP OVER KQNS
        ENDDO
C
C       ONE-BODY ENERGIES (USE MOST RECENT SOLUTIONS)
        EH = W1(NBLC+NSHELL)
C
C       ONE-BODY ENERGIES FOR OCCUPIED ELECTRONS
        M = 0
        DO IBAS=1,NBASA
          DO JBAS=1,NBASA
            M = M+1
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBASA
            LBAS = JBAS+NBASA
C
            DLL = C1(IBAS,NBLC+NSHELL)*C1(JBAS,NBLC+NSHELL)
            DSL = C1(KBAS,NBLC+NSHELL)*C1(JBAS,NBLC+NSHELL)
            DSS = C1(KBAS,NBLC+NSHELL)*C1(LBAS,NBLC+NSHELL)
C
C           KINETIC ENERGY: LL BLOCK
            IF(HMLT.EQ.'NORL') THEN
C
              EK = EK + T1(IBAS,JBAS)*DLL
C
C           KINETIC ENERGY: SL BLOCK
            ELSE
C
              EK = EK + 2.0D0*T1(KBAS,JBAS)*DSL
C
            ENDIF          
C
C           NUCLEAR ATTRACTION
            EV = EV + V1(IBAS,JBAS)*DLL + V1(KBAS,LBAS)*DSS
C
C           VACUUM POLARISATION: LL BLOCK
            EU = EU + U1(IBAS,JBAS)*DLL + U1(KBAS,LBAS)*DSS
C
          ENDDO
        ENDDO
C
        EG = 0.0D0
        EB = 0.0D0
        E1 = EK+EN
C
        ENEW = EH
C
C       WRITE RESULT
        WRITE(6,41) 1,EH,0.0D0,ENEW,1.0D0
        WRITE(7,41) 1,EH,0.0D0,ENEW,1.0D0
C
C       UPDATE FOCK LABEL FOR OCCUPATION COUNTER
        IOCCM0 = IOCCML
C
C       EXIT TO CONVERGENCE
        GOTO 1001
C
      ENDIF
C
C**********************************************************************C
C     TWO-BODY PROBLEM: INTERACTING ELECTRONS. (TREAT WITH SCF.)       C
C -------------------------------------------------------------------- C
C     ENTER ITERATIVE SELF-CONSISTENT FIELD PROCEDURE (USE INDEX 1000) C
C**********************************************************************C
C
      DO 1000 ITER=1,MIT0
C
C       INITIALISE ONE-BODY AND TWO-BODY ENERGY COUNTERS
        EH = 0.0D0
        EK = 0.0D0
        EV = 0.0D0
        EU = 0.0D0
        EG = 0.0D0
        EB = 0.0D0
C
C       INITIALISE ELECTRON OCCUPATION COUNTER
        IOCCML = IOCCM0
C
C**********************************************************************C
C     ONE-ELECTRON PART: LOOP OVER BASIS FUNCTIONS I,J (USE INDEX 100) C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO 100 LQNA=0,LMXCONF
C
C     RECORD LQNA VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
      NBASA = NFNC(LQNA,IZ)
      DO IBAS=1,NBASA
        EXLA(IBAS) = BEXL(IBAS,LQNA,IZ)
      ENDDO
C
C     MATRIX DIMENSIONS FOR THIS LQNA BLOCK
      IF(HMLT.EQ.'NORL') THEN
        NBLC = 0
      ELSE
        NBLC = NBASA
      ENDIF
      NMAT = NBASA+NBLC
C
C     INITIALISE HAMILTONIAN AND OVERLAP ARRAYS
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
          O1(IBAS,JBAS) = 0.0D0
          O2(IBAS,JBAS) = 0.0D0
          H1(IBAS,JBAS) = 0.0D0
          H2(IBAS,JBAS) = 0.0D0
          C1(IBAS,JBAS) = 0.0D0
          C2(IBAS,JBAS) = 0.0D0
          T1(IBAS,JBAS) = 0.0D0
          T2(IBAS,JBAS) = 0.0D0
          V1(IBAS,JBAS) = 0.0D0
          V2(IBAS,JBAS) = 0.0D0
          U1(IBAS,JBAS) = 0.0D0
          U2(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     EFFECTIVE AND AVERAGE OCCUPATION NUMBERS FOR THIS LQNA ORBITAL
C     A CLOSED SUBSHELL (NSHELL,LQNA) CONTAINS NCLS ELECTRONS
      NCLS = 4*LQNA+2
C
C     FOR EACH LISTED SUBSHELLS OF LQN TYPE
      DO IOCC=1,NUMOCC(LQNA)
C
C       NUMBER OF CHARGES IN THIS SUBSHELL (NSHELL=IOCC+LQNA)
        NQ = NORB(LQNA,IOCC)
C
        IF(NQ.EQ.NCLS) THEN
C         IF SUBSHELL IS CLOSED THERE IS NO FRACTIONAL OCCUPANCY
          QE(IOCC) = 1.0D0
        ELSE
C         IF SUBSHELL IS OPEN, CONSTRUCT FRACTION (GRANT 6.6.24)
          QE(IOCC) = DFLOAT(NQ-1)/DFLOAT(NCLS-1)
        ENDIF
C
C       ACTUAL FRACTIONAL SUBSHELL OCCUPANCY
        IF(NQ.GT.0) THEN
          QA(IOCC) = DFLOAT(NQ)/DFLOAT(NCLS)
        ELSE
          QA(IOCC) = 1.0D0
        ENDIF
C
      ENDDO
C
C     POSITIVE KAPPA(A) CHOICE (APPLIES ONLY FOR LQNA > 0)
      IF(LQNA.EQ.0.OR.HMLT.EQ.'NORL') GOTO 130

      KAPA1 = LQNA
      RK2A1 = DFLOAT(2*IABS(KAPA1))
C
C     GENERATE OVERLAP, KINETIC AND NUCLEAR ATTRACTION MATRICES
      CALL OVRLP0(O1   ,EXLA   ,KAPA1,NBASA)
C     CALL ONEEL0(T1,V1,EXLA,IZ,KAPA1,NBASA)
      CALL KINTC0(T1   ,EXLA   ,KAPA1,NBASA)
C     CALL PNTNC0(   V1,EXLA,IZ,KAPA1,NBASA)
C     CALL GSSNC0(   V1,EXLA,IZ,KAPA1,NBASA)
C     CALL UNINC0(   V1,EXLA,IZ,KAPA1,NBASA)
C     CALL FMINC0(   V1,EXLA,IZ,KAPA1,NBASA)
      CALL GSMNC0(   V1,EXLA,IZ,KAPA1,NBASA)
C
C     GENERATE NUCLEAR VACUUM POLARISATION MATRIX
      IF(HMLT.EQ.'DHFQ') THEN
        CALL VACPL0(U1,EXLA,IZ,KAPA1,NBASA)
      ENDIF
C
C     ONE-ELECTRON HAMILTONIAN MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
          H1(IBAS,JBAS) = T1(IBAS,JBAS)+V1(IBAS,JBAS)+U1(IBAS,JBAS)
        ENDDO
      ENDDO
C
130   CONTINUE
C
C     NEGATIVE KAPPA(A) CHOICE (APPLIES TO ALL LQNA VALUES)
      KAPA2 =-LQNA-1
      IF(HMLT.EQ.'NORL') THEN
        RK2A2 = DFLOAT(NCLS)
      ELSE
        RK2A2 = DFLOAT(2*IABS(KAPA2))
      ENDIF
C
C     GENERATE OVERLAP, KINETIC AND NUCLEAR ATTRACTION MATRICES
      CALL OVRLP0(O2   ,EXLA   ,KAPA2,NBASA)
C     CALL ONEEL0(T2,V2,EXLA,IZ,KAPA2,NBASA)
      CALL KINTC0(T2   ,EXLA   ,KAPA2,NBASA)
C     CALL PNTNC0(   V2,EXLA,IZ,KAPA2,NBASA)
c     CALL GSSNC0(   V2,EXLA,IZ,KAPA2,NBASA)
C     CALL UNINC0(   V2,EXLA,IZ,KAPA2,NBASA)
C     CALL FMINC0(   V2,EXLA,IZ,KAPA2,NBASA)
      CALL GSMNC0(   V2,EXLA,IZ,KAPA2,NBASA)
C
C     GENERATE NUCLEAR VACUUM POLARISATION MATRIX
      IF(HMLT.EQ.'DHFQ') THEN
        CALL VACPL0(U2,EXLA,IZ,KAPA2,NBASA)
      ENDIF
C
C     ONE-ELECTRON HAMILTONIAN MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
          H2(IBAS,JBAS) = T2(IBAS,JBAS)+V2(IBAS,JBAS)+U2(IBAS,JBAS)
        ENDDO
      ENDDO
C
C     SKIP SCF INTERACTIONS IN FIRST ITERATION
      IF(ITER.EQ.1) GOTO 150
C
C     INITIALISE RELEVANT COUNTERS AND ARRAYS
      RK2B1 = 0.0D0
      RK2B2 = 0.0D0
C
C**********************************************************************C
C     TWO-ELECTRON PART: LOOP OVER BASIS FUNCTIONS K,L (USE INDEX 200) C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO 200 LQNB=0,LMXCONF
C
C     RECORD LQNB VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
      NBASB = NFNC(LQNB,IZ)
      DO JBAS=1,NBASB
        EXLB(JBAS) = BEXL(JBAS,LQNB,IZ)
      ENDDO
C
C     NUMBER OF BASIS FUNCTION OVERLAPS IN THIS BLOCK
      MAXM = NBASB*NBASB
C
C     POSITIVE KAPPA(B) CHOICE (APPLIES ONLY FOR LQNB > 0)
      IF(LQNB.EQ.0.OR.HMLT.EQ.'NORL') GOTO 230
C
C     ANGULAR QUANTUM NUMBER AND DEGENERACY
      KAPB1 = LQNB
      RK2B1 = DFLOAT(2*IABS(KAPB1))
C
C     RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
      IF(LQNA.EQ.LQNB) THEN
        DO M=1,MAXM
          DLL1(M) = DENLL(M,2*LQNB  )
          DSL1(M) = DENSL(M,2*LQNB  )
          DSS1(M) = DENSS(M,2*LQNB  )
          DLS1(M) = DENLS(M,2*LQNB  )
        ENDDO
      ELSEIF(LQNA.NE.LQNB) THEN
        DO M=1,MAXM
          DLL1(M) = DFNLL(M,2*LQNB  )
          DSL1(M) = DFNSL(M,2*LQNB  )
          DSS1(M) = DFNSS(M,2*LQNB  )
          DLS1(M) = DFNLS(M,2*LQNB  )
        ENDDO
      ENDIF
C
230   CONTINUE
C
C     NEGATIVE KAPPA(B) CHOICE (APPLIES TO ALL LQNB VALUES)
C
C     ANGULAR QUANTUM NUMBER AND DEGENERACY
      KAPB2 =-LQNB-1
      IF(HMLT.EQ.'NORL') THEN
        RK2B2 = DFLOAT(4*LQNB+2)
      ELSE
        RK2B2 = DFLOAT(2*IABS(KAPB2))
      ENDIF
C
C     RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
      IF(LQNA.EQ.LQNB) THEN
        DO M=1,MAXM
          DLL2(M) = DENLL(M,2*LQNB+1)
          IF(HMLT.NE.'NORL') THEN
            DSL2(M) = DENSL(M,2*LQNB+1)
            DSS2(M) = DENSS(M,2*LQNB+1)
            DLS2(M) = DENLS(M,2*LQNB+1)
          ENDIF
        ENDDO
      ELSEIF(LQNA.NE.LQNB) THEN
        DO M=1,MAXM
          DLL2(M) = DFNLL(M,2*LQNB+1)
          IF(HMLT.NE.'NORL') THEN
            DSL2(M) = DFNSL(M,2*LQNB+1)
            DSS2(M) = DFNSS(M,2*LQNB+1)
            DLS2(M) = DFNLS(M,2*LQNB+1)
          ENDIF
        ENDDO
      ENDIF
C
C**********************************************************************C
C     GENERATE ATOMIC MEAN-FIELD COULOMB MATRIX                        C
C**********************************************************************C
C
C     GENERATE THE MEAN-FIELD ATOMIC COULOMB MATRIX OVER DENSITIES
      CALL COULM0
C
C     ADD COULOMB MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC COULOMB MATRIX
C
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B2*G22(IBAS,JBAS)
C
          ELSE
C         RELATIVISTIC COULOMB MATRIX
C
            H1(IBAS,JBAS) = H1(IBAS,JBAS) + RK2B1*G11(IBAS,JBAS)
     &                                    + RK2B2*G12(IBAS,JBAS)
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B1*G21(IBAS,JBAS)
     &                                    + RK2B2*G22(IBAS,JBAS)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C     TWO-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC COULOMB ENERGY
C
            EG = EG + RK2A2*RK2B2*G22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
          ELSE
C         RELATIVISTIC COULOMB ENERGY
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBASA
            LBAS = JBAS+NBASA
C
C           LL BLOCK
            EG = EG
     &         +       RK2A1*RK2B1*G11(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &         +       RK2A1*RK2B2*G12(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &         +       RK2A2*RK2B1*G21(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
     &         +       RK2A2*RK2B2*G22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C           SL BLOCK
            EG = EG
     &         + 2.0D0*RK2A1*RK2B1*G11(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &         + 2.0D0*RK2A1*RK2B2*G12(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &         + 2.0D0*RK2A2*RK2B1*G21(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
     &         + 2.0D0*RK2A2*RK2B2*G22(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
C
C           SS BLOCK
            EG = EG
     &         +       RK2A1*RK2B1*G11(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &         +       RK2A1*RK2B2*G12(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &         +       RK2A2*RK2B1*G21(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
     &         +       RK2A2*RK2B2*G22(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE ATOMIC MEAN-FIELD BREIT MATRIX                          C
C**********************************************************************C
C
C     GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX
      IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 250
C
C     GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX OVER DENSITIES
      CALL BREIT0
C
C     ADD TWO-PARTICLE CONTRIBUTIONS TO FOCK MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
C
          H1(IBAS,JBAS) = H1(IBAS,JBAS) + RK2B1*B11(IBAS,JBAS)
     &                                  + RK2B2*B12(IBAS,JBAS)
          H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B1*B21(IBAS,JBAS)
     &                                  + RK2B2*B22(IBAS,JBAS)
C
        ENDDO
      ENDDO
C
C     TWO-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
C         LL BLOCK
          EB = EB
     &       +       RK2A1*RK2B1*B11(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &       +       RK2A1*RK2B2*B12(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &       +       RK2A2*RK2B1*B21(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
     &       +       RK2A2*RK2B2*B22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C         SL BLOCK
          EB = EB
     &       + 2.0D0*RK2A1*RK2B1*B11(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &       + 2.0D0*RK2A1*RK2B2*B12(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &       + 2.0D0*RK2A2*RK2B1*B21(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
     &       + 2.0D0*RK2A2*RK2B2*B22(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
C
C         SS BLOCK
          EB = EB
     &       +       RK2A1*RK2B1*B11(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &       +       RK2A1*RK2B2*B12(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &       +       RK2A2*RK2B1*B21(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
     &       +       RK2A2*RK2B2*B22(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
        ENDDO
      ENDDO
C
250   CONTINUE
C
C**********************************************************************C
C     FINISHED GENERATING TWO-ELECTRON INTEGRALS                       C
C**********************************************************************C
C
C     END LOOP OVER LQNS FOR ORBITAL B
200   CONTINUE
C
C     ONE-BODY ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
C         KINETIC ENERGY: LL BLOCK
          IF(HMLT.EQ.'NORL') THEN
C
            EK = EK + RK2A2*T2(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C         KINETIC ENERGY: SL BLOCK
          ELSE
C
            EK = EK + 2.0D0*RK2A1*T1(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &              + 2.0D0*RK2A2*T2(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
C
          ENDIF          
C
C         NUCLEAR ATTRACTION: LL BLOCK
          EV = EV + RK2A1*V1(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &            + RK2A2*V2(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C         NUCLEAR ATTRACTION: SS BLOCK
          EV = EV + RK2A1*V1(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &            + RK2A2*V2(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
C         VACUUM POLARISATION: LL BLOCK
          EU = EU + RK2A1*U1(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &            + RK2A2*U2(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C         VACUUM POLARISATION: SS BLOCK
          EU = EU + RK2A1*U1(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &            + RK2A2*U2(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
        ENDDO
      ENDDO
C
C     FINISH GENERATING SCF CONTRIBUTIONS
150   CONTINUE
C
C     FINISHED CALCULATING OVERLAP COMBINATIONS BETWEEN THIS LQNA
C     VALUE AND ALL POSSIBLE LQNB VALUES
C
C**********************************************************************C
C     MATRIX DIAGONALISATION AND COEFFICIENT MATRIX UPDATES            C
C**********************************************************************C
C
C     POSITIVE KAPPA(A) CHOICE (APPLIES ONLY FOR LQNA > 0)
      IF(LQNA.EQ.0.OR.HMLT.EQ.'NORL') GOTO 140
C
C     WORKING EIGENVECTOR MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
          C1(IBAS,JBAS) = H1(IBAS,JBAS)
        ENDDO
      ENDDO
C
C     DIAGONALISE FOCK MATRIX (THIS NEEDS LAPACK LIBRARY)
      CALL DSYGV(1,'V','U',NMAT,C1,MBD,O1,MBD,W1,T,LWK0,INFO)
      IF(INFO.NE.0) THEN
        WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        STOP
      ENDIF
C
C     ATOMIC SELECTION RULE: ORTHOGONALITY IN BLOCKS OF KQN -> KA = KB
C
C     BEGIN LOOP OVER ALL MQNA VALUES
      DO IMVAL=1,IABS(KAPA1)
C
C       COEFFICIENT MATRIX ADDRESSES
        IL1 = LRGE(IZ,2*LQNA  ,2*IMVAL-1)
        IL2 = LRGE(IZ,2*LQNA  ,2*IMVAL  )
        IS1 = LRGE(IZ,2*LQNA  ,2*IMVAL-1)+NSKP
        IS2 = LRGE(IZ,2*LQNA  ,2*IMVAL  )+NSKP
C
C       LOOP OVER ALL SOLUTIONS OF THE EIGENVALUE PROBLEM
        DO IBAS=1,NBASA
C
C         COPY ENERGY EIGENVALUES TO MASTER LIST
          EIGN(NSKP+IL1+IBAS) = W1(NBLC+IBAS)
          EIGN(NSKP+IL2+IBAS) = W1(NBLC+IBAS)
          EIGN(     IL1+IBAS) = W1(     IBAS)
          EIGN(     IL2+IBAS) = W1(     IBAS)
C
C         EFFECTIVE FRACTIONAL OCCUPANCY FOR THIS ORBITAL
          QF = DSQRT(QA(IBAS))
C
C         LOOP OVER BASIS FUNCTIONS
          DO JBAS=1,NBASA
C
C           KRAMERS PAIR LARGE- AND SMALL-COMPONENT COEFFICIENTS
            CLP = QF*C1(     JBAS,NBLC+IBAS)
            CSP = QF*C1(NBLC+JBAS,NBLC+IBAS)
            CLN = QF*C1(     JBAS,     IBAS)
            CSN = QF*C1(NBLC+JBAS,     IBAS)
C
C           COPY INTO MASTER COEFFICIENT LIST
            COEF(IL1+JBAS,NSKP+IL1+IBAS) = DCMPLX(CLP,0.0D0)
            COEF(IL2+JBAS,NSKP+IL2+IBAS) = DCMPLX(CLP,0.0D0)
            COEF(IS1+JBAS,NSKP+IL1+IBAS) = DCMPLX(CSP,0.0D0)
            COEF(IS2+JBAS,NSKP+IL2+IBAS) = DCMPLX(CSP,0.0D0)
            COEF(IL1+JBAS,     IL1+IBAS) = DCMPLX(CLN,0.0D0)
            COEF(IL2+JBAS,     IL2+IBAS) = DCMPLX(CLN,0.0D0)
            COEF(IS1+JBAS,     IL1+IBAS) = DCMPLX(CSN,0.0D0)
            COEF(IS2+JBAS,     IL2+IBAS) = DCMPLX(CSN,0.0D0)
C          
          ENDDO
        ENDDO
C
C       LOOP OVER ALL OCCUPIED SUBSHELLS OF THIS KQN TYPE GIVEN MQN
        DO IOCC=1,NUMOCC(LQNA)
C
C         SKIP UNOCCUPIED ORBITALS
          IF(NORB(LQNA,IOCC).NE.0) THEN
C
C           FOCK ADDRESS FOR THIS PAIR
            IOCPN(IOCCML+1) = LRGE(IZ,2*LQNA  ,2*IMVAL-1)+IOCC
            IOCPN(IOCCML+2) = LRGE(IZ,2*LQNA  ,2*IMVAL  )+IOCC
C
C           SAVE THESE STARTING ADDRESSES
            IOCTP(IZ,2*LQNA  ,2*IMVAL-1,IOCC) = IOCPN(IOCCML+1)
            IOCTP(IZ,2*LQNA  ,2*IMVAL  ,IOCC) = IOCPN(IOCCML+2)
C
C           INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
            IOCCML = IOCCML+2
C
          ENDIF
C
        ENDDO
C
      ENDDO
C
C     BUILD ATOMIC CHARGE DENSITY MATRIX FOR THIS KQNA BLOCK
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         INITIALISE ATOMIC DENSITY LISTS FOR THIS BLOCK
          DENLL(M,2*LQNA  ) = 0.0D0
          DENSL(M,2*LQNA  ) = 0.0D0
          DENSS(M,2*LQNA  ) = 0.0D0
          DENLS(M,2*LQNA  ) = 0.0D0
C
          DFNLL(M,2*LQNA  ) = 0.0D0
          DFNSL(M,2*LQNA  ) = 0.0D0
          DFNSS(M,2*LQNA  ) = 0.0D0
          DFNLS(M,2*LQNA  ) = 0.0D0
C
C         LOOP OVER ALL LISTED SUBSHELLS OF THIS KQN TYPE
          DO IOCC=1,NUMOCC(LQNA)
C
C           SKIP THIS STEP SUBSHELL IS UNOCCUPIED
            IF(NORB(LQNA,IOCC).GT.0) THEN
            
C             DENSITY OVERLAPS FROM EIGENVECTOR PRODUCTS
              DLL = C1(IBAS     ,NBLC+IOCC)*C1(JBAS     ,NBLC+IOCC)
              DSL = C1(IBAS+NBLC,NBLC+IOCC)*C1(JBAS     ,NBLC+IOCC)
              DSS = C1(IBAS+NBLC,NBLC+IOCC)*C1(JBAS+NBLC,NBLC+IOCC)
              DLS = C1(IBAS     ,NBLC+IOCC)*C1(JBAS+NBLC,NBLC+IOCC)
C
C             ADD DENSITY CONTRIBUTIONS TO ATOMIC LIST
              DENLL(M,2*LQNA  ) = DENLL(M,2*LQNA  ) + QE(IOCC)*DLL
              DENSL(M,2*LQNA  ) = DENSL(M,2*LQNA  ) + QE(IOCC)*DSL
              DENSS(M,2*LQNA  ) = DENSS(M,2*LQNA  ) + QE(IOCC)*DSS
              DENLS(M,2*LQNA  ) = DENLS(M,2*LQNA  ) + QE(IOCC)*DLS
C
              DFNLL(M,2*LQNA  ) = DFNLL(M,2*LQNA  ) + QA(IOCC)*DLL
              DFNSL(M,2*LQNA  ) = DFNSL(M,2*LQNA  ) + QA(IOCC)*DSL
              DFNSS(M,2*LQNA  ) = DFNSS(M,2*LQNA  ) + QA(IOCC)*DSS
              DFNLS(M,2*LQNA  ) = DFNLS(M,2*LQNA  ) + QA(IOCC)*DLS
C
             ENDIF
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     ONE-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      DO IOCC=1,NUMOCC(LQNA)
        IF(NORB(LQNA,IOCC).GT.0) THEN
          EH = EH + QA(IOCC)*RK2A1*W1(NBLC+IOCC)
        ENDIF
      ENDDO
C
140   CONTINUE
C
C     NEGATIVE KAPPA(A) CHOICE (APPLIES TO ALL LQNA VALUES)
C
C     WORKING EIGENVECTOR MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
          C2(IBAS,JBAS) = H2(IBAS,JBAS)
        ENDDO
      ENDDO
C
C     DIAGONALISE FOCK MATRIX (THIS NEEDS LAPACK LIBRARY)
      CALL DSYGV(1,'V','U',NMAT,C2,MBD,O2,MBD,W2,T,LWK0,INFO)
      IF(INFO.NE.0) THEN
        WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        STOP
      ENDIF
C
C     ATOMIC SELECTION RULE: ORTHOGONALITY IN BLOCKS OF KQN -> KA = KB
C
C     BEGIN LOOP OVER ALL MQNA VALUES
      DO IMVAL=1,IABS(KAPA2)
C
C       COEFFICIENT MATRIX ADDRESSES
        IL1 = LRGE(IZ,2*LQNA+1,2*IMVAL-1)
        IL2 = LRGE(IZ,2*LQNA+1,2*IMVAL  )
        IS1 = LRGE(IZ,2*LQNA+1,2*IMVAL-1)+NSKP
        IS2 = LRGE(IZ,2*LQNA+1,2*IMVAL  )+NSKP
C
C       LOOP OVER ALL SOLUTIONS OF THE EIGENVALUE PROBLEM
        DO IBAS=1,NBASA
C
C         COPY ENERGY EIGENVALUES TO MASTER LIST
          EIGN(NSKP+IL1+IBAS) = W2(NBLC+IBAS)
          EIGN(NSKP+IL2+IBAS) = W2(NBLC+IBAS)
          EIGN(     IL1+IBAS) = W2(     IBAS)
          EIGN(     IL2+IBAS) = W2(     IBAS)
C
C         EFFECTIVE FRACTIONAL OCCUPANCY FOR THIS ORBITAL
          QF = DSQRT(QA(IBAS))
C
C         LOOP OVER BASIS FUNCTIONS
          DO JBAS=1,NBASA
C
C           KRAMERS PAIR LARGE- AND SMALL-COMPONENT COEFFICIENTS
            CLP = QF*C2(     JBAS,NBLC+IBAS)
            IF(HMLT.NE.'NORL') THEN
              CSP = QF*C2(NBLC+JBAS,NBLC+IBAS)
              CLN = QF*C2(     JBAS,     IBAS)
              CSN = QF*C2(NBLC+JBAS,     IBAS)
            ENDIF
C
C           COPY INTO MASTER COEFFICIENT LIST
            COEF(IL1+JBAS,NSKP+IL1+IBAS) = DCMPLX(CLP,0.0D0)
            COEF(IL2+JBAS,NSKP+IL2+IBAS) = DCMPLX(CLP,0.0D0)
            IF(HMLT.NE.'NORL') THEN
              COEF(IS1+JBAS,NSKP+IL1+IBAS) = DCMPLX(CSP,0.0D0)
              COEF(IS2+JBAS,NSKP+IL2+IBAS) = DCMPLX(CSP,0.0D0)
              COEF(IL1+JBAS,     IL1+IBAS) = DCMPLX(CLN,0.0D0)
              COEF(IL2+JBAS,     IL2+IBAS) = DCMPLX(CLN,0.0D0)
              COEF(IS1+JBAS,     IL1+IBAS) = DCMPLX(CSN,0.0D0)
              COEF(IS2+JBAS,     IL2+IBAS) = DCMPLX(CSN,0.0D0)
            ENDIF
C          
          ENDDO
        ENDDO
C
C       LOOP OVER ALL OCCUPIED SUBSHELLS OF THIS KQN TYPE GIVEN MQN
        DO IOCC=1,NUMOCC(LQNA)
C
C         SKIP UNOCCUPIED ORBITALS
          IF(NORB(LQNA,IOCC).NE.0) THEN
C
C           FOCK ADDRESS FOR THIS PAIR
            IOCPN(IOCCML+1) = LRGE(IZ,2*LQNA+1,2*IMVAL-1)+IOCC
            IOCPN(IOCCML+2) = LRGE(IZ,2*LQNA+1,2*IMVAL  )+IOCC
C
C           SAVE THESE STARTING ADDRESSES
            IOCTP(IZ,2*LQNA+1,2*IMVAL-1,IOCC) = IOCPN(IOCCML+1)
            IOCTP(IZ,2*LQNA+1,2*IMVAL  ,IOCC) = IOCPN(IOCCML+2)
C
C           INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
            IOCCML = IOCCML+2
C
          ENDIF
C
        ENDDO
C
      ENDDO
C
C     NON-RELATIVISTIC SPECIAL CASE: ALSO FILL IN THE +KQNA BLOCK
      IF(HMLT.EQ.'NORL'.AND.LQNA.GT.0) THEN
C
        DO IMVAL=1,IABS(KAPA(2*LQNA  ,IZ))
C
C         COEFFICIENT MATRIX ADDRESSES
          IL1 = LRGE(IZ,2*LQNA  ,2*IMVAL-1)
          IL2 = LRGE(IZ,2*LQNA  ,2*IMVAL  )
C
C         LOOP OVER ALL SOLUTIONS OF THE EIGENVALUE PROBLEM
          DO IBAS=1,NBASA
C
C           COPY ENERGY EIGENVALUES TO MASTER LIST
            EIGN(NSKP+IL1+IBAS) = W2(NBLC+IBAS)
            EIGN(NSKP+IL2+IBAS) = W2(NBLC+IBAS)
C
C           EFFECTIVE FRACTIONAL OCCUPANCY FOR THIS ORBITAL
            QF = DSQRT(QA(IBAS))
C
C           LOOP OVER BASIS FUNCTIONS
            DO JBAS=1,NBASA
C
C             KRAMERS PAIR LARGE- AND SMALL-COMPONENT COEFFICIENTS
              CLP = QF*C2(     JBAS,NBLC+IBAS)
C
C             COPY INTO MASTER COEFFICIENT LIST
              COEF(IL1+JBAS,NSKP+IL1+IBAS) = DCMPLX(CLP,0.0D0)
              COEF(IL2+JBAS,NSKP+IL2+IBAS) = DCMPLX(CLP,0.0D0)
C          
            ENDDO
          ENDDO
C
C         LOOP OVER ALL OCCUPIED SUBSHELLS OF THIS KQN TYPE GIVEN MQN
          DO IOCC=1,NUMOCC(LQNA)
C
C           SKIP UNOCCUPIED ORBITALS
            IF(NORB(LQNA,IOCC).NE.0) THEN
C
C             FOCK ADDRESS FOR THIS PAIR
              IOCPN(IOCCML+1) = LRGE(IZ,2*LQNA  ,2*IMVAL-1)+IOCC
              IOCPN(IOCCML+2) = LRGE(IZ,2*LQNA  ,2*IMVAL  )+IOCC
C
C             SAVE THESE STARTING ADDRESSES
              IOCTP(IZ,2*LQNA  ,2*IMVAL-1,IOCC) = IOCPN(IOCCML+1)
              IOCTP(IZ,2*LQNA  ,2*IMVAL  ,IOCC) = IOCPN(IOCCML+2)
C
C             INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
              IOCCML = IOCCML+2
C
            ENDIF
C
          ENDDO
C
        ENDDO
C
      ENDIF
C
C     BUILD ATOMIC CHARGE DENSITY MATRIX FOR THIS KQNA BLOCK
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         INITIALISE ATOMIC DENSITY LISTS FOR THIS BLOCK
          DENLL(M,2*LQNA+1) = 0.0D0
          DFNLL(M,2*LQNA+1) = 0.0D0
C
          IF(HMLT.NE.'NORL') THEN
            DENSL(M,2*LQNA+1) = 0.0D0
            DFNSL(M,2*LQNA+1) = 0.0D0
C
            DENSS(M,2*LQNA+1) = 0.0D0
            DFNSS(M,2*LQNA+1) = 0.0D0
C
            DENLS(M,2*LQNA+1) = 0.0D0
            DFNLS(M,2*LQNA+1) = 0.0D0
          ENDIF
C
C         LOOP OVER ALL LISTED SUBSHELLS OF THIS KQN TYPE
          DO IOCC=1,NUMOCC(LQNA)
C
C           SKIP THIS STEP IF SUBSHELL IS UNOCCUPIED
            IF(NORB(LQNA,IOCC).GT.0) THEN
C
C             LL DENSITY CONTRIBUTIONS
              DLL = C2(IBAS     ,NBLC+IOCC)*C2(JBAS     ,NBLC+IOCC)
              DENLL(M,2*LQNA+1) = DENLL(M,2*LQNA+1) + QE(IOCC)*DLL
              DFNLL(M,2*LQNA+1) = DFNLL(M,2*LQNA+1) + QA(IOCC)*DLL
C
              IF(HMLT.NE.'NORL') THEN
C
C               SL DENSITY CONTRIBUTIONS
                DSL = C2(IBAS+NBLC,NBLC+IOCC)*C2(JBAS     ,NBLC+IOCC)
                DENSL(M,2*LQNA+1) = DENSL(M,2*LQNA+1) + QE(IOCC)*DSL
                DFNSL(M,2*LQNA+1) = DFNSL(M,2*LQNA+1) + QA(IOCC)*DSL
C
C               SS DENSITY CONTRIBUTIONS
                DSS = C2(IBAS+NBLC,NBLC+IOCC)*C2(JBAS+NBLC,NBLC+IOCC)
                DENSS(M,2*LQNA+1) = DENSS(M,2*LQNA+1) + QE(IOCC)*DSS
                DFNSS(M,2*LQNA+1) = DFNSS(M,2*LQNA+1) + QA(IOCC)*DSS
C
C               LS DENSITY CONTRIBUTIONS
                DLS = C2(IBAS     ,NBLC+IOCC)*C2(JBAS+NBLC,NBLC+IOCC)
                DENLS(M,2*LQNA+1) = DENLS(M,2*LQNA+1) + QE(IOCC)*DLS
                DFNLS(M,2*LQNA+1) = DFNLS(M,2*LQNA+1) + QA(IOCC)*DLS
C
              ENDIF
C
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     ONE-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      DO IOCC=1,NUMOCC(LQNA)
        IF(NORB(LQNA,IOCC).GT.0) THEN
          EH = EH + QA(IOCC)*RK2A2*W2(NBLC+IOCC)
        ENDIF
      ENDDO
C
C     END LOOP OVER LQNA VALUES
100   CONTINUE
C
C     COULOMB AND BREIT ENERGIES HAVE BEEN DOUBLE-COUNTED
      EG = EG/2.0D0
      EB = EB/2.0D0
C
      E2 = EG+EB
C
C     TOTAL ATOMIC ENERGY IN THIS ITERATION
C     ENEW = EK+EV+EU-EG-EB
      ENEW = EH+EU-EG-EB
C
C     RELATIVE CHANGE IN ENERGY
      ETEST = DABS((EPRV-ENEW)/ENEW)
C
C     WRITE THE ITERATION NUMBER AND THE TOTAL ENERGY
      WRITE(6,41) ITER,EH,E2,ENEW,ETEST
      WRITE(7,41) ITER,EH,E2,ENEW,ETEST
C
C     SUCCESSFUL CONVERGENCE
      IF(ETEST.LE.ENRGTOL) THEN
        GOTO 1001
      ELSE
        EPRV = ENEW
      ENDIF
C
C     BARE NUCLEUS APPROXIMATION
      IF(HMLT.EQ.'BARE') GOTO 1001
C
C     END LOOP OVER ITERATIONS
1000  CONTINUE
C
C     WARN USER THAT ATOMIC SCF DID NOT CONVERGE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6, *) 'In HFSCF0: no convergence in ',ITER,' iterations.'
      WRITE(7, *) 'In HFSCF0: no convergence in ',ITER,' iterations.'
C
C     COVERGENCE SUCCESSFUL
1001  CONTINUE
C
C**********************************************************************C
C     WRITTEN SUMMARY                                                  C
C**********************************************************************C
C
C     SUMMARY OF ENERGY CONTRIBUTIONS
50    FORMAT(1X,A,24X,F19.12)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,50) 'Electron kinetic energy      ',EK
      WRITE(7,50) 'Electron kinetic energy      ',EK
      WRITE(6,50) 'Nuclear attraction energy    ',EV
      WRITE(7,50) 'Nuclear attraction energy    ',EV
      WRITE(6,50) 'Two-electron energy (Coulomb)',EG
      WRITE(7,50) 'Two-electron energy (Coulomb)',EG
      IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 500
      WRITE(6,50) 'Two-electron energy (Breit)  ',EB
      WRITE(7,50) 'Two-electron energy (Breit)  ',EB
      IF(HMLT.NE.'DHFQ') GOTO 500
      WRITE(6,50) 'Uehling energy               ',EU
      WRITE(7,50) 'Uehling energy               ',EU
500   CONTINUE
      WRITE(6,50) 'Total energy                 ',ENEW
      WRITE(7,50) 'Total energy                 ',ENEW
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C     CALCULATE BY STUPID RATIO THAT GRASP USES
      WRITE(6,50) 'Virial nuclear/kinetic ratio ',(ENEW-EK)/EK
      WRITE(7,50) 'Virial nuclear/kinetic ratio ',(ENEW-EK)/EK
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
C
C**********************************************************************C
C     ORBITAL AND ENERGY COUNTERS FOR WHOLE MOLECULE                   C
C**********************************************************************C
C
C     UPDATE COUNTER FOR HIGHEST OCCUPIED ATOMIC ORBITAL
      IOCCM0 = IOCCML
C
C     ADD RESULTS FROM THIS ATOM TO MOLECULAR ENERGY
      ETOT = ETOT + ENEW
      EONE = EONE + EH
      ECLG = ECLG + EG
      EBRG = EBRG + EB
      EUEH = EUEH + EU
C
      RETURN
      END
C
C
      SUBROUTINE G2PAIR0(IZ,IA,G2INT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      GGGGGG   222222  PPPPPPPP     AA    IIII RRRRRRR   000000       C
C     GG    GG 22    22 PP     PP   AAAA    II  RR    RR 00   000      C
C     GG             22 PP     PP  AA  AA   II  RR    RR 00  0000      C
C     GG           22   PP     PP AA    AA  II  RR    RR 00 00 00      C
C     GG   GGG   22     PPPPPPPP  AAAAAAAA  II  RRRRRRR  0000  00      C
C     GG    GG 22       PP        AA    AA  II  RR    RR 000   00      C
C      GGGGGG  22222222 PP        AA    AA IIII RR    RR  000000       C
C                                                                      C
C -------------------------------------------------------------------- C
C  G2PAIR0 PERFORMS A FIRST-ORDER ANALYSIS OF A 2-BODY INTERACTION     C
C  APPLIED TO AN AVERAGE-OVER-CONFIGURATION ATOMIC SOLUTION.           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ    - ATOMIC CENTRE INDEX.                                      C
C  ▶ IA    - ANALYSIS MODE (1 - SYMMETRY TYPES, 2 - ATOMIC ORBITALS).  C
C  ▶ G2INT - NAME OF TWO-BODY INTERACTION (COULM OR BREIT).            C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*1 LLAB,QSGN
      CHARACTER*2 ELMT(120),ELNM,KLAB
      CHARACTER*5 NMDL,G2INT
      CHARACTER*6 CNFG
C
      DIMENSION QA(MKP),QE(MKP)
      DIMENSION CL(MBS,MKP,MKP+1),CS(MBS,MKP,MKP+1)
      DIMENSION DALL(MB2,MKP,MKP+1),DALS(MB2,MKP,MKP+1),
     &          DASL(MB2,MKP,MKP+1),DASS(MB2,MKP,MKP+1)
      DIMENSION DELL(MB2,MKP,MKP+1),DELS(MB2,MKP,MKP+1),
     &          DESL(MB2,MKP,MKP+1),DESS(MB2,MKP,MKP+1)
      DIMENSION DNALL(MB2,MKP),DNALS(MB2,MKP),
     &          DNASL(MB2,MKP),DNASS(MB2,MKP)
      DIMENSION DNELL(MB2,MKP),DNELS(MB2,MKP),
     &          DNESL(MB2,MKP),DNESS(MB2,MKP)
      DIMENSION GSET(MBD,MBD,0:1,0:1)
      DIMENSION EGSTT(MKP,MKP,5),EGS(5)
      DIMENSION EGOTT(MKP,MKP,MKP+1,MKP+1,5),EGO(5)
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/ATMB/B11(MBD,MBD),B21(MBD,MBD),B12(MBD,MBD),B22(MBD,MBD)
      COMMON/ATMC/G11(MBD,MBD),G21(MBD,MBD),G12(MBD,MBD),G22(MBD,MBD)
      COMMON/ATMD/DLL1(MB2),DSL1(MB2),DSS1(MB2),DLS1(MB2),
     &            DLL2(MB2),DSL2(MB2),DSS2(MB2),DLS2(MB2)
      COMMON/AUFB/NORB(0:MEL,MKP+1),NUMOCC(0:MEL),LMXCONF
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EUEH
      COMMON/FILL/NCNF(MCT,0:MEL,MKP+1),NLVL(MCT,0:MEL),CNFG(MCT)
      COMMON/OCPD/IOCPN(MDM),IOCCM0,IOCTP(MCT,MKP,MKP+1,MKP+1)
C
C     CONDITIONS UNDER WHICH THIS MAKES NO SENSE
      IF(HMLT.EQ.'NORL'.AND.G2INT.EQ.'BREIT') THEN
        WRITE(6, *) 'In G2PAIR0: cannot apply Breit to NORL.'
        WRITE(7, *) 'In G2PAIR0: cannot apply Breit to NORL.'
      ELSEIF(G2INT.NE.'COULM'.AND.G2INT.NE.'BREIT') THEN
        WRITE(6, *) 'In G2PAIR0: select a valid operator.'
        WRITE(7, *) 'In G2PAIR0: select a valid operator.'
      ENDIF
C
C**********************************************************************C
C     PREPARE DENSITY MATRIX FOR EACH ORBITAL                          C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED SYMMETRY TYPES
      DO IKP=1,2*LMXCONF+1
C
C       QUANTUM NUMBERS
        KQNA = KAPA(IKP,IZ)
        IF(KQNA.LT.0) THEN
          LQNA =-KQNA-1
        ELSE
          LQNA = KQNA
        ENDIF
C
C       AVERAGE FRACTIONAL SUBSHELL OCCUPANCY
        DO NQN=1,NUMOCC(LQNA)
          QA(NQN) = DFLOAT(NORB(LQNA,NQN))/DFLOAT(4*LQNA+2)
        ENDDO
C
C       EFFECTIVE FRACTIONAL SUBSHELL OCCUPANCY
        DO NQN=1,NUMOCC(LQNA)
          IF(NORB(LQNA,NQN).EQ.(4*LQNA+2)) THEN
            QE(NQN) = 1.0D0
          ELSE
            QE(NQN) = DFLOAT(NORB(LQNA,NQN)-1)/DFLOAT(4*LQNA+1)
          ENDIF
        ENDDO
C
C       LOOP OVER ALL OCCUPIED LEVELS
        DO NQN=1,NUMOCC(LQNA)
C
C         SKIP ANY UNOCCUPIED LEVELS
          IF(NORB(LQNA,NQN).NE.0) THEN
C
            QAF = DSQRT(QA(NQN))
C
C           COEFFICIENT MATRIX STARTING ADDRESSES
            IL1 = LRGE(IZ,IKP,1)
            IS1 = LRGE(IZ,IKP,1)+NSKP
          
            IROW = IOCTP(IZ,IKP,1,NQN)
C
C           LOOP OVER BASIS FUNCTIONS
            DO IBAS=1,NFNC(LQNA,IZ)
C
C             IMPORT COEFFICIENTS
              CL(IBAS,IKP,NQN) = DREAL(COEF(IL1+IBAS,IROW+NSKP))/QAF
              CS(IBAS,IKP,NQN) = DREAL(COEF(IS1+IBAS,IROW+NSKP))/QAF
C          
            ENDDO
C        
          ENDIF
C      
        ENDDO
C
C       BUILD ATOMIC CHARGE DENSITY MATRIX FOR THIS KQNA BLOCK
        M = 0
        DO IBAS=1,NFNC(LQNA,IZ)
          DO JBAS=1,NFNC(LQNA,IZ)
            M = M+1
C
C           SUM COUNTERS
            DNALL(M,IKP) = 0.0D0
            DNALS(M,IKP) = 0.0D0
            DNASL(M,IKP) = 0.0D0
            DNASS(M,IKP) = 0.0D0
C
C           SUM COUNTERS
            DNELL(M,IKP) = 0.0D0
            DNELS(M,IKP) = 0.0D0
            DNESL(M,IKP) = 0.0D0
            DNESS(M,IKP) = 0.0D0
C
C           LOOP OVER ALL LISTED SUBSHELLS OF THIS KQN TYPE
            DO NQN=1,NUMOCC(LQNA)
C
              QAF = QA(NQN)
              QEF = QE(NQN)
C
              DALL(M,IKP,NQN) = QAF*CL(IBAS,IKP,NQN)*CL(JBAS,IKP,NQN)
              DALS(M,IKP,NQN) = QAF*CL(IBAS,IKP,NQN)*CS(JBAS,IKP,NQN)
              DASL(M,IKP,NQN) = QAF*CS(IBAS,IKP,NQN)*CL(JBAS,IKP,NQN)
              DASS(M,IKP,NQN) = QAF*CS(IBAS,IKP,NQN)*CS(JBAS,IKP,NQN)
C
C             UPDATE NET DENSITY
              DNALL(M,IKP) = DNALL(M,IKP) + DALL(M,IKP,NQN)
              DNALS(M,IKP) = DNALS(M,IKP) + DALS(M,IKP,NQN)
              DNASL(M,IKP) = DNASL(M,IKP) + DASL(M,IKP,NQN)
              DNASS(M,IKP) = DNASS(M,IKP) + DASS(M,IKP,NQN)
C
              DELL(M,IKP,NQN) = QEF*CL(IBAS,IKP,NQN)*CL(JBAS,IKP,NQN)
              DELS(M,IKP,NQN) = QEF*CL(IBAS,IKP,NQN)*CS(JBAS,IKP,NQN)
              DESL(M,IKP,NQN) = QEF*CS(IBAS,IKP,NQN)*CL(JBAS,IKP,NQN)
              DESS(M,IKP,NQN) = QEF*CS(IBAS,IKP,NQN)*CS(JBAS,IKP,NQN)
C
C             UPDATE NET DENSITY
              DNELL(M,IKP) = DNELL(M,IKP) + DELL(M,IKP,NQN)
              DNELS(M,IKP) = DNELS(M,IKP) + DELS(M,IKP,NQN)
              DNESL(M,IKP) = DNESL(M,IKP) + DESL(M,IKP,NQN)
              DNESS(M,IKP) = DNESS(M,IKP) + DESS(M,IKP,NQN)
C
            ENDDO

          ENDDO
        ENDDO
C
C     END LOOP OVER KQNA VALUES
      ENDDO
C
C**********************************************************************C
C     BREIT ENERGY BY SYMMETRY TYPE PAIRS                              C
C**********************************************************************C
C
      IF(IA.EQ.2) GOTO 699
C
600   FORMAT(1X,88('='),/,27X,A,1X,A,1X,A,/,1X,88('='))
601   FORMAT(1X,'(κA|κB)',9X,'E(LL|LL)',8X,'E(LL|SS)',8X,
     &                       'E(SS|LL)',8X,'E(SS|SS)',10X,'E(TOT)')
602   FORMAT(1X,'(κA|κB)',9X,'E(LL|SS)',8X,'E(LS|LS)',8X,
     &                       'E(SL|LS)',8X,'E(SS|LL)',10X,'E(TOT)')
603   FORMAT(1X,'(',A,'|',A,')',3X,5(F14.10,2X))
604   FORMAT(1X,'Atomic',2X,5(2X,F14.10))
C
C     PRINT HEADER TO TERMINAL
      WRITE(6,600) 'Interaction',G2INT,'by symmetry pairs'
      WRITE(7,600) 'Interaction',G2INT,'by symmetry pairs'
      IF(G2INT.EQ.'COULM') THEN
        WRITE(6,601)
        WRITE(7,601)
      ELSEIF(G2INT.EQ.'BREIT') THEN
        WRITE(6,602)
        WRITE(7,602)
      ENDIF
      WRITE(6,*) REPEAT('-',88)
      WRITE(7,*) REPEAT('-',88)
C
C     INITIALISE BREIT COUNTERS
      DO ITT=1,5
        EGS(ITT) = 0.0D0
        DO KPA=1,MKP
          DO KPB=1,MKP
            EGSTT(KPA,KPB,ITT) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO LQNA=0,LMXCONF
C
C       RECORD LQNA VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
        NBASA = NFNC(LQNA,IZ)
        DO IBAS=1,NBASA
          EXLA(IBAS) = BEXL(IBAS,LQNA,IZ)
        ENDDO
C
C       FULL MATRIX DIMENSION DEPENDS ON HMLT
        IF(HMLT.EQ.'NORL') THEN
          NMATA =   NBASA
        ELSE
          NMATA = 2*NBASA
        ENDIF
C
C       LOOP OVER ALL OCCUPIED LQN VALUES
        DO LQNB=0,LMXCONF
C
C         RECORD LQNB VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
          NBASB = NFNC(LQNB,IZ)
          DO JBAS=1,NBASB
            EXLB(JBAS) = BEXL(JBAS,LQNB,IZ)
          ENDDO
C
C         NUMBER OF BASIS FUNCTION OVERLAPS IN THIS BLOCK
          MAXM = NBASB*NBASB
C
C         RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
          IF(LQNA.NE.LQNB) THEN
            DO M=1,MAXM
              DLL2(M) = DNALL(M,2*LQNB+1)
              DSL2(M) = DNASL(M,2*LQNB+1)
              DSS2(M) = DNASS(M,2*LQNB+1)
              DLS2(M) = DNALS(M,2*LQNB+1)
              IF(LQNB.GT.0) THEN
                DLL1(M) = DNALL(M,2*LQNB  )
                DSL1(M) = DNASL(M,2*LQNB  )
                DSS1(M) = DNASS(M,2*LQNB  )
                DLS1(M) = DNALS(M,2*LQNB  )
              ENDIF
            ENDDO
          ELSE
            DO M=1,MAXM
              DLL2(M) = DNELL(M,2*LQNB+1)
              DSL2(M) = DNESL(M,2*LQNB+1)
              DSS2(M) = DNESS(M,2*LQNB+1)
              DLS2(M) = DNELS(M,2*LQNB+1)
              IF(LQNB.GT.0) THEN
                DLL1(M) = DNELL(M,2*LQNB  )
                DSL1(M) = DNESL(M,2*LQNB  )
                DSS1(M) = DNESS(M,2*LQNB  )
                DLS1(M) = DNELS(M,2*LQNB  )
              ENDIF
            ENDDO
          ENDIF
C
C         BATCH OF TWO-BODY INTEGRALS
          IF(G2INT.EQ.'COULM') THEN
C
C           GENERATE THE MEAN-FIELD ATOMIC COULOMB MATRIX OVER DENSITIES
            CALL COULM0
C
C           TRANSFER RESULTS INTO LOCAL ARRAY
            DO IBAS=1,NMATA
              DO JBAS=1,NMATA
                GSET(IBAS,JBAS,1,1) = G22(IBAS,JBAS)
                GSET(IBAS,JBAS,1,0) = G21(IBAS,JBAS)
                GSET(IBAS,JBAS,0,1) = G12(IBAS,JBAS)
                GSET(IBAS,JBAS,0,0) = G11(IBAS,JBAS)
              ENDDO
            ENDDO
C
          ELSEIF(G2INT.EQ.'BREIT') THEN
C
C           GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX OVER DENSITIES
            CALL BREIT0
C
C           TRANSFER RESULTS INTO LOCAL ARRAY
            DO IBAS=1,NMATA
              DO JBAS=1,NMATA
                GSET(IBAS,JBAS,1,1) = B22(IBAS,JBAS)
                GSET(IBAS,JBAS,1,0) = B21(IBAS,JBAS)
                GSET(IBAS,JBAS,0,1) = B12(IBAS,JBAS)
                GSET(IBAS,JBAS,0,0) = B11(IBAS,JBAS)
              ENDDO
            ENDDO
C          
          ENDIF
C
C         LOOP OVER SYMMETRY TYPES FOR THIS LQNA
          DO 650 ISA=0,1
C
          KQNA = ((-1)**ISA)*LQNA - ISA
          RK2A = DFLOAT(2*IABS(KQNA))
          KPA  = 2*LQNA+ISA
C
          IF(KQNA.EQ.0.OR.HMLT.EQ.'NORL') GOTO 651
C
C         LOOP OVER SYMMETRY TYPES FOR THIS LQNB
          DO 660 ISB=0,1
C
          KQNB = ((-1)**ISB)*LQNB - ISB
          RK2B = DFLOAT(2*IABS(KQNB))
          KPB  = 2*LQNB+ISB
C
          IF(KQNB.EQ.0.OR.HMLT.EQ.'NORL') GOTO 661
C
C         INITIALISE SOME COUNTERS
          GLL = 0.0D0
          GLS = 0.0D0
          GSL = 0.0D0
          GSS = 0.0D0
C
C         SUM OVER THIS BREIT MATRIX AND MULTIPLY BY DENSITY
C         TODO: I SWAPPED THESE OUT TO MATCH UP WITH BREIT1...
          M = 0
          DO IBAS=1,NBASA
            DO JBAS=1,NBASA
              M = M+1
C
C             SMALL COMPONENT BLOCK ADDRESSES
              KBAS = IBAS+NBASA
              LBAS = JBAS+NBASA
C
              GSS = GSS + GSET(IBAS,JBAS,ISA,ISB)*DNALL(M,KPA)
              GSL = GSL + GSET(IBAS,LBAS,ISA,ISB)*DNALS(M,KPA)
              GLS = GLS + GSET(KBAS,JBAS,ISA,ISB)*DNASL(M,KPA)
              GLL = GLL + GSET(KBAS,LBAS,ISA,ISB)*DNASS(M,KPA)
C
            ENDDO
          ENDDO
C
C         MULTIPLY BY SUBSHELL DEGENERACY FACTOR
          EGSTT(KPA,KPB,1) = 0.5D0*RK2A*RK2B*GLL
          EGSTT(KPA,KPB,2) = 0.5D0*RK2A*RK2B*GLS
          EGSTT(KPA,KPB,3) = 0.5D0*RK2A*RK2B*GSL
          EGSTT(KPA,KPB,4) = 0.5D0*RK2A*RK2B*GSS
C
C         TOTAL VALUE              
          EGSTT(KPA,KPB,5) = EGSTT(KPA,KPB,1) + EGSTT(KPA,KPB,2)
     &                     + EGSTT(KPA,KPB,3) + EGSTT(KPA,KPB,4)
C
C         ADD TO NET COMPONENT-TYPE COUNTER
          DO ITT=1,5
            EGS(ITT) = EGS(ITT) + EGSTT(KPA,KPB,ITT)
          ENDDO
C
661       CONTINUE
660       CONTINUE
C
651       CONTINUE
650       CONTINUE
C
C       END LOOP OVER LQNS FOR ORBITAL B
        ENDDO
C
C     END LOOP OVER LQNS FOR ORBITAL A
      ENDDO
C
C     QUOTE THE FINAL RESULTS IN A TABLE
      DO IKP=1,2*LMXCONF+1
        DO JKP=1,2*LMXCONF+1
          WRITE(6,603) KLAB(KAPA(IKP,IZ)),KLAB(KAPA(JKP,IZ)),
     &                                    (EGSTT(IKP,JKP,ITT),ITT=1,5)
          WRITE(7,603) KLAB(KAPA(IKP,IZ)),KLAB(KAPA(JKP,IZ)),
     &                                    (EGSTT(IKP,JKP,ITT),ITT=1,5)
        ENDDO
      ENDDO
      WRITE(6,*) REPEAT('-',88)
      WRITE(7,*) REPEAT('-',88)
      WRITE(6,604) (EGS(ITT),ITT=1,5)
      WRITE(7,604) (EGS(ITT),ITT=1,5)
      WRITE(6,*) REPEAT('=',88)
      WRITE(7,*) REPEAT('=',88)
      WRITE(6,*) ' '
      WRITE(7,*) ' '
C
C     ATOMIC TWO-BODY INTERACTION ENERGY
      E2 = EGS(5)
C
699   CONTINUE
C
C**********************************************************************C
C     BREIT ENERGY BY ATOMIC ORBITAL PAIRS                             C
C**********************************************************************C
C
      IF(IA.EQ.1) GOTO 799
C
700   FORMAT(1X,92('='),/,26X,A,1X,A,1X,A,/,1X,92('='))
701   FORMAT(1X,'(n κA|n κB)',9X,'E(LL|LL)',8X,'E(LL|SS)',8X,
     &                       'E(SS|LL)',8X,'E(SS|SS)',10X,'E(TOT)')
702   FORMAT(1X,'(n κA|n κB)',9X,'E(LL|SS)',8X,'E(LS|LS)',8X,
     &                       'E(SL|LS)',8X,'E(SS|LL)',10X,'E(TOT)')
703   FORMAT(1X,'(',I2,A,'|',I2,A,')',3X,5(F14.10,2X))
704   FORMAT(1X,'Atomic',6X,5(2X,F14.10))
C
C     PRINT HEADER TO TERMINAL
      WRITE(6,700) 'Interaction',G2INT,'by atomic orbital pairs'
      WRITE(7,700) 'Interaction',G2INT,'by atomic orbital pairs'
      IF(G2INT.EQ.'COULM') THEN
        WRITE(6,701)
        WRITE(7,701)
      ELSEIF(G2INT.EQ.'BREIT') THEN
        WRITE(6,702)
        WRITE(7,702)
      ENDIF
      WRITE(6,*) REPEAT('-',92)
      WRITE(7,*) REPEAT('-',92)
C
C     INITIALISE BREIT COUNTERS
      DO ITT=1,5
        EGO(ITT) = 0.0D0
        DO KPA=1,MKP
          DO KPB=1,MKP
            DO IOCC=1,MKP+1
              DO JOCC=1,MKP+1
                EGOTT(KPA,KPB,IOCC,JOCC,ITT) = 0.0D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER ALL OCCUPIED LQNA VALUES
      DO LQNA=0,LMXCONF
C
C       RECORD LQNA VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
        NBASA = NFNC(LQNA,IZ)
        DO IBAS=1,NBASA
          EXLA(IBAS) = BEXL(IBAS,LQNA,IZ)
        ENDDO
C
C       FULL MATRIX DIMENSION DEPENDS ON HMLT
        IF(HMLT.EQ.'NORL') THEN
          NMATA =   NBASA
        ELSE
          NMATA = 2*NBASA
        ENDIF
C
C       LOOP OVER ALL OCCUPIED LQNB VALUES
        DO LQNB=0,LMXCONF
C
C         RECORD LQNB VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
          NBASB = NFNC(LQNB,IZ)
          DO JBAS=1,NBASB
            EXLB(JBAS) = BEXL(JBAS,LQNB,IZ)
          ENDDO
C
C         LOOP OVER ALL OCCUPIED NQNS FOR LQNB TYPE
          DO JOCC=1,NUMOCC(LQNB)
C
C           NUMBER OF BASIS FUNCTION OVERLAPS IN THIS BLOCK
            MAXM = NBASB*NBASB
C
C           RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
            IF(LQNA.NE.LQNB) THEN
              DO M=1,MAXM
                DLL2(M) = DALL(M,2*LQNB+1,JOCC)
                DSL2(M) = DASL(M,2*LQNB+1,JOCC)
                DSS2(M) = DASS(M,2*LQNB+1,JOCC)
                DLS2(M) = DALS(M,2*LQNB+1,JOCC)
                IF(LQNB.GT.0) THEN
                  DLL1(M) = DALL(M,2*LQNB  ,JOCC)
                  DSL1(M) = DASL(M,2*LQNB  ,JOCC)
                  DSS1(M) = DASS(M,2*LQNB  ,JOCC)
                  DLS1(M) = DALS(M,2*LQNB  ,JOCC)
                ENDIF
              ENDDO
            ELSE
              DO M=1,MAXM
                DLL2(M) = DELL(M,2*LQNB+1,JOCC)
                DSL2(M) = DESL(M,2*LQNB+1,JOCC)
                DSS2(M) = DESS(M,2*LQNB+1,JOCC)
                DLS2(M) = DELS(M,2*LQNB+1,JOCC)
                IF(LQNB.GT.0) THEN
                  DLL1(M) = DELL(M,2*LQNB  ,JOCC)
                  DSL1(M) = DESL(M,2*LQNB  ,JOCC)
                  DSS1(M) = DESS(M,2*LQNB  ,JOCC)
                  DLS1(M) = DELS(M,2*LQNB  ,JOCC)
                ENDIF
              ENDDO
            ENDIF
C
C           BATCH OF TWO-BODY INTEGRALS
            IF(G2INT.EQ.'COULM') THEN
C
C             GENERATE THE MEAN-FIELD ATOMIC COULOMB MATRIX
              CALL COULM0
C
C             TRANSFER RESULTS INTO LOCAL ARRAY
              DO IBAS=1,NMATA
                DO JBAS=1,NMATA
                  GSET(IBAS,JBAS,1,1) = G22(IBAS,JBAS)
                  GSET(IBAS,JBAS,1,0) = G21(IBAS,JBAS)
                  GSET(IBAS,JBAS,0,1) = G12(IBAS,JBAS)
                  GSET(IBAS,JBAS,0,0) = G11(IBAS,JBAS)
                ENDDO
              ENDDO
C
            ELSEIF(G2INT.EQ.'BREIT') THEN
C
C             GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX
              CALL BREIT0
C
C             TRANSFER RESULTS INTO LOCAL ARRAY
              DO IBAS=1,NMATA
                DO JBAS=1,NMATA
                  GSET(IBAS,JBAS,1,1) = B22(IBAS,JBAS)
                  GSET(IBAS,JBAS,1,0) = B21(IBAS,JBAS)
                  GSET(IBAS,JBAS,0,1) = B12(IBAS,JBAS)
                  GSET(IBAS,JBAS,0,0) = B11(IBAS,JBAS)
                ENDDO
              ENDDO
C          
            ENDIF
C
C           LOOP OVER ALL OCCUPIED NQNS FOR LQNA TYPE
            DO IOCC=1,NUMOCC(LQNA)
C
C             LOOP OVER SYMMETRY TYPES FOR THIS LQNA
              DO 750 ISA=0,1
C
              KQNA = ((-1)**ISA)*LQNA - ISA
              RK2A = DFLOAT(2*IABS(KQNA))
              KPA  = 2*LQNA+ISA
C
              IF(KQNA.EQ.0.OR.HMLT.EQ.'NORL') GOTO 751
C
C             LOOP OVER SYMMETRY TYPES FOR THIS LQNB
              DO 760 ISB=0,1
C
              KQNB = ((-1)**ISB)*LQNB - ISB
              RK2B = DFLOAT(2*IABS(KQNB))
              KPB  = 2*LQNB+ISB
C
              IF(KQNB.EQ.0.OR.HMLT.EQ.'NORL') GOTO 761
C
C             INITIALISE SOME COUNTERS
              GLL = 0.0D0
              GLS = 0.0D0
              GSL = 0.0D0
              GSS = 0.0D0
C
C             SUM OVER THIS BREIT MATRIX AND MULTIPLY BY DENSITY
              M = 0
              DO IBAS=1,NBASA
                DO JBAS=1,NBASA
                  M = M+1
C
C                 SMALL COMPONENT BLOCK ADDRESSES
                  KBAS = IBAS+NBASA
                  LBAS = JBAS+NBASA
C
                  GLL = GLL + GSET(IBAS,JBAS,ISA,ISB)*DALL(M,KPA,IOCC)
                  GLS = GLS + GSET(IBAS,LBAS,ISA,ISB)*DALS(M,KPA,IOCC)
                  GSL = GSL + GSET(KBAS,JBAS,ISA,ISB)*DASL(M,KPA,IOCC)
                  GSS = GSS + GSET(KBAS,LBAS,ISA,ISB)*DASS(M,KPA,IOCC)
C
                ENDDO
              ENDDO
C
C             MULTIPLY BY SUBSHELL DEGENERACY FACTOR
              EGOTT(KPA,KPB,IOCC,JOCC,1) = 0.5D0*RK2A*RK2B*GLL
              EGOTT(KPA,KPB,IOCC,JOCC,2) = 0.5D0*RK2A*RK2B*GLS
              EGOTT(KPA,KPB,IOCC,JOCC,3) = 0.5D0*RK2A*RK2B*GSL
              EGOTT(KPA,KPB,IOCC,JOCC,4) = 0.5D0*RK2A*RK2B*GSS
C
C             TOTAL VALUE              
              EGOTT(KPA,KPB,IOCC,JOCC,5)
     &        = EGOTT(KPA,KPB,IOCC,JOCC,1) + EGOTT(KPA,KPB,IOCC,JOCC,2)
     &        + EGOTT(KPA,KPB,IOCC,JOCC,3) + EGOTT(KPA,KPB,IOCC,JOCC,4)
C
C             ADD TO NET COMPONENT-TYPE COUNTER
              DO ITT=1,5
                EGO(ITT) = EGO(ITT) + EGOTT(KPA,KPB,IOCC,JOCC,ITT)
              ENDDO
C
761           CONTINUE
760           CONTINUE
C
751           CONTINUE
750           CONTINUE
C
            ENDDO
          ENDDO
C
C       END LOOP OVER LQNS FOR ORBITAL B
        ENDDO
C
C     END LOOP OVER LQNS FOR ORBITAL A
      ENDDO
C
C     LIST OF LQN VALUES FROM IKP
C
C     QUOTE THE FINAL RESULTS IN A TABLE
      DO IKP=1,2*LMXCONF+1
        KQNA = KAPA(IKP,IZ)
        IF(KQNA.LT.0) THEN
          LQNA =-KQNA-1
        ELSE
          LQNA = KQNA
        ENDIF
        DO IOCC=1,NUMOCC(LQNA)
          DO JKP=1,2*LMXCONF+1
            KQNB = KAPA(JKP,IZ)
            IF(KQNB.LT.0) THEN
              LQNB =-KQNB-1
            ELSE
              LQNB = KQNB
            ENDIF
            DO JOCC=1,NUMOCC(LQNB)
              WRITE(6,703) IOCC+LQNA,KLAB(KAPA(IKP,IZ)),
     &                     JOCC+LQNB,KLAB(KAPA(JKP,IZ)),
     &                     (EGOTT(IKP,JKP,IOCC,JOCC,ITT),ITT=1,5)
              WRITE(7,703) IOCC+LQNA,KLAB(KAPA(IKP,IZ)),
     &                     JOCC+LQNB,KLAB(KAPA(JKP,IZ)),
     &                     (EGOTT(IKP,JKP,IOCC,JOCC,ITT),ITT=1,5)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
      WRITE(6,*) REPEAT('-',92)
      WRITE(7,*) REPEAT('-',92)
      WRITE(6,704) (EGO(ITT),ITT=1,5)
      WRITE(7,704) (EGO(ITT),ITT=1,5)
      WRITE(6,*) REPEAT('=',92)
      WRITE(7,*) REPEAT('=',92)
      WRITE(6,*) ' '
      WRITE(7,*) ' '
C
C     ATOMIC TWO-BODY INTERACTION ENERGY
      E2 = EGO(5)
C
799   CONTINUE
C
C**********************************************************************C
C     UPDATE CORRECT ENERGY COUNTER AND EXIT                           C
C**********************************************************************C
C
C     RECORD TOTAL BREIT ENERGY
      IF(G2INT.EQ.'COULM') THEN
        ECLG = ECLG + E2
      ELSEIF(G2INT.EQ.'BREIT') THEN
        EBRG = EBRG + E2
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE OVRLP0(OMAT,EXL,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  VV    VV RRRRRRR  LL      PPPPPPP   000000          C
C         OO    OO VV    VV RR    RR LL      PP    PP 00   000         C
C         OO    OO VV    VV RR    RR LL      PP    PP 00  0000         C
C         OO    OO VV    VV RR    RR LL      PP    PP 00 00 00         C
C         OO    OO  VV  VV  RRRRRRR  LL      PPPPPPP  0000  00         C
C         OO    OO   VVVV   RR    RR LL      PP       000   00         C
C          OOOOOO     VV    RR    RR LLLLLLL PP        000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  OVRLP0 CALCULATES THE ATOMIC OVERLAP MATRIX FOR SYMMETRY TYPE KQN.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION RN(MBS*MBS,4),OMAT(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T32 = RL+1.5D0
          T52 = RL+2.5D0
          E32 = EIJ**T32
          E52 = EIJ**T52
          SLL = 0.5D0*RN(M,1)*GAMHLF(2*LQN+3)/E32
          SSS = 2.0D0*RN(M,3)*GAMHLF(2*LQN+5)*EPR/E52
C
C         OVERLAP MATRIX ELEMENTS
          OMAT(IBAS     ,JBAS     ) = SLL
          IF(HMLT.EQ.'NORL') GOTO 50
          OMAT(IBAS+NBAS,JBAS     ) = 0.0D0
          OMAT(JBAS     ,IBAS+NBAS) = 0.0D0
          OMAT(IBAS+NBAS,JBAS+NBAS) = SSS
50        CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ONEEL0(TMAT,VMAT,EXL,IZ,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  NN    NN EEEEEEEE EEEEEEEE LL      000000           C
C         OO    OO NNN   NN EE       EE       LL     00   000          C
C         OO    OO NNNN  NN EE       EE       LL     00  0000          C
C         OO    OO NN NN NN EEEEEE   EEEEEE   LL     00 00 00          C
C         OO    OO NN  NNNN EE       EE       LL     0000  00          C
C         OO    OO NN   NNN EE       EE       LL     000   00          C
C          OOOOOO  NN    NN EEEEEEEE EEEEEEEE LLLLLLL 000000           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ONEEL0 CALCULATES THE ATOMIC DIRAC AND OVERLAP MATRICES FOR         C
C  SYMMETRY TYPE KQN, USING EVEN-TEMPERED SGTFS.                       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION RN(MBS*MBS,4),TMAT(MBD,MBD),VMAT(MBD,MBD),EXL(MBS)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      TL = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M    = M+1
          EJ   = EXL(JBAS)
          EIJ  = EI+EJ
          EL1  = EIJ**(LQN+1)
          EPR  = EI*EJ
          T52  = RL+2.5D0
          E52  = EIJ**T52
C
C         LL OVERLAP
          ULL = 0.0D0
          IF(NNUC(IZ).EQ.0) THEN
C           POINT-NUCLEUS APPROXIMATION
            ULL = 0.5D0*GAMHLF(2*LQN+2)/EL1
          ELSE
C           NUCLEAR BEST-FIT EXPANSION
            DO IFT=1,NNUC(IZ)
              XI  = XNUC(IZ,IFT)
              FC  = FNUC(IZ,IFT)
              ULL = ULL + FC*ERFINT0(LQN  ,EIJ,XI)
            ENDDO
          ENDIF

          IF(HMLT.EQ.'NORL') THEN
            PLL = GAMHLF(2*LQN+5)*EPR/E52
          ELSE
            PLL = 0.0D0
          ENDIF
C
C         TRANSFER INTO KINETIC AND NUCLEAR ATTRACTION MATRICES
          TMAT(IBAS,JBAS) =           RN(M,1)*PLL
          VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
C
C         LS,SL AND SS OVERLAPS
          IF(HMLT.EQ.'NORL') GOTO 50
C
C         OVERLAPS, KINETIC ELEMENTS AND SS POTENTIAL INTEGRALS
          SSS = 2.0D0*RN(M,3)*GAMHLF(2*LQN+5)*EPR/E52
          PSL = 2.0D0*RN(M,2)*GAMHLF(2*LQN+5)*EPR/E52
C
          USS = 0.0D0
          IF(NNUC(IZ).EQ.0) THEN
C           POINT-NUCLEUS APPROXIMATION
            VSA = 2.0D0*GAMHLF(2*LQN+4)*EPR/(EL1*EIJ)
            IF(KQN.LT.0) THEN
              VSN = 0.0D0
            ELSE
              VSN = 0.5D0*GAMHLF(2*LQN  )*TL*EIJ/EL1
            ENDIF
            USS = VSA+VSN
          ELSE
C           NUCLEAR BEST-FIT EXPANSION
            DO IFT=1,NNUC(IZ)
              XI  = XNUC(IZ,IFT)
              FC  = FNUC(IZ,IFT)
              VSA = 4.0D0*EPR*ERFINT0(LQN+1,EIJ,XI)
              IF(KQN.LT.0) THEN
                VSN = 0.0D0
              ELSE
                VSN =-2.0D0*EIJ*TL*ERFINT0(LQN  ,EIJ,XI)
     &                      +TL*TL*ERFINT0(LQN-1,EIJ,XI)
              ENDIF
              USS = USS + FC*(VSA+VSN)
            ENDDO
          ENDIF
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBAS
          LBAS = JBAS+NBAS
C
C         TRANSFER INTO KINETIC AND NUCLEAR ATTRACTION MATRICES
          TMAT(KBAS,JBAS) = CV*PSL
          TMAT(JBAS,KBAS) = CV*PSL
          VMAT(KBAS,LBAS) =-ZNUC(IZ)*RN(M,3)*USS-2.0D0*EMSS*CV*CV*SSS
C
50        CONTINUE
C
        ENDDO
      ENDDO     
C
      RETURN
      END
C
C
      SUBROUTINE KINTC0(TMAT,EXL,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           KK    KK IIII NN    NN TTTTTTTT CCCCCC   000000            C
C           KK   KK   II  NNN   NN    TT   CC    CC 00   000           C
C           KK  KK    II  NNNN  NN    TT   CC       00  0000           C
C           KKKKK     II  NN NN NN    TT   CC       00 00 00           C
C           KK  KK    II  NN  NNNN    TT   CC       0000  00           C
C           KK   KK   II  NN   NNN    TT   CC    CC 000   00           C
C           KK    KK IIII NN    NN    TT    CCCCCC   000000            C
C                                                                      C
C -------------------------------------------------------------------- C
C  KINTC0 CALCULATES THE ATOM-CENTERED KINETIC MATRIX ELEMENTS.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION RN(MBS*MBS,4),TMAT(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M    = M+1
          EJ   = EXL(JBAS)
          EIJ  = EI+EJ
          EPR  = EI*EJ
          T52  = RL+2.5D0
          E52  = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            PLL = RN(M,1)*GAMHLF(2*LQN+5)*EPR/E52
            TMAT(IBAS,JBAS) = PLL
C
          ELSE
C
C           OVERLAPS, KINETIC ELEMENTS AND SS POTENTIAL INTEGRALS
            PSL = 2.0D0*RN(M,2)*GAMHLF(2*LQN+5)*EPR/E52
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBAS
            LBAS = JBAS+NBAS
C
C           TRANSFER INTO KINETIC MATRIX
            TMAT(KBAS,JBAS) = CV*PSL
            TMAT(JBAS,KBAS) = CV*PSL
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE PNTNC0(VMAT,EXL,IZ,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        PPPPPPP  NN    NN TTTTTTTT NN    NN  CCCCCC   000000          C
C        PP    PP NNN   NN    TT    NNN   NN CC    CC 00   000         C
C        PP    PP NNNN  NN    TT    NNNN  NN CC       00  0000         C
C        PP    PP NN NN NN    TT    NN NN NN CC       00 00 00         C
C        PPPPPPP  NN  NNNN    TT    NN  NNNN CC       0000  00         C
C        PP       NN   NNN    TT    NN   NNN CC    CC 000   00         C
C        PP       NN    NN    TT    NN    NN  CCCCCC   000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  PNTNC0 CALCULATES ATOM-CENTRED NUCLEAR ATTRACTION MATRIX ELEMENTS   C
C  FOR A POINT-NUCLEAR CHARGE MODEL.                                   C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION RN(MBS*MBS,4),VMAT(MBD,MBD),EXL(MBS)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      TL = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          EL1 = EIJ**(LQN+1)
          T52 = RL+2.5D0
          E52 = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            ULL = 0.5D0*GAMHLF(2*LQN+2)/EL1
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
C
          ELSE
C
C           RELATIVISTIC CASE
            SSS = 2.0D0*GAMHLF(2*LQN+5)*EPR/E52
            ULL = 0.5D0*GAMHLF(2*LQN+2)/EL1
C
            VSA = 2.0D0*GAMHLF(2*LQN+4)*EPR/(EL1*EIJ)
            IF(KQN.LT.0) THEN
              VSN = 0.0D0
            ELSE
              VSN = 0.5D0*GAMHLF(2*LQN  )*TL*EIJ/EL1
            ENDIF
            USS = VSA+VSN
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBAS
            LBAS = JBAS+NBAS
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
            VMAT(KBAS,LBAS) = -ZNUC(IZ)*RN(M,3)*USS
     &                        -2.0D0*EMSS*CV*CV*RN(M,3)*SSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE UNINC0(VMAT,EXL,IZ,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          UU    UU NN    NN IIII NN    NN  CCCCCC   000000            C
C          UU    UU NNN   NN  II  NNN   NN CC    CC 00   000           C
C          UU    UU NNNN  NN  II  NNNN  NN CC       00  0000           C
C          UU    UU NN NN NN  II  NN NN NN CC       00 00 00           C
C          UU    UU NN  NNNN  II  NN  NNNN CC       0000  00           C
C          UU    UU NN   NNN  II  NN   NNN CC    CC 000   00           C
C           UUUUUU  NN    NN IIII NN    NN  CCCCCC   000000            C
C                                                                      C
C -------------------------------------------------------------------- C
C  UNINC0 CALCULATES ATOM-CENTRED NUCLEAR ATTRACTION MATRIX ELEMENTS   C
C  FOR A UNIFORMLY-CHARGED SPHERICAL NUCLEAR MODEL.                    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION RN(MBS*MBS,4),VMAT(MBD,MBD),EXL(MBS)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      TL = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          E02 = EIJ**(LQN)
          E22 = E02*EIJ
          E42 = E22*EIJ
          E52 = E42*DSQRT(EIJ)
C
          X   = 5.0D0*EIJ*RNUC(IZ)*RNUC(IZ)/3.0D0
          FAC = 2.0D0*DSQRT(X)*X
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            T1  = GAMUPR(2*LQN+2,X)
            T2  = 3.0D0*X*GAMLWR(2*LQN+3,X)-GAMLWR(2*LQN+5,X)
            ULL = T1 + T2/FAC
            ULL = 0.5D0*ULL/E22
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
C
          ELSE
C
C           RELATIVISTIC CASE
            T1  = GAMUPR(2*LQN+2,X)
            T2  = 3.0D0*X*GAMLWR(2*LQN+3,X)-GAMLWR(2*LQN+5,X)
            ULL = T1 + T2/FAC
            ULL = 0.5D0*ULL/E22
C
            SSS = 2.0D0*GAMHLF(2*LQN+5)*EPR/E52
C
            T1  = GAMUPR(2*LQN+4,X)
            T2  = 3.0D0*X*GAMLWR(2*LQN+5,X)-GAMLWR(2*LQN+7,X)
            VS2 = T1 + T2/FAC
            VS2 = 2.0D0*EPR*VS2/E42
C
            IF(KQN.LT.0) THEN
C
              VS0 = 0.0D0
              VS1 = 0.0D0
C
            ELSE
C
              T1  = GAMUPR(2*LQN+2,X)
              T2  = 3.0D0*X*GAMLWR(2*LQN+3,X)-GAMLWR(2*LQN+5,X)
              VS1 = T1 + T2/FAC
              VS1 =-TL*VS1/E02
C
              T1  = GAMUPR(2*LQN  ,X)
              T2  = 3.0D0*X*GAMLWR(2*LQN+1,X)-GAMLWR(2*LQN+3,X)
              VS0 = T1 + T2/FAC
              VS0 = 0.5D0*TL*TL*VS0/E02
C
            ENDIF
            USS = VS0+VS1+VS2
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBAS
            LBAS = JBAS+NBAS
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
            VMAT(KBAS,LBAS) = -ZNUC(IZ)*RN(M,3)*USS
     &                        -2.0D0*EMSS*CV*CV*RN(M,3)*SSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GSSNC0(VMAT,EXL,IZ,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         GGGGGG   SSSSSS   SSSSSS  NN    NN  CCCCCC   000000          C
C        GG    GG SS    SS SS    SS NNN   NN CC    CC 00   000         C
C        GG       SS       SS       NNNN  NN CC       00  0000         C
C        GG        SSSSSS   SSSSSS  NN NN NN CC       00 00 00         C
C        GG   GGG       SS       SS NN  NNNN CC       0000  00         C
C        GG    GG SS    SS SS    SS NN   NNN CC    CC 000   00         C
C         GGGGGG   SSSSSS   SSSSSS  NN    NN  CCCCCC   000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  GSSNC0 CALCULATES ATOM-CENTRED NUCLEAR ATTRACTION MATRIX ELEMENTS   C
C  FOR A GAUSSIAN NUCLEAR CHARGE MODEL.                                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION RN(MBS*MBS,4),VMAT(MBD,MBD),EXL(MBS)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      TL = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     GAUSSIAN WIDTH PARAMETER
      GPRM = 1.5D0/(RNUC(IZ)*RNUC(IZ))
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T52 = RL+2.5D0
          E52 = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            ULL = ERFINT0(LQN  ,EIJ,GPRM)
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
C
          ELSE
C
C           RELATIVISTIC CASE
            SSS = 2.0D0*GAMHLF(2*LQN+5)*EPR/E52
            ULL = ERFINT0(LQN  ,EIJ,GPRM)
            VSA = 4.0D0*EPR*ERFINT0(LQN+1,EIJ,GPRM)
            IF(KQN.LT.0) THEN
              VSN = 0.0D0
            ELSE
              VSN =-2.0D0*EIJ*TL*ERFINT0(LQN  ,EIJ,GPRM)
     &                    +TL*TL*ERFINT0(LQN-1,EIJ,GPRM)
            ENDIF
            USS = VSA+VSN
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBAS
            LBAS = JBAS+NBAS
C
C           TRANSFER INTO ARRAY
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
            VMAT(KBAS,LBAS) = -ZNUC(IZ)*RN(M,3)*USS
     &                        -2.0D0*EMSS*CV*CV*RN(M,3)*SSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GSMNC0(VMAT,EXL,IZ,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG   SSSSSS  MM       MM NN    NN  CCCCCC   000000        C
C       GG    GG SS    SS MMM     MMM NNN   NN CC    CC 00   000       C
C       GG       SS       MMMM   MMMM NNNN  NN CC       00  0000       C
C       GG        SSSSSS  MM MM MM MM NN NN NN CC       00 00 00       C
C       GG   GGG       SS MM  MMM  MM NN  NNNN CC       0000  00       C
C       GG    GG SS    SS MM   M   MM NN   NNN CC    CC 000   00       C
C        GGGGGG   SSSSSS  MM       MM NN    NN  CCCCCC   000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  GSMNC0 CALCULATES ATOM-CENTRED NUCLEAR ATTRACTION MATRIX ELEMENTS   C
C  FOR A BASIS OF GAUSSIAN NUCLEAR CHARGES, FRACTIONALLY DISTRIBUTED.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION RN(MBS*MBS,4),VMAT(MBD,MBD),EXL(MBS)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      TL = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T52 = RL+2.5D0
          E52 = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            ULL = 0.0D0
            DO IFT=1,NNUC(IZ)
              XI  = XNUC(IZ,IFT)
              FC  = FNUC(IZ,IFT)
              ULL = ULL + FC*ERFINT0(LQN  ,EIJ,XI)
            ENDDO
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
C
          ELSE
C
C           RELATIVISTIC CASE
            SSS = 2.0D0*GAMHLF(2*LQN+5)*EPR/E52
C
            ULL = 0.0D0
            DO IFT=1,NNUC(IZ)
              XI  = XNUC(IZ,IFT)
              FC  = FNUC(IZ,IFT)
              ULL = ULL + FC*ERFINT0(LQN  ,EIJ,XI)
            ENDDO

            USS = 0.0D0
            DO IFT=1,NNUC(IZ)
C
              XI  = XNUC(IZ,IFT)
              FC  = FNUC(IZ,IFT)
C
              VSA = 4.0D0*EPR*ERFINT0(LQN+1,EIJ,XI)
              IF(KQN.LT.0) THEN
                VSN = 0.0D0
              ELSE
                VSN =-2.0D0*EIJ*TL*ERFINT0(LQN  ,EIJ,XI)
     &                      +TL*TL*ERFINT0(LQN-1,EIJ,XI)
              ENDIF
C
              USS = USS + FC*(VSA+VSN)
C
            ENDDO
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBAS
            LBAS = JBAS+NBAS
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
            VMAT(KBAS,LBAS) = -ZNUC(IZ)*RN(M,3)*USS
     &                        -2.0D0*EMSS*CV*CV*RN(M,3)*SSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE FMINC0(VMAT,EXL,IZ,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         FFFFFFFF MM       MM IIII NN    NN  CCCCCC   000000          C
C         FF       MMM     MMM  II  NNN   NN CC    CC 00   000         C
C         FF       MMMM   MMMM  II  NNNN  NN CC       00  0000         C
C         FFFFFF   MM MM MM MM  II  NN NN NN CC       00 00 00         C
C         FF       MM  MMM  MM  II  NN  NNNN CC       0000  00         C
C         FF       MM   M   MM  II  NN   NNN CC    CC 000   00         C
C         FF       MM       MM IIII NN    NN  CCCCCC   000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  FMINC0 CALCULATES ATOM-CENTRED NUCLEAR ATTRACTION MATRIX ELEMENTS   C
C  FOR A FERMI NUCLEAR CHARGE MODEL.                                   C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION RN(MBS*MBS,4),VMAT(MBD,MBD),EXL(MBS)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      TL = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     GAUSSIAN WIDTH PARAMETER
      APRM = AFMI(IZ)
      CPRM = 5.0D0*RNUC(IZ)*RNUC(IZ)/3.0D0
     &     - 7.0D0*PI*PI*AFMI(IZ)*AFMI(IZ)/3.0D0
      CPRM = DSQRT(CPRM)
C
C     WARN USER IF FERMI MODEL IS NOT PHYSICAL
      IF(CPRM.LT.APRM) THEN
        WRITE(6, *) 'In FRMINC0: nucleus is too small for this model.'
        WRITE(7, *) 'In FRMINC0: nucleus is too small for this model.'
      ENDIF
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T52 = RL+2.5D0
          E52 = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            ULL = FMIINT0(LQN  ,EIJ,APRM,CPRM)
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
C
          ELSE
C
C           RELATIVISTIC CASE
            ULL = FMIINT0(LQN  ,EIJ,APRM,CPRM)
C
            SSS = 2.0D0*GAMHLF(2*LQN+5)*EPR/E52
C
            VSA = 4.0D0*EPR*FMIINT0(LQN+1,EIJ,APRM,CPRM)
            IF(KQN.LT.0) THEN
              VSN = 0.0D0
            ELSE
              VSN =-2.0D0*EIJ*TL*FMIINT0(LQN  ,EIJ,APRM,CPRM)
     &                    +TL*TL*FMIINT0(LQN-1,EIJ,APRM,CPRM)
            ENDIF
            USS = VSA+VSN
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBAS
            LBAS = JBAS+NBAS
C
C           TRANSFER INTO NUCLEAR ATTRACTION MATRIX
            VMAT(IBAS,JBAS) = -ZNUC(IZ)*RN(M,1)*ULL
            VMAT(KBAS,LBAS) = -ZNUC(IZ)*RN(M,3)*USS
     &                        -2.0D0*EMSS*CV*CV*RN(M,3)*SSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE NCOLP0(OMAT,EXL,IZ,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        NN    NN  CCCCCC   OOOOOO  LL       PPPPPPP   000000          C
C        NNN   NN CC    CC OO    OO LL       PP    PP 00   000         C
C        NNNN  NN CC       OO    OO LL       PP    PP 00  0000         C
C        NN NN NN CC       OO    OO LL       PP    PP 00 00 00         C
C        NN  NNNN CC       OO    OO LL       PPPPPPP  0000  00         C
C        NN   NNN CC    CC OO    OO LL       PP       000   00         C
C        NN    NN  CCCCCC   OOOOOO  LLLLLLLL PP        000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCOLP0 CALCULATES ATOM-CENTRED NUCLEAR OVERLAP MATRIX ELEMENTS FOR  C
C  A GAUSSIAN NUCLEAR CHARGE MODEL.                                    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION RN(MBS*MBS,4),OMAT(MBD,MBD),EXL(MBS)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      TL = DFLOAT(2*LQN+1)
C
C     INITIALISE ARRAY
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          OMAT(IBAS     ,JBAS     ) = 0.0D0
          OMAT(IBAS+NBAS,JBAS+NBAS) = 0.0D0
          OMAT(IBAS+NBAS,JBAS     ) = 0.0D0
          OMAT(IBAS     ,JBAS+NBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T52 = RL+2.5D0
          E52 = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            OLL = 0.0D0
            DO IFT=1,NNUC(IZ)
C
              XI  = XNUC(IZ,IFT)
              FC  = FNUC(IZ,IFT)
C
              XPR = XI*DSQRT(XI)/PI32
              PES = XI+EIJ
              RGN = XPR/(PES*DSQRT(PES))
              XEL = PES**LQN
C
              OLL = OLL + FC*GAMHLF(2*LQN+3)*RGN/XEL
C
            ENDDO
C
C           TRANSFER INTO DIRAC MATRIX
            OMAT(IBAS,JBAS) = 0.5D0*RN(M,1)*OLL
C
          ELSE
C
C           RELATIVISTIC CASE
C
            OLL = 0.0D0
            OSS = 0.0D0
            DO IFT=1,NNUC(IZ)
C
              XI  = XNUC(IZ,IFT)
              FC  = FNUC(IZ,IFT)
C
              XPR = XI*DSQRT(XI)/PI32
              PES = XI+EIJ
              RGN = XPR/(PES*DSQRT(PES))
              XEL = PES**LQN
C
              OLL = OLL + FC*GAMHLF(2*LQN+3)*RGN/XEL
C
              VSA = 4.0D0*EPR*GAMHLF(2*LQN+5)*RGN/(XEL*PES)
              IF(KQN.LT.0) THEN
                VSN = 0.0D0
              ELSE
                VSN = -2.0D0*EIJ*TL*GAMHLF(2*LQN+3)*RGN/XEL
     &                       +TL*TL*GAMHLF(2*LQN+1)*RGN*PES/XEL
              ENDIF
              OSS = OSS + FC*(VSA+VSN)
C
            ENDDO
C
C           TRANSFER INTO NUCLEAR OVERLAP MATRIX
            OMAT(IBAS     ,JBAS     ) = 0.5D0*RN(M,1)*OLL
            OMAT(IBAS+NBAS,JBAS+NBAS) = 0.5D0*RN(M,3)*OSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MOMNT0(RR,EXL,KQN,NBAS,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 000000       C
C      MMM     MMM OO    OO MMM     MMM NNN   NN    TT   00   000      C
C      MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT   00  0000      C
C      MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT   00 00 00      C
C      MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT   0000  00      C
C      MM   M   MM OO    OO MM   M   MM NN   NNN    TT   000   00      C
C      MM       MM  OOOOOO  MM       MM NN    NN    TT    000000       C
C                                                                      C
C -------------------------------------------------------------------- C
C  MOMNT0 CALCULATES RADIAL MATRIX ELEMENTS <r^K>^{TT} FOR INTEGER K.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION RN(MBS*MBS,4),RR(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      RK = DFLOAT(K)
      TL = DFLOAT(2*LQN+1)
C
C     INITIALISE ARRAYS
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          RR(IBAS     ,JBAS     ) = 0.0D0
          RR(IBAS+NBAS,JBAS+NBAS) = 0.0D0
          RR(IBAS+NBAS,JBAS     ) = 0.0D0
          RR(IBAS     ,JBAS+NBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     CONDITIONAL FOR K THAT PRODUCES DIVERGING INTEGRAL
      IF(2*LQN+K.LE.-3) THEN
        RETURN
      ENDIF
C
C     NORMALISATION FACTORS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS)
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
C
C         POWERS AND FACTORS
          TK3 = RL+0.5D0*RK+1.5D0
          TK5 = RL+0.5D0*RK+2.5D0
          EK3 = EIJ**TK3
          EK5 = EIJ**TK5
C
          IF(KQN.LT.0) THEN
            TM1 = 0.0D0
          ELSE
            TM1 =-RK*TL*EIJ*EIJ + 4.0D0*EPR*(RL+0.5D0+0.5D0*RK)*TK3         
          ENDIF
C
C         PRODUCT OF EACH PART
          RLL = 0.5D0*RN(M,1)*GAMHLF(2*LQN+K+3)/EK3
          IF(HMLT.EQ.'NORL') THEN
            RSS = 0.0D0
          ELSEIF(KQN.LT.0) THEN
            RSS = 2.0D0*RN(M,3)*GAMHLF(2*LQN+K+5)*EPR/EK5
          ELSEIF(KQN.GT.0) THEN
            RSS = 0.5D0*RN(M,3)*GAMHLF(2*LQN+K+1)*TM1/EK5
          ENDIF
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBAS
          LBAS = JBAS+NBAS
C
C         MATRIX ELEMENTS
          RR(IBAS,JBAS) = RLL
          IF(HMLT.NE.'NORL') THEN
            RR(IBAS,LBAS) = 0.0D0
            RR(KBAS,JBAS) = 0.0D0
            RR(KBAS,LBAS) = RSS
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE VACPL0(UMAT,EXL,IZ,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         VV    VV    AA     CCCCCC  PPPPPPP  LL       000000          C
C         VV    VV   AAAA   CC    CC PP    PP LL      00   000         C
C         VV    VV  AA  AA  CC       PP    PP LL      00  0000         C
C         VV    VV AA    AA CC       PP    PP LL      00 00 00         C
C          VV  VV  AAAAAAAA CC       PPPPPPP  LL      0000  00         C
C           VVVV   AA    AA CC    CC PP       LL      000   00         C
C            VV    AA    AA  CCCCCC  PP       LLLLLLLL 000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  VACPL0 GENERATES ATOMIC NUCLEAR VACUUM POLARISATION INTERACTION     C
C  MATRIX ELEMENTS FOR KQNA (UEHLING INTERACTION TO FIRST ORDER).      C
C -------------------------------------------------------------------- C
C  ▶ THE `LL' COMPONENT OF THIS CAN BE USED IN THE 'NORL' OPTION BUT   C
C    THE INPUT DECK ASSUMES THAT 'DHFQ' MEANS RELATIVISTIC.            C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION RN(MBS*MBS,4),UMAT(MBD,MBD),EXL(MBS)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      TL = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
C           (HAVE TO SELECT MANUALLY -- CONFLICT IN CARDIN INPUT DECK.)
            ULL = UEHINT0(IZ,LQN  ,EIJ)
            UMAT(IBAS,JBAS) = ZNUC(IZ)*RN(M,1)*ULL
C
          ELSE
C
C           RELATIVISTIC CASE
            ULL = UEHINT0(IZ,LQN  ,EIJ)
C
            VSA = 4.0D0*EPR*UEHINT0(IZ,LQN+1,EIJ)
            IF(KQN.LT.0) THEN
              VSN = 0.0D0
            ELSE
              VSN =-2.0D0*EIJ*TL*UEHINT0(IZ,LQN  ,EIJ)
     &                    +TL*TL*UEHINT0(IZ,LQN-1,EIJ)
            ENDIF
            USS = VSA+VSN
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBAS
            LBAS = JBAS+NBAS
C
C           TRANSFER INTO ARRAY
            UMAT(IBAS,JBAS) = ZNUC(IZ)*RN(M,1)*ULL
            UMAT(IBAS,LBAS) = 0.0D0
            UMAT(KBAS,JBAS) = 0.0D0
            UMAT(KBAS,LBAS) = ZNUC(IZ)*RN(M,3)*USS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE COULM0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        CCCCCC   OOOOOO  UU    UU LL      MM       MM  000000         C
C       CC    CC OO    OO UU    UU LL      MMM     MMM 00   000        C
C       CC       OO    OO UU    UU LL      MMMM   MMMM 00  0000        C
C       CC       OO    OO UU    UU LL      MM MM MM MM 00 00 00        C
C       CC       OO    OO UU    UU LL      MM  MMM  MM 0000  00        C
C       CC    CC OO    OO UU    UU LL      MM   M   MM 000   00        C
C        CCCCCC   OOOOOO   UUUUUU  LLLLLLL MM       MM  000000         C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULM0 CONSTRUCTS THE ATOMIC COULOMB MATRIX FROM RADIAL DIRECT      C
C  AND EXCHANGE INTEGRALS AND A MEAN-FIELD CHARGE DENSITY.             C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION RJLLLL(MB2,4),RJSSSS(MB2,4),RJLLSS(MB2,4),RJSSLL(MB2,4),
     &          RKLLLL(MB2,4),RKSSSS(MB2,4),RKSLSL(MB2,4)
C
      COMMON/ATMC/G11(MBD,MBD),G21(MBD,MBD),G12(MBD,MBD),G22(MBD,MBD)
      COMMON/ATMD/DLL1(MB2),DSL1(MB2),DSS1(MB2),DLS1(MB2),
     &            DLL2(MB2),DSL2(MB2),DSS2(MB2),DLS2(MB2)
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
C
C     INITIALISE COULOMB MATRIX
      DO IBAS=1,MBD
        DO JBAS=1,MBD
          G11(IBAS,JBAS) = 0.0D0
          G21(IBAS,JBAS) = 0.0D0
          G12(IBAS,JBAS) = 0.0D0
          G22(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C1 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+1)
      C3 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+3)
      C5 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+5)
      C7 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+7)
      C9 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+9)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
      V8 = 8.0D0
      VS = 1.6D1
C
      TI = DFLOAT(2*LQNA+1)
      TJ = DFLOAT(2*LQNA+1)
      TK = DFLOAT(2*LQNB+1)
      TL = DFLOAT(2*LQNB+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
C
C     EVALUATE CLOSED-SHELL ELECTRON REPULSION ANGULAR INTEGRALS
      CALL ANGCLM0
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL KLSET0
C
C     ITERATE OVER ALL MATRIX ELEMENTS
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
C
C         GAUSSIAN EXPONENTS FOR THIS PAIR
          EI = EXLA(IBAS)
          EJ = EXLA(JBAS)
C
C         BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
          CALL IJSET0
C
C         GENERATE BATCH OF RADIAL INTEGRALS (J AND K MATRICES)
          CALL RKCLM0(RJLLLL,RJSSSS,RJLLSS,RJSSLL,RKLLLL,RKSSSS,RKSLSL)
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
C           INITIALISE COUNTER
            GLL = 0.0D0
C
C           BUILD THE FOCK MATRIX
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,1)*DLL2(M) - RKLLLL(M,1)*DLL2(M)
            ENDDO
C
C           TRANSFER COUNTER VALUE TO COULOMB MATRIX
            G22(IBAS,JBAS) = GLL
C
          ELSE
C         RELATIVISTIC HAMILTONIAN
C
C           SMALL-COMPONENT MATRIX ADDRESSES
            KBAS = IBAS + NBASA
            LBAS = JBAS + NBASA
C
C    (22)   KQNA < 0 AND KQNB < 0  CONTRIBUTIONS (CANNOT SKIP)
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,1)*DLL2(M) - RKLLLL(M,1)*DLL2(M)
     &                  + RJLLSS(M,1)*DSS2(M)
              GSL = GSL                       - RKSLSL(M,1)*DSL2(M)
              GSS = GSS + RJSSSS(M,1)*DSS2(M) - RKSSSS(M,1)*DSS2(M)
     &                  + RJSSLL(M,1)*DLL2(M)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G22(IBAS,JBAS) = GLL
            G22(KBAS,JBAS) = GSL
            G22(JBAS,KBAS) = GSL
            G22(KBAS,LBAS) = GSS
C
C    (21)   KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNB.EQ.0) GOTO 200
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,2)*DLL1(M) - RKLLLL(M,2)*DLL1(M)
     &                  + RJLLSS(M,2)*DSS1(M)
              GSL = GSL                       - RKSLSL(M,2)*DSL1(M)
              GSS = GSS + RJSSSS(M,2)*DSS1(M) - RKSSSS(M,2)*DSS1(M)
     &                  + RJSSLL(M,2)*DLL1(M)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G21(IBAS,JBAS) = GLL
            G21(KBAS,JBAS) = GSL
            G21(JBAS,KBAS) = GSL
            G21(KBAS,LBAS) = GSS
C
200         CONTINUE
C
C    (12)   KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0) GOTO 300
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,3)*DLL2(M) - RKLLLL(M,3)*DLL2(M)
     &                  + RJLLSS(M,3)*DSS2(M)
              GSL = GSL                       - RKSLSL(M,3)*DSL2(M)
              GSS = GSS + RJSSSS(M,3)*DSS2(M) - RKSSSS(M,3)*DSS2(M)
     &                  + RJSSLL(M,3)*DLL2(M)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G12(IBAS,JBAS) = GLL
            G12(KBAS,JBAS) = GSL
            G12(JBAS,KBAS) = GSL
            G12(KBAS,LBAS) = GSS
C
300         CONTINUE
C
C    (11)   KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 400
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
C           SUM OVER MEAN FIELD CONTRIBUTIONS FOR THIS BASIS PAIR
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,4)*DLL1(M) - RKLLLL(M,4)*DLL1(M)
     &                  + RJLLSS(M,4)*DSS1(M)
              GSL = GSL                       - RKSLSL(M,4)*DSL1(M)
              GSS = GSS + RJSSSS(M,4)*DSS1(M) - RKSSSS(M,4)*DSS1(M)
     &                  + RJSSLL(M,4)*DLL1(M)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G11(IBAS,JBAS) = GLL
            G11(KBAS,JBAS) = GSL
            G11(JBAS,KBAS) = GSL
            G11(KBAS,LBAS) = GSS
C
400         CONTINUE
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RKCLM0(RJLLLL,RJSSSS,RJLLSS,RJSSLL,
     &                                       RKLLLL,RKSSSS,RKSLSL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       RRRRRRR  KK    KK CCCCCC  LL       MM       MM  000000         C
C       RR    RR KK   KK CC    CC LL       MMM     MMM 00   000        C
C       RR    RR KK  KK  CC       LL       MMMM   MMMM 00  0000        C
C       RR    RR KKKKK   CC       LL       MM MM MM MM 00 00 00        C
C       RRRRRRR  KK  KK  CC       LL       MM  MMM  MM 0000  00        C
C       RR    RR KK   KK CC    CC LL       MM   M   MM 000   00        C
C       RR    RR KK    KK CCCCCC  LLLLLLLL MM       MM  000000         C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKCLM0 EVALUATES A DIRECT AND EXCHANGE BATCH OF ELECTRON REPULSION  C
C  INTEGRALS OF ALL COMPONENT LABEL COMBINATIONS L AND S IN THE ATOMIC C
C  SCF PROCEDURE FOR A USER-SPECIFIED HAMILTONIAN.                     C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ RJLLLL(M,N) - DIRECT ERI OVERLAP {LL,LL}                          C
C  ▶ RJSSSS(M,N) - DIRECT ERI OVERLAP {SS,SS}                          C
C  ▶ RJLLSS(M,N) - DIRECT ERI OVERLAP {LL,SS}                          C
C  ▶ RJSSLL(M,N) - DIRECT ERI OVERLAP {SS,LL}                          C
C  ▶ RKLLLL(M,N) - EXCHANGE ERI OVERLAP {LL,LL}                        C
C  ▶ RKSSSS(M,N) - EXCHANGE ERI OVERLAP {SS,SS}                        C
C  ▶ RKSLSL(M,N) - EXCHANGE ERI OVERLAP {SL,SL}                        C
C -------------------------------------------------------------------- C
C  COULOMB MATRIX LIST INDEX:                                          C
C  ▶ N=1 - KQN(A)<0, KQN(B)<0 (TYPICAL LABEL 22)                       C
C  ▶ N=2 - KQN(A)<0, KQN(B)>0 (TYPICAL LABEL 12)                       C
C  ▶ N=3 - KQN(A)>0, KQN(B)<0 (TYPICAL LABEL 21)                       C
C  ▶ N=4 - KQN(A)>0, KQN(B)>0 (TYPICAL LABEL 11)                       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION XJ(MB2,2),XK(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
      DIMENSION BDU(MB2,-MAB:MAB,-MAB:MAB),BDL(MB2,-MAB:MAB,-MAB:MAB)
      DIMENSION BXU(MB2,-MAB:MAB,-MAB:MAB),BXL(MB2,-MAB:MAB,-MAB:MAB)
C
      DIMENSION RTIK0(MBS),RTJL0(MBS),PTIK0(MBS),PTJL0(MBS)
      DIMENSION RJLLLL(MB2,4),RJSSSS(MB2,4),RJLLSS(MB2,4),RJSSLL(MB2,4),
     &          RKLLLL(MB2,4),RKSSSS(MB2,4),RKSLSL(MB2,4)
C
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B0IK/EIK(MB2,-MAB:MAB),IKIND(MB2)
      COMMON/B0JL/EJL(MB2,-MAB:MAB),JLIND(MB2)
      COMMON/B0KL/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
      COMMON/XTNS/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C     LOWEST EXPONENT POWER
      IPOWER = LQNA+LQNB-NUF
C
C     A BLOCK OF BASIS EXPONENT PRODUCTS
      DO KBAS=1,NBASB
        RTIK0(KBAS) = DSQRT(EI+EXLB(KBAS))
        RTJL0(KBAS) = DSQRT(EJ+EXLB(KBAS))
        PTIK0(KBAS) = RTIK0(KBAS)**(-IPOWER)
        PTJL0(KBAS) = RTJL0(KBAS)**(-IPOWER)
      ENDDO
C
C     CALCULATE A FULL SET OF EXPONENT OVERLAPS FOR EXCHANGE
      DO M=1,MAXM
        RTIK  = RTIK0(IKIND(M))
        RTJL  = RTJL0(JLIND(M))
        EIK(M,-NUF) = PTIK0(IKIND(M))
        EJL(M,-NUF) = PTJL0(JLIND(M))
        DO IPOW=-NUF+1,NUF+5
          EIK(M,IPOW) = EIK(M,IPOW-1)/RTIK
          EJL(M,IPOW) = EJL(M,IPOW-1)/RTJL
        ENDDO
      ENDDO
C
C     CALCULATE LIST OF BETA FUNCTION ARGUMENTS, XK(MB2,2) (Z AND Z')
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = EI+EJ+TKL0
        XK(M,1) = (EI+EK(M))/TIJKL
        XK(M,2) = (EJ+EL(M))/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL DIRECT INTEGRALS
      NVALS = 3
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
C
C       TWICE THE ACTUAL FAMILY VALUE
        IAA(1) = 2*LQNA+2*NX-1
        IAA(2) = 2*LQNB+2*NX-1
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = 2*LQNB+2*NY-2
          IBB(2) = 2*LQNA+2*NY-2
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO J=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      =  1.0D0-XROOT(M)
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
            ENDIF
C
C           SORT THE BETA INTEGRAL INTO THE CORRECT ARRAY
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BDU(M,2*NX-1,2*NY-2) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BDL(M,2*NX-1,2*NY-2) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR EXCHANGE TERMS                     C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL EXCHANGE INTEGRALS
      NVALS = (NUF-NUI)/2+3
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
        IAA(1) = LQNA+LQNB+NUI+2*NX-1
        IAA(2) = LQNA+LQNB+NUI+2*NX-1
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = LQNA+LQNB-NUF+2*NY-2
          IBB(2) = LQNA+LQNB-NUF+2*NY-2
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA = (IAA(IBETA)-1)/2
            IB =  IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
              RA = X
              RB = DFLOAT(1-IB)
              RC = 1.0D0+X
              RD = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XK(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO J=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XK(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XK(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XK(M,IBETA)
              ENDDO
C
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XK(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
            ENDIF
C
C           SORT THE BETA INTEGRAL INTO THE UPPER/LOWER ARRAYS
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BXU(M, NUI+2*NX-1,-NUF+2*NY-2) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BXL(M, NUI+2*NX-1,-NUF+2*NY-2) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXM
        DO N=1,4
          RJLLLL(M,N) = 0.0D0
          RJLLSS(M,N) = 0.0D0
          RJSSLL(M,N) = 0.0D0
          RJSSSS(M,N) = 0.0D0
          RKLLLL(M,N) = 0.0D0
          RKSLSL(M,N) = 0.0D0
          RKSSSS(M,N) = 0.0D0
        ENDDO
      ENDDO
C
C     VALUE PREPARATION
      E0000 = 1.0D0
      E1000 = EI
      E0100 = EJ
      E1100 = EI*EJ
C
C     LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1010 = EI*EK(M)
        E1001 = EI*EL(M)
        E0110 = EJ*EK(M)
        E0101 = EJ*EL(M)
        E0011 = EK(M)*EL(M)
        E1110 = EI*EJ*EK(M)
        E1101 = EI*EJ*EL(M)
        E1011 = EI*EK(M)*EL(M)
        E0111 = EJ*EK(M)*EL(M)
        E1111 = EI*EJ*EK(M)*EL(M)
C
C**********************************************************************C
C       DIRECT INTEGRAL MATRICES: RJSSSS, RJLLSS, RJSSLL, RJLLLL       C
C**********************************************************************C
C
        IF(HMLT.EQ.'NORL') THEN
C       NON-RELATIVISTIC HAMILTONIAN
C
          B32 = EIJ(2)*EKL(M,3)*BDL(M,3,2) + EIJ(3)*EKL(M,2)*BDU(M,3,2)
C
          RJLLLL(M,1) = V1*T0000*E0000*C5*B32
C
        ELSE
C       RELATIVISTIC HAMILTONIAN
C
C         TEMPORARY STORAGE OF RAW RJ(1,M) (LTEN=1 BECAUSE NU=0 ONLY)
          B10 = EIJ(0)*EKL(M,1)*BDL(M,1,0) + EIJ(1)*EKL(M,0)*BDU(M,1,0)
          B12 = EIJ(2)*EKL(M,1)*BDL(M,1,2) + EIJ(3)*EKL(M,0)*BDU(M,3,0)
          B14 = EIJ(4)*EKL(M,1)*BDL(M,1,4) + EIJ(5)*EKL(M,0)*BDU(M,5,0)
          B30 = EIJ(0)*EKL(M,3)*BDL(M,3,0) + EIJ(1)*EKL(M,2)*BDU(M,1,2)
          B32 = EIJ(2)*EKL(M,3)*BDL(M,3,2) + EIJ(3)*EKL(M,2)*BDU(M,3,2)
          B34 = EIJ(4)*EKL(M,3)*BDL(M,3,4) + EIJ(5)*EKL(M,2)*BDU(M,5,2)
          B50 = EIJ(0)*EKL(M,5)*BDL(M,5,0) + EIJ(1)*EKL(M,4)*BDU(M,1,4)
          B52 = EIJ(2)*EKL(M,5)*BDL(M,5,2) + EIJ(3)*EKL(M,4)*BDU(M,3,4)
          B54 = EIJ(4)*EKL(M,5)*BDL(M,5,4) + EIJ(5)*EKL(M,4)*BDU(M,5,4)
C
C         FILL RJ ARRAYS FOR THIS LQNA,LQNB BLOCK
C
C         KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
          RJLLLL(M,1) = V1*T0000*E0000*C5*B32
          RJLLSS(M,1) = V4*T0000*E0011*C7*B52
          RJSSLL(M,1) = V4*T0000*E1100*C7*B34
          RJSSSS(M,1) = VS*T0000*E1111*C9*B54
C
C         KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 102
          RJLLLL(M,2) = V1*T0000*E0000*C5*B32
          RJLLSS(M,2) = V4*T0000*E0011*C7*B52
     &                - V2*T0001*E0010*C5*B32 - V2*T0010*E0001*C5*B32
     &                + V1*T0011*E0000*C3*B12
          RJSSLL(M,2) = V4*T0000*E1100*C7*B34
          RJSSSS(M,2) = VS*T0000*E1111*C9*B54
     &                - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B34
     &                + V4*T0011*E1100*C5*B14
102       CONTINUE
C
C         KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 103
          RJLLLL(M,3) = V1*T0000*E0000*C5*B32
          RJLLSS(M,3) = V4*T0000*E0011*C7*B52
          RJSSLL(M,3) = V4*T0000*E1100*C7*B34
     &                - V2*T0100*E1000*C5*B32 - V2*T1000*E0100*C5*B32
     &                + V1*T1100*E0000*C3*B30
          RJSSSS(M,3) = VS*T0000*E1111*C9*B54
     &                - V8*T0100*E1011*C7*B52 - V8*T1000*E0111*C7*B52
     &                + V4*T1100*E0011*C5*B50
103       CONTINUE
C
C         KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 104
          RJLLLL(M,4) = V1*T0000*E0000*C5*B32
          RJLLSS(M,4) = V4*T0000*E0011*C7*B52
     &                - V2*T0001*E0010*C5*B32 - V2*T0010*E0001*C5*B32
     &                + V1*T0011*E0000*C3*B12
          RJSSLL(M,4) = V4*T0000*E1100*C7*B34
     &                - V2*T0100*E1000*C5*B32 - V2*T1000*E0100*C5*B32
     &                + V1*T1100*E0000*C3*B30
          RJSSSS(M,4) = VS*T0000*E1111*C9*B54
     &                - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B34
     &                - V8*T0100*E1011*C7*B52 - V8*T1000*E0111*C7*B52
     &                + V4*T1100*E0011*C5*B50 + V4*T0011*E1100*C5*B14
     &                + V4*T0110*E1001*C5*B32 + V4*T1001*E0110*C5*B32
     &                + V4*T1010*E0101*C5*B32 + V4*T0101*E1010*C5*B32
     &                - V2*T0111*E1000*C3*B12 - V2*T1011*E0100*C3*B12
     &                - V2*T1101*E0010*C3*B30 - V2*T1110*E0001*C3*B30
     &                + V1*T1111*E0000*C1*B10
104       CONTINUE
C
        ENDIF
C
C**********************************************************************C
C       EXCHANGE INTEGRAL MATRICES: RKSSSS, RKSLSL, RKLLLL             C
C**********************************************************************C
C
C       LOOP OVER THE TENSOR ORDERS OF THE COULOMB INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
            B32 = EIK(M,-NU+2)*EJL(M, NU+3)*BXL(M, NU+3,-NU+2)
     &          + EIK(M, NU+3)*EJL(M,-NU+2)*BXU(M, NU+3,-NU+2)
C
            RKLL = V1*T0000*E0000*C5*B32
C
            RKLLLL(M,1) = RKLLLL(M,1) + BK(LTEN,1)*RKLL
C
          ELSE
C         RELATIVISTIC HAMILTONIAN
C
C           TEMPORARY STORAGE OF RAW RK(LTEN,M)
            B10 = EIK(M,-NU  )*EJL(M, NU+1)*BXL(M, NU+1,-NU  )
     &          + EIK(M, NU+1)*EJL(M,-NU  )*BXU(M, NU+1,-NU  )
            B12 = EIK(M,-NU+2)*EJL(M, NU+1)*BXL(M, NU+1,-NU+2)
     &          + EIK(M, NU+3)*EJL(M,-NU  )*BXU(M, NU+3,-NU  )
            B14 = EIK(M,-NU+4)*EJL(M, NU+1)*BXL(M, NU+1,-NU+4)
     &          + EIK(M, NU+5)*EJL(M,-NU  )*BXU(M, NU+5,-NU  )
            B30 = EIK(M,-NU  )*EJL(M, NU+3)*BXL(M, NU+3,-NU  )
     &          + EIK(M, NU+1)*EJL(M,-NU+2)*BXU(M, NU+1,-NU+2)
            B32 = EIK(M,-NU+2)*EJL(M, NU+3)*BXL(M, NU+3,-NU+2)
     &          + EIK(M, NU+3)*EJL(M,-NU+2)*BXU(M, NU+3,-NU+2)
            B34 = EIK(M,-NU+4)*EJL(M, NU+3)*BXL(M, NU+3,-NU+4)
     &          + EIK(M, NU+5)*EJL(M,-NU+2)*BXU(M, NU+5,-NU+2)
            B50 = EIK(M,-NU  )*EJL(M, NU+5)*BXL(M, NU+5,-NU  )
     &          + EIK(M, NU+1)*EJL(M,-NU+4)*BXU(M, NU+1,-NU+4)
            B52 = EIK(M,-NU+2)*EJL(M, NU+5)*BXL(M, NU+5,-NU+2)
     &          + EIK(M, NU+3)*EJL(M,-NU+4)*BXU(M, NU+3,-NU+4)
            B54 = EIK(M,-NU+4)*EJL(M, NU+5)*BXL(M, NU+5,-NU+4)
     &          + EIK(M, NU+5)*EJL(M,-NU+4)*BXU(M, NU+5,-NU+4)
C
C           KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
            RKLL = V1*T0000*E0000*C5*B32
            RKSL = V4*T0000*E1010*C7*B34
            RKSS = VS*T0000*E1111*C9*B54
C
            RKLLLL(M,1) = RKLLLL(M,1) + BK(LTEN,1)*RKLL
            RKSLSL(M,1) = RKSLSL(M,1) + BK(LTEN,1)*RKSL
            RKSSSS(M,1) = RKSSSS(M,1) + BK(LTEN,1)*RKSS
C
C           KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNB.EQ.0) GOTO 202
            RKLL = V1*T0000*E0000*C5*B32
            RKSL = V4*T0000*E1010*C7*B34 - V2*T0010*E1000*C5*B32
            RKSS = VS*T0000*E1111*C9*B54 - V8*T0001*E1110*C7*B34
     &           - V8*T0010*E1101*C7*B52 + V4*T0011*E1100*C5*B32
C
            RKLLLL(M,2) = RKLLLL(M,2) + BK(LTEN,2)*RKLL
            RKSLSL(M,2) = RKSLSL(M,2) + BK(LTEN,2)*RKSL
            RKSSSS(M,2) = RKSSSS(M,2) + BK(LTEN,2)*RKSS
202         CONTINUE
C
C           KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0) GOTO 203
            RKLL = V1*T0000*E0000*C5*B32
            RKSL = V4*T0000*E1010*C7*B34 - V2*T0100*E0010*C5*B32
            RKSS = VS*T0000*E1111*C9*B54 - V8*T0100*E1011*C7*B34
     &           - V8*T1000*E0111*C7*B52 + V4*T1100*E0011*C5*B32
C
            RKLLLL(M,3) = RKLLLL(M,3) + BK(LTEN,3)*RKLL
            RKSLSL(M,3) = RKSLSL(M,3) + BK(LTEN,3)*RKSL
            RKSSSS(M,3) = RKSSSS(M,3) + BK(LTEN,3)*RKSS
203         CONTINUE
C
C           KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 204
            RKLL = V1*T0000*E0000*C5*B32
            RKSL = V4*T0000*E1010*C7*B34 - V2*T1000*E0010*C5*B32
     &           - V2*T0010*E1000*C5*B32 + V1*T1010*E0000*C3*B30
            RKSS = VS*T0000*E1111*C9*B54
     &           - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B52
     &           - V8*T0100*E1011*C7*B34 - V8*T1000*E0111*C7*B52
     &           + V4*T1100*E0011*C5*B32 + V4*T0011*E1100*C5*B32
     &           + V4*T1001*E0110*C5*B32 + V4*T0110*E1001*C5*B32
     &           + V4*T0101*E1010*C5*B14 + V4*T1010*E0101*C5*B50
     &           - V2*T1101*E0010*C3*B12 - V2*T0111*E1000*C3*B12
     &           - V2*T1110*E0001*C3*B30 - V2*T1011*E0100*C3*B30
     &           + V1*T1111*E0000*C1*B10
C
            RKLLLL(M,4) = RKLLLL(M,4) + BK(LTEN,4)*RKLL
            RKSLSL(M,4) = RKSLSL(M,4) + BK(LTEN,4)*RKSL
            RKSSSS(M,4) = RKSSSS(M,4) + BK(LTEN,4)*RKSS
204         CONTINUE
C
          ENDIF
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      IF(HMLT.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          RNLLLL = RNIJ(1)*RNKL(M,1)
          RJLLLL(M,1) = RJLLLL(M,1)*RNLLLL
          RKLLLL(M,1) = RKLLLL(M,1)*RNLLLL
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          RNLLLL = RNIJ(1)*RNKL(M,1)
          RNLLSS = RNIJ(1)*RNKL(M,3)
          RNSLSL = RNIJ(2)*RNKL(M,2)
          RNSSLL = RNIJ(3)*RNKL(M,1)
          RNSSSS = RNIJ(3)*RNKL(M,3)
          DO N=1,4
            RJLLLL(M,N) = RJLLLL(M,N)*RNLLLL
            RJLLSS(M,N) = RJLLSS(M,N)*RNLLSS
            RJSSLL(M,N) = RJSSLL(M,N)*RNSSLL
            RJSSSS(M,N) = RJSSSS(M,N)*RNSSSS
            RKLLLL(M,N) = RKLLLL(M,N)*RNLLLL
            RKSLSL(M,N) = RKSLSL(M,N)*RNSLSL
            RKSSSS(M,N) = RKSSSS(M,N)*RNSSSS
          ENDDO
        ENDDO
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BREIT0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT 000000            C
C           BB    BB RR    RR EE        II     TT   00   000           C
C           BB    BB RR    RR EE        II     TT   00  0000           C
C           BBBBBBB  RR    RR EEEEEE    II     TT   00 00 00           C
C           BB    BB RRRRRRR  EE        II     TT   0000  00           C
C           BB    BB RR    RR EE        II     TT   000   00           C
C           BBBBBBB  RR    RR EEEEEEEE IIII    TT    000000            C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT0 CONSTRUCTS THE ATOMIC BREIT MATRIX FROM RADIAL DIRECT AND    C
C  EXCHANGE INTEGRALS AND A MEAN-FIELD CHARGE DENSITY.                 C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RKLLSS(MB2,4),RKSLLS(MB2,4),RKSSLL(MB2,4),RMSLLS(MB2,4)
C
      COMMON/ATMB/B11(MBD,MBD),B21(MBD,MBD),B12(MBD,MBD),B22(MBD,MBD)
      COMMON/ATMD/DLL1(MB2),DSL1(MB2),DSS1(MB2),DLS1(MB2),
     &            DLL2(MB2),DSL2(MB2),DSS2(MB2),DLS2(MB2)
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
C
C     INITIALISE BREIT MATRIX
      DO IBAS=1,MBD
        DO JBAS=1,MBD
          B11(IBAS,JBAS) = 0.0D0
          B21(IBAS,JBAS) = 0.0D0
          B12(IBAS,JBAS) = 0.0D0
          B22(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C3 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+3)
      C5 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+5)
      C7 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+7)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
C
      TI = DFLOAT(2*LQNA+1)
      TJ = DFLOAT(2*LQNA+1)
      TK = DFLOAT(2*LQNB+1)
      TL = DFLOAT(2*LQNB+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1001 = TI*TL
      T0011 = TK*TL
C
C     EVALUATE CLOSED-SHELL BREIT INTERACTION ANGULAR INTEGRALS
      CALL ANGBRT0
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL KLSET0
C
C     ITERATE OVER ALL MATRIX ELEMENTS
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
C
C         GAUSSIAN EXPONENTS FOR THIS PAIR
          EI = EXLA(IBAS)
          EJ = EXLA(JBAS)
C
C         BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
          CALL IJSET0
C
C         GENERATE BATCH OF RADIAL INTEGRALS (J AND K MATRICES)
          CALL RKBRT0(RKLLSS,RKSLLS,RKSSLL,RMSLLS)
C
C         SMALL-COMPONENT MATRIX ADDRESSES
          KBAS = IBAS + NBASA
          LBAS = JBAS + NBASA
C
C    (22) KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
          
          KAPA2 =-LQNA-1
          KAPB2 =-LQNB-1
          RK2A2 = DFLOAT(2*IABS(KAPA2))
          RK2B2 = DFLOAT(2*IABS(KAPB2))
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,1)*DSS2(M)
            BSL = BSL + RKSLLS(M,1)*DLS2(M) + RMSLLS(M,1)*DLS2(M)
            BSS = BSS + RKSSLL(M,1)*DLL2(M)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B22(IBAS,JBAS) = BLL
          B22(KBAS,JBAS) = BSL
          B22(JBAS,KBAS) = BSL
          B22(KBAS,LBAS) = BSS
C
C    (21) KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 200
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0

          KAPA2 =-LQNA-1
          KAPB1 = LQNB
          RK2A2 = DFLOAT(2*IABS(KAPA2))
          RK2B1 = DFLOAT(2*IABS(KAPB1))
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,2)*DSS1(M)
            BSL = BSL + RKSLLS(M,2)*DLS1(M) + RMSLLS(M,2)*DLS1(M)
            BSS = BSS + RKSSLL(M,2)*DLL1(M)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B21(IBAS,JBAS) = BLL
          B21(KBAS,JBAS) = BSL
          B21(JBAS,KBAS) = BSL
          B21(KBAS,LBAS) = BSS
C
200       CONTINUE
C
C    (12) KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 300
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0

          KAPA1 = LQNA
          KAPB2 =-LQNB-1
          RK2A1 = DFLOAT(2*IABS(KAPA1))
          RK2B2 = DFLOAT(2*IABS(KAPB2))
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,3)*DSS2(M)
            BSL = BSL + RKSLLS(M,3)*DLS2(M) + RMSLLS(M,3)*DLS2(M)
            BSS = BSS + RKSSLL(M,3)*DLL2(M)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B12(IBAS,JBAS) = BLL
          B12(KBAS,JBAS) = BSL
          B12(JBAS,KBAS) = BSL
          B12(KBAS,LBAS) = BSS
C
300       CONTINUE
C
C    (11) KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 400
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0

          KAPA1 = LQNA
          KAPB1 = LQNB
          RK2A1 = DFLOAT(2*IABS(KAPA1))
          RK2B1 = DFLOAT(2*IABS(KAPB1))
C
C         SUM OVER MEAN FIELD CONTRIBUTIONS FOR THIS BASIS PAIR
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,4)*DSS1(M)
            BSL = BSL + RKSLLS(M,4)*DLS1(M) + RMSLLS(M,4)*DLS1(M)
            BSS = BSS + RKSSLL(M,4)*DLL1(M)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B11(IBAS,JBAS) = BLL
          B11(KBAS,JBAS) = BSL
          B11(JBAS,KBAS) = BSL
          B11(KBAS,LBAS) = BSS
C
400       CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RKBRT0(RKLLSS,RKSLLS,RKSSLL,RMSLLS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         RRRRRRR  KK    KK BBBBBBB  RRRRRRR TTTTTTTT 000000           C
C         RR    RR KK   KK  BB    BB RR    RR   TT   00   000          C
C         RR    RR KK  KK   BB    BB RR    RR   TT   00  0000          C
C         RR    RR KKKKK    BBBBBBB  RR    RR   TT   00 00 00          C
C         RRRRRRR  KK  KK   BB    BB RRRRRRR    TT   0000  00          C
C         RR    RR KK   KK  BB    BB RR    RR   TT   000   00          C
C         RR    RR KK    KK BBBBBBB  RR    RR   TT    000000           C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKBRT0 EVALUATES A DIRECT AND EXCHANGE BATCH OF BREIT INTERACTION   C
C  INTEGRALS OF ALL COMPONENT LABEL COMBINATIONS L AND S IN THE ATOMIC C
C  (RELATIVISTIC) SCF PROCEDURE.                                       C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ RKLLSS(M,N) - EXCHANGE BII OVERLAP {LL,SS}                        C
C  ▶ RKSLLS(M,N) - EXCHANGE BII OVERLAP {SL,SL}                        C
C  ▶ RKSSLL(M,N) - EXCHANGE BII OVERLAP {SS,LL}                        C
C  ▶ RMSLLS(M,N) - SEMI-RANGE BII OVERLAP {SL,SL}                      C
C -------------------------------------------------------------------- C
C  BREIT MATRIX LIST INDEX:                                            C
C  ▶ N=1 - KQN(A)<0, KQN(B)<0 (TYPICAL LABEL 22)                       C
C  ▶ N=2 - KQN(A)<0, KQN(B)>0 (TYPICAL LABEL 12)                       C
C  ▶ N=3 - KQN(A)>0, KQN(B)<0 (TYPICAL LABEL 21)                       C
C  ▶ N=4 - KQN(A)>0, KQN(B)>0 (TYPICAL LABEL 11)                       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION XK(MB2,2),IAA(2),IBB(2)
      DIMENSION RTIK0(MBS),RTJL0(MBS),PTIK0(MBS),PTJL0(MBS)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
      DIMENSION BXU(MB2,-MAB:MAB,-MAB:MAB),BXL(MB2,-MAB:MAB,-MAB:MAB)
      DIMENSION RKLLSS(MB2,4),RKSLLS(MB2,4),RKSSLL(MB2,4),RMSLLS(MB2,4)
C
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B0IK/EIK(MB2,-MAB:MAB),IKIND(MB2)
      COMMON/B0JL/EJL(MB2,-MAB:MAB),JLIND(MB2)
      COMMON/B0KL/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
      COMMON/XTNS/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XK(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TKL0  = EK(M)+EL(M)
        TIJKL = TIJ0+TKL0
        XK(M,1) = (EI+EK(M))/TIJKL
        XK(M,2) = (EJ+EL(M))/TIJKL
      ENDDO
C
C     LOWEST EXPONENT POWER
      IPOWER = LQNA+LQNB-NUF
C
C     A BLOCK OF BASIS EXPONENT PRODUCTS
      DO KBAS=1,NBASB
        RTIK0(KBAS) = DSQRT(EI+EXLB(KBAS))
        RTJL0(KBAS) = DSQRT(EJ+EXLB(KBAS))
        PTIK0(KBAS) = RTIK0(KBAS)**(-IPOWER)
        PTJL0(KBAS) = RTJL0(KBAS)**(-IPOWER)
      ENDDO
C
C     CALCULATE A FULL SET OF EXPONENT OVERLAPS FOR EXCHANGE
      DO M=1,MAXM
        RTIK = RTIK0(IKIND(M))
        RTJL = RTJL0(JLIND(M))
        EIK(M,-NUF) = PTIK0(IKIND(M))
        EJL(M,-NUF) = PTJL0(JLIND(M))
        DO IPOW=-NUF+1,NUF+5
          EIK(M,IPOW) = EIK(M,IPOW-1)/RTIK
          EJL(M,IPOW) = EJL(M,IPOW-1)/RTJL
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR EXCHANGE TERMS                     C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL EXCHANGE INTEGRALS
      NVALS = (NUF-NUI)/2+2
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
        IAA(1) = LQNA+LQNB+NUI+2*NX
        IAA(2) = LQNA+LQNB+NUI+2*NX
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = LQNA+LQNB-NUF+2*NY-1
          IBB(2) = LQNA+LQNB-NUF+2*NY-1
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA = (IAA(IBETA)-1)/2
            IB =  IBB(IBETA)   /2
C
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
              RA = X
              RB = DFLOAT(1-IB)
              RC = 1.0D0+X
              RD = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XK(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO J=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XK(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XK(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XK(M,IBETA)
              ENDDO
C
C             CASE A: IA > 1
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XK(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
C             CASE B: IA = 1
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
C             CASE C: IA = 0
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
            ENDIF
C
C           SORT THE BETA INTEGRAL INTO THE UPPER/LOWER ARRAYS
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BXU(M, NUI+2*NX  ,-NUF+2*NY-1) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BXL(M, NUI+2*NX  ,-NUF+2*NY-1) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXM
        DO N=1,4
          RKLLSS(M,N) = 0.0D0
          RKSLLS(M,N) = 0.0D0
          RKSSLL(M,N) = 0.0D0
          RMSLLS(M,N) = 0.0D0
        ENDDO
      ENDDO
C
      E0000 = 1.0D0
      E1000 = EI
      E0100 = EJ
      E1100 = EI*EJ
C
C     LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1001 = EI*EL(M)
        E0011 = EK(M)*EL(M)
C
C**********************************************************************C
C       EXCHANGE INTEGRAL MATRICES: RKLLSS, RKSLLS, RKSSLL             C
C**********************************************************************C
C
C       LOOP OVER THE TENSOR ORDERS OF THE BREIT INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         TEMPORARY STORAGE OF RAW RK(LTEN,M)
          B21 = EIK(M,-NU+1)*EJL(M, NU+2)*BXL(M, NU+2,-NU+1)
     &        + EIK(M, NU+2)*EJL(M,-NU+1)*BXU(M, NU+2,-NU+1)
          B23 = EIK(M,-NU+3)*EJL(M, NU+2)*BXL(M, NU+2,-NU+3)
     &        + EIK(M, NU+4)*EJL(M,-NU+1)*BXU(M, NU+4,-NU+1)
          B41 = EIK(M,-NU+1)*EJL(M, NU+4)*BXL(M, NU+4,-NU+1)
     &        + EIK(M, NU+2)*EJL(M,-NU+3)*BXU(M, NU+2,-NU+3)
          B43 = EIK(M,-NU+3)*EJL(M, NU+4)*BXL(M, NU+4,-NU+3)
     &        + EIK(M, NU+4)*EJL(M,-NU+3)*BXU(M, NU+4,-NU+3)
C
C         FILL RK ARRAYS FOR THIS LQNA,LQNB BLOCK
C
C         KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
          RKLL = V4*T0000*E0011*C7*B43
          RKSL = V4*T0000*E1001*C7*B43
          RKSS = V4*T0000*E1100*C7*B43
C
          RKLLSS(M,1) = RKLLSS(M,1) + ELL(LTEN,1)*RKLL
          RKSLLS(M,1) = RKSLLS(M,1) + ESL(LTEN,1)*RKSL
          RKSSLL(M,1) = RKSSLL(M,1) + ESS(LTEN,1)*RKSS
C
C         KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 202
          RKLL = V4*T0000*E0011*C7*B43 - V2*T0001*E0010*C5*B23
     &         - V2*T0010*E0001*C5*B41 + V1*T0011*E0000*C3*B21
          RKSL = V4*T0000*E1001*C7*B43 - V2*T0001*E1000*C5*B23
          RKSS = V4*T0000*E1100*C7*B43
C
          RKLLSS(M,2) = RKLLSS(M,2) + ELL(LTEN,2)*RKLL
          RKSLLS(M,2) = RKSLLS(M,2) + ESL(LTEN,2)*RKSL
          RKSSLL(M,2) = RKSSLL(M,2) + ESS(LTEN,2)*RKSS
202       CONTINUE
C
C         KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 203
          RKLL = V4*T0000*E0011*C7*B43
          RKSL = V4*T0000*E1001*C7*B43 - V2*T1000*E0001*C5*B41
          RKSS = V4*T0000*E1100*C7*B43 - V2*T0100*E1000*C5*B23
     &         - V2*T1000*E0100*C5*B41 + V1*T1100*E0000*C3*B21
C
          RKLLSS(M,3) = RKLLSS(M,3) + ELL(LTEN,3)*RKLL
          RKSLLS(M,3) = RKSLLS(M,3) + ESL(LTEN,3)*RKSL
          RKSSLL(M,3) = RKSSLL(M,3) + ESS(LTEN,3)*RKSS
203       CONTINUE
C
C         KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 204
          RKLL = V4*T0000*E0011*C7*B43 - V2*T0001*E0010*C5*B23
     &         - V2*T0010*E0001*C5*B41 + V1*T0011*E0000*C3*B21
          RKSL = V4*T0000*E1001*C7*B43 - V2*T1000*E0001*C5*B41
     &         - V2*T0001*E1000*C5*B23 + V1*T1001*E0000*C3*B21
          RKSS = V4*T0000*E1100*C7*B43 - V2*T0100*E1000*C5*B23
     &         - V2*T1000*E0100*C5*B41 + V1*T1100*E0000*C3*B21
C
          RKLLSS(M,4) = RKLLSS(M,4) + ELL(LTEN,4)*RKLL
          RKSLLS(M,4) = RKSLLS(M,4) + ESL(LTEN,4)*RKSL
          RKSSLL(M,4) = RKSSLL(M,4) + ESS(LTEN,4)*RKSS
204       CONTINUE
C
        ENDDO
C
C**********************************************************************C
C       HALF-RANGE EXCHANGE INTEGRAL MATRICES: RMSLLS                  C
C**********************************************************************C
C
C       LOOP OVER THE TENSOR ORDERS OF THE COULOMB INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         TEMPORARY STORAGE OF RAW RM(LTEN,M) FOR RMSLLS
          B21 = EIK(M,-NU+1)*EJL(M, NU+2)*BXL(M, NU+2,-NU+1)
     &        - EIK(M, NU+2)*EJL(M,-NU+1)*BXU(M, NU+2,-NU+1)
          B23 = EIK(M,-NU+3)*EJL(M, NU+2)*BXL(M, NU+2,-NU+3)
     &        - EIK(M, NU+4)*EJL(M,-NU+1)*BXU(M, NU+4,-NU+1)
          B41 = EIK(M,-NU+1)*EJL(M, NU+4)*BXL(M, NU+4,-NU+1)
     &        - EIK(M, NU+2)*EJL(M,-NU+3)*BXU(M, NU+2,-NU+3)
          B43 = EIK(M,-NU+3)*EJL(M, NU+4)*BXL(M, NU+4,-NU+3)
     &        - EIK(M, NU+4)*EJL(M,-NU+3)*BXU(M, NU+4,-NU+3)
C
C         FILL RM ARRAYS FOR THIS LQNA,LQNB BLOCK
C
C         KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
          RMSL = V4*T0000*E1001*C7*B43

          RMSLLS(M,1) = RMSLLS(M,1) + GSL(LTEN,1)*RMSL
C
C         KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 302
          RMSL = V4*T0000*E1001*C7*B43 - V2*T0001*E1000*C5*B23
C
          RMSLLS(M,2) = RMSLLS(M,2) + GSL(LTEN,2)*RMSL
302       CONTINUE
C
C         KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 303
          RMSL = V4*T0000*E1001*C7*B43 - V2*T1000*E0001*C5*B41
C
          RMSLLS(M,3) = RMSLLS(M,3) + GSL(LTEN,3)*RMSL
303       CONTINUE
C
C         KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 304
          RMSL = V4*T0000*E1001*C7*B43 - V2*T1000*E0001*C5*B41
     &         - V2*T0001*E1000*C5*B23 + V1*T1001*E0000*C3*B21
C
          RMSLLS(M,4) = RMSLLS(M,4) + GSL(LTEN,4)*RMSL
304       CONTINUE
C
        ENDDO
C
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      DO M=1,MAXM
        RNLLSS = RNIJ(1)*RNKL(M,3)
        RNSSLL = RNIJ(3)*RNKL(M,1)
        RNSLLS = RNIJ(2)*RNKL(M,4)
        DO N=1,4
          RKLLSS(M,N) = RNLLSS*RKLLSS(M,N)
          RKSSLL(M,N) = RNSSLL*RKSSLL(M,N)
          RKSLLS(M,N) = RNSLLS*RKSLLS(M,N)
          RMSLLS(M,N) = RNSLLS*RMSLLS(M,N)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION ERFINT0(L,EIJ,ZTA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE RRRRRRR  FFFFFFFF IIII NN    NN TTTTTTTT 000000        C
C      EE       RR    RR FF        II  NNN   NN    TT   00   000       C
C      EE       RR    RR FF        II  NNNN  NN    TT   00  0000       C
C      EEEEEE   RR    RR FFFFFF    II  NN NN NN    TT   00 00 00       C
C      EE       RRRRRRR  FF        II  NN  NNNN    TT   0000  00       C
C      EE       RR    RR FF        II  NN   NNN    TT   000   00       C
C      EEEEEEEE RR    RR FF       IIII NN    NN    TT    000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERFINT0 CALCULATES THE VALUE OF AN INTEGRAL OVER A GAUSSIAN WITH    C
C  EXPONENT EIJ, AN ERROR FUNCTION WITH NUCLEAR WIDTH PARAMETER ZTA    C
C  AND AN ODD POLYNOMIAL ORDER, 2L+1. SUPPORTS UP TO RELATIVISTIC L=9. C
C                           ∞                                          C
C          ERFINT(L,λ,ζ) = ∫ r^2L+1 exp(-λ r^2) erf(√ζ r) dr.          C
C                           0                                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
C     ROUTINE ONLY ALLOWS NON-NEGATIVE INTEGER L
      IF(L.LT.0) THEN
        WRITE(6, *) 'In ERFINT0: order L must be positive. L = ',L
        WRITE(7, *) 'In ERFINT0: order L must be positive. L = ',L
        STOP
      ENDIF
C
C     FACTORS NEEDED FOR ALL PARAMETERS L
      X   = EIJ/ZTA
      X5  = X*X*X*X*X
      T0  = ZTA+EIJ
      RAT = ZTA/T0
      TRM = 0.5D0*DSQRT(ZTA)/EIJ/DSQRT(T0)
      DO I=1,L
        TRM = 0.5D0*TRM*RAT/EIJ
      ENDDO
C
      IF(L.EQ.0) THEN
        TRM = TRM
      ELSEIF(L.EQ.1) THEN
        VA  = 2.0D0 + 3.0D0*X
        TRM = TRM*VA
      ELSEIF(L.EQ.2) THEN
        VA  = 8.0D0 + 20.0D0*X + 15.0D0*X*X
        TRM = TRM*VA
      ELSEIF(L.EQ.3) THEN
        VA  = 16.0D0 + 56.0D0*X + 70.0D0*X*X + 35.0D0*X*X*X
        TRM = 3.0D0*TRM*VA
      ELSEIF(L.EQ.4) THEN
        VA  = 128.0D0 + 576.0D0*X + 1008.0D0*X*X + 840.0D0*X*X*X
        VB  = 315.0D0*X*X*X*X
        TRM = 3.0D0*TRM*(VA+VB)
      ELSEIF(L.EQ.5) THEN
        VA  = 256.0D0 + 1408.0D0*X + 3168.0D0*X*X + 3696.0D0*X*X*X
        VB  = 2310.0D0*X*X*X*X + 693.0D0*X*X*X*X*X
        TRM = 15.0D0*TRM*(VA+VB)
      ELSEIF(L.EQ.6) THEN
        VA  = 1024.0D0 + 6656.0D0*X + 18304.0D0*X*X
        VB  = 27456.0D0*X*X*X + 24024.0D0*X*X*X*X
        VC  = 12012.0D0*X5 + 3003.0D0*X5*X
        TRM = 45.0D0*TRM*(VA+VB+VC)
      ELSEIF(L.EQ.7) THEN
        VA  = 2048.0D0 + 15360.0D0*X + 49920.0D0*X*X
        VB  = 91520.0D0*X*X*X+ 102960.0D0*X*X*X*X + 72072.0D0*X5
        VC  = 30030.0D0*X5*X + 6435.0D0*X5*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC)
      ELSEIF(L.EQ.8) THEN
        VA  = 32768.0D0 + 278528.0D0*X + 1044480.0D0*X*X
        VB  = 2263040.0D0*X*X*X + 3111680.0D0*X*X*X*X
        VC  = 2800512.0D0*X5 + 1633632.0D0*X5*X + 583440.0D0*X5*X*X
        VD  = 109395.0D0*X5*X*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(L.EQ.9) THEN
        VA  = 65536.0D0 + 6222592.0D0*X + 2646016.0D0*X*X
        VB  = 6615040.0D0*X*X*X + 10749440.0D0*X*X*X*X
        VC  = 11824384.0D0*X5 + 8868288.0D0*X5*X + 4434144.0D0*X5*X*X
        VD  = 1385670.0D0*X5*X*X*X + 230945.0D0*X5*X*X*X*X
        TRM = 2835.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(L.EQ.10) THEN
        VA  = 262144.0D0 + 2752512.0D0*X + 13074432.0D0*X*X
        VB  = 37044224.0D0*X*X*X + 69457920.0D0*X*X*X*X
        VC  = 90295296.0D0*X5 + 82770688.0D0*X5*X
        VD  = 53209728.0D0*X5*X*X + 23279256.0D0*X5*X*X*X
        VE  = 6466460.0D0*X5*X*X*X*X + 969969.0D0*X5*X5
        TRM = 14175.0D0*TRM*(VA+VB+VC+VD+VE)
      ELSE
        WRITE(6, *) 'In ERFINT0: order L too large. L = ',L
        WRITE(7, *) 'In ERFINT0: order L too large. L = ',L
      ENDIF
C
C     TRANSFER DATA TO ERFINT0
      ERFINT0 = TRM
C
      RETURN
      END
C
C
      FUNCTION FMIINT0(L,EIJ,A,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       FFFFFFFF MM       MM IIII IIII NN    NN TTTTTTTT 000000        C
C       FF       MMM     MMM  II   II  NNN   NN    TT   00   000       C
C       FF       MMMM   MMMM  II   II  NNNN  NN    TT   00  0000       C
C       FFFFFF   MM MM MM MM  II   II  NN NN NN    TT   00 00 00       C
C       FF       MM  MMM  MM  II   II  NN  NNNN    TT   0000  00       C
C       FF       MM   M   MM  II   II  NN   NNN    TT   000   00       C
C       FF       MM       MM IIII IIII NN    NN    TT    000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  FMIINT0 CALCULATES AN AUXILLIARY FERMI POTENTIAL INTEGRAL OVER      C
C  A PAIR OF ATOMIC BASIS FUNCTIONS, WHERE L IS A POSITIVE INTEGER.    C
C                        ∞                                             C
C      FMIINT0(L,λ,ζ) = ∫ r^2L+1 exp(-λ r^2) r*V_fermi(r) dr.          C
C                        0                                             C
C  THIS ROUTINE USES MY OWN RECIPE FOR THE ANNOYING INTEGRAL CLASSES,  C
C  FOR THE FIRST FEW L CASES AND ON THE CONDITION THAT A√λ < 0.05D0.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
      DIMENSION U(0:60),P(24)
C
C     ROUTINE ONLY ALLOWS NON-NEGATIVE INTEGER L
      IF(L.LT.0) THEN
        WRITE(6, *) 'In FMIINT0: invalid parameter L. L = ',L
        WRITE(7, *) 'In FMIINT0: invalid parameter L. L = ',L
        STOP
      ENDIF
C
C     MULTIPLES OF THE FACTOR U
      U(0) = 1.0D0
      DO K=1,60
        U(K) = U(K-1)*A/C
      ENDDO
C
C     SPECIAL VALUES OF THE RIEMANN-ZETA FUNCTION
      P( 4) =-(PI**4)*7.0D0/720.0D0
      P( 6) =-(PI**6)*31.0D0/30240.0D0
      P( 8) =-(PI**8)*127.0D0/12096.0D2
      P(10) =-(PI**10)*73.0D0/684288.0D1
      P(12) =-(PI**12)*1414477.0D0/1307674368.0D3
      P(14) =-(PI**14)*8191.0D0/747242496.0D2
      P(16) =-(PI**16)*16931177.0D0/152437569184.0D4
      P(18) =-(PI**18)*5749691557.0D0/5109094217170944.0D3
      P(20) =-(PI**20)*91546277357.0D0/8028576626982912.0D5
      P(22) =-(PI**22)*3324754717.0D0/28777755182432256.0D4
      P(24) =-(PI**24)*1982765468311237.0D0/16938241367317436694528.0D5
C
C     CORRECT DIMENSIONS ARISE FROM THESE TERMS
      EL1 = 1.0D0/(EIJ**(L+1))
      C2L = C**(2*L+2)
C
C     DIMENSIONLESS GAUSSIAN PARAMETER
      SIGMA = EIJ*C*C
C
C     FERMI NORMALISATION CONSTANT
      FNRM = 1.0D0 + PI*PI*U(2) - 6.0D0*U(3)*POLYLOG(3,-1.0D0/U(1))
      FNRM = 1.0D0/FNRM
C
C     INTEGRAL TYPE: INCOMPLETE GAMMA FUNCTIONS
      FA  = 1.5D0 + PI*PI*U(2)*0.5D0
      FB  =-0.5D0
      FC  = 1.0D0 + PI*PI*U(2)
      Y1A = 0.5D0*GAMLWR(2*L+3,SIGMA)/(DSQRT(SIGMA))
      Y1B = 0.5D0*GAMLWR(2*L+5,SIGMA)/(SIGMA*DSQRT(SIGMA))
      Y1C = 0.5D0*GAMUPR(2*L+2,SIGMA)
      Y1  = FA*Y1A + FB*Y1B + FC*Y1C
C
C     INTEGRAL TYPE: SEMI-INFINITE GAMMA FUNCTIONS
      FD  =-6.0D0*U(3)*POLYLOG(3,-1.0D0/U(1))
      Y2D = 0.5D0*RFACT(L)
      
      Y2  = FD*Y2D
C
C     INTEGRAL TYPE: POLYLOG FUNCTIONS WITH GAUSSIANS AND POLYNOMIALS
C                    (EVALUATION METHOD DEPENDS ON SIGMA PARAMETER)
      Y34 = 0.0D0
C
C     EXPAND THE GAUSSIAN FACTOR IN TAYLOR SERIES AND ASSUME LARGE N/U
      IF(SIGMA.LT.1.0D0) THEN
C
C       MAXIMUM EXPANSION ORDER FOR GAUSSIAN
        KMAX = 20
C
C       INITIALISE BINS FOR GAUSSIAN EXPANSION SERIES     
        PHK = 1.0D0
        SGK = 1.0D0
        FTK = 1.0D0
C
C       TAYLOR EXPANSION OVER THE GAUSSIAN FOR SMALL SIGMA
        DO K=0,KMAX
C
          BIN = U(1)*U(2*L+2*K)*POLYLOG(2*L+2*K+5,-1.0D0/U(1))
          DO J=0,MIN(L+K,10)
C
            PR = 1.0D0/RFACT(2*L+2*K-2*J+1)
            BIN = BIN + 2.0D0*U(2*J)*P(2*J+4)*PR
C
          ENDDO
C             
          Y34 = Y34 + PHK*SGK*DFLOAT(L+K+2)*RFACT(2*L+2*K+1)*BIN/FTK
C
C         UPDATE PHASES, FACTORIALS AND POLYNOMIALS IN K
          PHK =-PHK
          SGK = SGK*SIGMA
          FTK = FTK*DFLOAT(K+1)
C          
        ENDDO
C     
C       INCLUDE MULTIPLICATIVE FACTOR
        Y34 = 6.0D0*U(4)*Y34
C
C     NUMERICAL QUADRATURE (WORKS FOR ANY CASE BUT COMPUTATIONALLY SLOW)
      ELSE
C
C       INTEGRATION GRID DETAILS
        NLIN = 100
        NEXP = 1000
        RMAX = 15.0D0
        ELIN = 1.0D0/DFLOAT(NLIN)
        EEXP = DLOG(RMAX/C)/DFLOAT(NEXP)
C
C       NUMERICALLY INTEGRATE REMAINING TERMS FROM 0 TO C (LINEAR)
        X0C = 0.0D0
        DO N=0,NLIN
          ZN  = ELIN*DFLOAT(N)
          Z1  = ZN**(2*L+1)
          Z2  = DEXP(-SIGMA*ZN*ZN)
          Z3  =-ZN*POLYLOG(2,(ZN-1.0D0)/U(1))
          Z4  = 2.0D0*U(1)*POLYLOG(3,(ZN-1.0D0)/U(1))
          X0C = X0C + EXTINT11(Z1*Z2*(Z3+Z4),N,NLIN)
        ENDDO
        X0C = 15.0D0*U(2)*ELIN*X0C/299376.0D0
C
C       NUMERICALLY INTEGRATE REMAINING TERMS FROM C TO INFINITY (EXP.)
        XCI = 0.0D0
        DO N=0,NEXP
          TN  = EEXP*DFLOAT(N)
          ZN  = DEXP(TN)
          Z1  = ZN**(2*L+2)
          Z2  = DEXP(-SIGMA*ZN*ZN)
          Z3  = ZN*POLYLOG(2,(1.0D0-ZN)/U(1))
          Z4  = 2.0D0*U(1)*POLYLOG(3,(1.0D0-ZN)/U(1))
          XCI = XCI + EXTINT11(Z1*Z2*(Z3+Z4),N,NEXP)
        ENDDO
        XCI = 15.0D0*U(2)*EEXP*XCI/299376.0D0
C        
        Y34 = X0C+XCI
C
      ENDIF
C
C     COMBINE ALL TERMS AND APPLY NORMALISATION FACTOR
      FMIINT0 = FNRM*(EL1*Y1 + EL1*Y2 + C2L*Y34)
C
      RETURN
      END
C
C
      FUNCTION EXTINT2(Y,I,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE XX     XX TTTTTTTT IIII NN    NN TTTTTTTT 222222       C
C      EE        XX   XX     TT     II  NNN   NN    TT   22    22      C
C      EE         XX XX      TT     II  NNNN  NN    TT         22      C
C      EEEEEE      XXX       TT     II  NN NN NN    TT       22        C
C      EE         XX XX      TT     II  NN  NNNN    TT     22          C
C      EE        XX   XX     TT     II  NN   NNN    TT   22            C
C      EEEEEEEE XX     XX    TT    IIII NN    NN    TT   22222222      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EXTINT2 DETERMINES THE VALUE OF THE CONTRIBUTION TO AN INTEGRAL     C
C  BASED ON THE TRAPEZOIDAL RULE.                                      C
C**********************************************************************C
C
C     FUNCTION ONLY ALLOWS I BETWEEN 0 AND N
      IF(I.LT.0.OR.I.GT.N) THEN
        WRITE(6, *) 'In EXTINT2: invalid index I. I = ',I
        WRITE(7, *) 'In EXTINT2: invalid index I. I = ',I
        STOP
      ENDIF
C
C     FOR THIS FORMULA TO APPLY, N MUST BE A MULTIPLE OF 2
      IF(MOD(N,2).NE.0.OR.N.LT.2) THEN
        WRITE(6, *) 'In EXTINT2: invalid discretisation N. N = ',N
        WRITE(7, *) 'In EXTINT2: invalid discretisation N. N = ',N
        STOP
      ENDIF
C
      IF(I.EQ.0.OR.I.EQ.N) THEN
        EXTINT2 = 0.5D0*Y
      ELSE
        EXTINT2 = Y
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION EXTINT11(Y,I,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     EEEEEEEE XX     XX TTTTTTTT IIII NN    NN TTTTTTTT 11   11       C
C     EE        XX   XX     TT     II  NNN   NN    TT   111  111       C
C     EE         XX XX      TT     II  NNNN  NN    TT    11   11       C
C     EEEEEE      XXX       TT     II  NN NN NN    TT    11   11       C
C     EE         XX XX      TT     II  NN  NNNN    TT    11   11       C
C     EE        XX   XX     TT     II  NN   NNN    TT    11   11       C
C     EEEEEEEE XX     XX    TT    IIII NN    NN    TT   1111 1111      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EXTINT11 DETERMINES THE VALUE OF THE CONTRIBUTION TO AN INTEGRAL    C
C  BASED ON THE REPEATED 11-POINT NEWTON-COTES FORMULA, WHERE Y IS     C
C  THE VALUE F(X_I), I IS THE INDEX OF INTEREST, AND THE START AND     C
C  END POINTS OF THE INTEGRAL ARE F(X_0) AND F(X_N) RESPECTIVELY.      C
C  IT IS NUMERICALLY ADVANTAGEOUS TO MULTIPLY BY 5.0D+0/2.99376D+5     C
C  AFTER THE SUM IS CALCULATED.                                        C
C**********************************************************************C
C
C     FUNCTION ONLY ALLOWS I BETWEEN 0 AND N
      IF(I.LT.0.OR.I.GT.N) THEN
        WRITE(6, *) 'In EXTINT11: invalid index I. I = ',I
        WRITE(7, *) 'In EXTINT11: invalid index I. I = ',I
        STOP
      ENDIF
C
C     FOR THIS FORMULA TO APPLY, N MUST BE A MULTIPLE OF 10
      IF(MOD(N,10).NE.0.OR.N.LT.10) THEN
        WRITE(6, *) 'In EXTINT11: invalid discretisation N. N = ',N
        WRITE(7, *) 'In EXTINT11: invalid discretisation N. N = ',N
        STOP
      ENDIF
C
      IF(I.EQ.0.OR.I.EQ.N) THEN
        EXTINT11 = 16067.0D0*Y
      ELSEIF(MOD(I,10).EQ.0) THEN
        EXTINT11 = 32134.0D0*Y
      ELSEIF(MOD(I,10).EQ.1.OR.MOD(I,10).EQ.9) THEN
        EXTINT11 = 106300.0D0*Y
      ELSEIF(MOD(I,10).EQ.2.OR.MOD(I,10).EQ.8) THEN
        EXTINT11 =-48525.0D0*Y
      ELSEIF(MOD(I,10).EQ.3.OR.MOD(I,10).EQ.7) THEN
        EXTINT11 = 272400.0D0*Y
      ELSEIF(MOD(I,10).EQ.4.OR.MOD(I,10).EQ.6) THEN
        EXTINT11 =-260550.0D0*Y
      ELSEIF(MOD(I,10).EQ.5) THEN
        EXTINT11 = 427368.0D0*Y
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION GCF(A,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                       GGGGGG   CCCCCC  FFFFFFFF                      C
C                      GG    GG CC    CC FF                            C
C                      GG       CC       FF                            C
C                      GG       CC       FFFFFF                        C
C                      GG   GGG CC       FF                            C
C                      GG    GG CC    CC FF                            C
C                       GGGGGG   CCCCCC  FF                            C
C                                                                      C
C -------------------------------------------------------------------- C
C  GCF EVALUATES THE CONFLUENT HYPERGEOMETRIC FUNCTION U(1,1+A;X) BY   C
C  CONTINUED FRACTION EXPANSION -- (6.2.7) IN NUMERICAL RECIPES, USING C
C  THE MODIFIED LENZ'S METHOD WITH B0 = 0.0D0.                         C
C  REQUIRE X > 0.0D0, AND CONVERGENCE IS RAPID FOR X > A+1.0D0.        C
C                                                                      C
C                   1      1.(1-A)   2.(2-A)                           C
C  U(1,1+A;X) =  ------- . ------- . ------- ...                       C
C                X+1-A-    X+3-A-    X+5-A-                            C
C                                                                      C
C**********************************************************************C
      DATA DLT,EPS/1.0D-30,1.0D-14/
      DATA ITM/100/
C
C     FUNCTION ONLY ALLOWS PARAMETERS X>0
      IF(X.LT.0.0D0) THEN
        WRITE(6, *) 'In GCF: argument X must be positive. X = ',X
        WRITE(7, *) 'In GCF: argument X must be positive. X = ',X
      ENDIF
C
C     FUNCTION CONVERGES ONLY IF X>A+1
      IF(X.LT.A+1.0D0) THEN
        WRITE(6, *) 'In GCF: use a series expansion for this order.',A,X
        WRITE(7, *) 'In GCF: use a series expansion for this order.',A,X
      ENDIF
C
      DEN = X+1.0D0-A
      SAF = 1.0D0/DLT
      RAT = 1.0D0/DEN
      GCF = RAT
C
C     ITERATE TO CONVERGENCE
      DO I=1,ITM
        
        RNM  =-I*(I-A)
        DEN = DEN + 2.0D0
C
C       UPDATE RAT AND FIX IF RESULT UNDERFLOWS
        RAT = RNM*RAT + DEN
        IF(DABS(RAT).LT.DLT) THEN
          RAT = DLT
        ENDIF
C
C       UPDATE SAF AND FIX IF RESULT UNDERFLOWS
        SAF = DEN + RNM/SAF
        IF(DABS(SAF).LT.DLT) THEN
          SAF = DLT
        ENDIF
C
        RAT = 1.0D0/RAT
        DEL = RAT*SAF
C
C       UPDATE GCF AND CHECK AGREEMENT
        GCF = GCF*DEL
        IF(DABS(DEL-1.0D0).LT.EPS) THEN
          GOTO 10
        ENDIF
        
      ENDDO
C
C     METHOD FAILURE
      WRITE(6, *) 'In GCF: A too large or ITM too small. A = ',A
      WRITE(7, *) 'In GCF: A too large or ITM too small. A = ',A
      STOP
C
C     METHOD SUCCESS
10    CONTINUE
C
      RETURN
      END
C
C
      FUNCTION PHIX(L,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                   PPPPPPP  HH    HH IIII XX     XX                   C
C                   PP    PP HH    HH  II   XX   XX                    C
C                   PP    PP HH    HH  II    XX XX                     C
C                   PP    PP HHHHHHHH  II     XXX                      C
C                   PPPPPPP  HH    HH  II    XX XX                     C
C                   PP       HH    HH  II   XX   XX                    C
C                   PP       HH    HH IIII XX     XX                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  PHIX IS AN AUXILLIARY FUNCTION WHICH EVALUATES AS A POWER SERIES    C
C  OF TRUNCTATED LENGTH N:0->20 THE COMBINATION OF LOWER INCOMPLETE    C
C  GAMMA FUNCTIONS NEEDED FOR ATOMIC UNIFORM NUCLEUS MATRIX ELEMENTS:  C
C                                                                      C
C  Φ(ℓ,x) = [3*x*γ(ℓ+1/2,x)-γ(ℓ+3/2,x)]/8*π*x^(3/2) with ℓ>0 and x>0.  C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     ROUTINE ONLY ALLOWS PARAMETERS L>0
      IF(L.LT.1) THEN
        WRITE(6, *) 'In PHIX: order L must be at least 1. L = ',L
        WRITE(7, *) 'In PHIX: order L must be at least 1. L = ',L
      ENDIF
C
C     PRE-MULTIPLYING FACTOR
      FC1 = X**(L)/PI
C
C     INITIALISE POLYNOMIAL COUNTERS
      PLY = 0.0D0
      PHS = 1.0D0
      XPW = 1.0D0
C
C     LOOP OVER REQUIRED POLYNOMIAL DEGREES (CHOOSE 20)
      DO N=0,20
        RAT = DFLOAT(L+N+2)/DFLOAT((2*L+2*N+1)*(2*L+2*N+3))
        PLY = PLY + PHS*XPW*RAT/RFACT(N)
        XPW = XPW*X
        PHS =-PHS
      ENDDO
C
C     VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
      PHIX = FC1*PLY
C
      RETURN
      END
C
C
      FUNCTION GAMUPR(L,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG     AA    MM       MM UU    UU PPPPPPP  RRRRRRR        C
C       GG    GG   AAAA   MMM     MMM UU    UU PP    PP RR    RR       C
C       GG        AA  AA  MMMM   MMMM UU    UU PP    PP RR    RR       C
C       GG       AA    AA MM MM MM MM UU    UU PP    PP RR    RR       C
C       GG   GGG AAAAAAAA MM  MMM  MM UU    UU PPPPPPP  RRRRRRR        C
C       GG    GG AA    AA MM   M   MM UU    UU PP       RR    RR       C
C        GGGGGG  AA    AA MM       MM  UUUUUU  PP       RR    RR       C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMUPR RETURNS THE UPPER INCOMPLETE GAMMA FUNCTION FOR INTEGER OR   C
C  HALF-INTEGER ARGUMENTS. INPUT L IS TWICE THE ACTUAL ARGUMENT.       C
C  SOLUTIONS ARE FINITE AND ALGEBRAIC -- NO APPROXIMATIONS NEEDED.     C
C  NECESSARY -- AN ALGEBRAIC SOLUTION HAS BEEN DEDUCED.                C
C                                                                      C
C                GAMUPR(ℓ,x) = Γ(ℓ/2,x) with ℓ>0 and x>0.              C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PIM(L)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     ROUTINE ONLY ALLOWS PARAMETERS L>0
      IF(L.LT.1) THEN
        WRITE(6, *) 'In GAMUPR: order L must be at least 1. L = ',L
        WRITE(7, *) 'In GAMUPR: order L must be at least 1. L = ',L
        STOP
      ENDIF
C
C     INTEGER ARGUMENTS L
      IF(MOD(L,2).EQ.0) THEN
C
C       EXPONENTIAL FACTOR
        FC1 = DEXP(-X)
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-2)/2
          POLY = POLY + XPOW*RFACT((L-2)/2)/RFACT(I)
          XPOW = XPOW*X
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMUPR = FC1*POLY
C
      ELSE
C
C       FACTORS REQUIRED FOR ALL ORDERS
        X12 = DSQRT(X)
        FC1 = PI12*(1.0D0-DERF(X12))
        FC2 = DEXP(-X)*X12
C
C       POCHHAMMER SYMBOL
        P32 = 1.0D0
        DO K=0,(L-3)/2
          P32 = P32*(0.5D0+DFLOAT(K))
        ENDDO
C
C       FACTOR FOR EACH POWER TERM
        LST = (L-1)/2
        IF(LST.GT.0) THEN
          PSD = 1.0D0
          DO I=1,LST
            PIM(I) = PSD
            PSD    = 0.5D0*PSD*DFLOAT(L-2*I)
          ENDDO
        ENDIF
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-3)/2
C
          POLY = POLY + XPOW*PIM(LST-I)
          XPOW = XPOW*X
C
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMUPR = P32*FC1 + POLY*FC2
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION GAMLWR(L,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      GGGGGG     AA    MM       MM LL      WW         WW RRRRRRR      C
C     GG    GG   AAAA   MMM     MMM LL      WW         WW RR    RR     C
C     GG        AA  AA  MMMM   MMMM LL      WW         WW RR    RR     C
C     GG       AA    AA MM MM MM MM LL      WW    W    WW RR    RR     C
C     GG   GGG AAAAAAAA MM  MMM  MM LL       WW  WWW  WW  RRRRRRR      C
C     GG    GG AA    AA MM   M   MM LL        WWWW WWWW   RR    RR     C
C      GGGGGG  AA    AA MM       MM LLLLLLLL   WW   WW    RR    RR     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMLWR RETURNS THE LOWER INCOMPLETE GAMMA FUNCTION FOR INTEGER OR   C
C  HALF-INTEGER ARGUMENTS. INPUT L IS TWICE THE ACTUAL ARGUMENT.       C
C  SOLUTIONS ARE FINITE AND ALGEBRAIC -- NO APPROXIMATIONS NEEDED.     C
C                                                                      C
C                GAMLWR(ℓ,x) = γ(ℓ/2,x) with ℓ>0 and x>0.              C
C                                                                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PIM(L)
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     ROUTINE ONLY ALLOWS PARAMETERS L>0
      IF(L.LT.1) THEN
        WRITE(6, *) 'In GAMLWR: order L must be at least 1. L = ',L
        WRITE(7, *) 'In GAMLWR: order L must be at least 1. L = ',L
        STOP
      ENDIF
C
C     INTEGER ARGUMENTS L
      IF(MOD(L,2).EQ.0) THEN
C
C       EXPONENTIAL FACTOR
        FC1 = DEXP(-X)
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-2)/2
          POLY = POLY + XPOW*RFACT((L-2)/2)/RFACT(I)
          XPOW = XPOW*X
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMLWR = RFACT((L-2)/2) - FC1*POLY
C
      ELSE
C
C       FACTORS REQUIRED FOR ALL ORDERS
        X12 = DSQRT(X)
        FC1 = PI12*DERF(X12)
        FC2 = DEXP(-X)*X12
C
C       POCHHAMMER SYMBOL
        P32 = 1.0D0
        DO K=0,(L-3)/2
          P32 = P32*(0.5D0+DFLOAT(K))
        ENDDO
C
C       FACTOR FOR EACH POWER TERM
        LST = (L-1)/2
        IF(LST.GT.0) THEN
          PSD = 1.0D0
          DO I=1,LST
            PIM(I) = PSD
            PSD    = 0.5D0*PSD*DFLOAT(L-2*I)
          ENDDO
        ENDIF
C
C       INITIALISE POLYNOMIAL COUNTERS
        POLY = 0.0D0
        XPOW = 1.0D0
C
C       LOOP OVER REQUIRED POLYNOMIAL DEGREES
        DO I=0,(L-3)/2
C
          POLY = POLY + XPOW*PIM(LST-I)
          XPOW = XPOW*X
C
        ENDDO
C
C       VALUE OF INTEGER-ORDER UPPER INCOMPLETE GAMMA FUNCTION
        GAMLWR = P32*FC1 - POLY*FC2
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION UEHINT0(IZ,L,EIJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       UU    UU EEEEEEEE HH    HH IIII NN    NN TTTTTTTT 000000       C
C       UU    UU EE       HH    HH  II  NNN   NN    TT   00   000      C
C       UU    UU EE       HH    HH  II  NNNN  NN    TT   00  0000      C
C       UU    UU EEEEEE   HHHHHHHH  II  NN NN NN    TT   00 00 00      C
C       UU    UU EE       HH    HH  II  NN  NNNN    TT   0000  00      C
C       UU    UU EE       HH    HH  II  NN   NNN    TT   000   00      C
C        UUUUUU  EEEEEEEE HH    HH IIII NN    NN    TT    000000       C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHINT0 CALCULATES AN AUXILLIARY UEHLING POTENTIAL INTEGRAL OVER A  C
C  PAIR OF ATOMIC BASIS FUNCTIONS, WHERE L IS A NON-NEGATIVE INTEGER.  C
C  THE UEHLING POTENTIALS HAVE ALREADY BEEN CALCULATED NUMERICALLY.    C
C                        ∞                                             C
C     UEHINT0(IZ,L,λ) = ∫ r^2L exp(-λ r^2) r^2*V_uehling(r;IZ) dr.     C
C                        0                                             C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/BQED/RUEH(MCT,3),FUEH(MCT,MFT),XUEH(MCT,MFT),NUEH(MCT)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
C
C     ROUTINE ONLY ALLOWS NON-NEGATIVE INTEGER L
      IF(L.LT.0) THEN
        WRITE(6, *) 'In UEHINT0: invalid parameter L. L = ',L
        WRITE(7, *) 'In UEHINT0: invalid parameter L. L = ',L
        STOP
      ENDIF
C
      UEHINT0 = 0.0D0
      DO IFT=1,NUEH(IZ)
C
        XI  = XUEH(IZ,IFT)
        FC  = FUEH(IZ,IFT)
C
        PES = XI+EIJ
        RGN = 1.0D0/(PES*DSQRT(PES))
        XEL = PES**L
C
        UEHINT0 = UEHINT0 + 0.5D0*FC*GAMHLF(2*L+3)*RGN/XEL
C
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION UEHINT0QUAD(IZ,L,EIJ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       UU    UU EEEEEEEE HH    HH IIII NN    NN TTTTTTTT 000000       C
C       UU    UU EE       HH    HH  II  NNN   NN    TT   00   000      C
C       UU    UU EE       HH    HH  II  NNNN  NN    TT   00  0000      C
C       UU    UU EEEEEE   HHHHHHHH  II  NN NN NN    TT   00 00 00      C
C       UU    UU EE       HH    HH  II  NN  NNNN    TT   0000  00      C
C       UU    UU EE       HH    HH  II  NN   NNN    TT   000   00      C
C        UUUUUU  EEEEEEEE HH    HH IIII NN    NN    TT    000000       C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHINT0 CALCULATES AN AUXILLIARY UEHLING POTENTIAL INTEGRAL OVER A  C
C  PAIR OF ATOMIC BASIS FUNCTIONS, WHERE L IS A NON-NEGATIVE INTEGER.  C
C  THE UEHLING POTENTIALS HAVE ALREADY BEEN CALCULATED NUMERICALLY.    C
C                        ∞                                             C
C      UEHINT0(Z,L,λ) = ∫ r^2L exp(-λ r^2) r^2*V_uehling(r;Z) dr.      C
C                        0                                             C
C -------------------------------------------------------------------- C
C ▶ INTEGRALS CAN ALSO BE CALCULATED BY QUADRATURE IN THIS VERSION.    C
C   TO USE THIS, ENABLE THE LAST CHUNK OF CODE IN 'NUCUEHL'.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/UEHQ/RAD(0:NRAD),VVAC(MCT,0:NRAD),RORI,RMID,RMAX,NLIN,NEXP
C
C     ROUTINE ONLY ALLOWS NON-NEGATIVE INTEGER L
      IF(L.LT.0) THEN
        WRITE(6, *) 'In UEHINT0: invalid parameter L. L = ',L
        WRITE(7, *) 'In UEHINT0: invalid parameter L. L = ',L
        STOP
      ENDIF
C
C     STEP SIZES
      HL = (RMID-RORI)/DFLOAT(NLIN)
      HE = DLOG(RMAX/RMID)/DFLOAT(NEXP)
C
C     UNIFORMLY-SPACED GRID VALUES
      X0M = 0.0D0
      DO N=0,NLIN
        RN  = RAD(N)
        Z1  = RN**(2*L)
        Z2  = DEXP(-EIJ*RN*RN)
        Z3  = VVAC(IZ,N)
        X0M = X0M + EXTINT11(Z1*Z2*Z3,N,NLIN)
      ENDDO
      X0M = 5.0D0*HL*X0M/299376.0D0
C
C     EXPONENTIALLY-SPACED GRID VALUES
      XMI = 0.0D0
      DO N=NLIN,NRAD
        RN  = RAD(N)
        Z1  = RN**(2*L+1)
        Z2  = DEXP(-EIJ*RN*RN)
        Z3  = VVAC(IZ,N)
        XMI = XMI + EXTINT11(Z1*Z2*Z3,N-NLIN,NEXP)
      ENDDO
      XMI = 5.0D0*HE*XMI/299376.0D0
C        
      UEHINT0 = X0M+XMI
C
      RETURN
      END
C
C
      SUBROUTINE ANGCLM0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     AA    NN    NN  GGGGGG   CCCCCC  LL       MM       MM  000000    C
C    AAAA   NNN   NN GG    GG CC    CC LL       MMM     MMM 00   000   C
C   AA  AA  NNNN  NN GG       CC       LL       MMMM   MMMM 00  0000   C
C  AA    AA NN NN NN GG       CC       LL       MM MM MM MM 00 00 00   C
C  AAAAAAAA NN  NNNN GG   GGG CC       LL       MM  MMM  MM 0000  00   C
C  AA    AA NN   NNN GG    GG CC    CC LL       MM   M   MM 000   00   C
C  AA    AA NN    NN  GGGGGG   CCCCCC  LLLLLLLL MM       MM  000000    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGCLM0 EVALUATES THE ANGULAR COEFFICIENTS OF THE COULOMB           C
C  INTERACTIONS FOR CLOSED SHELLS IN THE (L1,L2) MANIFOLD.             C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
      COMMON/XTNS/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
C
C     CALCULATE KQNA AND 2*JQNA VALUES FROM LQNA
      KLA =-LQNA-1
      KRA = LQNA
      JLA = 2*IABS(KLA)-1
      JRA = 2*IABS(KRA)-1
C
C     CALCULATE KQNB AND 2*JQNB VALUES FROM LQNB
      KLB =-LQNB-1
      KRB = LQNB
      JLB = 2*IABS(KLB)-1
      JRB = 2*IABS(KRB)-1
C
C     START AND END PARAMETERS FROM TRIANGLE RULE
      NUI = IABS(LQNA-LQNB)
      NUF = LQNA+LQNB+1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 0
      DO NU=NUI,NUF
C
C       PARITY OF 'LQNA+LQNB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQNA+LQNB+NU,2)
C
        IF(IPARAB.EQ.0) THEN
C       ONLY ANGULAR COEFFICIENTS OF EVEN PARITY ARE NON-ZERO
C
C         SAVE THIS TENSOR ORDER
          LTEN      = LTEN+1
          NUS(LTEN) = NU
C
          IF(HMLT.EQ.'NORL') THEN
            BK(LTEN,1) = 0.5D0*ANGSQLS(LQNA,LQNB,NU)
          ELSE
            BK(LTEN,1) = ANGSQJJ(JLA,JLB,NU)
            BK(LTEN,2) = ANGSQJJ(JLA,JRB,NU)
            BK(LTEN,3) = ANGSQJJ(JRA,JLB,NU)
            BK(LTEN,4) = ANGSQJJ(JRA,JRB,NU)
          ENDIF
        ENDIF
C
      ENDDO
C
C     NUMBER OF SURVIVING TENSOR ORDERS
      NUNUM = LTEN
C
      RETURN
      END
C
C
      SUBROUTINE ANGBRT0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        AA    NN    NN  GGGGGG  BBBBBBB  RRRRRRR TTTTTTTT 000000      C
C       AAAA   NNN   NN GG    GG BB    BB RR    RR   TT   00   000     C
C      AA  AA  NNNN  NN GG       BB    BB RR    RR   TT   00  0000     C
C     AA    AA NN NN NN GG       BBBBBBB  RR    RR   TT   00 00 00     C
C     AAAAAAAA NN  NNNN GG   GGG BB    BB RRRRRRR    TT   0000  00     C
C     AA    AA NN   NNN GG    GG BB    BB RR    RR   TT   000   00     C
C     AA    AA NN    NN  GGGGGG  BBBBBBB  RR    RR   TT    000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGBRT0 EVALUATES ANGULAR COEFFICIENTS OF THE ATOMIC CLOSED SHELL   C
C  BREIT INTERACTION FOR ALL (K1,K2) VALUES IN THE MANIFOLD (L1,L2).   C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ NUNUM - NUMBER OF NU VALUES THAT SATISFY PARITY RESTRICTION RULE. C
C  ▶ NUI - MINIMUM NU VALUE IN THIS MANIFOLD.                          C
C  ▶ NUF - MAXIMUM NU VALUE IN THIS MANIFOLD.                          C
C  ▶ ELL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;LL) TERMS    C
C  ▶ ESS(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SS) TERMS    C
C  ▶ ESL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SL) TERMS    C
C  ▶ GSL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SL) TERMS    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION SCOEFF(4,2)
C
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
      COMMON/XTNS/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
C
C     INITIALISE COEFFICIENT ARRAYS
      DO LTEN=1,MNU
        DO N=1,4
          ELL(LTEN,N) = 0.0D0
          ESS(LTEN,N) = 0.0D0
          ESL(LTEN,N) = 0.0D0
          GSL(LTEN,N) = 0.0D0
        ENDDO
        NUS(LTEN) = 0
      ENDDO
      NUNUM = 0
C
C     SPECIFY ALLOWED NU VALUES (PARITY LQNA+LQNB+NU MUST BE ODD)
      NUNUM = 0
      DO NU=0,IABS(LQNA+LQNB+1)
        IF(NU.GE.0.AND.MOD(LQNA+LQNB+NU,2).EQ.1) THEN
          NUNUM = NUNUM+1
          NUS(NUNUM) = NU
        ENDIF
      ENDDO
C
C     BREIT TENSOR ORDER LIMITS BASED ON PARITY CHECK
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C**********************************************************************C
C     (1) KQNA < 0 AND KQNB < 0   (CANNOT SKIP)                        C
C**********************************************************************C
C
C     KQNA AND KQNB
      KQNA =-LQNA-1
      KQNB =-LQNB-1
C
C     JQNA AND JQNB
      JQNA = 2*IABS(KQNA)-1
      JQNB = 2*IABS(KQNB)-1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       SKIP IF THIS VALUE OF NU EXCEEDS TRIANGLE RULE FOR KQN BLOCK
        IF(NU.GT.(JQNA+JQNB)/2) GOTO 101
C
C       ANGULAR FACTOR FOR THIS (KQNA,KQNB,NU)
        AJJN0 = ANGSQJJ(JQNA,JQNB,NU)
C
C       PARITY OF 'LQNA+LQNB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQNA+LQNB+NU,2)
C
C       CASE 1: ODD-PARITY CONTRIBUTIONS
        IF(IPARAB.EQ.1.AND.NU.NE.0) THEN
C
C         INTERMEDIATE (KQN,NU) COEFFICIENTS
          RCOEFF = DFLOAT((KQNA+KQNB)*(KQNA+KQNB))/DFLOAT(NU*(NU+1))
C
C         THIS CONTRIBUTION BELONGS IN "NU" BIN
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO TENSOR ORDER "NU"
          ELL(LTEN,1) = ELL(LTEN,1) + AJJN0*RCOEFF
          ESS(LTEN,1) = ESS(LTEN,1) + AJJN0*RCOEFF
          ESL(LTEN,1) = ESL(LTEN,1) + AJJN0*RCOEFF
C
        ENDIF
C
C       CASE 2: EVEN-PARITY CONTRIBUTIONS
        IF(IPARAB.EQ.0) THEN
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEFF,KQNA,KQNB,NU)
C
C         FIRST CONTRIBUTION BELONGS IN "NU-1" BIN
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,1) = ELL(LTEN,1) + AJJN0*SCOEFF(1,1)
          ESL(LTEN,1) = ESL(LTEN,1) + AJJN0*SCOEFF(2,1)
          ESS(LTEN,1) = ESS(LTEN,1) + AJJN0*SCOEFF(3,1)
          GSL(LTEN,1) = GSL(LTEN,1) + AJJN0*SCOEFF(4,1)
C
C         INCREASE TENSOR LIST LENGTH IF ENTRIES ARE NON-ZERO
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SECOND CONTRIBUTION BELONGS IN "NU+1" BIN
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,1) = ELL(LTEN,1) + AJJN0*SCOEFF(1,2)
          ESL(LTEN,1) = ESL(LTEN,1) + AJJN0*SCOEFF(2,2)
          ESS(LTEN,1) = ESS(LTEN,1) + AJJN0*SCOEFF(3,2)
          GSL(LTEN,1) = GSL(LTEN,1) + AJJN0*SCOEFF(4,2)
C
        ENDIF
C
101     CONTINUE
C
      ENDDO
C
C**********************************************************************C
C     (2) KQNA < 0 AND KQNB > 0   (SKIP IF POSSIBLE)                   C
C**********************************************************************C
C
      IF(LQNB.EQ.0) GOTO 200
C
C     KQNA AND KQNB
      KQNA =-LQNA-1
      KQNB = LQNB
C
C     JQNA AND JQNB
      JQNA = 2*IABS(KQNA)-1
      JQNB = 2*IABS(KQNB)-1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       SKIP IF THIS VALUE OF NU EXCEEDS TRIANGLE RULE FOR KQN BLOCK
        IF(NU.GT.(JQNA+JQNB)/2) GOTO 201
C
C       ANGULAR FACTOR FOR THIS (KQNA,KQNB,NU)
        AJJN0 = ANGSQJJ(JQNA,JQNB,NU)
C
C       PARITY OF 'LQNA+LQNB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQNA+LQNB+NU,2)
C
C       CASE 1: ODD-PARITY CONTRIBUTIONS
        IF(IPARAB.EQ.1.AND.NU.NE.0) THEN
C
C         INTERMEDIATE (KQN,NU) COEFFICIENTS
          RCOEFF = DFLOAT((KQNA+KQNB)*(KQNA+KQNB))/DFLOAT(NU*(NU+1))
C
C         THIS CONTRIBUTION BELONGS IN "NU" BIN
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO TENSOR ORDER "NU"
          ELL(LTEN,2) = ELL(LTEN,2) + AJJN0*RCOEFF
          ESS(LTEN,2) = ESS(LTEN,2) + AJJN0*RCOEFF
          ESL(LTEN,2) = ESL(LTEN,2) + AJJN0*RCOEFF
C
        ENDIF
C
C       CASE 2: EVEN-PARITY CONTRIBUTIONS
        IF(IPARAB.EQ.0) THEN
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEFF,KQNA,KQNB,NU)
C
C         FIRST CONTRIBUTION BELONGS IN "NU-1" BIN
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,2) = ELL(LTEN,2) + AJJN0*SCOEFF(1,1)
          ESL(LTEN,2) = ESL(LTEN,2) + AJJN0*SCOEFF(2,1)
          ESS(LTEN,2) = ESS(LTEN,2) + AJJN0*SCOEFF(3,1)
          GSL(LTEN,2) = GSL(LTEN,2) + AJJN0*SCOEFF(4,1)
C
C         INCREASE TENSOR LIST LENGTH IF ENTRIES ARE NON-ZERO
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SECOND CONTRIBUTION BELONGS IN "NU+1" BIN
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,2) = ELL(LTEN,2) + AJJN0*SCOEFF(1,2)
          ESL(LTEN,2) = ESL(LTEN,2) + AJJN0*SCOEFF(2,2)
          ESS(LTEN,2) = ESS(LTEN,2) + AJJN0*SCOEFF(3,2)
          GSL(LTEN,2) = GSL(LTEN,2) + AJJN0*SCOEFF(4,2)
C
        ENDIF
C
201     CONTINUE
C
      ENDDO
C
200   CONTINUE
C
C**********************************************************************C
C     (3) KQNA > 0 AND KQNB < 0   (SKIP IF POSSIBLE)                   C
C**********************************************************************C
C
      IF(LQNA.EQ.0) GOTO 300
C
C     KQNA AND KQNB
      KQNA = LQNA
      KQNB =-LQNB-1
C
C     JQNA AND JQNB
      JQNA = 2*IABS(KQNA)-1
      JQNB = 2*IABS(KQNB)-1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       SKIP IF THIS VALUE OF NU EXCEEDS TRIANGLE RULE FOR KQN BLOCK
        IF(NU.GT.(JQNA+JQNB)/2) GOTO 301
C
C       ANGULAR FACTOR FOR THIS (KQNA,KQNB,NU)
        AJJN0 = ANGSQJJ(JQNA,JQNB,NU)
C
C       PARITY OF 'LQNA+LQNB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQNA+LQNB+NU,2)
C
C       CASE 1: ODD-PARITY CONTRIBUTIONS
        IF(IPARAB.EQ.1.AND.NU.NE.0) THEN
C
C         INTERMEDIATE (KQN,NU) COEFFICIENTS
          RCOEFF = DFLOAT((KQNA+KQNB)*(KQNA+KQNB))/DFLOAT(NU*(NU+1))
C
C         THIS CONTRIBUTION BELONGS IN "NU" BIN
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO TENSOR ORDER "NU"
          ELL(LTEN,3) = ELL(LTEN,3) + AJJN0*RCOEFF
          ESS(LTEN,3) = ESS(LTEN,3) + AJJN0*RCOEFF
          ESL(LTEN,3) = ESL(LTEN,3) + AJJN0*RCOEFF
C
        ENDIF
C
C       CASE 2: EVEN-PARITY CONTRIBUTIONS
        IF(IPARAB.EQ.0) THEN
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEFF,KQNA,KQNB,NU)
C
C         FIRST CONTRIBUTION BELONGS IN "NU-1" BIN
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,3) = ELL(LTEN,3) + AJJN0*SCOEFF(1,1)
          ESL(LTEN,3) = ESL(LTEN,3) + AJJN0*SCOEFF(2,1)
          ESS(LTEN,3) = ESS(LTEN,3) + AJJN0*SCOEFF(3,1)
          GSL(LTEN,3) = GSL(LTEN,3) + AJJN0*SCOEFF(4,1)
C
C         INCREASE TENSOR LIST LENGTH IF ENTRIES ARE NON-ZERO
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SECOND CONTRIBUTION BELONGS IN "NU+1" BIN
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,3) = ELL(LTEN,3) + AJJN0*SCOEFF(1,2)
          ESL(LTEN,3) = ESL(LTEN,3) + AJJN0*SCOEFF(2,2)
          ESS(LTEN,3) = ESS(LTEN,3) + AJJN0*SCOEFF(3,2)
          GSL(LTEN,3) = GSL(LTEN,3) + AJJN0*SCOEFF(4,2)
C
        ENDIF
C
301     CONTINUE
C
      ENDDO
C
300   CONTINUE
C
C**********************************************************************C
C     (4) KQNA > 0 AND KQNB > 0   (SKIP IF POSSIBLE)                   C
C**********************************************************************C
C
      IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 400
C
C     KQNA AND KQNB
      KQNA = LQNA
      KQNB = LQNB
C
C     JQNA AND JQNB
      JQNA = 2*IABS(KQNA)-1
      JQNB = 2*IABS(KQNB)-1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       SKIP IF THIS VALUE OF NU EXCEEDS TRIANGLE RULE FOR KQN BLOCK
        IF(NU.GT.(JQNA+JQNB)/2) GOTO 401
C
C       ANGULAR FACTOR FOR THIS (KQNA,KQNB,NU)
        AJJN0 = ANGSQJJ(JQNA,JQNB,NU)
C
C       PARITY OF 'LQNA+LQNB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQNA+LQNB+NU,2)
C
C       CASE 1: ODD-PARITY CONTRIBUTIONS
        IF(IPARAB.EQ.1.AND.NU.NE.0) THEN
C
C         INTERMEDIATE (KQN,NU) COEFFICIENTS
          RCOEFF = DFLOAT((KQNA+KQNB)*(KQNA+KQNB))/DFLOAT(NU*(NU+1))
C
C         THIS CONTRIBUTION BELONGS IN "NU" BIN
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO TENSOR ORDER "NU"
          ELL(LTEN,4) = ELL(LTEN,4) + AJJN0*RCOEFF
          ESS(LTEN,4) = ESS(LTEN,4) + AJJN0*RCOEFF
          ESL(LTEN,4) = ESL(LTEN,4) + AJJN0*RCOEFF
C
        ENDIF
C
C       CASE 2: EVEN-PARITY CONTRIBUTIONS
        IF(IPARAB.EQ.0) THEN
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEFF,KQNA,KQNB,NU)
C
C         FIRST CONTRIBUTION BELONGS IN "NU-1" BIN
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,4) = ELL(LTEN,4) + AJJN0*SCOEFF(1,1)
          ESL(LTEN,4) = ESL(LTEN,4) + AJJN0*SCOEFF(2,1)
          ESS(LTEN,4) = ESS(LTEN,4) + AJJN0*SCOEFF(3,1)
          GSL(LTEN,4) = GSL(LTEN,4) + AJJN0*SCOEFF(4,1)
C
C         INCREASE TENSOR LIST LENGTH IF ENTRIES ARE NON-ZERO
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SECOND CONTRIBUTION BELONGS IN "NU+1" BIN
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,4) = ELL(LTEN,4) + AJJN0*SCOEFF(1,2)
          ESL(LTEN,4) = ESL(LTEN,4) + AJJN0*SCOEFF(2,2)
          ESS(LTEN,4) = ESS(LTEN,4) + AJJN0*SCOEFF(3,2)
          GSL(LTEN,4) = GSL(LTEN,4) + AJJN0*SCOEFF(4,2)
C
        ENDIF
C
401     CONTINUE
C
      ENDDO
C
400   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BRCOEF0(SCOEFF,KQNA,KQNB,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB  RRRRRRR   CCCCCC   OOOOOO  EEEEEEEE FFFFFFFF 000000      C
C    BB    BB RR    RR CC    CC OO    OO EE       FF      00   000     C
C    BB    BB RR    RR CC       OO    OO EE       FF      00  0000     C
C    BBBBBBB  RR    RR CC       OO    OO EEEEEE   FFFFFF  00 00 00     C
C    BB    BB RRRRRRR  CC       OO    OO EE       FF      0000  00     C
C    BB    BB RR    RR CC    CC OO    OO EE       FF      000   00     C
C    BBBBBBB  RR    RR  CCCCCC   OOOOOO  EEEEEEEE FF       000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRCOEF0 EVALUATES THE INTERMEDIATE COEFFICIENTS OF THE BREIT        C
C  INTERACTION FOR CLOSED SHELLS (TABLE 3 OF GRANT AND PYPER 1976).    C
C**********************************************************************C
      DIMENSION SCOEFF(4,2)
C

      RU  = DFLOAT(NU)
      RK  = DFLOAT(KQNB-KQNA)
C
      IF(NU.GT.0) THEN
        RM = RU-1.0D0
        B1 = (RM+2.0D0)/(2.0D0*   (2.0D0*RM+1.0D0))
        C1 =-(RM-1.0D0)/(2.0D0*RU*(2.0D0*RM+1.0D0))
        SCOEFF(1,1) = (RK+RU)*(C1*RK+B1)
        SCOEFF(2,1) = -B1*RU + C1*RK*RK
        SCOEFF(3,1) = (RK-RU)*(C1*RK-B1)
        SCOEFF(4,1) =  RK    *(C1*RU-B1)
      ELSE
        SCOEFF(1,1) = 0.0D0
        SCOEFF(2,1) = 0.0D0
        SCOEFF(3,1) = 0.0D0
        SCOEFF(4,1) = 0.0D0
      ENDIF
      IF(NU+1.GT.1) THEN
        RP = RU+1.0D0
        B2 = (RP-1.0D0)/(2.0D0*   (2.0D0*RP+1.0D0))
        C2 = (RP+2.0D0)/(2.0D0*RP*(2.0D0*RP+1.0D0))
        SCOEFF(1,2) = (RK-RP)*(C2*RK+B2)
        SCOEFF(2,2) =  B2*RP + C2*RK*RK 
        SCOEFF(3,2) = (RK+RP)*(C2*RK-B2)
        SCOEFF(4,2) =  RK    *(C2*RP+B2)
      ELSE
        SCOEFF(1,2) = 0.0D0
        SCOEFF(2,2) = 0.0D0
        SCOEFF(3,2) = 0.0D0
        SCOEFF(4,2) = 0.0D0
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ANGSQLS(L1,L2,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      AA    NN    NN  GGGGGG   SSSSSS    QQQQQQ    LL       SSSSSS    C
C     AAAA   NNN   NN GG    GG SS    SS  QQ    QQ   LL      SS    SS   C
C    AA  AA  NNNN  NN GG       SS       QQ      QQ  LL      SS         C
C   AA    AA NN NN NN GG        SSSSSS  QQ      QQ  LL       SSSSSS    C
C   AAAAAAAA NN  NNNN GG   GGG       SS QQ      QQ  LL            SS   C
C   AA    AA NN   NNN GG    GG SS    SS  QQ    QQ   LL      SS    SS   C
C   AA    AA NN    NN  GGGGGG   SSSSSS    QQQQQQ QQ LLLLLLLL SSSSSS    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGSQLS EVALUATES THE NON-RELATIVISTIC 3-J SYMBOL FOR ATOMIC        C
C  COULOMB ANGULAR COEFFICIENT ROUTINES, TAKEN FROM BRINK AND SATCHLER.C
C  L1,L2, AND K MUST BE EQUAL TO THE ACTUAL (INTEGER) ANGULAR MOMENTA  C
C  OF THE ELECTRON AND PHOTON.                                         C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
C     TRIANGLE INEQUALITY RESTRICTIONS
      IF(K.LT.IABS(L1-L2).OR.K.GT.(L1+L2)) THEN
        ANGSQLS = 0.0D0
        RETURN
      ENDIF
      LLK = L1+L2+K
C
C     PARITY SELECTION RULE
      IF((LLK/2)*2.NE.LLK) THEN
        ANGSQLS = 0.0D0
        RETURN
      ENDIF
C
      RF1 = RFACT(  L1+L2-K   )
      RF2 = RFACT(- L1+L2+K   )
      RF3 = RFACT(  L1-L2+K   )
      RF4 = RFACT(  L1+L2+K +1)
      RF5 = RFACT(( L1+L2+K)/2)
      RF6 = RFACT(( L1+L2-K)/2)
      RF7 = RFACT(( L1-L2+K)/2)
      RF8 = RFACT((-L1+L2+K)/2)
C
      T1 = RF1*RF2*RF3
      T2 = T1/RF4
      T3 = RF6*RF7*RF8
      T4 = RF5/T3
C
      ANGSQLS = T2*T4*T4
C
      RETURN
      END
C
C
      FUNCTION ANGSQJJ(J1,J2,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      AA    NN    NN  GGGGGG   SSSSSS    QQQQQQ       JJJJ     JJJJ   C
C     AAAA   NNN   NN GG    GG SS    SS  QQ    QQ        JJ       JJ   C
C    AA  AA  NNNN  NN GG       SS       QQ      QQ       JJ       JJ   C
C   AA    AA NN NN NN GG        SSSSSS  QQ      QQ       JJ       JJ   C
C   AAAAAAAA NN  NNNN GG   GGG       SS QQ      QQ       JJ       JJ   C
C   AA    AA NN   NNN GG    GG SS    SS  QQ    QQ  JJ    JJ JJ    JJ   C
C   AA    AA NN    NN  GGGGGG   SSSSSS    QQQQQQ QQ JJJJJJ   JJJJJJ    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGSQJJ EVALUATES THE SQUARE OF A 3-J SYMBOL,   /  j   K   j' \^2   C
C  WHERE j = J1/2 AND j' = J2/2, FOR THE           \-1/2  0  1/2 /     C
C  COULOMB/BREIT ANGULAR COEFFICIENT ROUTINES.                         C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(K.LT.IABS((J1-J2)/2).OR.K.GT.(J1+J2)/2) THEN
        ANGSQJJ = 0.0D0
        RETURN
      ELSEIF(J1.LE.0.OR.J2.LE.0) THEN
        ANGSQJJ = 0.0D0
        RETURN
      ENDIF
C
C     VARIABLE WHICH DEPENDS ON PARITY OF ARGUMENTS
      JJK = (J1+J2)/2 + K
      IF((JJK/2)*2.EQ.JJK) THEN
        M = K
      ELSE
        M = K+1
      ENDIF
C
      RN1 = RFACT(( J1+J2)/2 - K)
      RN2 = RFACT((-J1+J2)/2 + K)
      RN3 = RFACT(( J1-J2)/2 + K)
      RN4 = SFACT(( J1+J2)/2 + M)
      RD1 = DFLOAT(J1+1)
      RD2 = DFLOAT(J2+1)
      RD3 = RFACT(( J1+J2)/2 + K + 1)
      RD4 = SFACT(( J1+J2)/2 - M    )
      RD5 = SFACT(( J1-J2)/2 + M - 1)
      RD6 = SFACT((-J1+J2)/2 + M - 1)
      PHS = (-1.0D0)**((J2-(3*J1))/2+M)
C
      RNUM  = RN1*RN2*RN3*(RN4)**2
      RDEN  = RD1*RD2*RD3*(RD4*RD5*RD6)**2
C
      ANGSQJJ = PHS*RNUM/RDEN
C
      RETURN
      END
C
C
      SUBROUTINE IJSET0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           IIII     JJJJ SSSSSS  EEEEEEEE TTTTTTTT 000000             C
C            II       JJ SS    SS EE          TT   00   000            C
C            II       JJ SS       EE          TT   00  0000            C
C            II       JJ  SSSSSS  EEEEEE      TT   00 00 00            C
C            II       JJ       SS EE          TT   0000  00            C
C            II JJ    JJ SS    SS EE          TT   000   00            C
C           IIII JJJJJJ   SSSSSS  EEEEEEEE    TT    000000             C
C                                                                      C
C -------------------------------------------------------------------- C
C  IJSET0 GENERATES BASIS SET INTERMEDIATES FOR IJ-PAIRS TO BE USED    C
C  IN THE CONSTRUCTION OF ATOMIC TWO-ELECTRON INTEGRALS.               C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     NORMALISATION CONSTANTS FOR EXPONENTS EI AND EJ
      RL = DFLOAT(LQNA)
      G1 = TWLG-GAMLOG(2*LQNA+3)
      G2 = TWLG-GAMLOG(2*LQNA+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
C
      ELOG = DLOG(2.0D0*EI)
      RNLI = DEXP(0.5D0*(G1+R1*ELOG))
      RNSI = DEXP(0.5D0*(G2+R2*ELOG))
C
      ELOG = DLOG(2.0D0*EJ)
      RNLJ = DEXP(0.5D0*(G1+R1*ELOG))
      RNSJ = DEXP(0.5D0*(G2+R2*ELOG))
C
C     NORMALISATION PAIRS
      RNIJ(1) = RNLI*RNLJ
      RNIJ(2) = RNSI*RNLJ
      RNIJ(3) = RNSI*RNSJ
      RNIJ(4) = RNLI*RNSJ
C
C     POWERS OF THE EXPONENT SUM
      EIJ0 = EI+EJ
      EIJR = DSQRT(EIJ0)
      EIJA = EIJ0**(-LQNA)
      DO N=0,MAB
        EIJ(N) = EIJA
        EIJA   = EIJA/EIJR
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE KLSET0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         KK    KK LL       SSSSSS  EEEEEEEE TTTTTTTT 000000           C
C         KK   KK  LL      SS    SS EE          TT   00   000          C
C         KK  KK   LL      SS       EE          TT   00  0000          C
C         KKKKK    LL       SSSSSS  EEEEEE      TT   00 00 00          C
C         KK  KK   LL            SS EE          TT   0000  00          C
C         KK   KK  LL      SS    SS EE          TT   000   00          C
C         KK    KK LLLLLLLL SSSSSS  EEEEEEEE    TT    000000           C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLSET0 GENERATES BASIS SET INTERMEDIATES FOR KL-PAIRS TO BE USED    C
C  IN THE CONSTRUCTION OF ATOMIC TWO-ELECTRON INTEGRALS.               C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/B0QN/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/B0IK/EIK(MB2,-MAB:MAB),IKIND(MB2)
      COMMON/B0JL/EJL(MB2,-MAB:MAB),JLIND(MB2)
      COMMON/B0KL/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
C
C     GENERATE INDICES AND EXPONENT COMBINATIONS
      M = 0
      DO KBAS=1,NBASB
        EK0 = EXLB(KBAS)
        DO LBAS=1, NBASB
          M   = M+1
          EL0 = EXLB(LBAS)
          IKIND(M) = KBAS
          JLIND(M) = LBAS
          EK(M)    = EK0
          EL(M)    = EL0
          EKL0     = EK0+EL0
          EKLR     = DSQRT(EKL0)
          EKPW     = EKL0**LQNB
          EKLA     = 1.0D0/EKPW
          DO N=0,MAB
            EKL(M,N) = EKLA
            EKLA     = EKLA/EKLR
          ENDDO
        ENDDO
      ENDDO
C
C     NORMALISATION CONSTANTS
      CALL RNORM0(RNKL,EXLB,NBASB,LQNB)
C
      RETURN
      END
C
C
      SUBROUTINE RNORM0(RN,EXL,NBAS,LQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       RRRRRRR  NN    NN  OOOOOO  RRRRRRR  MM       MM  000000        C
C       RR    RR NNN   NN OO    OO RR    RR MMM     MMM 00   000       C
C       RR    RR NNNN  NN OO    OO RR    RR MMMM   MMMM 00  0000       C
C       RR    RR NN NN NN OO    OO RR    RR MM MM MM MM 00 00 00       C
C       RRRRRRR  NN  NNNN OO    OO RRRRRRR  MM  MMM  MM 0000  00       C
C       RR    RR NN   NNN OO    OO RR    RR MM   M   MM 000   00       C
C       RR    RR NN    NN  OOOOOO  RR    RR MM       MM  000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNORM0 EVALUATES NORMALISATION CONSTANTS OF ALL VARIETIES.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RN(MB2,4),EXL(MBS),RNL(MBS),RNS(MBS)
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      RL = DFLOAT(LQN)
      G1 = TWLG-GAMLOG(2*LQN+3)
      G2 = TWLG-GAMLOG(2*LQN+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO IBAS=1,NBAS
        ELOG      = DLOG(2.0D0*EXL(IBAS))
        RNL(IBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNS(IBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     RN(M,1) ARE THE LL NORMALISATION CONSTANTS
C     RN(M,2) ARE THE SL NORMALISATION CONSTANTS
C     RN(M,3) ARE THE SS NORMALISATION CONSTANTS
C     RN(M,4) ARE THE LS NORMALISATION CONSTANTS
C
      M = 0
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          M = M+1
          RN(M,1) = RNL(IBAS)*RNL(JBAS)
          RN(M,2) = RNS(IBAS)*RNL(JBAS)
          RN(M,3) = RNS(IBAS)*RNS(JBAS)
          RN(M,4) = RNL(IBAS)*RNS(JBAS)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTRE SCF CALCULATIONS.          C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] HFSCF: MAIN ROUTINE FOR MOLECULAR HARTREE-FOCK SCF PROCEDURE.  C
C   [B] OVRLP: CONSTRUCTS THE ONE-ELECTRON OVERLAP MATRIX.             C
C   [C] ONEEL: ONE-ELECTRON MULTI-CENTRE MATRIX OF INTEGRALS.          C
C   [D] VACPL: CONSTRUCTS MULTI-CENTRE VACUUM POLARISATION ELEMENTS.   C
C   [E] COULOMB: CONSTRUCTS ALL MULTI-CENTRE COULOMB SCF ELEMENTS.     C
C   [F] ERI: GENERATES A BLOCK OF ELECTRON REPULSION INTEGRALS.        C
C   [G] CLMMAT: MULTIPLIES BATCH FROM RR BY DENSITIES, ADDS TO GMAT.   C
C   [H] BREIT: MATRIX REP OF MEAN-FIELD BREIT INTERACTION.             C
C   [I] BII: GENERATES A BLOCK OF BREIT INTERACTION INTEGRALS.         C
C   [J] BRTMAT: MULTIPLIES BATCH FROM RR BY DENSITIES, ADDS TO BDSC.   C
C   [K] COUPLE: ESTABLISH OPEN/CLOSED SHELL COUPLING BETWEEN ARRAYS.   C
C   [L] SPARSITY: SEARCHES FOR VANISHING MATRIX ELEMTNS IN A MATRIX.   C
C   [M] NCART: RETURNS THE CARTESIAN INDEX FROM A LOOP INDEX.          C
C   [N] NCNTRS: RETURNS NUMBER OF UNIQUE NUCLEAR CENTRES FROM INPUT.   C
C   [O] ZPROJ: RETURNS A METRIC FOR Z-AXIS DEVIATION OF SOME COORDS.   C
C   [P] KLAB: RETURNS THE CONVENTIONAL DIRAC SYMMETRY TYPE STRING.     C
C   [Q] MLAB: RETURNS THE CONVENTIONAL DIRAC MAGNETIC STATE STRING.    C
C**********************************************************************C
C
C
      SUBROUTINE HFSCF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              HH    HH FFFFFFFF SSSSSS   CCCCCC  FFFFFFFF             C
C              HH    HH FF      SS    SS CC    CC FF                   C
C              HH    HH FF      SS       CC       FF                   C
C              HHHHHHHH FFFFFF   SSSSSS  CC       FFFFFF               C
C              HH    HH FF            SS CC       FF                   C
C              HH    HH FF      SS    SS CC    CC FF                   C
C              HH    HH FF       SSSSSS   CCCCCC  FF                   C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  HFSCF PERFORMS A SINGLE-DETERMINANT ITERATIVE SELF-CONSISTENT FIELD C
C  PROCEDURE OVER THE USER-SPECIFIED HAMILTONIAN.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*11 MS
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION RK(3*MDM),ESAV(0:MIT),DNRM(MIT),WEDN(MIT)
      DIMENSION NMLEV(4),TMLEV(4)
C
      COMPLEX*16 WK(LWK)
      COMPLEX*16 COEF(MDM,MDM),DTMP(MDM,MDM),OTMP(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 DOLD(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DAMP/DOLD
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EWDR,EWXC,EUEH
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(3),SHLV,ILEV
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ALPH,BETA,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TCVT,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C**********************************************************************C
C     SCF CALCULATION CHOICES AND ARRAY INITIALISATION                 C
C**********************************************************************C
C
C     PARAMETERS FOR COMPLETING STAGES
      ENRGLV1 = 1.0D-08
      ENRGLV2 = 5.0D-11
      ENRGTOL = 1.0D-12
      DSTYTOL = 1.0D-10
C
C     TOGGLE FOR ATOMIC COULOMB/BREIT INTEGRAL SPLICING BY RACAH ALGEBRA
      RACAH1 = .TRUE.
C
C     VISSCHER SMALL-COMPONENT DENSITY APPROXIMATION
      VSSCHR = .FALSE.
C
C     3-CENTRE (SS|SS) INTEGRAL SKIPPING
      SSSSI3 = .FALSE.
C
C     4-CENTRE (SS|SS) INTEGRAL SKIPPING
      SSSSI4 = .FALSE.
C
C     MANY-CENTRE GAUNT INTERACTION INSTEAD OF BREIT
      GAUNT2 = .FALSE.
C
C     CONVERGENCE STRATEGY: DIRECT INVERSION OF THE ITERATIVE SUBSPACE
      DIISQC = .TRUE.
C
C     STATIC DAMPING SCHEME
      DAMPFC = .FALSE.
C
C     TWO-ELECTRON SCHWARZ SCREENING
      SCHWRZ = .FALSE.
C
C     TOGGLE FOR R-INTEGRAL BATCH SAVING IN ERI/BII
      RCFILE = EQFILE
C
C     INITIALISE INTEGRAL INCLUSION LEVEL VALUES
      DO N=1,4
        NMLEV(N) = 0
        TMLEV(N) = 0.0D0
      ENDDO
C
C     INITIALISE ARRAYS AND TEMPORARY DENSITY MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          OVLP(I,J) = DCMPLX(0.0D0,0.0D0)
          HNUC(I,J) = DCMPLX(0.0D0,0.0D0)
          HKIN(I,J) = DCMPLX(0.0D0,0.0D0)
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          VUEH(I,J) = DCMPLX(0.0D0,0.0D0)
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          WDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          WXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          FOCK(I,J) = DCMPLX(0.0D0,0.0D0)
          DTMP(I,J) = DENT(I,J)
        ENDDO
      ENDDO
C
C     INITIALISE ENERGY NORM STORAGE
      IF(READIN) THEN
        ESAV(0) = 1.0D0
      ELSE
        ESAV(0) = ETOT
      ENDIF
C
C     STATIC DAMPING COUNTER
      IF(DAMPFC) THEN
        IDMPKEEP = 0
      ENDIF
C
C**********************************************************************C
C     PRELIMINARY STORAGE OF ARRAYS AND TITLES                         C
C**********************************************************************C
C
C     RECORD TIME AT START OF MOLECULAR SCF CALCULATION
      CALL CPU_TIME(TSCF1)
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',23),'MOLECULAR HARTREE-FOCK SCF'
      WRITE(7, *) REPEAT(' ',23),'MOLECULAR HARTREE-FOCK SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     CALCULATE MOLECULAR DENSITY IF ONE EXISTS
      IF(READIN) THEN
        CALL DENSTY
      ENDIF
C
C     REASONS TO SKIP DIRECTLY TO BREIT PERTURBATION ANAYLSIS
      IF(SHAPE.EQ.'ATOMIC'.AND.HMLT.EQ.'DHFP') GOTO 998
C
C     CALCULATE THE FULL SET OF EQ-COEFFICIENTS
      CALL CPU_TIME(T1)
      IF(EQFILE) THEN
        CALL EQSAVE
      ENDIF
      CALL CPU_TIME(T2)
      TEPP = T2-T1
C
C     GENERATE DIAGONAL TWO-ELECTRON INTEGRALS FOR SCREENING LATER
      CALL CPU_TIME(T1)
      IF(SCHWRZ.AND.NOCC.GT.1) THEN
        IF(HMLT.NE.'BARE') THEN
          CALL SELFCLM
          IF(HMLT.NE.'NORL'.AND.HMLT.NE.'DHFR') THEN
            CALL SELFBRT
          ENDIF
        ENDIF
      ENDIF
      CALL CPU_TIME(T2)
      TSCR = TSCR+T2-T1
C
C     PRINT THE FIRST INTEGRAL INCLUSION LEVEL
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      IF(ILEV.EQ.1) THEN
        WRITE(6,40)
        WRITE(7,40)
      ELSEIF(ILEV.EQ.2) THEN
        IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
          WRITE(6,41)
          WRITE(7,41)
        ELSE
          WRITE(6,42)
          WRITE(7,42)
        ENDIF
      ELSEIF(ILEV.EQ.3) THEN
        WRITE(6,43)
        WRITE(7,43)
      ENDIF
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C**********************************************************************C
C     START OF SELF-CONSISTENT FIELD CALCULATIONS                      C
C**********************************************************************C
C
C     LOOP OVER SCF ITERATIONS
      DO ITER=1,MIT
C
C       TIME AT START OF ITERATION
        CALL CPU_TIME(TMIT)
C
C       CALCULATE OVERLAP, KINETIC AND NUCLEAR POTENTIAL ELEMENTS
        CALL CPU_TIME(T1)
        IF(ITER.EQ.1) THEN
          CALL OVRLP
          CALL ONEEL
        ENDIF
        CALL CPU_TIME(T2)
        T1EL = T2-T1
        THMX = THMX+T1EL
C
C       CALCULATE NUCLEAR VACUUM POLARISATION ELEMENTS
        CALL CPU_TIME(T1)
        IF(HMLT.EQ.'DHFQ') THEN
          IF(ITER.EQ.1) THEN
            CALL VACPL
          ENDIF
        ENDIF
        CALL CPU_TIME(T2)
        T1EL = T1EL+T2-T1
        TQMX = TQMX+T2-T1
C
C       RESET TWO-ELECTRON INTEGRAL SCREENING COUNTERS
        DO MCNT=1,5
          DO ITT=1,6
            N2EB(MCNT,ITT) = 0
            N2EI(MCNT,ITT) = 0
            N2ES(MCNT,ITT) = 0
            T2ES(MCNT,ITT) = 0.0D0
          ENDDO
        ENDDO
C
C       GENERATE MEAN-FIELD CLOSED- AND OPEN-SHELL COULOMB MATRIX
        IF(HMLT.NE.'BARE'.AND.NOCC.GT.1) THEN
C
C         CALCULATE MANY-CENTRE COULOMB INTEGRALS (MCMURCHIE-DAVIDSON)
          CALL CPU_TIME(T1)
          CALL COULOMB
cc
c        OPEN(UNIT=8,FILE='plots/difference/full.dat',STATUS='UNKNOWN')
c        REWIND(UNIT=8)
c        DO I=1,NDIM
c          WRITE(8, *) (ABS(GDIR(J,I)),J=1,NDIM)
c        ENDDO
c        CLOSE(UNIT=8)
cc        STOP
C
          CALL CPU_TIME(T2)
          TCL2 = T2-T1
          TC2T = TC2T+TCL2
C
C         SMALL-COMPONENT DENSITIES ON AN ATOMIC CENTRE (VISSCHER)
          CALL CPU_TIME(T1)
C
C          IF(ILEV.GT.1.AND.VSSCHR) THEN
c            CALL VISSCHR


c        OPEN(UNIT=8,FILE='plots/difference/viss.dat',STATUS='UNKNOWN')
c        REWIND(UNIT=8)
c        DO I=1,NDIM
c          WRITE(8, *) (ABS(GDIR(J,I)),J=1,NDIM)
c        ENDDO
c        CLOSE(UNIT=8)
c        STOP
C
C          ENDIF
C
          CALL CPU_TIME(T2)
          TCLV = T2-T1
          TCVT = TCVT+TCLV
C
C
C         ADD ALL ONE-CENTRE COULOMB CONTRIBUTIONS (RACAH ALGEBRA)
          CALL CPU_TIME (T1)
          IF(RACAH1) THEN
            DO IZ=1,NCNT
              CALL COULOMB1(IZ)
            ENDDO
          ENDIF
          CALL CPU_TIME(T2)
          TCL1 = T2-T1
          TC1T = TC1T+TCL1
C
        ELSE
C
          TCL1 = 0.0D0
          TCL2 = 0.0D0
          TC1T = 0.0D0
          TB2T = 0.0D0
C
        ENDIF
C
C       GENERATE MEAN-FIELD BREIT MATRIX
        IF((HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ').AND.NOCC.GT.1) THEN
C
C         CALCULATE MANY-CENTRE BREIT INTEGRALS (MCMURCHIE-DAVIDSON)
          CALL CPU_TIME(T1)
          CALL BREIT
          CALL CPU_TIME(T2)
          TBR2 = T2-T1
          TB2T = TB2T+TBR2
C
C         ADD ALL ONE-CENTRE BREIT CONTRIBUTIONS (RACAH ALGEBRA)
          CALL CPU_TIME (T1)
          IF(RACAH1) THEN
            DO IZ=1,NCNT
              CALL BREIT1(IZ)
            ENDDO
          ENDIF
          CALL CPU_TIME(T2)
          TBR1 = T2-T1
          TB1T = TB1T+TBR1
C
        ELSE
C
          TBR2 = 0.0D0
          TB2T = 0.0D0
          TBR1 = 0.0D0
          TB1T = 0.0D0
C
        ENDIF
C
C       ADD TWO- AND MANY-CENTRE BINS TO (TT|TT) TOTALS
        DO MCNT=1,4
          DO ITT=1,5
            N2EB(5,ITT) = N2EB(5,ITT) + N2EB(MCNT,ITT)
            N2EI(5,ITT) = N2EI(5,ITT) + N2EI(MCNT,ITT)
            N2ES(5,ITT) = N2ES(5,ITT) + N2ES(MCNT,ITT)
            T2ES(5,ITT) = T2ES(5,ITT) + T2ES(MCNT,ITT)
          ENDDO
        ENDDO
C
C       ADD ALL (TT|TT) RESULTS TO TOTALS
        DO MCNT=1,5
          DO ITT=1,5
            N2EB(MCNT,6) = N2EB(MCNT,6) + N2EB(MCNT,ITT)
            N2EI(MCNT,6) = N2EI(MCNT,6) + N2EI(MCNT,ITT)
            N2ES(MCNT,6) = N2ES(MCNT,6) + N2ES(MCNT,ITT)
            T2ES(MCNT,6) = T2ES(MCNT,6) + T2ES(MCNT,ITT)
          ENDDO
        ENDDO
C
C       FRACTION OF BLOCKS SCREENED
        DO MCNT=1,5
          DO ITT=1,6
            IF(N2EI(MCNT,ITT).NE.0) THEN
              RATIO = DFLOAT(N2ES(MCNT,ITT))/DFLOAT(N2EI(MCNT,ITT))
              F2ES(MCNT,ITT) = 100.0D0*RATIO
            ELSE
              F2ES(MCNT,ITT) = 0.0D0
            ENDIF
          ENDDO
        ENDDO
C
C       START TIMER ON MATRIX ARITHMETIC ROUTINES
        CALL CPU_TIME(T1)
C
C       ESTABLISH COUPLING BETWEEN CLOSED- AND OPEN-SHELL MATRIX REPS
        IF(HMLT.NE.'BARE') THEN
          IF(NOCC.GT.1.AND.NOPN.NE.0) THEN
            CALL COUPLE
          ENDIF
        ENDIF
C
C       CONSTRUCT FOCK MATRIX FROM ONE- AND TWO-BODY INTERACTIONS
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = HNUC(I,J) + HKIN(I,J) + GDIR(I,J) - GXCH(I,J)
     &                + BDIR(I,J) - BXCH(I,J) + VUEH(I,J) + CPLE(I,J)
     &                - QDIR(I,J) + QXCH(I,J) - WDIR(I,J) + WXCH(I,J)
          ENDDO
        ENDDO
C
C       IMPLEMENT SPARSITY CHECK ON FOCK MATRIX
        CALL SPARSITY(FOCK,NDIM,1.0D-10)
C
C       LEVEL-SHIFT THE VIRTUAL SPACE TO MAKE ORBITALS LESS ACCESSIBLE
        IF(READIN.OR.ITER.NE.1) THEN
          CALL LEVSHFT(SHLV)
        ENDIF
        NMLEV(ILEV) = NMLEV(ILEV)+1
C
C       DIRECT INVERSION OF ITERATIVE SUBSPACE UPDATE
        IF(DIISQC) THEN
          CALL DIIS(NMLEV(ILEV))
        ENDIF
C
C       UPDATE MOLECULAR ENERGIES (BASED ON *PREVIOUS* DENSITY D^{N-1})
        CALL ENRGIES
C
C       SAVE OVERLAP MATRIX IN TEMPORARY MATRIX (ZHEGV OVERWRITES IT)
        DO I=1,NDIM
          DO J=1,NDIM
            OTMP(I,J) = OVLP(I,J)
          ENDDO
        ENDDO
C
C       DIAGONALISE FOCK MATRIX (REQUIRES LAPACK LIBRARY)
        CALL ZHEGV(1,'V','L',NDIM,FOCK,MDM,OTMP,MDM,EIGN,WK,LWK,RK,INF)
        IF(INF.NE.0) THEN
          WRITE(6, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INF
          WRITE(7, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INF
        ENDIF
C
C       TRANSFER EIGENVECTORS TO THE C ARRAY
        DO J=1,NDIM
          DO I=1,NDIM
            COEF(I,J) = FOCK(I,J)
          ENDDO
        ENDDO
C
C       DEDUCT LEVEL SHIFT VALUE FROM VIRTUAL ORBITAL EIGENVALUES
        IF(ITER.NE.1) THEN
          DO IVIR=NSKP+NOCC+1,NDIM
            EIGN(IVIR) = EIGN(IVIR)-SHLV
          ENDDO
        ENDIF
C
C       WRITE EIGENVECTORS TO OUTPUT FILE
        OPEN(UNIT=8,FILE=TRIM(WFNFL),STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          WRITE(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
C
C       MATRIX ARITHMETIC ROUTINES
        CALL CPU_TIME(T2)
        TDGN = T2-T1
        TEIG = TEIG+TDGN
C
C       WEIGHTED ENERGY DIFFERENCE NORM, WEDN
        DOFF = DABS(ETOT)+1.0D0
        WEDN(ITER) = DABS(ESAV(ITER-1)-ETOT)/DOFF
        ESAV(ITER) = ETOT
C
C       UPDATE THE DENSITY MATRIX
        CALL DENSTY
C
C       DENSITY DAMPING PARAMETERS
        EFRC = 0.7D0
        PDMP = 0.5D0
C
C       RATIO OF WEIGHTED ENERGY DIFFERENCES
        WEDR = WEDN(ITER)/WEDN(ITER-1)
C
C       REASONS TO ENTER INTO STATIC DAMPING PROCEDURE
        IF(DAMPFC) THEN
C
          IF(NMLEV(ILEV).GT.3.AND.WEDR.GT.EFRC) then
c          IF(IDMPKEEP.EQ.1) THEN
c          IF(NMLEV(ILEV).GT.3.AND.WEDR.GT.EFRC) IDMPKEEP = 1
c          IF(IDMPKEEP.EQ.1) THEN
C
C           ALERT THE USER
            WRITE(*,*) 'ENTERING STATIC DAMPING PHASE'
C
C           TRANSFORM DENSITY MATRIX INTO LINEAR ADMIXTURE
            DO I=1,NDIM
              DO J=1,NDIM
                DENT(I,J) = (1.0D0-PDMP)*DENT(I,J) + PDMP*DTMP(I,J)
              ENDDO
            ENDDO
C
          ENDIF
        ENDIF
C
C       DENSITY DIFFERENCE NORM CALCULATION
        DNRM(ITER) = 0.0D0
        DO J=1,NDIM
          DO I=1,NDIM
            TMP        = ABS(DENT(I,J)-DTMP(I,J))
            DNRM(ITER) = DNRM(ITER)+TMP*TMP
            DTMP(I,J)  = DENT(I,J)
          ENDDO
        ENDDO
        RDM2 = DFLOAT(NDIM*NDIM)
        DNRM(ITER) = DSQRT(DNRM(ITER))/RDM2
C
C       IF DNRM IS SMALL ENOUGH, REDUCE REQUIREMENTS TO ENTER STAGE 3
        IF(DNRM(ITER).LE.1.0D-09) THEN
          ENRGLV2 = 1.0D+02*DNRM(ITER)
        ENDIF
C
C       UPDATE TIME COUNTERS AT END OF ITERATION
        CALL CPU_TIME(TDON)
        TSTP = TDON-TMIT
        TMLEV(ILEV) = TMLEV(ILEV)+TSTP
C
C       DATE AND TIME AT END OF ITERATION
        CALL TIMENOW(STAMP)
C
C       HEADER FOR ITERATION SUMMARY
20      FORMAT(27X,A,1X,I3)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6,20) 'Iteration number',ITER
        WRITE(7,20) 'Iteration number',ITER
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       PRODUCE SPECTRUM SUMMARY AND INCLUDE FIRST 6 VIRTUAL STATES
        LF = LEN(TRIM(MOLCL))+LEN(TRIM(HMLT))
        LF = 23-LF/2
21      FORMAT(1X,A,'Molecular spectrum for ',A,' (',A,')')
        WRITE(6,21) REPEAT(' ',LF),TRIM(MOLCL),TRIM(HMLT)
        WRITE(7,21) REPEAT(' ',LF),TRIM(MOLCL),TRIM(HMLT)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        CALL SPECTRM(NOCC,6)
C
C       MOLECULAR ENERGIES
22      FORMAT(1X,A,21X,F21.12)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
        WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) 'Source',REPEAT(' ',60),'Energy'
        WRITE(7, *) 'Source',REPEAT(' ',60),'Energy'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,22) 'Nucleus-nucleus           (N) ',ENUC
        WRITE(7,22) 'Nucleus-nucleus           (N) ',ENUC
        WRITE(6,22) 'Electron-nucleus          (V) ',EHNC
        WRITE(7,22) 'Electron-nucleus          (V) ',EHNC
        WRITE(6,22) 'Electron kinetic          (T) ',EHKN
        WRITE(7,22) 'Electron kinetic          (T) ',EHKN
        IF(HMLT.NE.'BARE'.AND.NOCC.GT.1) THEN
          WRITE(6,22) 'Coulomb direct (closed)   (GD)',EGDR
          WRITE(7,22) 'Coulomb direct (closed)   (GD)',EGDR
          WRITE(6,22) 'Coulomb exchange (closed) (GX)',EGXC
          WRITE(7,22) 'Coulomb exchange (closed) (GX)',EGXC
          IF(NOPN.NE.0) THEN
            WRITE(6,22) 'Coulomb direct (open)     (QD)',EQDR
            WRITE(7,22) 'Coulomb direct (open)     (QD)',EQDR
            WRITE(6,22) 'Coulomb exchange (open)   (QX)',EQXC
            WRITE(7,22) 'Coulomb exchange (open)   (QX)',EQXC
          ENDIF
          IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
            WRITE(6,22) 'Breit direct (closed)     (BD)',EBDR
            WRITE(7,22) 'Breit direct (closed)     (BD)',EBDR
            WRITE(6,22) 'Breit exchange (closed)   (BX)',EBXC
            WRITE(7,22) 'Breit exchange (closed)   (BX)',EBXC
            IF(NOPN.NE.0) THEN
              WRITE(6,22) 'Breit direct (open)       (WD)',EWDR
              WRITE(7,22) 'Breit direct (open)       (WD)',EWDR
              WRITE(6,22) 'Breit exchange (open)     (WX)',EWXC
              WRITE(7,22) 'Breit exchange (open)     (WX)',EWXC
            ENDIF
          ENDIF
          IF(HMLT.EQ.'DHFQ') THEN
            WRITE(6,22) 'Vacuum polarisation       (U) ',EUEH
            WRITE(7,22) 'Vacuum polarisation       (U) ',EUEH
          ENDIF
        ENDIF
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,22) 'Molecule total                ',ETOT
        WRITE(7,22) 'Molecule total                ',ETOT
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       TWO-ELECTRON INTEGRAL SUMMARY
23      FORMAT(1X,A,4X,'1-centre',4X,'2-centre',4X,'3-centre',
     &                                     4X,'4-centre',7X,'Total')
24      FORMAT(1X,A,3X,I9,3X,I9,3X,I9,3X,I9,3X,I9)
25      FORMAT(1X,A,3X,F9.2,3X,F9.2,3X,F9.2,3X,F9.2,3X,F9.2)
26      FORMAT(1X,A,1X,A,1X,A,1X,A,1X,A,1X,A)
C
        IF(HMLT.EQ.'BARE'.OR.NOCC.LE.1) THEN
          GOTO 207
        ENDIF
c
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(7, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        IF(HMLT.EQ.'NORL') THEN
          WRITE(6,23) '(LL|LL)     '
          WRITE(7,23) '(LL|LL)     '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Blocks  (#) ',(N2EB(MCNT,1),MCNT=1,5)
          WRITE(7,24) 'Blocks  (#) ',(N2EB(MCNT,1),MCNT=1,5)
          IF(SCHWRZ) THEN
            WRITE(6,24) 'Integrals(#)',(N2EI(MCNT,1),MCNT=1,5)
            WRITE(7,24) 'Integrals(#)',(N2EI(MCNT,1),MCNT=1,5)
            WRITE(6,24) 'Screened (#)',(N2ES(MCNT,1),MCNT=1,5)
            WRITE(7,24) 'Screened (#)',(N2ES(MCNT,1),MCNT=1,5)
            WRITE(6,25) 'Screened (%)',(F2ES(MCNT,1),MCNT=1,5)
            WRITE(7,25) 'Screened (%)',(F2ES(MCNT,1),MCNT=1,5)
          ENDIF
          WRITE(6,26) 'Time        ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(7,26) 'Time        ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
        ELSE
          WRITE(6,23) 'Blocks  (#) '
          WRITE(7,23) 'Blocks  (#) '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) '(LL|LL)     ',(N2EB(MCNT,1),MCNT=1,5)
          WRITE(7,24) '(LL|LL)     ',(N2EB(MCNT,1),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 211
          WRITE(6,24) '(LL|SS)     ',(N2EB(MCNT,2),MCNT=1,5)
          WRITE(7,24) '(LL|SS)     ',(N2EB(MCNT,2),MCNT=1,5)
          WRITE(6,24) '(SS|LL)     ',(N2EB(MCNT,3),MCNT=1,5)
          WRITE(7,24) '(SS|LL)     ',(N2EB(MCNT,3),MCNT=1,5)
          WRITE(6,24) '(SS|SS)     ',(N2EB(MCNT,4),MCNT=1,5)
          WRITE(7,24) '(SS|SS)     ',(N2EB(MCNT,4),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 211
          WRITE(6,24) '(SL|LS)     ',(N2EB(MCNT,5),MCNT=1,5)
          WRITE(7,24) '(SL|LS)     ',(N2EB(MCNT,5),MCNT=1,5)
211       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Total       ',(N2EB(MCNT,6),MCNT=1,5)
          WRITE(7,24) 'Total       ',(N2EB(MCNT,6),MCNT=1,5)
          IF(SCHWRZ) THEN
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(6,23) 'Integrals(#)'
            WRITE(7,23) 'Integrals(#)'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,24) '(LL|LL)     ',(N2EI(MCNT,1),MCNT=1,5)
            WRITE(7,24) '(LL|LL)     ',(N2EI(MCNT,1),MCNT=1,5)
            IF(HMLT.EQ.'NORL') GOTO 212
            WRITE(6,24) '(LL|SS)     ',(N2EI(MCNT,2),MCNT=1,5)
            WRITE(7,24) '(LL|SS)     ',(N2EI(MCNT,2),MCNT=1,5)
            WRITE(6,24) '(SS|LL)     ',(N2EI(MCNT,3),MCNT=1,5)
            WRITE(7,24) '(SS|LL)     ',(N2EI(MCNT,3),MCNT=1,5)
            WRITE(6,24) '(SS|SS)     ',(N2EI(MCNT,4),MCNT=1,5)
            WRITE(7,24) '(SS|SS)     ',(N2EI(MCNT,4),MCNT=1,5)
            IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 212
            WRITE(6,24) '(SL|LS)     ',(N2EI(MCNT,5),MCNT=1,5)
            WRITE(7,24) '(SL|LS)     ',(N2EI(MCNT,5),MCNT=1,5)
212         CONTINUE
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,24) 'Total       ',(N2EI(MCNT,6),MCNT=1,5)
            WRITE(7,24) 'Total       ',(N2EI(MCNT,6),MCNT=1,5)
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(6,23) 'Screened (#)'
            WRITE(7,23) 'Screened (#)'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,24) '(LL|LL)     ',(N2ES(MCNT,1),MCNT=1,5)
            WRITE(7,24) '(LL|LL)     ',(N2ES(MCNT,1),MCNT=1,5)
            IF(HMLT.EQ.'NORL') GOTO 214
            WRITE(6,24) '(LL|SS)     ',(N2ES(MCNT,2),MCNT=1,5)
            WRITE(7,24) '(LL|SS)     ',(N2ES(MCNT,2),MCNT=1,5)
            WRITE(6,24) '(SS|LL)     ',(N2ES(MCNT,3),MCNT=1,5)
            WRITE(7,24) '(SS|LL)     ',(N2ES(MCNT,3),MCNT=1,5)
            WRITE(6,24) '(SS|SS)     ',(N2ES(MCNT,4),MCNT=1,5)
            WRITE(7,24) '(SS|SS)     ',(N2ES(MCNT,4),MCNT=1,5)
            IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 214
            WRITE(6,24) '(SL|LS)     ',(N2ES(MCNT,5),MCNT=1,5)
            WRITE(7,24) '(SL|LS)     ',(N2ES(MCNT,5),MCNT=1,5)
214         CONTINUE
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,24) 'Total       ',(N2ES(MCNT,6),MCNT=1,5)
            WRITE(7,24) 'Total       ',(N2ES(MCNT,6),MCNT=1,5)
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(6,23) 'Screened (%)'
            WRITE(7,23) 'Screened (%)'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,25) '(LL|LL)     ',(F2ES(MCNT,1),MCNT=1,5)
            WRITE(7,25) '(LL|LL)     ',(F2ES(MCNT,1),MCNT=1,5)
            IF(HMLT.EQ.'NORL') GOTO 216
            WRITE(6,25) '(LL|SS)     ',(F2ES(MCNT,2),MCNT=1,5)
            WRITE(7,25) '(LL|SS)     ',(F2ES(MCNT,2),MCNT=1,5)
            WRITE(6,25) '(SS|LL)     ',(F2ES(MCNT,3),MCNT=1,5)
            WRITE(7,25) '(SS|LL)     ',(F2ES(MCNT,3),MCNT=1,5)
            WRITE(6,25) '(SS|SS)     ',(F2ES(MCNT,4),MCNT=1,5)
            WRITE(7,25) '(SS|SS)     ',(F2ES(MCNT,4),MCNT=1,5)
            IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 216
            WRITE(6,25) '(SL|LS)     ',(F2ES(MCNT,5),MCNT=1,5)
            WRITE(7,25) '(SL|LS)     ',(F2ES(MCNT,5),MCNT=1,5)
216         CONTINUE
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,25) 'Total       ',(F2ES(MCNT,6),MCNT=1,5)
            WRITE(7,25) 'Total       ',(F2ES(MCNT,6),MCNT=1,5)
          ENDIF
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Time        '
          WRITE(7,23) 'Time        '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,26) '(LL|LL)     ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(7,26) '(LL|LL)     ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 219
          WRITE(6,26) '(LL|SS)     ',(MS(T2ES(MCNT,2)),MCNT=1,5)
          WRITE(7,26) '(LL|SS)     ',(MS(T2ES(MCNT,2)),MCNT=1,5)
          WRITE(6,26) '(SS|LL)     ',(MS(T2ES(MCNT,3)),MCNT=1,5)
          WRITE(7,26) '(SS|LL)     ',(MS(T2ES(MCNT,3)),MCNT=1,5)
          WRITE(6,26) '(SS|SS)     ',(MS(T2ES(MCNT,4)),MCNT=1,5)
          WRITE(7,26) '(SS|SS)     ',(MS(T2ES(MCNT,4)),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 219
          WRITE(6,26) '(SL|LS)     ',(MS(T2ES(MCNT,5)),MCNT=1,5)
          WRITE(7,26) '(SL|LS)     ',(MS(T2ES(MCNT,5)),MCNT=1,5)
219       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,26) 'Total       ',(MS(T2ES(MCNT,6)),MCNT=1,5)
          WRITE(7,26) 'Total       ',(MS(T2ES(MCNT,6)),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
        ENDIF
207     CONTINUE
C
C       MATRIX CONSTRUCTION STOPWATCH
        TMOR = TSTP-T1EL-TCL1-TCL2-TBR1-TBR2-TDGN
30      FORMAT(1X,A,24X,A)
31      FORMAT(1X,A,1X,I3,16X,A)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',20),'Fock construction labour analysis'
        WRITE(7, *) REPEAT(' ',20),'Fock construction labour analysis'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'One-electron matrices           ',HMS(T1EL)
        WRITE(7,30) 'One-electron matrices           ',HMS(T1EL)
        IF(HMLT.NE.'BARE') THEN
          WRITE(6,30) 'Coulomb (atomic)                ',HMS(TCL1)
          WRITE(7,30) 'Coulomb (atomic)                ',HMS(TCL1)
          WRITE(6,30) 'Coulomb (many-centre)           ',HMS(TCL2)
          WRITE(7,30) 'Coulomb (many-centre)           ',HMS(TCL2)
          IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
            WRITE(6,30) 'Breit (atomic)                  ',HMS(TBR1)
            WRITE(7,30) 'Breit (atomic)                  ',HMS(TBR1)
            WRITE(6,30) 'Breit (many-centre)             ',HMS(TBR2)
            WRITE(7,30) 'Breit (many-centre)             ',HMS(TBR2)
          ENDIF
        ENDIF
        WRITE(6,30) 'Matrix diagonalisation          ',HMS(TDGN)
        WRITE(7,30) 'Matrix diagonalisation          ',HMS(TDGN)
        WRITE(6,30) 'Other sources                   ',HMS(TMOR)
        WRITE(7,30) 'Other sources                   ',HMS(TMOR)
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,30) 'Total iteration time            ',HMS(TSTP)
        WRITE(7,30) 'Total iteration time            ',HMS(TSTP)
        WRITE(6,31) 'Time at end of iteration        ',ITER,STAMP
        WRITE(7,31) 'Time at end of iteration        ',ITER,STAMP
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       CONVERGENCE STATUS
32      FORMAT(1X,A,42X,I3)
33      FORMAT(1X,A,37X,F8.5)
34      FORMAT(1X,A,29X,1P,D16.9)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',26),'Convergence analysis'
        WRITE(7, *) REPEAT(' ',26),'Convergence analysis'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,32) 'Iteration number           ',ITER
        WRITE(7,32) 'Iteration number           ',ITER
        WRITE(6,32) 'Integral inclusion level   ',ILEV
        WRITE(7,32) 'Integral inclusion level   ',ILEV
        WRITE(6,33) 'Level shift parameter      ',SHLV
        WRITE(7,33) 'Level shift parameter      ',SHLV
        WRITE(6,34) 'Density difference norm    ',DNRM(ITER)
        WRITE(7,34) 'Density difference norm    ',DNRM(ITER)
        WRITE(6,34) 'Weighted energy difference ',WEDN(ITER)
        WRITE(7,34) 'Weighted energy difference ',WEDN(ITER)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       TEST FOR CONVERGENCE OR INTEGRAL CLASS UPDATE
40      FORMAT(29X,'Stage 1: (LL|LL)')
41      FORMAT(23X,'Stage 2: (LL|SS) and (SS|LL)')
42      FORMAT(19X,'Stage 2: (LL|SS), (SS|LL) and (SL|LS)')
43      FORMAT(29X,'Stage 3: (SS|SS)')
44      FORMAT(29X,'Stage 4: (SL|LS)')
C
C       THREE-STRIKE RULE: IF ENERGY DIFFERENCE KEEPS INCREASING, EXIT
        IF(NMLEV(ILEV).GT.15) THEN
C
C         STORE LAST FEW ENERGY DIFFERENCE VALUES
          WE1 = WEDN(ITER-3)
          WE2 = WEDN(ITER-2)
          WE3 = WEDN(ITER-1)
          WE4 = WEDN(ITER  )
C
C         IF EACH IS SEQUENTIALLY BIGGER THAN THE LAST, EXIT
          IF(WE4.GT.WE3.AND.WE3.GT.WE2.AND.WE2.GT.WE1) THEN
            WRITE(6, *) ' '
            WRITE(7, *) ' '
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6, *) 'In HFSCF: energy not converging. Exit BERTHA.'
            WRITE(7, *) 'In HFSCF: energy not converging. Exit BERTHA.'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            STOP
          ENDIF
C
        ENDIF
C
C       BARE NUCLEUS APPROXIMATION: NO COULOMB INTEGRALS AND NO SCF.
        IF(HMLT.EQ.'BARE'.OR.NOCC.LE.1) GOTO 300
C
C       CURRENTLY AT STAGE 1: (LL|LL)
        IF(ILEV.EQ.1) THEN
C
C         NON-RELATIVISTIC HAMILTONIAN ONLY INVOLVES (LL|LL)
          IF(HMLT.EQ.'NORL') THEN
C
C           SATISFIES ALL CRITERIA - SUCCESSFUL CONVERGENCE
            IF(WEDN(ITER).LT.ENRGTOL.AND.DNRM(ITER).LT.DSTYTOL) THEN
              GOTO 300
            ENDIF
C
C         ALL OTHER HAMILTONIANS REQUIRE FURTHER INTEGRAL INCLUSIONS
          ELSE
C
C           IF STAGE 1 HAS NOT CONVERGED, ITERATE AGAIN
            IF(WEDN(ITER).GE.ENRGLV1) THEN
              SHLV = SHLEV(ILEV)
C           IF STAGE 1 HAS CONVERGED, PROCEED TO STAGE 2
            ELSEIF(WEDN(ITER).LT.ENRGLV1) THEN
              ILEV = 2
              SHLV = SHLEV(ILEV)
              IDMPKEEP = 0
              WRITE(6, *) ' '
              WRITE(7, *) ' '
              WRITE(6, *) REPEAT('*',72)
              WRITE(7, *) REPEAT('*',72)
              IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
                WRITE(6,41)
                WRITE(7,41)
              ELSE
                WRITE(6,42)
                WRITE(7,42)
              ENDIF
              WRITE(6, *) REPEAT('*',72)
              WRITE(7, *) REPEAT('*',72)
              WRITE(6, *) ' '
              WRITE(7, *) ' '
            ENDIF
C
          ENDIF
C
C       CURRENTLY AT STAGE 2: (LL|SS), (SS|LL), (SL|LS)
        ELSEIF(ILEV.EQ.2) THEN

C         IF STAGE 2 HAS CONVERGED, PROCEED TO STAGE 3
          IF(WEDN(ITER).LT.ENRGLV2) THEN
            ILEV = 3
            SHLV = SHLEV(ILEV)
            IDMPKEEP = 0
            WRITE(6, *) ' '
            WRITE(7, *) ' '
            WRITE(6, *) REPEAT('*',72)
            WRITE(7, *) REPEAT('*',72)
            WRITE(6,43)
            WRITE(7,43)
            WRITE(6, *) REPEAT('*',72)
            WRITE(7, *) REPEAT('*',72)
            WRITE(6, *) ' '
            WRITE(7, *) ' '
          ENDIF
C
C       CURRENTLY AT STAGE 3: (SS|SS)
        ELSEIF(ILEV.EQ.3) THEN
C
C         SATISFIES ALL CRITERIA - SUCCESSFUL CONVERGENCE
          IF(WEDN(ITER).LT.ENRGTOL.AND.DNRM(ITER).LT.DSTYTOL) THEN
            GOTO 300
          ENDIF
C
        ENDIF
C
C     END LOOP OVER ITERATIONS
      ENDDO
C
C     FORCED EXIT: UNSUCCESSFUL CONVERGENCE
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6, *) 'In HFSCF: convergence not attained. ITER = ',ITER
      WRITE(7, *) 'In HFSCF: convergence not attained. ITER = ',ITER
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      STOP
C
C     EARLY EXIT: SUCCESSFUL CONVERGENCE
300   CONTINUE
C
C**********************************************************************C
C     END OF SELF-CONSISTENT FIELD CALCULATIONS                        C
C**********************************************************************C
C
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) REPEAT('\/',36)
      WRITE(7, *) REPEAT('\/',36)
      WRITE(6, *) REPEAT(':',72)
      WRITE(7, *) REPEAT(':',72)
      WRITE(6, *) REPEAT(' ',25),'Successful convergence!'
      WRITE(7, *) REPEAT(' ',25),'Successful convergence!'
      WRITE(6, *) REPEAT(':',72)
      WRITE(7, *) REPEAT(':',72)
      WRITE(6, *) REPEAT('/\',36)
      WRITE(7, *) REPEAT('/\',36)
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C**********************************************************************C
C     ADDITIONAL OPTIONS AFTER CONVERGENCE (1ST ORDER P.T.)            C
C**********************************************************************C
C
998   CONTINUE
C
C     CALCULATE THE PERTUBATIVE VALUE OF THE BREIT ENERGY
      IF(HMLT.EQ.'DHFP') THEN
        CALL CPU_TIME(TPRTI)
C
C       PRINT CALL TO NEW STAGE OF R-INTEGRALS
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('*',72)
        WRITE(7, *) REPEAT('*',72)
        WRITE(6,44)
        WRITE(7,44)
        WRITE(6, *) REPEAT('*',72)
        WRITE(7, *) REPEAT('*',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       TITLE FOR CALL TO BREIT ROUTINE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',24),'First order Breit energy'
        WRITE(7, *) REPEAT(' ',24),'First order Breit energy'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
C
C       GENERATE MATRIX REP OF BREIT INTERACTION
        TSCR = 0.0D0

        CALL CPU_TIME(T1)
        CALL BREIT
        IF(RACAH1) THEN
          DO IZ=1,NCNT
            CALL BREIT1(IZ)
          ENDDO
        ENDIF
        CALL CPU_TIME(T2)
C
        TBR2 = T2-T1
        TB2T = TB2T+TBR2
C
C       CALCULATE FRACTION OF SCREENED INTEGRALS
        TSCR = TSCR + TSCR
        DO MCNT=1,5
          DO ITT=5,6
            IF(N2EI(MCNT,ITT).NE.0) THEN
              RATIO = DFLOAT(N2ES(MCNT,ITT))/DFLOAT(N2EI(MCNT,ITT))
              F2ES(MCNT,ITT) = 100.0D0*RATIO
            ELSE
              F2ES(MCNT,ITT) = 0.0D0
            ENDIF
          ENDDO
        ENDDO
C
C       GENERATE COUPLING MATRIX
        IF(NOPN.NE.0) THEN
          CALL COUPLE
        ENDIF
C
C       ADD BREIT MATRIX TO MOST RECENT FOCK MATRIX
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = HNUC(I,J) + HKIN(I,J) + GDIR(I,J) - GXCH(I,J)
     &                + BDIR(I,J) - BXCH(I,J) + VUEH(I,J) + CPLE(I,J)
     &                - QDIR(I,J) + QXCH(I,J) - WDIR(I,J) + WXCH(I,J)
          ENDDO
        ENDDO
C
C       DIAGONALISE FOCK MATRIX (REQUIRES LAPACK LIBRARY)
        CALL ZHEGV(1,'V','L',NDIM,FOCK,MDM,OVLP,MDM,EIGN,WK,LWK,RK,INF)
        IF(INF.NE.0) THEN
          WRITE(6, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INF
          WRITE(7, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INF
        ENDIF
C
C       TRANSFER EIGENVECTORS TO THE C ARRAY
        DO J=1,NDIM
          DO I=1,NDIM
            COEF(I,J) = FOCK(I,J)
          ENDDO
        ENDDO
C
C       DEDUCT LEVEL SHIFT VALUE FROM VIRTUAL ORBITAL EIGENVALUES
        IF(ITER.EQ.1) THEN
          DO IVIR=NSKP+NOCC+1,NDIM
            EIGN(IVIR) = EIGN(IVIR) - SHLV
          ENDDO
        ENDIF
C
C       UPDATE EIGENVALUES AND COEFFICIENTS
        OPEN(UNIT=8,FILE=TRIM(WFNFL)//'(+B).wfn',STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          WRITE(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
C
C       RECALCULATE TOTAL ENERGY
        CALL ENRGIES
C
C       UPDATE TOTAL BREIT CALCULATION TIME
        CALL CPU_TIME(TPRTF)
        TBMX = TPRTF-TPRTI
C
C       SUMMARISE DIRECT AND EXCHANGE ENERGIES
        WRITE(6,22) 'Breit direct (closed)     (BD)',EBDR
        WRITE(7,22) 'Breit direct (closed)     (BD)',EBDR
        WRITE(6,22) 'Breit exchange (closed)   (BX)',EBXC
        WRITE(7,22) 'Breit exchange (closed)   (BX)',EBXC
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'Total BREIT time                ',HMS(TBMX)
        WRITE(7,30) 'Total BREIT time                ',HMS(TBMX)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       TWO-ELECTRON CALCULATION BREAKDOWN
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(7, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,23) '(SL|LS)     '
        WRITE(7,23) '(SL|LS)     '
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,24) 'Integrals(#)',(N2EI(MCNT,5),MCNT=1,5)
        WRITE(7,24) 'Integrals(#)',(N2EI(MCNT,5),MCNT=1,5)
        IF(SCHWRZ) THEN
          WRITE(6,24) 'Screened (#)',(N2ES(MCNT,5),MCNT=1,5)
          WRITE(7,24) 'Screened (#)',(N2ES(MCNT,5),MCNT=1,5)
          WRITE(6,25) 'Screened (%)',(F2ES(MCNT,5),MCNT=1,5)
          WRITE(7,25) 'Screened (%)',(F2ES(MCNT,5),MCNT=1,5)
        ENDIF
260     CONTINUE
        WRITE(6,26) 'Time        ',(MS(T2ES(MCNT,5)),MCNT=1,5)
        WRITE(7,26) 'Time        ',(MS(T2ES(MCNT,5)),MCNT=1,5)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       LEVEL ITERATIONS AND TIME
        NMLEV(4) = 1
        TMLEV(4) = TBMX
        ITER     = ITER+1
C
      ENDIF
C
C**********************************************************************C
C     SUMMARY OF CALCULATION DETAILS                                   C
C**********************************************************************C
C
C     TIME AT END OF MOLECULAR CALCULATION
      CALL CPU_TIME(TSCF2)
      TTOT = TSCF2-TSCF1
C
C     DATE AND TIME AT END OF CALCULATION
      CALL TIMENOW(STAMP)
C
C     PRINT OUT FINAL SCF RESULTS
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'Molecular SCF summary'
      WRITE(7, *) REPEAT(' ',25),'Molecular SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     MOLECULAR ENERGIES
      EDIR = EGDR+EQDR+EBDR+EWDR
      EXCH = EGXC+EQXC+EBXC+EWXC
50    FORMAT(1X,A,22X,A,11X,A,14X,A)
51    FORMAT(1X,A,39X,F17.9)
52    FORMAT(1X,A,1X,F17.9,2X,F17.9,2X,F17.9)
      WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,50) 'Source','Direct','Exchange','Total'
      WRITE(7,50) 'Source','Direct','Exchange','Total'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,51) 'Nucleus-nucleus ',ENUC
      WRITE(7,51) 'Nucleus-nucleus ',ENUC
      WRITE(6,51) 'Electron-nucleus',EHNC
      WRITE(7,51) 'Electron-nucleus',EHNC
      WRITE(6,51) 'Electron kinetic',EHKN
      WRITE(7,51) 'Electron kinetic',EHKN
      IF(HMLT.NE.'DHFQ') GOTO 405
      WRITE(6,51) 'Vac. pol effects',EUEH
      WRITE(7,51) 'Vac. pol effects',EUEH
405   CONTINUE
      IF(HMLT.EQ.'BARE') GOTO 400
      WRITE(6,52) 'Coulomb (closed)',EGDR,EGXC,ECLG
      WRITE(7,52) 'Coulomb (closed)',EGDR,EGXC,ECLG
      IF(NOPN.EQ.0) GOTO 410
      WRITE(6,52) 'Coulomb (open)  ',EQDR,EQXC,ECLQ
      WRITE(7,52) 'Coulomb (open)  ',EQDR,EQXC,ECLQ
410   CONTINUE
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 400
      WRITE(6,52) 'Breit (closed)  ',EBDR,EBXC,EBRG
      WRITE(7,52) 'Breit (closed)  ',EBDR,EBXC,EBRG
      IF(NOPN.EQ.0) GOTO 400
      WRITE(6,52) 'Breit (open)    ',EWDR,EWXC,EBRQ
      WRITE(7,52) 'Breit (open)    ',EWDR,EWXC,EBRQ
400   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,52) 'Molecule        ',EDIR,EXCH,ETOT
      WRITE(7,52) 'Molecule        ',EDIR,EXCH,ETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     EQ-COEFFICIENT AND R-INTEGRAL ANALYSIS
53    FORMAT(1X,A,4X,A,14X,A,20X,A)
54    FORMAT(1X,A,3X,A,14X,A,A)
64    FORMAT(1X,A,3X,A)
55    FORMAT(38X,A,A)
56    FORMAT(1X,A,2X,A,33X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Eq-coefficients and R-integrals'
      WRITE(7, *) REPEAT(' ',20),'Eq-coefficients and R-integrals'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,53) 'Eq-coefficients','Time','R-integrals','Time'
      WRITE(7,53) 'Eq-coefficients','Time','R-integrals','Time'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,54) 'E0LL',HMS(TELL),'(LL|LL)            ',HMS(TRLL)
      WRITE(7,54) 'E0LL',HMS(TELL),'(LL|LL)            ',HMS(TRLL)
      IF(HMLT.EQ.'NORL') GOTO 420
      WRITE(6,54) 'E0SS',HMS(TESS),'(LL|SS) and (SS|LL)',HMS(TRLS)
      WRITE(7,54) 'E0SS',HMS(TESS),'(LL|SS) and (SS|LL)',HMS(TRLS)
      WRITE(6,55)                  '(SS|SS)            ',HMS(TRSS)
      WRITE(7,55)                  '(SS|SS)            ',HMS(TRSS)
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 420
      WRITE(6,54) 'EILS',HMS(TELS),'(SL|LS)            ',HMS(TRBR)
      WRITE(7,54) 'EILS',HMS(TELS),'(SL|LS)            ',HMS(TRBR)
      WRITE(6,64) 'EISL',HMS(TESL)
      WRITE(7,64) 'EISL',HMS(TESL)
420   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,56) 'Total',HMS(TELL+TESS+TELS+TESL),
     &                    HMS(TRLL+TRLS+TRSS+TRBR)
      WRITE(7,56) 'Total',HMS(TELL+TESS+TELS+TESL),
     &                    HMS(TRLL+TRLS+TRSS+TRBR)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     CONVERGENCE ANALYSIS
      T1 = TMLEV(1)
      T2 = TMLEV(2)
      T3 = TMLEV(3)
      T4 = TMLEV(4)
59    FORMAT(1X,A,3X,A,16X,A,6X,A,14X,A)
60    FORMAT(1X,I1,7X,A,2X,F8.5,13X,I3,2X,A)
61    FORMAT(1X,I1,7X,A)
62    FORMAT(9X,A,2X,F8.5,13X,I3,2X,A)
63    FORMAT(1X,A,46X,I3,2X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',25),'Convergence analysis'
      WRITE(7, *) REPEAT(' ',25),'Convergence analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,59) 'Stage','Inclusion','Shift','Iterations','Time'
      WRITE(7,59) 'Stage','Inclusion','Shift','Iterations','Time'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,60) 1,'(LL|LL)             ',SHLEV(1),NMLEV(1),HMS(T1)
      WRITE(7,60) 1,'(LL|LL)             ',SHLEV(1),NMLEV(1),HMS(T1)
      IF(HMLT.EQ.'NORL') GOTO 440
      IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
        WRITE(6,61) 2,'(LL|SS) and (SS|LL),'
        WRITE(7,61) 2,'(LL|SS) and (SS|LL),'
        WRITE(6,62)   '(SL|LS)             ',SHLEV(2),NMLEV(2),HMS(T2)
        WRITE(7,62)   '(SL|LS)             ',SHLEV(2),NMLEV(2),HMS(T2)
      ELSE
        WRITE(6,60) 2,'(LL|SS) and (SS|LL) ',SHLEV(2),NMLEV(2),HMS(T2)
        WRITE(7,60) 2,'(LL|SS) and (SS|LL) ',SHLEV(2),NMLEV(2),HMS(T2)
      ENDIF
      WRITE(6,60) 3,'(SS|SS)             ',SHLEV(3),NMLEV(3),HMS(T3)
      WRITE(7,60) 3,'(SS|SS)             ',SHLEV(3),NMLEV(3),HMS(T3)
      IF(HMLT.EQ.'DHFP') THEN
        WRITE(6,60) 4,'(SL|LS)             ',SHLEV(3),NMLEV(4),HMS(T4)
        WRITE(7,60) 4,'(SL|LS)             ',SHLEV(3),NMLEV(4),HMS(T4)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,63) 'Total',ITER,HMS(T1+T2+T3+T4)
      WRITE(7,63) 'Total',ITER,HMS(T1+T2+T3+T4)
440   CONTINUE
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     HFSCF LABOUR ANALYIS
57    FORMAT(1X,A,24X,A)
58    FORMAT(1X,A,1X,25X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT(' ',26),'HFSCF labour analysis'
      WRITE(7, *) REPEAT(' ',26),'HFSCF labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(HMLT.EQ.'BARE') GOTO 530
      TC1O = TC1T-TC1S-TC1B-TC1R-TC1F-TC1M
      WRITE(6, *) REPEAT(' ',24),'Coulomb (atomic) details'
      WRITE(7, *) REPEAT(' ',24),'Coulomb (atomic) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TC1S)
      WRITE(7,57) 'Screening                       ',HMS(TC1S)
      WRITE(6,57) 'Basis intermediates             ',HMS(TC1B)
      WRITE(7,57) 'Basis intermediates             ',HMS(TC1B)
      WRITE(6,57) 'R(AB|CD) integrals              ',HMS(TC1R)
      WRITE(7,57) 'R(AB|CD) integrals              ',HMS(TC1R)
      WRITE(6,57) 'Full integrals                  ',HMS(TC1F)
      WRITE(7,57) 'Full integrals                  ',HMS(TC1F)
      WRITE(6,57) 'Matrix construction             ',HMS(TC1M)
      WRITE(7,57) 'Matrix construction             ',HMS(TC1M)
      WRITE(6,57) 'Other                           ',HMS(TC1O)
      WRITE(7,57) 'Other                           ',HMS(TC1O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TC1T)
      WRITE(7,57) 'Total                           ',HMS(TC1T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      TC2O = TC2T-TCLV-TC2S-TCEC-TCRM-TCRR-TCC1-TCC2-TCMC
      WRITE(6, *) REPEAT(' ',21),'Coulomb (many-centre) details'
      WRITE(7, *) REPEAT(' ',21),'Coulomb (many-centre) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TC2S)
      WRITE(7,57) 'Screening                       ',HMS(TC2S)
      IF(VSSCHR) THEN
        WRITE(6,57) 'Visscher small-components       ',HMS(TCLV)
        WRITE(7,57) 'Visscher small-components       ',HMS(TCLV)
      ENDIF
      WRITE(6,57) 'Eq-coefficients                 ',HMS(TCEC)
      WRITE(7,57) 'Eq-coefficients                 ',HMS(TCEC)
      WRITE(6,57) 'R-integral make                 ',HMS(TCRM)
      WRITE(7,57) 'R-integral make                 ',HMS(TCRM)
      WRITE(6,57) 'R-integral read                 ',HMS(TCRR)
      WRITE(7,57) 'R-integral read                 ',HMS(TCRR)
      WRITE(6,57) '1st contraction                 ',HMS(TCC1)
      WRITE(7,57) '1st contraction                 ',HMS(TCC1)
      WRITE(6,57) '2nd contraction                 ',HMS(TCC2)
      WRITE(7,57) '2nd contraction                 ',HMS(TCC2)
      WRITE(6,57) 'Matrix construction             ',HMS(TCMC)
      WRITE(7,57) 'Matrix construction             ',HMS(TCMC)
      WRITE(6,57) 'Other                           ',HMS(TC2O)
      WRITE(7,57) 'Other                           ',HMS(TC2O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TC2T)
      WRITE(7,57) 'Total                           ',HMS(TC2T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 530
      TB1O = TB1T-TB1S-TB1B-TB1R-TB1F-TB1M
      WRITE(6, *) REPEAT(' ',25),'Breit (atomic) details'
      WRITE(7, *) REPEAT(' ',25),'Breit (atomic) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TB1S)
      WRITE(7,57) 'Screening                       ',HMS(TB1S)
      WRITE(6,57) 'Basis intermediates             ',HMS(TB1B)
      WRITE(7,57) 'Basis intermediates             ',HMS(TB1B)
      WRITE(6,57) 'R(AB|CD) integrals              ',HMS(TB1R)
      WRITE(7,57) 'R(AB|CD) integrals              ',HMS(TB1R)
      WRITE(6,57) 'Full integrals                  ',HMS(TB1F)
      WRITE(7,57) 'Full integrals                  ',HMS(TB1F)
      WRITE(6,57) 'Matrix construction             ',HMS(TB1M)
      WRITE(7,57) 'Matrix construction             ',HMS(TB1M)
      WRITE(6,57) 'Other                           ',HMS(TB1O)
      WRITE(7,57) 'Other                           ',HMS(TB1O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TB1T)
      WRITE(7,57) 'Total                           ',HMS(TB1T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
555   CONTINUE
      TB2O = TB2T-TB2S-TBEC-TBRM-TBRR-TBC1-TBC2-TBMC
      WRITE(6, *) REPEAT(' ',22),'Breit (many-centre) details'
      WRITE(7, *) REPEAT(' ',22),'Breit (many-centre) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TB2S)
      WRITE(7,57) 'Screening                       ',HMS(TB2S)
      WRITE(6,57) 'Eq-coefficients                 ',HMS(TBEC)
      WRITE(7,57) 'Eq-coefficients                 ',HMS(TBEC)
      WRITE(6,57) 'R-integral make                 ',HMS(TBRM)
      WRITE(7,57) 'R-integral make                 ',HMS(TBRM)
      WRITE(6,57) 'R-integral read                 ',HMS(TBRR)
      WRITE(7,57) 'R-integral read                 ',HMS(TBRR)
      WRITE(6,57) '1st contraction                 ',HMS(TBC1)
      WRITE(7,57) '1st contraction                 ',HMS(TBC1)
      WRITE(6,57) '2nd contraction                 ',HMS(TBC2)
      WRITE(7,57) '2nd contraction                 ',HMS(TBC2)
      WRITE(6,57) 'Matrix construction             ',HMS(TBMC)
      WRITE(7,57) 'Matrix construction             ',HMS(TBMC)
      WRITE(6,57) 'Other                           ',HMS(TB2O)
      WRITE(7,57) 'Other                           ',HMS(TB2O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TB2T)
      WRITE(7,57) 'Total                           ',HMS(TB2T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
530   CONTINUE
      TOTH = TTOT-TEPP-THMX-TQMX-TC1T-TC2T-TCVT-TB1T-TB2T-TEIG
      WRITE(6, *) REPEAT(' ',27),'Overall SCF summary'
      WRITE(7, *) REPEAT(' ',27),'Overall SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Eq-coefficient data file prep.  ',HMS(TEPP)
      WRITE(7,57) 'Eq-coefficient data file prep.  ',HMS(TEPP)
      WRITE(6,57) 'Nuclear, kinetic and overlap    ',HMS(THMX)
      WRITE(7,57) 'Nuclear, kinetic and overlap    ',HMS(THMX)
      IF(HMLT.EQ.'DHFQ') THEN
        WRITE(6,57) 'Vacuum polarisation             ',HMS(TQMX)
        WRITE(7,57) 'Vacuum polarisation             ',HMS(TQMX)
      ENDIF
      IF(HMLT.EQ.'BARE') GOTO 430
      WRITE(6,57) 'Coulomb (atomic)                ',HMS(TC1T)
      WRITE(7,57) 'Coulomb (atomic)                ',HMS(TC1T)
      WRITE(6,57) 'Coulomb (many-centre)           ',HMS(TC2T)
      WRITE(7,57) 'Coulomb (many-centre)           ',HMS(TC2T)
      IF(VSSCHR) THEN
        WRITE(6,57) 'Visscher small-component approx.',HMS(TCVT)
        WRITE(7,57) 'Visscher small-component approx.',HMS(TCVT)
      ENDIF
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 430
      WRITE(6,57) 'Breit (atomic)                  ',HMS(TB1T)
      WRITE(7,57) 'Breit (atomic)                  ',HMS(TB1T)
      WRITE(6,57) 'Breit (many-centre)             ',HMS(TB2T)
      WRITE(7,57) 'Breit (many-centre)             ',HMS(TB2T)
430   CONTINUE
      WRITE(6,57) 'Matrix diagonalisation          ',HMS(TEIG)
      WRITE(7,57) 'Matrix diagonalisation          ',HMS(TEIG)
      WRITE(6,57) 'Other sources                   ',HMS(TOTH)
      WRITE(7,57) 'Other sources                   ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TTOT)
      WRITE(7,57) 'Total                           ',HMS(TTOT)
      WRITE(6,58) 'Time at end of calculation',STAMP
      WRITE(7,58) 'Time at end of calculation',STAMP
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE OVRLP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              OOOOOO  VV    VV RRRRRRR  LL      PPPPPPP               C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO  VV  VV  RRRRRRR  LL      PPPPPPP               C
C             OO    OO   VVVV   RR    RR LL      PP                    C
C              OOOOOO     VV    RR    RR LLLLLLL PP                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  OVRLP CONSTRUCTS A MOLECULAR BASIS FUNCTION OVERLAP MATRIX.         C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION RC(MB2,MRC),EXL(MBS,4),XYZ(3,4),APH(MB2),CP(MB2,3),
     &          PNC(MB2),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TCVT,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          OVLP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS=+1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-PHS*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = PHS*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC OVERLAP CALCULATIONS COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 500
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS=+1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-PHS*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = PHS*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF THE OVERLAP MATRIX FOR THIS BLOCK OF   C
C     BASIS FUNCTIONS -- NOW OVERLAY THE RESULTS INTO OVLP.            C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC OVERLAP MATRIX COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 600
C
C     SS BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ONEEL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               OOOOOO  NN    NN EEEEEEE EEEEEEE LL                    C
C              OO    OO NNN   NN EE      EE      LL                    C
C              OO    OO NNNN  NN EE      EE      LL                    C
C              OO    OO NN NN NN EEEEEE  EEEEEE  LL                    C
C              OO    OO NN  NNNN EE      EE      LL                    C
C              OO    OO NN   NNN EE      EE      LL                    C
C               OOOOOO  NN    NN EEEEEEE EEEEEEE LLLLLLL               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ONEEL CONSTRUCTS A FULL SET OF MULTI-CENTRE OVERLAP, KINETIC AND    C
C  NUCLEAR ATTRACTION BASIS FUNCTION MATRIX ELEMENTS.                  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CTMP1,CTMP2,CTMP3,CTMP4
      COMPLEX*16 E11A,E11B,E11C,TRM11,E21A,E21B,E21C,TRM21
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4),
     &           VLL(MBS,MBS,4),VSS(MBS,MBS,4),
     &           TLL(MBS,MBS,4),TLS(MBS,MBS,4),TSL(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          HNUC(I,J) = DCMPLX(0.0D0,0.0D0)
          HKIN(I,J) = DCMPLX(0.0D0,0.0D0)
          OVLP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXM = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IM=1,4
            SLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            SSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            TLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            TLS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            TSL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
          DO M=1,MAXM
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-PHS*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = PHS*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
          ENDDO
        ENDDO
C
        IF(NNUC(IZ).EQ.0) THEN
C       POINT-NUCLEUS APPROXIMATION
C
C         PREPARE ELEMENTS FOR RMAKE
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             POINT-NUCLEUS EFFECTIVE PARAMETERS
              EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
              APH(M) = EIJ
              PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
C
            ENDDO
          ENDDO
C
C         GENERATE A BATCH OF R-INTEGRALS
          CALL CPU_TIME(TDM1)
          CALL RMAKE(RC,CP,APH,MAXM,LAMLL)
          CALL CPU_TIME(TDM2)
          TRLL = TRLL + TDM2 - TDM1
C
C         NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUM OF ELL0 AND RC
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              DO ITUV=1,NTUVLL
                VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                           - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
                VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                           - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
              ENDDO
              VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
              VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
            ENDDO
          ENDDO
C
        ELSE
C       BEST-FIT EXPANSION
C
C         LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
          DO IFT=1,NNUC(IZ)
C
C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
            XI = XNUC(IZ,IFT)
            FC = FNUC(IZ,IFT)
C
C           PREPARE ELEMENTS FOR RMAKE
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
C
C               FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
                EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
                ESM    = EIJ+XI
                APH(M) = EIJ*XI/ESM
                PNC(M) = 2.0D0*PI*ZNUC(IZ)*FC*DSQRT(XI/ESM)/EIJ
C
              ENDDO
            ENDDO
C
C           GENERATE A BATCH OF R-INTEGRALS
            CALL CPU_TIME(TDM1)
            CALL RMAKE(RC,CP,APH,MAXM,LAMLL)
            CALL CPU_TIME(TDM2)
            TRLL = TRLL + TDM2 - TDM1
C
C           NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUM OF ELL0 AND RC
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                DO ITUV=1,NTUVLL
                  VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                             - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
                  VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                             - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
                ENDDO
                VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
                VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
              ENDDO
            ENDDO
C
C         END LOOP OVER NUCLEAR BASIS FOR IZ
          ENDDO
C
        ENDIF
C
C     END LOOP OVER CENTRES IZ
      ENDDO
C
C     CONSTRUCT NON-RELATIVISTIC KINETIC ENERGY INTEGRALS (IOS 91)
      IF(HMLT.EQ.'NORL') THEN
        RL2 = DFLOAT(2*LQN(2)+3)
        M   = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
C
C           GAUSSIAN PRODUCT THEOREM DETAILS
            EJ  = EXL(JBAS,2)
            EIJ = EXL(IBAS,1) + EXL(JBAS,2)
            ERT = DSQRT(PI/EIJ)**3
            PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C           COORDINATES RELATIVE TO NUCLEAR CENTRE
            PBX = PX-XYZ(1,2)
            PBY = PY-XYZ(2,2)
            PBZ = PZ-XYZ(3,2)
            PB2 = PBX*PBX + PBY*PBY + PBZ*PBZ
C
            E0FC = EJ*RL2 - 2.0D0*EJ*EJ*PB2 - 3.0D0*EJ*EJ/EIJ
            E1FC = 4.0D0*EJ*EJ
C
C           TRUNCATE EXPRESSION DEPENDING ON LAMLL VALUE
C           ALL COMBINATIONS ALLOW FOR THE LAMLL = 0 MANIFOLD
            TRM11 = E0FC*E11(M,IABC(0,0,0))
            TRM21 = E0FC*E21(M,IABC(0,0,0))
C           IF LAMLL > 0 PROVIDE SECOND BUNCH OF TERMS
            IF(LAMLL.GE.1) THEN
              E11A = E11(M,IABC(1,0,0))
              E21A = E21(M,IABC(1,0,0))
              E11B = E11(M,IABC(0,1,0))
              E21B = E21(M,IABC(0,1,0))
              E11C = E11(M,IABC(0,0,1))
              E21C = E21(M,IABC(0,0,1))
              TRM11 = TRM11 - E1FC*(PBX*E11A + PBY*E11B + PBZ*E11C)
              TRM21 = TRM21 - E1FC*(PBX*E21A + PBY*E21B + PBZ*E21C)
            ENDIF
C           IF LAMLL > 1 PROVIDE FINAL BUNCH OF TERMS
            IF(LAMLL.GE.2) THEN
              E11A = E11(M,IABC(2,0,0))
              E21A = E21(M,IABC(2,0,0))
              E11B = E11(M,IABC(0,2,0))
              E21B = E21(M,IABC(0,2,0))
              E11C = E11(M,IABC(0,0,2))
              E21C = E21(M,IABC(0,0,2))
              TRM11 = TRM11 - E1FC*(E11A + E11B + E11C)
              TRM21 = TRM21 - E1FC*(E21A + E21B + E21C)
            ENDIF
            TLL(IBAS,JBAS,1) = ERT*TRM11
            TLL(IBAS,JBAS,3) = ERT*TRM21
            TLL(IBAS,JBAS,2) =-PHS*DCONJG(TLL(IBAS,JBAS,3))
            TLL(IBAS,JBAS,4) = PHS*DCONJG(TLL(IBAS,JBAS,1))
C            
          ENDDO
        ENDDO
C       NON-RELATIVISTIC HAMILTONIAN MATRICES COMPLETE
        GOTO 500
      ENDIF
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
          DO M=1,MAXM
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXL(IBAS,1)+EXL(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-PHS*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = PHS*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
          ENDDO
        ENDDO
C
        IF(NNUC(IZ).EQ.0) THEN
C       POINT-NUCLEUS APPROXIMATION
C
C         PREPARE ELEMENTS FOR RMAKE
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             POINT-NUCLEUS EFFECTIVE PARAMETERS
              EIJ = EXL(IBAS,1)+EXL(JBAS,2)
              APH(M) = EIJ
              PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
C
            ENDDO
          ENDDO
C
C         GENERATE A BATCH OF R-INTEGRALS
          CALL CPU_TIME(TDM1)
          CALL RMAKE(RC,CP,APH,MAXM,LAMSS)
          CALL CPU_TIME(TDM2)
          TRSS = TRSS + TDM2 - TDM1
C
C         NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUM OF ESS0 AND RC
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
              DO ITUV=1,NTUVSS
                VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                           + PNC(M)*E11(M,ITUV)*RC(M,ITUV)
                VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                           + PNC(M)*E21(M,ITUV)*RC(M,ITUV)
              ENDDO
              VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
              VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
            ENDDO
          ENDDO
C
        ELSE
C       BEST-FIT EXPANSION
C
C         LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
          DO IFT=1,NNUC(IZ)
C
C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
            XI = XNUC(IZ,IFT)
            FC = FNUC(IZ,IFT)
C
C           PREPARE ELEMENTS FOR RMAKE
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
C
C               FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
                EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
                ESM    = EIJ+XI
                APH(M) = EIJ*XI/ESM
                PNC(M) = 2.0D0*PI*ZNUC(IZ)*FC*DSQRT(XI/ESM)/EIJ
C
              ENDDO
            ENDDO
C
C           GENERATE A BATCH OF R-INTEGRALS
            CALL CPU_TIME(TDM1)
            CALL RMAKE(RC,CP,APH,MAXM,LAMSS)
            CALL CPU_TIME(TDM2)
            TRSS = TRSS + TDM2 - TDM1
C
C           NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUM OF ESS0 AND RC
            M = 0
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
                M = M+1
                DO ITUV=1,NTUVSS
                  VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                             + PNC(M)*E11(M,ITUV)*RC(M,ITUV)
                  VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                             + PNC(M)*E21(M,ITUV)*RC(M,ITUV)
                ENDDO
                VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
                VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
              ENDDO
            ENDDO
C
C         END LOOP OVER NUCLEAR BASIS FOR IZ
          ENDDO
C
        ENDIF
C
C     END LOOP OVER CENTRES IZ
      ENDDO
C
C     SUBTRACT THE SS OVERLAP MATRIX AND FINISH CONSTRUCTION
      CV2 = 2.0D0*EMSS*CV*CV
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          VSS(IBAS,JBAS,1) =-VSS(IBAS,JBAS,1) - CV2*SSS(IBAS,JBAS,1)
          VSS(IBAS,JBAS,3) =-VSS(IBAS,JBAS,3) - CV2*SSS(IBAS,JBAS,3)
          VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
          VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 3: THE SL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     KINETIC MATRIX ELEMENTS
      FACT = CV*DSQRT(DFLOAT(2*LQN(2)+3))
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ    = EXL(IBAS,1) + EXL(JBAS,2)
          EJRT   = FACT*DSQRT(EXL(JBAS,2))
          EROOT  = DSQRT(PI/EIJ)**3
          TSL(IBAS,JBAS,1) = EJRT*EROOT*E11(M,1)
          TSL(IBAS,JBAS,3) = EJRT*EROOT*E21(M,1)
          TSL(IBAS,JBAS,2) =-PHS*DCONJG(TSL(IBAS,JBAS,3))
          TSL(IBAS,JBAS,4) = PHS*DCONJG(TSL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C
C**********************************************************************C
C     PART 4: THE LS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
C
      CALL CPU_TIME(TDM1)
C
C     TODO: THE INDEX SWAP '2 1' MAKES FILE IMPORT ANNOYING. I'M LAZY.
C             JUST GENERATE THESE EQ'S AS A BATCH (DOESN'T TAKE LONG).
C
C     IF(EQFILE) THEN
C       DO ITUV=1,NTUVSS
C         IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
C         M = 0
C         DO IBAS=1,NBAS(1)
C           DO JBAS=1,NBAS(2)
C             M = M+1
C             N = (JBAS-1)*NBAS(2) + IBAS
C             PI^{SL}_{IJ} = PI^{LS}_{JI}* (THE NEXT LINES ARE WRONG)
C             E11(M,ITUV) = DCMPLX(E0SSFL(IAD+N,1),-E0SSFL(IAD+N,2))
C             E21(M,ITUV) = DCMPLX(E0SSFL(IAD+N,3),-E0SSFL(IAD+N,4))
C           ENDDO
C         ENDDO
C       ENDDO
C     ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,2,1,0)
C     ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     KINETIC MATRIX ELEMENTS
      FACT = CV*DSQRT(DFLOAT(2*LQN(1)+3))
      M = 0
      DO JBAS=1,NBAS(2)
        DO IBAS=1,NBAS(1)
          M = M+1
          EIJ    = EXL(JBAS,2) + EXL(IBAS,1)
          EIRT   = FACT*DSQRT(EXL(IBAS,1))
          EROOT  = DSQRT(PI/EIJ)**3
          TLS(IBAS,JBAS,1) = EIRT*EROOT*E11(M,1)
          TLS(IBAS,JBAS,3) = EIRT*EROOT*E21(M,1)
          TLS(IBAS,JBAS,2) =-PHS*DCONJG(TLS(IBAS,JBAS,3))
          TLS(IBAS,JBAS,4) = PHS*DCONJG(TLS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     GENERATE LS MATRICES FROM THE ABOVE SL MATRICES
      M = 0
      DO JBAS=1,NBAS(2)
        DO IBAS=1,NBAS(1)
          M = M + 1
          CTMP1 = DCONJG(TLS(IBAS,JBAS,1))
          CTMP2 = DCONJG(TLS(IBAS,JBAS,2))
          CTMP3 = DCONJG(TLS(IBAS,JBAS,3))
          CTMP4 = DCONJG(TLS(IBAS,JBAS,4))
C
          TLS(IBAS,JBAS,1) = CTMP1
          TLS(IBAS,JBAS,2) = CTMP3
          TLS(IBAS,JBAS,3) = CTMP2
          TLS(IBAS,JBAS,4) = CTMP4
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF HNUC AND HKIN FOR THIS BLOCK.          C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL OVERLAP BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
C
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVLP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVLP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVLP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
C
            OVLP(JL1+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL1+IBAS) = DCONJG(OVLP(IL1+IBAS,JL2+JBAS))
            OVLP(JL1+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL1+JBAS))
            OVLP(JL2+JBAS,IL2+IBAS) = DCONJG(OVLP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     LL NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HNUC(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            HNUC(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            HNUC(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            HNUC(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            HNUC(JL1+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL2+JBAS))
            HNUC(JL1+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            HNUC(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            HNUC(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            HNUC(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            HNUC(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            HNUC(JL1+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL2+JBAS))
            HNUC(JL1+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC HAMILTONIAN HAS A KINETIC MATRIX IN THE LL BLOCK
      IF(HMLT.EQ.'NORL') THEN
C
C       LL KINETIC BLOCKS
        IF(IL1.GT.JL1) THEN
          DO JBAS=1,NBAS(2)
            DO IBAS=1,NBAS(1)
              HKIN(IL1+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,1)
              HKIN(IL1+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,2)
              HKIN(IL2+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,3)
              HKIN(IL2+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,4)
C
              HKIN(JL1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL2+JBAS))
              HKIN(JL1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL2+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
        IF(IL1.EQ.JL1) THEN
          DO JBAS=1,NBAS(2)
            DO IBAS=JBAS,NBAS(1)
              HKIN(IL1+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,1)
              HKIN(IL1+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,2)
              HKIN(IL2+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,3)
              HKIN(IL2+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,4)
C
              HKIN(JL1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL2+JBAS))
              HKIN(JL1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL2+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
        GOTO 600
C
      ENDIF
C
C     SS OVERLAP BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
C
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVLP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVLP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVLP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVLP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
C
            OVLP(JS1+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS1+IBAS) = DCONJG(OVLP(IS1+IBAS,JS2+JBAS))
            OVLP(JS1+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS1+JBAS))
            OVLP(JS2+JBAS,IS2+IBAS) = DCONJG(OVLP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SS NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HNUC(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            HNUC(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            HNUC(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            HNUC(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            HNUC(JS1+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS2+JBAS))
            HNUC(JS1+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            HNUC(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            HNUC(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            HNUC(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            HNUC(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            HNUC(JS1+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS2+JBAS))
            HNUC(JS1+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     LS BLOCKS
      IF(IL1.GE.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HKIN(IL1+IBAS,JS1+JBAS) = TLS(IBAS,JBAS,1)
            HKIN(IL1+IBAS,JS2+JBAS) = TLS(IBAS,JBAS,2)
            HKIN(IL2+IBAS,JS1+JBAS) = TLS(IBAS,JBAS,3)
            HKIN(IL2+IBAS,JS2+JBAS) = TLS(IBAS,JBAS,4)
C
            HKIN(JS1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JS1+JBAS))
            HKIN(JS2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JS2+JBAS))
            HKIN(JS1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JS1+JBAS))
            HKIN(JS2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HKIN(IS1+IBAS,JL1+JBAS) = TSL(IBAS,JBAS,1)
            HKIN(IS1+IBAS,JL2+JBAS) = TSL(IBAS,JBAS,2)
            HKIN(IS2+IBAS,JL1+JBAS) = TSL(IBAS,JBAS,3)
            HKIN(IS2+IBAS,JL2+JBAS) = TSL(IBAS,JBAS,4)
C
            HKIN(JL1+JBAS,IS1+IBAS) = DCONJG(HKIN(IS1+IBAS,JL1+JBAS))
            HKIN(JL2+JBAS,IS1+IBAS) = DCONJG(HKIN(IS1+IBAS,JL2+JBAS))
            HKIN(JL1+JBAS,IS2+IBAS) = DCONJG(HKIN(IS2+IBAS,JL1+JBAS))
            HKIN(JL2+JBAS,IS2+IBAS) = DCONJG(HKIN(IS2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
C     END LOOPS OVER BASIS PAIRS A,B
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE VACPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             VV    VV    AA     CCCCCC  PPPPPPP  LL                   C
C             VV    VV   AAAA   CC    CC PP    PP LL                   C
C             VV    VV  AA  AA  CC       PP    PP LL                   C
C             VV    VV AA    AA CC       PP    PP LL                   C
C              VV  VV  AAAAAAAA CC       PPPPPPP  LL                   C
C               VVVV   AA    AA CC    CC PP       LL                   C
C                VV    AA    AA  CCCCCC  PP       LLLLLLLL             C
C                                                                      C
C -------------------------------------------------------------------- C
C  VACPL CONSTRUCTS A FULL SET OF MULTI-CENTRE VACUUM POLARISATION     C
C  MATRIX ELEMENTS BASED ON POLARISATION OF NUCLEI AND THE UEHLING     C
C  INTERACTION TO FIRST ORDER.                                         C
C -------------------------------------------------------------------- C
C ▶ THE `LL' COMPONENT OF THIS CAN BE USED IN THE 'NORL' TREE OPTION,  C
C   BUT THE INPUT DECK ASSUMES THAT 'DHFQ' IMPLIES RELATIVISTIC.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VLL(MBS,MBS,4),VSS(MBS,MBS,4)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BQED/RUEH(MCT,3),FUEH(MCT,MFT),XUEH(MCT,MFT),NUEH(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     INITIALISE STORAGE MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          VUEH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IM=1,4
            VLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAMLL VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER NUCLEAR CENTRES WITH A UEHLING POTENTIAL
          DO IZ=1,NCNT
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
            RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C           LOOP OVER TERMS IN THE UEHLING POTENTIAL EXPANSION FOR IZ
            DO IFT=1,NUEH(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XUEH(IZ,IFT)
              FC = FUEH(IZ,IFT)
C
C             GAUSSIAN COMPONENT OF HGTF
              ESM = EIJ+XI
              E12 = PI12/DSQRT(ESM)
              E32 = E12*E12*E12
              ECP = EIJ*XI/ESM
              GSS = DEXP(-ECP*RSQ)
C
C             LOOP OVER ALL {A,B,C}
              DO ITUV=1,NTUVLL
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(ITUV))
                HBETA = HERMITE(ECP,RPY,IB(ITUV))
                HGAMA = HERMITE(ECP,RPZ,IC(ITUV))
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH*HBETA*HGAMA*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,ITUV)*HABC
                TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,ITUV)*HABC
C
              ENDDO
C
C
C           END LOOP OVER UEHLING EXPANSION FOR IZ
            ENDDO
C
C         END LOOP OVER CENTRES IZ
          ENDDO
C
C         MATRIX ELEMENTS
          VLL(IBAS,JBAS,1) = TA1
          VLL(IBAS,JBAS,3) = TA2
          VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
          VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAMSS VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
          PY = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
          PZ = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER NUCLEAR CENTRES WITH A UEHLING POTENTIAL
          DO IZ=1,NCNT
C
C           COORDINATES OF EVALUATION
            RPX = PX-BXYZ(1,IZ)
            RPY = PY-BXYZ(2,IZ)
            RPZ = PZ-BXYZ(3,IZ)
            RSQ = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C           LOOP OVER TERMS IN THE UEHLING POTENTIAL EXPANSION FOR IZ
            DO IFT=1,NUEH(IZ)
C
C             GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
              XI = XUEH(IZ,IFT)
              FC = FUEH(IZ,IFT)
C
C             GAUSSIAN COMPONENT OF HGTF
              ESM = EIJ+XI
              E12 = PI12/DSQRT(ESM)
              E32 = E12*E12*E12
              ECP = EIJ*XI/ESM
              GSS = DEXP(-ECP*RSQ)
C
C             LOOP OVER ALL {A,B,C}
              DO ITUV=1,NTUVSS
C
C               CARTESIAN HERMITE POLYNOMIAL VALUES
                HALPH = HERMITE(ECP,RPX,IA(ITUV))
                HBETA = HERMITE(ECP,RPY,IB(ITUV))
                HGAMA = HERMITE(ECP,RPZ,IC(ITUV))
C
C               HGTF IS A PRODUCT OF THESE
                HABC = HALPH*HBETA*HGAMA*GSS
C
C               MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
                TA1 = TA1 + ZNUC(IZ)*FC*E32*E11(M,ITUV)*HABC
                TA2 = TA2 + ZNUC(IZ)*FC*E32*E21(M,ITUV)*HABC
C
              ENDDO
C
C
C           END LOOP OVER UEHLING EXPANSION FOR IZ
            ENDDO
C
C         END LOOP OVER CENTRES IZ
          ENDDO
C
C         MATRIX ELEMENTS
          VSS(IBAS,JBAS,1) = TA1
          VSS(IBAS,JBAS,3) = TA2
          VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
          VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF VUEH FOR THIS BLOCK.                   C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL UEHLING INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VUEH(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VUEH(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VUEH(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VUEH(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VUEH(JL1+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL2+JBAS))
            VUEH(JL1+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VUEH(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VUEH(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VUEH(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VUEH(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VUEH(JL1+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL2+JBAS))
            VUEH(JL1+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
C
C     SS UEHLING INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VUEH(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VUEH(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VUEH(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VUEH(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VUEH(JS1+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS2+JBAS))
            VUEH(JS1+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VUEH(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VUEH(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VUEH(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VUEH(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VUEH(JS1+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS2+JBAS))
            VUEH(JS1+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     END LOOPS OVER BASIS PAIRS A,B
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE COULOMB
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    CCCCCC   OOOOOO  UU    UU LL      OOOOOO  MM       MM BBBBBBB     C
C   CC    CC OO    OO UU    UU LL     OO    OO MMM     MMM BB    BB    C
C   CC       OO    OO UU    UU LL     OO    OO MMMM   MMMM BB    BB    C
C   CC       OO    OO UU    UU LL     OO    OO MM MM MM MM BBBBBBB     C
C   CC       OO    OO UU    UU LL     OO    OO MM  MMM  MM BB    BB    C
C   CC    CC OO    OO UU    UU LL     OO    OO MM   M   MM BB    BB    C
C    CCCCCC   OOOOOO   UUUUUU  LLLLLLL OOOOOO  MM       MM BBBBBBB     C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB GENERATES ALL MANY-CENTRE ELECTRON REPULSION INTEGRALS IN   C
C  BATCHES AND ADDS THEM TO THE SCF CLOSED/OPEN-SHELL COULOMB MATRIX.  C
C  CALCULATIONS ARE MADE WITH A RELATIVISTIC MCMURCHIE-DAVIDSON SCHEME.C
C -------------------------------------------------------------------- C
C  TODO: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C     INCLUDE 'omp_lib.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),JQN(4)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP),ICNT(4),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,IQL,IQR
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(3),SHLV,ILEV
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TCVT,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     INTEGRAL SCREENING SENSITIVITY PARAMETER
      DATA SENS/1.0D-12/
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                        SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL ATOMIC CENTRES (USE INDEX 1000)                    C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
        ICNT(1) = ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,ICNTA
        ICNT(2) = ICNTB
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1000 ICNTC=1,NCNT
        ICNT(3) = ICNTC
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 1000 ICNTD=1,NCNT
        ICNT(4) = ICNTD
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTRE CONTRIBUTIONS (DEFER TO RACAH ALGEBRA ROUTINE)
      IF(MCNT.EQ.1.AND.RACAH1) THEN
        GOTO 1001
      ENDIF
Cc      
C      if(icnta.ne.icntb.or.icntc.ne.icntd) then
C        goto 1001
C      endif
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES (USE INDEX 2000)                C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
        JQN(1) = 2*IABS(KQN(1))-1
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
        JQN(2) = 2*IABS(KQN(2))-1
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
        JQN(3) = 2*IABS(KQN(3))-1
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
        JQN(4) = 2*IABS(KQN(4))-1
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       LQN PAIR PARITY (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
        IPARCD = MOD(LQN(3)+LQN(4),2)
C
C       LQN PAIR PARITY SELECTION RULE
        IF(IPARAB.NE.IPARCD) THEN
          GOTO 2001
        ENDIF
C
C       JQN TRIANGLE RULE CHECK FOR MULTIPOLE EXPANSION (ATOM-CENTRED)
        NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
        NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
        IF(NUI.GT.NUF) THEN
          GOTO 2001
        ENDIF
C
C       ADDITIONAL LQN SELECTION RULE PARITY ANALYSIS
        ISELK = 0
        DO NU=NUI,NUF
C
C         A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD (0 IF EVEN, 1 IF ODD)
          IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
          IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C         LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH EVEN
          IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) ISELK = 1
C
        ENDDO
        IF(ISELK.EQ.0) GOTO 2001
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| PROJECTIONS (INDEX 3000)                     C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1) THEN
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) GOTO 3003
        GOTO 3001
      ENDIF
3003  CONTINUE
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
        ISELM = 0
        DO ISGN1=1,2
          DO ISGN2=1,2
            DO ISGN3=1,2
              DO ISGN4=1,2
                MMJA = MQN(1)*((-1)**ISGN1)
                MMJB = MQN(2)*((-1)**ISGN2)
                MMJC = MQN(3)*((-1)**ISGN3)
                MMJD = MQN(4)*((-1)**ISGN4)
                IF(MMJA-MMJB.EQ.MMJD-MMJC) ISELM = 1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(ISELM.EQ.0) GOTO 3001
      ENDIF
C
C**********************************************************************C
C     IDENTIFICATION OF ERI SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     CALCULATE BLOCK INDICES FOR {ABCD} COMBINATIONS
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ1.LT.IQ2) GOTO 3001
      IF(IQ3.LT.IQ4) GOTO 3001
      IF(IQL.LT.IQR) GOTO 3001
C
      IF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 1
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL = IQR
        ITSCF = 2
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 3
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 4
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 5
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL = IQR
        ITSCF = 6
      ELSE
C       ALL OTHER CASES GENERATED BY THE ABOVE, SO SKIP
        GOTO 3001
      ENDIF
C
C     READ IN FLAG VALUES FROM ISCF DATA BLOCK
      DO IS=1,11
        IFLG(IS) = ISCF(IS,ITSCF)
      ENDDO
C
C     INCLUDE SPECIAL CASES FOR MATCHING BLOCKS
      IF(IQ2.EQ.IQ3) THEN
C       IQ2 = IQ3
        IF(ITSCF.EQ.1.OR.ITSCF.EQ.3.OR.ITSCF.EQ.4) THEN
          IFLG( 9) = 1
        ENDIF
      ENDIF
C
      IF(ITSCF.EQ.1) THEN
        IF(IQ1.EQ.IQ3) THEN
C         IQ1 = IQ3
          IFLG(10) = 1
        ELSEIF(IQ2.EQ.IQ4) THEN
C         IQ2 = IQ4
          IFLG(11) = 1
        ENDIF
      ENDIF
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND B: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
        NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
        NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDAB
        NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDAB
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR C AND D: T'T' = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDCD
        NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDCD
        ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDCD
        ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDCD
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = MAPTTTT(IT1,IT2)
C
C     STAGE 1: INCLUDE ONLY (LL|LL) REPULSION INTEGRALS
      IF(ILEV.EQ.1.AND.ITT.GT.1) THEN
        GOTO 4001
      ENDIF
C
C     STAGE 2: INCLUDE ONLY (LL|SS) AND (SS|LL) REPULSION INTEGRALS
      IF(ILEV.EQ.2.AND.ITT.GT.3) THEN
        GOTO 4001
      ENDIF
C
C     STAGE 3: INCLUDE ONLY TWO-CENTRE (SS|SS) REPULSION INTEGRALS
      IF(ILEV.EQ.3.AND.ITT.EQ.4) THEN
C
        IF(SSSSI3.AND.MCNT.EQ.3) THEN
          GOTO 4001
        ENDIF
        IF(SSSSI4.AND.MCNT.EQ.4) THEN
          GOTO 4001
        ENDIF
C
c        IF(MCNT.EQ.2) THEN
cC         DIRECT CHOICE
c          IF(ICNTA.EQ.ICNTB.AND.ICNTC.EQ.ICNTD) THEN
c            GOTO 4002
cC         EXCHANGE CHOICE
c          ELSEIF(ICNTA.EQ.ICNTD.AND.ICNTB.EQ.ICNTC) THEN
c            GOTO 4002
c          ENDIF
c          GOTO 4001
cC         TODO: THIS IS WHERE I WOULD EVALUATE THE POINT-COULOMB RESULTS
c4002      CONTINUE
C        ENDIF
      ENDIF
      
C      IF(ITT.NE.4) GOTO 4001
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      N2EB(MCNT,ITT) = N2EB(MCNT,ITT)+1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) TO CONSTRUCT GMAT/QMAT     C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL CPU_TIME(TI)
C
C     START OF PARALLEL REGION
C!$OMP PARALLEL DO COLLAPSE(2)
C!$OMP&  PRIVATE(RR,IBCH,IFLG)
C!$OMP&  SHARED(XYZ,KQN,MQN,EXL,NBAS,ITN)
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
          IF(SCHWRZ.AND.ITT.GT.1) THEN
            ITOG = 1
          ELSE
            ITOG = 0
          ENDIF
          itog = 0
C
          CALL SCHWARZ(GDSC,SENS,TC2S)
C
C         UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
          N2EI(MCNT,ITT) = N2EI(MCNT,ITT)+NBAS(3)*NBAS(4)
          N2ES(MCNT,ITT) = N2ES(MCNT,ITT)+NBAS(3)*NBAS(4)-MAXN
C
C         CONDITIONAL TO SKIP THIS BATCH
          IF(IBCH.EQ.1) THEN
C
C           GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
            CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C           MULTIPLY BY DENSITY ELEMENTS AND ADD TO GMAT/QMAT
            CALL CLMMAT(RR,IFLG,TCMC)
C
          ENDIF
C
        ENDDO
      ENDDO
C     END OF PARALLEL REGION
C!$OMP END PARALLEL DO
C
C     RECORD TIME AT END OF BATCH
      CALL CPU_TIME(TF)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + TF - TI
C
4001  CONTINUE
4000  CONTINUE
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL MATRICES BY CONJUGATION.            C
C**********************************************************************C
C
C     LOOP OVER LOWER TRIANGLE OF EACH TT' BLOCK
      DO J=1,NDIM-NSKP
        DO I=1,J
C
C         SMALL-COMPONENT ADDRESSES
          K = I+NSKP
          L = J+NSKP
C
C         SKIP DIAGONAL PARTS OF EACH SUB-BLOCK
          IF(LABICN(I).NE.LABICN(J)) GOTO 400
          IF(LABKQN(I).NE.LABKQN(J)) GOTO 400
          IF(IABS(LABMQN(I)).NE.IABS(LABMQN(J))) GOTO 400
          GOTO 401
400       CONTINUE
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LL BLOCK
          GDIR(I,J) = GDIR(I,J) + DCONJG(GDIR(J,I))
          GDIR(J,I) =             DCONJG(GDIR(I,J))
          GXCH(I,J) = GXCH(I,J) + DCONJG(GXCH(J,I))
          GXCH(J,I) =             DCONJG(GXCH(I,J))
C
C         IF HMLT = 'NORL' SKIP THE NEXT FEW CALCULATIONS
          IF(HMLT.EQ.'NORL') GOTO 401
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SS BLOCK
          GDIR(K,L) = GDIR(K,L) + DCONJG(GDIR(L,K))
          GDIR(L,K) =             DCONJG(GDIR(K,L))
          GXCH(K,L) = GXCH(K,L) + DCONJG(GXCH(L,K))
          GXCH(L,K) =             DCONJG(GXCH(K,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LS BLOCK
          GXCH(I,L) = GXCH(I,L) + DCONJG(GXCH(L,I))
          GXCH(L,I) =             DCONJG(GXCH(I,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SL BLOCK
          GXCH(K,J) = GXCH(K,J) + DCONJG(GXCH(J,K))
          GXCH(J,K) =             DCONJG(GXCH(K,J))
C
401       CONTINUE
        ENDDO
      ENDDO
C
C     OPEN-SHELL SPECIAL CASE
      IF(NOPN.EQ.0) GOTO 450
C
C     LOOP OVER LOWER TRIANGLE OF EACH TT' BLOCK
      DO J=1,NDIM-NSKP
        DO I=1,J
C
C         SMALL-COMPONENT ADDRESSES
          K = I+NSKP
          L = J+NSKP
C
C         SKIP DIAGONAL PARTS OF EACH SUB-BLOCK
          IF(LABICN(I).NE.LABICN(J)) GOTO 410
          IF(LABKQN(I).NE.LABKQN(J)) GOTO 410
          IF(IABS(LABMQN(I)).NE.IABS(LABMQN(J))) GOTO 410
          GOTO 402
410       CONTINUE
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LL BLOCK
          QDIR(I,J) = QDIR(I,J) + DCONJG(QDIR(J,I))
          QDIR(J,I) =             DCONJG(QDIR(I,J))
          QXCH(I,J) = QXCH(I,J) + DCONJG(QXCH(J,I))
          QXCH(J,I) =             DCONJG(QXCH(I,J))
C
C         IF HMLT = 'NORL' SKIP THE NEXT FEW CALCULATIONS
          IF(HMLT.EQ.'NORL') GOTO 402
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SS BLOCK
          QDIR(K,L) = QDIR(K,L) + DCONJG(QDIR(L,K))
          QDIR(L,K) =             DCONJG(QDIR(K,L))
          QXCH(K,L) = QXCH(K,L) + DCONJG(QXCH(L,K))
          QXCH(L,K) =             DCONJG(QXCH(K,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LS BLOCK
          QXCH(I,L) = QXCH(I,L) + DCONJG(QXCH(L,I))
          QXCH(L,I) =             DCONJG(QXCH(I,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SL BLOCK
          QXCH(K,J) = QXCH(K,J) + DCONJG(QXCH(J,K))
          QXCH(J,K) =             DCONJG(QXCH(K,J))
C
402       CONTINUE
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS
      DO J=1,NDIM
        DO I=1,NDIM
          QDIR(I,J) = ACFF*QDIR(I,J)
          QXCH(I,J) = BCFF*QXCH(I,J)
        ENDDO
      ENDDO
C
C     CLOSED-SHELL SKIP POINT
450   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ERI(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                        EEEEEEEE RRRRRRR  IIII                        C
C                        EE       RR    RR  II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEE   RR    RR  II                         C
C                        EE       RRRRRRR   II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEEEE RR    RR IIII                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ XYZ  - FULL SET OF CARTESIAN BASIS CENTERS.                       C
C  ▶ KQN  - FULL SET OF RELATIVISTIC LABELS.                           C
C  ▶ MQN  - FULL SET OF MAGNETIC QUANTUM NUMBERS (MAGNITUDE).          C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  ▶ EXL  - FULL LISTS OF EXPONENTS IN THE BLOCK.                      C
C  ▶ IBAS - 1ST BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ JBAS - 2ND BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ ITN  - COMPONENT OVERLAP (T,T') FOR CD. ITN(I) = {LL,LS,SL,SS}.   C
C  OUTPUT:                                                             C
C  ▶ RR   - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MEQ),IABR21(MEQ),IABI11(MEQ),IABI21(MEQ)
      DIMENSION ICDR11(MEQ),ICDR21(MEQ),ICDI11(MEQ),ICDI21(MEQ)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ),ECD11(MB2,MEQ),
     &           EAB21(MB2,MEQ),ECD21(MB2,MEQ)
C
      SAVE EAB11,EAB21,IABR11,IABI11,IABR21,IABI21
      SAVE ECD11,ECD21,ICDR11,ICDI11,ICDR21,ICDI21
      SAVE RCTTFL,IRCTTFL
C
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(3),SHLV,ILEV
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TCVT,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA SENS/1.0D-10/
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.1.AND.ITN(IT).NE.4) THEN
          WRITE(6, *) 'In ERI: illegal component overlaps in ITN.'
          WRITE(7, *) 'In ERI: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS A, B, C, D
      DO N=1,4
        IF(KQN(N).LT.0) THEN
          LQN(N) =-KQN(N)-1
        ELSE
          LQN(N) = KQN(N)
        ENDIF
      ENDDO
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                        SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTORS FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ(AB)-COEFFICIENTS
      IF(ITN(1).EQ.1) THEN
        LAMAB = LQN(1)+LQN(2)
      ELSEIF(ITN(1).EQ.4) THEN
        LAMAB = LQN(1)+LQN(2)+2
      ENDIF
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ(CD)-COEFFICIENTS
      IF(ITN(2).EQ.1) THEN
        LAMCD = LQN(3)+LQN(4)
      ELSEIF(ITN(2).EQ.4) THEN
        LAMCD = LQN(3)+LQN(4)+2
      ENDIF
C
C     VRS MAXIMUM LAMBDA LEVEL FOR CONTRACTED R-INTEGRAL BATCH
      LAMABCD = LAMAB+LAMCD
C
C     VRS MAXIMUM LAMBDA LEVEL FOR RCTTFL SAVED LIST (ONLY IF MCNT.GT.2)
      IF(.NOT.RCFILE.OR.HMLT.EQ.'NORL') THEN
        LAMABCDFL = LAMABCD
      ELSEIF(RCFILE.AND.HMLT.NE.'NORL') THEN
        IF(ILEV.EQ.1) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)
        ELSEIF(ILEV.EQ.2) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+2
        ELSEIF(ILEV.EQ.3) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+4
        ENDIF
      ENDIF
C
C     VRS TOTAL LENGTH OF EQ-COEFFICIENT LISTS AND R-INTEGRAL BATCH
      NTUVAB     = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD     = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD   = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
      NTUVABCDFL = (LAMABCDFL+1)*(LAMABCDFL+2)*(LAMABCDFL+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(EQFILE) THEN
        IF(ITN(1).EQ.1) THEN
          DO ITUV=1,NTUVAB
            IAD = IABLL + (ITUV-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
              EAB21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
            ENDDO
          ENDDO
        ELSEIF(ITN(1).EQ.4) THEN
          DO ITUV=1,NTUVAB
            IAD = IABSS + (ITUV-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
              EAB21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
            ENDDO
          ENDDO
        ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      ELSE
        IF(ITN(1).EQ.1) THEN
          CALL EQLLMK(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ELSEIF(ITN(1).EQ.4) THEN
          CALL EQSSMK(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.1) THEN
        TELL = TELL+TDM2-TDM1
      ELSEIF(ITN(1).EQ.4) THEN
        TESS = TESS+TDM2-TDM1
      ENDIF
C
C     SCREENING: TEST E(AB| -) COLUMNS OF CARTESIAN INDEX (T ,U ,V )
      DO IAB=1,NTUVAB
C
C       Re{E(AB|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          ERAB11 = DREAL(EAB11(M,IAB))
          SUM = SUM + DABS(ERAB11)
          IF(SUM.GT.SENS) THEN
            IABR11(IAB) = 1
            GOTO 101
          ENDIF
        ENDDO
        IABR11(IAB) = 0
101     CONTINUE
C
C       Im{E(AB|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          EIAB11 = DIMAG(EAB11(M,IAB))
          SUM = SUM + DABS(EIAB11)
          IF(SUM.GT.SENS) THEN
            IABI11(IAB) = 1
            GOTO 102
          ENDIF
        ENDDO
        IABI11(IAB) = 0
102     CONTINUE
C
C       Re{E(AB|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          ERAB21 = DREAL(EAB21(M,IAB))
          SUM = SUM + DABS(ERAB21)
          IF(SUM.GT.SENS) THEN
            IABR21(IAB) = 1
            GOTO 103
          ENDIF
        ENDDO
        IABR21(IAB) = 0
103     CONTINUE
C
C       Im{E(AB|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          EIAB21 = DIMAG(EAB21(M,IAB))
          SUM = SUM + DABS(EIAB21)
          IF(SUM.GT.SENS) THEN
            IABI21(IAB) = 1
            GOTO 104
          ENDIF
        ENDDO
        IABI21(IAB) = 0
104     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(EQFILE) THEN
        IF(ITN(2).EQ.1) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDLL + (ITUV-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ITUV)))
            DO M=1,MAXCD
              ECD11(M,ITUV) = Z*DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
              ECD21(M,ITUV) = Z*DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
            ENDDO
          ENDDO
        ELSEIF(ITN(2).EQ.4) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDSS + (ITUV-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ITUV)))
            DO M=1,MAXCD
              ECD11(M,ITUV) = Z*DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
              ECD21(M,ITUV) = Z*DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
            ENDDO
          ENDDO
        ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      ELSE
        IF(ITN(2).EQ.1) THEN
          CALL EQLLMK(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ELSEIF(ITN(2).EQ.4) THEN
          CALL EQSSMK(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(2).EQ.1) THEN
        TELL = TELL+TDM2-TDM1
      ELSEIF(ITN(2).EQ.4) THEN
        TESS = TESS+TDM2-TDM1
      ENDIF
C
C     SCREENING: TEST E(CD| -) COLUMNS OF CARTESIAN INDEX (T',U',V')
      DO ICD=1,NTUVCD
C
C       Re{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          ERCD11 = DREAL(ECD11(M,ICD))
          SUM = SUM + DABS(ERCD11)
          IF(SUM.GT.SENS) THEN
            ICDR11(ICD) = 1
            GOTO 201
          ENDIF
        ENDDO
        ICDR11(ICD) = 0
201     CONTINUE
C
C       Im{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          EICD11 = DIMAG(ECD11(M,ICD))
          SUM = SUM + DABS(EICD11)
          IF(SUM.GT.SENS) THEN
            ICDI11(ICD) = 1
            GOTO 202
          ENDIF
        ENDDO
        ICDI11(ICD) = 0
202     CONTINUE
C
C       Re{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          ERCD21 = DREAL(ECD21(M,ICD))
          SUM = SUM + DABS(ERCD21)
          IF(SUM.GT.SENS) THEN
            ICDR21(ICD) = 1
            GOTO 203
          ENDIF
        ENDDO
        ICDR21(ICD) = 0
203     CONTINUE
C
C       Im{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          EICD21 = DIMAG(ECD21(M,ICD))
          SUM = SUM + DABS(EICD21)
          IF(SUM.GT.SENS) THEN
            ICDI21(ICD) = 1
            GOTO 204
          ENDIF
        ENDDO
        ICDI21(ICD) = 0
204     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL CPU_TIME(T2)
      TCEC = TCEC + T2 - T1
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) FROM SCRATCH OR READ-IN          C
C**********************************************************************C
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     READ FROM LOCAL RC(AB|CD) FILE
      IF(RCFILE.AND.IRIJ(IBAS,JBAS).EQ.0) THEN
C
        CALL CPU_TIME(T1)
C
C       STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
        IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCDFL
C
C       READ RC(AB|CD) INTEGRALS FROM THIS STARTING POINT
        DO N=1,MAXN
          DO IABCD=1,NTUVABCD
            IAD = IADRTT + (IMAP(N)-1)*NTUVABCDFL + IABCD
            RC(N,IABCD) = RCTTFL(IAD)
          ENDDO
        ENDDO
C
C       STARTING ADDRESS FOR SCREENING FLAGS
        IADSCR = (IJ-1)*NTUVABCDFL
C
C       READ SCREENING FLAGS FROM THIS STARTING POINT
        DO IABCD=1,NTUVABCD
          IAD = IADSCR + IABCD
          IRC(IABCD) = IRCTTFL(IAD)
        ENDDO
C
C       RECORD TIME SPENT READING R-INTEGRALS
        CALL CPU_TIME(T2)
        TCRR = TCRR+T2-T1
C
C       NORMALISATION FACTORS FOR THIS BATCH
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.1) THEN
              N   = N+1
              EKL = EXL(KBAS,3)+EXL(LBAS,4)
              EMX = DSQRT(EIJ+EKL)*EIJ*EKL
              PRE(N) = 2.0D0*PI52/EMX
            ENDIF
          ENDDO
        ENDDO
C
      ENDIF
C
C     CALCULATE FROM SCRATCH
      IF(.NOT.RCFILE.OR.IRIJ(IBAS,JBAS).EQ.1) THEN
C
        CALL CPU_TIME(T1)
C
C       GAUSSIAN OVERLAP CENTRE
        PX = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
        PY = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
        PZ = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C       AUXILLIARY DATA FOR RMAKE ROUTINE
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF((RCFILE.AND.IRIJ(IBAS,JBAS).EQ.1)
     &                         .OR.(.NOT.RCFILE.AND.ISCR(M).EQ.1)) THEN
              N   = N+1
              EKL = EXL(KBAS,3)+EXL(LBAS,4)
              EMX = DSQRT(EIJ+EKL)*EIJ*EKL
              APH(N) = EIJ*EKL/(EIJ+EKL)
              PRE(N) = 2.0D0*PI52/EMX
              QX = (XYZ(1,3)*EXL(KBAS,3) + XYZ(1,4)*EXL(LBAS,4))/EKL
              QY = (XYZ(2,3)*EXL(KBAS,3) + XYZ(2,4)*EXL(LBAS,4))/EKL
              QZ = (XYZ(3,3)*EXL(KBAS,3) + XYZ(3,4)*EXL(LBAS,4))/EKL
              PQ(N,1) = QX-PX
              PQ(N,2) = QY-PY
              PQ(N,3) = QZ-PZ
            ENDIF
          ENDDO
        ENDDO
C
C       EXTEND MAXN IF GENERATING A FULL SET OF INTEGRALS
        MAXN = MAXCD
C
C       GENERATE R-INTEGRALS
        CALL RMAKE(RC,PQ,APH,MAXN,LAMABCDFL)
C
C       SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
        DO IABCDFL=1,NTUVABCDFL
C
C         SUM OF RC(AB|CD) MAGNITUDES
          SUM = 0.0D0
          DO N=1,MAXN
            SUM = SUM + DABS(RC(N,IABCDFL))
            IF(SUM.GT.SENS) THEN
              IRC(IABCDFL) = 1
              GOTO 301
            ENDIF
          ENDDO
          IRC(IABCDFL) = 0
301       CONTINUE
C
        ENDDO
C
C       SAVE THIS SET TO APPROPRIATE CLASS ADDRESS
        IF(RCFILE) THEN
C
C         TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
          ILIM = IJ*NBAS(3)*NBAS(4)*NTUVABCDFL
C
          IF(ILIM.GT.20*MFL) THEN
C           OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
            WRITE(6, *) 'In ERI: RCTT words exceed allocated limit.'
            WRITE(7, *) 'In ERI: RCTT words exceed allocated limit.'
            GOTO 300
          ELSE
C           DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
            IRIJ(IBAS,JBAS) = 0
          ENDIF
C
C         STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
          IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCDFL

C         COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
          DO N=1,MAXN
            DO IABCDFL=1,NTUVABCDFL
              IAD = IADRTT + (N-1)*NTUVABCDFL + IABCDFL
              RCTTFL(IAD)  = RC(N,IABCDFL)
            ENDDO
          ENDDO
C
C         STARTING ADDRESS FOR SCREENING FLAGS
          IADSCR = (IJ-1)*NTUVABCDFL
C
C         COPY SCREENING MARKERS TO A SAVED LIST
          DO IABCDFL=1,NTUVABCDFL
            IAD = IADSCR + IABCDFL
            IRCTTFL(IAD) = IRC(IABCDFL)
          ENDDO
C
C         SHORTEN THE CURRENT RC LIST WITH IMAP FROM SCREENING
          M = 0
          N = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              IF(ISCR(M).EQ.1) THEN
                N      = N+1
                PRE(N) = PRE(M)
                DO IABCD=1,NTUVABCD
                  RC(N,IABCD) = RC(M,IABCD)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
C
        ENDIF
300     CONTINUE
C
        CALL CPU_TIME(T2)
        TCRM = TCRM+T2-T1
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.1.AND.ITN(2).EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITN(1).EQ.4.AND.ITN(2).EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ELSE
        TRLS = TRLS+TDM2-TDM1
      ENDIF
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     TIME AT START OF FIRST CONTRACTION
      CALL CPU_TIME(T1)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) PASSES SCREENING CONDITION
        IF(IABR11(IAB)+IABI11(IAB)+IABR21(IAB)+IABI21(IAB).EQ.0) THEN
          GOTO 401
        ENDIF
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO ICD=1,NTUVCD
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),IC(IAB)+IC(ICD))
C
C         SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
          IF(IRC(IRABCD).EQ.0) GOTO 402
C
C         SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
          IF(ICDR11(ICD)+ICDI11(ICD)+ICDR21(ICD)+ICDI21(ICD).EQ.0) THEN
            GOTO 402
          ENDIF
C
C         CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
          IF(ISYM.EQ.1.AND.IABR11(IAB).EQ.0) GOTO 411
          IF(ICDR11(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                       + DREAL(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
411       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
          IF(ISYM.EQ.1.AND.IABI11(IAB).EQ.0) GOTO 412
          IF(ICDI11(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                         + DIMAG(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
412       CONTINUE
C
C         CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
          IF(ISYM.EQ.1.AND.IABR21(IAB).EQ.0) GOTO 413
          IF(ICDR21(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                         + DREAL(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
413       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
          IF(ISYM.EQ.1.AND.IABI21(IAB).EQ.0) GOTO 414
          IF(ICDI21(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                         + DIMAG(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
414       CONTINUE
C
C         SKIP POINT FOR RC(AB|CD) SCREENING
402       CONTINUE
C
C       END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
        ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION
      CALL CPU_TIME(T2)
      TCC1 = TCC1+T2-T1
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB = ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD = ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 1) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 4) = PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,16) = PABCD*DCONJG(RR(N, 1))
        RR(N,13) = PABCD*DCONJG(RR(N, 4))
      ENDDO
C
      IF(ISYM.EQ.1) GOTO 501
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 3) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 2) =-PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,14) =-PABCD*DCONJG(RR(N, 3))
        RR(N,15) =-PABCD*DCONJG(RR(N, 2))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 9) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 8) =-PABCD*DCONJG(RR(N, 9))
        RR(N, 5) =-PABCD*DCONJG(RR(N,12))
      ENDDO
C
501   CONTINUE
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) =     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) =-PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 6) = PABCD*DCONJG(RR(N,11))
        RR(N, 7) = PABCD*DCONJG(RR(N,10))
      ENDDO
C
C     TIME AT END OF SECOND CONTRACTION
      CALL CPU_TIME(T3)
      TCC2 = TCC2+T3-T2
C
C**********************************************************************C
C     COULOMB INTEGRAL BATCH NOW FULLY CONSTRUCTED                     C
C**********************************************************************C
C
C     INCLUDE THE R-INTEGRAL NORMALISATION FACTOR
      DO N=1,MAXN
        DO ITG=1,16
          RR(N,ITG) = PRE(N)*RR(N,ITG)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE CLMMAT(RR,IFLG,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       CCCCCC  LL       MM       MM MM       MM    AA   TTTTTTTT      C
C      CC    CC LL       MMM     MMM MMM     MMM   AAAA     TT         C
C      CC       LL       MMMM   MMMM MMMM   MMMM  AA  AA    TT         C
C      CC       LL       MM MM MM MM MM MM MM MM AA    AA   TT         C
C      CC       LL       MM  MMM  MM MM  MMM  MM AAAAAAAA   TT         C
C      CC    CC LL       MM   M   MM MM   M   MM AA    AA   TT         C
C       CCCCCC  LLLLLLLL MM       MM MM       MM AA    AA   TT         C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMMAT MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF COULOMB MATRICES.     C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO ERI):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C  ▶ NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C  ▶ IFLG(11)   - INTEGRAL SYMMETRY FLAGS.                             C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION IFLG(11),NBAS(4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,IQL,IQR
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ALPH,BETA,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                        SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS...                                    C
C**********************************************************************C
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS   ( MA, MB| MD, MC) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T1 T1,T2 T2}
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 101
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 101
C
            GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENT(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENT(NC2+KBAS,ND2+LBAS)
C
101         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES G^{T1 T1,T2 T2}
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 102
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 102
C
              GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENT(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENT(ND2+LBAS,NC2+KBAS)
C
102         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T2 T2,T1 T1}
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 103
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 103
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENT(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENT(NA2+IBAS,NB2+JBAS)
C
103         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T2 T2,T1 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 104
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 104
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENT(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENT(NB2+JBAS,NA2+IBAS)
C
104         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T1 T2,T2 T1}
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 105
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 105
C
            GXCH(NA1+IBAS,ND1+LBAS) = GXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENT(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND2+LBAS) = GXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENT(NC2+KBAS,NB2+JBAS)
C
105         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T1 T2,T2 T1}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 106
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 106
C
            GXCH(NA1+IBAS,NC1+KBAS) = GXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENT(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC2+KBAS) = GXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENT(ND2+LBAS,NB2+JBAS)
C
106         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T1 T2,T2 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 107
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 107
C
            GXCH(NB1+JBAS,ND1+LBAS) = GXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENT(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND2+LBAS) = GXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENT(NC2+KBAS,NA2+IBAS)
C
107         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 08:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MC| MD, MA) =         ( MB, MA| MD, MC)
C     CALCULATES G^{T1 T2,T2 T1}            = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 108
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 108
C
            GXCH(NB1+JBAS,NC1+KBAS) = GXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENT(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENT(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC2+KBAS) = GXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENT(ND2+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENT(ND1+LBAS,NA1+IBAS)
C
108         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T2 T1,T1 T2}
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 109
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 109
C
            GXCH(NC1+KBAS,NB1+JBAS) = GXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENT(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB2+JBAS) = GXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENT(NA2+IBAS,ND2+LBAS)
C
109         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T2 T1,T1 T2}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 110
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 110
C
            GXCH(NC1+KBAS,NA1+IBAS) = GXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENT(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA2+IBAS) = GXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENT(NB2+JBAS,ND2+LBAS)
C
110         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T2 T1,T1 T2}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 111
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 111
C
            GXCH(ND1+LBAS,NB1+JBAS) = GXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENT(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB2+JBAS) = GXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENT(NA2+IBAS,NC2+KBAS)
111         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ISYM.EQ.1) GOTO 200
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS   ( MA, MB| MD, MC) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T1 T1,T2 T2}
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 201
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 201
C
            GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENT(NC2+KBAS,ND1+LBAS)
C
            GDIR(NA1+IBAS,NB2+JBAS) = GDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENT(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB1+JBAS) = GDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENT(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,14)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENT(NC2+KBAS,ND1+LBAS)
C
201         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES G^{T1 T1,T2 T2}
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 202
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 202
C
              GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENT(ND2+LBAS,NC1+KBAS)
C
              GDIR(NA1+IBAS,NB2+JBAS) = GDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENT(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB1+JBAS) = GDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENT(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,14)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENT(ND2+LBAS,NC1+KBAS)
C
202         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T2 T2,T1 T1}
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 203
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 203
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENT(NA2+IBAS,NB1+JBAS)
C
            GDIR(NC1+KBAS,ND2+LBAS) = GDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENT(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND1+LBAS) = GDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENT(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 8)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENT(NA2+IBAS,NB1+JBAS)
C
203         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T2 T2,T1 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 204
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 204
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENT(NB2+JBAS,NA1+IBAS)
C
            GDIR(NC1+KBAS,ND2+LBAS) = GDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENT(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND1+LBAS) = GDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENT(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 8)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENT(NB2+JBAS,NA1+IBAS)
C
204         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T1 T2,T2 T1}
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 205
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 205
C
            GXCH(NA1+IBAS,ND1+LBAS) = GXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENT(NC2+KBAS,NB1+JBAS)
C
            GXCH(NA1+IBAS,ND2+LBAS) = GXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENT(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND1+LBAS) = GXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENT(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND2+LBAS) = GXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENT(NC2+KBAS,NB1+JBAS)
C
205         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T1 T2,T2 T1}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 206
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 206
C
            GXCH(NA1+IBAS,NC1+KBAS) = GXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENT(ND2+LBAS,NB1+JBAS)
C
            GXCH(NA1+IBAS,NC2+KBAS) = GXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENT(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC1+KBAS) = GXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENT(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC2+KBAS) = GXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENT(ND2+LBAS,NB1+JBAS)
C
206         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T1 T2,T2 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 207
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 207
C
            GXCH(NB1+JBAS,ND1+LBAS) = GXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENT(NC2+KBAS,NA1+IBAS)
C
            GXCH(NB1+JBAS,ND2+LBAS) = GXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENT(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND1+LBAS) = GXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENT(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND2+LBAS) = GXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENT(NC2+KBAS,NA1+IBAS)
C
207         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 08:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MC| MD, MA) =         ( MB, MA| MD, MC)
C     CALCULATES G^{T1 T2,T2 T1}            = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 208
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 208
C
            GXCH(NB1+JBAS,NC1+KBAS) = GXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENT(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENT(ND2+LBAS,NA1+IBAS)
C
            GXCH(NB1+JBAS,NC2+KBAS) = GXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENT(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENT(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENT(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENT(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC1+KBAS) = GXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENT(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENT(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENT(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENT(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC2+KBAS) = GXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENT(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENT(ND2+LBAS,NA1+IBAS)
C
208         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES G^{T2 T1,T1 T2}
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 209
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 209
C
            GXCH(NC1+KBAS,NB1+JBAS) = GXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENT(NA2+IBAS,ND1+LBAS)
C
            GXCH(NC1+KBAS,NB2+JBAS) = GXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENT(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB1+JBAS) = GXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENT(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB2+JBAS) = GXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENT(NA2+IBAS,ND1+LBAS)
C
209         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES G^{T2 T1,T1 T2}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 210
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 210
C
            GXCH(NC1+KBAS,NA1+IBAS) = GXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENT(NB2+JBAS,ND1+LBAS)
C
            GXCH(NC1+KBAS,NA2+IBAS) = GXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENT(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA1+IBAS) = GXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENT(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA2+IBAS) = GXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENT(NB2+JBAS,ND1+LBAS)
C
210         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T2 T1,T1 T2}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 211
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 211
C
            GXCH(ND1+LBAS,NB1+JBAS) = GXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENT(NA2+IBAS,NC1+KBAS)
C
            GXCH(ND1+LBAS,NB2+JBAS) = GXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENT(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB1+JBAS) = GXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENT(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB2+JBAS) = GXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENT(NA2+IBAS,NC1+KBAS)
C
211         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
200   CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS...                                      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5000
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS   ( MA, MB| MD, MC) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T1 T1,T2 T2}
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 301
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 301
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,ND2+LBAS)
C
301         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES Q^{T1 T1,T2 T2}
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 302
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 302
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NC2+KBAS)
C
302         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T2 T2,T1 T1}
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 303
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 303
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,NB2+JBAS)
C
303         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T2 T2,T1 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 304
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 304
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,NA2+IBAS)
C
304         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T1 T2,T2 T1}
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 305
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 305
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,NB2+JBAS)
C
305         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T1 T2,T2 T1}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 306
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 306
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NB2+JBAS)
C
306         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T1 T2,T2 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 307
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 307
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NC2+KBAS,NA2+IBAS)
C
307         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 08:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MC| MD, MA) =         ( MB, MA| MD, MC)
C     CALCULATES Q^{T1 T2,T2 T1}            = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 308
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 308
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENO(ND2+LBAS,NA2+IBAS)
C
308         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T2 T1,T1 T2}
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 309
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 309
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,ND2+LBAS)
C
309         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T2 T1,T1 T2}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 310
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 310
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,ND2+LBAS)
C
310         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T2 T1,T1 T2}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 311
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 311
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(NA2+IBAS,NC2+KBAS)
C
311         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ISYM.EQ.1) GOTO 400
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS   ( MA, MB| MD, MC) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T1 T1,T2 T2}
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 401
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 401
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,ND1+LBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,ND1+LBAS)
C
401        CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES Q^{T1 T1,T2 T2}
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 402
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 402
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NC1+KBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NC1+KBAS)
C
402         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T2 T2,T1 T1}
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 403
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 403
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,NB1+JBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,NB1+JBAS)
C
403         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T2 T2,T1 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 404
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 404
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,NA1+IBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,NA1+IBAS)
C
404         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T1 T2,T2 T1}
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 405
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 405
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,ND2+LBAS) = QXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND1+LBAS) = QXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,NB1+JBAS)
C
405         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES Q^{T1 T2,T2 T1}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 406
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 406
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,NC2+KBAS) = QXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC1+KBAS) = QXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NB1+JBAS)
C
406         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T1 T2,T2 T1}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 407
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 407
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NC2+KBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,ND2+LBAS) = QXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND1+LBAS) = QXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NC2+KBAS,NA1+IBAS)
C
407         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 08:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MC| MD, MA) =         ( MB, MA| MD, MC)
C     CALCULATES Q^{T1 T2,T2 T1}            = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 408
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 408
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENO(ND2+LBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,NC2+KBAS) = QXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC1+KBAS) = QXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENO(ND2+LBAS,NA1+IBAS)
C
408         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES Q^{T2 T1,T1 T2}
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 409
            N = N+1
            IF(IMTX(M,9).EQ.0) GOTO 409
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NB2+JBAS) = QXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB1+JBAS) = QXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,ND1+LBAS)
C
409         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES Q^{T2 T1,T1 T2}            = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 410
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 410
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NA2+IBAS) = QXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA1+IBAS) = QXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,ND1+LBAS)
C
410         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES G^{T2 T1,T1 T2}            =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 411
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 411
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(NA2+IBAS,NC1+KBAS)
C
            QXCH(ND1+LBAS,NB2+JBAS) = QXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB1+JBAS) = QXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(NA2+IBAS,NC1+KBAS)
C
411         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     SKIP POINT FOR LINEAR BATCH
400   CONTINUE
C
C     SKIP POINT FOR CLOSED SYSTEMS
5000  CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
C
C
      SUBROUTINE VISSCHR
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       VV    VV IIII SSSSSS   SSSSSS   CCCCCC  HH    HH RRRRRRR       C
C       VV    VV  II SS    SS SS    SS CC    CC HH    HH RR    RR      C
C       VV    VV  II SS       SS       CC       HH    HH RR    RR      C
C       VV    VV  II  SSSSSS   SSSSSS  CC       HHHHHHHH RR    RR      C
C        VV  VV   II       SS       SS CC       HH    HH RRRRRRR       C
C         VVVV    II SS    SS SS    SS CC    CC HH    HH RR    RR      C
C          VV    IIII SSSSSS   SSSSSS   CCCCCC  HH    HH RR    RR      C
C                                                                      C
C -------------------------------------------------------------------- C
C  VISSCHR EVALUATES ALL MULTI-CENTER ELEMENTS OF THE COULOMB MATRIX   C
C  WHICH INVOLVE A SMALL-SMALL DENSITY FRAGMENT ON ONE NUCLEAR CENTRE. C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION SLL(MBS,MBS),SSS(MBS,MBS),RN(MBS*MBS,4),EXL0(MBS)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
      DIMENSION QLL(MCT),QSS(MCT)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VLL(MBS,MBS,4),VSS(MBS,MBS,4)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     REASONS TO SKIP THIS ROUTINE
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'NORL') THEN
        RETURN
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ATOM-CENTRED CHARGES BY COMPONENT TYPE                           C
C**********************************************************************C
C
C     EVALUATE EFFECTIVE SMALL-COMPONENT CHARGES, QSS
      DO IZ=1,NCNT
C
C       INITIALISE THE COUNTER
        QSS(IZ) = 0.0D0
C
C       LOOP OVER ALL SYMMETRY TYPES ON CENTRE IZ
        DO K0=1,NKAP(IZ)
C
C         QUANTUM NUMBERS FOR THIS BLOCK
          KQN0 = KAPA(K0,IZ)
          IF(KQN0.LT.0) THEN
            LQN0 =-KQN0-1
          ELSE
            LQN0 = KQN0
          ENDIF
          RL0 = DFLOAT(LQN0)
C
C         BASIS EXPONENTS FOR THIS BLOCK
          NBAS0 = NFNC(LQN0,IZ)
          DO IBAS=1,NBAS0
            EXL0(IBAS) = BEXL(IBAS,LQN0,IZ)
            EXL0(IBAS) = BEXL(IBAS,LQN0,IZ)
          ENDDO
C
C         GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
          CALL RNORM0(RN,EXL0,NBAS0,LQN0)
C
C         LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
          M = 0
          DO IBAS=1,NBAS0
            EI = EXL0(IBAS)
            DO JBAS=1,NBAS0
              M   = M+1
              EJ  = EXL0(JBAS)
              EIJ = EI+EJ
              EPR = EI*EJ
              T32 = RL0+1.5D0
              T52 = RL0+2.5D0
              E32 = EIJ**T32
              E52 = EIJ**T52
              SLL(IBAS,JBAS) = 0.5D0*RN(M,1)*GAMHLF(2*LQN0+3)/E32
              SSS(IBAS,JBAS) = 2.0D0*RN(M,3)*GAMHLF(2*LQN0+5)*EPR/E52
            ENDDO
          ENDDO
C
C         LOOP OVER ALL MQN TYPES FOR THIS KQN
          DO M0=1,IABS(KQN0)
C
C           2*MQN0 VALUE
            MQN0 = 2*M0-1
C
C           RELEVANT COMPONENT OFFSETS
            IL1 = LRGE(IZ,K0,MQN0  )
            IL2 = LRGE(IZ,K0,MQN0+1)
C
            IS1 = IL1+NSKP
            IS2 = IL2+NSKP
C
C           ADD TO COUNTERS
            DO IBAS=1,NBAS0
              DO JBAS=1,NBAS0
C
                QLL(IZ) = QLL(IZ)
     &                  + DENT(IL1+IBAS,IL1+JBAS)*SLL(IBAS,JBAS)
     &                  + DENT(IL2+IBAS,IL2+JBAS)*SLL(IBAS,JBAS)
C
                QSS(IZ) = QSS(IZ)
     &                  + DENT(IS1+IBAS,IS1+JBAS)*SSS(IBAS,JBAS)
     &                  + DENT(IS2+IBAS,IS2+JBAS)*SSS(IBAS,JBAS)
C
              ENDDO
            ENDDO
C
C         END LOOP OVER MQN TYPES
          ENDDO
C
C       END LOOP OVER SYMMETRY TYPES
        ENDDO
C
C     END LOOP OVER CENTRES IZ
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
      IF(ICNTA.NE.ICNTB) GOTO 1001
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXM = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IM=1,4
            VLL(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IM) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
c
      goto 567
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
          DO M=1,MAXM
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NO ATOM-CENTRED CONTRIBUTIONS
        IF(ICNTA.EQ.IZ.AND.ICNTB.EQ.IZ) GOTO 3101
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
          ENDDO
        ENDDO
C
CC       GAUSSIAN CHARGE OPTIONS
C        XI = BEXL(1,0,IZ)
C        FC = 1.0D0
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
C
C           OPTIONS FOR POINT CHARGE
            ESM    = EIJ+XI
            APH(M) = EIJ
            PNC(M) = 2.0D0*QSS(IZ)*PI/EIJ
CC
CC           OPTIONS FOR GAUSSIAN CHARGE
C            ESM    = EIJ+XI
C            APH(M) = EIJ*XI/ESM
C            PNC(M) = 2.0D0*PI*QSS(IZ)*FC*DSQRT(XI/ESM)/EIJ
CC
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXM,LAMLL)
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUM OF ELL0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVLL
              VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                         - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                         - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
            VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
            VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
C
3101    CONTINUE
C
C     END LOOP OVER CENTRES IZ
      ENDDO

567   continue
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(EQFILE) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
          DO M=1,MAXM
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ELSE
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NO ATOM-CENTRED CONTRIBUTIONS
        IF(ICNTA.EQ.IZ.AND.ICNTB.EQ.IZ) GOTO 3201
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1) + XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1) + XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1) + XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
          ENDDO
        ENDDO
C
CC       GAUSSIAN CHARGE OPTIONS
        XI = BEXL(1,0,IZ)
        FC = 1.0D0
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
C
C           OPTIONS FOR POINT CHARGE
c            ESM    = EIJ+XI
c            APH(M) = EIJ
c            PNC(M) = 2.0D0*QSS(IZ)*PI/EIJ
CC
CC           OPTIONS FOR GAUSSIAN CHARGE
            ESM    = EIJ+XI
            APH(M) = EIJ*XI/ESM
            PNC(M) = 2.0D0*PI*QSS(IZ)*FC*DSQRT(XI/ESM)/EIJ
CC
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXM,LAMSS)
        CALL CPU_TIME(TDM2)
        TRSS = TRSS + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUM OF ESS0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVSS
              VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                         - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                         - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
            VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
            VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
          ENDDO
        ENDDO
C
3201    CONTINUE
C
C     END LOOP OVER CENTRES IZ
      ENDDO
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF GDIR FOR THIS BLOCK.                   C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
      GOTO 568
C
C     LL NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            GDIR(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            GDIR(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            GDIR(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            GDIR(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            GDIR(JL1+JBAS,IL1+IBAS) = DCONJG(GDIR(IL1+IBAS,JL1+JBAS))
            GDIR(JL2+JBAS,IL1+IBAS) = DCONJG(GDIR(IL1+IBAS,JL2+JBAS))
            GDIR(JL1+JBAS,IL2+IBAS) = DCONJG(GDIR(IL2+IBAS,JL1+JBAS))
            GDIR(JL2+JBAS,IL2+IBAS) = DCONJG(GDIR(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            GDIR(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            GDIR(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            GDIR(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            GDIR(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            GDIR(JL1+JBAS,IL1+IBAS) = DCONJG(GDIR(IL1+IBAS,JL1+JBAS))
            GDIR(JL2+JBAS,IL1+IBAS) = DCONJG(GDIR(IL1+IBAS,JL2+JBAS))
            GDIR(JL1+JBAS,IL2+IBAS) = DCONJG(GDIR(IL2+IBAS,JL1+JBAS))
            GDIR(JL2+JBAS,IL2+IBAS) = DCONJG(GDIR(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF

568   CONTINUE
C
C     SS NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            GDIR(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            GDIR(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            GDIR(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            GDIR(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            GDIR(JS1+JBAS,IS1+IBAS) = DCONJG(GDIR(IS1+IBAS,JS1+JBAS))
            GDIR(JS2+JBAS,IS1+IBAS) = DCONJG(GDIR(IS1+IBAS,JS2+JBAS))
            GDIR(JS1+JBAS,IS2+IBAS) = DCONJG(GDIR(IS2+IBAS,JS1+JBAS))
            GDIR(JS2+JBAS,IS2+IBAS) = DCONJG(GDIR(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            GDIR(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            GDIR(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            GDIR(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            GDIR(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            GDIR(JS1+JBAS,IS1+IBAS) = DCONJG(GDIR(IS1+IBAS,JS1+JBAS))
            GDIR(JS2+JBAS,IS1+IBAS) = DCONJG(GDIR(IS1+IBAS,JS2+JBAS))
            GDIR(JS1+JBAS,IS2+IBAS) = DCONJG(GDIR(IS2+IBAS,JS1+JBAS))
            GDIR(JS2+JBAS,IS2+IBAS) = DCONJG(GDIR(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     END LOOPS OVER BASIS PAIRS A,B
3000  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BREIT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT               C
C               BB    BB RR    RR EE        II     TT                  C
C               BB    BB RR    RR EE        II     TT                  C
C               BBBBBBB  RR    RR EEEEEE    II     TT                  C
C               BB    BB RRRRRRR  EE        II     TT                  C
C               BB    BB RR    RR EE        II     TT                  C
C               BBBBBBB  RR    RR EEEEEEEE IIII    TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT GENERATES ALL MANY-CENTRE BREIT INTERACTION INTEGRALS IN      C
C  BATCHES AND ADDS THEM TO THE SCF CLOSED/OPEN-SHELL BREIT MATRIX.    C
C  CALCULATIONS ARE MADE WITH A RELATIVISTIC MCMURCHIE-DAVIDSON SCHEME.C
C -------------------------------------------------------------------- C
C  TODO: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
      CHARACTER*80 TITLE
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),JQN(4),MQN(4),NBAS(4)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP),ICNT(4),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,IQL,IQR
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/LSHF/SHLEV(3),SHLV,ILEV
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ALPH,BETA,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TCVT,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     INTEGRAL SCREENING SENSITIVITY PARAMETER
      DATA SENS/1.0D-12/
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                        SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TWO-ELECTRON COMPONENT OVERLAP INDEX (FOR USE IN BII)
      ITN(1) = 2
      ITN(2) = 2
      ITT = MAPTTTT(2,2)
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
            LENIQ               = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL NUCLEAR CENTRES (USE INDEX 1000)                   C
C**********************************************************************C

      IPAIRS = 0
      ITHREE = 0
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 1000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTRE CONTRIBUTIONS (DEFER TO RACAH ALGEBRA ROUTINE)
      IF(MCNT.EQ.1.AND.RACAH1) THEN
        GOTO 1001
      ENDIF
C
C     SKIP MULTI-CENTRE CONTRIBUTIONS IN STAGE 1
      IF(MCNT.NE.1.AND.ILEV.EQ.1) GOTO 1001
C
C     MAXIMUM NUMBER OF CENTRES ON GIVEN NUCLEUS
      IF(ICNTA.EQ.ICNTB.AND.ICNTC.EQ.ICNTD) THEN
        MPAIR  = 1
        IPAIRS = IPAIRS + 1
      ELSEIF(ICNTA.EQ.ICNTC.AND.ICNTB.EQ.ICNTD) THEN
        MPAIR  = 1
        IPAIRS = IPAIRS + 1
      ELSEIF(ICNTA.EQ.ICNTD.AND.ICNTC.EQ.ICNTB) THEN
        MPAIR  = 1
        IPAIRS = IPAIRS + 1
      ELSE
        MPAIR  = 0
        ITHREE = ITHREE + 1
      ENDIF
      
C
C     REPLACE BREIT INTERACTION WITH GAUNT ONLY
C     IF(GAUNT2.AND.MCNT.GT.1) THEN
      IF(GAUNT2.AND.MPAIR.EQ.0) THEN
        MGNT = 1
      ELSE
        MGNT = 0
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES (USE INDEX 2000)                C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
        JQN(1) = 2*IABS(KQN(1))-1
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
        JQN(2) = 2*IABS(KQN(2))-1
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
        JQN(3) = 2*IABS(KQN(3))-1
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
        JQN(4) = 2*IABS(KQN(4))-1
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
C
C       LQN PAIR PARITY (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
        IPARCD = MOD(LQN(3)+LQN(4),2)
C
C       LQN PAIR PARITY SELECTION RULE
        IF(IPARAB.NE.IPARCD) THEN
          GOTO 2001
        ENDIF
C
C       JQN TRIANGLE RULE CHECK FOR MULTIPOLE EXPANSION (ATOM-CENTRED)
        NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
        NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
        IF(NUI.GT.NUF) THEN
          GOTO 2001
        ENDIF
C
C       ADDITIONAL LQN SELECTION RULE PARITY ANALYSIS
        ISELK = 0
        DO NU=NUI,NUF
C
C         A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD (0 IF EVEN, 1 IF ODD)
          IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
          IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C         CASE 1: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH ODD (UNLESS NU=0)
          IF(IPARAB.EQ.1.AND.IPARCD.EQ.1.AND.NU.NE.0) ISELK = 1
C
C         CASE 2: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH EVEN
          IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) ISELK = 1
C
        ENDDO
        IF(ISELK.EQ.0) GOTO 2001
C
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| PROJECTIONS (INDEX 3000)                     C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IEAB  = 1
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      IECD  = 1
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1) THEN
        ISELM = 0
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) ISELM = 1
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) ISELM = 1
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) ISELM = 1
        IF(ISELM.EQ.0) GOTO 3001
      ENDIF
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
        ISELM = 0
        DO ISGN1=1,2
          DO ISGN2=1,2
            DO ISGN3=1,2
              DO ISGN4=1,2
                MMJA = MQN(1)*((-1)**ISGN1)
                MMJB = MQN(2)*((-1)**ISGN2)
                MMJC = MQN(3)*((-1)**ISGN3)
                MMJD = MQN(4)*((-1)**ISGN4)
                IF(MMJA-MMJB.EQ.MMJD-MMJC) ISELM = 1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(ISELM.EQ.0) GOTO 3001
      ENDIF
C
C**********************************************************************C
C     IDENTIFICATION OF ERI SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     STARTING INDEX VALUES
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1-1)*LENIQ + IQ2
      IQR = (IQ3-1)*LENIQ + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQL.LT.IQR) GOTO 3001
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
C     NB! OPPOSITE PHASE AS IN THE LL/SS CASE SEEN IN COULOMB
      PAB1 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C     FURTHER DEFINE STARTING ADDRESSES FOR {ABCD} BASIS OVERLAPS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)+NSKP
      NB2 = LRGE(ICNTB,KB,2*MB  )+NSKP
      NC1 = LRGE(ICNTC,KC,2*MC-1)
      NC2 = LRGE(ICNTC,KC,2*MC  )
      ND1 = LRGE(ICNTD,KD,2*MD-1)+NSKP
      ND2 = LRGE(ICNTD,KD,2*MD  )+NSKP
C
C     UPDATE COUNTER FOR NUMBER OF BLOCKS
      N2EB(MCNT,ITT) = N2EB(MCNT,ITT)+1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) TO CONSTRUCT WDIR/WMAT     C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL CPU_TIME(TI)
C
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
          IF(.NOT.SCHWRZ) THEN
            ITOG = 0
          ENDIF
C
C         CALL THE SCREENING ROUTINE
          CALL SCHWARZ(BDSC,SENS,TB2S)
C
C         UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
          N2EI(MCNT,ITT) = N2EI(MCNT,ITT) + NBAS(3)*NBAS(4)
          N2ES(MCNT,ITT) = N2ES(MCNT,ITT) + NBAS(3)*NBAS(4)-MAXN
C
C         CONDITIONAL TO SKIP THIS BATCH
          IF(IBCH.EQ.1) THEN
C
C           GENERATE A BATCH OF BREIT INTERACTION INTEGRALS
            CALL BII(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN,MGNT)
C
C           MULTIPLY BY DENSITY ELEMENTS AND ADD TO WDIR/WMAT
            CALL BRTMAT(RR,TBMC)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C     RECORD TIME AT END OF BATCH
      CALL CPU_TIME(TF)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + TF - TI
C
3001  CONTINUE
3000  CONTINUE
2001  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF BREIT MATRIX BY MATRIX CONJUGATION.     C
C**********************************************************************C
C
      DO I=1,NDIM-NSKP
        DO J=NSKP+1,NDIM
          BDIR(J,I) = DCONJG(BDIR(I,J))
          BXCH(J,I) = DCONJG(BXCH(I,J))
          WDIR(J,I) = DCONJG(WDIR(I,J))
          WXCH(J,I) = DCONJG(WXCH(I,J))
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS (LIFTED FROM COULOMB)
      IF(NOPN.GT.0) THEN
        DO J=1,NDIM
          DO I=1,NDIM
            WDIR(I,J) = ACFF*WDIR(I,J)
            WXCH(I,J) = BCFF*WXCH(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BII(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN,MGNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          BBBBBBB IIII IIII                           C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB  II   II                            C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB IIII IIII                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ XYZ  - FULL SET OF CARTESIAN BASIS CENTERS.                       C
C  ▶ KQN  - FULL SET OF RELATIVISTIC LABELS.                           C
C  ▶ MQN  - FULL SET OF MAGNETIC QUANTUM NUMBERS (MAGNITUDE).          C
C  ▶ NBAS - FULL SET OF EXPONENT LIST LENGTHS.                         C
C  ▶ EXL  - FULL LISTS OF EXPONENTS IN THE BLOCK.                      C
C  ▶ IBAS - 1ST BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ JBAS - 2ND BASIS FUNCTION (HELD CONSTANT DURING ROUTINE).         C
C  ▶ ITN  - COMPONENT OVERLAP COMBINATION.                             C
C  ▶ MGNT - GAUNT INTERACTION OVERRIDE OPTION.                         C
C  OUTPUT:                                                             C
C  ▶ RR   - BII'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ITN(2)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),T(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MEQ,3),IABI11(MEQ,3),IABR21(MEQ,3),IABI21(MEQ,3)
      DIMENSION ICDR11(MEQ,3),ICDI11(MEQ,3),ICDR21(MEQ,3),ICDI21(MEQ,3)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
      DIMENSION IDX(3),JDX(3)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ,3),EAB21(MB2,MEQ,3),
     &           ECD11(MB2,MEQ,3),ECD21(MB2,MEQ,3)
C
      SAVE EAB11,EAB21,IABR11,IABI11,IABR21,IABI21
      SAVE ECD11,ECD21,ICDR11,ICDI11,ICD221,ICDI21
      SAVE RCTTFL,IRCTTFL
C
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TCVT,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     EQ-COEFFICIENT SENSITIVITY PARAMETER
      DATA SENS/1.0D-10/
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.2.AND.ITN(IT).NE.3) THEN
          WRITE(6, *) 'In BII: illegal component overlaps in ITN.'
          WRITE(7, *) 'In BII: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      DO N=1,4
        IF(KQN(N).LT.0) THEN
         LQN(N) =-KQN(N)-1
        ELSE
         LQN(N) = KQN(N)
        ENDIF
      ENDDO
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                        SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTOR FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ-COEFFICIENT ADDRESSES
      LAMAB = LQN(1)+LQN(2)+1
      LAMCD = LQN(3)+LQN(4)+1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR CONTRACTED R-INTEGRAL BATCH
      IF(MGNT.EQ.1) THEN
C       GAUNT INTEGRALS ONLY
        LAMABCD = LAMAB+LAMCD
      ELSE
C       FULL BREIT INTERACTION
        LAMABCD = LAMAB+LAMCD+2
      ENDIF
C
C     VRS TOTAL LENGTH OF EQ-COEFFICIENT LISTS AND R-INTEGRAL BATCH
      NTUVAB   = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD   = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXL(IBAS,1)+EXL(JBAS,2)
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(EQFILE) THEN
        IF(ITN(1).EQ.2) THEN
          DO ITUV=1,NTUVAB
            IAD = IABLS + (ITUV-1)*MAXAB
            DO M=1,MAXAB
            EAB11(M,ITUV,1) = DCMPLX(EILSFL(IAD+M, 1),EILSFL(IAD+M, 2))
            EAB21(M,ITUV,1) = DCMPLX(EILSFL(IAD+M, 3),EILSFL(IAD+M, 4))
            EAB11(M,ITUV,2) = DCMPLX(EILSFL(IAD+M, 5),EILSFL(IAD+M, 6))
            EAB21(M,ITUV,2) = DCMPLX(EILSFL(IAD+M, 7),EILSFL(IAD+M, 8))
            EAB11(M,ITUV,3) = DCMPLX(EILSFL(IAD+M, 9),EILSFL(IAD+M,10))
            EAB21(M,ITUV,3) = DCMPLX(EILSFL(IAD+M,11),EILSFL(IAD+M,12))
            ENDDO
          ENDDO
        ELSEIF(ITN(1).EQ.3) THEN
          DO ITUV=1,NTUVAB
            IAD = IABSL + (ITUV-1)*MAXAB
            DO M=1,MAXAB
            EAB11(M,ITUV,1) = DCMPLX(EISLFL(IAD+M, 1),EISLFL(IAD+M, 2))
            EAB21(M,ITUV,1) = DCMPLX(EISLFL(IAD+M, 3),EISLFL(IAD+M, 4))
            EAB11(M,ITUV,2) = DCMPLX(EISLFL(IAD+M, 5),EISLFL(IAD+M, 6))
            EAB21(M,ITUV,2) = DCMPLX(EISLFL(IAD+M, 7),EISLFL(IAD+M, 8))
            EAB11(M,ITUV,3) = DCMPLX(EISLFL(IAD+M, 9),EISLFL(IAD+M,10))
            EAB21(M,ITUV,3) = DCMPLX(EISLFL(IAD+M,11),EISLFL(IAD+M,12))
            ENDDO
          ENDDO
        ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      ELSE
        IF(ITN(1).EQ.2) THEN
          CALL EILSB3(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2)
        ELSEIF(ITN(1).EQ.3) THEN
          CALL EISLB3(EAB11,EAB21,EXL,XYZ,KQN,MQN,NBAS,IPHSAB,1,2)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.2) THEN
        TELS = TELS+TDM2-TDM1
      ELSEIF(ITN(1).EQ.3) THEN
        TESL = TESL+TDM2-TDM1
      ENDIF
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH IAB
      DO ICMP=1,3
        DO IAB=1,NTUVAB
C
C         Re{E(AB|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            ER = DREAL(EAB11(M,IAB,ICMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              IABR11(IAB,ICMP) = 1
              GOTO 101
            ENDIF
          ENDDO
          IABR11(IAB,ICMP) = 0
101       CONTINUE
C
C         Im{E(AB|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            EI = DIMAG(EAB11(M,IAB,ICMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              IABI11(IAB,ICMP) = 1
              GOTO 102
            ENDIF
          ENDDO
          IABI11(IAB,ICMP) = 0
102       CONTINUE
C
C         Re{E(AB|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            ER = DREAL(EAB21(M,IAB,ICMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              IABR21(IAB,ICMP) = 1
              GOTO 103
            ENDIF
          ENDDO
          IABR21(IAB,ICMP) = 0
103       CONTINUE
C
C         Im{E(AB|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            EI = DIMAG(EAB21(M,IAB,ICMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              IABI21(IAB,ICMP) = 1
              GOTO 104
            ENDIF
          ENDDO
          IABI21(IAB,ICMP) = 0
104       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(EQFILE) THEN
        IF(ITN(2).EQ.2) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDLS + (ITUV-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ITUV)))
            DO M=1,MAXCD
            ECD11(M,ITUV,1)=Z*DCMPLX(EILSFL(IAD+M, 1),EILSFL(IAD+M, 2))
            ECD21(M,ITUV,1)=Z*DCMPLX(EILSFL(IAD+M, 3),EILSFL(IAD+M, 4))
            ECD11(M,ITUV,2)=Z*DCMPLX(EILSFL(IAD+M, 5),EILSFL(IAD+M, 6))
            ECD21(M,ITUV,2)=Z*DCMPLX(EILSFL(IAD+M, 7),EILSFL(IAD+M, 8))
            ECD11(M,ITUV,3)=Z*DCMPLX(EILSFL(IAD+M, 9),EILSFL(IAD+M,10))
            ECD21(M,ITUV,3)=Z*DCMPLX(EILSFL(IAD+M,11),EILSFL(IAD+M,12))
            ENDDO
          ENDDO
        ELSEIF(ITN(2).EQ.3) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDSL + (ITUV-1)*MAXCD
            Z   = DFLOAT((-1)**(ILAM(ITUV)))
            DO M=1,MAXCD
            ECD11(M,ITUV,1)=Z*DCMPLX(EISLFL(IAD+M, 1),EISLFL(IAD+M, 2))
            ECD21(M,ITUV,1)=Z*DCMPLX(EISLFL(IAD+M, 3),EISLFL(IAD+M, 4))
            ECD11(M,ITUV,2)=Z*DCMPLX(EISLFL(IAD+M, 5),EISLFL(IAD+M, 6))
            ECD21(M,ITUV,2)=Z*DCMPLX(EISLFL(IAD+M, 7),EISLFL(IAD+M, 8))
            ECD11(M,ITUV,3)=Z*DCMPLX(EISLFL(IAD+M, 9),EISLFL(IAD+M,10))
            ECD21(M,ITUV,3)=Z*DCMPLX(EISLFL(IAD+M,11),EISLFL(IAD+M,12))
            ENDDO
          ENDDO
        ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      ELSE
        IF(ITN(2).EQ.2) THEN
          CALL EILSB3(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4)
        ELSEIF(ITN(2).EQ.3) THEN
          CALL EISLB3(ECD11,ECD21,EXL,XYZ,KQN,MQN,NBAS,IPHSCD,3,4)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(2).EQ.2) THEN
        TELS = TELS+TDM2-TDM1
      ELSEIF(ITN(2).EQ.3) THEN
        TESL = TESL+TDM2-TDM1
      ENDIF
C
C     SCREENING PROCEDURE: NORM SUM OF EQ-COEFFICIENT LIST FOR EACH ICD
      DO JCMP=1,3
        DO ICD=1,NTUVCD
C
C         Re{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            ER = DREAL(ECD11(M,ICD,JCMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              ICDR11(ICD,JCMP) = 1
              GOTO 201
            ENDIF
          ENDDO
          ICDR11(ICD,JCMP) = 0
201       CONTINUE
C
C         Im{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            EI = DIMAG(ECD11(M,ICD,JCMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              ICDI11(ICD,JCMP) = 1
              GOTO 202
            ENDIF
          ENDDO
          ICDI11(ICD,JCMP) = 0
202       CONTINUE
C
C         Re{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            ER = DREAL(ECD21(M,ICD,JCMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              ICDR21(ICD,JCMP) = 1
              GOTO 203
            ENDIF
          ENDDO
          ICDR21(ICD,JCMP) = 0
203       CONTINUE
C
C         Im{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            EI = DIMAG(ECD21(M,ICD,JCMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              ICDI21(ICD,JCMP) = 1
              GOTO 204
            ENDIF
          ENDDO
          ICDI21(ICD,JCMP) = 0
204       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL ASKED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL CPU_TIME(T2)
      TBEC = TBEC + T2 - T1
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) FROM SCRATCH OR READ-IN          C
C**********************************************************************C
C
C     FACTORS NEEDED IN BOTH CASES
C
C     GAUSSIAN OVERLAP CENTRE
      PX = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF((RCFILE.AND.IRIJ(IBAS,JBAS).EQ.0.AND.ISCR(M).EQ.1)
     &                    .OR.(RCFILE.AND.IRIJ(IBAS,JBAS).EQ.1)
     &                       .OR.(.NOT.RCFILE.AND.ISCR(M).EQ.1)) THEN
            N   = N+1
            EKL = EXL(KBAS,3)+EXL(LBAS,4)
            QX  = (XYZ(1,3)*EXL(KBAS,3)+XYZ(1,4)*EXL(LBAS,4))/EKL
            QY  = (XYZ(2,3)*EXL(KBAS,3)+XYZ(2,4)*EXL(LBAS,4))/EKL
            QZ  = (XYZ(3,3)*EXL(KBAS,3)+XYZ(3,4)*EXL(LBAS,4))/EKL
            APH(N)  = EIJ*EKL/(EIJ+EKL)
            PQ(N,1) = QX-PX
            PQ(N,2) = QY-PY
            PQ(N,3) = QZ-PZ
            EMX     = DSQRT(EIJ+EKL)*EIJ*EKL
            PRE(N)  = 2.0D0*PI52/EMX
          ENDIF
        ENDDO
      ENDDO
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     READ FROM LOCAL RC(AB|CD) FILE
      IF(RCFILE.AND.IRIJ(IBAS,JBAS).EQ.0) THEN
C
        CALL CPU_TIME(T1)
C
C       STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
        IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCD
C
C       READ RC(AB|CD) INTEGRALS FROM THIS STARTING POINT
        N = 0
        DO N=1,MAXN
          DO IABCD=1,NTUVABCD
            IAD = IADRTT + (IMAP(N)-1)*NTUVABCD + IABCD
            RC(N,IABCD) = RCTTFL(IAD)
          ENDDO
        ENDDO
C
C       STARTING ADDRESS FOR SCREENING FLAGS
        IADSCR = (IJ-1)*NTUVABCD
C
C       READ SCREENING FLAGS FROM THIS STARTING POINT
        DO IABCD=1,NTUVABCD
          IAD = IADSCR + IABCD
          IRC(IABCD) = IRCTTFL(IAD)
        ENDDO
C
C       RECORD TIME SPENT READING R-INTEGRALS
        CALL CPU_TIME(T2)
        TBRR = TBRR+T2-T1
C
      ENDIF
C
C     CALCULATE FROM SCRATCH
      IF(.NOT.RCFILE.OR.IRIJ(IBAS,JBAS).EQ.1) THEN
C
        CALL CPU_TIME(T1)
C
C       GENERATE R-INTEGRALS
        CALL RMAKE(RC,PQ,APH,MAXN,LAMABCD)
C
C       SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
        DO IABCD=1,NTUVABCD
C
C         SUM OF RC(AB|CD) MAGNITUDES
          SUM = 0.0D0
          DO N=1,MAXN
            SUM = SUM + DABS(RC(N,IABCD))
            IF(SUM.GT.SENS) THEN
              IRC(IABCD) = 1
              GOTO 301
            ENDIF
          ENDDO
          IRC(IABCD) = 0
301       CONTINUE
C
        ENDDO
C
C       SAVE THIS SET TO APPROPRIATE CLASS ADDRESS
        IF(RCFILE) THEN
C
C         TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
          ILIM = IJ*NBAS(3)*NBAS(4)*NTUVABCD
C
          IF(ILIM.GT.20*MFL) THEN
C           OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
            WRITE(6, *) 'In BII: RCTT words exceed allocated limit.'
            WRITE(7, *) 'In BII: RCTT words exceed allocated limit.'
            GOTO 300
          ELSE
C           DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
            IRIJ(IBAS,JBAS) = 0
          ENDIF
C
C         STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
          IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCD

C         COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
          DO N=1,MAXN
            DO IABCD=1,NTUVABCD
              IAD = IADRTT + (N-1)*NTUVABCD + IABCD
              RCTTFL(IAD) = RC(N,IABCD)
            ENDDO
          ENDDO
C
C         STARTING ADDRESS FOR SCREENING FLAGS
          IADSCR = (IJ-1)*NTUVABCD
C
C         COPY SCREENING MARKERS TO A SAVED LIST
          DO IABCD=1,NTUVABCD
            IAD = IADSCR + IABCD
            IRCTTFL(IAD) = IRC(IABCD)
          ENDDO
C
C         SHORTEN THE CURRENT RC LIST WITH IMAP FROM SCREENING
          M = 0
          N = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              IF(ISCR(M).EQ.1) THEN
                N       = N+1
                APH(N)  = APH(M)
                PQ(N,1) = PQ(M,1)
                PQ(N,2) = PQ(M,2)
                PQ(N,3) = PQ(M,3)
                PRE(N)  = PRE(M)
                DO IABCD=1,NTUVABCD
                  RC(N,IABCD) = RC(M,IABCD)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
C
C         SHORTEN MAXN
          MAXN = N
C
        ENDIF
300     CONTINUE
C
        CALL CPU_TIME(T2)
        TBRM = TBRM+T2-T1
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL CPU_TIME(TDM2)
      TRBR = TRBR+TDM2-TDM1
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     LOOP OVER CARTESIAN INDEX ICMP FOR CENTRE AB (USE INDEX 6000)
      DO 6000 ICMP=1,3
C
C     TIME AT START OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T1I)
C
C     CARTESIAN INDEX ICMP AS A VECTOR, IDX
      CALL NCART(IDX,ICMP)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) PASSES SCREENING CONDITION
        IF(IABR11(IAB,ICMP)+IABI11(IAB,ICMP)
     &                   +IABR21(IAB,ICMP)+IABI21(IAB,ICMP).EQ.0) THEN
          GOTO 401
        ENDIF
C
C >>>>> GAUNT INTERACTION
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO ICD=1,NTUVCD
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = IABC(IA(IAB)+IA(ICD),IB(IAB)+IB(ICD),IC(IAB)+IC(ICD))
C
C         SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
          IF(IRC(IRABCD).EQ.0) GOTO 402
C
C         SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
          IF(ICDR11(ICD,ICMP)+ICDI11(ICD,ICMP)
     &                   +ICDR21(ICD,ICMP)+ICDI21(ICD,ICMP).EQ.0) THEN
            GOTO 402
          ENDIF
C
C         CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
          IF(ISYM.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 411
          IF(ICDR11(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                    + DREAL(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
411       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
          IF(ISYM.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 412
          IF(ICDI11(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                    + DIMAG(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
412       CONTINUE
C
C         CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
          IF(ISYM.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 413
          IF(ICDR21(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                    + DREAL(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
413       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
          IF(ISYM.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 414
          IF(ICDI21(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                    + DIMAG(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
414       CONTINUE
C
C         SKIP POINT FOR RC(AB|CD) AND E(CD) SCREENING
402       CONTINUE
C
C >>>>>   GAUGE TERM (REQUIRES ADDITIONAL CARTESIAN SUM Q')
          IF(MGNT.EQ.1) GOTO 450
C
C         LOOP OVER CARTESIAN INDEX JCMP FOR CENTRE CD
          DO JCMP=1,3
C
C           SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
            IF(ICDR11(ICD,JCMP)+ICDI11(ICD,JCMP)
     &                     +ICDR21(ICD,JCMP)+ICDI21(ICD,JCMP).EQ.0) THEN
              GOTO 403
            ENDIF
C
C           CARTESIAN INDEX JCMP AS A VECTOR, JDX
            CALL NCART(JDX,JCMP)
C
C           NEW ADDRESS DEPENDING ON JCMP CARTESIAN INDEX
            IF(JCMP.EQ.1) THEN
              RTP = DFLOAT(IA(IAB)+IA(ICD))
            ELSEIF(JCMP.EQ.2) THEN
              RTP = DFLOAT(IB(IAB)+IB(ICD))
            ELSEIF(JCMP.EQ.3) THEN
              RTP = DFLOAT(IC(IAB)+IC(ICD))
            ENDIF
C
C           FIRST CONTRIBUTION ADDRESS
            I1 = IA(IAB)+IA(ICD)+IDX(1)+JDX(1)
            J1 = IB(IAB)+IB(ICD)+IDX(2)+JDX(2)
            K1 = IC(IAB)+IC(ICD)+IDX(3)+JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR1 = IABC(I1,J1,K1)
C
C           SECOND CONTRIBUTION ADDRESS
            I2 = IA(IAB)+IA(ICD)+IDX(1)
            J2 = IB(IAB)+IB(ICD)+IDX(2)
            K2 = IC(IAB)+IC(ICD)+IDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR2 = IABC(I2,J2,K2)
C
C           THIRD CONTRIBUTION ADDRESS
            I3 = IA(IAB)+IA(ICD)+IDX(1)-JDX(1)
            J3 = IB(IAB)+IB(ICD)+IDX(2)-JDX(2)
            K3 = IC(IAB)+IC(ICD)+IDX(3)-JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
              IADR3 = IABC(I3,J3,K3)
            ELSE
              IADR3 = 0
            ENDIF
C
C           SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
            IF(IADR3.NE.0) THEN
              IF(IRC(IADR1)+IRC(IADR2)+IRC(IADR3).EQ.0) GOTO 403
            ELSE
              IF(IRC(IADR1)+IRC(IADR2).EQ.0) GOTO 403
            ENDIF
C
C           PRE-FACTORS FOR THE UPCOMING CONTRACTION
            DO N=1,MAXN
              T1 = RC(N,IADR1)*0.5D0/APH(N)
              T2 = RC(N,IADR2)*PQ(N,JCMP)
              IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
                T3 = RC(N,IADR3)*RTP
              ELSE
                T3 = 0.0D0
              ENDIF
              T(N) = T1-T2+T3
            ENDDO
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 415
            IF(ICDR11(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABR11(N,IAB) = GABR11(N,IAB)
     &                            - DREAL(ECD11(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
415         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 416
            IF(ICDI11(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABI11(N,IAB) = GABI11(N,IAB)
     &                            - DIMAG(ECD11(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
416         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 417
            IF(ICDR21(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABR21(N,IAB) = GABR21(N,IAB)
     &                            - DREAL(ECD21(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
417         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ISYM.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 418
            IF(ICDI21(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABI21(N,IAB) = GABI21(N,IAB)
     &                            - DIMAG(ECD21(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
418         CONTINUE
C
C         SKIP POINT FOR E(CD) SCREENING
403       CONTINUE
C
C         END LOOP OVER CARTESIAN INDEX JCMP FOR CENTRE CD
          ENDDO
C
C         SKIP POINT FOR GAUNT INTERACTION ONLY
450       CONTINUE
C
C       END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
        ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T1F)
      TBC1 = TBC1+T1F-T1I
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB =-ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD =-ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,1 ) = RR(N,1 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,4 ) = RR(N,4 ) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
      IF(ISYM.EQ.1) GOTO 501
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,3 ) = RR(N,3 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,2 ) = RR(N,2 ) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,9 ) = RR(N,9 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = RR(N,12) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
501   CONTINUE
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) = RR(N,11) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) = RR(N,10) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     TIME AT END OF SECOND CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T2F)
      TBC2 = TBC2+T2F-T1F
C
C     END LOOP OVER CARTESIAN INDICES {IX,IY,IZ}
6000  CONTINUE
C
C     HALF OF THE RR ARRAY CAN BE GENERATED WITH PHASE RELATIONS
      DO N=1,MAXN
        RR(N,16) = PABCD*DCONJG(RR(N,1 ))
        RR(N,13) = PABCD*DCONJG(RR(N,4 ))
        RR(N,14) =-PABCD*DCONJG(RR(N,3 ))
        RR(N,15) =-PABCD*DCONJG(RR(N,2 ))
        RR(N,8 ) =-PABCD*DCONJG(RR(N,9 ))
        RR(N,5 ) =-PABCD*DCONJG(RR(N,12))
        RR(N,6 ) = PABCD*DCONJG(RR(N,11))
        RR(N,7 ) = PABCD*DCONJG(RR(N,10))
      ENDDO     
C
C**********************************************************************C
C     BREIT INTEGRAL BATCH NOW FULLY CONSTRUCTED                       C
C**********************************************************************C
C
C     INCLUDE THE OUTSIDE FACTOR OF (-1/2) AND MOVE TO FULL ARRAY
      DO N=1,MAXN
        DO ITG=1,16
          RR(N,ITG) =-0.5D0*PRE(N)*RR(N,ITG)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BRTMAT(RR,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        BBBBBBB  RRRRRRR TTTTTTTT MM       MM    AA   TTTTTTTT        C
C        BB    BB RR    RR   TT    MMM     MMM   AAAA     TT           C
C        BB    BB RR    RR   TT    MMMM   MMMM  AA  AA    TT           C
C        BBBBBBB  RR    RR   TT    MM MM MM MM AA    AA   TT           C
C        BB    BB RRRRRRR    TT    MM  MMM  MM AAAAAAAA   TT           C
C        BB    BB RR    RR   TT    MM   M   MM AA    AA   TT           C
C        BBBBBBB  RR    RR   TT    MM       MM AA    AA   TT           C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTMAT MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF BREIT MATRICES.       C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO BII):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C  ▶ NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION NBAS(4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,IQL,IQR
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/SHLL/ALPH,BETA,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                        SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS...                                    C
C**********************************************************************C
C
C     BDIR = 0 FOR CLOSED-SHELL SYSTEMS -- CAN ALLOW THIS FOR TESTING
      IF(NOPN.EQ.0) GOTO 150
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 101
          N = N+1
          IF(IMTX(M, 1).EQ.0) GOTO 101
C
          BDIR(NA1+IBAS,NB1+JBAS) = BDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 1)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 4)*DENT(NC2+KBAS,ND2+LBAS)
C
          BDIR(NA2+IBAS,NB2+JBAS) = BDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(M,13)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M,16)*DENT(NC2+KBAS,ND2+LBAS)
C
101       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES B^{LS,SL}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 102
          N = N+1
          IF(IMTX(M, 2).EQ.0) GOTO 102
C
          BDIR(NA1+IBAS,NB1+JBAS) = BDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 4)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 1)*DENT(ND2+LBAS,NC2+KBAS)
C
          BDIR(NA2+IBAS,NB2+JBAS) = BDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(M,16)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,13)*DENT(ND2+LBAS,NC2+KBAS)
C
102       CONTINUE
        ENDDO
      ENDDO
C
      IF(IQL.EQ.IQR) GOTO 160
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 103
          N = N+1
          IF(IMTX(M, 3).EQ.0) GOTO 103
C
          BDIR(NC1+KBAS,ND1+LBAS) = BDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 1)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M,13)*DENT(NA2+IBAS,NB2+JBAS)
C
          BDIR(NC2+KBAS,ND2+LBAS) = BDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(M, 4)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M,16)*DENT(NA2+IBAS,NB2+JBAS)
C
103       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LS,SL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 104
          N = N+1
          IF(IMTX(M, 4).EQ.0) GOTO 104
C
          BDIR(NC1+KBAS,ND1+LBAS) = BDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,13)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 1)*DENT(NB2+JBAS,NA2+IBAS)
C
          BDIR(NC2+KBAS,ND2+LBAS) = BDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,16)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 4)*DENT(NB2+JBAS,NA2+IBAS)
C
104       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT WHEN IQL=IQR
160   CONTINUE
C
C     SKIP POINT FOR BDIR IN CLOSED-SHELL SYSTEMS
150   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 105
          N = N+1
          IF(IMTX(M, 5).EQ.0) GOTO 105
C
          BXCH(NA1+IBAS,ND1+LBAS) = BXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 1)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 7)*DENT(NC2+KBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,ND2+LBAS) = BXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(M,10)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M,16)*DENT(NC2+KBAS,NB2+JBAS)
C
105       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LL,SS}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 106
          N = N+1
          IF(IMTX(M, 6).EQ.0) GOTO 106
C
          BXCH(NA1+IBAS,NC1+KBAS) = BXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 4)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 7)*DENT(ND2+LBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,NC2+KBAS) = BXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,10)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,13)*DENT(ND2+LBAS,NB2+JBAS)
C
106       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{SS,LL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 107
          N = N+1
          IF(IMTX(M, 7).EQ.0) GOTO 107
C
          BXCH(NB1+JBAS,ND1+LBAS) = BXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,13)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 7)*DENT(NC2+KBAS,NA2+IBAS)
C
          BXCH(NB2+JBAS,ND2+LBAS) = BXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M,10)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 4)*DENT(NC2+KBAS,NA2+IBAS)
C
107       CONTINUE
        ENDDO
      ENDDO
C
C     APPLY AN EQ-COEFFICIENT REFLECTION FORMULA TO RECYCLE INTEGRALS
      IF(IQL.EQ.IQR) GOTO 170
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 109
          N = N+1
          IF(IMTX(M, 9).EQ.0) GOTO 109
C
          BXCH(NC1+KBAS,NB1+JBAS) = BXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 1)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M,10)*DENT(NA2+IBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NB2+JBAS) = BXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(M, 7)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M,16)*DENT(NA2+IBAS,ND2+LBAS)
C
109       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LL,SS}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 110
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 110
C
          BXCH(NC1+KBAS,NA1+IBAS) = BXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,13)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M,10)*DENT(NB2+JBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NA2+IBAS) = BXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 7)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M, 4)*DENT(NB2+JBAS,ND2+LBAS)
C
110       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{SS,LL}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 111
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 111
C
          BXCH(ND1+LBAS,NB1+JBAS) = BXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 4)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,10)*DENT(NA2+IBAS,NC2+KBAS)
C
          BXCH(ND2+LBAS,NB2+JBAS) = BXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M, 7)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,13)*DENT(NA2+IBAS,NC2+KBAS)
C
111       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQL=IQR
170   CONTINUE
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ISYM.EQ.1) GOTO 200
C
C     BDIR = 0 FOR CLOSED-SHELL SYSTEMS -- CAN ALLOW THIS FOR TESTING
      IF(NOPN.EQ.0) GOTO 250
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 201
          N = N+1
          IF(IMTX(M, 1).EQ.0) GOTO 201
C
          BDIR(NA1+IBAS,NB1+JBAS) = BDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 2)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 3)*DENT(NC2+KBAS,ND1+LBAS)
C
          BDIR(NA1+IBAS,NB2+JBAS) = BDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M, 5)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 6)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 7)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 8)*DENT(NC2+KBAS,ND2+LBAS)
C
          BDIR(NA2+IBAS,NB1+JBAS) = BDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M, 9)*DENT(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M,10)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M,11)*DENT(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M,12)*DENT(NC2+KBAS,ND2+LBAS)
C
          BDIR(NA2+IBAS,NB2+JBAS) = BDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(M,14)*DENT(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M,15)*DENT(NC2+KBAS,ND1+LBAS)
C
201       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES B^{LS,SL}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 202
          N = N+1
          IF(IMTX(M, 2).EQ.0) GOTO 202
C
          BDIR(NA1+IBAS,NB1+JBAS) = BDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 2)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 3)*DENT(ND2+LBAS,NC1+KBAS)
C
          BDIR(NA1+IBAS,NB2+JBAS) = BDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 8)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 6)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 7)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 5)*DENT(ND2+LBAS,NC2+KBAS)
C
          BDIR(NA2+IBAS,NB1+JBAS) = BDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,12)*DENT(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,10)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,11)*DENT(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 9)*DENT(ND2+LBAS,NC2+KBAS)
C
          BDIR(NA2+IBAS,NB2+JBAS) = BDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(M,14)*DENT(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,15)*DENT(ND2+LBAS,NC1+KBAS)
C
202       CONTINUE
        ENDDO
      ENDDO
C
      IF(IQL.EQ.IQR) GOTO 260
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 203
          N = N+1
          IF(IMTX(M, 3).EQ.0) GOTO 203
C
          BDIR(NC1+KBAS,ND1+LBAS) = BDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 5)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M, 9)*DENT(NA2+IBAS,NB1+JBAS)
C
          BDIR(NC1+KBAS,ND2+LBAS) = BDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 2)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 6)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,10)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,14)*DENT(NA2+IBAS,NB2+JBAS)      
C
          BDIR(NC2+KBAS,ND1+LBAS) = BDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 3)*DENT(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 7)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,11)*DENT(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,15)*DENT(NA2+IBAS,NB2+JBAS)
C
          BDIR(NC2+KBAS,ND2+LBAS) = BDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(M, 8)*DENT(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,12)*DENT(NA2+IBAS,NB1+JBAS)
C
203       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LS,SL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 204
          N = N+1
          IF(IMTX(M, 4).EQ.0) GOTO 204
C
          BDIR(NC1+KBAS,ND1+LBAS) = BDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 5)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 9)*DENT(NB2+JBAS,NA1+IBAS)
C
          BDIR(NC1+KBAS,ND2+LBAS) = BDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,14)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 6)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,10)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 2)*DENT(NB2+JBAS,NA2+IBAS)
C
          BDIR(NC2+KBAS,ND1+LBAS) = BDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,15)*DENT(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 7)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,11)*DENT(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 3)*DENT(NB2+JBAS,NA2+IBAS)
C
          BDIR(NC2+KBAS,ND2+LBAS) = BDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(M, 8)*DENT(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,12)*DENT(NB2+JBAS,NA1+IBAS)
C
204       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT WHEN IQL=IQR
260   CONTINUE
C
C     SKIP POINT FOR BDIR IN CLOSED-SHELL SYSTEMS
250   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 205
          N = N+1
          IF(IMTX(M, 5).EQ.0) GOTO 205
C
          BXCH(NA1+IBAS,ND1+LBAS) = BXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 3)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 5)*DENT(NC1+KBAS,NB2+JBAS)
C
          BXCH(NA1+IBAS,ND2+LBAS) = BXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M, 2)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 4)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 6)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 8)*DENT(NC2+KBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,ND1+LBAS) = BXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M, 9)*DENT(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M,11)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M,13)*DENT(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M,15)*DENT(NC2+KBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,ND2+LBAS) = BXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(M,12)*DENT(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M,14)*DENT(NC1+KBAS,NB2+JBAS)
C
205       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LL,SS}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 206
          N = N+1
          IF(IMTX(M, 6).EQ.0) GOTO 206
C
          BXCH(NA1+IBAS,NC1+KBAS) = BXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 8)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M, 3)*DENT(ND2+LBAS,NB1+JBAS)
C
          BXCH(NA1+IBAS,NC2+KBAS) = BXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 2)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 6)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 1)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 5)*DENT(ND2+LBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,NC1+KBAS) = BXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,12)*DENT(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,16)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M,11)*DENT(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M,15)*DENT(ND2+LBAS,NB2+JBAS)
C
          BXCH(NA2+IBAS,NC2+KBAS) = BXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,14)*DENT(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 9)*DENT(ND2+LBAS,NB1+JBAS)
C
206       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{SS,LL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 207
          N = N+1
          IF(IMTX(M, 7).EQ.0) GOTO 207
C
          BXCH(NB1+JBAS,ND1+LBAS) = BXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 5)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(M,15)*DENT(NC2+KBAS,NA1+IBAS)
C
          BXCH(NB1+JBAS,ND2+LBAS) = BXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,14)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 6)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(M,16)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 8)*DENT(NC2+KBAS,NA2+IBAS)
C
          BXCH(NB2+JBAS,ND1+LBAS) = BXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 9)*DENT(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 1)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,11)*DENT(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 3)*DENT(NC2+KBAS,NA2+IBAS)
C
          BXCH(NB2+JBAS,ND2+LBAS) = BXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 2)*DENT(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,12)*DENT(NC2+KBAS,NA1+IBAS)
C
207       CONTINUE
        ENDDO
      ENDDO
C
C     APPLY AN EQ-COEFFICIENT REFLECTION FORMULA TO RECYCLE INTEGRALS
      IF(IQL.EQ.IQR) GOTO 270
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 209
          N = N+1
          IF(IMTX(M, 9).EQ.0) GOTO 209
C
          BXCH(NC1+KBAS,NB1+JBAS) = BXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 2)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M, 9)*DENT(NA2+IBAS,ND1+LBAS)
C
          BXCH(NC1+KBAS,NB2+JBAS) = BXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 5)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 6)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,13)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,14)*DENT(NA2+IBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NB1+JBAS) = BXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 3)*DENT(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 4)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,11)*DENT(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,12)*DENT(NA2+IBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NB2+JBAS) = BXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(M, 8)*DENT(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,15)*DENT(NA2+IBAS,ND1+LBAS)
C
209       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LL,SS}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 210
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 210
C
          BXCH(NC1+KBAS,NA1+IBAS) = BXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,14)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M, 9)*DENT(NB2+JBAS,ND1+LBAS)
C
          BXCH(NC1+KBAS,NA2+IBAS) = BXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 5)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 6)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 1)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M, 2)*DENT(NB2+JBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NA1+IBAS) = BXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,15)*DENT(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,16)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M,11)*DENT(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M,12)*DENT(NB2+JBAS,ND2+LBAS)
C
          BXCH(NC2+KBAS,NA2+IBAS) = BXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 8)*DENT(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 3)*DENT(NB2+JBAS,ND1+LBAS)
C
210       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{SS,LL}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 211
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 211
C
          BXCH(ND1+LBAS,NB1+JBAS) = BXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 2)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(M,12)*DENT(NA2+IBAS,NC1+KBAS)
C
          BXCH(ND1+LBAS,NB2+JBAS) = BXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 8)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 6)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(M,16)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,14)*DENT(NA2+IBAS,NC2+KBAS)
C
          BXCH(ND2+LBAS,NB1+JBAS) = BXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 3)*DENT(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 1)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,11)*DENT(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 9)*DENT(NA2+IBAS,NC2+KBAS)
C
          BXCH(ND2+LBAS,NB2+JBAS) = BXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 5)*DENT(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,15)*DENT(NA2+IBAS,NC1+KBAS)
C
211       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQL=IQR
270   CONTINUE
C
C     SKIP POINT FOR ATOMS AND LINEAR MOLECULES
200   CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS...                                      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5000
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 301
          N = N+1
          IF(IMTX(M, 1).EQ.0) GOTO 301
C
          WDIR(NA1+IBAS,NB1+JBAS) = WDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 1)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 4)*DENO(NC2+KBAS,ND2+LBAS)
C
          WDIR(NA2+IBAS,NB2+JBAS) = WDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(M,13)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M,16)*DENO(NC2+KBAS,ND2+LBAS)
C
301       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES B^{LS,SL}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 302
          N = N+1
          IF(IMTX(M, 2).EQ.0) GOTO 302
C
          WDIR(NA1+IBAS,NB1+JBAS) = WDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 4)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 1)*DENO(ND2+LBAS,NC2+KBAS)
C
          WDIR(NA2+IBAS,NB2+JBAS) = WDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(M,16)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,13)*DENO(ND2+LBAS,NC2+KBAS)
C
302       CONTINUE
        ENDDO
      ENDDO
C
      IF(IQL.EQ.IQR) GOTO 360
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 303
          N = N+1
          IF(IMTX(M, 3).EQ.0) GOTO 303
C
          WDIR(NC1+KBAS,ND1+LBAS) = WDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 1)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M,13)*DENO(NA2+IBAS,NB2+JBAS)
C
          WDIR(NC2+KBAS,ND2+LBAS) = WDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(M, 4)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M,16)*DENO(NA2+IBAS,NB2+JBAS)
C
303       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LS,SL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 304
          N = N+1
          IF(IMTX(M, 4).EQ.0) GOTO 304
C
          WDIR(NC1+KBAS,ND1+LBAS) = WDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,13)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 1)*DENO(NB2+JBAS,NA2+IBAS)
C
          WDIR(NC2+KBAS,ND2+LBAS) = WDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,16)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 4)*DENO(NB2+JBAS,NA2+IBAS)
C
304       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT WHEN IQL=IQR
360   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 305
          N = N+1
          IF(IMTX(M, 5).EQ.0) GOTO 305
C
          WXCH(NA1+IBAS,ND1+LBAS) = WXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 1)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 7)*DENO(NC2+KBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,ND2+LBAS) = WXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(M,10)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M,16)*DENO(NC2+KBAS,NB2+JBAS)
C
305       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LL,SS}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 306
          N = N+1
          IF(IMTX(M, 6).EQ.0) GOTO 306
C
          WXCH(NA1+IBAS,NC1+KBAS) = WXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 4)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 7)*DENO(ND2+LBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,NC2+KBAS) = WXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,10)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,13)*DENO(ND2+LBAS,NB2+JBAS)
C
306       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{SS,LL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 307
          N = N+1
          IF(IMTX(M, 7).EQ.0) GOTO 307
C
          WXCH(NB1+JBAS,ND1+LBAS) = WXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,13)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 7)*DENO(NC2+KBAS,NA2+IBAS)
C
          WXCH(NB2+JBAS,ND2+LBAS) = WXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M,10)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 4)*DENO(NC2+KBAS,NA2+IBAS)
C
307       CONTINUE
        ENDDO
      ENDDO
C
C     APPLY AN EQ-COEFFICIENT REFLECTION FORMULA TO RECYCLE INTEGRALS
      IF(IQL.EQ.IQR) GOTO 370
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 309
          N = N+1
          IF(IMTX(M, 9).EQ.0) GOTO 309
C
          WXCH(NC1+KBAS,NB1+JBAS) = WXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 1)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M,10)*DENO(NA2+IBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NB2+JBAS) = WXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(M, 7)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M,16)*DENO(NA2+IBAS,ND2+LBAS)
C
309       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LL,SS}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 310
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 310
C
          WXCH(NC1+KBAS,NA1+IBAS) = WXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,13)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M,10)*DENO(NB2+JBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NA2+IBAS) = WXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 7)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M, 4)*DENO(NB2+JBAS,ND2+LBAS)
C
310       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{SS,LL}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 311
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 311
C
          WXCH(ND1+LBAS,NB1+JBAS) = WXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 4)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,10)*DENO(NA2+IBAS,NC2+KBAS)
C
          WXCH(ND2+LBAS,NB2+JBAS) = WXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M, 7)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,13)*DENO(NA2+IBAS,NC2+KBAS)
C
311       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQL=IQR
370   CONTINUE
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ISYM.EQ.1) GOTO 400
C
C     BATCH TYPE 01: 
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 401
          N = N+1
          IF(IMTX(M, 1).EQ.0) GOTO 401
C
          WDIR(NA1+IBAS,NB1+JBAS) = WDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 2)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 3)*DENO(NC2+KBAS,ND1+LBAS)
C
          WDIR(NA1+IBAS,NB2+JBAS) = WDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M, 5)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 6)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 7)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 8)*DENO(NC2+KBAS,ND2+LBAS)
C
          WDIR(NA2+IBAS,NB1+JBAS) = WDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M, 9)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M,10)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M,11)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M,12)*DENO(NC2+KBAS,ND2+LBAS)
C
          WDIR(NA2+IBAS,NB2+JBAS) = WDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(M,14)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M,15)*DENO(NC2+KBAS,ND1+LBAS)
C
401       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 02:
C     DIRECT INTEGRALS    ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
C     CALCULATES B^{LS,SL}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 402
          N = N+1
          IF(IMTX(M, 2).EQ.0) GOTO 402
C
          WDIR(NA1+IBAS,NB1+JBAS) = WDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 2)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 3)*DENO(ND2+LBAS,NC1+KBAS)
C
          WDIR(NA1+IBAS,NB2+JBAS) = WDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 8)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 6)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 7)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 5)*DENO(ND2+LBAS,NC2+KBAS)
C
          WDIR(NA2+IBAS,NB1+JBAS) = WDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,12)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,10)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,11)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 9)*DENO(ND2+LBAS,NC2+KBAS)
C
          WDIR(NA2+IBAS,NB2+JBAS) = WDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(M,14)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,15)*DENO(ND2+LBAS,NC1+KBAS)
C
402       CONTINUE
        ENDDO
      ENDDO
C
      IF(IQL.EQ.IQR) GOTO 460
C
C     BATCH TYPE 03:
C     DIRECT INTEGRALS    ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 403
          N = N+1
          IF(IMTX(M, 3).EQ.0) GOTO 403
C
          WDIR(NC1+KBAS,ND1+LBAS) = WDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(M, 5)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M, 9)*DENO(NA2+IBAS,NB1+JBAS)
C
          WDIR(NC1+KBAS,ND2+LBAS) = WDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(M, 2)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 6)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,10)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,14)*DENO(NA2+IBAS,NB2+JBAS)      
C
          WDIR(NC2+KBAS,ND1+LBAS) = WDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(M, 3)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(M, 7)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,11)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(M,15)*DENO(NA2+IBAS,NB2+JBAS)
C
          WDIR(NC2+KBAS,ND2+LBAS) = WDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(M, 8)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(M,12)*DENO(NA2+IBAS,NB1+JBAS)
C
403       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 04:
C     DIRECT INTEGRALS    ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LS,SL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 404
          N = N+1
          IF(IMTX(M, 4).EQ.0) GOTO 404
C
          WDIR(NC1+KBAS,ND1+LBAS) = WDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 5)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 9)*DENO(NB2+JBAS,NA1+IBAS)
C
          WDIR(NC1+KBAS,ND2+LBAS) = WDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,14)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 6)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,10)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 2)*DENO(NB2+JBAS,NA2+IBAS)
C
          WDIR(NC2+KBAS,ND1+LBAS) = WDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,15)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 7)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,11)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 3)*DENO(NB2+JBAS,NA2+IBAS)
C
          WDIR(NC2+KBAS,ND2+LBAS) = WDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(M, 8)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,12)*DENO(NB2+JBAS,NA1+IBAS)
C
404       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT WHEN IQL=IQR
460   CONTINUE
C
C     BATCH TYPE 05:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MD| MC, MB) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 405
          N = N+1
          IF(IMTX(M, 5).EQ.0) GOTO 405
C
          WXCH(NA1+IBAS,ND1+LBAS) = WXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 3)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 5)*DENO(NC1+KBAS,NB2+JBAS)
C
          WXCH(NA1+IBAS,ND2+LBAS) = WXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M, 2)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 4)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 6)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 8)*DENO(NC2+KBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,ND1+LBAS) = WXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M, 9)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M,11)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M,13)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M,15)*DENO(NC2+KBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,ND2+LBAS) = WXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(M,12)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M,14)*DENO(NC1+KBAS,NB2+JBAS)
C
405       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 06:             ~       ~
C     EXCHANGE INTEGRALS  ( MA, MC| MD, MB) =         ( MA, MB| MD, MC)
C     CALCULATES B^{LL,SS}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 406
          N = N+1
          IF(IMTX(M, 6).EQ.0) GOTO 406
C
          WXCH(NA1+IBAS,NC1+KBAS) = WXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 8)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M, 3)*DENO(ND2+LBAS,NB1+JBAS)
C
          WXCH(NA1+IBAS,NC2+KBAS) = WXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M, 2)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 6)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 1)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M, 5)*DENO(ND2+LBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,NC1+KBAS) = WXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M,12)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(M,16)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(M,11)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M,15)*DENO(ND2+LBAS,NB2+JBAS)
C
          WXCH(NA2+IBAS,NC2+KBAS) = WXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,14)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 9)*DENO(ND2+LBAS,NB1+JBAS)
C
406       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 07:             ~       ~
C     EXCHANGE INTEGRALS  ( MB, MD| MC, MA) =         ( MB, MA| MC, MD)
C     CALCULATES B^{SS,LL}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 407
          N = N+1
          IF(IMTX(M, 7).EQ.0) GOTO 407
C
          WXCH(NB1+JBAS,ND1+LBAS) = WXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 5)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(M,15)*DENO(NC2+KBAS,NA1+IBAS)
C
          WXCH(NB1+JBAS,ND2+LBAS) = WXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M,14)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 6)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(M,16)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(M, 8)*DENO(NC2+KBAS,NA2+IBAS)
C
          WXCH(NB2+JBAS,ND1+LBAS) = WXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 9)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 1)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,11)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M, 3)*DENO(NC2+KBAS,NA2+IBAS)
C
          WXCH(NB2+JBAS,ND2+LBAS) = WXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 2)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M,12)*DENO(NC2+KBAS,NA1+IBAS)
C
407       CONTINUE
        ENDDO
      ENDDO
C
C     APPLY AN EQ-COEFFICIENT REFLECTION FORMULA TO RECYCLE INTEGRALS
      IF(IQL.EQ.IQR) GOTO 470
C
C     BATCH TYPE 09:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MB| MA, MD) =         ( MA, MB| MC, MD)
C     CALCULATES B^{LS,LS}
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 409
          N = N+1
          IF(IMTX(M, 9).EQ.0) GOTO 409
C
          WXCH(NC1+KBAS,NB1+JBAS) = WXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(M, 2)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M, 9)*DENO(NA2+IBAS,ND1+LBAS)
C
          WXCH(NC1+KBAS,NB2+JBAS) = WXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(M, 5)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 6)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,13)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,14)*DENO(NA2+IBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NB1+JBAS) = WXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(M, 3)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(M, 4)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,11)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(M,12)*DENO(NA2+IBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NB2+JBAS) = WXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(M, 8)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(M,15)*DENO(NA2+IBAS,ND1+LBAS)
C
409       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 10:         ~       ~    
C     EXCHANGE INTEGRALS  ( MC, MA| MB, MD) =         ( MB, MA| MC, MD)
C     CALCULATES B^{LL,SS}                  = PAB*    (-MA,-MB| MC, MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 410
          N = N+1
          IF(IMTX(M,10).EQ.0) GOTO 410
C
          WXCH(NC1+KBAS,NA1+IBAS) = WXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,14)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M, 9)*DENO(NB2+JBAS,ND1+LBAS)
C
          WXCH(NC1+KBAS,NA2+IBAS) = WXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 5)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M, 6)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 1)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M, 2)*DENO(NB2+JBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NA1+IBAS) = WXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(M,15)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(M,16)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(M,11)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(M,12)*DENO(NB2+JBAS,ND2+LBAS)
C
          WXCH(NC2+KBAS,NA2+IBAS) = WXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(M, 8)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(M, 3)*DENO(NB2+JBAS,ND1+LBAS)
C
410       CONTINUE
        ENDDO
      ENDDO
C
C     BATCH TYPE 11:         ~       ~
C     EXCHANGE INTEGRALS  ( MD, MB| MA, MC) =         ( MA, MB| MD, MC)
C     CALCULATES B^{SS,LL}                  =     PCD*( MA, MB|-MC,-MD)
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF(ISCR(M).EQ.0) GOTO 411
          N = N+1
          IF(IMTX(M,11).EQ.0) GOTO 411
C
          WXCH(ND1+LBAS,NB1+JBAS) = WXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 2)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(M,12)*DENO(NA2+IBAS,NC1+KBAS)
C
          WXCH(ND1+LBAS,NB2+JBAS) = WXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 8)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M, 6)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(M,16)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(M,14)*DENO(NA2+IBAS,NC2+KBAS)
C
          WXCH(ND2+LBAS,NB1+JBAS) = WXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(M, 3)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 1)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,11)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(M, 9)*DENO(NA2+IBAS,NC2+KBAS)
C
          WXCH(ND2+LBAS,NB2+JBAS) = WXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(M, 5)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(M,15)*DENO(NA2+IBAS,NC1+KBAS)
C
411       CONTINUE
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQL=IQR
470   CONTINUE
C
C     SKIP POINT FOR ATOMS AND LINEAR MOLECULES
400   CONTINUE
C
C     SKIP POINT FOR CLOSED-SHELL MOLECULES
5000  CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
      SUBROUTINE COUPLE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         CCCCCC   OOOOOO  UU    UU PPPPPPP  LL       EEEEEEEE         C
C        CC    CC OO    OO UU    UU PP    PP LL       EE               C
C        CC       OO    OO UU    UU PP    PP LL       EE               C
C        CC       OO    OO UU    UU PP    PP LL       EEEEEE           C
C        CC       OO    OO UU    UU PPPPPPP  LL       EE               C
C        CC    CC OO    OO UU    UU PP       LL       EE               C
C         CCCCCC   OOOOOO   UUUUUU  PP       LLLLLLLL EEEEEEEE         C
C                                                                      C
C -------------------------------------------------------------------- C
C  COUPLE SPECIFIES THE OPEN-SHELL COUPLING MATRIX R:                  C
C               R = {S.D(O).Q + Q.D(O).S}  (RSCF 89)                   C
C  AND ADDS TO THE EXISTING DIRECT- AND EXCHANGE COULOMB/BREIT ARRAYS. C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMPLEX*16 X1,X2
      COMPLEX*16 T1(MDM,MDM),T2(MDM,MDM)
      COMPLEX*16 R1(MDM,MDM),R2(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
C
C**********************************************************************C
C     OPEN-SHELL COULOMB CONTRIBUTIONS                                 C
C**********************************************************************C
C
C     CONTRACT OVER 2ND AND 3RD MATRICES: T1(K,J) = D(K,L)*Q(L,J)
C                                         T2(K,J) = D(K,L)*S(L,J)
      DO K=1,NDIM
        DO J=1,NDIM
C
C         RESET SUM COUNTERS
          T1(K,J) = DCMPLX(0.0D0,0.0D0)
          T2(K,J) = DCMPLX(0.0D0,0.0D0)
C
C         PERFORM CONTRACTION
          DO L=1,NDIM
            T1(K,J) = T1(K,J) + DENT(K,L)*QDIR(L,J)-DENT(K,L)*QXCH(L,J)
            T2(K,J) = T2(K,J) + DENT(K,L)*OVLP(L,J)
          ENDDO
C
        ENDDO
      ENDDO
C
C     CONTRACT OVER 1ST AND 2ND MATRICES: R1(I,J) = S(I,K)*T1(K,J)
C                                         R2(I,J) = Q(I,K)*T2(K,J)
      DO I=1,NDIM
        DO J=1,NDIM
C
C         RESET SUM COUNTERS
          R1(I,J) = DCMPLX(0.0D0,0.0D0)
          R2(I,J) = DCMPLX(0.0D0,0.0D0)
C
C         PERFORM CONTRACTION
          DO K=1,NDIM
            R1(I,J) = R1(I,J) + OVLP(I,K)*T1(K,J)
            R2(I,J) = R2(I,J) + QDIR(I,K)*T2(K,J)-QXCH(I,K)*T2(K,J)
          ENDDO
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     OPEN-SHELL BREIT CONTRIBUTIONS                                   C
C**********************************************************************C
C
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 100
C
C     CONTRACT OVER 2ND AND 3RD MATRICES: T1(K,J) = D(K,L)*W(L,J)
C                                         T2(K,J) = D(K,L)*S(L,J)
      DO K=1,NDIM
        DO J=1,NDIM
C
C         RESET SUM COUNTERS
          T1(K,J) = DCMPLX(0.0D0,0.0D0)
          T2(K,J) = DCMPLX(0.0D0,0.0D0)
C
C         PERFORM CONTRACTION
          DO L=1,NDIM
            T1(K,J) = T1(K,J) + DENT(K,L)*WDIR(L,J)-DENT(K,L)*WXCH(L,J)
            T2(K,J) = T2(K,J) + DENT(K,L)*OVLP(L,J)
          ENDDO
C
        ENDDO
      ENDDO
C
C     CONTRACT OVER 1ST AND 2ND MATRICES: R1(I,J) = S(I,K)*T1(K,J)
C                                         R2(I,J) = W(I,K)*T2(K,J)
      DO I=1,NDIM
        DO J=1,NDIM
C
C         PERFORM CONTRACTION
          DO K=1,NDIM
            R1(I,J) = R1(I,J) + OVLP(I,K)*T1(K,J)
            R2(I,J) = R2(I,J) + WDIR(I,K)*T2(K,J)-WXCH(I,K)*T2(K,J)
          ENDDO
C
        ENDDO
      ENDDO
C
100   CONTINUE
C
C**********************************************************************C
C     TOTAL COUPLING MATRIX                                            C
C**********************************************************************C
C
C     COUPLING MATRIX ELEMENTS
      DO I=1,NDIM
        DO J=1,NDIM
          CPLE(I,J) = R1(I,J) + R2(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE SPARSITY(A,N,EPS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS  PPPPPPP     AA    RRRRRRR   SSSSSS IIII TTTTTTTT YY    YY  C
C  SS    SS PP    PP   AAAA   RR    RR SS    SS II     TT    YY    YY  C
C  SS       PP    PP  AA  AA  RR    RR SS       II     TT    YY    YY  C
C   SSSSSS  PP    PP AA    AA RR    RR  SSSSSS  II     TT     YY  YY   C
C        SS PPPPPPP  AAAAAAAA RRRRRRR        SS II     TT      YYYY    C
C  SS    SS PP       AA    AA RR    RR SS    SS II     TT       YY     C
C   SSSSSS  PP       AA    AA RR    RR  SSSSSS IIII    TT       YY     C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPARSITY APPLIES MATRIX SPARSITY CONDITIONS ON A COMPLEX-VALUED     C
C  ARRAY A OF DIMENSION N.                                             C
C**********************************************************************C
C
      COMPLEX*16 A(N,N)
C
C     LOOP OVER ALL MATRIX ELEMENTS
      DO I=1,NDIM
        DO J=1,NDIM
C
          X = DREAL(A(I,J))
          Y = DIMAG(A(I,J))
C
C         ELIMINATE ANY VANISHINGLY SMALL MATRIX ELEMENTS
          IF(DABS(X).LT.EPS) THEN
            X = 0.0D0
          ENDIF
          IF(DABS(Y).LT.EPS) THEN
            Y = 0.0D0
          ENDIF
C
C         ALSO ELMINATE ALL DIAGONAL IMAGINARY MATRIX ELEMENTS
          IF(I.EQ.J) THEN
            Y = 0.0D0
          ENDIF
C
C         TRANSFER ELEMENT BACK TO A MATRIX
          A(I,J) = DCMPLX(X,Y)
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE NCART(IVECT,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             NN    NN  CCCCCC     AA    RRRRRRR TTTTTTTT              C
C             NNN   NN CC    CC   AAAA   RR    RR   TT                 C
C             NNNN  NN CC        AA  AA  RR    RR   TT                 C
C             NN NN NN CC       AA    AA RR    RR   TT                 C
C             NN  NNNN CC       AAAAAAAA RRRRRRR    TT                 C
C             NN   NNN CC    CC AA    AA RR    RR   TT                 C
C             NN    NN  CCCCCC  AA    AA RR    RR   TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCART RETURNS THE CARTESIAN INDEX FROM THE INDEX VALUE IND.         C
C**********************************************************************C
C
      DIMENSION IVECT(3)
C
      IF(IND.EQ.1) THEN
        IVECT(1) = 1
        IVECT(2) = 0
        IVECT(3) = 0
      ELSEIF(IND.EQ.2) THEN
        IVECT(1) = 0
        IVECT(2) = 1
        IVECT(3) = 0
      ELSEIF(IND.EQ.3) THEN
        IVECT(1) = 0
        IVECT(2) = 0
        IVECT(3) = 1
      ELSE
        WRITE(6, *) 'In NCART: supplied index not valid',IND
        WRITE(7, *) 'In NCART: supplied index not valid',IND
        RETURN
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        NN    NN  CCCCCC  NN    NN TTTTTTTT RRRRRRR   SSSSSS          C
C        NNN   NN CC    CC NNN   NN    TT    RR    RR SS    SS         C
C        NNNN  NN CC       NNNN  NN    TT    RR    RR SS               C
C        NN NN NN CC       NN NN NN    TT    RR    RR  SSSSSS          C
C        NN  NNNN CC       NN  NNNN    TT    RRRRRRR        SS         C
C        NN   NNN CC    CC NN   NNN    TT    RR    RR SS    SS         C
C        NN    NN  CCCCCC  NN    NN    TT    RR    RR  SSSSSS          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCNTRS RETURNS NUMBER OF UNIQUE NUCLEAR CENTRES FROM INPUT VALUES.  C
C**********************************************************************C
C
C     STORE ICNTA IN FIRST PLACE
      NCNTRS = 1
C
C     CHECK ICNTB AGAINST STORED VALUES
      IF(ICNTB.NE.ICNTA) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTC AGAINST STORED VALUES
      IF(ICNTC.NE.ICNTA.AND.ICNTC.NE.ICNTB) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTD AGAINST STORED VALUES
      IF(ICNTD.NE.ICNTA.AND.ICNTD.NE.ICNTB.AND.ICNTD.NE.ICNTC) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ZPROJ(XYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            ZZZZZZZZ PPPPPPP  RRRRRRR   OOOOOO     JJJJJJ             C
C                 ZZ  PP    PP RR    RR OO    OO       JJ              C
C                ZZ   PP    PP RR    RR OO    OO       JJ              C
C               ZZ    PP    PP RR    RR OO    OO       JJ              C
C              ZZ     PPPPPPP  RRRRRRR  OO    OO       JJ              C
C             ZZ      PP       RR    RR OO    OO JJ    JJ              C
C            ZZZZZZZZ PP       RR    RR  OOOOOO   JJJJJJ               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZPROJ RETURNS THE SUM OF ABSOLUTE DIFFERENCES BETWEEN X AND Y       C
C  LOCATIONS OF FOUR SUPPLIED COORDINATES.                             C
C**********************************************************************C
C
       DIMENSION XYZ(3,4)
C
       ZPROJ = 0.0D0
C
       DO IX=1,2
         DO M=1,3
           DO N=M+1,4
             ZPROJ = ZPROJ + DABS(XYZ(IX,M)-XYZ(IX,N))
           ENDDO
         ENDDO
       ENDDO
C
       RETURN
       END
C
C
      FUNCTION LLAB(LQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 LL       LL          AA    BBBBBBB                   C
C                 LL       LL         AAAA   BB    BB                  C
C                 LL       LL        AA  AA  BB    BB                  C
C                 LL       LL       AA    AA BBBBBBB                   C
C                 LL       LL       AAAAAAAA BB    BB                  C
C                 LL       LL       AA    AA BB    BB                  C
C                 LLLLLLLL LLLLLLLL AA    AA BBBBBBB                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  LLAB RETURNS THE CONVENTIONAL ATOMIC ORBITAL TYPE LABEL FOR THE     C
C  NON-RELATIVISTIC QUANTUM NUMBER LQN OF LENGTH 1.                    C
C**********************************************************************C
C
      CHARACTER*1 LLAB
C
      IF(LQN.EQ.0) THEN
        LLAB = 's'
      ELSEIF(LQN.EQ.1) THEN
        LLAB = 'p'
      ELSEIF(LQN.EQ.2) THEN
        LLAB = 'd'
      ELSEIF(LQN.EQ.3) THEN
        LLAB = 'f'
      ELSEIF(LQN.EQ.4) THEN
        LLAB = 'g'
      ELSEIF(LQN.EQ.5) THEN
        LLAB = 'h'
      ELSEIF(LQN.EQ.6) THEN
        LLAB = 'i'
      ELSEIF(LQN.EQ.7) THEN
        LLAB = 'j'
      ELSEIF(LQN.EQ.8) THEN
        LLAB = 'k'
      ELSEIF(LQN.EQ.9) THEN
        LLAB = 'l'
      ELSEIF(LQN.EQ.10) THEN
        LLAB = 'm'
      ELSEIF(LQN.EQ.11) THEN
        LLAB = 'n'
      ELSEIF(LQN.EQ.12) THEN
        LLAB = 'o'
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION KLAB(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 KK    KK LL          AA    BBBBBBB                   C
C                 KK   KK  LL         AAAA   BB    BB                  C
C                 KK  KK   LL        AA  AA  BB    BB                  C
C                 KKKKK    LL       AA    AA BBBBBBB                   C
C                 KK  KK   LL       AAAAAAAA BB    BB                  C
C                 KK   KK  LL       AA    AA BB    BB                  C
C                 KK    KK LLLLLLLL AA    AA BBBBBBB                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLAB RETURNS THE CONVENTIONAL SYMMETRY TYPE LABEL FOR DIRAC         C
C  ORBITAL TYPE KQN AS A STRING OF LENGTH 2.                           C
C**********************************************************************C
C
       CHARACTER*1 LLAB,CHS
       CHARACTER*2 KLAB
C
       IF(KQN.LT.0) THEN
         LQN =-KQN-1
       ELSE
         LQN = KQN
       ENDIF
C
       IF(KQN.EQ.-1) THEN
         CHS = ' '
       ELSEIF(KQN.LT.0) THEN
         CHS = '-'
       ELSE
         CHS = '+'
       ENDIF
C
C      STITCH TOGETHER THE LQN TITLE AND THE PARITY LABEL
       WRITE(KLAB,'(A,A)') LLAB(LQN),CHS
C
       RETURN
       END
C
C
      FUNCTION MLAB(MQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                MM       MM LL          AA    BBBBBBB                 C
C                MMM     MMM LL         AAAA   BB    BB                C
C                MMMM   MMMM LL        AA  AA  BB    BB                C
C                MM MM MM MM LL       AA    AA BBBBBBB                 C
C                MM  MMM  MM LL       AAAAAAAA BB    BB                C
C                MM   M   MM LL       AA    AA BB    BB                C
C                MM       MM LLLLLLLL AA    AA BBBBBBB                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  MLAB RETURNS THE CONVENTIONAL SYMMETRY TYPE LABEL FOR DIRAC         C
C  MAGNETIC NUMBER MQN AS A STRING OF LENGTH 5.                        C
C**********************************************************************C
C
       CHARACTER*1 CHS
       CHARACTER*5 MLAB
C
       IF(MOD(MQN,2).EQ.0) THEN
         CHS = '+'
       ELSE
         CHS = '-'
       ENDIF
C
C      ODD INTEGER FOR NUMERATOR
       MAG = MQN-MOD(MQN+1,2)
C
C      STITCH TOGETHER THE MQN TITLE
       IF(MAG.LT.10) THEN
         WRITE(MLAB,'(A,I1,A)') CHS,MAG,'/2 '
       ELSE
         WRITE(MLAB,'(A,I2,A)') CHS,MAG,'/2'
       ENDIF
C
       RETURN
       END
C
C
C**********************************************************************C
C ==================================================================== C
C   [6] ONE-CENTRE ROUTINES: ATOMIC INTEGRALS FOR MOLECULAR PURPOSES.  C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] COULOMB1: ATOM-CENTRED CONTRIBUTIONS TO COULOMB MATRIX.        C
C   [B] RKCLM1: MAKES A BATCH OF RADIAL COULOMB INTEGRALS RK(ABCD).    C
C   [C] ANGCLM1: CONSTRUCTS ANGULAR COEFFICIENTS FOR COULOMB1.         C
C   [D] DK: ANGULAR AND CG-COEFFICIENT PRE-FACTORS FOR ANGCLM1.        C
C   [E] SYM3J: EVALUATES A WIGNER 3J-SYMBOL.                           C
C   [F] BREIT1: ONE-CENTRE CONTRIBUTION TO MOLECULAR BREIT MATRIX.     C
C   [G] RKBRT1: MAKES A BATCH OF RADIAL COULOMB INTEGRALS RK(ABCD).    C
C   [H] ANGBRT1: ANGULAR TERMS FOR ONE-CENTRE BREIT INTEGRALS.         C
C   [I] BRCOEF1: INTERMEDIATE COUPLING TERMS FOR ABOVE BREIT INTEGRALS.C
C   [J] IJSET1: BASIS SET INTERMEDIATES FOR IJ-PAIRS IN RKCLM1/RKBRT1. C
C   [K] KLSET1: BASIS SET INTERMEDIATES FOR KL-PAIRS IN RKCLM1/RKBRT1. C
C   [L] TESTANG: TESTS A FULL BATCH OF COMMON ANGULAR COEFFICIENTS.    C
C**********************************************************************C
C
C
      SUBROUTINE COULOMB1(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  CCCCCC   OOOOOO  UU    UU LL      OOOOOO  MM       MM BBBBBBB   11  C
C CC    CC OO    OO UU    UU LL     OO    OO MMM     MMM BB    BB 111  C
C CC       OO    OO UU    UU LL     OO    OO MMMM   MMMM BB    BB  11  C
C CC       OO    OO UU    UU LL     OO    OO MM MM MM MM BBBBBBB   11  C
C CC       OO    OO UU    UU LL     OO    OO MM  MMM  MM BB    BB  11  C
C CC    CC OO    OO UU    UU LL     OO    OO MM   M   MM BB    BB  11  C
C  CCCCCC   OOOOOO   UUUUUU  LLLLLLL OOOOOO  MM       MM BBBBBBB  1111 C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB1 CONSTRUCT ALL ATOM-CENTRED CONTRIBUTIONS TO THE MOLECULAR  C
C  MEAN-FIELD COULOMB MATRIX WITH RACAH ALGEBRA AND BETA INTEGRALS.    C
C  THIS ROUTINE IS SIMILAR TO THE IN-LINE CONSTRUCTION OF MEAN-FIELD   C
C  ATOMIC COULOMB MATRIX IN HFSCF0, BUT WITH MQN STRUCTURE AS WELL.    C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
      DIMENSION RJLLLL(MB2,MNU),RJLLSS(MB2,MNU),
     &          RJSSLL(MB2,MNU),RJSSSS(MB2,MNU)
      DIMENSION XLLLL(MB2),XSSLL(MB2),XLLSS(MB2),XSSSS(MB2)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TCVT,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     ANGULAR FACTOR SENSITIVITY PARAMETER
      DATA SENS/1.0D-10/
C
      CALL CPU_TIME(TBCH1)
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                        SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPE FOR A,B,C,D BLOCKS (USE INDEX 1000)  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 1000 KA=1,NKAP(IZ)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,IZ)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),IZ)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),IZ)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 1000 KB=1,NKAP(IZ)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,IZ)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),IZ)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),IZ)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 1000 KC=1,NKAP(IZ)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,IZ)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),IZ)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),IZ)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 1000 KD=1,NKAP(IZ)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,IZ)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),IZ)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),IZ)
        ENDDO
C
C     NUMBER OF BASIS FUNCTION COMBINATIONS IN (CD) BLOCK
      MAXM = NBAS(3)*NBAS(4)
C
C**********************************************************************C
C     PREPARE INTERMEDIATE DATA FOR USE IN RKCLM1                      C
C**********************************************************************C
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C1 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+1)
      C3 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+3)
      C5 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+5)
      C7 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+7)
      C9 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+9)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
      V8 = 8.0D0
      VS = 1.6D1
C
      TI = DFLOAT(LQN(1)+KQN(1)+1)
      TJ = DFLOAT(LQN(2)+KQN(2)+1)
      TK = DFLOAT(LQN(3)+KQN(3)+1)
      TL = DFLOAT(LQN(4)+KQN(4)+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
C
C     ANGULAR COEFFICIENTS
      CALL CPU_TIME(T1)
      CALL ANGCLM1(DKAB,DKCD,KQN,LQN,ISEL)
      CALL CPU_TIME(T2)
      TC1B = TC1B+T2-T1
C
C     EXIT THIS COMBINATION IF IT VIOLATES A SELECTION RULE
      IF(ISEL.EQ.0) GOTO 1001
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL CPU_TIME(T1)
      CALL KLSET1(IZ)
      CALL CPU_TIME(T2)
      TC1B = TC1B+T2-T1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 2000)         C
C**********************************************************************C
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      IF(HMLT.EQ.'NORL') THEN
        N2EB(1,1) = N2EB(1,1) + 1
      ELSE
        N2EB(1,1) = N2EB(1,1) + 1
        N2EB(1,2) = N2EB(1,2) + 1
        N2EB(1,3) = N2EB(1,3) + 1
        N2EB(1,4) = N2EB(1,4) + 1
      ENDIF
C
      DO 2000 IBAS=1,NBAS(1)
      DO 2000 JBAS=1,NBAS(2)
C
C       UPDATE COUNTER FOR NUMBER OF INTEGRALS
        IF(HMLT.EQ.'NORL') THEN
          N2EI(1,1) = N2EI(1,1) + NBAS(3)*NBAS(4)
        ELSE
          N2EI(1,1) = N2EI(1,1) + NBAS(3)*NBAS(4)
          N2EI(1,2) = N2EI(1,2) + NBAS(3)*NBAS(4)
          N2EI(1,3) = N2EI(1,3) + NBAS(3)*NBAS(4)
          N2EI(1,4) = N2EI(1,4) + NBAS(3)*NBAS(4)
        ENDIF
C
C       BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
        CALL CPU_TIME(T1)
        CALL IJSET1
        CALL CPU_TIME(T2)
        TC1B = TC1B+T2-T1
C
C       BATCH OF RADIAL INTEGRALS (EFFECTIVE INTERACTION STRENGTHS)
        CALL CPU_TIME(T1)
        CALL RKCLM1(RJLLLL,RJLLSS,RJSSLL,RJSSSS)
        CALL CPU_TIME(T2)
        TC1R = TC1R+T2-T1
C
C       CAN NOW CONTRACT THESE RADIAL INTEGRALS OVER ANGULAR COMPONENTS
C       OF G-SPINOR BASIS FUNCTIONS USING A TENSOR EXPANSION IN {L,Q}
C
C**********************************************************************C
C     LOOP OVER |MQN| MAGNITUDES FOR A,B,C,D BLOCKS (USE INDEX 3000)   C
C**********************************************************************C
C
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C**********************************************************************C
C     LOOP OVER THE SIGNS OF |MQN| FOR A,B,C,D BLOCKS (USE INDEX 4000) C
C**********************************************************************C
C
      DO 4000 ISGN1=1,2
        MMJA = MQN(1)*((-1)**ISGN1)
        IMJA = MQN(1)+ISGN1-1
C
      DO 4000 ISGN2=1,2
        MMJB = MQN(2)*((-1)**ISGN2)
        IMJB = MQN(2)+ISGN2-1
C
      DO 4000 ISGN3=1,2
        MMJC = MQN(3)*((-1)**ISGN3)
        IMJC = MQN(3)+ISGN3-1
C
      DO 4000 ISGN4=1,2
        MMJD = MQN(4)*((-1)**ISGN4)
        IMJD = MQN(4)+ISGN4-1
C
C     STARTING FOCK ADDRESS FOR EACH BASIS LIST
      NAL = LRGE(IZ,KA,IMJA)
      NBL = LRGE(IZ,KB,IMJB)
      NCL = LRGE(IZ,KC,IMJC)
      NDL = LRGE(IZ,KD,IMJD)
C
      NAS = LRGE(IZ,KA,IMJA)+NSKP
      NBS = LRGE(IZ,KB,IMJB)+NSKP
      NCS = LRGE(IZ,KC,IMJC)+NSKP
      NDS = LRGE(IZ,KD,IMJD)+NSKP
C
C     APPLY ANGULAR MQN SELECTION RULE
      IF(MMJA-MMJB.NE.MMJD-MMJC) GOTO 4001
      IF(ISYM.EQ.1) THEN
        IF(ISGN1.EQ.ISGN2.AND.ISGN3.EQ.ISGN4) GOTO 4002
        IF(ISGN1.EQ.ISGN4.AND.ISGN3.EQ.ISGN2) GOTO 4002     
        GOTO 4001
      ENDIF
4002  CONTINUE
C
C     INITIALISE EFFECTIVE INTERACTION STRENGTH VALUES
      CALL CPU_TIME(T1)
      DO M=1,NBAS(3)*NBAS(4)
        XLLLL(M) = 0.0D0
        XLLSS(M) = 0.0D0
        XSSLL(M) = 0.0D0
        XSSSS(M) = 0.0D0
      ENDDO
C
C     ASSEMBLE INTEGRAL BY SUMMING OVER EXPANSION POWER L
      DO LTEN=1,NUNUM
C
C       ANGULAR COEFFICIENT
        ANGFAC = DKAB(LTEN,IMJA,IMJB)*DKCD(LTEN,IMJC,IMJD)
C
C       SCREENING OF INTEGRAL BASED ON ANGULAR COEFFICIENT
        IF(DABS(ANGFAC).LE.SENS) GOTO 4003
C
        IF(HMLT.EQ.'NORL') THEN
C       NON-RELATIVISTIC HAMILTONIAN
C
          DO M=1,NBAS(3)*NBAS(4)
            XLLLL(M) = XLLLL(M) + ANGFAC*RJLLLL(M,LTEN)
          ENDDO
C
        ELSE
C       RELATIVISTIC HAMILTONIAN
C
          DO M=1,NBAS(3)*NBAS(4)
            XLLLL(M) = XLLLL(M) + ANGFAC*RJLLLL(M,LTEN)
            XLLSS(M) = XLLSS(M) + ANGFAC*RJLLSS(M,LTEN)
            XSSLL(M) = XSSLL(M) + ANGFAC*RJSSLL(M,LTEN)
            XSSSS(M) = XSSSS(M) + ANGFAC*RJSSSS(M,LTEN)
          ENDDO
C
        ENDIF
C
C       SKIP POINT FOR ANGULAR SCREENING
4003    CONTINUE
C
      ENDDO
C
C     FULL-INTEGRAL CONSTRUCTION COMPLETE
      CALL CPU_TIME(T2)
      TC1F = TC1F+T2-T1
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO CLOSED-SHELL COULOMB MATRIX     C
C -------------------------------------------------------------------- C
C     TODO: BE AWARE THAT THERE ARE ISSUES WITH NUMERICAL ACCURACY     C
C           IN THIS METHOD, STEMMING FROM ACCUMULATING ERRORS IN THE   C
C           FLOATING-POINT REPRESENTATION OF INTEGERS AND RATIONALS.   C
C           (EG. ANGFAC^2 IS A RATIONAL NUMBER).                       C
C**********************************************************************C
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       DIRECT CONTRIBUTIONS
        IF(ISYM.EQ.1) THEN
          IF(ISGN1.NE.ISGN2.OR.ISGN3.NE.ISGN4) GOTO 5001
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NDL+LBAS)
C
          ENDDO
        ENDDO
5001    CONTINUE
C
C       EXCHANGE CONTRIBUTIONS
        IF(ISYM.EQ.1) THEN
          IF(ISGN1.NE.ISGN4.OR.ISGN3.NE.ISGN2) GOTO 5002
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS) 
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NBL+JBAS)
C
          ENDDO
        ENDDO
5002    CONTINUE
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C       DIRECT CONTRIBUTIONS
        IF(ISYM.EQ.1) THEN
          IF(ISGN1.NE.ISGN2.OR.ISGN3.NE.ISGN4) GOTO 5003
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NDL+LBAS)
     &                          +      XLLSS(M)*DENT(NCS+KBAS,NDS+LBAS)
C
            GDIR(NAS+IBAS,NBS+JBAS) = GDIR(NAS+IBAS,NBS+JBAS)
     &                          +      XSSLL(M)*DENT(NCL+KBAS,NDL+LBAS)
     &                          +      XSSSS(M)*DENT(NCS+KBAS,NDS+LBAS)
C
          ENDDO
        ENDDO
5003    CONTINUE
C
C       EXCHANGE CONTRIBUTIONS
        IF(ISYM.EQ.1) THEN
          IF(ISGN1.NE.ISGN4.OR.ISGN3.NE.ISGN2) GOTO 5004
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS)
     &                          +      XLLLL(M)*DENT(NCL+KBAS,NBL+JBAS)
C
            GXCH(NAL+IBAS,NDS+LBAS) = GXCH(NAL+IBAS,NDS+LBAS)
     &                          +      XLLSS(M)*DENT(NCS+KBAS,NBL+JBAS)
C
            GXCH(NAS+IBAS,NDL+LBAS) = GXCH(NAS+IBAS,NDL+LBAS)
     &                          +      XSSLL(M)*DENT(NCL+KBAS,NBS+JBAS)
C
            GXCH(NAS+IBAS,NDS+LBAS) = GXCH(NAS+IBAS,NDS+LBAS)
     &                          +      XSSSS(M)*DENT(NCS+KBAS,NBS+JBAS)
C
          ENDDO
        ENDDO
5004    CONTINUE
C
      ENDIF
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL COULOMB MATRIX       C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5100
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       DIRECT CONTRIBUTIONS
        IF(ISYM.EQ.1) THEN
          IF(ISGN1.NE.ISGN2.OR.ISGN3.NE.ISGN4) GOTO 5005
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS)
     &                          + ACFF*XLLLL(M)*DENO(NCL+KBAS,NDL+LBAS)
C
          ENDDO
        ENDDO
5005    CONTINUE
C
C       EXCHANGE CONTRIBUTIONS
        IF(ISYM.EQ.1) THEN
          IF(ISGN1.NE.ISGN4.OR.ISGN3.NE.ISGN2) GOTO 5006
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C           
            QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                          + BCFF*XLLLL(M)*DENO(NCL+KBAS,NBL+JBAS)
C
          ENDDO
        ENDDO
5006    CONTINUE
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C       DIRECT CONTRIBUTIONS
        IF(ISYM.EQ.1) THEN
          IF(ISGN1.NE.ISGN2.OR.ISGN3.NE.ISGN4) GOTO 5007
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS)
     &                          + ACFF*XLLLL(M)*DENO(NCL+KBAS,NDL+LBAS)
     &                          + ACFF*XLLSS(M)*DENO(NCS+KBAS,NDS+LBAS)
C
            QDIR(NAS+IBAS,NBS+JBAS) = QDIR(NAS+IBAS,NBS+JBAS)
     &                          + ACFF*XSSLL(M)*DENO(NCL+KBAS,NDL+LBAS)
     &                          + ACFF*XSSSS(M)*DENO(NCS+KBAS,NDS+LBAS)
C
          ENDDO
        ENDDO
5007    CONTINUE
C
C       EXCHANGE CONTRIBUTIONS
        IF(ISYM.EQ.1) THEN
          IF(ISGN1.NE.ISGN4.OR.ISGN3.NE.ISGN2) GOTO 5008
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                          + BCFF*XLLLL(M)*DENO(NCL+KBAS,NBL+JBAS)
C
            QXCH(NAL+IBAS,NDS+LBAS) = QXCH(NAL+IBAS,NDS+LBAS)
     &                          + BCFF*XLLSS(M)*DENO(NCS+KBAS,NBL+JBAS)
C
            QXCH(NAS+IBAS,NDL+LBAS) = QXCH(NAS+IBAS,NDL+LBAS)
     &                          + BCFF*XSSLL(M)*DENO(NCL+KBAS,NBS+JBAS)
            
            QXCH(NAS+IBAS,NDS+LBAS) = QXCH(NAS+IBAS,NDS+LBAS)
     &                          + BCFF*XSSSS(M)*DENO(NCS+KBAS,NBS+JBAS)
C
          ENDDO
        ENDDO
5008    CONTINUE
C
      ENDIF
C
5100  CONTINUE
C
C     MATRIX MULTIPLICATION STEP COMPLETE
      CALL CPU_TIME(T3)
      TC1M = TC1M+T3-T2
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL ONE-CENTRE CONTRIBUTIONS.           C
C**********************************************************************C
C
C     EARLY EXIT FOR MQN SELECTION RULES
4001  CONTINUE
C     END LOOP OVER ALL |MQN| SIGNS
4000  CONTINUE
C     END LOOP OVER ALL |MQN| MAGNITUDES
3000  CONTINUE
C     END LOOP OVER IBAS AND JBAS
2000  CONTINUE
C     EARLY EXIT FOR KQN SELECTION RULES
1001  CONTINUE
C     END LOOP OVER ALL KQNS
1000  CONTINUE
C
C     RECORD CPU TIME AT END OF BATCH AND ADD TO APPROPRIATE COUNTER
      CALL CPU_TIME(TBCH2)
      IF(HMLT.EQ.'NORL') THEN
        T2ES(1,1) = T2ES(1,1) + TBCH2 - TBCH1
      ELSE
        T2ES(1,1) = T2ES(1,1) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,2) = T2ES(1,2) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,3) = T2ES(1,3) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,4) = T2ES(1,4) + 0.25D0*(TBCH2-TBCH1)
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE RKCLM1(RJLLLL,RJLLSS,RJSSLL,RJSSSS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         RRRRRRR  KK    KK CCCCCC  LL       MM       MM  11           C
C         RR    RR KK   KK CC    CC LL       MMM     MMM 111           C
C         RR    RR KK  KK  CC       LL       MMMM   MMMM  11           C
C         RR    RR KKKKK   CC       LL       MM MM MM MM  11           C
C         RRRRRRR  KK  KK  CC       LL       MM  MMM  MM  11           C
C         RR    RR KK   KK CC    CC LL       MM   M   MM  11           C
C         RR    RR KK    KK CCCCCC  LLLLLLLL MM       MM 1111          C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKCLM1 EVALUATES A BATCH OF GENERAL (OPEN-SHELL) ONE-CENTRE RADIAL  C
C  INTEGRALS OVER THE COULOMB INTERACTION, SEPARATING RESULTS BY THE   C
C  ALLOWED TENSOR ORDERS RK(ABCD).                                     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION XJ(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
      DIMENSION BDU(MB2,-MAB:MAB,-MAB:MAB),BDL(MB2,-MAB:MAB,-MAB:MAB)
C
      DIMENSION RJLLLL(MB2,MNU),RJLLSS(MB2,MNU),
     &          RJSSLL(MB2,MNU),RJSSSS(MB2,MNU)
C
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B0KL/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL EXCHANGE INTEGRALS
      NVALS = (NUF-NUI)/2+3
C
C     LOOP OVER EXPANSION TERMINALS FOR FIRST PAIR
      DO NX=1,NVALS
        IAA(1) = LQN(1)+LQN(2)+NUI+2*NX-1
        IAA(2) = LQN(3)+LQN(4)+NUI+2*NX-1
C
C       LOOP OVER EXPANSION TERMINALS FOR SECOND PAIR
        DO NY=1,NVALS
          IBB(1) = LQN(3)+LQN(4)-NUF+2*NY-2
          IBB(2) = LQN(1)+LQN(2)-NUF+2*NY-2
C
C         LOOP OVER BETA INTEGRAL COMBINATIONS
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BDU(M, NUI+2*NX-1,-NUF+2*NY-2) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BDL(M, NUI+2*NX-1,-NUF+2*NY-2) = BETA(M)
              ENDDO
            ENDIF

          ENDDO

        ENDDO
      ENDDO
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR INTEGRALS
      DO M=1,MAXM
        DO LTEN=1,NUNUM
          RJLLLL(M,LTEN) = 0.0D0
          RJLLSS(M,LTEN) = 0.0D0
          RJSSLL(M,LTEN) = 0.0D0
          RJSSSS(M,LTEN) = 0.0D0
        ENDDO
      ENDDO
C
C     VALUE PREPARATION
      E0000 = 1.0D0
      E1000 = EI
      E0100 = EJ
      E1100 = EI*EJ
C
C     LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1010 = EI*EK(M)
        E1001 = EI*EL(M)
        E0110 = EJ*EK(M)
        E0101 = EJ*EL(M)
        E0011 = EK(M)*EL(M)
        E1110 = EI*EJ*EK(M)
        E1101 = EI*EJ*EL(M)
        E1011 = EI*EK(M)*EL(M)
        E0111 = EJ*EK(M)*EL(M)
        E1111 = EI*EJ*EK(M)*EL(M)
C
C       LOOP OVER THE TENSOR ORDERS OF THE COULOMB INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C**********************************************************************C
C     SPECIAL CASE: NON-RELATIVISTIC HAMILTONIAN                       C
C**********************************************************************C
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
C           BETA INTEGRALS WITH POWERS OF EXPONENTIALS
            B32 = EIJ(-NU+2)*EKL(M, NU+3)*BDL(M, NU+3,-NU+2)
     &          + EIJ( NU+3)*EKL(M,-NU+2)*BDU(M, NU+3,-NU+2)
C
C           EFFECTIVE INTERACTION STRENGTH FOR THIS TENSOR ORDER
            RJLLLL(M,LTEN) = C5*B32
C
C           SKIP PAST THE RELATIVISTIC STAGES
            GOTO 999
C
          ENDIF
C
C**********************************************************************C
C     LARGER CASE: RELATIVISTIC HAMILTONIAN (T TERMS GIVE ZEROES)      C
C**********************************************************************C
C
C         TEMPORARY STORAGE OF RAW RJ(LTEN,M)
          B10 = EIJ(-NU  )*EKL(M, NU+1)*BDL(M, NU+1,-NU  )
     &        + EIJ( NU+1)*EKL(M,-NU  )*BDU(M, NU+1,-NU  )
          B12 = EIJ(-NU+2)*EKL(M, NU+1)*BDL(M, NU+1,-NU+2)
     &        + EIJ( NU+3)*EKL(M,-NU  )*BDU(M, NU+3,-NU  )
          B14 = EIJ(-NU+4)*EKL(M, NU+1)*BDL(M, NU+1,-NU+4)
     &        + EIJ( NU+5)*EKL(M,-NU  )*BDU(M, NU+5,-NU  )
          B30 = EIJ(-NU  )*EKL(M, NU+3)*BDL(M, NU+3,-NU  )
     &        + EIJ( NU+1)*EKL(M,-NU+2)*BDU(M, NU+1,-NU+2)
          B32 = EIJ(-NU+2)*EKL(M, NU+3)*BDL(M, NU+3,-NU+2)
     &        + EIJ( NU+3)*EKL(M,-NU+2)*BDU(M, NU+3,-NU+2)
          B34 = EIJ(-NU+4)*EKL(M, NU+3)*BDL(M, NU+3,-NU+4)
     &        + EIJ( NU+5)*EKL(M,-NU+2)*BDU(M, NU+5,-NU+2)
          B50 = EIJ(-NU  )*EKL(M, NU+5)*BDL(M, NU+5,-NU  )
     &        + EIJ( NU+1)*EKL(M,-NU+4)*BDU(M, NU+1,-NU+4)
          B52 = EIJ(-NU+2)*EKL(M, NU+5)*BDL(M, NU+5,-NU+2)
     &        + EIJ( NU+3)*EKL(M,-NU+4)*BDU(M, NU+3,-NU+4)
          B54 = EIJ(-NU+4)*EKL(M, NU+5)*BDL(M, NU+5,-NU+4)
     &        + EIJ( NU+5)*EKL(M,-NU+4)*BDU(M, NU+5,-NU+4)
C
C         EFFECTIVE INTERACTION STRENGTH RJLLLL(M,LTEN)
          RJLLLL(M,LTEN) = V1*T0000*E0000*C5*B32
C
C         EFFECTIVE INTERACTION STRENGTH RJLLSS(M,LTEN)
          RJLLSS(M,LTEN) = V4*T0000*E0011*C7*B52 - V2*T0001*E0010*C5*B32
     &                   - V2*T0010*E0001*C5*B32 + V1*T0011*E0000*C3*B12
C
C         EFFECTIVE INTERACTION STRENGTH RJSSLL(M,LTEN)
          RJSSLL(M,LTEN) = V4*T0000*E1100*C7*B34 - V2*T0100*E1000*C5*B32
     &                   - V2*T1000*E0100*C5*B32 + V1*T1100*E0000*C3*B30
C
C         EFFECTIVE INTERACTION STRENGTH RJSSSS(M,LTEN)
          RJSSSS(M,LTEN) = VS*T0000*E1111*C9*B54
     &                   - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B34
     &                   - V8*T0100*E1011*C7*B52 - V8*T1000*E0111*C7*B52
     &                   + V4*T1100*E0011*C5*B50 + V4*T0011*E1100*C5*B14
     &                   + V4*T1001*E0110*C5*B32 + V4*T0110*E1001*C5*B32
     &                   + V4*T0101*E1010*C5*B32 + V4*T1010*E0101*C5*B32
     &                   - V2*T1101*E0010*C3*B30 - V2*T0111*E1000*C3*B12
     &                   - V2*T1110*E0001*C3*B30 - V2*T1011*E0100*C3*B12
     &                   + V1*T1111*E0000*C1*B10
C
C         SKIP POINT FOR NON-RELATIVISTIC HAMILTONIANS
999       CONTINUE
C
C       END LOOP OVER TENSOR ORDERS
        ENDDO
C
C     END LOOP OVER K,L BASIS FUNCTIONS
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      IF(HMLT.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          RNLLLL = RNIJ(1)*RNKL(M,1)
          DO LTEN=1,NUNUM
            RJLLLL(M,LTEN) = RNLLLL*RJLLLL(M,LTEN)
          ENDDO
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          RNLLLL = RNIJ(1)*RNKL(M,1)
          RNLLSS = RNIJ(1)*RNKL(M,3)
          RNSSLL = RNIJ(3)*RNKL(M,1)
          RNSSSS = RNIJ(3)*RNKL(M,3)
          DO LTEN=1,NUNUM
            RJLLLL(M,LTEN) = RNLLLL*RJLLLL(M,LTEN)
            RJLLSS(M,LTEN) = RNLLSS*RJLLSS(M,LTEN)
            RJSSLL(M,LTEN) = RNSSLL*RJSSLL(M,LTEN)
            RJSSSS(M,LTEN) = RNSSSS*RJSSSS(M,LTEN)
          ENDDO
        ENDDO
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ANGCLM1(DKAB,DKCD,KQN,LQN,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       AA    NN    NN  GGGGGG   CCCCCC  LL       MM       MM  11      C
C      AAAA   NNN   NN GG    GG CC    CC LL       MMM     MMM 111      C
C     AA  AA  NNNN  NN GG       CC       LL       MMMM   MMMM  11      C
C    AA    AA NN NN NN GG       CC       LL       MM MM MM MM  11      C
C    AAAAAAAA NN  NNNN GG   GGG CC       LL       MM  MMM  MM  11      C
C    AA    AA NN   NNN GG    GG CC    CC LL       MM   M   MM  11      C
C    AA    AA NN    NN  GGGGGG   CCCCCC  LLLLLLLL MM       MM 1111     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGCLM1 PERFORMS THE ANGULAR ANALYSIS FOR THE EVALUATION OF TWO     C
C  ELECTRON INTEGRALS USING RACAH ALGEBRA TECHNIQUES. (OPEN-SHELL.)    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION KQN(4),LQN(4),JQN(4)
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
C
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C**********************************************************************C
C     PARITY ANALYSIS: CHECK UNDERLYING LQN COMBINATIONS AND EXIT      C
C     IF THERE IS NO MULTIPOLE EXPANSION OF THE INTERACTION.           C
C**********************************************************************C
C
C     A AND B: PARITY OF 'LQN(1)+LQN(2)' (0 IF EVEN, 1 IF ODD)
      IPARAB = MOD(LQN(1)+LQN(2),2)
C
C     C AND D: PARITY OF 'LQN(3)+LQN(4)' (0 IF EVEN, 1 IF ODD)
      IPARCD = MOD(LQN(3)+LQN(4),2)
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.EQ.IPARCD) THEN
        ISEL = 1
      ELSE
        ISEL = 0
        RETURN
      ENDIF
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
C     TENSOR LIMITS BY TRIANGLE RULE
      NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
      NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
C
C     JQN SELECTION RULE: TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUI.GT.NUF) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     FURTHER PARITY ANALYSIS: RUN OVER ALLOWED TENSOR ORDERS NU AND   C
C     SCREEN THOSE WHICH ARE NOT ALLOWED ON PARITY GROUNDS.            C
C**********************************************************************C
C
      NUNUM = 0
      DO NU=NUI,NUF
C
C       A AND B: PARITY OF 'LQN(1)+LQN(2)+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
C       C AND D: PARITY OF 'LQN(3)+LQN(4)+NU' (0 IF EVEN, 1 IF ODD)
        IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C       LQN SELECTION RULE: WHEN SUM OF A AND B, C AND D EVEN
        IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) THEN
C
C         INCREASE TOTAL NUMBER OF NU VALUES TO BE FACILITATED
          NUNUM = NUNUM+1
C
C         SAVE THIS PARTICULAR NU VALUE TO A LIST
          NUS(NUNUM) = NU
C
        ENDIF
C
      ENDDO
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, EXIT PROCEDURE
      IF(NUNUM.EQ.0) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C     RE-SET THE LOWER AND UPPER LIMITS OF THE EXPANSION
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C**********************************************************************C
C     WIGNER-ECKART: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|        C
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.   C
C**********************************************************************C
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(1),-MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(1), MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(1),-MJA,JQN(2), MJB,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(1), MJA,JQN(2), MJB,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     THE ARGUMENTS OF DK COEFFICIENTS ARE REVERSED IN THE CASE OF THE
C     CD PAIRS IN ORDER TO ACCOMMODATE THE RELATION:
C               DK(J,M,J',M',L) = ((-1)^Q)*DK(J',M',J,M,L).
C
C     LOOP OVER MQN(C) AND MQN(D) VALUES
      DO MC=1,IABS(KQN(3))
        MJC = 2*MC-1
        DO MD=1,IABS(KQN(4))
          MJD = 2*MD-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKCD(LTEN,MJC  ,MJD  ) = DK(JQN(4),-MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD  ) = DK(JQN(4),-MJD,JQN(3), MJC,NU)
            DKCD(LTEN,MJC  ,MJD+1) = DK(JQN(4), MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD+1) = DK(JQN(4), MJD,JQN(3), MJC,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BREIT1(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT 11              C
C             BB    BB RR    RR EE        II     TT   111              C
C             BB    BB RR    RR EE        II     TT    11              C
C             BBBBBBB  RR    RR EEEEEE    II     TT    11              C
C             BB    BB RRRRRRR  EE        II     TT    11              C
C             BB    BB RR    RR EE        II     TT    11              C
C             BBBBBBB  RR    RR EEEEEEEE IIII    TT   1111             C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT1 CONSTRUCTS A ONE-CENTRE CONTRIBUTION TO THE MOLECULAR        C
C  MEAN-FIELD BREIT MATRIX WITH RACAH ALGEBRA AND BETA INTEGRALS.      C
C  THIS ROUTINE IS SIMILAR TO THE IN-LINE CONSTRUCTION OF MEAN-FIELD   C
C  ATOMIC BREIT MATRIX IN HFSCF0, BUT WITH MQN STRUCTURE AS WELL.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ANGFAC(8)
      DIMENSION BCOF(MNU,8,MKP+1,MKP+1,MKP+1,MKP+1)
      DIMENSION RJLSLS(MB2,MNU,2),RJSLSL(MB2,MNU,2),
     &          RJLSSL(MB2,MNU,2),RJSLLS(MB2,MNU,2)
      DIMENSION XLSLS(MB2),XSLSL(MB2),XLSSL(MB2),XSLLS(MB2)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(MDM),IOPN(MDM),NCLS,NOPN,NOELEC
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TCVT,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     ANGULAR FACTOR SENSITIVITY PARAMETER
      DATA SENS/1.0D-10/
C
      CALL CPU_TIME(TBCH1)
C
C     INTEGRAL SKIPPING ON MOLECULAR GROUP SYMMETRY CLASS BASIS
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.
     &                        SHAPE.EQ.'LINEAR') THEN
        ISYM = 1
      ELSE
        ISYM = 0
      ENDIF
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPE FOR A,B,C,D BLOCKS (USE INDEX 1000)  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 1000 KA=1,NKAP(IZ)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,IZ)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),IZ)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),IZ)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 1000 KB=1,NKAP(IZ)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,IZ)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),IZ)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),IZ)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 1000 KC=1,NKAP(IZ)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,IZ)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),IZ)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),IZ)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 1000 KD=1,NKAP(IZ)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,IZ)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),IZ)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),IZ)
        ENDDO
C
C       NUMBER OF BASIS FUNCTIONS IN (CD) BLOCK
        MAXM = NBAS(3)*NBAS(4)
C
C**********************************************************************C
C     PREPARE INTERMEDIATE DATA FOR USE IN RKBRT1                      C
C**********************************************************************C
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C3 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+3)
      C5 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+5)
      C7 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+7)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
C
      TI = DFLOAT(LQN(1)+KQN(1)+1)
      TJ = DFLOAT(LQN(2)+KQN(2)+1)
      TK = DFLOAT(LQN(3)+KQN(3)+1)
      TL = DFLOAT(LQN(4)+KQN(4)+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
C
C     ANGULAR COEFFICIENTS
      CALL CPU_TIME(T1)
      CALL ANGBRT1(BCOF,KQN,LQN,ISEL)
      CALL CPU_TIME(T2)
      TB1B = TB1B+T2-T1
C
C     EXIT THIS COMBINATION IF IT VIOLATES A SELECTION RULE
      IF(ISEL.EQ.0) GOTO 1001
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL CPU_TIME(T1)
      CALL KLSET1(IZ)
      CALL CPU_TIME(T2)
      TB1B = TB1B+T2-T1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 2000)         C
C**********************************************************************C
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      N2EB(1,5) = N2EB(1,5)+1
C
      DO 2000 IBAS=1,NBAS(1)
      DO 2000 JBAS=1,NBAS(2)
C
C       UPDATE COUNTER FOR NUMBER OF INTEGRALS
        N2EI(1,5) = N2EI(1,5) + NBAS(3)*NBAS(4)
C
C       BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
        CALL CPU_TIME(T1)
        CALL IJSET1
        CALL CPU_TIME(T2)
        TB1B = TB1B+T2-T1
C
C       BATCH OF RADIAL INTEGRALS (EFFECTIVE INTERACTION STRENGTHS)
        CALL CPU_TIME(T1)
        CALL RKBRT1(RJLSLS,RJSLSL,RJLSSL,RJSLLS)
        CALL CPU_TIME(T2)
        TB1R = TB1R+T2-T1
C
C       CAN NOW CONTRACT THESE RADIAL INTEGRALS OVER ANGULAR COMPONENTS
C       OF G-SPINOR BASIS FUNCTIONS USING A TENSOR EXPANSION IN {L,Q}
C
C**********************************************************************C
C     LOOP OVER |KQN| MAGNITUDES FOR A,B,C,D BLOCKS (USE INDEX 3000)   C
C**********************************************************************C
C
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C**********************************************************************C
C     LOOP OVER THE SIGNS OF |MQN| FOR A,B,C,D BLOCKS (USE INDEX 4000) C
C**********************************************************************C
C
      DO 4000 ISGN1=1,2
        MMJA = MQN(1)*((-1)**ISGN1)
        IMJA = MQN(1)+ISGN1-1
C
      DO 4000 ISGN2=1,2
        MMJB = MQN(2)*((-1)**ISGN2)
        IMJB = MQN(2)+ISGN2-1
C
      DO 4000 ISGN3=1,2
        MMJC = MQN(3)*((-1)**ISGN3)
        IMJC = MQN(3)+ISGN3-1
C
      DO 4000 ISGN4=1,2
        MMJD = MQN(4)*((-1)**ISGN4)
        IMJD = MQN(4)+ISGN4-1
C
C     STARTING FOCK ADDRESS FOR EACH BASIS LIST
      NAL = LRGE(IZ,KA,IMJA)
      NBL = LRGE(IZ,KB,IMJB)
      NCL = LRGE(IZ,KC,IMJC)
      NDL = LRGE(IZ,KD,IMJD)
C
      NAS = LRGE(IZ,KA,IMJA) + NSKP
      NBS = LRGE(IZ,KB,IMJB) + NSKP
      NCS = LRGE(IZ,KC,IMJC) + NSKP
      NDS = LRGE(IZ,KD,IMJD) + NSKP
C
C     APPLY ANGULAR MQN SELECTION RULE
      IF(MMJA-MMJB.NE.MMJD-MMJC) GOTO 4001
      IF(ISYM.EQ.1) THEN
        IF(ISGN1.EQ.ISGN2.AND.ISGN3.EQ.ISGN4) GOTO 4002
        IF(ISGN1.EQ.ISGN4.AND.ISGN3.EQ.ISGN2) GOTO 4002     
        GOTO 4001
      ENDIF
4002  CONTINUE
C
C     RESET CONTRACTED RADIAL ARRAYS
      CALL CPU_TIME(T1)
      DO M=1,NBAS(3)*NBAS(4)
        XLSLS(M) = 0.0D0
        XSLSL(M) = 0.0D0
        XLSSL(M) = 0.0D0
        XSLLS(M) = 0.0D0
      ENDDO
C
C     ASSEMBLE INTEGRAL BY SUMMING OVER EXPANSION POWER L
      DO LTEN=1,NUNUM
C
C       ANGULAR COEFFICIENTS
        DO IMU=1,8
          ANGFAC(IMU) = BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD)
        ENDDO
C
C       SCREENING OF INTEGRAL BASED ON ANGULAR COEFFICIENT
        ANGSUM = 0.0D0
        DO IMU=1,8
          ANGSUM = ANGSUM + DABS(ANGFAC(IMU))
        ENDDO
        IF(DABS(ANGSUM).LE.SENS) GOTO 4003
C
        DO M=1,NBAS(3)*NBAS(4)
C
C         FACTORS LEADING TO BXCH(LS)
          XLSLS(M) = XLSLS(M) + ANGFAC(1)*RJLSLS(M,LTEN,1)
     &                        + ANGFAC(2)*RJLSLS(M,LTEN,2)
C
C         FACTORS LEADING TO BXCH(SL)
          XSLSL(M) = XSLSL(M) + ANGFAC(3)*RJSLSL(M,LTEN,1)
     &                        + ANGFAC(4)*RJSLSL(M,LTEN,2)
C
C         FACTORS LEADING TO BXCH(LL)
          XLSSL(M) = XLSSL(M) + ANGFAC(5)*RJLSSL(M,LTEN,1)
     &                        + ANGFAC(6)*RJLSSL(M,LTEN,2)
C
C         FACTORS LEADING TO BXCH(SS)
          XSLLS(M) = XSLLS(M) + ANGFAC(7)*RJSLLS(M,LTEN,1)
     &                        + ANGFAC(8)*RJSLLS(M,LTEN,2)
C
        ENDDO
C
C       SKIP POINT FOR ANGULAR SCREENING
4003    CONTINUE
C
      ENDDO
C
C     FULL-INTEGRAL CONSTRUCTION COMPLETE
      CALL CPU_TIME(T2)
      TB1F = TB1F+T2-T1
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO CLOSED-SHELL BREIT MATRIX       C
C -------------------------------------------------------------------- C
C          (NO BDIR CONTRIBUTIONS FOR CLOSED-SHELL SYSTEMS.)           C
C**********************************************************************C
C
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         EXCHANGE CONTRIBUTIONS
          BXCH(NAL+IBAS,NDS+LBAS) = BXCH(NAL+IBAS,NDS+LBAS)
     &                  +      XLSLS(M)*DCONJG(DENT(NBS+JBAS,NCL+KBAS))
C
          BXCH(NAS+IBAS,NDL+LBAS) = BXCH(NAS+IBAS,NDL+LBAS)
     &                  +      XSLSL(M)*DCONJG(DENT(NBL+JBAS,NCS+KBAS))
C
          BXCH(NAL+IBAS,NDL+LBAS) = BXCH(NAL+IBAS,NDL+LBAS)
     &                  +      XLSSL(M)*DCONJG(DENT(NBS+JBAS,NCS+KBAS))
C
          BXCH(NAS+IBAS,NDS+LBAS) = BXCH(NAS+IBAS,NDS+LBAS)
     &                  +      XSLLS(M)*DCONJG(DENT(NBL+JBAS,NCL+KBAS))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL BREIT MATRIX.        C
C     THIS ALSO REQUIRES THE CLOSED-SHELL DIRECT MATRIX ELEMENTS.      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5100
C
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         DIRECT CONTRIBUTIONS TO CLOSED-SHELL MATRIX
          BDIR(NAL+IBAS,NBS+JBAS) = BDIR(NAL+IBAS,NBS+JBAS)
     &                  +      XLSLS(M)*DCONJG(DENT(NCL+KBAS,NDS+LBAS))
     &                  +      XLSSL(M)*DCONJG(DENT(NCS+KBAS,NDL+LBAS))
C
          BDIR(NAS+IBAS,NBL+JBAS) = BDIR(NAS+IBAS,NBL+JBAS)
     &                  +      XSLSL(M)*DCONJG(DENT(NCS+KBAS,NDL+LBAS))
     &                  +      XSLLS(M)*DCONJG(DENT(NCL+KBAS,NDS+LBAS))
C
C         DIRECT CONTRIBUTIONS TO OPEN-SHELL MATRIX
          WDIR(NAL+IBAS,NBS+JBAS) = WDIR(NAL+IBAS,NBS+JBAS)
     &                  + ACFF*XLSLS(M)*DCONJG(DENO(NCL+KBAS,NDS+LBAS))
     &                  + ACFF*XLSSL(M)*DCONJG(DENO(NCS+KBAS,NDL+LBAS))
C
          WDIR(NAS+IBAS,NBL+JBAS) = WDIR(NAS+IBAS,NBL+JBAS)
     &                  + ACFF*XSLSL(M)*DCONJG(DENO(NCS+KBAS,NDL+LBAS))
     &                  + ACFF*XSLLS(M)*DCONJG(DENO(NCL+KBAS,NDS+LBAS))
C
C         EXCHANGE CONTRIBUTIONS TO OPEN-SHELL MATRIX
          WXCH(NAL+IBAS,NDS+LBAS) = WXCH(NAL+IBAS,NDS+LBAS)
     &                  + BCFF*XLSLS(M)*DCONJG(DENO(NBS+JBAS,NCL+KBAS))
C
          WXCH(NAS+IBAS,NDL+LBAS) = WXCH(NAS+IBAS,NDL+LBAS)
     &                  + BCFF*XSLSL(M)*DCONJG(DENO(NBL+JBAS,NCS+KBAS))
C
          WXCH(NAL+IBAS,NDL+LBAS) = WXCH(NAL+IBAS,NDL+LBAS)
     &                  + BCFF*XLSSL(M)*DCONJG(DENO(NBS+JBAS,NCS+KBAS))
C
          WXCH(NAS+IBAS,NDS+LBAS) = WXCH(NAS+IBAS,NDS+LBAS)
     &                  + BCFF*XSLLS(M)*DCONJG(DENO(NBL+JBAS,NCL+KBAS))
C
        ENDDO
      ENDDO
C
5100  CONTINUE
C
C     MATRIX MULTIPLICATION STEP COMPLETE
      CALL CPU_TIME(T3)
      TB1M = TB1M+T3-T2
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL ONE-CENTRE CONTRIBUTIONS.           C
C**********************************************************************C
C
C     EARLY EXIT FOR MQN SELECTION RULES
4001  CONTINUE
C     END LOOP OVER ALL |MQN| SIGNS
4000  CONTINUE
C     END LOOP OVER ALL |MQN| MAGNITUDES
3000  CONTINUE
C     END LOOP OVER IBAS AND JBAS
2000  CONTINUE
C     EARLY EXIT FOR KQN SELECTION RULES
1001  CONTINUE
C     END LOOP OVER ALL KQNS
1000  CONTINUE
C
C     RECORD CPU TIME AT END OF BATCH AND ADD TO APPROPRIATE COUNTER
      CALL CPU_TIME(TBCH2)
      T2ES(1,5) = T2ES(1,5)+TBCH2-TBCH1
C
      RETURN
      END
C
C
      SUBROUTINE RKBRT1(RJLSLS,RJSLSL,RJLSSL,RJSLLS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            RRRRRRR  KK    KK BBBBBBB  RRRRRRR TTTTTTTT 11            C
C            RR    RR KK   KK  BB    BB RR    RR   TT   111            C
C            RR    RR KK  KK   BB    BB RR    RR   TT    11            C
C            RR    RR KKKKK    BBBBBBB  RR    RR   TT    11            C
C            RRRRRRR  KK  KK   BB    BB RRRRRRR    TT    11            C
C            RR    RR KK   KK  BB    BB RR    RR   TT    11            C
C            RR    RR KK    KK BBBBBBB  RR    RR   TT   1111           C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKBRT1 EVALUATES A BATCH OF GENERAL (OPEN-SHELL) ONE-CENTRE RADIAL  C
C  INTEGRALS OVER THE BREIT INTERACTION, SEPARATING RESULTS BY THE     C
C  ALLOWED TENSOR ORDERS RK(ABCD).                                     C
C -------------------------------------------------------------------- C
C  RJLSLS(MB2,MNU,IUL) - JLSLS INTEGRAL LIST OF TENSOR TYPE MNU        C
C  RJSLSL(MB2,MNU,IUL) - JSLSL INTEGRAL LIST OF TENSOR TYPE MNU        C
C  RJLSSL(MB2,MNU,IUL) - JLSSL INTEGRAL LIST OF TENSOR TYPE MNU        C
C  RJSLLS(MB2,MNU,IUL) - JSLLS INTEGRAL LIST OF TENSOR TYPE MNU        C
C -------------------------------------------------------------------- C
C  INDEX 1 FOR UPPER INTEGRALS, INDEX 2 FOR LOWER INTEGRALS.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION XJ(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
      DIMENSION BDU(MB2,-MAB:MAB,-MAB:MAB),BDL(MB2,-MAB:MAB,-MAB:MAB)
C
      DIMENSION RJLSLS(MB2,MNU,2),RJSLSL(MB2,MNU,2),
     &          RJLSSL(MB2,MNU,2),RJSLLS(MB2,MNU,2)
C
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B0KL/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL BETA INTEGRALS
      NVALS = (NUF-NUI)/2+2
C
C     LOOP OVER EXPANSION TERMINALS FOR FIRST PAIR
      DO NX=1,NVALS
        IAA(1) = LQN(1)+LQN(2)+NUI+2*NX
        IAA(2) = LQN(3)+LQN(4)+NUI+2*NX
C
C       LOOP OVER EXPANSION TERMINALS FOR SECOND PAIR
        DO NY=1,NVALS
          IBB(1) = LQN(3)+LQN(4)-NUF+2*NY-1
          IBB(2) = LQN(1)+LQN(2)-NUF+2*NY-1
C
C         LOOP OVER BETA INTEGRAL COMBINATIONS
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BDU(M, NUI+2*NX  ,-NUF+2*NY-1) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BDL(M, NUI+2*NX  ,-NUF+2*NY-1) = BETA(M)
              ENDDO
            ENDIF

          ENDDO

        ENDDO
      ENDDO
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXM
        DO LTEN=1,NUNUM
          DO IUL=1,2
            RJLSLS(M,LTEN,IUL) = 0.0D0
            RJSLSL(M,LTEN,IUL) = 0.0D0
            RJLSSL(M,LTEN,IUL) = 0.0D0
            RJSLLS(M,LTEN,IUL) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     VALUE PREPARATION
      E0000 = 1.0D0
      E1000 = EI
      E0100 = EJ
      E1100 = EI*EJ
C
C     LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1010 = EI*EK(M)
        E1001 = EI*EL(M)
        E0110 = EJ*EK(M)
        E0101 = EJ*EL(M)
        E0011 = EK(M)*EL(M)
C
C       LOOP OVER THE TENSOR ORDERS OF THE BREIT INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         TEMPORARY STORAGE OF RAW RJ(LTEN,M)
          B21L = EIJ(-NU+1)*EKL(M, NU+2)*BDL(M, NU+2,-NU+1)
          B21U = EIJ( NU+2)*EKL(M,-NU+1)*BDU(M, NU+2,-NU+1)
          B23L = EIJ(-NU+3)*EKL(M, NU+2)*BDL(M, NU+2,-NU+3)
          B41U = EIJ( NU+4)*EKL(M,-NU+1)*BDU(M, NU+4,-NU+1)
          B41L = EIJ(-NU+1)*EKL(M, NU+4)*BDL(M, NU+4,-NU+1)
          B23U = EIJ( NU+2)*EKL(M,-NU+3)*BDU(M, NU+2,-NU+3)
          B43L = EIJ(-NU+3)*EKL(M, NU+4)*BDL(M, NU+4,-NU+3)
          B43U = EIJ( NU+4)*EKL(M,-NU+3)*BDU(M, NU+4,-NU+3)
C
C         EFFECTIVE INTERACTION STRENGTH RJLSLS(M,LTEN)
          RJLSLS(M,LTEN,1) 
     &         = V4*T0000*E0101*C7*B43U - V2*T0001*E0100*C5*B41U
     &         - V2*T0100*E0001*C5*B23U + V1*T0101*E0000*C3*B21U
C
          RJLSLS(M,LTEN,2) 
     &         = V4*T0000*E0101*C7*B43L - V2*T0001*E0100*C5*B23L
     &         - V2*T0100*E0001*C5*B41L + V1*T0101*E0000*C3*B21L
C
C         EFFECTIVE INTERACTION STRENGTH RJSLSL(M,LTEN)
          RJSLSL(M,LTEN,1)
     &         = V4*T0000*E1010*C7*B43U - V2*T0010*E1000*C5*B41U
     &         - V2*T1000*E0010*C5*B23U + V1*T1010*E0000*C3*B21U
C
          RJSLSL(M,LTEN,2)
     &         = V4*T0000*E1010*C7*B43L - V2*T0010*E1000*C5*B23L
     &         - V2*T1000*E0010*C5*B41L + V1*T1010*E0000*C3*B21L
C
C         EFFECTIVE INTERACTION STRENGTH RJLSSL(M,LTEN)
          RJLSSL(M,LTEN,1) 
     &         = V4*T0000*E0110*C7*B43U - V2*T0010*E0100*C5*B41U
     &         - V2*T0100*E0010*C5*B23U + V1*T0110*E0000*C3*B21U
C
          RJLSSL(M,LTEN,2)
     &         = V4*T0000*E0110*C7*B43L - V2*T0010*E0100*C5*B23L
     &         - V2*T0100*E0010*C5*B41L + V1*T0110*E0000*C3*B21L
C
C         EFFECTIVE INTERACTION STRENGTH RJSLLS(M,LTEN)
          RJSLLS(M,LTEN,1) 
     &         = V4*T0000*E1001*C7*B43U - V2*T0001*E1000*C5*B41U
     &         - V2*T1000*E0001*C5*B23U + V1*T1001*E0000*C3*B21U
C
          RJSLLS(M,LTEN,2) 
     &         = V4*T0000*E1001*C7*B43L - V2*T0001*E1000*C5*B23L
     &         - V2*T1000*E0001*C5*B41L + V1*T1001*E0000*C3*B21L
C
C         SKIP POINT FOR NON-RELATIVISTIC HAMILTONIANS
999       CONTINUE
C
C       END LOOP OVER TENSOR ORDERS
        ENDDO
C
C     END LOOP OVER K,L BASIS FUNCTIONS
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      DO M=1,MAXM
        RNLSLS = RNIJ(4)*RNKL(M,4)
        RNSLSL = RNIJ(2)*RNKL(M,2)
        RNSLLS = RNIJ(2)*RNKL(M,4)
        RNLSSL = RNIJ(4)*RNKL(M,2)
        DO LTEN=1,NUNUM
          DO IUL=1,2
            RJLSLS(M,LTEN,IUL) = RNLSLS*RJLSLS(M,LTEN,IUL)
            RJSLSL(M,LTEN,IUL) = RNSLSL*RJSLSL(M,LTEN,IUL)
            RJLSSL(M,LTEN,IUL) = RNLSSL*RJLSSL(M,LTEN,IUL)
            RJSLLS(M,LTEN,IUL) = RNSLLS*RJSLLS(M,LTEN,IUL)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ANGBRT1(BCOF,KQN,LQN,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          AA    NN    NN  GGGGGG  BBBBBBB  RRRRRRR TTTTTTTT 11        C
C         AAAA   NNN   NN GG    GG BB    BB RR    RR   TT   111        C
C        AA  AA  NNNN  NN GG       BB    BB RR    RR   TT    11        C
C       AA    AA NN NN NN GG       BBBBBBB  RR    RR   TT    11        C
C       AAAAAAAA NN  NNNN GG   GGG BB    BB RRRRRRR    TT    11        C
C       AA    AA NN   NNN GG    GG BB    BB RR    RR   TT    11        C
C       AA    AA NN    NN  GGGGGG  BBBBBBB  RR    RR   TT   1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGBRT1 PERFORMS THE ANGULAR ANALYSIS FOR THE EVALUATION OF TWO     C
C  ELECTRON INTEGRALS USING RACAH ALGEBRA TECHNIQUES. (OPEN-SHELL.)    C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION KQN(4),LQN(4),JQN(4)
      DIMENSION SCOEFF(8,2)
      DIMENSION DKAB(0:MNU,MKP+1,MKP+1),DKCD(0:MNU,MKP+1,MKP+1)
      DIMENSION AJJN(MKP+1,MKP+1,MKP+1,MKP+1)
      DIMENSION BCOF(MNU,8,MKP+1,MKP+1,MKP+1,MKP+1)
C
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     INITIALISE BREIT COEFFICIENTS
      DO LTEN=1,MNU
        DO IMU=1,8
          DO IMJA=1,2*IABS(KQN(1))
            DO IMJB=1,2*IABS(KQN(2))
              DO IMJC=1,2*IABS(KQN(3))
                DO IMJD=1,2*IABS(KQN(4))
                  BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD) = 0.0D0
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        NUS(LTEN) = 0
      ENDDO
      NUNUM = 0
C
C     SPECIFY ALLOWED NU VALUES (ODD PARITY CONDITIONS)
      NUNUM = 0
      DO NU=0,MIN0((JQN(1)+JQN(2))/2,(JQN(3)+JQN(4))/2)
        IPARAB = MOD(LQN(1)+LQN(2),2)
        IPARCD = MOD(LQN(3)+LQN(4),2)
        IF(NU.GE.0.AND.IPARAB.EQ.1.AND.IPARCD.EQ.1) THEN
          NUNUM = NUNUM+1
          NUS(NUNUM) = NU
        ENDIF
      ENDDO
C
C     BREIT TENSOR ORDER LIMITS BASED ON PARITY CHECK
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
C     TENSOR LIMITS BY TRIANGLE RULE
      NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
      NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
C
C     JQN SELECTION RULE: TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUI.GT.NUF) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     LQN PARITY ANALYSIS: CHECK PARITY OF LQN COMBINATIONS.           C
C     EXIT IF THERE IS NO MULTIPOLE EXPANSION FOR THIS CASE.           C
C**********************************************************************C
C
C     A AND B: PARITY OF 'LQN(1)+LQN(2)' (0 IF EVEN, 1 IF ODD)
      IPARAB = MOD(LQN(1)+LQN(2),2)
C
C     C AND D: PARITY OF 'LQN(3)+LQN(4)' (0 IF EVEN, 1 IF ODD)
      IPARCD = MOD(LQN(3)+LQN(4),2)
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.EQ.IPARCD) THEN
        ISEL = 1
      ELSE
        ISEL = 0
        RETURN
      ENDIF
C
C**********************************************************************C
C     WIGNER-ECKART: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|        C
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.   C
C**********************************************************************C
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO NU=NUI,NUF
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(NU,MJA  ,MJB  ) = DK(JQN(1),-MJA,JQN(2),-MJB,NU)
            DKAB(NU,MJA+1,MJB  ) = DK(JQN(1), MJA,JQN(2),-MJB,NU)
            DKAB(NU,MJA  ,MJB+1) = DK(JQN(1),-MJA,JQN(2), MJB,NU)
            DKAB(NU,MJA+1,MJB+1) = DK(JQN(1), MJA,JQN(2), MJB,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     THE ARGUMENTS OF DK COEFFICIENTS ARE REVERSED IN THE CASE OF THE
C     CD PAIRS IN ORDER TO ACCOMMODATE THE RELATION:
C               DK(J,M,J',M',L) = ((-1)^Q)*DK(J',M',J,M,L).
C
C     LOOP OVER MQN(C) AND MQN(D) VALUES
      DO MC=1,IABS(KQN(3))
        MJC = 2*MC-1
        DO MD=1,IABS(KQN(4))
          MJD = 2*MD-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO NU=NUI,NUF
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKCD(NU,MJC  ,MJD  ) = DK(JQN(4),-MJD,JQN(3),-MJC,NU)
            DKCD(NU,MJC+1,MJD  ) = DK(JQN(4),-MJD,JQN(3), MJC,NU)
            DKCD(NU,MJC  ,MJD+1) = DK(JQN(4), MJD,JQN(3),-MJC,NU)
            DKCD(NU,MJC+1,MJD+1) = DK(JQN(4), MJD,JQN(3), MJC,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CALCULATE COMPONENT-TYPE OVERLAP COEFFICIENTS FOR TENSOR ORDERS  C
C     NU (AND NU±1 WHERE APPLICABLE), COUPLING IN ANGULAR FACTORS.     C
C**********************************************************************C
C
      ISEL = 0
      LTEN = 1
      DO NU=NUI,NUF
C
C       A AND B: PARITY OF 'LA+LB+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
C       C AND D: PARITY OF 'LC+LD+NU' (0 IF EVEN, 1 IF ODD)
        IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C       JQN AND NU ANGULAR FACTORS FOR THIS COMBINATION
        DO IMJA=1,2*IABS(KQN(1))
          DO IMJB=1,2*IABS(KQN(2))
            DO IMJC=1,2*IABS(KQN(3))
              DO IMJD=1,2*IABS(KQN(4))
                AJJN(IMJA,IMJB,IMJC,IMJD)
     &           = DKAB(NU,IMJA,IMJB)*DKCD(NU,IMJC,IMJD)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
C
C       CASE 1: LA+LB+NU AND LC+LD+NU ARE BOTH ODD (AND NU=/=0)
        IF(IPARAB.EQ.1.AND.IPARCD.EQ.1.AND.NU.NE.0) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         INTERMEDIATE (KQN,NU) COEFFICIENTS
          RNU    = DFLOAT(NU*(NU+1))
          RCOEFF =-DFLOAT((KQN(1)+KQN(2))*(KQN(3)+KQN(4)))/RNU
C
C         THIS CONTRIBUTION BELONGS IN "NU" BIN
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO TENSOR ORDER "NU"
          DO IMU=1,8
C
            DO IMJA=1,2*IABS(KQN(1))
              DO IMJB=1,2*IABS(KQN(2))
                DO IMJC=1,2*IABS(KQN(3))
                  DO IMJD=1,2*IABS(KQN(4))
                    BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD)
     &               = BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD)
     &               +          AJJN(IMJA,IMJB,IMJC,IMJD)*RCOEFF
                  ENDDO
                ENDDO
              ENDDO
            ENDDO
C
          ENDDO
C
        ENDIF
C
C       CASE 2: LA+LB+NU AND LC+LD+NU ARE BOTH EVEN
        IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         CALCULATE BREIT COEFFICIENTS WITH CALL TO BRCOEF1
          CALL BRCOEF1(SCOEFF,KQN,NU)
C
C         FIRST CONTRIBUTION BELONGS IN "NU-1" BIN
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          DO IMU=1,8
C
            DO IMJA=1,2*IABS(KQN(1))
              DO IMJB=1,2*IABS(KQN(2))
                DO IMJC=1,2*IABS(KQN(3))
                  DO IMJD=1,2*IABS(KQN(4))
                    BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD)
     &               = BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD)
     &               +          AJJN(IMJA,IMJB,IMJC,IMJD)*SCOEFF(IMU,1)
                  ENDDO
                ENDDO
              ENDDO
            ENDDO
C
          ENDDO
C
C         INCREASE TENSOR LIST LENGTH IF ENTRIES ARE NON-ZERO
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SECOND CONTRIBUTION BELONGS IN "NU+1" BIN
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          DO IMU=1,8
C
            DO IMJA=1,2*IABS(KQN(1))
              DO IMJB=1,2*IABS(KQN(2))
                DO IMJC=1,2*IABS(KQN(3))
                  DO IMJD=1,2*IABS(KQN(4))
                    BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD)
     &               = BCOF(LTEN,IMU,IMJA,IMJB,IMJC,IMJD)
     &         +                AJJN(IMJA,IMJB,IMJC,IMJD)*SCOEFF(IMU,2)
                  ENDDO
                ENDDO
              ENDDO
            ENDDO
C
          ENDDO
C
        ENDIF
C
      ENDDO
C
C     RESET THE LOWER AND UPPER LIMITS OF THE EXPANSION
      NUI = NUS(1)
      NUF = NUS(LTEN)
      NUNUM = LTEN
C
      RETURN
      END
C
C
      SUBROUTINE BRCOEF1(SCOEFF,KQN,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      BBBBBBB  RRRRRRR   CCCCCC   OOOOOO  EEEEEEEE FFFFFFFF 11        C
C      BB    BB RR    RR CC    CC OO    OO EE       FF      111        C
C      BB    BB RR    RR CC       OO    OO EE       FF       11        C
C      BBBBBBB  RR    RR CC       OO    OO EEEEEE   FFFFFF   11        C
C      BB    BB RRRRRRR  CC       OO    OO EE       FF       11        C
C      BB    BB RR    RR CC    CC OO    OO EE       FF       11        C
C      BBBBBBB  RR    RR  CCCCCC   OOOOOO  EEEEEEEE FF      1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRCOEF1 EVALUATES THE INTERMEDIATE COEFFICIENTS OF THE BREIT        C
C  INTERACTION IN THE GENERAL CASE (TABLE 2 OF GRANT AND PYPER 1976).  C
C  COEFFICIENTS WE CONFIRMED BY REFERENCING (CHEN AND JOHNSON 1993).   C
C -------------------------------------------------------------------- C
C  MAPPING OF SCOEFF ADDRESSES TO BREIT INTEGRALS (NU±1)               C
C   1: LSLS (UPPER)    2: LSLS (LOWER)                                 C
C   3: SLSL (UPPER)    4: SLSL (LOWER)                                 C
C   5: LSSL (UPPER)    6: LSSL (LOWER)                                 C
C   7: SLLS (UPPER)    8: SLLS (LOWER)                                 C
C**********************************************************************C
      DIMENSION SCOEFF(8,2),KQN(4)
C
      KCA = KQN(2)-KQN(1)
      KDB = KQN(4)-KQN(3)
C
      IF(NU.GE.1) THEN
        B1 = DFLOAT(NU*(NU+1))/DFLOAT(2*NU*(2*NU-1))
        C1 = DFLOAT(   (NU-2))/DFLOAT(2*NU*(2*NU-1))
        SCOEFF(1,1) = DFLOAT(NU  +KCA)*(B1-C1*KDB)
        SCOEFF(2,1) = DFLOAT(NU  +KDB)*(B1-C1*KCA)
        SCOEFF(3,1) = DFLOAT(NU  -KCA)*(B1+C1*KDB)
        SCOEFF(4,1) = DFLOAT(NU  -KDB)*(B1+C1*KCA)
        SCOEFF(5,1) =-DFLOAT(NU  +KCA)*(B1+C1*KDB)
        SCOEFF(6,1) =-DFLOAT(NU  -KDB)*(B1-C1*KCA)
        SCOEFF(7,1) =-DFLOAT(NU  -KCA)*(B1-C1*KDB)
        SCOEFF(8,1) =-DFLOAT(NU  +KDB)*(B1+C1*KCA)
      ELSE
        DO I=1,8
          SCOEFF(I,1) = 0.0D0
        ENDDO
      ENDIF
C
      IF(NU.GE.0) THEN
        B2 = DFLOAT(NU*(NU+1))/DFLOAT((2*NU+2)*(2*NU+3))
        C2 = DFLOAT(    NU+3 )/DFLOAT((2*NU+2)*(2*NU+3))
        SCOEFF(1,2) =-DFLOAT(NU+1-KDB)*(B2+C2*KCA)
        SCOEFF(2,2) =-DFLOAT(NU+1-KCA)*(B2+C2*KDB)
        SCOEFF(3,2) =-DFLOAT(NU+1+KDB)*(B2-C2*KCA)
        SCOEFF(4,2) =-DFLOAT(NU+1+KCA)*(B2-C2*KDB)
        SCOEFF(5,2) = DFLOAT(NU+1+KDB)*(B2+C2*KCA)
        SCOEFF(6,2) = DFLOAT(NU+1-KCA)*(B2-C2*KDB)
        SCOEFF(7,2) = DFLOAT(NU+1-KDB)*(B2-C2*KCA)
        SCOEFF(8,2) = DFLOAT(NU+1+KCA)*(B2+C2*KDB)
      ELSE
        DO I=1,8
          SCOEFF(I,2) = 0.0D0
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION DK(JA,MA,JB,MB,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          DDDDDDD  KK    KK                           C
C                          DD    DD KK   KK                            C
C                          DD    DD KK  KK                             C
C                          DD    DD KKKKK                              C
C                          DD    DD KK  KK                             C
C                          DD    DD KK   KK                            C
C                          DDDDDDD  KK    KK                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  DK CALCULATES THE APPROPRIATE TENSOR COEFFICIENT FOR A 2-SPINOR     C
C  EVEN OPERATOR EXPANSION OF ORDER NU (DEFINED AS IN GRANT 6.2.12.)   C
C  IT EVALUATES THE ANGULAR COEFFICIENTS OF THE COULOMB INTERACTION,   C
C  ABSORBING THE ANGULAR DIAGRAM AND ANGULAR PARTS OF THE EFFECTIVE    C
C  INTERACTION STRENGTH TOGETHER. IT EVALUATES ALL PARTS THAT DEPEND   C
C  ON THE ANGULAR FACTOR AT THE INTERACTION VERTEX, ASSUMING THAT THE  C
C  PRIMITIVE RK-RADIAL INTEGRAL (AND NOT XK) IS THE REMAINDER.         C
C -------------------------------------------------------------------- C
C  INPUT CONVENTION: THE ANGULAR MOMENTA (JA,JB,MA,MB) SHOULD BE       C
C  SUPPLIED AS TWICE THEIR ACTUAL VALUES (THESE ARE ODD-HALF-INTEGER   C
C  ELECTRONIC VALUES) WHILE NU AND IQ ARE THE **ACTUAL** VALUES OF THE C
C  PHOTON PARAMETERS. THE SELECTION RULE IS THAT (MA+MB)/2+IQ=0.       C
C  THIS METHOD CAN ALSO BE USED FOR OPEN-SHELL ATOMIC BREIT INTEGRALS. C
C**********************************************************************C
C
C      CHOOSE IQ IN ACCORDANCE WITH PHOTON SELECTION RULE
       IQ = (MA-MB)/2
C
C      MQN PHASE TERM
       PHS = DFLOAT((-1)**((MA+1)/2))
C
C      CONVENTIONAL JQN SQUARE ROOT TERMS
       RTJ = DSQRT(DFLOAT((JA+1)*(JB+1)))
C
C      3J SYMBOL ASSOCIATED WITH ANGULAR MOMENTUM CONSERVATION
       SEL = SYM3J(JA,NU,JB,+1,0,-1)
C
C      3J SYMBOL CONTAINING SPIN TERMS
       QMM = SYM3J(JA,NU,JB,-MA,IQ,MB)
C
C      FINAL ANGULAR FACTOR
       DK = PHS*RTJ*SEL*QMM
C
       RETURN
       END
C
C
      FUNCTION SYM3J(JA,L,JB,MA,M,MB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            SSSSSS  YY    YY MM       MM  333333      JJJJJ           C
C           SS    SS YY    YY MMM     MMM 33    33       JJ            C
C           SS       YY    YY MMMM   MMMM       33       JJ            C
C            SSSSSS   YY  YY  MM MM MM MM    3333        JJ            C
C                 SS   YYYY   MM  MMM  MM       33       JJ            C
C           SS    SS    YY    MM   M   MM  33   33 JJ    JJ            C
C            SSSSSS     YY    MM       MM   33333   JJJJJJ             C
C                                                                      C
C -------------------------------------------------------------------- C
C  SYM3J EVALUATES A WIGNER 3-J SYMBOL,               / j  L  j'\      C
C  WHERE j=JA/2, j'=JB/2, m=MA/2 AND m'=MB/2,         \ m  M  m'/      C
C  BUT L AND M ARE THE ACTUAL VALUES. (BRINK AND SATCHLER {2.34}.)     C
C**********************************************************************C
C
      COMMON/FCTS/RFACT(0:80),SFACT(0:80)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(IABS(M).GT.L) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(2*M+MA+MB.NE.0) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(IABS(MA).GT.JA.OR.IABS(MB).GT.JB) THEN
        SYM3J = 0.0D0
        RETURN
      ENDIF
C
C     OVERALL PHASE FACTOR (CONVERSION FROM CG-COEFF TO 3J-SYMBOL)
      IPS = (JA-MB)/2 - L
      PHS = DFLOAT((-1)**(IPS))
C
C     SYMMETRIC FACTOR INVOLVING VERTICAL PAIRS (j,m), (L,M), (j',m')
      SM1 = RFACT((JA+MA)/2)
      SM2 = RFACT((JA-MA)/2)
      SM3 = RFACT((JB-MB)/2)
      SM4 = RFACT((JB+MB)/2)
      SM5 = RFACT(  L +M   )
      SM6 = RFACT(  L -M   )
      SYM = DSQRT(SM1*SM2*SM3*SM4*SM5*SM6)
C
C     TRIANGULAR FACTOR, DELTA (j, L, j')
      TR1 = RFACT((JA-JB)/2+L  )
      TR2 = RFACT((JA+JB)/2-L  )
      TR3 = RFACT((JB-JA)/2+L  )
      TR4 = RFACT((JA+JB)/2+L+1)
      TRP = DSQRT(TR1*TR2*TR3/TR4)
C
C     LIMITS IN THE SUM OVER TENSOR ORDERS NU
      NUI = MAX0(L-(JB+MA)/2,M+(JA-JB)/2,  0)
      NUF = MIN0(  (JA-MA)/2,L+(JA-JB)/2,L+M)
C
C     SUM OVER ALLOWED TENSOR ORDERS NU
      XNU = 0.0D0
      DO NU=NUI,NUF
C
C       PHASE TERM FROM TENSOR ORDER
        PTN = DFLOAT((-1)**NU)
C
C       FACTORS INVOLVING TENSOR ORDER
        RD1 = RFACT((JA-MA)/2    -NU)
        RD2 = RFACT((JB+MA)/2-L  +NU)
        RD3 = RFACT((JB-JA)/2  -M+NU)
        RD4 = RFACT((JA-JB)/2+L  -NU)
        RD5 = RFACT(          L+M-NU)
        RD6 = RFACT(              NU)
        RDP = RD1*RD2*RD3*RD4*RD5*RD6
C
C       ADD THIS CONTRIBUTION TO THE 3J-SYMBOL
        XNU = XNU + PTN/RDP
C
      ENDDO
C
C     3-J SYMBOL IS A PRODUCT OF PHASE, SYMMETRIC FACTOR, TRIANGULAR
C     FACTOR AND THE SUM OVER ALLOWED NU TERMS
      SYM3J = PHS*TRP*SYM*XNU
C
      RETURN
      END
C
C
      SUBROUTINE IJSET1
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              IIII     JJJJ SSSSSS  EEEEEEEE TTTTTTTT 11              C
C               II       JJ SS    SS EE          TT   111              C
C               II       JJ SS       EE          TT    11              C
C               II       JJ  SSSSSS  EEEEEE      TT    11              C
C               II       JJ       SS EE          TT    11              C
C               II JJ    JJ SS    SS EE          TT    11              C
C              IIII JJJJJJ   SSSSSS  EEEEEEEE    TT   1111             C
C                                                                      C
C -------------------------------------------------------------------- C
C  IJSET1 PREPARES BASIS SET INTERMEDIATES FOR ALL IJ-PAIRS OF BASIS   C
C  FUNCTIONS, FOR USE IN ROUTINES RKCLM1/RKBRT1.                       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/B0IJ/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     GAUSSIAN EXPONENTS FOR THIS PAIR
      EI = EXL(IBAS,1)
      EJ = EXL(JBAS,2)
C
C     NORMALISATION CONSTANTS FOR EXPONENT EI
      RL = DFLOAT(LQN(1))
      G1 = TWLG-GAMLOG(2*LQN(1)+3)
      G2 = TWLG-GAMLOG(2*LQN(1)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
C
      ELOG = DLOG(2.0D0*EI)
      RNLI = DEXP(0.5D0*(G1+R1*ELOG))
      RNSI = DEXP(0.5D0*(G2+R2*ELOG))
C
C     NORMALISATION CONSTANTS FOR EXPONENT EJ
      RL = DFLOAT(LQN(2))
      G1 = TWLG-GAMLOG(2*LQN(2)+3)
      G2 = TWLG-GAMLOG(2*LQN(2)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
C
      ELOG = DLOG(2.0D0*EJ)
      RNLJ = DEXP(0.5D0*(G1+R1*ELOG))
      RNSJ = DEXP(0.5D0*(G2+R2*ELOG))
C
C     COMPOSITE NORMALISATION CONSTANTS
      RNIJ(1) = RNLI*RNLJ
      RNIJ(2) = RNSI*RNLJ
      RNIJ(3) = RNSI*RNSJ
      RNIJ(4) = RNLI*RNSJ
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     LOWEST EXPONENT POWER
      IPOWER = LQN(1)+LQN(2)-NUF
C
C     SEED GAUSSIAN EXPONENT VALUE
      EIJ0 = EI+EJ
      EIJR = DSQRT(EIJ0)
      EIJ(-NUF) = EIJR**(-IPOWER)
C
C     LOOP OVER ALL TENSOR ORDERS AND DIVIDE
      DO IPOW=-NUF+1,NUF+5
        EIJ(IPOW) = EIJ(IPOW-1)/EIJR
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE KLSET1(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            KK    KK LL       SSSSSS  EEEEEEEE TTTTTTTT 11            C
C            KK   KK  LL      SS    SS EE          TT   111            C
C            KK  KK   LL      SS       EE          TT    11            C
C            KKKKK    LL       SSSSSS  EEEEEE      TT    11            C
C            KK  KK   LL            SS EE          TT    11            C
C            KK   KK  LL      SS    SS EE          TT    11            C
C            KK    KK LLLLLLLL SSSSSS  EEEEEEEE    TT   1111           C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLSET1 PREPARES BASIS SET INTERMEDIATES FOR ALL IJ-PAIRS OF BASIS   C
C  FUNCTIONS, FOR USE IN ROUTINES RKCLM1/RKBRT1.                       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RNLC(MBS),RNSC(MBS),RNLD(MBS),RNSD(MBS)
      DIMENSION EKL0(MB2)
C
      COMMON/B0KL/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/B1QN/EXL(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/XNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST C
      RL = DFLOAT(LQN(3))
      G1 = TWLG-GAMLOG(2*LQN(3)+3)
      G2 = TWLG-GAMLOG(2*LQN(3)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO KBAS=1,NBAS(3)
        EKV        = BEXL(KBAS,LQN(3),IZ)
        ELOG       = DLOG(2.0D0*EKV)
        RNLC(KBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNSC(KBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST D
      RL = DFLOAT(LQN(4))
      G1 = TWLG-GAMLOG(2*LQN(4)+3)
      G2 = TWLG-GAMLOG(2*LQN(4)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO LBAS=1,NBAS(4)
        ELV        = BEXL(LBAS,LQN(4),IZ)
        ELOG       = DLOG(2.0D0*ELV)
        RNLD(LBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNSD(LBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     LIST OF EXPONENTS AND NORMALISATION COEFFICIENTS IN THE BLOCK
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          EK(M)     = BEXL(KBAS,LQN(3),IZ)
          EL(M)     = BEXL(LBAS,LQN(4),IZ)
          EKL0(M)   = EK(M)+EL(M)
          RNKL(M,1) = RNLC(KBAS)*RNLD(LBAS)
          RNKL(M,2) = RNSC(KBAS)*RNLD(LBAS)
          RNKL(M,3) = RNSC(KBAS)*RNSD(LBAS)
          RNKL(M,4) = RNLC(KBAS)*RNSD(LBAS)
        ENDDO
      ENDDO
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     LOWEST EXPONENT POWER
      IPOWER = LQN(3)+LQN(4)-NUF
C
C     GAUSSIAN OVERLAPS TO ALL REQUIRED POWERS
      DO M=1,MAXM
C
C       SEED GAUSSIAN EXPONENT VALUE
        EKLR = DSQRT(EKL0(M))
        EKL(M,-NUF) = EKLR**(-IPOWER)
C
C       LOOP OVER ALL TENSOR ORDERS AND DIVIDE
        DO IPOW=-NUF+1,NUF+5
          EKL(M,IPOW) = EKL(M,IPOW-1)/EKLR
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE TESTANG(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     TTTTTTTT EEEEEEEE SSSSSS TTTTTTTT   AA    NN    NN  GGGGGG       C
C        TT    EE      SS    SS   TT     AAAA   NNN   NN GG    GG      C
C        TT    EE      SS         TT    AA  AA  NNNN  NN GG            C
C        TT    EEEEEE   SSSSSS    TT   AA    AA NN NN NN GG            C
C        TT    EE            SS   TT   AAAAAAAA NN  NNNN GG   GGG      C
C        TT    EE      SS    SS   TT   AA    AA NN   NNN GG    GG      C
C        TT    EEEEEEEE SSSSSS    TT   AA    AA NN    NN  GGGGGG       C
C                                                                      C
C -------------------------------------------------------------------- C
C  TESTANG IS A ROUTINE THAT PRINTS A TABLE OF ANGULAR COEFFICIENTS,   C
C  DK(J M ,J'M') FOR AN ALLOWED NUMBER OF TENSOR POWERS K, AND ALL     C
C  COMBINATIONS OF JA, JB, MA, MB FOR GIVEN SYMMETRY TYPES KA, KB.     C
C -------------------------------------------------------------------- C
C  TODO: MUST CALL 'FACTRL' ROUTINE AT SOME POINT BEFORE THIS.         C
C        FACTORS ARE PRESENTED AS THEIR SQUARES (SIGNS RETAINED), WITH C
C        AN EXTRA OPTION TO MULTIPLY THEM AGAIN BY A FACTOR F(NU).     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION KQN(2),JQN(2),LQN(2)
      DIMENSION NUS(MNU),FMLT(MNU)
      DIMENSION BK(MNU)
      DIMENSION ELL(MNU),ESL(MNU),ESS(MNU),GSL(MNU)
      DIMENSION DKAB(MNU,MKP+1,MKP+1)
C
C     OVER-RIDE INPUT KQN VALUES
      KQN(1) =-1
      KQN(2) =-1
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE LQN VALUES
      DO I=1,2
        IF(KQN(I).LT.0) THEN
          LQN(I) =-KQN(I)-1
        ELSE
          LQN(I) = KQN(I)
        ENDIF
      ENDDO
C
C     ALLOWED TENSOR POWERS
      NUI = IABS(JQN(1)-JQN(2))/2
      NUF =     (JQN(1)+JQN(2))/2
      NUNUM = NUF-NUI+1
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, QUIT PROCEDURE
      IF(NUNUM.EQ.0) RETURN
C
C**********************************************************************C
C     CLOSED-SHELL COULOMB EXCHANGE TERMS, BK(JJ').                    C
C**********************************************************************C
C
C     LOOP OVER ALL TENSOR ORDERS ALLOWED BY TRIANGLE CONDITION
      LTEN = 0
      DO NU=NUI,NUF
C
C       PARITY OF 'LQN(1)+LQN(2)' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
C
        IF(IPARAB.EQ.0) THEN
C       ONLY ANGULAR COEFFICIENTS OF EVEN PARITY ARE NON-ZERO
C
C         SAVE THIS TENSOR ORDER
          LTEN = LTEN+1
          NUS(LTEN) = NU
C
          IF(HMLT.EQ.'NORL') THEN
            BK(LTEN) = 0.5D0*ANGSQLS(LQN(1),LQN(2),NU)
          ELSE
            BK(LTEN) =       ANGSQJJ(JQN(1),JQN(2),NU)
          ENDIF
        ENDIF
C
      ENDDO
C
C     NUMBER OF SURVIVING TENSOR ORDERS
      NUNUM = LTEN
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' CLOSED COULOMB EXCHANGE COEFFICIENTS:'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
301   FORMAT(1X,A, 1(1X,F13.9))
302   FORMAT(1X,A, 2(1X,F13.9))
303   FORMAT(1X,A, 3(1X,F13.9))
304   FORMAT(1X,A, 4(1X,F13.9))
305   FORMAT(1X,A, 5(1X,F13.9))
306   FORMAT(1X,A, 6(1X,F13.9))
307   FORMAT(1X,A, 7(1X,F13.9))
308   FORMAT(1X,A, 8(1X,F13.9))
309   FORMAT(1X,A, 9(1X,F13.9))
310   FORMAT(1X,A,10(1X,F13.9))
311   FORMAT(1X,A,11(1X,F13.9))
312   FORMAT(1X,A,12(1X,F13.9))
313   FORMAT(1X,A,13(1X,F13.9))
314   FORMAT(1X,A,14(1X,F13.9))
C
      IF(NUNUM.EQ.1) THEN
        WRITE(*,301) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,302) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,303) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,304) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,305) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,306) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,307) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,308) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,309) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,310) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,311) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,312) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,313) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,314) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
C**********************************************************************C
C     CLOSED-SHELL BREIT EXCHANGE TERMS, EK(JJ') AND GK(JJ').          C
C**********************************************************************C
C
C     INITIALISE COEFFICIENT ARRAYS
      DO LTEN=1,NUF-NUI+1
        ELL(LTEN) = 0.0D0
        ESL(LTEN) = 0.0D0
        ESS(LTEN) = 0.0D0
        GSL(LTEN) = 0.0D0
      ENDDO
C
C     LOOP OVER ALL TENSOR ORDERS ALLOWED BY TRIANGLE CONDITION
      LTEN = 1
      DO NU=NUI,NUF
C
C       RAW SQUARED 3J-SYMBOL
        RAW = ANGSQJJ(JQN(1),JQN(2),NU)
C
C       FLOATING-POINT VERSIONS OF TENSOR ORDER AND KQN DIFFERENCE
        RU  = DFLOAT(NU)
        RK  = DFLOAT(KQN(2)-KQN(1))
        RP  = DFLOAT(KQN(1)+KQN(2))
C
C       A AND B: PARITY OF 'LQN(1)+LQN(2)+NU' (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
        IF(IPARAB.EQ.1.AND.NU.NE.0) THEN
C       ANGULAR COEFFICIENTS OF ODD PARITY
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN) = ELL(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
          ESS(LTEN) = ESS(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
          ESL(LTEN) = ESL(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
C
        ELSEIF(IPARAB.EQ.0) THEN
C       ANGULAR COEFFICIENTS OF EVEN PARITY
C
C         DOWN-LADDER ENTRIES...
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         ADD TO ARRAY ELEMENTS ONLY IF EFFECTIVE TENSOR ORDER >= 0
          IF(NU-1.GE.0) THEN
            B1 = DFLOAT(NU+1)/DFLOAT(2*(2*NU-1))
            C1 =-DFLOAT(NU-2)/DFLOAT(2*(2*NU-1)*NU)
            ELL(LTEN) = ELL(LTEN) + RAW*((RU+RK)*(B1+C1*RK))
            ESL(LTEN) = ESL(LTEN) - RAW*((B1*RU)-(C1*RK*RK))
            ESS(LTEN) = ESS(LTEN) + RAW*((RU-RK)*(B1-C1*RK))
            GSL(LTEN) = GSL(LTEN) - RAW*(    RK *(B1-C1*RU))
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         UP-LADDER ENTRIES...
          NUS(LTEN) = NU+1
C
C         ADD TO ARRAY ELEMENTS ONLY IF EFFECTIVE TENSOR ORDER >= 1
          IF(NU+1.GE.1) THEN
            B2 = DFLOAT(NU  )/DFLOAT(2*(2*NU+3))
            C2 = DFLOAT(NU+3)/DFLOAT(2*(NU+1)*(2*NU+3))
            ELL(LTEN) = ELL(LTEN) + RAW*((RK-RU-1.0D0)*( B2+C2*RK))
            ESL(LTEN) = ESL(LTEN) + RAW*((B2*(RU+1.0D0))+C2*RK*RK)
            ESS(LTEN) = ESS(LTEN) - RAW*((RK+RU+1.0D0)*( B2-C2*RK))
            GSL(LTEN) = GSL(LTEN) + RAW*(C2*RK*(RU+1.0D0)+B2*RK)
          ENDIF
C
        ENDIF
C
      ENDDO
      
      NUNUM = LTEN
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' CLOSED BREIT EXCHANGE COEFFICIENTS:'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
      IF(NUNUM.EQ.1) THEN
        WRITE(*,301) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,302) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,303) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,304) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,305) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,306) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,307) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,308) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,309) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,310) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,311) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,312) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,313) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,314) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
C**********************************************************************C
C     GENERAL COULOMB TERMS, DK(J M ;J'M').                            C
C**********************************************************************C
C
C     RESTORE ORIGINAL TENSOR ORDER RANGE
      NUNUM = NUF-NUI+1
C
C     ASSIGN THE TENSOR POWERS TO A LIST
      LTEN = 0
      DO NU=NUI,NUF
        LTEN      = LTEN+1
        NUS(LTEN) = NU
      ENDDO
C
C     ANGULAR FACTORS: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.
C     REVERSE (JA,MA) WITH (JB,MB) INPUTS TO ACCOMMODATE THE RELATION:
C                DK(J,M,J',M',L) = ((-1)^Q)*DK(J'M',J,M,L).
C
C     ASSIGN PRE-FACTORS TO TENSOR POWERS
      DO LTEN=1,NUNUM
        FMLT(LTEN) = 1.0D0
      ENDDO
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(2),-MJB,JQN(1),-MJA,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(2),-MJB,JQN(1),+MJA,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(2),+MJB,JQN(1),-MJA,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(2),+MJB,JQN(1),+MJA,NU)
C
C            G1 = FMLT(LTEN)*DKAB(LTEN,MJA  ,MJB  )
C            G2 = FMLT(LTEN)*DKAB(LTEN,MJA+1,MJB  )
C            G3 = FMLT(LTEN)*DKAB(LTEN,MJA  ,MJB+1)
C            G4 = FMLT(LTEN)*DKAB(LTEN,MJA+1,MJB+1)
CC
CC           SQUARE THE RESULT BUT KEEP THE SIGN
C            F1 = DSIGN(1.0D0,G1)
C            F2 = DSIGN(1.0D0,G2)
C            F3 = DSIGN(1.0D0,G3)
C            F4 = DSIGN(1.0D0,G4)
CC
C            DKAB(LTEN,MJA  ,MJB  ) = F1*G1*G1
C            DKAB(LTEN,MJA+1,MJB  ) = F2*G2*G2
C            DKAB(LTEN,MJA  ,MJB+1) = F3*G3*G3
C            DKAB(LTEN,MJA+1,MJB+1) = F4*G4*G4
C
          ENDDO
C
C       END THE LOOP OVER MQN(A)
        ENDDO
C     END THE LOOP OVER MQN(B)
      ENDDO
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' GENERAL COULOMB COEFFICIENTS D^K(JA,MA;JB,MB):'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
101   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 1(9X,'K =',I2))
102   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 2(9X,'K =',I2))
103   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 3(9X,'K =',I2))
104   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 4(9X,'K =',I2))
105   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 5(9X,'K =',I2))
106   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 6(9X,'K =',I2))
107   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 7(9X,'K =',I2))
108   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 8(9X,'K =',I2))
109   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 9(9X,'K =',I2))
110   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',10(9X,'K =',I2))
111   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',11(9X,'K =',I2))
112   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',12(9X,'K =',I2))
113   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',13(9X,'K =',I2))
114   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',14(9X,'K =',I2))
C
C     LOOP OVER POSITIVE MQN(B) VALUES -- DESCENDING ORDER OF MAGNITUDE
      DO MB=IABS(KQN(2)),1,-1
        MJB = 2*MB-1
C       LOOP OVER POSITIVE MQN(A) -- DESCENDING ORDER OF MAGNITUDE
        DO MA=IABS(KQN(1)),1,-1
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
C       LOOP OVER POSITIVE MQN(A) -- ASCENDING ORDER OF MAGNITUDE
        DO MA=1,IABS(KQN(1))
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
        IF(MB.NE.1) WRITE(*,*) REPEAT('-',NLNES)
C     END THE LOOP OVER MQN(B)
      ENDDO
      WRITE(*,*) REPEAT('-',NLNES)
C     LOOP OVER NEGATIVE MQN(B) VALUES -- ASCENDING ORDER OF MAGNITUDE
      DO MB=1,IABS(KQN(2))
        MJB = 2*MB-1
C       LOOP OVER POSITIVE MQN(A) -- DESCENDING ORDER OF MAGNITUDE
        DO MA=IABS(KQN(1)),1,-1
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
C       LOOP OVER POSITIVE MQN(A) -- ASCENDING ORDER OF MAGNITUDE
        DO MA=1,IABS(KQN(1))
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
        IF(MB.NE.IABS(KQN(2))) WRITE(*,*) REPEAT('-',NLNES)
C     END THE LOOP OVER MQN(B)
      ENDDO
      WRITE(*,*) REPEAT('=',NLNES)
C
201   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 1(1X,F13.9))
202   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 2(1X,F13.9))
203   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 3(1X,F13.9))
204   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 4(1X,F13.9))
205   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 5(1X,F13.9))
206   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 6(1X,F13.9))
207   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 7(1X,F13.9))
208   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 8(1X,F13.9))
209   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 9(1X,F13.9))
210   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',10(1X,F13.9))
211   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',11(1X,F13.9))
212   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',12(1X,F13.9))
213   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',13(1X,F13.9))
214   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',14(1X,F13.9))
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [7] MULTI-CONFIG: MANY-CENTRE MULTICONFIG. SCF CALCULATIONS.       C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] MCSCF: MAIN ROUTINE FOR MULTI-CONFIGURATIONAL SCF CALCULATION. C
C**********************************************************************C
C
C
      SUBROUTINE MCSCF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           MM       MM  CCCCCC   SSSSSS   CCCCCC  FFFFFFFF            C
C           MMM     MMM CC    CC SS    SS CC    CC FF                  C
C           MMMM   MMMM CC       SS       CC       FF                  C
C           MM MM MM MM CC        SSSSSS  CC       FFFFFF              C
C           MM  MMM  MM CC             SS CC       FF                  C
C           MM   M   MM CC    CC SS    SS CC    CC FF                  C
C           MM       MM  CCCCCC   SSSSSS   CCCCCC  FF                  C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  MCSCF PERFORMS A MULTI-CONFIGURATIONAL SCF CALCULATION USING THE    C
C  APPROACH OF KNOWLES AND WERNER (1985,1988).                         C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMMON/TMCF/EMTY
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',20),'MULTI-CONFIGURATIONAL MOLECULAR SCF'
      WRITE(7, *) REPEAT(' ',20),'MULTI-CONFIGURATIONAL MOLECULAR SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     EQ-COEFFICIENTS IN COMMON ARRAYS
      IF(EQFILE.AND.READIN) THEN
        CALL EQSAVE
      ENDIF
C
C     WARN USER THAT ROUTINE HASN'T BEEN WRITTEN YET
      WRITE(6, *) 'In BERTHA: MCSCF option not yet available.'
      WRITE(7, *) 'In BERTHA: MCSCF option not yet available.'
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [8] MBPT: CORRELATION ENERGY CALCULATION ROUTINES.                 C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] MBPT: MAIN ROUTINE FOR MANY-BODY DIAGRAMMATIC P.T.             C
C   [B] MBPT1: ZERO- AND FIRST-ORDER ENERGY ANALYSIS.                  C
C   [C] MBPT2: SECOND-ORDER CORRELATION ENERGY ANALYSIS.               C
C**********************************************************************C
C
C
      SUBROUTINE MBPT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                MM       MM BBBBBBB  PPPPPPP TTTTTTTT                 C
C                MMM     MMM BB    BB PP    PP   TT                    C
C                MMMM   MMMM BB    BB PP    PP   TT                    C
C                MM MM MM MM BBBBBBB  PP    PP   TT                    C
C                MM  MMM  MM BB    BB PPPPPPP    TT                    C
C                MM   M   MM BB    BB PP         TT                    C
C                MM       MM BBBBBBB  PP         TT                    C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  MBPT PERFORMS MANY-BODY DIAGRAMMATIC EVALUATION ON A CONVERGED      C
C  MOLECULAR HARTREE-FOCK SOLUTION SPACE.                              C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 G2INT
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/TMPT/EMTY
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',21),'MANY-BODY PERTURBATION THEORY'
      WRITE(7, *) REPEAT(' ',21),'MANY-BODY PERTURBATION THEORY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     EQ-COEFFICIENTS IN COMMON ARRAYS
      IF(EQFILE.AND.READIN) THEN
        CALL EQSAVE
      ENDIF
C
C     GENERATE DENSITY MATRIX
      IF(READIN) THEN
        CALL DENSTY
      ENDIF
C
C     RESTRICT SET OF OCCUPIED AND VIRTUAL STATES
      MINO = 1
      NUMO = NOCC
      MINV = NOCC+1
      NUMV = NVRT
C
C     LABEL THE TWO-BODY INTERACTION ('COULM' OR 'BREIT')
c     G2INT = 'COULM'
      G2INT = 'BREIT'
C
C     SUMMARY OF INPUT CHOICES
      WRITE(6, *) 'First occupied orbital:     ',MINO
      WRITE(7, *) 'First occupied orbital:     ',MINO
      WRITE(6, *) 'Number of occupied orbitals:',NUMO
      WRITE(7, *) 'Number of occupied orbitals:',NUMO
      WRITE(6, *) 'First virtual orbital:      ',MINV
      WRITE(7, *) 'First virtual orbital:      ',MINV
      WRITE(6, *) 'Number of virtual orbitals: ',NUMV
      WRITE(7, *) 'Number of virtual orbitals: ',NUMV
      IF(G2INT.EQ.'COULM') THEN
        WRITE(6, *) '2-body interaction: Coulomb.'
        WRITE(7, *) '2-body interaction: Coulomb.'
      ELSEIF(G2INT.EQ.'BREIT') THEN
        WRITE(6, *) '2-body interaction: Breit.'
        WRITE(7, *) '2-body interaction: Breit.'
      ENDIF
C
C     CALL FIRST-ORDER MBPT ROUTINE
      CALL MBPT1(MINO,NUMO,G2INT)
      STOP
C
C     CALL SECOND-ORDER MBPT ROUTINE
      CALL MBPT2(MINO,NUMO,MINV,NUMV,G2INT)
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TMPT)
      TTOT = TTOT-TDUM
C
      RETURN
      END
C
C
      SUBROUTINE MBPT1(MINO,NUMO,G2INT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              MM       MM BBBBBBB  PPPPPPP TTTTTTTT 11                C
C              MMM     MMM BB    BB PP    PP   TT   111                C
C              MMMM   MMMM BB    BB PP    PP   TT    11                C
C              MM MM MM MM BBBBBBB  PP    PP   TT    11                C
C              MM  MMM  MM BB    BB PPPPPPP    TT    11                C
C              MM   M   MM BB    BB PP         TT    11                C
C              MM       MM BBBBBBB  PP         TT   1111               C
C                                                                      C
C -------------------------------------------------------------------- C
C  MBPT1 EVALUATES ZERO- AND FIRST-ORDER ENERGIES FOR ALL OCCUPIED     C
C  SOLUTIONS TO A CONVERGED HARTREE-FOCK PROBLEM.                      C
C -------------------------------------------------------------------- C
C INPUT:                                                               C
C  ▶ MINO  - LOWEST OCCUPIED STATE TO ACCOUNT FOR. (FULL: 1)           C
C  ▶ NUMO  - NUMBER OF OCCUPIED STATES TO ACCOUNT FOR. (FULL: NOCC)    C
C  ▶ G2INT - NAME OF TWO-BODY OPERATOR ('COULM' OR 'BREIT').           C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 G2INT
      CHARACTER*16 HMS
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 TITLE
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),JQN(4)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP),ITN(2)
      DIMENSION EAB1(NUMO,NUMO,6),EA1(NUMO,6)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 B1(MBS*NUMO,8),B2(MBS*NUMO,8)
      COMPLEX*16 DB(MB2,NUMO*NUMO,4)
      COMPLEX*16 ADB1(MBS,NUMO*NUMO*NUMO,2),ADB2(MBS,NUMO*NUMO*NUMO,2)
      COMPLEX*16 CADB((NUMO+1)*NUMO*NUMO*NUMO/2)
      COMPLEX*16 FOCK(MDM,MDM),OVLP(MDM,MDM),HNUC(MDM,MDM),
     &           HKIN(MDM,MDM),GDIR(MDM,MDM),GXCH(MDM,MDM),
     &           BDIR(MDM,MDM),BXCH(MDM,MDM),VUEH(MDM,MDM),
     &           QDIR(MDM,MDM),QXCH(MDM,MDM),WDIR(MDM,MDM),
     &           WXCH(MDM,MDM),CPLE(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/MTRX/FOCK,OVLP,HNUC,HKIN,GDIR,GXCH,BDIR,BXCH,VUEH,QDIR,
     &            QXCH,WDIR,WXCH,CPLE
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      RCFILE = .FALSE.
C
C     WARNINGS BASED ON INVALID HMLT VS. G2INT COMBINATIONS
      IF(G2INT.EQ.'COULM') THEN
        IF(HMLT.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT1: HMLT = BARE but G2INT = COULM.'
          WRITE(7, *) 'In MBPT1: HMLT = BARE but G2INT = COULM.'
        ENDIF
      ELSEIF(G2INT.EQ.'BREIT') THEN
        IF(HMLT.EQ.'NORL') THEN
          WRITE(6, *) 'In MBPT1: HMLT = NORL but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLT = NORL but G2INT = BREIT.'
          RETURN
        ELSEIF(HMLT.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT1: HMLT = BARE but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLT = BARE but G2INT = BREIT.'
        ELSEIF(HMLT.EQ.'DHFR') THEN
          WRITE(6, *) 'In MBPT1: HMLT = DHFR but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLT = DHFR but G2INT = BREIT.'
        ENDIF
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 1
          ITSTOP = 1
          ITSKIP = 1
        ENDIF
      ELSE
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 4
          ITSTOP = 1
          ITSKIP =-3
        ELSEIF(G2INT.EQ.'BREIT') THEN
          ITSTRT = 2
          ITSTOP = 3
          ITSKIP = 1        
        ENDIF
      ENDIF
C
C     INITIALISE TIME COUNTERS
      T1EL = 0.0D0
      TERI = 0.0D0
      TCN1 = 0.0D0
      TCN2 = 0.0D0
      TCN3 = 0.0D0
      TCN4 = 0.0D0
      TSUM = 0.0D0
C
      CALL CPU_TIME(TBEG)
C
C     CLEAR ENERGY COUNTERS
      DO N=1,6
        DO IOCCB=1,NUMO
          EA1(IOCCB,N) = 0.0D0
          DO IOCCA=1,NUMO
            EAB1(IOCCA,IOCCB,N) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     CLEAR THE ARRAY FOR (AR|BS) VALUES
      M = 0
      DO IOCCC=1,NUMO
        DO IOCCA=1,NUMO
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
              M = M+1
              CADB(M) = DCMPLX(0.0D0,0.0D0)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ONE-BODY ENERGIES (INSIGNIFICANT COMPUTATIONAL COST)             C
C**********************************************************************C
C
C     RECORD TIME AT THE START OF THIS PROCESS
      CALL CPU_TIME(T1)
C
C     CALCULATE ONE-BODY MATRIX REPS
      CALL ONEEL
C
C     LOOP OVER ALL OCCUPIED ORBITAL PAIRS AND CONTRACT
      E1H = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         FOCK MATRIX ADDRESS FOR IOCCA AND IOCCB
          IA = MINO-1+IOCCA+NSKP
          IB = MINO-1+IOCCB+NSKP
C
C         ONE-BODY ENERGY
          EN = 0.0D0
          ET = 0.0D0
          IF(IOCCA.EQ.IOCCB) THEN
            DO J=1,NDIM
              DO I=1,NDIM
                EN = EN + DREAL(HNUC(I,J)*DCONJG(COEF(I,IA))*COEF(J,IA))
                ET = ET + DREAL(HKIN(I,J)*DCONJG(COEF(I,IA))*COEF(J,IA))
              ENDDO
            ENDDO
          ENDIF
          EAB1(IOCCA,IOCCB,1) = EN
          EAB1(IOCCA,IOCCB,2) = ET
          EAB1(IOCCA,IOCCB,3) = EN+ET
          E1H = E1H + EAB1(IOCCA,IOCCB,3)
C
        ENDDO
      ENDDO
C
C     RECORD TIME AT THE END OF THIS PROCESS
      CALL CPU_TIME(T2)
      T1EL = T1EL+T2-T1
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPES A AND B (USE INDEX 2000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
        JQN(1) = 2*IABS(KQN(1))-1
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
        JQN(2) = 2*IABS(KQN(2))-1
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1, NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER |MQN| PROJECTIONS A AND B (INDEX 3000)                 C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     INDEX ASSIGNMENT
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(G2INT.EQ.'COULM') THEN
        IF(IQ1.LT.IQ2) GOTO 3001
      ENDIF
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSL = IADISL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      IF(G2INT.EQ.'COULM') THEN
        PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
        PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      ELSEIF(G2INT.EQ.'BREIT') THEN
        PAB1 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
        PAB2 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      ENDIF
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS A AND B (INDEX 4000)          C
C**********************************************************************C
C
C     COMPONENT LABEL FOR A AND B: TT = LL(1) or SS(4) <- COULOMB
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(ITN(1).EQ.1) THEN
          NADDA = 0
          NADDB = 0
        ELSEIF(ITN(1).EQ.2) THEN
          NADDA = 0
          NADDB = NSKP
        ELSEIF(ITN(1).EQ.3) THEN
          NADDA = NSKP
          NADDB = 0
        ELSEIF(ITN(1).EQ.4) THEN
          NADDA = NSKP
          NADDB = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C**********************************************************************C
C     FOCK MATRIX STARTING ADDRESSES                                   C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDA
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDA
C
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDB
C
C     CLEAR ARRAY FOR THE COMPLETED CONTRACTION OVER BLOCKS C AND D
      DO MDB=1,NUMO*NUMO
        DO MIJ=1,NBAS(1)*NBAS(2)
          DO IJSPIN=1,4
            DB(MIJ,MDB,IJSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES C AND D (USE INDEX 5000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE C
      DO 5000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 5000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
      IF(MCNT.NE.1.AND.ICNTA.NE.1) GOTO 5001
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPES C AND D (USE INDEX 6000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(C) VALUES
      DO 6000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
        JQN(3) = 2*IABS(KQN(3))-1
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 6000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
        JQN(4) = 2*IABS(KQN(4))-1
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON KQN                           C
C**********************************************************************C
C
C     ATOM-CENTRED SELECTION RULES
      IF(MCNT.EQ.1) THEN
C
C       LQN PAIR PARITY (0 IF EVEN, 1 IF ODD)
        IPARAB = MOD(LQN(1)+LQN(2),2)
        IPARCD = MOD(LQN(3)+LQN(4),2)
C
C       LQN PAIR PARITY SELECTION RULE
        IF(IPARAB.NE.IPARCD) THEN
          GOTO 6001
        ENDIF
C
C       JQN TRIANGLE RULE CHECK FOR MULTIPOLE EXPANSION (ATOM-CENTRED)
        NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
        NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
        IF(NUI.GT.NUF) THEN
          GOTO 6001
        ENDIF
C
C       ADDITIONAL LQN SELECTION RULE PARITY ANALYSIS
        ISELK = 0
        DO NU=NUI,NUF
C
C         A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD (0 IF EVEN, 1 IF ODD)
          IPARAB = MOD(LQN(1)+LQN(2)+NU,2)
C
C         C AND D: LQN(3)+LQN(4)+NU EVEN OR ODD (0 IF EVEN, 1 IF ODD)
          IPARCD = MOD(LQN(3)+LQN(4)+NU,2)
C
C         CASE 1: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH ODD (UNLESS NU=0)
          IF(IPARAB.EQ.1.AND.IPARCD.EQ.1.AND.NU.NE.0) ISELK = 1
C
C         CASE 2: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH EVEN
          IF(IPARAB.EQ.0.AND.IPARCD.EQ.0) ISELK = 1
C
        ENDDO
        IF(ISELK.EQ.0) GOTO 6001
C
      ENDIF
C
C     ADDITIONAL SELECTION RULES FOR CLOSED-SHELL ATOMS
      IF(MCNT.EQ.1) THEN
        ISELK = 0
        IF(KA.EQ.KB.AND.KC.EQ.KD) ISELK = 1
        IF(KA.EQ.KC.AND.KB.EQ.KD) ISELK = 1
        IF(KA.EQ.KD.AND.KB.EQ.KC) ISELK = 1
        IF(ISELK.EQ.0) GOTO 6001
      ENDIF
C
C**********************************************************************C
C     LOOP OVER |MQN| PROJECTIONS C AND D (INDEX 7000)                 C
C**********************************************************************C
C
C     LOOP OVER |MQN(C)| VALUES
      DO 7000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 7000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     INDEX ASSIGNMENT
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(G2INT.EQ.'COULM') THEN
        IF(IQ3.LT.IQ4) GOTO 7001
      ENDIF
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSL = IADISL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      IF(G2INT.EQ.'COULM') THEN
        PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
        PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
      ELSEIF(G2INT.EQ.'BREIT') THEN
        PCD1 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
        PCD2 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
      ENDIF
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ISYM.EQ.1) THEN
        ISELM = 0
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) ISELM = 1
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) ISELM = 1
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) ISELM = 1
        IF(ISELM.EQ.0) GOTO 7001
      ENDIF
C
C     ATOM-CENTRED SELECTION RULES (ONLY APPLIES IF RACAH1 SWITCHED OFF)
      IF(MCNT.EQ.1) THEN
        ISELM = 0
        DO ISGN1=1,2
          DO ISGN2=1,2
            DO ISGN3=1,2
              DO ISGN4=1,2
                MMJA = MQN(1)*((-1)**ISGN1)
                MMJB = MQN(2)*((-1)**ISGN2)
                MMJC = MQN(3)*((-1)**ISGN3)
                MMJD = MQN(4)*((-1)**ISGN4)
                IF(MMJA-MMJB.EQ.MMJD-MMJC) ISELM = 1
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        IF(ISELM.EQ.0) GOTO 7001
      ENDIF
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS C AND D (INDEX 8000)          C
C**********************************************************************C
C
C     COMPONENT LABEL FOR C AND D: TT = LL(1) or SS(4) <- COULOMB
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 8000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(ITN(2).EQ.1) THEN
          NADDC = 0
          NADDD = 0
        ELSEIF(ITN(2).EQ.2) THEN
          NADDC = 0
          NADDD = NSKP
        ELSEIF(ITN(2).EQ.3) THEN
          NADDC = NSKP
          NADDD = 0
        ELSEIF(ITN(2).EQ.4) THEN
          NADDC = NSKP
          NADDD = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C**********************************************************************C
C     FOCK MATRIX STARTING ADDRESSES                                   C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDC
      NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDC
C
      ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDD
      ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 9000)         C
C**********************************************************************C
C
      DO 9000 IBAS=1,NBAS(1)
      DO 9000 JBAS=1,NBAS(2)
C
C     LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
      MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C     RESET SCREENING COUNTERS
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
      ENDDO
      MAXN = NBAS(3)*NBAS(4)
C
C     OVERRIDE GAUNT REPLACEMENT TOGGLE
      MGNT = 0
C
C     BATCH OF TWO-BODY INTEGRALS (IJ|KL) FOR FIXED (IJ)
      CALL CPU_TIME(T1)
      IF(G2INT.EQ.'COULM') THEN
        CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
      ELSEIF(G2INT.EQ.'BREIT') THEN
        CALL BII(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN,MGNT)
      ENDIF
      CALL CPU_TIME(T2)
      TERI = TERI + T2 - T1
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (DIRECT)
      DO MKB=1,NBAS(3)*NUMO
        DO IJKSPIN=1,8
          B1(MKB,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (SWAP)
      DO MLB=1,NBAS(4)*NUMO
        DO IJLSPIN=1,8
          B2(MLB,IJLSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST CONTRACTION:                                               C
C     (IJ;T|KL;T') -> (IJ;T|KB;T')  AND  (IJ;T|LK;T') -> (IJ;T|LB;T')  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FIRST CONTRACTION (DIRECT): (IJ;T|KL;T') -> (IJ;T|KB;T')
C
C     LOOP OVER OCCUPIED STATES IOCCB
      DO IOCCB=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCB
        IB = MINO-1+IOCCB+NSKP
C
C       LOOP OVER ALL KBAS IN BLOCK C
        DO KBAS=1,NBAS(3)
C
C         LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
          MKB = (KBAS-1)*NUMO + IOCCB
C
C         LOOP OVER ALL LBAS IN BLOCK D AND CONTRACT OVER ERI
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|-B) = (--|--) + (--|-+)
            B1(MKB,1) = B1(MKB,1) + RR(M, 1)*COEF(ND1+LBAS,IB)
     &                            + RR(M, 2)*COEF(ND2+LBAS,IB)
C
C           (--|+B) = (--|+-) + (--|++)
            B1(MKB,2) = B1(MKB,2) + RR(M, 3)*COEF(ND1+LBAS,IB)
     &                            + RR(M, 4)*COEF(ND2+LBAS,IB)
C
C           (-+|-B) = (-+|--) + (-+|-+)
            B1(MKB,3) = B1(MKB,3) + RR(M, 5)*COEF(ND1+LBAS,IB)
     &                            + RR(M, 6)*COEF(ND2+LBAS,IB)
C
C           (-+|+B) = (-+|+-) + (-+|++)
            B1(MKB,4) = B1(MKB,4) + RR(M, 7)*COEF(ND1+LBAS,IB)
     &                            + RR(M, 8)*COEF(ND2+LBAS,IB)
C
C           (+-|-B) = (+-|--) + (+-|-+)
            B1(MKB,5) = B1(MKB,5) + RR(M, 9)*COEF(ND1+LBAS,IB)
     &                            + RR(M,10)*COEF(ND2+LBAS,IB)
C
C           (+-|+B) = (+-|+-) + (+-|++)
            B1(MKB,6) = B1(MKB,6) + RR(M,11)*COEF(ND1+LBAS,IB)
     &                            + RR(M,12)*COEF(ND2+LBAS,IB)
C
C           (++|-B) = (++|--) + (++|-+)
            B1(MKB,7) = B1(MKB,7) + RR(M,13)*COEF(ND1+LBAS,IB)
     &                            + RR(M,14)*COEF(ND2+LBAS,IB)
C
C           (++|+B) = (++|+-) + (++|++)
            B1(MKB,8) = B1(MKB,8) + RR(M,15)*COEF(ND1+LBAS,IB)
     &                            + RR(M,16)*COEF(ND2+LBAS,IB)
C
          ENDDO
        ENDDO
      ENDDO
C
C     FIRST CONTRACTION (SWAP): (IJ;T|LK;T') -> (IJ;T|LB;T')
      IF(G2INT.EQ.'COULM'.AND.IQ3.EQ.IQ4) GOTO 9001
      IF(G2INT.EQ.'BREIT') GOTO 9001
C
C     LOOP OVER OCCUPIED STATES IOCCB
      DO IOCCB=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCB
        IB = MINO-1+IOCCB+NSKP
C
C       LOOP OVER ALL LBAS IN BLOCK D
        DO LBAS=1,NBAS(4)
C
C         LIST ADDRESS FOR THIS LBAS,IOCCB COMBINATION
          MLB = (LBAS-1)*NUMO + IOCCB
C
C         LOOP OVER ALL KBAS IN BLOCK C AND CONTRACT OVER ERI
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|-B)' = PCD1*(--|++) + PCD2*(--|-+)
            B2(MLB,1) = B2(MLB,1) 
     &                        + PCD1*RR(M, 4)*DCONJG(COEF(NC1+KBAS,IB))
     &                        + PCD2*RR(M, 2)*DCONJG(COEF(NC2+KBAS,IB))
C
C           (--|+B)' = PCD2*(--|+-) + PCD1*(--|--)
            B2(MLB,2) = B2(MLB,2) 
     &                        + PCD2*RR(M, 3)*DCONJG(COEF(NC1+KBAS,IB))
     &                        + PCD1*RR(M, 1)*DCONJG(COEF(NC2+KBAS,IB))
C
C           (-+|-B)' = PCD1*(-+|++) + PCD2*(-+|-+)
            B2(MLB,3) = B2(MLB,3) 
     &                        + PCD1*RR(M, 8)*DCONJG(COEF(NC1+KBAS,IB))
     &                        + PCD2*RR(M, 6)*DCONJG(COEF(NC2+KBAS,IB))
C
C           (-+|+B)' = PCD2*(-+|+-) + PCD1*(-+|--)
            B2(MLB,4) = B2(MLB,4) 
     &                        + PCD2*RR(M, 7)*DCONJG(COEF(NC1+KBAS,IB))
     &                        + PCD1*RR(M, 5)*DCONJG(COEF(NC2+KBAS,IB))
C
C           (+-|-B)' = PCD1*(+-|++) + PCD2*(+-|-+)
            B2(MLB,5) = B2(MLB,5) 
     &                        + PCD1*RR(M,12)*DCONJG(COEF(NC1+KBAS,IB))
     &                        + PCD2*RR(M,10)*DCONJG(COEF(NC2+KBAS,IB))
C
C           (+-|+B)' = PCD2*(+-|+-) + PCD1*(+-|--)
            B2(MLB,6) = B2(MLB,6) 
     &                        + PCD2*RR(M,11)*DCONJG(COEF(NC1+KBAS,IB))
     &                        + PCD1*RR(M, 9)*DCONJG(COEF(NC2+KBAS,IB))
C
C           (++|-B)' = PCD1*(++|++) + PCD2*(++|-+)
            B2(MLB,7) = B2(MLB,7) 
     &                        + PCD1*RR(M,16)*DCONJG(COEF(NC1+KBAS,IB))
     &                        + PCD2*RR(M,14)*DCONJG(COEF(NC2+KBAS,IB))
C
C           (++|+B)' = PCD2*(++|+-) + PCD1*(++|--)
            B2(MLB,8) = B2(MLB,8) 
     &                        + PCD2*RR(M,15)*DCONJG(COEF(NC1+KBAS,IB))
     &                        + PCD1*RR(M,13)*DCONJG(COEF(NC2+KBAS,IB))
C
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ3=IQ4
9001  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN1 = TCN1 + T2 - T1
C
C**********************************************************************C
C     SECOND CONTRACTION:                                   ~          C
C     (IJ;T|KB;T') -> (IJ;T|DB)  AND  (IJ;T|LB;T') -> (IJ;T|DB)        C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     SECOND CONTRACTION (DIRECT): (IJ;T|KB) -> (IJ;T|DB)
C
C     LOOP OVER OCCUPIED STATES IOCCD
      DO IOCCD=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCD
        ID = MINO-1+IOCCD+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCB
        DO IOCCB=1,NUMO
C
C         LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION IN B1
          MDB = (IOCCB-1)*NUMO + IOCCD
C
C         LOOP OVER ALL KBAS IN BLOCK C AND CONTRACT OVER B1
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
            MKB = (KBAS-1)*NUMO + IOCCB
C
C           (--|DB) = (--|-B) + (--|+B)
            DB(MIJ,MDB,1) = DB(MIJ,MDB,1)
     &                            + B1(MKB,1)*DCONJG(COEF(NC1+KBAS,ID))
     &                            + B1(MKB,2)*DCONJG(COEF(NC2+KBAS,ID))
C
C           (+-|DB) = (+-|-B) + (+-|+B)
            DB(MIJ,MDB,2) = DB(MIJ,MDB,2)
     &                            + B1(MKB,3)*DCONJG(COEF(NC1+KBAS,ID))
     &                            + B1(MKB,4)*DCONJG(COEF(NC2+KBAS,ID))
C
C           (-+|DB) = (-+|-B) + (-+|+B)
            DB(MIJ,MDB,3) = DB(MIJ,MDB,3)
     &                            + B1(MKB,5)*DCONJG(COEF(NC1+KBAS,ID))
     &                            + B1(MKB,6)*DCONJG(COEF(NC2+KBAS,ID))
C
C           (++|DB) = (++|-B) + (++|+B)
            DB(MIJ,MDB,4) = DB(MIJ,MDB,4)
     &                            + B1(MKB,7)*DCONJG(COEF(NC1+KBAS,ID))
     &                            + B1(MKB,8)*DCONJG(COEF(NC2+KBAS,ID))
C
          ENDDO
        ENDDO
      ENDDO
C
C     SECOND CONTRACTION (SWAP): (IJ;T|LB) -> (IJ;T|DB)
      IF(G2INT.EQ.'COULM'.AND.IQ3.EQ.IQ4) GOTO 9002
      IF(G2INT.EQ.'BREIT') GOTO 9002
C
C     LOOP OVER OCCUPIED STATES IOCCD
      DO IOCCD=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCD
        ID = MINO-1+IOCCD+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCB
        DO IOCCB=1,NUMO
C
C         LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION IN B2
          MDB = (IOCCB-1)*NUMO + IOCCD
C
C         LOOP OVER ALL LBAS IN BLOCK D AND CONTRACT OVER B2
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS LBAS,IOCCB COMBINATION
            MLB = (LBAS-1)*NUMO + IOCCB
C
C           (--|DB) = (--|-B)' + (--|+B)'
            DB(MIJ,MDB,1) = DB(MIJ,MDB,1) + B2(MLB,1)*COEF(ND1+LBAS,ID)
     &                                    + B2(MLB,2)*COEF(ND2+LBAS,ID)
C
C           (-+|DB) = (-+|-B)' + (-+|+B)'
            DB(MIJ,MDB,2) = DB(MIJ,MDB,2) + B2(MLB,3)*COEF(ND1+LBAS,ID)
     &                                    + B2(MLB,4)*COEF(ND2+LBAS,ID)
C
C           (+-|DB) = (+-|-B)' + (+-|+B)'
            DB(MIJ,MDB,3) = DB(MIJ,MDB,3) + B2(MLB,5)*COEF(ND1+LBAS,ID)
     &                                    + B2(MLB,6)*COEF(ND2+LBAS,ID)
C
C           (++|DB) = (++|-B)' + (++|+B)'
            DB(MIJ,MDB,4) = DB(MIJ,MDB,4) + B2(MLB,7)*COEF(ND1+LBAS,ID)
     &                                    + B2(MLB,8)*COEF(ND2+LBAS,ID)
C
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ3=IQ4
9002  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN2 = TCN2 + T2 - T1
C
C     END LOOP OVER BASIS PAIR (IBAS,JBAS)
9000  CONTINUE
C
C     END LOOP OVER COMPONENT OVERLAP T'T'
8000  CONTINUE
C
C     SKIP POINT FOR IQ3.LT.IQ4
7001  CONTINUE
C
C     ALL CONTRIBUTIONS FROM BLOCK (C,D) NOW ACCOUNTED FOR
7000  CONTINUE
C     SKIP POINT FOR KQN SELECTION RULES
6001  CONTINUE
6000  CONTINUE
5001  CONTINUE
5000  CONTINUE
C
C**********************************************************************C
C     THIRD CONTRACTION:                                               C
C     (IJ;T|DB) -> (IA;T|DB)  AND  (JI;T|DB) -> (JA;T|DB)              C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     THIRD CONTRACTION (DIRECT): (IJ;T|DB) -> (IA;T|DB)
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (DIRECT)
      DO MADB=1,NUMO*NUMO*NUMO
        DO IBAS=1,NBAS(1)
          DO ISPIN=1,2
            ADB1(IBAS,MADB,ISPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCD
        DO IOCCD=1,NUMO
C
C         LOOP OVER OCCUPIED STATES IOCCB
          DO IOCCB=1,IOCCA

C
C           LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
            MDB = (IOCCB-1)*NUMO+IOCCD
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
            MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C           LOOP OVER ALL (IBAS,JBAS) IN A AND B, CONTRACT OVER DB
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-A|DB) = (--|DB) + (-+|DB)
                ADB1(IBAS,MADB,1) = ADB1(IBAS,MADB,1)
     &                                + DB(MIJ,MDB,1)*COEF(NB1+JBAS,IA)
     &                                + DB(MIJ,MDB,2)*COEF(NB2+JBAS,IA)
C
C               (+A|DB) = (+-|DB) + (++|DB)
                ADB1(IBAS,MADB,2) = ADB1(IBAS,MADB,2)
     &                                + DB(MIJ,MDB,3)*COEF(NB1+JBAS,IA)
     &                                + DB(MIJ,MDB,4)*COEF(NB2+JBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     THIRD CONTRACTION (SWAP): (JI;T|DB) -> (JA;T|DB)
      IF(G2INT.EQ.'COULM'.AND.IQ1.EQ.IQ2) GOTO 4001
      IF(G2INT.EQ.'BREIT') GOTO 4001
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (SWAP)
      DO MADB=1,NUMO*NUMO*NUMO
        DO JBAS=1,NBAS(2)
          DO JSPIN=1,2
            ADB2(JBAS,MADB,JSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCD
        DO IOCCD=1,NUMO
C
C         LOOP OVER OCCUPIED STATES IOCCB
          DO IOCCB=1,IOCCA
C
C           LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
            MDB = (IOCCB-1)*NUMO+IOCCD
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
            MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C           LOOP OVER BASIS FUNCTIONS IN A AND B, CONTRACT OVER DB
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-A|DB)' = PAB1*(++|DB) + PAB2*(-+|DB)
                ADB2(JBAS,MADB,1) = ADB2(JBAS,MADB,1)
     &                   + PAB1*DB(MIJ,MDB,4)*DCONJG(COEF(NA1+IBAS,IA))
     &                   + PAB2*DB(MIJ,MDB,2)*DCONJG(COEF(NA2+IBAS,IA))
C
C               (+A|DB)' = PAB2*(+-|DB) + PAB1*(--|DB)
                ADB2(JBAS,MADB,2) = ADB2(JBAS,MADB,2)
     &                   + PAB2*DB(MIJ,MDB,3)*DCONJG(COEF(NA1+IBAS,IA))
     &                   + PAB1*DB(MIJ,MDB,1)*DCONJG(COEF(NA2+IBAS,IA))
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ1=IQ2
4001  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN3 = TCN3 + T2 - T1
C
C**********************************************************************C
C     FOURTH CONTRACTION:                      ~                       C
C     (IA;T|DB) -> (CA|DB)  AND  (JA;T|DB) -> (CA|DB)                  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOURTH CONTRACTION (DIRECT): (IA;T|DB) -> (CA|DB)
C
C     LOOP OVER OCCUPIED STATES IOCCC
      DO IOCCC=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCC
        IC = MINO-1+IOCCC+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         LOOP OVER OCCUPIED STATES IOCCD
          DO IOCCD=1,NUMO
C
C           LOOP OVER OCCUPIED STATES IOCCB
            DO IOCCB=1,IOCCA
C
C             LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
              MDB = (IOCCB-1)*NUMO + IOCCD
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
              MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C             LIST ADDRESS FOR THIS IOCCC,IOCCA AND THE ABOVE MDB
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + MDB
C
C             LOOP OVER ALL IBAS IN BLOCK A, CONTRACT OVER ADB1
              DO IBAS=1,NBAS(1)
C
C               (CA|DB) = (-A|DB) + (+A|DB)
                CADB(MCADB) = CADB(MCADB)
     &                    + ADB1(IBAS,MADB,1)*DCONJG(COEF(NA1+IBAS,IC))
     &                    + ADB1(IBAS,MADB,2)*DCONJG(COEF(NA2+IBAS,IC))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C                                              ~
C     FOURTH CONTRACTION (SWAP): (JA;T|DB) -> (CA|DB)
      IF(G2INT.EQ.'COULM'.AND.IQ1.EQ.IQ2) GOTO 4002
      IF(G2INT.EQ.'BREIT') GOTO 4002
C
C     LOOP OVER OCCUPIED STATES IOCCC
      DO IOCCC=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCC
        IC = MINO-1+IOCCC+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         LOOP OVER OCCUPIED STATES IOCCD
          DO IOCCD=1,NUMO
C
C           LOOP OVER OCCUPIED STATES IOCCB
            DO IOCCB=1,IOCCA
C
C             LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
              MDB = (IOCCB-1)*NUMO + IOCCD
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
              MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C             LIST ADDRESS FOR THIS IOCCC,IOCCA AND THE ABOVE MDB
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + MDB
C
C             LOOP OVER BASIS FUNCTIONS IN BLOCK B, CONTRACT OVER ADB2
              DO JBAS=1,NBAS(2)
C
C               (CA|DB) = (-A|DB)' + (+A|DB)'
                CADB(MCADB) = CADB(MCADB)
     &                            + ADB2(JBAS,MADB,1)*COEF(NB1+JBAS,IC)
     &                            + ADB2(JBAS,MADB,2)*COEF(NB2+JBAS,IC)
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ1=IQ2
4002  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN4 = TCN4 + T2 - T1
C
C     END LOOP OVER COMPONENT OVERLAP TT
4000  CONTINUE
C
C     SKIP POINT FOR IQ1.LT.IQ2
3001  CONTINUE
C
C     ALL CONTRIBUTIONS FROM BLOCK (A,B) NOW ACCOUNTED FOR
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER PAIR CORRELATION ENERGY FROM (CA|DB)      C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOR EACH IOCCA,IOCCB PAIR, SUM OVER IVRTR AND IVRTS CONTRIBUTIONS
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCC=1,NUMO
        DO IOCCA=1,NUMO
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCD=1,NUMO
            DO IOCCB=1,IOCCA
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTR,IOCCB,IVRTS
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + (IOCCB-1)*NUMO + IOCCD
C
              IF(IOCCA.EQ.IOCCC.AND.IOCCB.EQ.IOCCD) THEN
                EAB1(IOCCA,IOCCB,4) = DREAL(CADB(MCADB))
              ENDIF
              
              IF(IOCCB.EQ.IOCCC.AND.IOCCA.EQ.IOCCD) THEN
                EAB1(IOCCA,IOCCB,5) =-DREAL(CADB(MCADB))
              ENDIF
C
C             ADD TO DIRECT AND EXCHANGE BINS
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     FILL IN THE OTHER HALF OF THE ARRAY AND CALCULATE TOTALS
      E1D = 0.0D0
      E1X = 0.0D0
      E1S = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         INTERMEDIATE VALUES
          EAB1DIR = EAB1(IOCCA,IOCCB,4)
          EAB1XCH = EAB1(IOCCA,IOCCB,5)
          EAB1SUM = EAB1DIR + EAB1XCH
C
C         PUT THESE INTO EAB1 AND ADD CONTRIBUTION TO E1
          EAB1(IOCCA,IOCCB,6) = EAB1SUM
          IF(IOCCA.NE.IOCCB) THEN
            EAB1(IOCCB,IOCCA,4) = EAB1DIR
            EAB1(IOCCB,IOCCA,5) = EAB1XCH
            EAB1(IOCCB,IOCCA,6) = EAB1SUM
            E1D = E1D +       EAB1DIR
            E1X = E1X +       EAB1XCH
            E1S = E1S +       EAB1SUM
          ELSE
            E1D = E1D + 0.5D0*EAB1DIR
            E1X = E1X + 0.5D0*EAB1XCH
            E1S = E1S + 0.5D0*EAB1SUM
          ENDIF
        ENDDO
      ENDDO
C
C     WRITE RESULTS OF EAB ENERGIES TO AN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT1.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NUMO
        DO IOCCB=1,NUMO
          WRITE(8, *) (EAB1(IOCCA,IOCCB,N),N=1,6)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER SINGLE ORBITAL ENERGY                     C
C**********************************************************************C
C
C     FOR EACH IOCCA, SUM OVER THE IOCCB CONTRIBUTIONS
      DO IOCCA=1,NUMO
        DO N=1,6
          EA1(IOCCA,N) = 0.0D0
          DO IOCCB=1,NUMO
            EA1(IOCCA,N) = EA1(IOCCA,N) + EAB1(IOCCA,IOCCB,N)
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TSUM = TSUM + T2 - T1
C
C**********************************************************************C
C     TERMINAL OUTPUT SUMMARY                                          C
C**********************************************************************C
C
C     MBPT1 PAIRWISE SUMMARY
20    FORMAT(1X,A,9X,A,9X,A,9X,A,10X,A)
21    FORMAT(' (',I2,',',I2,')',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
221   FORMAT(' (',I2,',',I2,')',3(F16.10,3X))
121   FORMAT(' (',A,',',A,')',3X,F16.10,5X,F16.10,5X,F16.10)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'MBPT1 pairwise summary'
      WRITE(7, *) REPEAT(' ',25),'MBPT1 pairwise summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) '( a, b)','E1H(ab)','E1J(ab)','E1K(ab)','E1G(ab)'
      WRITE(7,20) '( a, b)','E1H(ab)','E1J(ab)','E1K(ab)','E1G(ab)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        DO IOCCB=1,IOCCA
          IBNUM = IOCCB+MINO-1
          WRITE(6,21) IANUM,IBNUM,(EAB1(IOCCA,IOCCB,N),N=3,6)
          WRITE(7,21) IANUM,IBNUM,(EAB1(IOCCA,IOCCB,N),N=3,6)
        ENDDO
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 SINGLE-PARTICLE SUMMARY
30    FORMAT(1X,A,10X,A,10X,A,10X,A,10X,A)
31    FORMAT('  ',I2,'    ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',21),'MBPT1 single particle summary'
      WRITE(7, *) REPEAT(' ',21),'MBPT1 single particle summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) '  a    ','E1H(a)','E1J(a)','E1K(a)',' E1G(a)'
      WRITE(7,30) '  a    ','E1H(a)','E1J(a)','E1K(a)',' E1G(a)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        WRITE(6,31) IANUM,(EA1(IOCCA,N),N=3,6)
        WRITE(7,31) IANUM,(EA1(IOCCA,N),N=3,6)
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 TOTAL FIRST-ORDER INTERACTION
32    FORMAT(' total  ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',19),'MBPT1 first order molecular energy'
      WRITE(7, *) REPEAT(' ',19),'MBPT1 first order molecular energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,32) E1H,E1D,E1X,E1S
      WRITE(7,32) E1H,E1D,E1X,E1S
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 LABOUR ANALYSIS
      CALL CPU_TIME(TFIN)
      TTOT = TFIN - TBEG
      TOTH = TTOT - (T1EL + TERI + TCN1 + TCN2 + TSUM)

40    FORMAT(1X,A,15X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',26),'MBPT1 labour analysis'
      WRITE(7, *) REPEAT(' ',26),'MBPT1 labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6,40) 'One-body terms - EH(A,B)                 ',HMS(T1EL)
      WRITE(7,40) 'One-body terms - EH(A,B)                 ',HMS(T1EL)
      WRITE(6,40) 'ERI construction - (IJ|KL)               ',HMS(TERI)
      WRITE(7,40) 'ERI construction - (IJ|KL)               ',HMS(TERI)
      WRITE(6,40) '1st contraction  - (IJ|KB)               ',HMS(TCN1)
      WRITE(7,40) '1st contraction  - (IJ|KB)               ',HMS(TCN1)
      WRITE(6,40) '2nd contraction  - (IJ|BB) and (IJ|AB)   ',HMS(TCN2)
      WRITE(7,40) '2nd contraction  - (IJ|BB) and (IJ|AB)   ',HMS(TCN2)
      WRITE(6,40) '3rd contraction  - (IA|BB) and (IA|AB)   ',HMS(TCN3)
      WRITE(7,40) '3rd contraction  - (IA|BB) and (IA|AB)   ',HMS(TCN3)
      WRITE(6,40) '4th contraction  - (AA|BB) and (BA|AB)   ',HMS(TCN4)
      WRITE(7,40) '4th contraction  - (AA|BB) and (BA|AB)   ',HMS(TCN4)
      WRITE(6,40) 'Other                                    ',HMS(TOTH)
      WRITE(7,40) 'Other                                    ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,40) 'Total MBPT1 time                         ',HMS(TTOT)
      WRITE(7,40) 'Total MBPT1 time                         ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE MBPT2(MINO,NUMO,MINV,NUMV,G2INT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            MM       MM BBBBBBB  PPPPPPP TTTTTTTT 222222              C
C            MMM     MMM BB    BB PP    PP   TT   22    22             C
C            MMMM   MMMM BB    BB PP    PP   TT         22             C
C            MM MM MM MM BBBBBBB  PP    PP   TT       22               C
C            MM  MMM  MM BB    BB PPPPPPP    TT     22                 C
C            MM   M   MM BB    BB PP         TT   22                   C
C            MM       MM BBBBBBB  PP         TT   22222222             C
C                                                                      C
C -------------------------------------------------------------------- C
C  MBPT2 CALCULATES SECOND-ORDER PAIR CORRELATION CORRECTIONS OVER A   C
C  USER-SPECIFIED TWO-BODY OPERATOR. IT USES A RELATIVISTIC ADAPTION   C
C  OF THE DIRECT MP2 ALGORITHM OF HEAD-GORDON, POPLE AND FRISCH (1988).C
C  THIS IS NOT MOLLER-PLESSET PERTURBATION THEORY, SO CALL IT MBPT2.   C
C  ELECTRON REPULATION INTEGRALS ARE GENERATED ONCE, AT THE EXPENSE OF C
C  ADDITIONAL MEMORY STORAGE -- THEY ARE CONTRACTED IN FOUR STEPS.     C
C  THIS ALGORITHM EXPLOITS SYMMETRIES BETWEEN (A,B) AND (C,D) IN THE   C
C  INTEGRALS (AB|CD), BUT NOT THE SWAP (AB|CD)<->(CD|AB). STRUCTURE    C
C  MIMICS THAT OF 'COULOMB', BUT DOES NOT IMPLEMENT SELECTION RULES.   C
C  CONTRACTION ADDRESSES ARE CALCULATED EXPLICITLY RATHER THAN JUST    C
C  WITH UPDATING COUNTERS -- THIS IS TO GUIDE THE USER IN TRACKING.    C
C -------------------------------------------------------------------- C
C INPUT:                                                               C
C ▶ MINO  - LOWEST OCCUPIED STATE TO ACCOUNT FOR. (FULL: 1)            C
C ▶ NUMO  - NUMBER OF OCCUPIED STATES TO ACCOUNT FOR. (FULL: NOCC)     C
C ▶ MINV  - LOWEST VIRTUAL STATE TO ACCOUNT FOR. (FULL: NOCC+1)        C
C ▶ NUMV  - NUMBER OF VIRTUAL STATES TO ACCOUNT FOR. (FULL: NVRT)      C
C ▶ G2INT - NAME OF TWO-BODY OPERATOR ('COULM' OR 'BREIT').            C
C -------------------------------------------------------------------- C
C ▶ LOOP STRUCTURE NOT LIKE COULOMB -- MUST CONTRACT C AND D ASAP.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 G2INT
      CHARACTER*16 HMS
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP)
      DIMENSION EAB2(NUMO,NUMO,6),EA2(NUMO,6)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 B(MBS*NUMO,8),SB(MB2,NUMO*NUMV,4)
      COMPLEX*16 ASB1(MBS,NUMO*NUMO*NUMV,2),ASB2(MBS,NUMO*NUMO*NUMV,2)
      COMPLEX*16 RASB((NUMO+1)*NUMO*NUMV*NUMV/2)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      RCFILE = .FALSE.
C
C     WARNINGS BASED ON INVALID HMLT VS. G2INT COMBINATIONS
      IF(G2INT.EQ.'COULM') THEN
        IF(HMLT.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT2: HMLT = BARE but G2INT = COULM.'
          WRITE(7, *) 'In MBPT2: HMLT = BARE but G2INT = COULM.'
        ENDIF
      ELSEIF(G2INT.EQ.'BREIT') THEN
        IF(HMLT.EQ.'NORL') THEN
          WRITE(6, *) 'In MBPT2: HMLT = NORL but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLT = NORL but G2INT = BREIT.'
          RETURN
        ELSEIF(HMLT.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT2: HMLT = BARE but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLT = BARE but G2INT = BREIT.'
        ELSEIF(HMLT.EQ.'DHFR') THEN
          WRITE(6, *) 'In MBPT2: HMLT = DHFR but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLT = DHFR but G2INT = BREIT.'
        ELSEIF(HMLT.EQ.'DHFP') THEN
          WRITE(6, *) 'In MBPT2: HMLT = DHFP but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLT = DHFP but G2INT = BREIT.'
        ENDIF
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 1
          ITSTOP = 1
          ITSKIP = 1
        ENDIF
      ELSE
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 4
          ITSTOP = 1
          ITSKIP =-3
        ELSEIF(G2INT.EQ.'BREIT') THEN
          ITSTRT = 2
          ITSTOP = 3
          ITSKIP = 1        
        ENDIF
      ENDIF
C
C     INITIALISE TIME COUNTERS
      TERI = 0.0D0
      TCN1 = 0.0D0
      TCN2 = 0.0D0
      TCN3 = 0.0D0
      TCN4 = 0.0D0
      TSUM = 0.0D0
C
      CALL CPU_TIME(TBEG)
C
C     IMPORT MBPT1 PAIR RESULTS FOR E1(ab)
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT1.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NUMO
        DO IOCCB=1,NUMO
          READ(8, *) Q1,Q2,Q3,(EAB2(IOCCA,IOCCB,N),N=1,3)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C     CLEAR THE REMAINDER OF THE CORRELATION PAIR ENERGY VALUES
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
          DO N=4,6
            EAB2(IOCCA,IOCCB,N) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     CLEAR THE ARRAY FOR (AR|BS) VALUES
      M = 0
      DO IVRTR=1,NUMV
        DO IOCCA=1,NUMO
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
              M = M+1
              RASB(M) = DCMPLX(0.0D0,0.0D0)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS TT(AB) (USE INDEX 1000)       C
C**********************************************************************C
C
C     COMPONENT LABEL FOR A AND B: TT = LL(1) or SS(4) <- COULOMB
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 1000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(ITN(1).EQ.1) THEN
          NADDA = 0
          NADDB = 0
        ELSEIF(ITN(1).EQ.2) THEN
          NADDA = 0
          NADDB = NSKP
        ELSEIF(ITN(1).EQ.3) THEN
          NADDA = NSKP
          NADDB = 0
        ELSEIF(ITN(1).EQ.4) THEN
          NADDA = NSKP
          NADDB = NSKP
        ENDIF
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF A (USE INDEX 2000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     INDEX ASSIGNMENT
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON A
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDA
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDA
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF B (USE INDEX 3000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE B
      DO 3000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(B) VALUES
      DO 3000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1, NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     INDEX ASSIGNMENT
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON B
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDB
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSL = IADISL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
      IEAB = 1
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      IF(G2INT.EQ.'COULM') THEN
        PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
        PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      ELSEIF(G2INT.EQ.'BREIT') THEN
        PAB1 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
        PAB2 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      ENDIF
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(G2INT.EQ.'COULM') THEN
        IF(IQ1.LT.IQ2) GOTO 3001
      ENDIF
C
C     CLEAR ARRAY FOR SECOND CONTRACTION (KL->SB)
      DO MSB=1,NUMO*NUMV
        DO MIJ=1,NBAS(1)*NBAS(2)
          DO IJSPIN=1,4
            SB(MIJ,MSB,IJSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) (INDEX 4000)               C
C**********************************************************************C
C
      DO 4000 IBAS=1,NBAS(1)
      DO 4000 JBAS=1,NBAS(2)
C
C     LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
      MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS TT(CD) (USE INDEX 5000)       C
C**********************************************************************C
C
C     COMPONENT LABEL FOR C AND D: TT = LL(1) or SS(4) <- COULOMB
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 5000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(ITN(2).EQ.1) THEN
          NADDC = 0
          NADDD = 0
        ELSEIF(ITN(2).EQ.2) THEN
          NADDC = 0
          NADDD = NSKP
        ELSEIF(ITN(2).EQ.3) THEN
          NADDC = NSKP
          NADDD = 0
        ELSEIF(ITN(2).EQ.4) THEN
          NADDC = NSKP
          NADDD = NSKP
        ENDIF
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF C (USE INDEX 6000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE C
      DO 6000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER KQN(C) VALUES
      DO 6000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER |MQN(C)| VALUES
      DO 6000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     INDEX ASSIGNMENT
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON C
      NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDC
      NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDC
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (L->B)
      DO MKB=1,NBAS(3)*NUMO
        DO IJKSPIN=1,8
          B(MKB,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF D (USE INDEX 7000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE D
      DO 7000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     LOOP OVER KQN(D) VALUES
      DO 7000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C     LOOP OVER |MQN(D)| VALUES
      DO 7000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     INDEX ASSIGNMENT
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON D
      ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDD
      ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDD
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSL = IADISL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C     FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
      IECD = 1
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      IF(G2INT.EQ.'COULM') THEN
        PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
        PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
      ELSEIF(G2INT.EQ.'BREIT') THEN
        PCD1 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
        PCD2 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
      ENDIF
C
C**********************************************************************C
C     ALL LOOPS NOW COMPLETE -- GENERATE BATCH OF ERIs AND CONTRACT    C
C**********************************************************************C
C
C     RESET SCREENING COUNTERS
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
      ENDDO
C
C     OVERRIDE GAUNT REPLACEMENT TOGGLE
      MGNT = 0
C
C     BATCH OF ELECTRON INTERACTION INTEGRALS (IJ|KL) FOR FIXED (IJ)
      CALL CPU_TIME(T1)
      IF(G2INT.EQ.'COULM') THEN
        CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
      ELSEIF(G2INT.EQ.'BREIT') THEN
        CALL BII(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN,MGNT)
      ENDIF
      CALL CPU_TIME(T2)
      TERI = TERI + T2 - T1
C
C**********************************************************************C
C     FIRST CONTRACTION:                                               C
C     (IJ;T|KL;T') -> (IJ;T|KB;T')                                     C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FIRST CONTRACTION (NORMAL): (IJ;T|KL;T') -> (IJ;T|KB;T')
C
C     LOOP OVER OCCUPIED STATES IOCCB
      DO IOCCB=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCB
        IB = MINO-1+IOCCB+NSKP
C
C       LOOP OVER ALL KBAS IN BLOCK C
        DO KBAS=1,NBAS(3)
C
C         LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
          MKB = (KBAS-1)*NUMO + IOCCB
C
C         CONTRACT OVER ALL LBAS IN BLOCK D
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|-B) = (--|--) + (--|-+)
            B(MKB,1) = B(MKB,1) + RR(M, 1)*COEF(ND1+LBAS,IB)
     &                          + RR(M, 2)*COEF(ND2+LBAS,IB)
C
C           (--|+B) = (--|+-) + (--|++)
            B(MKB,2) = B(MKB,2) + RR(M, 3)*COEF(ND1+LBAS,IB)
     &                          + RR(M, 4)*COEF(ND2+LBAS,IB)
C
C           (-+|-B) = (-+|--) + (-+|-+)
            B(MKB,3) = B(MKB,3) + RR(M, 5)*COEF(ND1+LBAS,IB)
     &                          + RR(M, 6)*COEF(ND2+LBAS,IB)
C
C           (-+|+B) = (-+|+-) + (-+|++)
            B(MKB,4) = B(MKB,4) + RR(M, 7)*COEF(ND1+LBAS,IB)
     &                          + RR(M, 8)*COEF(ND2+LBAS,IB)
C
C           (+-|-B) = (+-|--) + (+-|-+)
            B(MKB,5) = B(MKB,5) + RR(M, 9)*COEF(ND1+LBAS,IB)
     &                          + RR(M,10)*COEF(ND2+LBAS,IB)
C
C           (+-|+B) = (+-|+-) + (+-|++)
            B(MKB,6) = B(MKB,6) + RR(M,11)*COEF(ND1+LBAS,IB)
     &                          + RR(M,12)*COEF(ND2+LBAS,IB)
C
C           (++|-B) = (++|--) + (++|-+)
            B(MKB,7) = B(MKB,7) + RR(M,13)*COEF(ND1+LBAS,IB)
     &                          + RR(M,14)*COEF(ND2+LBAS,IB)
C
C           (++|+B) = (++|+-) + (++|++)
            B(MKB,8) = B(MKB,8) + RR(M,15)*COEF(ND1+LBAS,IB)
     &                          + RR(M,16)*COEF(ND2+LBAS,IB)
C
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TCN1 = TCN1 + T2 - T1
C
C     FIRST CONTRACTION COMPLETE FOR THIS D BLOCK
7000  CONTINUE
C
C**********************************************************************C
C     SECOND CONTRACTION:                                              C
C     (IJ;T|KB;T') -> (IJ;T|SB)                                        C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     SECOND CONTRACTION (NORMAL): (IJ;T|KB;T') -> (IJ;T|SB;T')
C
C     LOOP OVER VIRTUAL STATES IVRTS
      DO IVRTS=1,NUMV
C
C       FOCK MATRIX ADDRESS FOR IVRTS
        IS = MINV-1+IVRTS+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCB
        DO IOCCB=1,NUMO
C
C         LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION IN B1
          MSB = (IOCCB-1)*NUMV + IVRTS
C
C         CONTRACT OVER ALL KBAS IN BLOCK C
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
            MKB = (KBAS-1)*NUMO + IOCCB
C
C           (--|SB) = (--|-B) + (--|+B)
            SB(MIJ,MSB,1) = SB(MIJ,MSB,1)
     &                             + B(MKB,1)*DCONJG(COEF(NC1+KBAS,IS))
     &                             + B(MKB,2)*DCONJG(COEF(NC2+KBAS,IS))
C
C           (-+|SB) = (-+|-B) + (-+|+B)
            SB(MIJ,MSB,2) = SB(MIJ,MSB,2)
     &                             + B(MKB,3)*DCONJG(COEF(NC1+KBAS,IS))
     &                             + B(MKB,4)*DCONJG(COEF(NC2+KBAS,IS))
C
C           (+-|SB) = (+-|-B) + (+-|+B)
            SB(MIJ,MSB,3) = SB(MIJ,MSB,3)
     &                             + B(MKB,5)*DCONJG(COEF(NC1+KBAS,IS))
     &                             + B(MKB,6)*DCONJG(COEF(NC2+KBAS,IS))
C
C           (++|SB) = (++|-B) + (++|+B)
            SB(MIJ,MSB,4) = SB(MIJ,MSB,4)
     &                             + B(MKB,7)*DCONJG(COEF(NC1+KBAS,IS))
     &                             + B(MKB,8)*DCONJG(COEF(NC2+KBAS,IS))
C
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TCN2 = TCN2 + T2 - T1
C
C     SECOND CONTRACTION COMPLETE FOR THIS C BLOCK AND T'T' OVERLAP
6000  CONTINUE
5000  CONTINUE
C
C     SECOND CONTRACTION COMPLETE FOR ALL (IBAS,JBAS)
4000  CONTINUE
C
C**********************************************************************C
C     THIRD CONTRACTION:                                               C
C     (IJ;T|SB) -> (IA;T|SB)  AND  (JI;T|SB) -> (JA;T|SB)              C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     THIRD CONTRACTION (DIRECT): (IJ;T|SB) -> (IA;T|SB)
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (DIRECT)
      DO MASB=1,NUMV*NUMO*NUMO
        DO IBAS=1,NBAS(1)
          DO ISPIN=1,2
            ASB1(IBAS,MASB,ISPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSKP
C
C       LOOP OVER VIRTUAL STATES IVRTS
        DO IVRTS=1,NUMV
C
C         LOOP OVER OCCUPIED STATES IOCCB
          DO IOCCB=1,IOCCA
C
C           LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
            MSB = (IOCCB-1)*NUMV+IVRTS
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
            MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C           CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-A|SB) = (--|SB) + (-+|SB)
                ASB1(IBAS,MASB,1) = ASB1(IBAS,MASB,1)
     &                           +      SB(MIJ,MSB,1)*COEF(NB1+JBAS,IA)
     &                           +      SB(MIJ,MSB,2)*COEF(NB2+JBAS,IA)
C
C               (+A|SB) = (+-|SB) + (++|SB)
                ASB1(IBAS,MASB,2) = ASB1(IBAS,MASB,2)
     &                           +      SB(MIJ,MSB,3)*COEF(NB1+JBAS,IA)
     &                           +      SB(MIJ,MSB,4)*COEF(NB2+JBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     THIRD CONTRACTION (SWAP): (JI;T|SB) -> (JA;T|SB)
      IF(G2INT.EQ.'COULM'.AND.IQ1.EQ.IQ2) GOTO 3002
      IF(G2INT.EQ.'BREIT') GOTO 3002
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (SWAP)
      DO MASB=1,NUMV*NUMO*NUMO
        DO JBAS=1,NBAS(2)
          DO JSPIN=1,2
            ASB2(JBAS,MASB,JSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSKP
C
C       LOOP OVER VIRTUAL STATES IVRTS
        DO IVRTS=1,NUMV
C
C         LOOP OVER OCCUPIED STATES IOCCB
          DO IOCCB=1,IOCCA
C
C           LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
            MSB = (IOCCB-1)*NUMV+IVRTS
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
            MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C           CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-A|SB)' = PAB1*(++|SB) + PAB2*(-+|SB)
                ASB2(JBAS,MASB,1) = ASB2(JBAS,MASB,1)
     &                   + PAB1*SB(MIJ,MSB,4)*DCMPLX(COEF(NA1+IBAS,IA))
     &                   + PAB2*SB(MIJ,MSB,2)*DCMPLX(COEF(NA2+IBAS,IA))
C
C               (+A|SB)' = PAB2*(+-|SB) + PAB1*(--|SB)
                ASB2(JBAS,MASB,2) = ASB2(JBAS,MASB,2)
     &                   + PAB2*SB(MIJ,MSB,3)*DCMPLX(COEF(NA1+IBAS,IA))
     &                   + PAB1*SB(MIJ,MSB,1)*DCMPLX(COEF(NA2+IBAS,IA))
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ1=IQ2
3002  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN3 = TCN3 + T2 - T1
C
C**********************************************************************C
C     FOURTH CONTRACTION:                      ~                       C
C     (IA;T|SB) -> (RA|SB)  AND  (JA;T|SB) -> (RA|SB)                  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOURTH CONTRACTION (DIRECT): (IA;T|SB) -> (RA|SB)
C
C     LOOP OVER VIRTUAL STATES IVRTR
      DO IVRTR=1,NUMV
C
C       FOCK MATRIX ADDRESS FOR IVRTR
        IR = MINV-1+IVRTR+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         LOOP OVER VIRTUAL STATES IVRTS
          DO IVRTS=1,NUMV
C
C           LOOP OVER OCCUPIED STATES IOCCB
            DO IOCCB=1,IOCCA
C
C             LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
              MSB = (IOCCB-1)*NUMV + IVRTS
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
              MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C             LIST ADDRESS FOR THIS IVRTR,IOCCA AND THE ABOVE MSB
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTR-1)*NUMV*IOCCA + MSB
C
C             CONTRACT OVER ALL IBAS IN BLOCK A
              DO IBAS=1,NBAS(1)
C
C               (RA|SB) = (-A|SB) + (+A|SB)
                RASB(MRASB) = RASB(MRASB)
     &                    + ASB1(IBAS,MASB,1)*DCONJG(COEF(NA1+IBAS,IR))
     &                    + ASB1(IBAS,MASB,2)*DCONJG(COEF(NA2+IBAS,IR))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C                                              ~
C     FOURTH CONTRACTION (SWAP): (JA;T|SB) -> (RA|SB)
      IF(G2INT.EQ.'COULM'.AND.IQ1.EQ.IQ2) GOTO 3003
      IF(G2INT.EQ.'BREIT') GOTO 3003
C
C     LOOP OVER VIRTUAL STATES IVRTR
      DO IVRTR=1,NUMV
C
C       FOCK MATRIX ADDRESS FOR IVRTR
        IR = MINV-1+IVRTR+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         LOOP OVER VIRTUAL STATES IVRTS
          DO IVRTS=1,NUMV
C
C           LOOP OVER OCCUPIED STATES IOCCB
            DO IOCCB=1,IOCCA
C
C             LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
              MSB = (IOCCB-1)*NUMV+IVRTS
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
              MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C             LIST ADDRESS FOR THIS IVRTR,IOCCA AND THE ABOVE MSB
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &                + (IVRTR-1)*NUMV*IOCCA + MSB
C
C             CONTRACT OVER ALL JBAS IN BLOCK B
              DO JBAS=1,NBAS(2)
C                ~
C               (RA|SB) = (-A|SB)' + (+A|SB)'
                RASB(MRASB) = RASB(MRASB)
     &                            + ASB2(JBAS,MASB,1)*COEF(NB1+JBAS,IR)
     &                            + ASB2(JBAS,MASB,2)*COEF(NB2+JBAS,IR)
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ1=IQ2
3003  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN4 = TCN4 + T2 - T1
C
C     SKIP POINT FOR IQ1.LT.IQ2
3001  CONTINUE
C
C     ALL CONTRIBUTIONS FROM THIS CLASS (A,B) BLOCK NOW ACCOUNTED FOR
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER PAIR CORRELATION ENERGY                   C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOR EACH IOCCA,IOCCB PAIR, SUM OVER IVRTR AND IVRTS CONTRIBUTIONS
C
C     LOOP OVER VIRTUAL STATES IVRTR
      DO IVRTR=1,NUMV
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         FOCK MATRIX ADDRESSES
          IA = MINO-1+IOCCA+NSKP
          IR = MINV-1+IVRTR+NSKP
C
C         LOOP OVER VIRTUAL STATES IVRTS
          DO IVRTS=1,NUMV
C
C           LOOP OVER OCCUPIED STATES IOCCB
            DO IOCCB=1,IOCCA
C
C             FOCK MATRIX ADDRESSES
              IB = MINO-1+IOCCB+NSKP
              IS = MINV-1+IVRTS+NSKP
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTR,IOCCB,IVRTS
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTR-1)*NUMV*IOCCA + (IOCCB-1)*NUMV + IVRTS
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTS,IOCCB,IVRTR
              MSARB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTS-1)*NUMV*IOCCA + (IOCCB-1)*NUMV + IVRTR
C
C             NUMERATOR FOR DIRECT AND EXCHANGE CONTRIBUTIONS
              RNUMD = DREAL(RASB(MRASB)*DCONJG(RASB(MRASB)))
              RNUMX =-DREAL(RASB(MRASB)*DCONJG(RASB(MSARB)))
C
C             DENOMINATOR FOR BOTH CONTRIBUTIONS
              EABRS = EIGN(IA) + EIGN(IB) - EIGN(IR) - EIGN(IS)
C
C             ADD TO DIRECT AND EXCHANGE BINS
              EAB2(IOCCA,IOCCB,4) = EAB2(IOCCA,IOCCB,4) + RNUMD/EABRS
              EAB2(IOCCA,IOCCB,5) = EAB2(IOCCA,IOCCB,5) + RNUMX/EABRS
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     FILL IN THE OTHER HALF OF THE ARRAY AND CALCULATE TOTALS
      E1S = 0.0D0
      E2D = 0.0D0
      E2X = 0.0D0
      E2S = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         INTERMEDIATE VALUES
          EAB1TOT = EAB2(IOCCA,IOCCB,3)
          EAB2DIR = EAB2(IOCCA,IOCCB,4)
          EAB2XCH = EAB2(IOCCA,IOCCB,5)
          EAB2SUM = EAB2DIR + EAB2XCH
C
C         PUT THESE INTO EAB2 AND ADD CONTRIBUTION TO E2
          EAB2(IOCCA,IOCCB,6) = EAB2SUM
          IF(IOCCA.NE.IOCCB) THEN
            EAB2(IOCCB,IOCCA,3) = EAB1TOT
            EAB2(IOCCB,IOCCA,4) = EAB2DIR
            EAB2(IOCCB,IOCCA,5) = EAB2XCH
            EAB2(IOCCB,IOCCA,6) = EAB2SUM
            E1S = E1S +       EAB1TOT
            E2D = E2D +       EAB2DIR
            E2X = E2X +       EAB2XCH
            E2S = E2S +       EAB2SUM
          ELSE
            E1S = E1S + 0.5D0*EAB1TOT
            E2D = E2D + 0.5D0*EAB2DIR
            E2X = E2X + 0.5D0*EAB2XCH
            E2S = E2S + 0.5D0*EAB2SUM
          ENDIF
        ENDDO
      ENDDO
C
C     WRITE RESULTS OF EAB ENERGIES TO AN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT2.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NOCC
        DO IOCCB=1,NOCC
          WRITE(8, *) (EAB2(IOCCA,IOCCB,N),N=1,6)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER SINGLE ORBITAL ENERGY                     C
C**********************************************************************C
C
C     FOR EACH IOCCA, SUM OVER THE IOCCB CONTRIBUTIONS
      DO IOCCA=1,NUMO
        DO N=1,6
          EA2(IOCCA,N) = 0.0D0
          DO IOCCB=1,NUMO
            EA2(IOCCA,N) = EA2(IOCCA,N) + EAB2(IOCCA,IOCCB,N)
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TSUM = TSUM + T2 - T1
C
C**********************************************************************C
C     TERMINAL OUTPUT SUMMARY                                          C
C**********************************************************************C
C
C     MBPT2 PAIRWISE SUMMARY
20    FORMAT(1X,A,9X,A,9X,A,9X,A,9X,A)
21    FORMAT(' (',I2,',',I2,')',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'MBPT2 pairwise summary'
      WRITE(7, *) REPEAT(' ',25),'MBPT2 pairwise summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) '( a, b)','E1G(ab)','E2J(ab)','E2K(ab)','E2G(ab)'
      WRITE(7,20) '( a, b)','E1G(ab)','E2J(ab)','E2K(ab)','E2G(ab)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        DO IOCCB=1,IOCCA
          IBNUM = IOCCB+MINO-1
          WRITE(6,21) IANUM,IBNUM,(EAB2(IOCCA,IOCCB,N),N=3,6)
          WRITE(7,21) IANUM,IBNUM,(EAB2(IOCCA,IOCCB,N),N=3,6)
        ENDDO
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 SINGLE-PARTICLE SUMMARY
30    FORMAT(1X,A,10X,A,10X,A,10X,A,10X,A)
31    FORMAT('  ',I2,'    ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',21),'MBPT2 single particle summary'
      WRITE(7, *) REPEAT(' ',21),'MBPT2 single particle summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) '  a    ','E1G(a)','E2J(a)','E2K(a)',' E2G(a)'
      WRITE(7,30) '  a    ','E1G(a)','E2J(a)','E2K(a)',' E2G(a)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        WRITE(6,31) IANUM,(EA2(IOCCA,N),N=3,6)
        WRITE(7,31) IANUM,(EA2(IOCCA,N),N=3,6)
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 TOTAL SECOND ORDER CORRELATION ENERGY
32    FORMAT(' total  ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',17),'MBPT2 second order correlation energy'
      WRITE(7, *) REPEAT(' ',17),'MBPT2 second order correlation energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,32) E1S,E2D,E2X,E2S
      WRITE(7,32) E1S,E2D,E2X,E2S
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 LABOUR ANALYSIS
      CALL CPU_TIME(TFIN)
      TTOT = TFIN - TBEG
      TOTH = TTOT - (TERI + TCN1 + TCN2 + TCN3 + TCN4 + TSUM)

40    FORMAT(1X,A,24X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',26),'MBPT2 labour analysis'
      WRITE(7, *) REPEAT(' ',26),'MBPT2 labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6,40) 'ERI construction - (IJ|KL)      ',HMS(TERI)
      WRITE(7,40) 'ERI construction - (IJ|KL)      ',HMS(TERI)
      WRITE(6,40) '1st contraction  - (IJ|KB)      ',HMS(TCN1)
      WRITE(7,40) '1st contraction  - (IJ|KB)      ',HMS(TCN1)
      WRITE(6,40) '2nd contraction  - (IJ|SB)      ',HMS(TCN2)
      WRITE(7,40) '2nd contraction  - (IJ|SB)      ',HMS(TCN2)
      WRITE(6,40) '3rd contraction  - (IA|SB)      ',HMS(TCN3)
      WRITE(7,40) '3rd contraction  - (IA|SB)      ',HMS(TCN3)
      WRITE(6,40) '4th contraction  - (RA|SB)      ',HMS(TCN4)
      WRITE(7,40) '4th contraction  - (RA|SB)      ',HMS(TCN4)
      WRITE(6,40) 'Virtual orbital sum - E2(A,B)   ',HMS(TSUM)
      WRITE(7,40) 'Virtual orbital sum - E2(A,B)   ',HMS(TSUM)
      WRITE(6,40) 'Other                           ',HMS(TOTH)
      WRITE(7,40) 'Other                           ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,40) 'Total MBPT2 time                ',HMS(TTOT)
      WRITE(7,40) 'Total MBPT2 time                ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [9] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] PT1BODY: MAIN ROUTINE FOR MOLECULAR EXPECTATION VALUES.        C
C   [B] PROPRTY: MOLECULAR EXPECTATION VALUE FROM DENSITY MATRIX.      C
C   [C] RSPT1: SET OF 1ST ORDER MOLECULAR MATRIX ELEMENTS AND E(2).    C
C   [D] DIAGRMTC: SET OF GOLDSTONE DIAGRAM CONTRIBUTIONS FOR ORBITAL.  C
C -------------------------------------------------------------------- C
C   [A] ATOMPOP: PROJECT SOLUTION ONTO ATOMIC DIRAC BASIS.             C
C   [B] MULLIKN: MULLIKEN POPULATION ANALYSIS ON CONVERGED SOLUTION.   C
C   [C] ORTHGNL: ORBITAL ORTHOGONALITY ANALYSIS.                       C
C   [D] SPINPRJ: SPIN-PROJECTION ANALYSIS FOR EACH SPINOR.             C
C   [E] ELCDIPL: PERMANENT ELECTRIC DIPOLE MOMENT ANALYSIS.            C
C   [F] ELCQDPL: PERMANENT ELECTRIC QUADRUPOLE MOMENT ANALYSIS.        C
C   [G] MAGDIPL: PERMANENT MAGNETIC DIPOLE MOMENT ANALYSIS.            C
C   [H] MAGQDPL: PERMANENT MAGNETIC QUADRUPOLE MOMENT ANALYSIS.        C
C   [I] STRKEFF: STARK EFFECT ANALYSIS, GIVEN ELECTRIC FIELD E.        C
C   [J] ZMANEFF: ZEEMAN EFFECT ANALYSIS, GIVEN MAGNETIC FIELD B.       C
C   [K] HYPFINE: HYPERFINE INTERACTION ANALYSIS, GIVEN NUCLEAR MOMENT. C
C   [L] NMRSHLD: MAGNETIC SHIELDING TENSOR FOR A CENTRE IN A MOLECULE. C
C   [M] GTENSOR: ELECTRONIC G-FACTOR FOR A MOLECULE.                   C
C   [N] EEDMSML: ATOM-CENTERED PT-ODD EDM OPERATOR (WITH E-FIELD).     C
C   [O] EEDMEFF: ONE-BODY EFFECTIVE PT-ODD EDM OPERATOR.               C
C   [P] ENHANFC: MOLECULAR EEDM ENHANCEMENT FACTOR CALCULATION.        C
C   [Q] SCLPTEN: SCALAR PT-ODD ELECTRON-NUCLEAR INTERACTION ANALYSIS.  C
C   [R] VECPTEN: VECTOR PT-ODD ELECTRON-NUCLEAR INTERACTION ANALYSIS.  C
C   [S] NUCMAGQ: NUCLEAR MAGNETIC QUADRUPOLE INTERACTION ANALYSIS.     C
C   [T] PVIOLTN: P-ODD EFFECTIVE OPERATOR ANALYSIS.                    C
C   [U] BETADCY: CORRECTIONS DUE TO THE NUCLEAR DECAY OF A CENTRE.     C
C   [V] NUCOLAP: GAUSSIAN NUCLEAR OVERLAP WITH ELECTRON CHARGE DENSITY.C
C   [W] COREPOL: APPLY CORE-POLARISATION CORRECTION TO AN OPERATOR.    C
C -------------------------------------------------------------------- C
C   [A] COREINT: COULOMB INTEGRAL MATRIX ELEMENTS FOR USE IN COREPOL.  C
C   [B] VMOMNT0: ZEROTH MOMENT INTEGRALS OVER σ_Q AND TT'.             C
C   [C] VMOMNT1: FIRST MOMENT INTEGRALS OVER σ_Q, TT' AND IX.          C
C   [D] VMOMNT2: SECOND MOMENT INTEGRALS OVER σ_Q, TT', IX AND JX.     C
C   [E] VMNPOLE: FIELD MONOPOLE INTEGRALS OVER σ_Q AND TT'.            C
C   [F] VDIPOLE: FIELD DIPOLE INTEGRALS OVER σ_Q, TT' AND IX.          C
C   [G] VSETGTN: MODIFIED FIELD DIPOLE INTEGRALS FOR GTENSOR ROUTINE.  C
C   [H] VQDPOLE: FIELD QUADRUPOLE INT'S OVER σ_Q, TT', IX AND IX'.     C
C   [I] VNCATRC: NUCLEAR ATTRACTION INTEGRALS.                         C
C   [J] VPTNCD1: FIRST DERIVATIVE OF POINT NUCLEAR INTEGRALS.          C
C   [K] VPTNCD2: SECOND DERIVATIVE OF POINT NUCLEAR INTEGRALS.         C
C   [L] VNCOLAP: NUCLEAR CHARGE INTEGRALS OVER σ_Q, TT' AND IZ.        C
C   [M] VKNETIC: RELATIVISTIC KINETIC OVERLAP INTEGRALS.               C
C   [N] VLPLACE: NON-RELATIVISTIC KINETIC INTEGRALS.                   C
C   [O] VPLNWAV: PLANE WAVE MATRIX ELEMENT INTEGRALS FOR WAVE VECTOR K.C
C**********************************************************************C
C
C
      SUBROUTINE PT1BODY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       PPPPPPP TTTTTTTT 11  BBBBBBB   OOOOOO  DDDDDDD  YY    YY       C
C       PP    PP   TT   111  BB    BB OO    OO DD    DD YY    YY       C
C       PP    PP   TT    11  BB    BB OO    OO DD    DD  YY  YY        C
C       PP    PP   TT    11  BBBBBBB  OO    OO DD    DD   YYYY         C
C       PPPPPPP    TT    11  BB    BB OO    OO DD    DD    YY          C
C       PP         TT    11  BB    BB OO    OO DD    DD    YY          C
C       PP         TT   1111 BBBBBBB   OOOOOO  DDDDDDD     YY          C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  PT1BODY CALCULATES MATRIX ELEMENTS AND ENERGY CORRECTIONS GIVEN A   C
C  HARTREE-FOCK CALCULATION AND SET OF COEFFICIENTS AND ENERGIES.      C
C -------------------------------------------------------------------- C
C  EQSAVE ONLY GENERATES ELL0, ESS0 AND MAYBE ELSI, AND IN GENERAL     C
C  THESE CALCULATIONS REQUIRE ETT'Q, SO GENERATE AS NEEDED INSTEAD.    C
C -------------------------------------------------------------------- C
C  BASIS OVERLAP MATRIX ELEMENTS AVAILABLE:                            C
C ▶(μ,T|σ_Q|ν,T')          - VMOMNT0(VIJ,IQ)      - ZEROTH MOMENT      C
C ▶(μ,T|σ_Q.x|ν,T')        - VMOMNT1(VIJ,IQ,IX)   - FIRST MOMENT       C
C ▶(μ,T|σ_Q.x.x'|ν,T')     - VMOMNT2(VIJ,IQ,IX,JX)- SECOND MOMENT      C
C ▶(μ,T|σ_Q.x/r^3|ν,T')    - VMNPOLE(VIJ,IQ,IX)   - FIELD MONOPOLE     C
C ▶(μ,T|σ_Q.x.y/r^3|ν,T')  - VDIPOLE(VIJ,IQ,IX'S) - FIELD DIPOLE       C
C ▶(μ,T|σ_Q.x.y.z/r^3|ν,T')- VQDPOLE(VIJ,IQ,IX'S) - FIELD QUADRUPOLE   C
C ▶(μ,T|σ_Q.V(nuc)|ν,T')   - VNCATRC(VIJ)         - NUCLEAR ATTRACTION C
C ▶(μ,T|σ_Q.∇x/r|ν,T')     - VPTNCD1(VIJ,IQ,IX)   - POINT NUCLEAR D1   C
C ▶(μ,T|σ_Q.∇x.∇y/r|ν,T')  - VPTNCD2(VIJ,IQ,IX,JX)- POINT NUCLEAR D2   C
C ▶(μ,T|σ_Q.ϱ(nuc)|ν,T')   - VNCOLAP(VIJ)         - NUCLEAR OVERLAP    C
C ▶(μ,T|σ_Q.p|ν,T')        - VKNETIC(VIJ)         - REL'VISTIC KINETIC C
C ▶(μ,T|σ_Q.∇^2|ν,T')      - VLPLACE(VIJ)         - NON-REL KINETIC    C
C ▶(μ,T|exp(ik.x)|ν,T')    - VPLNWAV(VIJ)         - PLANE WAVE         C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*7  HMINT(10)
      CHARACTER*16 HMS
C
      DIMENSION EFIELD(3),BFIELD(3),GAUGE(3),NEUT(MCT)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/PT1B/NHMINT,HMINT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TPRP/EMTY
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     EQ-COEFF AND R-INT TIME INITIALISATION
      TELL = 0.0D0
      TESS = 0.0D0
      TELS = 0.0D0
      TESL = 0.0D0
      TRLL = 0.0D0
      TRSS = 0.0D0
      TRLS = 0.0D0
      TRSL = 0.0D0
C
C     SPECIAL CASE FOR COREPOL: GENERATE FULL SET OF EQTT'
      DO N=1,NHMINT
        IF(EQFILE.AND.HMINT(N).EQ.'COREPOL') THEN
          CALL EQSAVE
        ENDIF
      ENDDO
C
C     IF READING IN PREVIOUS SOLUTION, CALCULATE MOLECULAR DENSITY
      IF(READIN) THEN
        WRITE(6, *) 'Spectrum generated by Hartree-Fock solution:'
        WRITE(7, *) 'Spectrum generated by Hartree-Fock solution:'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        CALL SPECTRM(NOCC,6)
        CALL DENSTY
      ENDIF
C
C     LOOP OVER ALL REQUESTED INTERACTION HAMILTONIANS
      DO N=1,NHMINT

C       PRINT A TITLE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) 'One-body H_{int} = ',HMINT(N)
        WRITE(7, *) 'One-body H_{int} = ',HMINT(N)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
        IF(HMINT(N).EQ.'ATOMPOP') THEN
C         NUMBER OF VIRTUAL ORBITALS TO INCLUDE IN LIST
          IVIR = 2
          CALL ATOMPOP(IVIR)
        ELSEIF(HMINT(N).EQ.'MULLIKN') THEN
C         NUMBER OF VIRTUAL ORBITALS TO INCLUDE IN LIST
          IVIR = 0
          ICKM = 2
          CALL MULLIKN(NOCC,IVIR,ICKM)
        ELSEIF(HMINT(N).EQ.'ORTHGNL') THEN
          CALL ORTHGNL
        ELSEIF(HMINT(N).EQ.'SPINPRJ') THEN
          CALL SPINPRJ
        ELSEIF(HMINT(N).EQ.'ELCDIPL') THEN
          CALL ELCDIPL
        ELSEIF(HMINT(N).EQ.'ELCQDPL') THEN
          CALL ELCQDPL
        ELSEIF(HMINT(N).EQ.'MAGDIPL') THEN
          CALL MAGDIPL
        ELSEIF(HMINT(N).EQ.'MAGQDPL') THEN
          CALL MAGQDPL
        ELSEIF(HMINT(N).EQ.'STRKEFF') THEN
C         UNIFORM ELECTRIC FIELD VECTOR
          EFIELD(1) = 0.0D0
          EFIELD(2) = 0.0D0
          EFIELD(3) = 1.0D0
C         GAUGE ORIGIN
          GAUGE(1) = 0.0D0
          GAUGE(2) = 0.0D0
          GAUGE(3) = 0.0D0
          CALL STRKEFF(EFIELD,GAUGE)
        ELSEIF(HMINT(N).EQ.'ZMANEFF') THEN
C         UNIFORM MAGNETIC FIELD VECTOR
          BFIELD(1) = 0.0D0
          BFIELD(2) = 0.0D0
          BFIELD(3) = 1.0D0
C         GAUGE ORIGIN
          GAUGE(1) = 0.0D0
          GAUGE(2) = 0.0D0
          GAUGE(3) = 0.0D0
          CALL ZMANEFF(BFIELD,GAUGE)
        ELSEIF(HMINT(N).EQ.'HYPFINE') THEN
C         CENTRE WITH NUCLEAR MAGENTIC MOMENT, 2*I AND DIPOLE MOMENT MU
          IZ   = 1
          ISPN = 1
          RNMU = 0.49367
          CALL HYPFINE(IZ,RNMU,ISPN)
C         IV = 79
C         CALL COREPOLHYP(IV,IZ,RNMU,ISPN)
        ELSEIF(HMINT(N).EQ.'NMRSHLD') THEN
C         GAUGE ORIGIN
          IZ       = 1
          GAUGE(1) = 0.0D0
          GAUGE(2) = 0.0D0
          GAUGE(3) = 0.0D0
          CALL NMRSHLD(IZ,GAUGE)
        ELSEIF(HMINT(N).EQ.'GTENSOR') THEN
          GAUGE(1) = 0.0D0
          GAUGE(2) = 0.0D0
          GAUGE(3) = 0.0D0
          CALL GTENSOR(GAUGE)
        ELSEIF(HMINT(N).EQ.'EEDMSML') THEN
C         NUCLEAR CENTRE WHOSE ELECTRIC FIELD IS TO BE INTEGRATED OVER
          IZ   = 1
          IOCC = 79
          CALL EEDMSML(IZ,IOCC)
        ELSEIF(HMINT(N).EQ.'EEDMEFF') THEN
          IOCC = 79
          CALL EEDMEFF(IOCC)
        ELSEIF(HMINT(N).EQ.'ENHANFC') THEN
C         NUMBER OF ORBITALS FROM VIRTUAL SPECTRUM (IN ORDER) TO INCLUDE
          IOCC = 11
          CALL ENHANFC(IOCC)
        ELSEIF(HMINT(N).EQ.'SCLPTEN') THEN
          IZ   = 1
          IOCC = 79
          CALL SCLPTEN(IZ,IOCC)
        ELSEIF(HMINT(N).EQ.'VECPTEN') THEN
C         NUCLEAR CENTRE WHOSE CURRENT DIST. IS TO BE INTEGRATED OVER
          IZ   = 1
          ISPN = 1
          IOCC = 79
          CALL VECPTEN(IZ,IOCC,ISPN)
        ELSEIF(HMINT(N).EQ.'NUCMAGQ') THEN
C         NUCLEAR CENTRE CONTAINING A VALENCE PROTON
          IZ   = 1
          ISPN = 5
          LPRT = 0
          IOCC = 79
          CALL NUCMAGQ(IZ,ISPN,LPRT,IOCC)
        ELSEIF(HMINT(N).EQ.'PVIOLTN') THEN
C         SPECIFY NUMBER OF NEUTRONS IN EACH ATOMIC CENTRE UP TO NCNT
c          NEUT(1) = 6
c          NEUT(2) = 45
c          NEUT(3) = 18
c          NEUT(4) = 10
c          NEUT(5) = 0
          CALL PVIOLTN(NEUT)
        ELSEIF(HMINT(N).EQ.'BETADCY') THEN
C         CENTRE UNDERGOING DECAY AND EMITTED CHARGE
          IZ   = 1
          ZDCY = 2.0D0
          CALL BETADCY(IZ,ZDCY)
        ELSEIF(HMINT(N).EQ.'NUCOLAP') THEN
C         CENTRE WHOSE DENSITY OVERLAP IS DESIRED
          IZ = 1
          CALL NUCOLAP(IZ)
        ELSEIF(HMINT(N).EQ.'COREPOL') THEN
          IV = 11
          CALL COREPOL(IV)
        ELSE
          WRITE(6, *) 'In PT1BODY: this operator is not available.'
          WRITE(7, *) 'In PT1BODY: this operator is not available.'
        ENDIF
C
C     END LOOP OVER INTERACTION HAMILTONIANS
      ENDDO
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TPRP)
      TPRP = TPRP-TDUM
C
20    FORMAT(1X,A,37X,A)
      IF(TELL.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in EMAKE (LL):',HMS(TELL)
        WRITE(7,20) 'Time in EMAKE (LL):',HMS(TELL)
      ENDIF
      IF(TELS.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in EMAKE (LS):',HMS(TELS)
        WRITE(7,20) 'Time in EMAKE (LS):',HMS(TELS)
      ENDIF
      IF(TESL.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in EMAKE (SL):',HMS(TESL)
        WRITE(7,20) 'Time in EMAKE (SL):',HMS(TESL)
      ENDIF
      IF(TESS.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in EMAKE (SS):',HMS(TESS)
        WRITE(7,20) 'Time in EMAKE (SS):',HMS(TESS)
      ENDIF
      IF(TRLL.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in RMAKE (LL):',HMS(TRLL)
        WRITE(7,20) 'Time in RMAKE (LL):',HMS(TRLL)
      ENDIF
      IF(TRLS.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in RMAKE (LS):',HMS(TRLS)
        WRITE(7,20) 'Time in RMAKE (LS):',HMS(TRLS)
      ENDIF
      IF(TRSL.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in RMAKE (SL):',HMS(TRSL)
        WRITE(7,20) 'Time in RMAKE (SL):',HMS(TRSL)
      ENDIF
      IF(TRSS.GT.1.0D-01) THEN
        WRITE(6,20) 'Time in RMAKE (SS):',HMS(TRSS)
        WRITE(7,20) 'Time in RMAKE (SS):',HMS(TRSS)
      ENDIF
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE PROPRTY(E1,BLL,BLS,BSL,BSS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP  RRRRRRR   OOOOOO  PPPPPPP  RRRRRRR TTTTTTTT YY    YY    C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT    YY    YY    C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT     YY  YY     C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT      YYYY      C
C     PPPPPPP  RRRRRRR  OO    OO PPPPPPP  RRRRRRR    TT       YY       C
C     PP       RR    RR OO    OO PP       RR    RR   TT       YY       C
C     PP       RR    RR  OOOOOO  PP       RR    RR   TT       YY       C
C                                                                      C
C -------------------------------------------------------------------- C
C  PROPRTY CALCULATES A MOLECULAR EXPECTATION VALUE OVER THE DENSITY   C
C  MATRIX AND BASIS PAIR INTEGRALS IN THE B MATRICES.                  C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C  ▶ E1: COMPLEX-VALUED MOLECULAR EXPECTATION VALUE RESULTS FOR EACH   C
C        COMPONENT TYPE OVERLAP ITT, WITH ITT=5 FOR TOTAL VALUE.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMPLEX*16 E1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 BLL(MDM,MDM),BSS(MDM,MDM),BLS(MDM,MDM),BSL(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/DENS/DENC,DENO,DENT
C
C     INITIALISE COUNTER ARRAYS FOR BASIS OVERLAP CONTRIBUTIONS
      DO ITT=1,4
        E1(ITT) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     LOOP OVER ALL BASIS FUNCTIONS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          E1(1) = E1(1) + BLL(I,J)*DENT(I     ,J     )
          IF(HMLT.EQ.'NORL') GOTO 100
          E1(2) = E1(2) + BLS(I,J)*DENT(I     ,J+NSKP)
          E1(3) = E1(3) + BSL(I,J)*DENT(I+NSKP,J     )
          E1(4) = E1(4) + BSS(I,J)*DENT(I+NSKP,J+NSKP)
100       CONTINUE
        ENDDO
      ENDDO
C
C     MOLECULAR EXPECTATION VALUE
      E1(5) = E1(1)+E1(2)+E1(3)+E1(4)
C
      RETURN
      END
C
C
      SUBROUTINE RSPT1(V1,BLL,BLS,BSL,BSS,NORD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                RRRRRRR   SSSSSS  PPPPPPP TTTTTTTT 11                 C
C                RR    RR SS    SS PP    PP   TT   111                 C
C                RR    RR SS       PP    PP   TT    11                 C
C                RR    RR  SSSSSS  PP    PP   TT    11                 C
C                RRRRRRR        SS PPPPPPP    TT    11                 C
C                RR    RR SS    SS PP         TT    11                 C
C                RR    RR  SSSSSS  PP         TT   1111                C
C                                                                      C
C -------------------------------------------------------------------- C
C  RSPT1 ASSEMBLES AN ARRAY OF MOLECULAR MATRIX ELEMENTS FROM BASIS    C
C  FUNCTION OVERLAPS IN BTT BY FIRST-ORDER RAYLEIGH-SCHRODINGER P.T.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ BTT  - ARRAY OF COMPONENT OVERLAPS FOR INTEGRALS OVER BASIS FNS.  C
C  ▶ NORD - MAXIMUM ORDER IN PERTURBATIVE EXPANSION TO FOLLOW.         C
C  OUTPUT:                                                             C
C  ▶ V1   - ARRAY OF MATRIX ELEMENTS FOR ZERO-ORDER SOLUTION.          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      COMPLEX*16 SUMLL,SUMSS,SUMLS,SUMSL,TMP
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 BLL(MDM,MDM),BSS(MDM,MDM),BLS(MDM,MDM),BSL(MDM,MDM)
      COMPLEX*16 V1(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGC/COEF
C
C     TOLERANCE VALUE FOR VANISHING MATRIX ELEMENTS
      TOL = 1.0D-10
C
C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
      DO IOCC=1,NDIM
        DO JOCC=1,NDIM
C
          IF(NORD.EQ.1.AND.IOCC.NE.JOCC) GOTO 150
C
C         INITIALISE COUNTER ARRAYS FOR BASIS OVERLAP CONTRIBUTIONS
          SUMLL = DCMPLX(0.0D0,0.0D0)
          SUMSS = DCMPLX(0.0D0,0.0D0)
          SUMLS = DCMPLX(0.0D0,0.0D0)
          SUMSL = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FOCK MATRIX ADDRESSES
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
C
              K = I+NSKP
              L = J+NSKP
C
C             LARGE AND SMALL CONTRIBUTIONS
              SUMLL = SUMLL + DCONJG(COEF(I,IOCC))*COEF(J,JOCC)*BLL(I,J)
              IF(HMLT.EQ.'NORL') GOTO 100
              SUMSS = SUMSS + DCONJG(COEF(K,IOCC))*COEF(L,JOCC)*BSS(I,J)
              SUMLS = SUMLS + DCONJG(COEF(I,IOCC))*COEF(L,JOCC)*BLS(I,J)
              SUMSL = SUMSL + DCONJG(COEF(K,IOCC))*COEF(J,JOCC)*BSL(I,J)
100           CONTINUE
C
            ENDDO
          ENDDO
C
C         SAVE SUMS TO MATRIX
          V1(IOCC,JOCC) = SUMLL + SUMSS + SUMLS + SUMSL
C
C         VANISHING MATRIX ELEMENTS
          TMP1 = DREAL(V1(IOCC,JOCC))
          TMP2 = DIMAG(V1(IOCC,JOCC))
          IF(DABS(TMP1).LT.TOL) THEN
            TMP1 = 0.0D0
          ENDIF
          IF(DABS(TMP2).LT.TOL) THEN
            TMP2 = 0.0D0
          ENDIF
          V1(IOCC,JOCC) = DCMPLX(TMP1,TMP2)
C
150       CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,IOCC,IWRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C DDDDDDD IIII    AA     GGGGGG  RRRRRRR  MM       MM TTTTTTTT CCCCCC  C
C DD    DD II    AAAA   GG    GG RR    RR MMM     MMM    TT   CC    CC C
C DD    DD II   AA  AA  GG       RR    RR MMMM   MMMM    TT   CC       C
C DD    DD II  AA    AA GG       RR    RR MM MM MM MM    TT   CC       C
C DD    DD II  AAAAAAAA GG   GGG RRRRRRR  MM  MMM  MM    TT   CC       C
C DD    DD II  AA    AA GG    GG RR    RR MM   M   MM    TT   CC    CC C
C DDDDDDD IIII AA    AA  GGGGGG  RR    RR MM       MM    TT    CCCCCC  C
C                                                                      C
C -------------------------------------------------------------------- C
C  DIAGRMTC CALCULATES ALL GOLDSTONE DIAGRAMS UP TO ORDER NORD ARISING C
C  FROM INTERACTION MATRIX V1 FOR AN OCCUPIED STATE IOCC, SEPARATING   C
C  RESULTS INTO POSITIVE/NEGATIVE ENERGY SPECTRUM CONTRIBUTIONS.       C
C -------------------------------------------------------------------- C
C  TODO: THIS DOES NOT COMPLEX CONJUGATE AT ALL AND COMPLEX GOES       C
C        TO DOUBLE. PROBABLY WON'T AFFECT ANYTHING BUT CHECK ANYWAY.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ V1   - ARRAY OF ALL MATRIX ELEMENTS BETWEEN SOLUTION STATES.      C
C  ▶ NORD - MAXIMUM ORDER TO BE CALCULATED IN PERTURBATIVE EXPANSION.  C
C  ▶ IOCC - SOLUTION STATE OF INTEREST.                                C
C  ▶ IWRT - PARAMETER THAT DETERMINES WHETHER TO WRITE RESULTS.        C
C  OUTPUT:                                                             C
C  ▶ EPOS - POSITIVE-ENERGY SPECTRUM COMPONENT OF GOLDSTONE DIAGRAMS.  C
C  ▶ ENEG - PART OF GOLDSTONE DIAGRAMS THAT INVOLVE NEGATIVE CONTRIB'N.C
C  ▶ ETOT - TOTAL GOLDSTONE DIAGRAM EXPECTATION VALUE -- SEE THE END   C
C           OF THIS SUBROUTINE FOR IDENTIFICATION OF DIAGRAMS (0:21).  C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 V2,V3P,V3H,V4PP,V4PH,V4HH,V4RR,V5PPP,V5PPH,V5C,V5PHH,
     &           V5A,V5B,V5D,V5HHH,V5E
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGE/E0(MDM)
C
C     INITIALISE ENERGY COUNTERS
      DO I=0,21
        EPOS(I) = 0.0D0
        ENEG(I) = 0.0D0
        ETOT(I) = 0.0D0
      ENDDO
C
C**********************************************************************C
C     E^(0) ZERO-ORDER CORRECTION                                      C
C**********************************************************************C
C
C     PERTURBATION ENERGY E^(0) -- DIRECTLY FROM EIGENVALUE PROBLEM
      ETOT(0) = E0(IOCC)
      EPOS(0) = E0(IOCC)
C
      IF(NORD.EQ.0) GOTO 100
C
C**********************************************************************C
C     E^(1) FIRST-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     PERTURBATION ENERGY E^(1) -- DIAGONAL ELEMENTS OF V1
      ETOT(1) = V1(IOCC,IOCC)
      EPOS(1) = V1(IOCC,IOCC)
C
      IF(NORD.EQ.1) GOTO 100
C
C**********************************************************************C
C     E^(2) SECOND-ORDER CORRECTION                                    C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 102
        IF(E0(IOCC).EQ.E0(JOCC)) GOTO 102
C
C       E^(2) SECOND-ORDER TOTAL
        V2 = V1(IOCC,JOCC)*V1(JOCC,IOCC)
        E2 = E0(IOCC)-E0(JOCC)
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(2) = ETOT(2) + V2/E2
C
        IF(JOCC.GT.NSKP) THEN
          EPOS(2) = EPOS(2) + V2/E2
        ENDIF
C
102     CONTINUE
C
      ENDDO
C
      IF(NORD.EQ.2) GOTO 100
C
C**********************************************************************C
C     E^(3) THIRD-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 103
        IF(E0(IOCC).EQ.E0(JOCC)) GOTO 103
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 203
          IF(E0(IOCC).EQ.E0(KOCC)) GOTO 203
C
C         E^(3) [P] THIRD-ORDER PAIR TERM
          V3P = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E3P = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(3) = ETOT(3) + V3P/E3P
C
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(3) = EPOS(3) + V3P/E3P
          ENDIF
C
203       CONTINUE
C          
        ENDDO
C       
C       E^(3) [H] THIRD-ORDER HOLE TERM
        V3H = (V1(IOCC,JOCC)**2)
        E3H = (E0(IOCC)-E0(JOCC))**2
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(4) = ETOT(4) - ETOT(1)*V3H/E3H
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(4) = EPOS(4) - EPOS(1)*V3H/E3H
        ENDIF
C
103     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(3)
      ETOT(5) = ETOT(3)+ETOT(4)
      EPOS(5) = EPOS(3)+EPOS(4)
C
      IF(NORD.EQ.3) GOTO 100
C
C**********************************************************************C
C     E^(4) FOURTH-ORDER CORRECTION                                    C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 104
        IF(E0(IOCC).EQ.E0(JOCC)) GOTO 104
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 204
          IF(E0(IOCC).EQ.E0(KOCC)) GOTO 204
C
C         LOOP OVER STATES
          DO LOCC=1,NDIM
C
C           SELF-ENERGIES NOT INCLUDED
            IF(IOCC.EQ.LOCC) GOTO 304
            IF(E0(IOCC).EQ.E0(LOCC)) GOTO 304
C
C           E^(4) [PP] FOURTH-ORDER PAIR-PAIR TERM
            V4PP = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,LOCC)
     &                                        *V1(LOCC,IOCC)
            E4PP = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &                                *(E0(IOCC)-E0(LOCC))
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(6) = ETOT(6) + V4PP/E4PP
C
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(6) = EPOS(6) + V4PP/E4PP
            ENDIF
C
304         CONTINUE
C
          ENDDO
C
C         E^(4) [PH] FOURTH-ORDER PAIR-HOLE TERM
          V4PH = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E4PH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(7) = ETOT(7) - 2.0D0*ETOT(1)*V4PH/E4PH
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(7) = EPOS(7) - 2.0D0*EPOS(1)*V4PH/E4PH
          ENDIF
C
204       CONTINUE
C          
        ENDDO
C       
C       E^(4) [HH] FOURTH-ORDER HOLE-HOLE TERM
        V4HH = V1(IOCC,JOCC)*V1(JOCC,IOCC)
        E4HH = (E0(IOCC)-E0(JOCC))**3
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(8) = ETOT(8) + (ETOT(1)**2)*V4HH/E4HH
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(8) = EPOS(8) + (EPOS(1)**2)*V4HH/E4HH
        ENDIF
C       
C       E^(4) [R1+R2] FOURTH-ORDER RESOLVANT-RESOLVANT TERM
        V4RR = V1(IOCC,JOCC)**2
        E4RR = (E0(IOCC)-E0(JOCC))**2
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(9) = ETOT(9) - ETOT(2)*V4RR/E4RR
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(9) = EPOS(9) - EPOS(2)*V4RR/E4RR
        ENDIF
C
104     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(4)
      ETOT(10) = ETOT(6)+ETOT(7)+ETOT(8)+ETOT(9)
      EPOS(10) = EPOS(6)+EPOS(7)+EPOS(8)+EPOS(9)
C
      IF(NORD.EQ.4) GOTO 100
C
C**********************************************************************C
C     E^(5) FIFTH-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 105
        IF(E0(IOCC).EQ.E0(JOCC)) GOTO 105
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 205
          IF(E0(IOCC).EQ.E0(KOCC)) GOTO 205
C
C         LOOP OVER STATES
          DO LOCC=1,NDIM
C
C           SELF-ENERGIES NOT INCLUDED
            IF(IOCC.EQ.LOCC) GOTO 305
            IF(E0(IOCC).EQ.E0(LOCC)) GOTO 305
C
C           LOOP OVER STATES
            DO MOCC=1,NDIM
C
C             SELF-ENERGIES NOT INCLUDED
              IF(IOCC.EQ.MOCC) GOTO 405
              IF(E0(IOCC).EQ.E0(MOCC)) GOTO 405
C
C             E^(5) [PPP] FIFTH-ORDER PAIR-PAIR-PAIR TERM
              V5PPP = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,LOCC)
     &                             *V1(LOCC,MOCC)*V1(MOCC,IOCC)
              E5PPP = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &               *(E0(IOCC)-E0(LOCC))*(E0(IOCC)-E0(MOCC))
C
C             CONTRIBUTIONS TO ENERGY TERM
              ETOT(11) = ETOT(11) + V5PPP/E5PPP
C
              IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP
     &                                        .AND.MOCC.GT.NSKP) THEN
                EPOS(11) = EPOS(11) + V5PPP/E5PPP
              ENDIF
C
405           CONTINUE
C
            ENDDO
C
C           E^(5) [PPH] FIFTH-ORDER PAIR-PAIR-HOLE TERM
            V5PPH = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,LOCC)
     &                                         *V1(LOCC,IOCC)
            E5PPH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(LOCC))
     &                                 *(E0(IOCC)-E0(JOCC))**2
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(12) = ETOT(12) - 3.0D0*ETOT(1)*V5PPH/E5PPH
C          
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(12) = EPOS(12) - 3.0D0*EPOS(1)*V5PPH/E5PPH
            ENDIF
C
C           E^(5) [??C] FIFTH-ORDER TERM
            V5C = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,LOCC)
     &                                      *(V1(LOCC,IOCC)**2)
            E5C = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &                               *(E0(IOCC)-E0(LOCC))**2
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(17) = ETOT(17) - V5C/E5C
C          
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(17) = EPOS(17) - V5C/E5C
            ENDIF
C
305         CONTINUE
C
          ENDDO
C
C         E^(5) [PHH] FIFTH-ORDER PAIR-HOLE-HOLE TERM
          V5PHH = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E5PHH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**3
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(13) = ETOT(13) + 2.0D0*(ETOT(1)**2)*V5PHH/E5PHH
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(13) = EPOS(13) + 2.0D0*(EPOS(1)**2)*V5PHH/E5PHH
          ENDIF
C       
C         E^(5) [??A] FIFTH-ORDER FIRST EXCHANGE TERM
          V5A = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E5A = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(15) = ETOT(15) - 2.0D0*ETOT(2)*V5A/E5A
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(15) = EPOS(15) - 2.0D0*EPOS(2)*V5A/E5A
          ENDIF
C       
C         E^(5) [??B] FIFTH-ORDER SECOND EXCHANGE TERM
          V5B = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E5B = ((E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC)))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(16) = ETOT(16) + (ETOT(1)**2)*V5B/E5B
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(16) = EPOS(16) + (EPOS(1)**2)*V5B/E5B
          ENDIF
C       
C         E^(5) [??D] FIFTH-ORDER TERM
          V5D = (V1(IOCC,JOCC)*V1(KOCC,IOCC))**2
          E5D = ((E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC)))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(18) = ETOT(18) - 2.0D0*ETOT(1)*V5D/E5D
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(18) = EPOS(18) - 2.0D0*EPOS(1)*V5D/E5D
          ENDIF
C
205       CONTINUE
C          
        ENDDO
C       
C       E^(5) [HHH] FIFTH-ORDER HOLE-HOLE-HOLE TERM
        V5HHH = V1(IOCC,JOCC)**2
        E5HHH = (E0(IOCC)-E0(JOCC))**4
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(14) = ETOT(14) - (ETOT(1)**3)*V5HHH/E5HHH
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(14) = EPOS(14) - (EPOS(1)**3)*V5HHH/E5HHH
        ENDIF
C       
C       E^(5) [??E] FIFTH-ORDER TERM
        V5E = V1(IOCC,JOCC)**2
        E5E = (E0(IOCC)-E0(JOCC))**3
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(19) = ETOT(19) - 4.0D0*ETOT(1)*ETOT(2)*V5E/E5E
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(19) = EPOS(19) - 4.0D0*EPOS(1)*EPOS(2)*V5E/E5E
        ENDIF
C
105     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(5)
      ETOT(20) = ETOT(11)+ETOT(12)+ETOT(13)+ETOT(14)+ETOT(15)
     &                   +ETOT(16)+ETOT(17)+ETOT(18)+ETOT(19)
      EPOS(20) = EPOS(11)+EPOS(12)+EPOS(13)+EPOS(14)+EPOS(15)
     &                   +EPOS(16)+EPOS(17)+EPOS(18)+EPOS(19)
C
      IF(NORD.EQ.5) GOTO 100
C
C**********************************************************************C
C     END OF CORRECTION CALCULATION                                    C
C**********************************************************************C
C
100   CONTINUE
C
C     ADD TOTAL ENERGIES TO THE FINAL ENTRY
      EPOS(21) = EPOS(0)+EPOS(1)+EPOS(2)+EPOS(5)+EPOS(10)+EPOS(20)
      ETOT(21) = ETOT(0)+ETOT(1)+ETOT(2)+ETOT(5)+ETOT(10)+ETOT(20)
C
C     NEGATIVE-ENERGY CONTRIBUTIONS ARE SIMPLY A DIFFERENCE
      DO I=0,21
        ENEG(I) = ETOT(I)-EPOS(I)
      ENDDO
C
C**********************************************************************C
C     WRITE RESULTS                                                    C
C**********************************************************************C
C
      IF(IWRT.EQ.0) GOTO 70
C
41    FORMAT(1X,A,15X,A,14X,A,14X,A)
42    FORMAT(1X,A,3X,F18.12,2X,F18.12,2X,F18.12)
      WRITE(6,41) 'E^(N)     |','E[pos]','E[neg]','E[tot]'
      WRITE(7,41) 'E^(N)     |','E[pos]','E[neg]','E[tot]'
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      WRITE(7,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      IF(NORD.EQ.0) GOTO 50
      WRITE(6,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      WRITE(7,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      IF(NORD.EQ.1) GOTO 50
      WRITE(6,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      WRITE(7,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      IF(NORD.EQ.2) GOTO 50
      WRITE(6,42) 'E^(3)[P]  |',EPOS( 3),ENEG( 3),ETOT( 3)
      WRITE(7,42) 'E^(3)[P]  |',EPOS( 3),ENEG( 3),ETOT( 3)
      WRITE(6,42) 'E^(3)[H]  |',EPOS( 4),ENEG( 4),ETOT( 4)
      WRITE(7,42) 'E^(3)[H]  |',EPOS( 4),ENEG( 4),ETOT( 4)
      IF(NORD.EQ.3) GOTO 50
      WRITE(6,42) 'E^(4)[PP] |',EPOS( 6),ENEG( 6),ETOT( 6)
      WRITE(7,42) 'E^(4)[PP] |',EPOS( 6),ENEG( 6),ETOT( 6)
      WRITE(6,42) 'E^(4)[PH] |',EPOS( 7),ENEG( 7),ETOT( 7)
      WRITE(7,42) 'E^(4)[PH] |',EPOS( 7),ENEG( 7),ETOT( 7)
      WRITE(6,42) 'E^(4)[HH] |',EPOS( 8),ENEG( 8),ETOT( 8)
      WRITE(7,42) 'E^(4)[HH] |',EPOS( 8),ENEG( 8),ETOT( 8)
      WRITE(6,42) 'E^(4)[RR] |',EPOS( 9),ENEG( 9),ETOT( 9)
      WRITE(7,42) 'E^(4)[RR] |',EPOS( 9),ENEG( 9),ETOT( 9)
      IF(NORD.EQ.4) GOTO 50
      WRITE(6,42) 'E^(5)[PPP]|',EPOS(11),ENEG(11),ETOT(11)
      WRITE(7,42) 'E^(5)[PPP]|',EPOS(11),ENEG(11),ETOT(11)
      WRITE(6,42) 'E^(5)[PPH]|',EPOS(12),ENEG(12),ETOT(12)
      WRITE(7,42) 'E^(5)[PPH]|',EPOS(12),ENEG(12),ETOT(12)
      WRITE(6,42) 'E^(5)[PHH]|',EPOS(13),ENEG(13),ETOT(13)
      WRITE(7,42) 'E^(5)[PHH]|',EPOS(13),ENEG(13),ETOT(13)
      WRITE(6,42) 'E^(5)[HHH]|',EPOS(14),ENEG(14),ETOT(14)
      WRITE(7,42) 'E^(5)[HHH]|',EPOS(14),ENEG(14),ETOT(14)
      WRITE(6,42) 'E^(5)[??A]|',EPOS(15),ENEG(15),ETOT(15)
      WRITE(7,42) 'E^(5)[??A]|',EPOS(15),ENEG(15),ETOT(15)
      WRITE(6,42) 'E^(5)[??B]|',EPOS(16),ENEG(16),ETOT(16)
      WRITE(7,42) 'E^(5)[??B]|',EPOS(16),ENEG(16),ETOT(16)
      WRITE(6,42) 'E^(5)[??C]|',EPOS(17),ENEG(17),ETOT(17)
      WRITE(7,42) 'E^(5)[??C]|',EPOS(17),ENEG(17),ETOT(17)
      WRITE(6,42) 'E^(5)[??D]|',EPOS(18),ENEG(18),ETOT(18)
      WRITE(7,42) 'E^(5)[??D]|',EPOS(18),ENEG(18),ETOT(18)
      WRITE(6,42) 'E^(5)[??E]|',EPOS(19),ENEG(19),ETOT(19)
      WRITE(7,42) 'E^(5)[??E]|',EPOS(19),ENEG(19),ETOT(19)
      IF(NORD.EQ.5) GOTO 50
50    CONTINUE
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      WRITE(7,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      IF(NORD.EQ.0) GOTO 60
      WRITE(6,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      WRITE(7,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      IF(NORD.EQ.1) GOTO 60
      WRITE(6,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      WRITE(7,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      IF(NORD.EQ.2) GOTO 60
      WRITE(6,42) 'E^(3)     |',EPOS( 5),ENEG( 5),ETOT( 5)
      WRITE(7,42) 'E^(3)     |',EPOS( 5),ENEG( 5),ETOT( 5)
      IF(NORD.EQ.3) GOTO 60
      WRITE(6,42) 'E^(4)     |',EPOS(10),ENEG(10),ETOT(10)
      WRITE(7,42) 'E^(4)     |',EPOS(10),ENEG(10),ETOT(10)
      IF(NORD.EQ.4) GOTO 60
      WRITE(6,42) 'E^(5)     |',EPOS(20),ENEG(20),ETOT(20)
      WRITE(7,42) 'E^(5)     |',EPOS(20),ENEG(20),ETOT(20)
      IF(NORD.EQ.5) GOTO 60
60    CONTINUE
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'Energy    |',EPOS(21),ENEG(21),ETOT(21)
      WRITE(7,42) 'Energy    |',EPOS(21),ENEG(21),ETOT(21)
C
70    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ATOMPOP(IVIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      AA   TTTTTTTT OOOOOO  MM       MM PPPPPPP   OOOOOO  PPPPPPP     C
C     AAAA     TT   OO    OO MMM     MMM PP    PP OO    OO PP    PP    C
C    AA  AA    TT   OO    OO MMMM   MMMM PP    PP OO    OO PP    PP    C
C   AA    AA   TT   OO    OO MM MM MM MM PP    PP OO    OO PP    PP    C
C   AAAAAAAA   TT   OO    OO MM  MMM  MM PPPPPPP  OO    OO PPPPPPP     C
C   AA    AA   TT   OO    OO MM   M   MM PP       OO    OO PP          C
C   AA    AA   TT    OOOOOO  MM       MM PP        OOOOOO  PP          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ATOMPOP PROJECTS ALL OCCUPIED (AND SOME VIRTUAL) LCAO EXPANSIONS    C
C  INTO THE BASIS OF DIRAC ORBITALS ABOUT EACH ATOMIC CENTRE. THIS     C
C  INVOLVES POSITIVE CONTRIBUTIONS ABOUT EACH CENTRE, AND AN ACCOUNT   C
C  OF 'POLARIZATION' TERMS THAT ARE TWO-CENTRE IN ORIGIN.              C
C -------------------------------------------------------------------- C
C  NOTE THAT INDIVIDUAL RESULTS CAN BE GREATER THAN UNITY, BECAUSE     C
C  POLARISATION CONTRIBUTIONS CAN BE NEGATIVE.                         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE IN LIST.             C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*2 ELMT(120),ELA
      CHARACTER*5 NMDL
C
      DIMENSION FRC(MDM,MCT,MKP,(MKP+1)/2,3)
      DIMENSION BRD(MDM,3),TOT(MDM,3),RHO(MCT,3)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/MDLV/ELMT
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
C
C     INITIALISE COUNTER MATRICES
      DO IOCC=1,NOCC+IVIR
        DO IZ=1,NCNT
          DO IKAP=1,NKAP(IZ)
            IKQN = KAPA(IKAP,IZ)
            NMV  = IABS(IKQN)
            DO IMV=1,NMV
              DO IT=1,3
                FRC(IOCC,IZ,IKAP,IMV,IT) = 0.0D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO IT=1,3
          BRD(IOCC,IT) = 0.0D0
          TOT(IOCC,IT) = 0.0D0
        ENDDO
      ENDDO
      DO IZ=1,NCNT
        DO IT=1,3
          RHO(IZ,IT) = 0.0D0
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRICES (ZEROTH MOMENT)
      CALL VMOMNT0(OLAPLL,1,0,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT0(OLAPSS,4,0,1,2)
      ENDIF
C
C     LOOP OVER OCCUPIED ORBITALS
      DO IOCC=1,NOCC+IVIR
C
C       IGNORE NEGATIVE SPECTRUM
        MOCC = IOCC+NSKP
C
C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
        DO I=1,NDIM-NSKP
          K    = I+NSKP
          ICNT = LABICN(I)
          IKQN = LABKQN(I)
          IMQN = IABS(LABMQN(I))
          IF(IKQN.LT.0) THEN
            IKAP =-2*IKQN-1
          ELSE
            IKAP = 2*IKQN
          ENDIF
          IMV = (IMQN+1)/2
          DO J=1,NDIM-NSKP
            L    = J+NSKP
            JCNT = LABICN(J)
            JKQN = LABKQN(J)
            JMQN = IABS(LABMQN(J))
C
C           LARGE AND SMALL CONTRIBUTIONS
            EL = DREAL(DCONJG(COEF(I,MOCC))*COEF(J,MOCC)*OLAPLL(I,J))
            IF(HMLT.NE.'NORL') THEN
              ES = DREAL(DCONJG(COEF(K,MOCC))*COEF(L,MOCC)*OLAPSS(I,J))
            ELSE
              ES = 0.0D0
            ENDIF
C
C           UPDATE CHARGE ON CENTRE ICNT (OCCUPIED ORBITALS ONLY)
            IF(IOCC.LE.NOCC) THEN
              RHO(ICNT,1) = RHO(ICNT,1) + EL
              RHO(ICNT,2) = RHO(ICNT,2) + ES
              RHO(ICNT,3) = RHO(ICNT,3) + EL + ES
            ENDIF

C           DECIDE WHERE TO PUT CONTRIBUTION
            IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
              FRC(IOCC,ICNT,IKAP,IMV,1) = FRC(IOCC,ICNT,IKAP,IMV,1)+EL
              FRC(IOCC,ICNT,IKAP,IMV,2) = FRC(IOCC,ICNT,IKAP,IMV,2)+ES
              FRC(IOCC,ICNT,IKAP,IMV,3) = FRC(IOCC,ICNT,IKAP,IMV,1)
     &                                  + FRC(IOCC,ICNT,IKAP,IMV,2)
            ELSE
              BRD(IOCC,1) = BRD(IOCC,1) + EL
              BRD(IOCC,2) = BRD(IOCC,2) + ES
              BRD(IOCC,3) = BRD(IOCC,3) + EL + ES
            ENDIF
C
          ENDDO
C
        ENDDO
C
C       TOTAL OCCUPANCIES
        DO ICNT=1,NCNT
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            NMV  = IABS(IKQN)
            DO IMV=1,NMV
              TOT(IOCC,1) = TOT(IOCC,1) + FRC(IOCC,ICNT,IKAP,IMV,1)
              TOT(IOCC,2) = TOT(IOCC,2) + FRC(IOCC,ICNT,IKAP,IMV,2)
              TOT(IOCC,3) = TOT(IOCC,3) + FRC(IOCC,ICNT,IKAP,IMV,3)
            ENDDO
          ENDDO
        ENDDO
        TOT(IOCC,1) = TOT(IOCC,1) + BRD(IOCC,1)
        TOT(IOCC,2) = TOT(IOCC,2) + BRD(IOCC,2)
        TOT(IOCC,3) = TOT(IOCC,3) + BRD(IOCC,3)
C
C     END LOOP OVER OCCUPIED ORBITALS
      ENDDO
C
C     RESULTS: CHARGES ON EACH CENTRE
20    FORMAT(1X,'Total charge on centre ',I2,' = ',F15.10)
21    FORMAT(1X,'Total charge on molecule  = ',F15.10)
      WRITE(6, *) 'Mulliken population analysis:'
      WRITE(7, *) 'Mulliken population analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      SUM = 0.0D0
      DO ICNT=1,NCNT
        WRITE(6,20) ICNT,ZNUC(ICNT)-RHO(ICNT,3)
        WRITE(7,20) ICNT,ZNUC(ICNT)-RHO(ICNT,3)
        SUM = SUM + ZNUC(ICNT)-RHO(ICNT,3)
      ENDDO
      WRITE(6,21) SUM
      WRITE(7,21) SUM
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     RESULTS: DIRAC BASIS DECOMPOSITION FOR EACH ORBITAL
22    FORMAT(' Orb.',2X,'Cent.',2X,'KQN',3X,'|MQN|',10X,
     &                                   'Q(L)',13X,'Q(S)',11X,'Q(TOT)')
23    FORMAT(1X,I3,2X,I2,'(',A,')',3X,I2,3X,I2,'/2',4X,F11.8,6X,
     &                                                   F11.8,6X,F11.8)
24    FORMAT(1X,I3,3X,I2,'(',A,')',2X,I2,3X,I2,'/2',4X,F11.8,6X,
     &                                                   F11.8,6X,F11.8)
25    FORMAT(1X,I3,3X,A ,15X,F11.8,6X,F11.8,6X,F11.8)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6,22)
      WRITE(7,22)
      DO IOCC=1,NOCC+IVIR
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        IF(IOCC.EQ.NOCC+1) THEN
          WRITE(6, *) 'Virtual orbitals (not actually occupied):'
          WRITE(7, *) 'Virtual orbitals (not actually occupied):'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF
        DO ICNT=1,NCNT
          ELA = ELMT(INT(ZNUC(ICNT)))
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            NMV  = IABS(IKQN)
            DO IMV=1,NMV
              IF(FRC(IOCC,ICNT,IKAP,IMV,3).GT.1.0D-9) THEN
                IF(NCNT.LT.10) THEN
                  WRITE(6,23) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                  WRITE(7,23) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                ELSE
                  WRITE(6,24) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                  WRITE(7,24) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                ENDIF
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        WRITE(6,25) IOCC,'Polar.',(BRD(IOCC,IT),IT=1,3)
        WRITE(7,25) IOCC,'Polar.',(BRD(IOCC,IT),IT=1,3)
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,25) IOCC,'Total ',(TOT(IOCC,IT),IT=1,3)
        WRITE(7,25) IOCC,'Total ',(TOT(IOCC,IT),IT=1,3)
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE MULLIKN(NUMO,NUMV,ICKM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM UU    UU LL       LL       IIII KK    KK NN    NN    C
C     MMM     MMM UU    UU LL       LL        II  KK   KK  NNN   NN    C
C     MMMM   MMMM UU    UU LL       LL        II  KK  KK   NNNN  NN    C
C     MM MM MM MM UU    UU LL       LL        II  KKKKK    NN NN NN    C
C     MM  MMM  MM UU    UU LL       LL        II  KK  KK   NN  NNNN    C
C     MM   M   MM UU    UU LL       LL        II  KK   KK  NN   NNN    C
C     MM       MM  UUUUUU  LLLLLLLL LLLLLLLL IIII KK    KK NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  MULLIKN CALCULATES A MULLIKEN POPULATION ANALYSIS ON A DIATOMIC     C
C  SYSTEM, AS DESCRIBED IN:                                            C
C  (*) J.Chem.Phys., 23: 1833, 1841, 2338, 2343 (1955).                C
C  (*) J.Chem.Phys., 36: 3428 (1962).                                  C
C -------------------------------------------------------------------- C
C  FOUR LEVELS OF SUMMARY ARE PRINTED TO THE TERMINAL:                 C
C   ▶ OVERLAP DECOMPOSITION (BY ORBITAL AND FOR WHOLE MOLECULE).       C
C   ▶ GROSS CHARGES (BY ORBITAL AND FOR WHOLE MOLECULE).               C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ NUMO - NUMBER OF OCCUPIED ORBITALS TO ACCOUNT FOR (USUALLY NOCC)  C
C  ▶ NUMV - NUMBER OF VIRTUAL ORBITALS (CHOOSE ZERO OR A SMALL NUMBER) C
C  ▶ ICKM - 1 FOR (CKM), 2 FOR (CK), 3 FOR (C).                        C
C -------------------------------------------------------------------- C
C TODO: CAN REPLACE "OVRLAP" WITH ANY OTHER TYPE OF MATRIX ELEMENT     C
C       TO GET A DECOMPOSITION OF CONTRIBUTIONS.                       C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*2  ELMT(120),KLAB
      CHARACTER*3  IORB
      CHARACTER*5  NMDL,MLAB
      CHARACTER*14 CEKM1,CEKM2
C
      DIMENSION IKM(-MEL:MEL,-MKP:MKP)
      DIMENSION CKMOVP(MCT,ML2*ML2/2,MCT,ML2*ML2/2,NUMO+NUMV,3),
     &          CKMOVPSUM(MCT,ML2*ML2/2,MCT,ML2*ML2/2,3)
      DIMENSION BLC(NUMO+NUMV,3),BLCSUM(3)
      DIMENSION CKMGRS(MCT,ML2*ML2/2,NUMO+NUMV,4)
      DIMENSION CKMGRSSUM(MCT,ML2*ML2/2,4)
      DIMENSION TOT(NUMO+NUMV,4),TOTSUM(4)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/MDLV/ELMT
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
C
      DATA EPS/1.0D-6/
C
C     IDENTIFY CENTRE WITH LARGEST KQN
      IBIG = 0
      LBIG = 0
      DO IZ=1,NCNT
        MLQN = (NKAP(IZ)-1)/2
        IF(MLQN.GT.LBIG) THEN
          IBIG = IZ
          LBIG = MLQN
        ENDIF
      ENDDO
C
C     KQN AND MQN COMBINATION MAPPED TO A LIST
      ICK = 0
      DO IKAP=1,NKAP(IBIG)
        IKQN = KAPA(IKAP,IBIG)
        DO IMAG=1,2*IABS(IKQN)
          ICK = ICK+1
          IF(MOD(IMAG,2).EQ.1) THEN
            IMQN =-IMAG
          ELSE
            IMQN = IMAG-1
          ENDIF
          IKM(IKQN,IMQN) = ICK
        ENDDO
      ENDDO
C
C     INITIALISE ALL OVERLAP CHARGE COUNTERS AND TOTALS
      DO IT=1,3
        BLCSUM(IT) = 0.0D0
        DO IOCC=1,NUMO+NUMV
          BLC(IOCC,IT) = 0.0D0
        ENDDO
        DO ICNT=1,NCNT
          ICK = 0
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            DO IMAG=1,2*IABS(IKQN)
              ICK = ICK+1
              DO JCNT=1,NCNT
                JCK = 0
                DO JKAP=1,NKAP(JCNT)
                  JKQN = KAPA(JKAP,JCNT)
                  DO JMAG=1,2*IABS(JKQN)
                    JCK = JCK+1
                    CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT) = 0.0D0
                    DO IOCC=1,NUMO+NUMV
                      CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT) = 0.0D0
                    ENDDO
                  ENDDO
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     INITIALISE ALL GROSS CHARGE COUNTERS AND TOTALS
      DO IP=1,4
        TOTSUM(IP) = 0.0D0
        DO IOCC=1,NUMO+NUMV
          TOT(IOCC,IP) = 0.0D0
        ENDDO
        DO IZ=1,NCNT
          ICK = 0
          DO IKAP=1,NKAP(IZ)
            IKQN = KAPA(IKAP,IZ)
            DO IMAG=1,2*IABS(IKQN)
              ICK = ICK+1
              CKMGRSSUM(IZ,ICK,IP) = 0.0D0
              DO IOCC=1,NUMO+NUMV
                CKMGRS(IZ,ICK,IOCC,IP) = 0.0D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRICES (ZEROTH MOMENT)
      CALL VMOMNT0(OLAPLL,1,0,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT0(OLAPSS,4,0,1,2)
      ENDIF
C
C     LOOP OVER OCCUPIED AND VIRTUAL ORBITALS
      DO IOCC=1,NUMO+NUMV
C
C       FOCK ADDRESS FOR THIS CENTRE
        IAD = IOCC+NSKP
C
C       NET SPINOR CHARGES: LOOP OVER ALL BASIS FUNCTIONS
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
C
C           SMALL-COMPONENT ADDRESSES
            K = I+NSKP
            L = J+NSKP
C
C           LARGE-COMPONENT ELECTRON DENSITY
            VL = DREAL(DCONJG(COEF(I,IAD))*COEF(J,IAD)*OLAPLL(I,J))
C
C           SMALL-COMPONENT ELECTRON DENSITY
            IF(HMLT.NE.'NORL') THEN
              VS = DREAL(DCONJG(COEF(K,IAD))*COEF(L,IAD)*OLAPSS(I,J))
            ELSE
              VS = 0.0D0
            ENDIF
C
C           IDENTIFY ATOMIC LABELS
            ICNT = LABICN(I)
            JCNT = LABICN(J)
            IKQN = LABKQN(I)
            JKQN = LABKQN(J)
            IMQN = LABMQN(I)
            JMQN = LABMQN(J)
C
C           FOCK ADDRESSES
            ICK = IKM(IKQN,IMQN)
            JCK = IKM(JKQN,JMQN)
C
C           UPDATE ORBITAL OVERLAP CHARGE CONTRIBUTIONS
            CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,1) 
     &                       = CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,1) + VL
            CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,2)
     &                       = CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,2) + VS
            CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,3)
     &                       = CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,3) + VL+VS
C
C           UPDATE ORBITAL GROSS CHARGE CONTRIBUTIONS
            IF(ICNT.EQ.JCNT.AND.ICK.EQ.JCK) THEN
              CKMGRS(ICNT,ICK,IOCC,1) = CKMGRS(ICNT,ICK,IOCC,1) + VL+VS
            ELSEIF(ICNT.EQ.JCNT.AND.ICK.NE.JCK) THEN
              CKMGRS(ICNT,ICK,IOCC,2) = CKMGRS(ICNT,ICK,IOCC,2) + VL+VS
            ELSE
              CKMGRS(ICNT,ICK,IOCC,3) = CKMGRS(ICNT,ICK,IOCC,3) + VL+VS
            ENDIF
            CKMGRS(ICNT,ICK,IOCC,4) = CKMGRS(ICNT,ICK,IOCC,4) + VL+VS
C
C           UPDATE MOLECULAR OVERLAP CHARGE CONTRIBUTIONS
            IF(IOCC.LE.NUMO) THEN
              CKMOVPSUM(ICNT,ICK,JCNT,JCK,1)
     &                         = CKMOVPSUM(ICNT,ICK,JCNT,JCK,1) + VL
              CKMOVPSUM(ICNT,ICK,JCNT,JCK,2)
     &                         = CKMOVPSUM(ICNT,ICK,JCNT,JCK,2) + VS
              CKMOVPSUM(ICNT,ICK,JCNT,JCK,3)
     &                         = CKMOVPSUM(ICNT,ICK,JCNT,JCK,3) + VL+VS
            ENDIF
C
C           UPDATE MOLECULAR GROSS CHARGE CONTRIBUTIONS
            IF(IOCC.LE.NUMO) THEN
              IF(ICNT.EQ.JCNT.AND.ICK.EQ.JCK) THEN
                CKMGRSSUM(ICNT,ICK,1) = CKMGRSSUM(ICNT,ICK,1) + VL+VS
              ELSEIF(ICNT.EQ.JCNT.AND.ICK.NE.JCK) THEN
                CKMGRSSUM(ICNT,ICK,2) = CKMGRSSUM(ICNT,ICK,2) + VL+VS
              ELSE
                CKMGRSSUM(ICNT,ICK,3) = CKMGRSSUM(ICNT,ICK,3) + VL+VS
              ENDIF
              CKMGRSSUM(ICNT,ICK,4) = CKMGRSSUM(ICNT,ICK,4) + VL+VS
            ENDIF
C
C         END LOOP OVER FOCK ADDRESSES
          ENDDO
        ENDDO
C
C       LOOP OVER ORBITAL TYPES
        DO ICNT=1,NCNT
          ICK = 0
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            DO IMAG=1,2*IABS(IKQN)
              ICK = ICK+1
C
C             UPDATE GROSS COUNTERS
              DO IP=1,4
                TOT(IOCC,IP) = TOT(IOCC,IP) + CKMGRS(ICNT,ICK,IOCC,IP)
                TOTSUM(IP)   = TOTSUM(IP)   + CKMGRS(ICNT,ICK,IOCC,IP)
              ENDDO
C
C             LOOP OVER OVERLAP SET OF ORBITAL TYPES
              DO JCNT=1,NCNT
                JCK = 0
                DO JKAP=1,NKAP(JCNT)
                  JKQN = KAPA(JKAP,JCNT)
                  DO JMAG=1,2*IABS(JKQN)
                    JCK = JCK+1
C
C                   UPDATE BLOCK COUNTERS
                    DO IT=1,3
                      BLC(IOCC,IT) = BLC(IOCC,IT)
     &                             + CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT)
                      BLCSUM(IT) = BLCSUM(IT)
     &                             + CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT)
                    ENDDO
C                    
                  ENDDO
                ENDDO
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
C
C     END LOOP OVER OCCUPIED ORBITALS
      ENDDO
C
C     CONCATENATE NET RESULTS INTO MORE GENERAL GROUPS: CKM -> CK
      IF(ICKM.EQ.1) GOTO 60
C
C     LOOP OVER CKM TYPES
      DO ICNT=1,NCNT
        ICK = 0
        DO IKAP=1,NKAP(ICNT)
          ICM  = ICK
          IKQN = KAPA(IKAP,ICNT)
          DO IMAG=1,2*IABS(IKQN)
            ICK = ICK+1
C
C           INCREASE ICM
            IF(IMAG.EQ.1) THEN
              ICM = ICM+1
              GOTO 51
            ENDIF
C
C           PLACE ALL CONTRIBUTIONS INTO THE FIRST IMAG ENTRY
            DO IP=1,4
              DO IOCC=1,NUMO+NUMV
                CKMGRS(ICNT,ICM,IOCC,IP) = CKMGRS(ICNT,ICM,IOCC,IP)
     &                                   + CKMGRS(ICNT,ICK,IOCC,IP)
              ENDDO
              CKMGRSSUM(ICNT,ICM,IP) = CKMGRSSUM(ICNT,ICM,IP)
     &                               + CKMGRSSUM(ICNT,ICK,IP)
            ENDDO
C
51          CONTINUE
C
C           LOOP OVER C'K'M' TYPES
            DO JCNT=1,NCNT
              JCK = 0
              DO JKAP=1,NKAP(JCNT)
                JCM  = JCK
                JKQN = KAPA(JKAP,JCNT)
                DO JMAG=1,2*IABS(JKQN)
                  JCK = JCK+1
C
C                 INCREASE JCM
                  IF(JMAG.EQ.1) THEN
                    JCM = JCM+1
                    IF(IMAG.EQ.1) GOTO 52
                  ENDIF
C
C                 PLACE ALL CONTRIBUTIONS INTO THE FIRST IMAG,JMAG ENTRY
                  DO IT=1,3
                    DO IOCC=1,NUMO+NUMV
                      CKMOVP(ICNT,ICM,JCNT,JCM,IOCC,IT)
     &                              = CKMOVP(ICNT,ICM,JCNT,JCM,IOCC,IT)
     &                              + CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT)
                    ENDDO
                    CKMOVPSUM(ICNT,ICM,JCNT,JCM,IT)
     &                                = CKMOVPSUM(ICNT,ICM,JCNT,JCM,IT)
     &                                + CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT)
                  ENDDO
C
52                CONTINUE
                ENDDO
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     CONCATENATE NET RESULTS INTO MORE GENERAL GROUPS: CK -> C
      IF(ICKM.EQ.2) GOTO 60
C
C     LOOP OVER CKM TYPES
      DO ICNT=1,NCNT
        ICK = 0
        DO IKAP=1,NKAP(ICNT)
          IKQN = KAPA(IKAP,ICNT)
          DO IMAG=1,2*IABS(IKQN)
            ICK = ICK+1
C
C           SKIP FIRST KAPPA CASE AND ALL BUT ONE IMAG
            IF(IKAP.EQ.1) GOTO 55
            IF(IMAG.NE.1) GOTO 55
C
C           PLACE ALL CONTRIBUTIONS INTO THE FIRST IMAG ENTRY
            DO IP=1,4
              DO IOCC=1,NUMO+NUMV
                CKMGRS(ICNT,1,IOCC,IP) = CKMGRS(ICNT,1,IOCC,IP)
     &                                 + CKMGRS(ICNT,ICK,IOCC,IP)
              ENDDO
              CKMGRSSUM(ICNT,1,IP) = CKMGRSSUM(ICNT,1,IP)
     &                             + CKMGRSSUM(ICNT,ICK,IP)
            ENDDO
C
55          CONTINUE
C
C           LOOP OVER C'K'M' TYPES
            DO JCNT=1,NCNT
              JCK = 0
              DO JKAP=1,NKAP(JCNT)
                JKQN = KAPA(JKAP,JCNT)
                DO JMAG=1,2*IABS(JKQN)
                  JCK = JCK+1
C
C                 SKIP FIRST KAPPA CASES AND ALL BUT ONE IMAG
                  IF(IKAP.EQ.1.AND.JKAP.EQ.1) GOTO 56
                  IF(IMAG.NE.1.OR.JMAG.NE.1) GOTO 56
C
C                 PLACE ALL CONTRIBUTIONS INTO THE FIRST IMAG,JMAG ENTRY
                  DO IT=1,3
                    DO IOCC=1,NUMO+NUMV
                      CKMOVP(ICNT,1,JCNT,1,IOCC,IT)
     &                              = CKMOVP(ICNT,1,JCNT,1,IOCC,IT)
     &                              + CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT)
                    ENDDO
                    CKMOVPSUM(ICNT,1,JCNT,1,IT)
     &                                = CKMOVPSUM(ICNT,1,JCNT,1,IT)
     &                                + CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT)
                  ENDDO
C
56                CONTINUE
                ENDDO
              ENDDO
            ENDDO
C
          ENDDO
        ENDDO
      ENDDO
C
60    CONTINUE
C
C     FINAL LIST:
C     WARN USER ABOUT CHARGE TOLERANCE PARAMETER
      WRITE(6,'(A,ES10.4)') ' Charge contributions above EPS = ',EPS
      WRITE(7,'(A,ES10.4)') ' Charge contributions above EPS = ',EPS
C
C**********************************************************************C
C     OVERLAP DECOMPOSITION BY ORBITAL                                 C
C**********************************************************************C
C
      WRITE(6,'(/1X,A)') 'Overlap decomposition by orbital'
      WRITE(7,'(/1X,A)') 'Overlap decomposition by orbital'
      WRITE(6,'(1X,72("=")/A,7X,A,8X,A,6X,A/1X,72("="))')
     & ' Orb| C1 E1 κ1  m1  | C2 E2 κ2  m2  |','Q_LL','Q_SS |','Q_net'
      WRITE(7,'(1X,72("=")/A,7X,A,8X,A,6X,A/1X,72("="))')
     & ' Orb| C1 E1 κ1  m1  | C2 E2 κ2  m2  |','Q_LL','Q_SS |','Q_net'
C
C     LOOP OVER ALL ORBITALS
      DO IOCC=1,NUMO+NUMV
C
C       SPECIAL SEPARATOR FOR VIRTUAL SPINORS
        IF(IOCC.EQ.NUMO+1) THEN
          WRITE(6,'(/1X,72("*")/28X,A/1X,72("*"))') 'Virtual spinors'
          WRITE(7,'(/1X,72("*")/28X,A/1X,72("*"))') 'Virtual spinors'
        ENDIF
C
C       LOOP OVER CENTRES AND KAPPAS
        WRITE(IORB,'(I3)') IOCC
        ICR = 0
        DO ICNT=1,NCNT
          ICS = 0
          ICK = 0
          DO IKAP=1,NKAP(ICNT)
            ICT = 0
            IKQN = KAPA(IKAP,ICNT)
            DO IMAG=1,2*IABS(IKQN)
C
C             UPDATE (KQN,MQN) COUNTER
              ICK = ICK+1
C
C             SKIP DEPENDING ON DECOMPOSITION TYPE
              IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 71
              IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 71
C
C             SKIP NEGLIGIBLE ENTRIES
              X = CKMOVP(ICNT,ICK,ICNT,ICK,IOCC,3)
              IF(DABS(X).GT.EPS) THEN
C
C               UPDATE COUNTERS
                ICR = ICR+1
                ICS = ICS+1
                ICT = ICT+1
C
C               WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
                IF(ICS.EQ.1) THEN
                  WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
     &             ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
                ELSEIF(ICT.EQ.1) THEN
                  WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
                ELSE
                  WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
                ENDIF
                WRITE(CEKM2,'(A)') ''
C
C               CROP CEKM IF ICKM IS 2 OR 3 
                IF(ICKM.EQ.2) THEN
                  WRITE(CEKM1,'(A)') CEKM1(1:8)
                  WRITE(CEKM2,'(A)') CEKM2(1:8)
                ELSEIF(ICKM.EQ.3) THEN
                  WRITE(CEKM1,'(A)') CEKM1(1:6)
                  WRITE(CEKM2,'(A)') CEKM2(1:6)
                ENDIF
C
C               PRINT TO TERMINAL
                WRITE(6,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
     &                           IORB//'| '//CEKM1//'|'//CEKM2//' |',
     &                      (CKMOVP(ICNT,ICK,ICNT,ICK,IOCC,IT),IT=1,3)
                WRITE(7,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
     &                           IORB//'| '//CEKM1//'|'//CEKM2//' |',
     &                      (CKMOVP(ICNT,ICK,ICNT,ICK,IOCC,IT),IT=1,3)
C
C               IORB NOT NEEDED ANY MORE
                IORB = '   '
C
              ENDIF
C
71            CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
C
C       START COUNTER AND LOOP OVER CENTRES AND KAPPA PAIRS
        ICR = 0
        DO ICNT=1,NCNT
          ICS = 0
          ICK = 0
          DO IKAP=1,NKAP(ICNT)
            ICT  = 0
            IKQN = KAPA(IKAP,ICNT)
            DO IMAG=1,2*IABS(IKQN)
C
C             UPDATE (IKQN,IMQN) COUNTER
              ICK = ICK+1
C
C             SKIP DEPENDING ON DECOMPOSITION TYPE
              IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 72
              IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 72
C
              JCS = 0
              JCK = 0
              DO JKAP=1,NKAP(ICNT)
                JCT  = 0
                JKQN = KAPA(JKAP,ICNT)
                DO JMAG=1,2*IABS(JKQN)
C
C                 UPDATE (JKQN,JMQN) COUNTER
                  JCK = JCK+1
C
                  IF(IKAP.EQ.JKAP.AND.IMAG.EQ.JMAG) GOTO 73
C
C                 SKIP DEPENDING ON DECOMPOSITION TYPE
                  IF(ICKM.GE.2.AND.JMAG.NE.1) GOTO 73
                  IF(ICKM.EQ.3.AND.JKAP.NE.1) GOTO 73
C
C                 SKIP NEGLIGIBLE OR NON-ALLOWED ENTRIES
                  X = CKMOVP(ICNT,ICK,ICNT,JCK,IOCC,3)
                  IF(DABS(X).GT.EPS) THEN
C
C                   UPDATE COUNTERS
                    ICR = ICR+1
                    ICS = ICS+1
                    ICT = ICT+1
                    JCS = JCS+1
                    JCT = JCT+1
C
C                   SEPARATOR
                    IF(ICR.EQ.1) THEN
                      WRITE(6, *) REPEAT('-',72)
                      WRITE(7, *) REPEAT('-',72)
                    ENDIF
C
C                   WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
                    IF(ICS.EQ.1) THEN
                      WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
     &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
                    ELSEIF(ICT.EQ.1) THEN
                      WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
                    ELSEIF(JCS.EQ.1) THEN
                      WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
                    ELSEIF(JCT.EQ.1) THEN
                      WRITE(CEKM1,'(A)') 
                    ENDIF
C
                    IF(JCT.EQ.1) THEN
                      WRITE(CEKM2,'(6X,A,1X,A)') KLAB(JKQN),MLAB(JMAG)
                    ELSE
                      WRITE(CEKM2,'(9X,A)') MLAB(JMAG)
                    ENDIF
C
C                   CROP CEKM IF ICKM IS 2 OR 3 
                    IF(ICKM.EQ.2) THEN
                      WRITE(CEKM1,'(A)') CEKM1(1:8)
                      WRITE(CEKM2,'(A)') CEKM2(1:8)
                    ELSEIF(ICKM.EQ.3) THEN
                      WRITE(CEKM1,'(A)') CEKM1(1:6)
                      WRITE(CEKM2,'(A)') CEKM2(1:6)
                    ENDIF
C
C                   PRINT TO TERMINAL
                    WRITE(6,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
     &                             IORB//'| '//CEKM1//'|'//CEKM2//' |',
     &                       (CKMOVP(ICNT,ICK,ICNT,JCK,IOCC,IT),IT=1,3)
                    WRITE(7,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
     &                             IORB//'| '//CEKM1//'|'//CEKM2//' |',
     &                       (CKMOVP(ICNT,ICK,ICNT,JCK,IOCC,IT),IT=1,3)
C
                  ENDIF
C
73                CONTINUE
C
                ENDDO
              ENDDO
C
72            CONTINUE
C
            ENDDO            
          ENDDO
        ENDDO
C
C       LOOP OVER CENTRES AND KAPPAS
        ICR = 0
        DO ICNT=1,NCNT
          ICS = 0
          ICK = 0
          DO IKAP=1,NKAP(ICNT)
            ICT = 0
            IKQN = KAPA(IKAP,ICNT)
            DO IMAG=1,2*IABS(IKQN)
C
C             UPDATE (IKQN,IMQN) COUNTER
              ICK = ICK+1
C
C             SKIP DEPENDING ON DECOMPOSITION TYPE
              IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 74
              IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 74
C
              JCR = 0
              DO JCNT=1,NCNT
                IF(ICNT.EQ.JCNT) GOTO 100
                JCS = 0
                JCK = 0
                DO JKAP=1,NKAP(JCNT)
                  JCT = 0
                  JKQN = KAPA(JKAP,JCNT)
                  DO JMAG=1,2*IABS(JKQN)
C
C                   UPDATE (JKQN,JMQN) COUNTER
                    JCK = JCK+1
C
C                   SKIP DEPENDING ON DECOMPOSITION TYPE
                    IF(ICKM.GE.2.AND.JMAG.NE.1) GOTO 75
                    IF(ICKM.EQ.3.AND.JKAP.NE.1) GOTO 75
C
C                   SKIP NEGLIGIBLE ENTRIES
                    X = CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,3)
                    IF(DABS(X).GT.EPS) THEN
C
C                     UPDATE COUNTERS
                      ICR = ICR+1
                      ICS = ICS+1
                      ICT = ICT+1
                      JCR = JCR+1
                      JCS = JCS+1
                      JCT = JCT+1
                      
                      IF(ICR.EQ.1) THEN
                        WRITE(6,*) REPEAT('-',72)
                        WRITE(7,*) REPEAT('-',72)
                      ENDIF
C
C                     WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
                      IF(ICS.EQ.1) THEN
                        WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
     &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
                      ELSEIF(ICT.EQ.1) THEN
                        WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
                      ELSEIF(JCR.EQ.1) THEN
                        WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
                      ELSE
                        WRITE(CEKM1,'(A)') 
                      ENDIF

                      IF(JCS.EQ.1) THEN
                        WRITE(CEKM2,'(I2,1X,A,1X,A,1X,A)') JCNT,
     &              ADJUSTR(ELMT(INT(ZNUC(JCNT)))),KLAB(JKQN),MLAB(JMAG)
                      ELSEIF(JCT.EQ.1) THEN
                        WRITE(CEKM2,'(6X,A,1X,A)') KLAB(JKQN),MLAB(JMAG)
                      ELSE
                        WRITE(CEKM2,'(9X,A)') MLAB(JMAG)
                      ENDIF
C
C                     CROP CEKM IF ICKM IS 2 OR 3 
                      IF(ICKM.EQ.2) THEN
                        WRITE(CEKM1,'(A)') CEKM1(1:8)
                        WRITE(CEKM2,'(A)') CEKM2(1:8)
                      ELSEIF(ICKM.EQ.3) THEN
                        WRITE(CEKM1,'(A)') CEKM1(1:6)
                        WRITE(CEKM2,'(A)') CEKM2(1:6)
                      ENDIF
C
C                     PRINT TO TERMINAL
                      WRITE(6,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
     &                             IORB//'| '//CEKM1//'| '//CEKM2//'|',
     &                       (CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT),IT=1,3)
                      WRITE(7,'(1X,A,F11.8,1X,F11.8," |",F11.8)')
     &                             IORB//'| '//CEKM1//'| '//CEKM2//'|',
     &                       (CKMOVP(ICNT,ICK,JCNT,JCK,IOCC,IT),IT=1,3)
C
                    ENDIF
C
75                  CONTINUE
C
                  ENDDO
                ENDDO
100             CONTINUE
              ENDDO
C
74            CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
C
C       QUOTE TOTAL FOR THIS ORBITAL
        WRITE(6,'(1X,72("-")/1X,I3,A,25X,A,2(F11.8,1X),"|",F11.8/1X,A)') 
     &          IOCC,'| Total','|',(BLC(IOCC,IT),IT=1,3),REPEAT('=',72)
        WRITE(7,'(1X,72("-")/1X,I3,A,25X,A,2(F11.8,1X),"|",F11.8/1X,A)') 
     &          IOCC,'| Total','|',(BLC(IOCC,IT),IT=1,3),REPEAT('=',72)
C
C     END LOOP OVER LISTED ORBITALS
      ENDDO
C
C**********************************************************************C
C     GROSS CHARGE BY ORBITAL                                          C
C**********************************************************************C
C
      WRITE(6,'(/1X,A)') 'Gross charges by orbital'
      WRITE(7,'(/1X,A)') 'Gross charges by orbital'
      WRITE(6,'(1X,72("=")/1X,A,3X,A,2X,A,7X,A,6X,A,8X,A/1X,72("="))')
     &  'Orb.|  C  E κ   m','|','Dirac orb.','Hybrid','Bonding','Gross'
      WRITE(7,'(1X,72("=")/1X,A,3X,A,2X,A,7X,A,6X,A,8X,A/1X,72("="))')
     &  'Orb.|  C  E κ   m','|','Dirac orb.','Hybrid','Bonding','Gross'
C
C     LOOP OVER ALL ORBITALS
      DO IOCC=1,NUMO+NUMV
C
C       STRING TITLE FOR THIS IOCC
        WRITE(IORB,'(I3)') IOCC
C
C       LOOP OVER CENTRES AND KAPPAS
        DO ICNT=1,NCNT
          ICR = 0
          ICK = 0
          DO IKAP=1,NKAP(ICNT)
            ICS  = 0
            IKQN = KAPA(IKAP,ICNT)
            DO IMAG=1,2*IABS(IKQN)
              ICT = 0
C
C             UPDATE (IKQN,IMQN) COUNTER
              ICK = ICK+1
C
C             SKIP DEPENDING ON DECOMPOSITION TYPE
              IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 76
              IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 76
C
C             SKIP NEGLIGIBLE ENTRIES
              IF(DABS(CKMGRS(ICNT,ICK,IOCC,4)).GT.EPS) THEN
C
C               UPDATE COUNTERS
                ICR = ICR+1
                ICS = ICS+1
                ICT = ICT+1
C
C               WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
                IF(ICR.EQ.1) THEN
                  WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
     &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
                ELSEIF(ICS.EQ.1) THEN
                  WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
                ELSEIF(ICT.EQ.1) THEN
                  WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
                ELSE
                  WRITE(CEKM1,'(A)') 
                ENDIF
C
C               CROP CEKM IF ICKM IS 2 OR 3 
                IF(ICKM.EQ.2) THEN
                  WRITE(CEKM1,'(A)') CEKM1(1:8)
                ELSEIF(ICKM.EQ.3) THEN
                  WRITE(CEKM1,'(A)') CEKM1(1:6)
                ENDIF
C
C               PRINT TO TERMINAL
                WRITE(6,'(1X,A,"|",F12.8,3(F13.8))') 
     &             IORB//' | '//CEKM1,(CKMGRS(ICNT,ICK,IOCC,IP),IP=1,4)
                WRITE(7,'(1X,A,"|",F12.8,3(F13.8))') 
     &             IORB//' | '//CEKM1,(CKMGRS(ICNT,ICK,IOCC,IP),IP=1,4)
C
C               NO LONGER NEED IORB LABEL
                WRITE(IORB,'(A)')
C
              ENDIF
C
76            CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
C
C       QUOTE TOTAL FOR THIS ORBITAL
        WRITE(6,'(1X,72("-")/1X,I3,A,9X,A,F12.8,3(F13.8)/1X,72("="))')
     &                        IOCC,' | Total','|',(TOT(IOCC,IP),IP=1,4)
        WRITE(7,'(1X,72("-")/1X,I3,A,9X,A,F12.8,3(F13.8)/1X,72("="))')
     &                        IOCC,' | Total','|',(TOT(IOCC,IP),IP=1,4)
C
C     END LOOP OVER ALL ORBITALS
      ENDDO
C
C**********************************************************************C
C     OVERLAP DECOMPOSITION FOR WHOLE SYSTEM                           C
C**********************************************************************C
C
      WRITE(6,'(/1X,A)') 'Overlap decomposition for molecule'
      WRITE(7,'(/1X,A)') 'Overlap decomposition for molecule'
      WRITE(6,'(1X,72("=")/4X,A,7X,A,8X,A,6X,A/1X,72("="))')
     &     '| C1 E1 κ1  m1  | C2 E2 κ2  m2  |','Q_LL','Q_SS |','Q_net'
      WRITE(7,'(1X,72("=")/4X,A,7X,A,8X,A,6X,A/1X,72("="))')
     &     '| C1 E1 κ1  m1  | C2 E2 κ2  m2  |','Q_LL','Q_SS |','Q_net'
C
C     LOOP OVER CENTRES AND KAPPAS
      ICR = 0
      DO ICNT=1,NCNT
        ICS = 0
        ICK = 0
        DO IKAP=1,NKAP(ICNT)
          ICT = 0
          IKQN = KAPA(IKAP,ICNT)
          DO IMAG=1,2*IABS(IKQN)
C
C           UPDATE (KQN,MQN) COUNTER
            ICK = ICK+1
C
C           SKIP DEPENDING ON DECOMPOSITION TYPE
            IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 77
            IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 77
C
C           SKIP NEGLIGIBLE ENTRIES
            X = CKMOVPSUM(ICNT,ICK,ICNT,ICK,3)
            IF(DABS(X).GT.EPS) THEN
C
C             UPDATE COUNTERS
              ICR = ICR+1
              ICS = ICS+1
              ICT = ICT+1
C
C             WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
              IF(ICS.EQ.1) THEN
                WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
     &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
              ELSEIF(ICT.EQ.1) THEN
                WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
              ELSE
                WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
              ENDIF
              WRITE(CEKM2,'(A)') ''
C
C             CROP CEKM IF ICKM IS 2 OR 3 
              IF(ICKM.EQ.2) THEN
                WRITE(CEKM1,'(A)') CEKM1(1:8)
              ELSEIF(ICKM.EQ.3) THEN
                WRITE(CEKM1,'(A)') CEKM1(1:6)
              ENDIF
C
C             PRINT TO TERMINAL
              WRITE(6,'(4X,A,F11.8,1X,F11.8," |",F11.8)')
     &                                   '| '//CEKM1//'|'//CEKM2//' |',
     &                         (CKMOVPSUM(ICNT,ICK,ICNT,ICK,IT),IT=1,3)
              WRITE(7,'(4X,A,F11.8,1X,F11.8," |",F11.8)')
     &                                   '| '//CEKM1//'|'//CEKM2//' |',
     &                         (CKMOVPSUM(ICNT,ICK,ICNT,ICK,IT),IT=1,3)
C
            ENDIF
C
77          CONTINUE
C
          ENDDO
        ENDDO
      ENDDO
C
C     START COUNTER AND LOOP OVER CENTRES AND KAPPA PAIRS
      ICR = 0
      DO ICNT=1,NCNT
        ICS = 0
        ICK = 0
        DO IKAP=1,NKAP(ICNT)
          ICT  = 0
          IKQN = KAPA(IKAP,ICNT)
          DO IMAG=1,2*IABS(IKQN)
C
C           UPDATE (IKQN,IMQN) COUNTER
            ICK = ICK+1
C
C           SKIP DEPENDING ON DECOMPOSITION TYPE
            IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 78
            IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 78
C
            JCS = 0
            JCK = 0
            DO JKAP=1,NKAP(ICNT)
              JCT  = 0
              JKQN = KAPA(JKAP,ICNT)
              DO JMAG=1,2*IABS(JKQN)
C
C               UPDATE (JKQN,JMQN) COUNTER
                JCK = JCK+1
C
                IF(IKAP.EQ.JKAP.AND.IMAG.EQ.JMAG) GOTO 79
C
C               SKIP DEPENDING ON DECOMPOSITION TYPE
                IF(ICKM.GE.2.AND.JMAG.NE.1) GOTO 79
                IF(ICKM.EQ.3.AND.JKAP.NE.1) GOTO 79
C
C               SKIP NEGLIGIBLE OR NON-ALLOWED ENTRIES
                X = CKMOVPSUM(ICNT,ICK,ICNT,JCK,3)
                IF(DABS(X).GT.EPS) THEN
C
C                 UPDATE COUNTERS
                  ICR = ICR+1
                  ICS = ICS+1
                  ICT = ICT+1
                  JCS = JCS+1
                  JCT = JCT+1
C
C                 SEPARATOR
                  IF(ICR.EQ.1) THEN
                    WRITE(6, *) REPEAT('-',72)
                    WRITE(7, *) REPEAT('-',72)
                  ENDIF
C
C                 WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
                  IF(ICS.EQ.1) THEN
                    WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
     &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
                  ELSEIF(ICT.EQ.1) THEN
                    WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
                  ELSEIF(JCS.EQ.1) THEN
                    WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
                  ELSEIF(JCT.EQ.1) THEN
                    WRITE(CEKM1,'(A)') 
                  ENDIF
C
                  IF(JCT.EQ.1) THEN
                    WRITE(CEKM2,'(6X,A,1X,A)') KLAB(JKQN),MLAB(JMAG)
                  ELSE
                    WRITE(CEKM2,'(9X,A)') MLAB(JMAG)
                  ENDIF
C
C                 CROP CEKM IF ICKM IS 2 OR 3 
                  IF(ICKM.EQ.2) THEN
                    WRITE(CEKM1,'(A)') CEKM1(1:8)
                    WRITE(CEKM2,'(A)') CEKM2(1:8)
                  ELSEIF(ICKM.EQ.3) THEN
                    WRITE(CEKM1,'(A)') CEKM1(1:6)
                    WRITE(CEKM2,'(A)') CEKM2(1:6)
                  ENDIF
C
C                 PRINT TO TERMINAL
                  WRITE(6,'(4X,A,F11.8,1X,F11.8," |",F11.8)')
     &                                   '| '//CEKM1//'|'//CEKM2//' |',
     &                         (CKMOVPSUM(ICNT,ICK,ICNT,JCK,IT),IT=1,3)
                  WRITE(7,'(4X,A,F11.8,1X,F11.8," |",F11.8)')
     &                                   '| '//CEKM1//'|'//CEKM2//' |',
     &                         (CKMOVPSUM(ICNT,ICK,ICNT,JCK,IT),IT=1,3)
C
                ENDIF
C
79              CONTINUE
C
              ENDDO
            ENDDO
C
78          CONTINUE
C
          ENDDO            
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRES AND KAPPAS
      ICR = 0
      DO ICNT=1,NCNT
        ICS = 0
        ICK = 0
        DO IKAP=1,NKAP(ICNT)
          ICT = 0
          IKQN = KAPA(IKAP,ICNT)
          DO IMAG=1,2*IABS(IKQN)
C
C           UPDATE (IKQN,IMQN) COUNTER
            ICK = ICK+1
C
C           SKIP DEPENDING ON DECOMPOSITION TYPE
            IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 80
            IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 80
C
            JCR = 0
            DO JCNT=1,NCNT
              IF(ICNT.EQ.JCNT) GOTO 101
              JCS = 0
              JCK = 0
              DO JKAP=1,NKAP(JCNT)
                JCT = 0
                JKQN = KAPA(JKAP,JCNT)
                DO JMAG=1,2*IABS(JKQN)
C
C                 UPDATE (JKQN,JMQN) COUNTER
                  JCK = JCK+1
C
C                 SKIP DEPENDING ON DECOMPOSITION TYPE
                  IF(ICKM.GE.2.AND.JMAG.NE.1) GOTO 81
                  IF(ICKM.EQ.3.AND.JKAP.NE.1) GOTO 81
C
C                 SKIP NEGLIGIBLE ENTRIES
                  X = CKMOVPSUM(ICNT,ICK,JCNT,JCK,3)
                  IF(DABS(X).GT.EPS) THEN
C
C                   UPDATE COUNTERS
                    ICR = ICR+1
                    ICS = ICS+1
                    ICT = ICT+1
                    JCR = JCR+1
                    JCS = JCS+1
                    JCT = JCT+1
                      
                    IF(ICR.EQ.1) THEN
                      WRITE(6,*) REPEAT('-',72)
                      WRITE(7,*) REPEAT('-',72)
                    ENDIF
C
C                   WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
                    IF(ICS.EQ.1) THEN
                      WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
     &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
                    ELSEIF(ICT.EQ.1) THEN
                      WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
                    ELSEIF(JCR.EQ.1) THEN
                      WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
                    ELSE
                      WRITE(CEKM1,'(A)') 
                    ENDIF

                    IF(JCS.EQ.1) THEN
                      WRITE(CEKM2,'(I2,1X,A,1X,A,1X,A)') JCNT,
     &              ADJUSTR(ELMT(INT(ZNUC(JCNT)))),KLAB(JKQN),MLAB(JMAG)
                    ELSEIF(JCT.EQ.1) THEN
                      WRITE(CEKM2,'(6X,A,1X,A)') KLAB(JKQN),MLAB(JMAG)
                    ELSE
                      WRITE(CEKM2,'(9X,A)') MLAB(JMAG)
                    ENDIF
C
C                   CROP CEKM IF ICKM IS 2 OR 3 
                    IF(ICKM.EQ.2) THEN
                      WRITE(CEKM1,'(A)') CEKM1(1:8)
                      WRITE(CEKM2,'(A)') CEKM2(1:8)
                    ELSEIF(ICKM.EQ.3) THEN
                      WRITE(CEKM1,'(A)') CEKM1(1:6)
                      WRITE(CEKM2,'(A)') CEKM2(1:6)
                    ENDIF
C
C                   PRINT TO TERMINAL
                    WRITE(6,'(4X,A,F11.8,1X,F11.8," |",F11.8)')
     &                                   '| '//CEKM1//'| '//CEKM2//'|',
     &                         (CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT),IT=1,3)
                    WRITE(7,'(4X,A,F11.8,1X,F11.8," |",F11.8)')
     &                                   '| '//CEKM1//'| '//CEKM2//'|',
     &                         (CKMOVPSUM(ICNT,ICK,JCNT,JCK,IT),IT=1,3)
C
                  ENDIF
C
81                CONTINUE
C
                ENDDO
              ENDDO
101           CONTINUE
            ENDDO
C
80          CONTINUE
C
          ENDDO
        ENDDO
      ENDDO
C
C     QUOTE TOTAL FOR THIS ORBITAL
      WRITE(6,'(1X,72("-")/4X,A,25X,A,2(F11.8,1X),"|",F11.8/1X,A)') 
     &                 '| Total','|',(BLCSUM(IT),IT=1,3),REPEAT('=',72)
      WRITE(7,'(1X,72("-")/4X,A,25X,A,2(F11.8,1X),"|",F11.8/1X,A)') 
     &                 '| Total','|',(BLCSUM(IT),IT=1,3),REPEAT('=',72)
C
C**********************************************************************C
C     GROSS CHARGE FOR MOLECULE                                        C
C**********************************************************************C
C
      WRITE(6,'(/1X,A)') 'Gross charges by orbital'
      WRITE(7,'(/1X,A)') 'Gross charges by orbital'
      WRITE(6,'(1X,72("=")/5X,A,3X,A,2X,A,7X,A,6X,A,8X,A/1X,72("="))')
     &      '|  C  E κ   m','|','Dirac orb.','Hybrid','Bonding','Gross'
      WRITE(7,'(1X,72("=")/5X,A,3X,A,2X,A,7X,A,6X,A,8X,A/1X,72("="))')
     &      '|  C  E κ   m','|','Dirac orb.','Hybrid','Bonding','Gross'
C
C     LOOP OVER CENTRES AND KAPPAS
      DO ICNT=1,NCNT
        ICR = 0
        ICK = 0
        DO IKAP=1,NKAP(ICNT)
          ICS  = 0
          IKQN = KAPA(IKAP,ICNT)
          DO IMAG=1,2*IABS(IKQN)
            ICT = 0
C
C           UPDATE (IKQN,IMQN) COUNTER
            ICK = ICK+1
C
C           SKIP DEPENDING ON DECOMPOSITION TYPE
            IF(ICKM.GE.2.AND.IMAG.NE.1) GOTO 82
            IF(ICKM.EQ.3.AND.IKAP.NE.1) GOTO 82
C
C           SKIP NEGLIGIBLE ENTRIES
            IF(DABS(CKMGRSSUM(ICNT,ICK,4)).GT.EPS) THEN
C
C             UPDATE COUNTERS
              ICR = ICR+1
              ICS = ICS+1
              ICT = ICT+1
C
C             WRITE CEKM LABELS DEPENDING ON COUNTER UPDATES
              IF(ICR.EQ.1) THEN
                WRITE(CEKM1,'(I2,1X,A,1X,A,1X,A)') ICNT,
     &              ADJUSTR(ELMT(INT(ZNUC(ICNT)))),KLAB(IKQN),MLAB(IMAG)
              ELSEIF(ICS.EQ.1) THEN
                WRITE(CEKM1,'(6X,A,1X,A)') KLAB(IKQN),MLAB(IMAG)
              ELSEIF(ICT.EQ.1) THEN
                WRITE(CEKM1,'(9X,A)') MLAB(IMAG)
              ELSE
                WRITE(CEKM1,'(A)') 
              ENDIF
C
C             CROP CEKM IF ICKM IS 2 OR 3 
              IF(ICKM.EQ.2) THEN
                WRITE(CEKM1,'(A)') CEKM1(1:8)
              ELSEIF(ICKM.EQ.3) THEN
                WRITE(CEKM1,'(A)') CEKM1(1:6)
              ENDIF
C
C             PRINT TO TERMINAL
              WRITE(6,'(5X,A,"|",F12.8,3(F13.8))') 
     &                      '| '//CEKM1,(CKMGRSSUM(ICNT,ICK,IP),IP=1,4)
              WRITE(7,'(5X,A,"|",F12.8,3(F13.8))') 
     &                      '| '//CEKM1,(CKMGRSSUM(ICNT,ICK,IP),IP=1,4)
C
            ENDIF
C
82          CONTINUE
C
          ENDDO
        ENDDO
      ENDDO
C
C     QUOTE TOTAL FOR THIS ORBITAL
      WRITE(6,'(1X,72("-")/5X,A,9X,A,F12.8,3(F13.8)/1X,72("=")/)')
     &                                '| Total','|',(TOTSUM(IP),IP=1,4)
      WRITE(7,'(1X,72("-")/5X,A,9X,A,F12.8,3(F13.8)/1X,72("=")/)')
     &                                '| Total','|',(TOTSUM(IP),IP=1,4)
C
      RETURN
      END
C
C
      SUBROUTINE ORTHGNL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     OOOOOO  RRRRRRR TTTTTTTT HH    HH  GGGGGG  NN    NN LL           C
C    OO    OO RR    RR   TT    HH    HH GG    GG NNN   NN LL           C
C    OO    OO RR    RR   TT    HH    HH GG       NNNN  NN LL           C
C    OO    OO RR    RR   TT    HHHHHHHH GG       NN NN NN LL           C
C    OO    OO RRRRRRR    TT    HH    HH GG   GGG NN  NNNN LL           C
C    OO    OO RR    RR   TT    HH    HH GG    GG NN   NNN LL           C
C     OOOOOO  RR    RR   TT    HH    HH  GGGGGG  NN    NN LLLLLLLL     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ORTHGNL PERFORMS A MOLECULAR ORTHOGONALITY ANALYSIS.                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VMOMNT0(OLAPLL,1,0,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT0(OLAPSS,4,0,1,2)
      ENDIF
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
      WRITE(6, *) 'Direct overlap analysis:'
      WRITE(7, *) 'Direct overlap analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Occupation number = ',DREAL(E1(5))
      WRITE(7,20) 'Occupation number = ',DREAL(E1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCMNPL_V1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCMNPL_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON V1
          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 4
C
40    FORMAT(1X,A,I3)
      WRITE(6,40) 'Goldstone diagram values for IOCC = ',IOCC
      WRITE(7,40) 'Goldstone diagram values for IOCC = ',IOCC
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO V1
      CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE SPINPRJ
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       SSSSSS  PPPPPPP IIII NN    NN PPPPPPP  RRRRRRR      JJJJJ      C
C      SS    SS PP    PP II  NNN   NN PP    PP RR    RR       JJ       C
C      SS       PP    PP II  NNNN  NN PP    PP RR    RR       JJ       C
C       SSSSSS  PP    PP II  NN NN NN PP    PP RR    RR       JJ       C
C            SS PPPPPPP  II  NN  NNNN PPPPPPP  RRRRRRR        JJ       C
C      SS    SS PP       II  NN   NNN PP       RR    RR JJ    JJ       C
C       SSSSSS  PP      IIII NN    NN PP       RR    RR  JJJJJJ        C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPINPRJ PERFORMS A SPIN-PROJECTION ANALYSIS.                        C
C -------------------------------------------------------------------- C
C  TODO: FOR DIATOMIC MOLECULES, Y-COMPONENT LESS RELIABLE THAN X.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 CONE,SUMX,SUMY,SUMZ
      COMPLEX*16 VX(MDM),VY(MDM),VZ(MDM)
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 PRJXLL(MDM,MDM),PRJXSS(MDM,MDM),
     &           PRJYLL(MDM,MDM),PRJYSS(MDM,MDM),
     &           PRJZLL(MDM,MDM),PRJZSS(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/EIGC/COEF
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C**********************************************************************C
C     PREPARE MATRIX ELEMENT INTEGRALS                                 C
C**********************************************************************C
C
C     GENERATE DIRECT SPIN PROJECTION MATRICES (ZEROTH MOMENT)
      CALL VMOMNT0(PRJXLL,1,1,1,2)
      CALL VMOMNT0(PRJYLL,1,2,1,2)
      CALL VMOMNT0(PRJZLL,1,3,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT0(PRJXSS,4,1,1,2)
        CALL VMOMNT0(PRJYSS,4,2,1,2)
        CALL VMOMNT0(PRJZSS,4,3,1,2)
      ENDIF
C
C**********************************************************************C
C     COMPUTE EXPECTATION VALUES MANUALLY BECAUSE SPIN EIGENFUNCTIONS  C
C     ARE NOT THE SAME AS SPATIAL EIGENFUNCTIONS -- NEED LINEAR COMBO. C
C**********************************************************************C
C
      WRITE(6, *) 'Spin projection analysis'
      WRITE(7, *) 'Spin projection analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
29    FORMAT(1X,A,I3,A)
30    FORMAT(1X,A,2X,3(14X,'E^(',I1,')',A))
31    FORMAT(1X,I3,' Re:',F21.9,F22.9,F22.9)
32    FORMAT(4X,' Im:',F21.9,F22.9,F22.9)
      WRITE(6,29) 'Expectation value for each orbital IOCC:'
      WRITE(7,29) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
      WRITE(7,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     LOOP OVER ORBITALS
      DO IOCC=NSKP+1,NSKP+NOCC+2
C
C       SOLUTIONS MUST COUPLE IN KRAMER PAIRS
        IF(MOD(IOCC,2).EQ.0) THEN
          NP =-1
        ELSE
          NP = 1
        ENDIF
C
C       INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
        SUMX = DCMPLX(0.0D0,0.0D0)
        SUMY = DCMPLX(0.0D0,0.0D0)
        SUMZ = DCMPLX(0.0D0,0.0D0)
C
C       LOOP OVER FOCK MATRIX ADDRESSES
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
C
C           LARGE CONTRIBUTIONS
            SUMX = SUMX+DCONJG(COEF(I,IOCC))*COEF(J,IOCC+NP)*PRJXLL(I,J)
            SUMY = SUMY+DCONJG(COEF(I,IOCC))*COEF(J,IOCC+NP)*PRJYLL(I,J)
            SUMZ = SUMZ+DCONJG(COEF(I,IOCC))*COEF(J,IOCC   )*PRJZLL(I,J)
C
C           SMALL CONTRIBUTIONS
            IF(HMLT.EQ.'NORL') GOTO 100
C
            K = I+NSKP
            L = J+NSKP
C
            SUMX = SUMX+DCONJG(COEF(K,IOCC))*COEF(L,IOCC+NP)*PRJXSS(I,J)
            SUMY = SUMY+DCONJG(COEF(K,IOCC))*COEF(L,IOCC+NP)*PRJYSS(I,J)
            SUMZ = SUMZ+DCONJG(COEF(K,IOCC))*COEF(L,IOCC   )*PRJZSS(I,J)
C
100         CONTINUE
C
          ENDDO
        ENDDO
C
C       SAVE SUM
        VX(IOCC) = SUMX
        VY(IOCC) =-SUMY*CONE
        VZ(IOCC) = SUMZ
C
      ENDDO
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_SPINPRJ_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=NSKP+1,NSKP+NOCC+2
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
     &                          DABS(DREAL(VY(IOCC))),
     &                          DABS(DREAL(VZ(IOCC)))
          WRITE(7,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
     &                          DABS(DREAL(VY(IOCC))),
     &                          DABS(DREAL(VZ(IOCC)))
          WRITE(8,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
     &                          DABS(DREAL(VY(IOCC))),
     &                          DABS(DREAL(VZ(IOCC)))
C
          WRITE(6,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
     &                                      DABS(DIMAG(VZ(IOCC)))
          WRITE(7,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
     &                                      DABS(DIMAG(VZ(IOCC)))
          WRITE(8,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
     &                                      DABS(DIMAG(VZ(IOCC)))
C
C         SEPARATOR FOR VIRTUAL SPECTRUM
          IF(IOCC.EQ.NSKP+NOCC) THEN
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(8, *) REPEAT('=',72)
          ELSEIF(IOCC.LT.NSKP+NOCC+2) THEN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(8, *) REPEAT('-',72)
          ENDIF
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ELCDIPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       EEEEEEEE LL       CCCCCC  DDDDDDD IIII PPPPPPP  LL             C
C       EE       LL      CC    CC DD    DD II  PP    PP LL             C
C       EE       LL      CC       DD    DD II  PP    PP LL             C
C       EEEEEE   LL      CC       DD    DD II  PP    PP LL             C
C       EE       LL      CC       DD    DD II  PPPPPPP  LL             C
C       EE       LL      CC    CC DD    DD II  PP       LL             C
C       EEEEEEEE LLLLLLLL CCCCCC  DDDDDDD IIII PP       LLLLLLLL       C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCDIPL CALCULATES THE PERMANENT ELECTRIC DIPOLE MOMENT OF THE      C
C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION ZCNT(3),ECNT(3),QCNT(3),ORIG(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 SUMLL,SUMSS
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM),
     &           EMPTY(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     DEFINE ORIGIN VECTOR
      DO IX=1,3
        ORIG(IX) = 0.0D0
      ENDDO
C
C**********************************************************************C
C     CENTRE OF CHARGE COORDINATES                                     C
C**********************************************************************C
C
C     NET NUCLEAR CHARGE
      ZTOT = 0.0D0
      DO IZ=1,NCNT
        ZTOT = ZTOT + ZNUC(IZ)
      ENDDO
C
C     CENTRE OF NUCLEAR CHARGE
      DO IX=1,3
        ZCNT(IX) = 0.0D0
        DO IZ=1,NCNT
          ZCNT(IX) = ZCNT(IX) + ZNUC(IZ)*BXYZ(IX,IZ)
        ENDDO
        ZCNT(IX) = ZCNT(IX)/ZTOT
      ENDDO
C
C     FIRST MOMENT INTEGRALS: X DIRECTION
      CALL VMOMNT1(DXLL,ORIG,1,0,1,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DXSS,ORIG,4,0,1,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: X DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DXLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DXSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(1) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     FIRST MOMENT INTEGRALS: Y DIRECTION
      CALL VMOMNT1(DYLL,ORIG,1,0,2,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DYSS,ORIG,4,0,2,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: Y DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DYLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DYSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(2) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     FIRST MOMENT INTEGRALS: Z DIRECTION
      CALL VMOMNT1(DZLL,ORIG,1,0,3,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DZSS,ORIG,4,0,3,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: Z DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DZLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DZSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(3) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     MOLECULAR CENTRE OF CHARGE (<X>,<Y>,<Z>)
      QTOT = ZTOT+DFLOAT(NOCC)
      DO IX=1,3
        QCNT(IX) = (ZTOT*ZCNT(IX) + NOCC*ECNT(IX))/QTOT
      ENDDO
C
C     PRINT CENTRE OF NUCLEAR CHARGE TO TERMINAL
      WRITE(6, *) 'Centre of nuclear/electron/total mass:'
      WRITE(7, *) 'Centre of nuclear/electron/total mass:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
10    FORMAT(1X,A,' = (',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
      WRITE(7,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
      WRITE(6,10) 'E(IX)',(ECNT(IX),IX=1,3)
      WRITE(7,10) 'E(IX)',(ECNT(IX),IX=1,3)
      WRITE(6,10) 'Q(IX)',(QCNT(IX),IX=1,3)
      WRITE(7,10) 'Q(IX)',(QCNT(IX),IX=1,3)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
      CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
      CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
C
      WRITE(6, *) 'Molecular electric dipole moment (e.a_{0}):'
      WRITE(7, *) 'Molecular electric dipole moment (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'd_{e} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'd_{e} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      WRITE(6, *) 'Molecular electric dipole moment (debye):'
      WRITE(7, *) 'Molecular electric dipole moment (debye):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      DX1R = CDB*DREAL(EX1(5))
      DY1R = CDB*DREAL(EY1(5))
      DZ1R = CDB*DREAL(EZ1(5))
C
      WRITE(6,20) 'd_{e} = ',DX1R,DY1R,DZ1R
      WRITE(7,20) 'd_{e} = ',DX1R,DY1R,DZ1R
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(7X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,DXLL,EMPTY,EMPTY,DXSS,NORD)
      CALL RSPT1(VY1,DYLL,EMPTY,EMPTY,DYSS,NORD)
      CALL RSPT1(VZ1,DZLL,EMPTY,EMPTY,DZSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_ELCDIPL_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_ELCDIPL_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_ELCDIPL_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCDIPL_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      
C      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 4
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     X-COMPONENT
      WRITE(6,40) IOCC,'X'
      WRITE(7,40) IOCC,'X'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VX1
      CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END X-COMPONENT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     Y-COMPONENT
      WRITE(6,40) IOCC,'Y'
      WRITE(7,40) IOCC,'Y'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VY1
      CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Y-COMPONENT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ELCQDPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE LL       CCCCCC    QQQQQQ    DDDDDDD  PPPPPPP  LL         C
C   EE       LL      CC    CC  QQ    QQ   DD    DD PP    PP LL         C
C   EE       LL      CC       QQ      QQ  DD    DD PP    PP LL         C
C   EEEEEE   LL      CC       QQ      QQ  DD    DD PP    PP LL         C
C   EE       LL      CC       QQ      QQ  DD    DD PPPPPPP  LL         C
C   EE       LL      CC    CC  QQ    QQ   DD    DD PP       LL         C
C   EEEEEEEE LLLLLLLL CCCCCC    QQQQQQ QQ DDDDDDD  PP       LLLLLLLL   C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCQDPL CALCULATES THE PERMANENT ELECTRIC QUADRUPOLE MOMENT OF THE  C
C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION ZCNT(3),ECNT(3),QCNT(3),ORIG(3)
C
      COMPLEX*16 EXX1(5),EYY1(5),EZZ1(5),EXY1(5),EYZ1(5),EXZ1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
      COMPLEX*16 QXXLL(MDM,MDM),QYYLL(MDM,MDM),QZZLL(MDM,MDM),
     &           QXYLL(MDM,MDM),QYZLL(MDM,MDM),QXZLL(MDM,MDM),
     &           QXXSS(MDM,MDM),QYYSS(MDM,MDM),QZZSS(MDM,MDM),
     &           QXYSS(MDM,MDM),QYZSS(MDM,MDM),QXZSS(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     DEFINE ORIGIN VECTOR
      DO IX=1,3
        ORIG(IX) = 0.0D0
      ENDDO
C
C**********************************************************************C
C     CENTRE OF CHARGE COORDINATES                                     C
C**********************************************************************C
C
C     NET NUCLEAR CHARGE
      ZTOT = 0.0D0
      DO IZ=1,NCNT
        ZTOT = ZTOT + ZNUC(IZ)
      ENDDO
C
C     CENTRE OF NUCLEAR CHARGE
      DO IX=1,3
        ZCNT(IX) = 0.0D0
        DO IZ=1,NCNT
          ZCNT(IX) = ZCNT(IX) + ZNUC(IZ)*BXYZ(IX,IZ)
        ENDDO
        ZCNT(IX) = ZCNT(IX)/ZTOT
      ENDDO
C
C     FIRST MOMENT INTEGRALS: X DIRECTION
      CALL VMOMNT1(DXLL,ORIG,1,0,1,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DXSS,ORIG,4,0,1,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: X DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DXLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DXSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(1) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     FIRST MOMENT INTEGRALS: Y DIRECTION
      CALL VMOMNT1(DYLL,ORIG,1,0,2,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DYSS,ORIG,4,0,2,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: Y DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DYLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DYSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(2) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     FIRST MOMENT INTEGRALS: Z DIRECTION
      CALL VMOMNT1(DZLL,ORIG,1,0,3,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DZSS,ORIG,4,0,3,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: Z DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DZLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DZSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(3) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     MOLECULAR CENTRE OF CHARGE (<X>,<Y>,<Z>)
      QTOT = ZTOT+DFLOAT(NOCC)
      DO IX=1,3
        QCNT(IX) = (ZTOT*ZCNT(IX) + NOCC*ECNT(IX))/QTOT
      ENDDO
C
C     PRINT CENTRE OF NUCLEAR CHARGE TO TERMINAL
      WRITE(6, *) 'Centre of nuclear/electron/total mass:'
      WRITE(7, *) 'Centre of nuclear/electron/total mass:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
10    FORMAT(1X,A,' = (',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
      WRITE(7,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
      WRITE(6,10) 'E(IX)',(ECNT(IX),IX=1,3)
      WRITE(7,10) 'E(IX)',(ECNT(IX),IX=1,3)
      WRITE(6,10) 'Q(IX)',(QCNT(IX),IX=1,3)
      WRITE(7,10) 'Q(IX)',(QCNT(IX),IX=1,3)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     GENERATE SECOND MOMENT OVERLAP INTEGRALS (USE ORIG, NOT ZCNT)
      CALL VMOMNT2(QXXLL,ORIG,ORIG,1,0,1,1,1,2)
      CALL VMOMNT2(QYYLL,ORIG,ORIG,1,0,2,2,1,2)
      CALL VMOMNT2(QZZLL,ORIG,ORIG,1,0,3,3,1,2)
      CALL VMOMNT2(QXYLL,ORIG,ORIG,1,0,1,2,1,2)
      CALL VMOMNT2(QYZLL,ORIG,ORIG,1,0,2,3,1,2)
      CALL VMOMNT2(QXZLL,ORIG,ORIG,1,0,1,3,1,2)
C
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT2(QXXSS,ORIG,ORIG,4,0,1,1,1,2)
        CALL VMOMNT2(QYYSS,ORIG,ORIG,4,0,2,2,1,2)
        CALL VMOMNT2(QZZSS,ORIG,ORIG,4,0,3,3,1,2)
        CALL VMOMNT2(QXYSS,ORIG,ORIG,4,0,1,2,1,2)
        CALL VMOMNT2(QYZSS,ORIG,ORIG,4,0,2,3,1,2)
        CALL VMOMNT2(QXZSS,ORIG,ORIG,4,0,1,3,1,2)
      ENDIF
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EXX1,QXXLL,EMPTY,EMPTY,QXXSS)
      CALL PROPRTY(EYY1,QYYLL,EMPTY,EMPTY,QYYSS)
      CALL PROPRTY(EZZ1,QZZLL,EMPTY,EMPTY,QZZSS)
      CALL PROPRTY(EXY1,QXYLL,EMPTY,EMPTY,QXYSS)
      CALL PROPRTY(EYZ1,QYZLL,EMPTY,EMPTY,QYZSS)
      CALL PROPRTY(EXZ1,QXZLL,EMPTY,EMPTY,QXZSS)
C
      WRITE(6, *) 'Molecular electric quadrupole moment (e.a_{0}):'
      WRITE(7, *) 'Molecular electric quadrupole moment (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,' (',F20.14,',',F20.14,',',F20.14,')')
21    FORMAT(9X,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'q_{e} =',DREAL(EXX1(5)),DREAL(EXY1(5)),DREAL(EXZ1(5))
      WRITE(7,20) 'q_{e} =',DREAL(EXX1(5)),DREAL(EXY1(5)),DREAL(EXZ1(5))
      WRITE(6,21)           DREAL(EXY1(5)),DREAL(EYY1(5)),DREAL(EYZ1(5))
      WRITE(7,21)           DREAL(EXY1(5)),DREAL(EYY1(5)),DREAL(EYZ1(5))
      WRITE(6,21)           DREAL(EXZ1(5)),DREAL(EYZ1(5)),DREAL(EZZ1(5))
      WRITE(7,21)           DREAL(EXZ1(5)),DREAL(EYZ1(5)),DREAL(EZZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
C
      RETURN
      END
C
C
      SUBROUTINE MAGDIPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM    AA     GGGGGG  DDDDDDD IIII PPPPPPP  LL           C
C     MMM     MMM   AAAA   GG    GG DD    DD II  PP    PP LL           C
C     MMMM   MMMM  AA  AA  GG       DD    DD II  PP    PP LL           C
C     MM MM MM MM AA    AA GG       DD    DD II  PP    PP LL           C
C     MM  MMM  MM AAAAAAAA GG   GGG DD    DD II  PPPPPPP  LL           C
C     MM   M   MM AA    AA GG    GG DD    DD II  PP       LL           C
C     MM       MM AA    AA  GGGGGG  DDDDDDD IIII PP       LLLLLLLL     C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGDIPL CALCULATES THE PERMANENT MAGNETIC DIPOLE MOMENT OF THE      C
C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION ORIG(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
     &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In MAGDIPL: not possible for this Hamiltonian!'
        WRITE(7, *) 'In MAGDIPL: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE FIRST MOMENT BASIS OVERLAP INTEGRALS
      CALL VMOMNT1(DXYLS,ORIG,2,1,2,1,2)
      CALL VMOMNT1(DXZLS,ORIG,2,1,3,1,2)
      CALL VMOMNT1(DYXLS,ORIG,2,2,1,1,2)
      CALL VMOMNT1(DYZLS,ORIG,2,2,3,1,2)
      CALL VMOMNT1(DZXLS,ORIG,2,3,1,1,2)
      CALL VMOMNT1(DZYLS,ORIG,2,3,2,1,2)
C
      CALL VMOMNT1(DXYSL,ORIG,3,1,2,1,2)
      CALL VMOMNT1(DXZSL,ORIG,3,1,3,1,2)
      CALL VMOMNT1(DYXSL,ORIG,3,2,1,1,2)
      CALL VMOMNT1(DYZSL,ORIG,3,2,3,1,2)
      CALL VMOMNT1(DZXSL,ORIG,3,3,1,1,2)
      CALL VMOMNT1(DZYSL,ORIG,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          WXLS(I,J) = 0.5D0*CV*(DZYLS(I,J)-DYZLS(I,J))
          WYLS(I,J) = 0.5D0*CV*(DXZLS(I,J)-DZXLS(I,J))
          WZLS(I,J) = 0.5D0*CV*(DYXLS(I,J)-DXYLS(I,J))
C
C         COMPONENT OVERLAP SL
          WXSL(I,J) = 0.5D0*CV*(DZYSL(I,J)-DYZSL(I,J))
          WYSL(I,J) = 0.5D0*CV*(DXZSL(I,J)-DZXSL(I,J))
          WZSL(I,J) = 0.5D0*CV*(DYXSL(I,J)-DXYSL(I,J))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,EMPTY,WXLS,WXSL,EMPTY)
      CALL PROPRTY(EY1,EMPTY,WYLS,WYSL,EMPTY)
      CALL PROPRTY(EZ1,EMPTY,WZLS,WZSL,EMPTY)
C
      WRITE(6, *) 'Molecular magnetic dipole moment (e.a_{0}):'
      WRITE(7, *) 'Molecular magnetic dipole moment (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'd_{m} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'd_{m} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(7X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,EMPTY,WXLS,WXSL,EMPTY,NORD)
      CALL RSPT1(VY1,EMPTY,WYLS,WYSL,EMPTY,NORD)
      CALL RSPT1(VZ1,EMPTY,WZLS,WZSL,EMPTY,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_MAGDIPL_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_MAGDIPL_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_MAGDIPL_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MAGDIPL_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      
C      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 4
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     X-COMPONENT
      WRITE(6,40) IOCC,'X'
      WRITE(7,40) IOCC,'X'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VX1
      CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END X-COMPONENT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     Y-COMPONENT
      WRITE(6,40) IOCC,'Y'
      WRITE(7,40) IOCC,'Y'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VY1
      CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Y-COMPONENT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE MAGQDPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C MM       MM    AA     GGGGGG    QQQQQQ    DDDDDDD  PPPPPPP  LL       C
C MMM     MMM   AAAA   GG    GG  QQ    QQ   DD    DD PP    PP LL       C
C MMMM   MMMM  AA  AA  GG       QQ      QQ  DD    DD PP    PP LL       C
C MM MM MM MM AA    AA GG       QQ      QQ  DD    DD PP    PP LL       C
C MM  MMM  MM AAAAAAAA GG   GGG QQ      QQ  DD    DD PPPPPPP  LL       C
C MM   M   MM AA    AA GG    GG  QQ    QQ   DD    DD PP       LL       C
C MM       MM AA    AA  GGGGGG    QQQQQQ QQ DDDDDDD  PP       LLLLLLLL C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGQDPL CALCULATES THE PERMANENT MAGNETIC QUADRUPOLE MOMENT OF THE  C
C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
C -------------------------------------------------------------------- C
C  TODO: THIS IS UNFINISHED, BECAUSE I CAN'T SEEM TO FIND A FORMULA.   C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
c
      CHARACTER*5 NMDL
C
      DIMENSION ORIG(3)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 QXYLS(MDM,MDM),QXZLS(MDM,MDM),QYXLS(MDM,MDM),
     &           QYZLS(MDM,MDM),QZXLS(MDM,MDM),QZYLS(MDM,MDM),
     &           QXYSL(MDM,MDM),QXZSL(MDM,MDM),QYXSL(MDM,MDM),
     &           QYZSL(MDM,MDM),QZXSL(MDM,MDM),QZYSL(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/DENS/DENC,DENO,DENT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In MAGQDPL: not possible for this Hamiltonian!'
        WRITE(7, *) 'In MAGQDPL: not possible for this Hamiltonian!'
      ENDIF
C
C     DEFINE ORIGIN VECTOR
      DO IX=1,3
        ORIG(IX) = 0.0D0
      ENDDO
C
C     GENERATE SECOND MOMENT OVERELAP INTEGRALS
      CALL VMOMNT2(QXYLS,ORIG,ORIG,2,1,2,3,1,2)
      CALL VMOMNT2(QXZLS,ORIG,ORIG,2,1,3,2,1,2)
      CALL VMOMNT2(QYXLS,ORIG,ORIG,2,2,1,3,1,2)
      CALL VMOMNT2(QYZLS,ORIG,ORIG,2,2,3,1,1,2)
      CALL VMOMNT2(QZXLS,ORIG,ORIG,2,3,1,2,1,2)
      CALL VMOMNT2(QZYLS,ORIG,ORIG,2,3,2,1,1,2)
C
      CALL VMOMNT2(QXYSL,ORIG,ORIG,3,1,2,3,1,2)
      CALL VMOMNT2(QXZSL,ORIG,ORIG,3,1,3,2,1,2)
      CALL VMOMNT2(QYXSL,ORIG,ORIG,3,2,1,3,1,2)
      CALL VMOMNT2(QYZSL,ORIG,ORIG,3,2,3,1,1,2)
      CALL VMOMNT2(QZXSL,ORIG,ORIG,3,3,1,2,1,2)
      CALL VMOMNT2(QZYSL,ORIG,ORIG,3,3,2,1,1,2)
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) 'MAGQDPL is unfinished.'
      WRITE(7, *) 'MAGQDPL is unfinished.'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE STRKEFF(EFIELD,GAUGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS TTTTTTTT RRRRRRR  KK    KK EEEEEEEE FFFFFFFF FFFFFFFF    C
C     SS    SS   TT    RR    RR KK   KK  EE       FF       FF          C
C     SS         TT    RR    RR KK  KK   EE       FF       FF          C
C      SSSSSS    TT    RR    RR KKKKK    EEEEEE   FFFFFF   FFFFFF      C
C           SS   TT    RRRRRRR  KK  KK   EE       FF       FF          C
C     SS    SS   TT    RR    RR KK   KK  EE       FF       FF          C
C      SSSSSS    TT    RR    RR KK    KK EEEEEEEE FF       FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  STRKEFF PERFORMS A STARK EFFECT ANALYSIS, GIVEN APPLIED ELECTRIC    C
C  FIELD (EX,EY,EZ).                                                   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EFIELD - UNIFORM ELECTRIC FIELD VECTOR (EX,EY,EZ).                C
C  ▶ GAUGE  - GAUGE ORIGIN COORDINATES.                                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EFIELD(3),GAUGE(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 D0XLL(MDM,MDM),D0YLL(MDM,MDM),D0ZLL(MDM,MDM),
     &           D0XSS(MDM,MDM),D0YSS(MDM,MDM),D0ZSS(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     MATRIX ELEMENT INTEGRALS
      CALL VMOMNT1(D0XLL,GAUGE,1,0,1,1,2)
      CALL VMOMNT1(D0YLL,GAUGE,1,0,2,1,2)
      CALL VMOMNT1(D0ZLL,GAUGE,1,0,3,1,2)
C
      IF(HMLT.EQ.'NORL') THEN
        CALL VMOMNT1(D0XSS,GAUGE,4,0,1,1,2)
        CALL VMOMNT1(D0YSS,GAUGE,4,0,2,1,2)
        CALL VMOMNT1(D0ZSS,GAUGE,4,0,3,1,2)
      ENDIF
C
C     CONSTRUCT ELECTRIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LL
          D0XLL(I,J) =-EFIELD(1)*D0XLL(I,J)
          D0YLL(I,J) =-EFIELD(2)*D0YLL(I,J)
          D0ZLL(I,J) =-EFIELD(3)*D0ZLL(I,J)
C
C         COMPONENT OVERLAP SS
          D0XSS(I,J) =-EFIELD(1)*D0XSS(I,J)
          D0YSS(I,J) =-EFIELD(2)*D0YSS(I,J)
          D0ZSS(I,J) =-EFIELD(3)*D0ZSS(I,J)
C
        ENDDO
      ENDDO
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,D0XLL,EMPTY,EMPTY,D0XSS)
      CALL PROPRTY(EY1,D0YLL,EMPTY,EMPTY,D0YSS)
      CALL PROPRTY(EZ1,D0ZLL,EMPTY,EMPTY,D0ZSS)
C
      WRITE(6, *) 'Stark effect interaction energy (e.a_{0}):'
      WRITE(7, *) 'Stark effect interaction energy (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'E_{S} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'E_{S} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C      GOTO 400
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 2
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,D0XLL,EMPTY,EMPTY,D0XSS,NORD)
      CALL RSPT1(VY1,D0YLL,EMPTY,EMPTY,D0YSS,NORD)
      CALL RSPT1(VZ1,D0ZLL,EMPTY,EMPTY,D0ZSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_STRKEFF_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_STRKEFF_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_STRKEFF_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_STRKEFF_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
400   CONTINUE
C
      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 2
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ZMANEFF(BFIELD,GAUGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   ZZZZZZZZ MM       MM    AA    NN    NN EEEEEEEE FFFFFFFF FFFFFFFF  C
C        ZZ  MMM     MMM   AAAA   NNN   NN EE       FF       FF        C
C       ZZ   MMMM   MMMM  AA  AA  NNNN  NN EE       FF       FF        C
C      ZZ    MM MM MM MM AA    AA NN NN NN EEEEEE   FFFFFF   FFFFFF    C
C     ZZ     MM  MMM  MM AAAAAAAA NN  NNNN EE       FF       FF        C
C    ZZ      MM   M   MM AA    AA NN   NNN EE       FF       FF        C
C   ZZZZZZZZ MM       MM AA    AA NN    NN EEEEEEEE FF       FF        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZMANEFF PERFORMS A ZEEMAN EFFECT ANALYSIS, GIVEN APPLIED MAGNETIC   C
C  FIELD (BX,BY,BZ).                                                   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ BFIELD - UNIFORM MAGNETIC FIELD VECTOR (BX,BY,BZ).                C
C  ▶ GAUGE  - GAUGE ORIGIN COORDINATES.                                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION BFIELD(3),GAUGE(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
     &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In ZMANEFF: not possible for this Hamiltonian!'
        WRITE(7, *) 'In ZMANEFF: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     MATRIX ELEMENT INTEGRALS
      CALL VMOMNT1(DXYLS,GAUGE,2,1,2,1,2)
      CALL VMOMNT1(DXZLS,GAUGE,2,1,3,1,2)
      CALL VMOMNT1(DYXLS,GAUGE,2,2,1,1,2)
      CALL VMOMNT1(DYZLS,GAUGE,2,2,3,1,2)
      CALL VMOMNT1(DZXLS,GAUGE,2,3,1,1,2)
      CALL VMOMNT1(DZYLS,GAUGE,2,3,2,1,2)
C
      CALL VMOMNT1(DXYSL,GAUGE,3,1,2,1,2)
      CALL VMOMNT1(DXZSL,GAUGE,3,1,3,1,2)
      CALL VMOMNT1(DYXSL,GAUGE,3,2,1,1,2)
      CALL VMOMNT1(DYZSL,GAUGE,3,2,3,1,2)
      CALL VMOMNT1(DZXSL,GAUGE,3,3,1,1,2)
      CALL VMOMNT1(DZYSL,GAUGE,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          WXLS(I,J) =-0.5D0*CV*BFIELD(1)*(DYZLS(I,J)-DZYLS(I,J))
          WYLS(I,J) =-0.5D0*CV*BFIELD(2)*(DZXLS(I,J)-DXZLS(I,J))
          WZLS(I,J) =-0.5D0*CV*BFIELD(3)*(DXYLS(I,J)-DYXLS(I,J))
C
C         COMPONENT OVERLAP SL
          WXSL(I,J) =-0.5D0*CV*BFIELD(1)*(DYZSL(I,J)-DZYSL(I,J))
          WYSL(I,J) =-0.5D0*CV*BFIELD(2)*(DZXSL(I,J)-DXZSL(I,J))
          WZSL(I,J) =-0.5D0*CV*BFIELD(3)*(DXYSL(I,J)-DYXSL(I,J))
C
        ENDDO
      ENDDO
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,EMPTY,WXLS,WXSL,EMPTY)
      CALL PROPRTY(EY1,EMPTY,WYLS,WYSL,EMPTY)
      CALL PROPRTY(EZ1,EMPTY,WZLS,WZSL,EMPTY)
C
      WRITE(6, *) 'Zeeman effect interaction energy (e.a_{0}):'
      WRITE(7, *) 'Zeeman effect interaction energy (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'E_{Z} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'E_{Z} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C      GOTO 400
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 2
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,EMPTY,WXLS,WXSL,EMPTY,NORD)
      CALL RSPT1(VY1,EMPTY,WYLS,WYSL,EMPTY,NORD)
      CALL RSPT1(VZ1,EMPTY,WZLS,WZSL,EMPTY,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_ZMANEFF_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_ZMANEFF_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_ZMANEFF_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ZMANEFF_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
400   CONTINUE
C
      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 1
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE HYPFINE(IZ,RNMU,ISPN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      HH    HH YY    YY PPPPPPP  FFFFFFFF IIII NN    NN EEEEEEEE      C
C      HH    HH YY    YY PP    PP FF        II  NNN   NN EE            C
C      HH    HH YY    YY PP    PP FF        II  NNNN  NN EE            C
C      HHHHHHHH  YY  YY  PP    PP FFFFFF    II  NN NN NN EEEEEE        C
C      HH    HH   YYYY   PPPPPPP  FF        II  NN  NNNN EE            C
C      HH    HH    YY    PP       FF        II  NN   NNN EE            C
C      HH    HH    YY    PP       FF       IIII NN    NN EEEEEEEE      C
C                                                                      C
C -------------------------------------------------------------------- C
C  HYPFINE DETERMINES THE FIRST-ORDER ENERGY SHIFT ARISING FROM THE    C
C  MAGNETIC DIPOLE MOMENT OF NUCLEUS IZ, WITH DIPOLE MOMENT STRENGTH   C
C  RNMU AND NUCLEAR SPIN ISPN. (USE SPIN HAMILTONIAN IN GRANT 11.5.8.) C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ   - THE NUCLEAR CENTRE WITH A MAGNETIC MOMENT.                 C
C  ▶ RNMU - NUCLEAR MAGNETIC DIPOLE MOMENT MU (NUCLEAR MAGNETON UNITS).C
C  ▶ ISPN - DOUBLE THE NUCLEAR SPIN OF THE CENTRE.                     C
C -------------------------------------------------------------------- C
C LIST OF AVAILABLE NUCLEAR DIPOLE MOMENTS AT FOLLOWING LINK:          C
C https://www.psi.ch/low-energy-muons/DocumentsEN/nuclear-moments.pdf  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION RNLOC(3)
C
      COMPLEX*16 CONE,SUMX,SUMY,SUMZ
      COMPLEX*16 VX(MDM),VY(MDM),VZ(MDM)
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
     &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/EIGC/COEF
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In HYPFINE: not possible for this Hamiltonian!'
        WRITE(7, *) 'In HYPFINE: not possible for this Hamiltonian!'
      ENDIF
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE OTHER ARRAYS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          DXYLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DXZLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DYXLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DYZLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DZXLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DZYLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DXYSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DXZSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DYXSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DYZSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DZXSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DZYSL(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOCATION OF NUCLEUS WITH MAGNETIC MOMENT
      DO IX=1,3
        RNLOC(IX) = BXYZ(IX,IZ)
      ENDDO
C
C     PRE-FACTOR FOR MATRIX ELEMENTS
      RI2 = DFLOAT(ISPN)/2.D0
      PRE =-CHZ*1.0D-6/(PMSS*CV*RI2)
C
C**********************************************************************C
C     PREPARE MATRIX ELEMENT INTEGRALS                                 C
C**********************************************************************C
C
C     MATRIX ELEMENT INTEGRALS
      CALL VMNPOLE(DXYLS,RNLOC,2,1,2,1,2)
      CALL VMNPOLE(DXZLS,RNLOC,2,1,3,1,2)
      CALL VMNPOLE(DYXLS,RNLOC,2,2,1,1,2)
      CALL VMNPOLE(DYZLS,RNLOC,2,2,3,1,2)
      CALL VMNPOLE(DZXLS,RNLOC,2,3,1,1,2)
      CALL VMNPOLE(DZYLS,RNLOC,2,3,2,1,2)
C
      CALL VMNPOLE(DXYSL,RNLOC,3,1,2,1,2)
      CALL VMNPOLE(DXZSL,RNLOC,3,1,3,1,2)
      CALL VMNPOLE(DYXSL,RNLOC,3,2,1,1,2)
      CALL VMNPOLE(DYZSL,RNLOC,3,2,3,1,2)
      CALL VMNPOLE(DZXSL,RNLOC,3,3,1,1,2)
      CALL VMNPOLE(DZYSL,RNLOC,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC MOMENT DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          WXLS(I,J) = DYZLS(I,J)-DZYLS(I,J)
          WYLS(I,J) = DZXLS(I,J)-DXZLS(I,J)
          WZLS(I,J) = DXYLS(I,J)-DYXLS(I,J)
C
C         COMPONENT OVERLAP SL
          WXSL(I,J) = DYZSL(I,J)-DZYSL(I,J)
          WYSL(I,J) = DZXSL(I,J)-DXZSL(I,J)
          WZSL(I,J) = DXYSL(I,J)-DYXSL(I,J)
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     COMPUTE EXPECTATION VALUES MANUALLY BECAUSE SPIN EIGENFUNCTIONS  C
C     ARE NOT THE SAME AS SPATIAL EIGENFUNCTIONS -- NEED LINEAR COMBO. C
C**********************************************************************C
C
29    FORMAT(1X,A,I3,A)
30    FORMAT(1X,A,2X,3(14X,'E^(',I1,')',A))
31    FORMAT(1X,I3,' Re:',F21.9,F22.9,F22.9)
32    FORMAT(4X,' Im:',F21.9,F22.9,F22.9)
      WRITE(6,29) 'Expectation value for each orbital IOCC (in MHz):'
      WRITE(7,29) 'Expectation value for each orbital IOCC (in MHz):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
      WRITE(7,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     LOOP OVER ORBITALS
      DO IOCC=NSKP+1,NSKP+NOCC+2
C
C       SOLUTIONS MUST COUPLE IN KRAMER PAIRS
        IF(MOD(IOCC,2).EQ.0) THEN
          NP =-1
        ELSE
          NP = 1
        ENDIF
C
C       INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
        SUMX = DCMPLX(0.0D0,0.0D0)
        SUMY = DCMPLX(0.0D0,0.0D0)
        SUMZ = DCMPLX(0.0D0,0.0D0)
C
C       LOOP OVER FOCK MATRIX ADDRESSES
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
C
            K = I+NSKP
            L = J+NSKP
C
C           LARGE AND SMALL CONTRIBUTIONS
            SUMX = SUMX + DCONJG(COEF(I,IOCC))*COEF(L,IOCC+NP)*WXLS(I,J)
     &                  + DCONJG(COEF(K,IOCC))*COEF(J,IOCC+NP)*WXSL(I,J)
            SUMY = SUMY + DCONJG(COEF(I,IOCC))*COEF(L,IOCC+NP)*WYLS(I,J)
     &                  + DCONJG(COEF(K,IOCC))*COEF(J,IOCC+NP)*WYSL(I,J)
            SUMZ = SUMZ + DCONJG(COEF(I,IOCC))*COEF(L,IOCC   )*WZLS(I,J)
     &                  + DCONJG(COEF(K,IOCC))*COEF(J,IOCC   )*WZSL(I,J)
C
          ENDDO
        ENDDO
C
C       SAVE SUM
        VX(IOCC) = SUMX*PRE*RNMU
        VY(IOCC) =-SUMY*PRE*RNMU*CONE
        VZ(IOCC) = SUMZ*PRE*RNMU
C
      ENDDO
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_HYPFINE_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=NSKP+1,NSKP+NOCC+2
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
     &                          DABS(DREAL(VY(IOCC))),
     &                          DABS(DREAL(VZ(IOCC)))
          WRITE(7,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
     &                          DABS(DREAL(VY(IOCC))),
     &                          DABS(DREAL(VZ(IOCC)))
          WRITE(8,31) IOCC-NSKP,DABS(DREAL(VX(IOCC))),
     &                          DABS(DREAL(VY(IOCC))),
     &                          DABS(DREAL(VZ(IOCC)))
C
          WRITE(6,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
     &                                      DABS(DIMAG(VZ(IOCC)))
          WRITE(7,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
     &                                      DABS(DIMAG(VZ(IOCC)))
          WRITE(8,32) DABS(DIMAG(VX(IOCC))),DABS(DIMAG(VY(IOCC))),
     &                                      DABS(DIMAG(VZ(IOCC)))
C
C         SEPARATOR FOR VIRTUAL SPECTRUM
          IF(IOCC.EQ.NSKP+NOCC) THEN
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(8, *) REPEAT('=',72)
          ELSEIF(IOCC.LT.NSKP+NOCC+2) THEN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(8, *) REPEAT('-',72)
          ENDIF
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE NMRSHLD(IZ,GAUGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  NN    NN MM       MM RRRRRRR   SSSSSS  HH    HH LL       DDDDDDD    C
C  NNN   NN MMM     MMM RR    RR SS    SS HH    HH LL       DD    DD   C
C  NNNN  NN MMMM   MMMM RR    RR SS       HH    HH LL       DD    DD   C
C  NN NN NN MM MM MM MM RR    RR  SSSSSS  HHHHHHHH LL       DD    DD   C
C  NN  NNNN MM  MMM  MM RRRRRRR        SS HH    HH LL       DD    DD   C
C  NN   NNN MM   M   MM RR    RR SS    SS HH    HH LL       DD    DD   C
C  NN    NN MM       MM RR    RR  SSSSSS  HH    HH LLLLLLLL DDDDDDD    C
C                                                                      C
C -------------------------------------------------------------------- C
C  NMRSHLD CALCULATES THE NUCLEAR SHIELDING TENSOR FOR ONE NUCLEUS IN  C
C  A MOLECULE UNDER THE HARTREE-FOCK APPROXIMATION, TO LEADING ORDER.  C
C  NOTE: SINCE THE S-TENSOR IS A CROSSING TERM IN SECOND ORDER P.T.    C
C        WITH INTERPRETATIONS FOR THE POSITIVE- AND NEGATIVE-ENERGY    C
C        UNOCCUPIED SPECTRUM, CALCULATIONS HERE ARE DONE EXPLICITLY.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ    - THE NUCLEAR CENTRE WITH A MAGNETIC MOMENT.                C
C  ▶ GAUGE - GAUGE ORIGIN COORDINATES - TRY BXYZ(IZ) TO START.         C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION GAUGE(3),RNLOC(3)
      DIMENSION PX(NDIM,NDIM),PY(NDIM,NDIM),PZ(NDIM,NDIM)
      DIMENSION KQN(2),LQN(2),NBAS(2)
C
      COMPLEX*16 CONE,GC,BC,HC
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 VXXX(MDM,MDM),VYXX(MDM,MDM),VZXX(MDM,MDM),
     &           VXXY(MDM,MDM),VYXY(MDM,MDM),VZXY(MDM,MDM),
     &           VXXZ(MDM,MDM),VYXZ(MDM,MDM),VZXZ(MDM,MDM),
     &           VXYX(MDM,MDM),VYYX(MDM,MDM),VZYX(MDM,MDM),
     &           VXYY(MDM,MDM),VYYY(MDM,MDM),VZYY(MDM,MDM),
     &           VXYZ(MDM,MDM),VYYZ(MDM,MDM),VZYZ(MDM,MDM),
     &           VXZX(MDM,MDM),VYZX(MDM,MDM),VZZX(MDM,MDM),
     &           VXZY(MDM,MDM),VYZY(MDM,MDM),VZZY(MDM,MDM),
     &           VXZZ(MDM,MDM),VYZZ(MDM,MDM),VZZZ(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 GTT(MDM,MDM,9)
      COMPLEX*16 BLS(MDM,MDM,3),BSL(MDM,MDM,3),
     &           HLS(MDM,MDM,3),HSL(MDM,MDM,3)
      COMPLEX*16 VB(MDM,MDM,3),VH(MDM,MDM,3)
      COMPLEX*16 SIG1G(3,3),SIG2N(3,3),SIG2P(3,3),SIGMA(3,3)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     LOCATION OF NUCLEUS WITH MAGNETIC MOMENT
      DO IX=1,3
        RNLOC(IX) = BXYZ(IX,IZ)
      ENDDO
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In NMRSHLD: not possible for this Hamiltonian!'
        WRITE(7, *) 'In NMRSHLD: not possible for this Hamiltonian!'
      ENDIF
C
C**********************************************************************C
C     GENERATE MATRIX OF BASIS FUNCTION OVERLAP CENTRES PX,PY,PZ       C
C**********************************************************************C
C
C     INITIALISE ELEMENTS
      DO I=1,NDIM
        DO J=1,NDIM
          PX(I,J) = 0.0D0
          PY(I,J) = 0.0D0
          PZ(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRES A AND B
      DO 1000 ICNTA=1,NCNT
      DO 1000 ICNTB=1,NCNT
C
C     LOOP OVER KQN(A) AND KQN(B) VALUES
      DO 1000 KA=1,NKAP(ICNTA)
      DO 1000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCKS A AND B
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       NUMBER OF BASIS EXPONENTS FOR BLOCKS A AND B
        NBAS(1) = NFNC(LQN(1),ICNTA)
        NBAS(2) = NFNC(LQN(2),ICNTB)
C
C     LOOP OVER |MQN(A)| AND |MQN(B)| VALUES
      DO 1000 MA=1,IABS(KQN(1))
      DO 1000 MB=1,IABS(KQN(2))
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SMALL-COMPONENT ADDRESSES
          KBAS = IBAS+NSKP
          LBAS = JBAS+NSKP
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX(NA1+IBAS,NB1+LBAS) = BXYZ(1,ICNTA)-BXYZ(1,ICNTB)
          PX(NA1+IBAS,NB2+LBAS) = BXYZ(1,ICNTA)-BXYZ(1,ICNTB)
          PX(NA2+IBAS,NB1+LBAS) = BXYZ(1,ICNTA)-BXYZ(1,ICNTB)
          PX(NA2+IBAS,NB2+LBAS) = BXYZ(1,ICNTA)-BXYZ(1,ICNTB)
          PY(NA1+IBAS,NB1+LBAS) = BXYZ(2,ICNTA)-BXYZ(2,ICNTB)
          PY(NA1+IBAS,NB2+LBAS) = BXYZ(2,ICNTA)-BXYZ(2,ICNTB)
          PY(NA2+IBAS,NB1+LBAS) = BXYZ(2,ICNTA)-BXYZ(2,ICNTB)
          PY(NA2+IBAS,NB2+LBAS) = BXYZ(2,ICNTA)-BXYZ(2,ICNTB)
          PZ(NA1+IBAS,NB1+LBAS) = BXYZ(3,ICNTA)-BXYZ(3,ICNTB)
          PZ(NA1+IBAS,NB2+LBAS) = BXYZ(3,ICNTA)-BXYZ(3,ICNTB)
          PZ(NA2+IBAS,NB1+LBAS) = BXYZ(3,ICNTA)-BXYZ(3,ICNTB)
          PZ(NA2+IBAS,NB2+LBAS) = BXYZ(3,ICNTA)-BXYZ(3,ICNTB)
C
          PX(NA1+KBAS,NB1+JBAS) = PX(NA1+IBAS,NB1+LBAS)
          PX(NA1+KBAS,NB2+JBAS) = PX(NA1+IBAS,NB2+LBAS)
          PX(NA2+KBAS,NB1+JBAS) = PX(NA2+IBAS,NB1+LBAS)
          PX(NA2+KBAS,NB2+JBAS) = PX(NA2+IBAS,NB2+LBAS)
          PY(NA1+KBAS,NB1+JBAS) = PY(NA1+IBAS,NB1+LBAS)
          PY(NA1+KBAS,NB2+JBAS) = PY(NA1+IBAS,NB2+LBAS)
          PY(NA2+KBAS,NB1+JBAS) = PY(NA2+IBAS,NB1+LBAS)
          PY(NA2+KBAS,NB2+JBAS) = PY(NA2+IBAS,NB2+LBAS)
          PZ(NA1+KBAS,NB1+JBAS) = PZ(NA1+IBAS,NB1+LBAS)
          PZ(NA1+KBAS,NB2+JBAS) = PZ(NA1+IBAS,NB2+LBAS)
          PZ(NA2+KBAS,NB1+JBAS) = PZ(NA2+IBAS,NB1+LBAS)
          PZ(NA2+KBAS,NB2+JBAS) = PZ(NA2+IBAS,NB2+LBAS)
C
        ENDDO
      ENDDO
1000  CONTINUE
C
C**********************************************************************C
C     PREPARATION OF MATRIX ELEMENTS FOR σ(1)                          C
C**********************************************************************C
C
C     DIPOLE ELECTRIC FIELD MATRIX ELEMENTS
      CALL VSETGTN(VXYX,VXYY,VXYZ,RNLOC,1,2)
      CALL VSETGTN(VXZX,VXZY,VXZZ,RNLOC,1,3)
      CALL VSETGTN(VYXX,VYXY,VYXZ,RNLOC,2,1)
      CALL VSETGTN(VYZX,VYZY,VYZZ,RNLOC,2,3)
      CALL VSETGTN(VZXX,VZXY,VZXZ,RNLOC,3,1)
      CALL VSETGTN(VZYX,VZYY,VZYZ,RNLOC,3,2)
C
C     CONSTRUCT `GAUGE-DEPENDENT' MATRIX ELEMENTS
      DO I=1,NDIM
        DO J=1,NDIM
          GTT(I,J,1) = PY(I,J)*(VYZZ(I,J)-VZYZ(I,J))
     &               - PZ(I,J)*(VYZY(I,J)-VZYY(I,J))
          GTT(I,J,2) = PY(I,J)*(VZXZ(I,J)-VXZZ(I,J))
     &               - PZ(I,J)*(VZXY(I,J)-VXZY(I,J))
          GTT(I,J,3) = PY(I,J)*(VXYZ(I,J)-VYXZ(I,J))
     &               - PZ(I,J)*(VXYY(I,J)-VYXY(I,J))
          GTT(I,J,4) = PZ(I,J)*(VYZX(I,J)-VZYX(I,J))
     &               - PX(I,J)*(VYZZ(I,J)-VZYZ(I,J))
          GTT(I,J,5) = PZ(I,J)*(VZXX(I,J)-VXZX(I,J))
     &               - PX(I,J)*(VZXZ(I,J)-VXZZ(I,J))
          GTT(I,J,6) = PZ(I,J)*(VXYX(I,J)-VYXX(I,J))
     &               - PX(I,J)*(VXYZ(I,J)-VYXZ(I,J))
          GTT(I,J,7) = PX(I,J)*(VYZY(I,J)-VZYY(I,J))
     &               - PY(I,J)*(VYZX(I,J)-VZYX(I,J))
          GTT(I,J,8) = PX(I,J)*(VZXY(I,J)-VXZY(I,J))
     &               - PY(I,J)*(VZXX(I,J)-VXZX(I,J))
          GTT(I,J,9) = PX(I,J)*(VXYY(I,J)-VYXY(I,J))
     &               - PY(I,J)*(VXYX(I,J)-VYXX(I,J))
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF FIRST-ORDER GAUGE TERM, E^(1)_GAUGE.              C
C**********************************************************************C
C
C     INITIALISE σ MATRICES
      DO IX=1,3
        DO JX=1,3
          SIG1G(IX,JX) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER FOCK MATRIX ADDRESSES AND ADD TO σ(1)
      DO I=1,NDIM
        DO J=1,NDIM
          SIG1G(1,1) = SIG1G(1,1) - CONE*DENT(I,J)*GTT(I,J,1)/CV
          SIG1G(1,2) = SIG1G(1,2) - CONE*DENT(I,J)*GTT(I,J,2)/CV
          SIG1G(1,3) = SIG1G(1,3) - CONE*DENT(I,J)*GTT(I,J,3)/CV
          SIG1G(2,1) = SIG1G(2,1) - CONE*DENT(I,J)*GTT(I,J,4)/CV
          SIG1G(2,2) = SIG1G(2,2) - CONE*DENT(I,J)*GTT(I,J,5)/CV
          SIG1G(2,3) = SIG1G(2,3) - CONE*DENT(I,J)*GTT(I,J,6)/CV
          SIG1G(3,1) = SIG1G(3,1) - CONE*DENT(I,J)*GTT(I,J,7)/CV
          SIG1G(3,2) = SIG1G(3,2) - CONE*DENT(I,J)*GTT(I,J,8)/CV
          SIG1G(3,3) = SIG1G(3,3) - CONE*DENT(I,J)*GTT(I,J,9)/CV
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PREPARATION OF MATRIX ELEMENTS FOR σ(2)                          C
C**********************************************************************C
C
C     FIRST MOMENT MATRIX ELEMENTS
      CALL VMOMNT1(DXYLS,GAUGE,2,1,2,1,2)
      CALL VMOMNT1(DXZLS,GAUGE,2,1,3,1,2)
      CALL VMOMNT1(DYXLS,GAUGE,2,2,1,1,2)
      CALL VMOMNT1(DYZLS,GAUGE,2,2,3,1,2)
      CALL VMOMNT1(DZXLS,GAUGE,2,3,1,1,2)
      CALL VMOMNT1(DZYLS,GAUGE,2,3,2,1,2)
C
      CALL VMOMNT1(DXYSL,GAUGE,3,1,2,1,2)
      CALL VMOMNT1(DXZSL,GAUGE,3,1,3,1,2)
      CALL VMOMNT1(DYXSL,GAUGE,3,2,1,1,2)
      CALL VMOMNT1(DYZSL,GAUGE,3,2,3,1,2)
      CALL VMOMNT1(DZXSL,GAUGE,3,3,1,1,2)
      CALL VMOMNT1(DZYSL,GAUGE,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          BLS(I,J,1) = DYZLS(I,J)-DZYLS(I,J)
          BLS(I,J,2) = DZXLS(I,J)-DXZLS(I,J)
          BLS(I,J,3) = DXYLS(I,J)-DYXLS(I,J)
C
C         COMPONENT OVERLAP SL
          BSL(I,J,1) = DYZSL(I,J)-DZYSL(I,J)
          BSL(I,J,2) = DZXSL(I,J)-DXZSL(I,J)
          BSL(I,J,3) = DXYSL(I,J)-DYXSL(I,J)
C
        ENDDO
      ENDDO
C
C     ELECTRIC MONOPOLE MOMENT MATRIX ELEMENTS
      CALL VMNPOLE(DXYLS,RNLOC,2,1,2,1,2)
      CALL VMNPOLE(DXZLS,RNLOC,2,1,3,1,2)
      CALL VMNPOLE(DYXLS,RNLOC,2,2,1,1,2)
      CALL VMNPOLE(DYZLS,RNLOC,2,2,3,1,2)
      CALL VMNPOLE(DZXLS,RNLOC,2,3,1,1,2)
      CALL VMNPOLE(DZYLS,RNLOC,2,3,2,1,2)
C
      CALL VMNPOLE(DXYSL,RNLOC,3,1,2,1,2)
      CALL VMNPOLE(DXZSL,RNLOC,3,1,3,1,2)
      CALL VMNPOLE(DYXSL,RNLOC,3,2,1,1,2)
      CALL VMNPOLE(DYZSL,RNLOC,3,2,3,1,2)
      CALL VMNPOLE(DZXSL,RNLOC,3,3,1,1,2)
      CALL VMNPOLE(DZYSL,RNLOC,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC MOMENT DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          HLS(I,J,1) = DYZLS(I,J)-DZYLS(I,J)
          HLS(I,J,2) = DZXLS(I,J)-DXZLS(I,J)
          HLS(I,J,3) = DXYLS(I,J)-DYXLS(I,J)
C
C         COMPONENT OVERLAP SL
          HSL(I,J,1) = DYZSL(I,J)-DZYSL(I,J)
          HSL(I,J,2) = DZXSL(I,J)-DXZSL(I,J)
          HSL(I,J,3) = DXYSL(I,J)-DYXSL(I,J)
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FULL LIST OF σ(2) MATRIX ELEMENTS                                C
C**********************************************************************C
C
C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
      DO IA=1,NDIM
        DO IK=1,NDIM
C
C         MATRIX ELEMENTS REQUIRE (OCC,UNOCC) COMBINATIONS ONLY
          IF(IA.GT.NSKP.AND.IA.LE.(NSKP+NOCC)) THEN
            IAOCC = 1
          ELSE
            IAOCC = 0
          ENDIF
          IF(IK.GT.NSKP.AND.IK.LE.(NSKP+NOCC)) THEN
            IKOCC = 1
          ELSE
            IKOCC = 0
          ENDIF
C
          IF(IAOCC.EQ.IKOCC) GOTO 150
C
C         LOOP OVER CARTESIAN INDEX IX
          DO IX=1,3
C
C           INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
            BC = DCMPLX(0.0D0,0.0D0)
            HC = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER FOCK MATRIX ADDRESSES
            DO I=1,NDIM-NSKP
              DO J=1,NDIM-NSKP
C
                K = I+NSKP
                L = J+NSKP
C
C               ACCOUNT ONLY FOR LS AND SL COMPONENT OVERLAPS
                BC = BC + DCONJG(COEF(I,IA))*COEF(L,IK)*BLS(I,J,IX)
     &                  + DCONJG(COEF(K,IA))*COEF(J,IK)*BSL(I,J,IX)
                HC = HC + DCONJG(COEF(I,IA))*COEF(L,IK)*HLS(I,J,IX)
     &                  + DCONJG(COEF(K,IA))*COEF(J,IK)*HSL(I,J,IX)
C
              ENDDO
            ENDDO
C
C           SAVE COUNTERS TO MATRICES
            VB(IA,IK,IX) = BC
            VH(IA,IK,IX) = HC
C
          ENDDO
C
150       CONTINUE
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF SECOND-ORDER CROSSING TERM, E^(2)_CROSS.          C
C**********************************************************************C
C
C     INITIALISE σ MATRICES
      DO IX=1,3
        DO JX=1,3
          SIG2P(IX,JX) = DCMPLX(0.0D0,0.0D0)
          SIG2N(IX,JX) = DCMPLX(0.0D0,0.0D0)
          SIGMA(IX,JX) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER ALL OCCUPIED ORBITALS IA
      DO IA=NSKP+1,NSKP+NOCC
C
C       EIGENVALUE ENERGY FOR THIS ORBITAL
        EA = EIGN(IA)
C
C       POSITIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E+ STATES
        DO IK=NSKP+NOCC+1,NDIM
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EA-EIGN(IK)
C
C         LOOP OVER CARTESIAN INDICES IX AND JX
          DO IX=1,3
            DO JX=1,3
C
C             CONTRIBUTIONS TO EACH PART OF THE S-TENSOR
              SIG2P(IX,JX) = SIG2P(IX,JX)
     &                      +        VB(IA,IK,IX)*VH(IK,IA,JX)/EAK
     &                      + DCONJG(VB(IA,IK,IX)*VH(IK,IA,JX)/EAK)
C
            ENDDO
          ENDDO
C
C       END POSITIVE-ENERGY LOOP
        ENDDO
C
C       NEGATIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E- STATES
        DO IK=1,NSKP
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EA-EIGN(IK)
C
C         LOOP OVER CARTESIAN INDICES IX AND JX
          DO IX=1,3
            DO JX=1,3
C
C             CONTRIBUTIONS TO EACH PART OF THE S-TENSOR
              SIG2N(IX,JX) = SIG2N(IX,JX)
     &                      +        VB(IA,IK,IX)*VH(IK,IA,JX)/EAK
     &                      + DCONJG(VB(IA,IK,IX)*VH(IK,IA,JX)/EAK)
C
            ENDDO
          ENDDO
C
C       END NEGATIVE-ENERGY LOOP
        ENDDO
C
C     END LOOP OVER OCCUPIED ORBITALS
      ENDDO
C
C**********************************************************************C
C     SUMMARY OF RESULTS                                               C
C**********************************************************************C
C
C     CONVERT TO NMR TMS REFERENCE FORM (PPM)
      DO IX=1,3
        DO JX=1,3
          SIG1G(IX,JX) = 0.5D0*1.0D6*SIG1G(IX,JX)
          SIG2P(IX,JX) = 0.5D0*1.0D6*SIG2P(IX,JX)
          SIG2N(IX,JX) = 0.5D0*1.0D6*SIG2N(IX,JX)
          SIGMA(IX,JX) = SIG1G(IX,JX) 
     &                 + SIG2P(IX,JX) + SIG2N(IX,JX)
        ENDDO
      ENDDO
C
C     SPHERICAL AVERAGE
      D1G = 0.0D0
      D2P = 0.0D0
      D2N = 0.0D0
      DSG = 0.0D0
      DO IX=1,3
        D1G = D1G + DREAL(SIG1G(IX,IX))/3.0D0
        D2P = D2P + DREAL(SIG2P(IX,IX))/3.0D0
        D2N = D2N + DREAL(SIG2N(IX,IX))/3.0D0
        DSG = DSG + DREAL(SIGMA(IX,IX))/3.0D0
      ENDDO
C
20    FORMAT(17X,'(',F16.10,',',F16.10,',',F16.10,')')
21    FORMAT(9X,A,1X,'(',F16.10,',',F16.10,',',F16.10,')')
C
      WRITE(6, *) 'Nuclear shielding tensor analysis:'
      WRITE(7, *) 'Nuclear shielding tensor analysis:'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     SUMMARISE THE TENSOR ELEMENTS
      WRITE(6, *) 'Gauge-dependent shielding tensor (ppm au):'
      WRITE(7, *) 'Gauge-dependent shielding tensor (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20)           (DREAL(SIG1G(1,JX)),JX=1,3)
      WRITE(7,20)           (DREAL(SIG1G(1,JX)),JX=1,3)
      WRITE(6,21) ' σ(1) =',(DREAL(SIG1G(2,JX)),JX=1,3)
      WRITE(7,21) ' σ(1) =',(DREAL(SIG1G(2,JX)),JX=1,3)
      WRITE(6,20)           (DREAL(SIG1G(3,JX)),JX=1,3)
      WRITE(7,20)           (DREAL(SIG1G(3,JX)),JX=1,3)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6, *) 'Paramagnetic shielding tensor (ppm au):'
      WRITE(7, *) 'Paramagnetic shielding tensor (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20)           (DREAL(SIG2P(1,JX)),JX=1,3)
      WRITE(7,20)           (DREAL(SIG2P(1,JX)),JX=1,3)
      WRITE(6,21) 'σ(2+) =',(DREAL(SIG2P(2,JX)),JX=1,3)
      WRITE(7,21) 'σ(2+) =',(DREAL(SIG2P(2,JX)),JX=1,3)
      WRITE(6,20)           (DREAL(SIG2P(3,JX)),JX=1,3)
      WRITE(7,20)           (DREAL(SIG2P(3,JX)),JX=1,3)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6, *) 'Diamagnetic shielding tensor (ppm au):'
      WRITE(7, *) 'Diamagnetic shielding tensor (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20)           (DREAL(SIG2N(1,JX)),JX=1,3)
      WRITE(7,20)           (DREAL(SIG2N(1,JX)),JX=1,3)
      WRITE(6,21) 'σ(2-) =',(DREAL(SIG2N(2,JX)),JX=1,3)
      WRITE(7,21) 'σ(2-) =',(DREAL(SIG2N(2,JX)),JX=1,3)
      WRITE(6,20)           (DREAL(SIG2N(3,JX)),JX=1,3)
      WRITE(7,20)           (DREAL(SIG2N(3,JX)),JX=1,3)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6, *) 'Total nuclear magnetic shielding tensor (ppm au):'
      WRITE(7, *) 'Total nuclear magnetic shielding tensor (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20)           (DREAL(SIGMA(1,JX)),JX=1,3)
      WRITE(7,20)           (DREAL(SIGMA(1,JX)),JX=1,3)
      WRITE(6,21) '    σ =',(DREAL(SIGMA(2,JX)),JX=1,3)
      WRITE(7,21) '    σ =',(DREAL(SIGMA(2,JX)),JX=1,3)
      WRITE(6,20)           (DREAL(SIGMA(3,JX)),JX=1,3)
      WRITE(7,20)           (DREAL(SIGMA(3,JX)),JX=1,3)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
22    FORMAT(8X,'|',6X,A,8X,A,8X,A,2X,'|',7X,A)
23    FORMAT(1X,A,'|',F14.8,2X,F14.8,2X,F14.8,2X,'|',1X,F14.8)
      WRITE(6, *) 'Spherical averages (ppm au):'
      WRITE(7, *) 'Spherical averages (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'σ_(xx)  ','σ_(yy)  ','σ_(zz)  ','sig(tot)'
      WRITE(7,22) 'σ_(xx)  ','σ_(yy)  ','σ_(zz)  ','sig(tot)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'sig(1 )',(DREAL(SIG1G(IX,IX)),IX=1,3),D1G
      WRITE(7,23) 'sig(1 )',(DREAL(SIG1G(IX,IX)),IX=1,3),D1G
      WRITE(6,23) 'sig(2+)',(DREAL(SIG2P(IX,IX)),IX=1,3),D2P
      WRITE(7,23) 'sig(2+)',(DREAL(SIG2P(IX,IX)),IX=1,3),D2P
      WRITE(6,23) 'sig(2-)',(DREAL(SIG2N(IX,IX)),IX=1,3),D2N
      WRITE(7,23) 'sig(2-)',(DREAL(SIG2N(IX,IX)),IX=1,3),D2N
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'σ  ',(DREAL(SIGMA(IX,IX)),IX=1,3),DSG
      WRITE(7,23) 'σ  ',(DREAL(SIGMA(IX,IX)),IX=1,3),DSG
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE GTENSOR(GAUGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     GGGGGG TTTTTTTT EEEEEEEE NN    NN  SSSSSS   OOOOOO  RRRRRRR      C
C    GG    GG   TT    EE       NNN   NN SS    SS OO    OO RR    RR     C
C    GG         TT    EE       NNNN  NN SS       OO    OO RR    RR     C
C    GG         TT    EEEEEE   NN NN NN  SSSSSS  OO    OO RR    RR     C
C    GG   GGG   TT    EE       NN  NNNN       SS OO    OO RRRRRRR      C
C    GG    GG   TT    EE       NN   NNN SS    SS OO    OO RR    RR     C
C     GGGGGG    TT    EEEEEEEE NN    NN  SSSSSS   OOOOOO  RR    RR     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GTENSOR CALCULATES THE ELECTRONIC G-TENSOR AND THUS CHARACTERISES   C
C  THE MAGNETIC MOMENT AND GYROMAGNETIC RATIO FOR A MOLECULAR SYSTEM.  C
C  (IT IS ESSENTIALLY A PROPORTIONALITY CONSTANT THAT RELATES THE      C
C  OBSERVED MAGNETIC MOMENTS MY OF A PARTICLE TO ITS ANGULAR MOMENTUM  C
C  QUANTUM NUMBER AND A UNIT OF MAGNETIC MOMENT.)                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION GAUGE(3)
C
      COMPLEX*16 CONE,SUMX,SUMY,SUMZ
      COMPLEX*16 VX(MDM),VY(MDM),VZ(MDM)
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 WX(MDM,MDM),WY(MDM,MDM),WZ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     ANOMALOUS MAGNETIC MOMENT OF THE ELECTRON
      ANOMAG = GFREE-2.0D0
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In GTENSOR: not possible for this Hamiltonian!'
        WRITE(7, *) 'In GTENSOR: not possible for this Hamiltonian!'
      ENDIF
C
C**********************************************************************C
C     PREPARE MATRIX ELEMENT INTEGRALS                                 C
C**********************************************************************C
C
C     MATRIX ELEMENT INTEGRALS
      CALL VMOMNT1(DXYLS,GAUGE,2,1,2,1,2)
      CALL VMOMNT1(DXZLS,GAUGE,2,1,3,1,2)
      CALL VMOMNT1(DYXLS,GAUGE,2,2,1,1,2)
      CALL VMOMNT1(DYZLS,GAUGE,2,2,3,1,2)
      CALL VMOMNT1(DZXLS,GAUGE,2,3,1,1,2)
      CALL VMOMNT1(DZYLS,GAUGE,2,3,2,1,2)
C
      CALL VMOMNT1(DXYSL,GAUGE,3,1,2,1,2)
      CALL VMOMNT1(DXZSL,GAUGE,3,1,3,1,2)
      CALL VMOMNT1(DYXSL,GAUGE,3,2,1,1,2)
      CALL VMOMNT1(DYZSL,GAUGE,3,2,3,1,2)
      CALL VMOMNT1(DZXSL,GAUGE,3,3,1,1,2)
      CALL VMOMNT1(DZYSL,GAUGE,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         X-DIRECTION
          WX(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
          WX(I     ,J+NSKP) = DYZLS(I,J)-DZYLS(I,J)
          WX(I+NSKP,J     ) = DYZSL(I,J)-DZYSL(I,J)
          WX(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)
C
C         Y-DIRECTION
          WY(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
          WY(I     ,J+NSKP) = DZXLS(I,J)-DXZLS(I,J)
          WY(I+NSKP,J     ) = DZXSL(I,J)-DXZSL(I,J)
          WY(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)
C
C         Z-DIRECTION
          WZ(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
          WZ(I     ,J+NSKP) = DXYLS(I,J)-DYXLS(I,J)
          WZ(I+NSKP,J     ) = DXYSL(I,J)-DYXSL(I,J)
          WZ(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     COMPUTE EXPECTATION VALUES MANUALLY BECAUSE SPIN EIGENFUNCTIONS  C
C     ARE NOT THE SAME AS SPATIAL EIGENFUNCTIONS -- NEED LINEAR COMBO. C
C**********************************************************************C
C
29    FORMAT(1X,A,I3,A)
30    FORMAT(1X,A,2X,3(14X,'E^(',I1,')',A))
31    FORMAT(1X,I3,' Re:',F21.9,F22.9,F22.9)
32    FORMAT(4X,' Im:',F21.9,F22.9,F22.9)
      WRITE(6,29) 'Expectation value for each orbital IOCC (in MHz):'
      WRITE(7,29) 'Expectation value for each orbital IOCC (in MHz):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
      WRITE(7,30) 'Orb.',1,'[X]',1,'[Y]',1,'[Z]'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     LOOP OVER ORBITALS
      DO IOCC=NSKP+1,NSKP+NOCC+2
C
C       SOLUTIONS MUST COUPLE IN KRAMER PAIRS
        IF(MOD(IOCC,2).EQ.0) THEN
          NP =-1
        ELSE
          NP = 1
        ENDIF
C
C       INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
        SUMX = DCMPLX(0.0D0,0.0D0)
        SUMY = DCMPLX(0.0D0,0.0D0)
        SUMZ = DCMPLX(0.0D0,0.0D0)
C
C       LOOP OVER FOCK MATRIX ADDRESSES
        DO I=1,NDIM
          DO J=1,NDIM
C
C           ADDITIONS TO EACH CARTESIAN COMPONENT
            SUMX = SUMX + DCONJG(COEF(I,IOCC))*COEF(J,IOCC+NP)*WX(I,J)
            SUMY = SUMY + DCONJG(COEF(I,IOCC))*COEF(J,IOCC+NP)*WY(I,J)
            SUMZ = SUMZ + DCONJG(COEF(I,IOCC))*COEF(J,IOCC   )*WZ(I,J)
C
          ENDDO
        ENDDO
C
C       SAVE SUM
        VX(IOCC) = SUMX
        VY(IOCC) =-SUMY*CONE
        VZ(IOCC) = SUMZ
C
      ENDDO
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_GTENSOR_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=NSKP+1,NSKP+NOCC+2
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC-NSKP,2.0D0*CV*DABS(DREAL(VX(IOCC)))+ANOMAG,
     &                          2.0D0*CV*DABS(DREAL(VY(IOCC)))+ANOMAG,
     &                          2.0D0*CV*DABS(DREAL(VZ(IOCC)))+ANOMAG
          WRITE(7,31) IOCC-NSKP,2.0D0*CV*DABS(DREAL(VX(IOCC)))+ANOMAG,
     &                          2.0D0*CV*DABS(DREAL(VY(IOCC)))+ANOMAG,
     &                          2.0D0*CV*DABS(DREAL(VZ(IOCC)))+ANOMAG
          WRITE(8,31) IOCC-NSKP,2.0D0*CV*DABS(DREAL(VX(IOCC)))+ANOMAG,
     &                          2.0D0*CV*DABS(DREAL(VY(IOCC)))+ANOMAG,
     &                          2.0D0*CV*DABS(DREAL(VZ(IOCC)))+ANOMAG
C
          WRITE(6,32) 2.0D0*CV*DABS(DIMAG(VX(IOCC))),
     &                2.0D0*CV*DABS(DIMAG(VY(IOCC))),
     &                2.0D0*CV*DABS(DIMAG(VZ(IOCC)))
          WRITE(7,32) 2.0D0*CV*DABS(DIMAG(VX(IOCC))),
     &                2.0D0*CV*DABS(DIMAG(VY(IOCC))),
     &                2.0D0*CV*DABS(DIMAG(VZ(IOCC)))
          WRITE(8,32) 2.0D0*CV*DABS(DIMAG(VX(IOCC))),
     &                2.0D0*CV*DABS(DIMAG(VY(IOCC))),
     &                2.0D0*CV*DABS(DIMAG(VZ(IOCC)))
C
C         SEPARATOR FOR VIRTUAL SPECTRUM
          IF(IOCC.EQ.NSKP+NOCC) THEN
            WRITE(6, *) REPEAT('=',72)
            WRITE(7, *) REPEAT('=',72)
            WRITE(8, *) REPEAT('=',72)
          ELSEIF(IOCC.LT.NSKP+NOCC+2) THEN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(8, *) REPEAT('-',72)
          ENDIF
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE EEDMSML(IZ,IOCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C EEEEEEEE EEEEEEEE DDDDDDD  MM       MM  SSSSSS  MM       MM LL       C
C EE       EE       DD    DD MMM     MMM SS    SS MMM     MMM LL       C
C EE       EE       DD    DD MMMM   MMMM SS       MMMM   MMMM LL       C
C EEEEEE   EEEEEE   DD    DD MM MM MM MM  SSSSSS  MM MM MM MM LL       C
C EE       EE       DD    DD MM  MMM  MM       SS MM  MMM  MM LL       C
C EE       EE       DD    DD MM   M   MM SS    SS MM   M   MM LL       C
C EEEEEEEE EEEEEEEE DDDDDDD  MM       MM  SSSSSS  MM       MM LLLLLLLL C
C                                                                      C
C -------------------------------------------------------------------- C
C  EEDMSML PERFORMS AN ATOM-CENTRED PT-ODD ELECTRON EDM ANALYSIS,      C
C  USING THE SMALL-SMALL OVERLAP AND ELECTRIC FIELD OPERATOR.          C
C  THE DIPOLE MOMENT STRENGTH 'DE' HAS BEEN FACTORED AWAY FROM THIS.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ   - THE NUCLEAR CENTRE OF INTEREST.                            C
C  ▶ IOCC - THE ORBITAL OF INTEREST.                                   C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION XYZ(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 EFLDX(MDM,MDM),EFLDY(MDM,MDM),EFLDZ(MDM,MDM)
      COMPLEX*16 EFLD(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In EEDMSML: not possible for this Hamiltonian!'
        WRITE(7, *) 'In EEDMSML: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     INITIALISE TEMPORARY STORAGE ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
          EFLDX(I,J) = DCMPLX(0.0D0,0.0D0)
          EFLDY(I,J) = DCMPLX(0.0D0,0.0D0)
          EFLDZ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     ADJUST NUCLEAR CHARGE OF CENTRE IZ
      DO IX=1,3
        XYZ(IX) = BXYZ(IX,IZ)
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VMNPOLE(EFLDX,XYZ,4,1,1,1,2)
      CALL VMNPOLE(EFLDY,XYZ,4,2,2,1,2)
      CALL VMNPOLE(EFLDZ,XYZ,4,3,3,1,2)
C
C     MULTIPLY RESULTS BY APPROPRIATE FACTOR
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EFLD(I,J) = EFLDX(I,J)+EFLDY(I,J)+EFLDZ(I,J)
          EFLD(I,J) = 2.0D0*ZNUC(IZ)*EFLD(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,EMPTY,EMPTY,EMPTY,EFLD,NORD)
C
C     MATRIX ELEMENT (WITH |DE| FACTORED OUT) IN HARTEE
      WDAU = ABS(V1(NSKP+IOCC,NSKP+IOCC))
C
C     MATRIX ELEMENT IN HERTZ
      WDHZ = WDAU*CHZ
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_EEDMSML_V.dat',STATUS='UNKNOWN')
      WRITE(11, *) V1(IOCC,IOCC)
      CLOSE(UNIT=11)
C
29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
30    FORMAT(24X,ES17.10,1X,A)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
      WRITE(7,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
      WRITE(6,30)                                WDHZ,'Hz'
      WRITE(7,30)                                WDHZ,'Hz'
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE EEDMEFF(IOCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE EEEEEEEE DDDDDDD  MM       MM EEEEEEEE FFFFFFFF FFFFFFFF  C
C   EE       EE       DD    DD MMM     MMM EE       FF       FF        C
C   EE       EE       DD    DD MMMM   MMMM EE       FF       FF        C
C   EEEEEE   EEEEEE   DD    DD MM MM MM MM EEEEEE   FFFFFF   FFFFFF    C
C   EE       EE       DD    DD MM  MMM  MM EE       FF       FF        C
C   EE       EE       DD    DD MM   M   MM EE       FF       FF        C
C   EEEEEEEE EEEEEEEE DDDDDDD  MM       MM EEEEEEEE FF       FF        C
C                                                                      C
C -------------------------------------------------------------------- C
C  EEDMEFF PERFORMS ONE-BODY EFFECTIVE ELECTRON EDM ANALYSIS.          C
C  THE DIPOLE MOMENT STRENGTH 'DE' HAS BEEN FACTORED AWAY FROM THIS.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IOCC - THE ORBITAL OF INTEREST.                                   C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 CONE
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 PLS(MDM,MDM),PSL(MDM,MDM)
      COMPLEX*16 EFLD(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In EEDMEFF: not possible for this Hamiltonian!'
        WRITE(7, *) 'In EEDMEFF: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     INITIALISE TEMPORARY STORAGE ARRAYS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          PLS(I,J) = DCMPLX(0.0D0,0.0D0)
          PSL(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VLPLACE(PLS,2,0,1,2)
      CALL VLPLACE(PSL,3,0,1,2)
C
C     MULTIPLY RESULTS BY APPROPRIATE FACTOR
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          PLS(I,J) =-2.0D0*CV*CONE*PLS(I,J)
          PSL(I,J) = 2.0D0*CV*CONE*PSL(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,EMPTY,PLS,PSL,EMPTY,NORD)
C
C     MATRIX ELEMENT (WITH |DE| FACTORED OUT) IN HARTEE
      WDAU = ABS(V1(NSKP+IOCC,NSKP+IOCC))
C
C     MATRIX ELEMENT IN HERTZ
      WDHZ = WDAU*CHZ
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_EEDMEFF_V.dat',STATUS='UNKNOWN')
      WRITE(11, *) V1(IOCC,IOCC)
      CLOSE(UNIT=11)
C
29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
30    FORMAT(24X,ES17.10,1X,A)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
      WRITE(7,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
      WRITE(6,30)                                WDHZ,'Hz'
      WRITE(7,30)                                WDHZ,'Hz'
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ENHANFC(IOCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    EEEEEEEE NN    NN HH    HH    AA    NN    NN FFFFFFFF CCCCCC      C
C    EE       NNN   NN HH    HH   AAAA   NNN   NN FF      CC    CC     C
C    EE       NNNN  NN HH    HH  AA  AA  NNNN  NN FF      CC           C
C    EEEEEE   NN NN NN HHHHHHHH AA    AA NN NN NN FFFFFF  CC           C
C    EE       NN  NNNN HH    HH AAAAAAAA NN  NNNN FF      CC           C
C    EE       NN   NNN HH    HH AA    AA NN   NNN FF      CC    CC     C
C    EEEEEEEE NN    NN HH    HH AA    AA NN    NN FF       CCCCCC      C
C                                                                      C
C -------------------------------------------------------------------- C
C  ENHANFC CALCULATES THE ELECTRON EDM ENHANCEMENT FACTOR VALUE        C
C  AS GIVEN IN (10.10) OF HAAKON SKAANE'S PHD THESIS.                  C
C -------------------------------------------------------------------- C
C  ▶ SINCE THE R-VECTOR IS A CROSSING TERM IN SECOND ORDER P.T.,       C
C    CALCULATIONS HERE ARE DONE EXPLICITLY.                            C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION GAUGE(3)
C
      COMPLEX*16 CONE
      COMPLEX*16 SC,PC
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 VLL0X(MDM,MDM),VLL0Y(MDM,MDM),VLL0Z(MDM,MDM),
     &           VSS0X(MDM,MDM),VSS0Y(MDM,MDM),VSS0Z(MDM,MDM),
     &           VLS0(MDM,MDM),VSL0(MDM,MDM)
      COMPLEX*16 SLL(MDM,MDM,3),SSS(MDM,MDM,3),
     &           PLS(MDM,MDM),PSL(MDM,MDM)
      COMPLEX*16 VS(MDM,MDM,3),VP(MDM,MDM)
      COMPLEX*16 RNEG(3),RPOS(3),RTOT(3)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In ENHANFC: not possible for this Hamiltonian!'
        WRITE(7, *) 'In ENHANFC: not possible for this Hamiltonian!'
      ENDIF
C
C**********************************************************************C
C     PREPARATION OF MATRIX ELEMENTS                                   C
C**********************************************************************C
C
C     DEFINE 'GAUGE' AS THE ORIGIN
      DO IX=1,3
        GAUGE(IX) = 0.0D0
      ENDDO
C
C     FIRST MOMENT MATRIX ELEMENTS
      CALL VMOMNT1(VLL0X,GAUGE,1,0,1,1,2)
      CALL VMOMNT1(VLL0Y,GAUGE,1,0,2,1,2)
      CALL VMOMNT1(VLL0Z,GAUGE,1,0,3,1,2)
C
      CALL VMOMNT1(VSS0X,GAUGE,4,0,1,1,2)
      CALL VMOMNT1(VSS0Y,GAUGE,4,0,2,1,2)
      CALL VMOMNT1(VSS0Z,GAUGE,4,0,3,1,2)
C
C     CONSTRUCT STARK SPLITTING MATRIX
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SLL(I,J,1) = VLL0X(I,J)
          SLL(I,J,2) = VLL0Y(I,J)
          SLL(I,J,3) = VLL0Z(I,J)
          SSS(I,J,1) = VSS0X(I,J)
          SSS(I,J,2) = VSS0Y(I,J)
          SSS(I,J,3) = VSS0Z(I,J)
        ENDDO
      ENDDO
C
C     LAPLACIAN MATRIX ELEMENTS
      CALL VLPLACE(VLS0,2,0,1,2)
      CALL VLPLACE(VSL0,3,0,1,2)
C
C     CONSTRUCT EFFECTIVE EDM OPERATOR BY MULTIPLICATION
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VLS0(I,J) = 2.0D0*CV*CONE*VLS0(I,J)
          VSL0(I,J) =-2.0D0*CV*CONE*VSL0(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FULL LIST OF FIRST-ORDER TERMS                                   C
C**********************************************************************C
C
C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
      DO IA=1,NDIM
        DO IK=1,NDIM
C
C         MATRIX ELEMENTS REQUIRE (OCC,UNOCC) COMBINATIONS ONLY
          IF(IA.GT.NSKP.AND.IA.LE.(NSKP+NOCC+IOCC)) THEN
            IAOCC = 1
          ELSE
            IAOCC = 0
          ENDIF
          IF(IK.GT.NSKP.AND.IK.LE.(NSKP+NOCC+IOCC)) THEN
            IKOCC = 1
          ELSE
            IKOCC = 0
          ENDIF
C
          IF(IAOCC.EQ.IKOCC) GOTO 150
C
C         LOOP OVER CARTESIAN INDEX IX
          DO IX=1,3
C
C           INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
            SC = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER FOCK MATRIX ADDRESSES
            DO I=1,NDIM-NSKP
              DO J=1,NDIM-NSKP
C
                K = I+NSKP
                L = J+NSKP
C
C               ACCOUNT ONLY FOR LL AND SS COMPONENT OVERLAPS
                SC = SC + DCONJG(COEF(I,IA))*COEF(J,IK)*SLL(I,J,IX)
     &                  + DCONJG(COEF(K,IA))*COEF(L,IK)*SSS(I,J,IX)
C
              ENDDO
            ENDDO
C
C           SAVE COUNTERS TO MATRICES
            VS(IA,IK,IX) = SC
C
          ENDDO
C
C         INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
          PC = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FOCK MATRIX ADDRESSES
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
C
              K = I+NSKP
              L = J+NSKP
C
C             ACCOUNT ONLY FOR LS AND SL COMPONENT OVERLAPS
              PC = PC + DCONJG(COEF(I,IA))*COEF(L,IK)*VLS0(I,J)
     &                + DCONJG(COEF(K,IA))*COEF(J,IK)*VSL0(I,J)
C
            ENDDO
          ENDDO
C
C         SAVE COUNTERS TO MATRICES
          VP(IA,IK) = PC
C
150       CONTINUE
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF SECOND-ORDER CROSSING TERM, E^(2)_CROSS.          C
C**********************************************************************C
C
C     INITIALISE R VECTOR
      DO IX=1,3
        RPOS(IX) = DCMPLX(0.0D0,0.0D0)
        RNEG(IX) = DCMPLX(0.0D0,0.0D0)
        RTOT(IX) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     LOOP OVER ALL OCCUPIED ORBITALS IA
      DO IA=NSKP+1,NSKP+NOCC+IOCC
C
C       EIGENVALUE ENERGY FOR THIS ORBITAL
        EA = EIGN(IA)
C
C       POSITIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E+ STATES
        DO IK=NSKP+NOCC+IOCC+1,NDIM
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EA-EIGN(IK)
C
C         GENENERATE ENERGY CONDITIONAL
          IF(DABS(EAK).LT.1.0D-3) GOTO 81
C
C         LOOP OVER CARTESIAN INDICES IX
          DO IX=1,3
C
C           CONTRIBUTIONS TO EACH PART OF THE CORRECTION
            RPOS(IX) = RPOS(IX)
     &                 +        VS(IA,IK,IX)*VP(IK,IA)/EAK
     &                 + DCONJG(VS(IA,IK,IX)*VP(IK,IA)/EAK)
          ENDDO
C
81        CONTINUE
C
C       END POSITIVE-ENERGY LOOP
        ENDDO
C
C       NEGATIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E- STATES
        DO IK=1,NSKP
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EA-EIGN(IK)
C
C         GENENERATE ENERGY CONDITIONAL
          IF(DABS(EAK).LT.1.0D-3) GOTO 82
C
C         LOOP OVER CARTESIAN INDICES IX
          DO IX=1,3
C
C           CONTRIBUTIONS TO EACH PART OF THE CORRECTION
            RNEG(IX) = RNEG(IX)
     &                 +        VS(IA,IK,IX)*VP(IK,IA)/EAK
     &                 + DCONJG(VS(IA,IK,IX)*VP(IK,IA)/EAK)
C
          ENDDO
C
82        CONTINUE
C
C       END NEGATIVE-ENERGY LOOP
        ENDDO
C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
C     END LOOP OVER OCCUPIED ORBITALS
      ENDDO
C
C     TOTAL CONTRIBUTION
      DO IX=1,3
        RTOT(IX) = RPOS(IX) + RNEG(IX)
      ENDDO
C
C     SPHERICAL AVERAGE
      DPOS = 0.0D0
      DNEG = 0.0D0
      DTOT = 0.0D0
      DO IX=1,3
        DPOS = DPOS + DREAL(RPOS(IX))**2
        DNEG = DNEG + DREAL(RNEG(IX))**2
        DTOT = DTOT + DREAL(RTOT(IX))**2
      ENDDO
      DPOS = DSQRT(DPOS)
      DNEG = DSQRT(DNEG)
      DTOT = DSQRT(DTOT)
C
21    FORMAT(10X,A,1X,'(',F16.10,',',F16.10,',',F16.10,')')
22    FORMAT(8X,'|',9X,A,11X,A,11X,A,2X,'|',9X,A)
23    FORMAT(1X,A,2X,' |',F14.8,2X,F14.8,2X,F14.8,2X,'|',1X,F14.8)
      WRITE(6, *) 'eEDM enhancement factor components (au):'
      WRITE(7, *) 'eEDM enhancement factor components (au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'R_(x)','R_(y)','R_(z)','R(tot)'
      WRITE(7,22) 'R_(x)','R_(y)','R_(z)','R(tot)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'R(+)',(DREAL(RPOS(IX)),IX=1,3),DPOS
      WRITE(7,23) 'R(+)',(DREAL(RPOS(IX)),IX=1,3),DPOS
      WRITE(6,23) 'R(-)',(DREAL(RNEG(IX)),IX=1,3),DNEG
      WRITE(7,23) 'R(-)',(DREAL(RNEG(IX)),IX=1,3),DNEG
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'R(t)',(DREAL(RTOT(IX)),IX=1,3),DTOT
      WRITE(7,23) 'R(t)',(DREAL(RTOT(IX)),IX=1,3),DTOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE SCLPTEN(IZ,IOCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS   CCCCCC  LL       PPPPPPP TTTTTTTT EEEEEEEE NN    NN    C
C     SS    SS CC    CC LL       PP    PP   TT    EE       NNN   NN    C
C     SS       CC       LL       PP    PP   TT    EE       NNNN  NN    C
C      SSSSSS  CC       LL       PP    PP   TT    EEEEEE   NN NN NN    C
C           SS CC       LL       PPPPPPP    TT    EE       NN  NNNN    C
C     SS    SS CC    CC LL       PP         TT    EE       NN   NNN    C
C      SSSSSS   CCCCCC  LLLLLLLL PP         TT    EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  SCLPTEN GIVE A SCALAR PT-ODD ELECTRON-NUCLEUS INTERACTION ANALYSIS. C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 CONE
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 VNUCLS(MDM,MDM),VNUCSL(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In SCLPTEN: not possible for this Hamiltonian!'
        WRITE(7, *) 'In SCLPTEN: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     INITIALISE TEMPORARY STORAGE ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
          VNUCLS(I,J) = DCMPLX(0.0D0,0.0D0)
          VNUCSL(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     NUCLEAR CHARGE FOR THIS CENTRE
      ZCNT = ZNUC(IZ)
C
C     GENERATE NUCLEAR ATTRACTION OVERLAP INTEGRALS
      CALL VNCATRC(VNUCLS,ZCNT,IZ,2,0,1,2)
      CALL VNCATRC(VNUCSL,ZCNT,IZ,3,0,1,2)
C
C     MULTIPLY RESULTS BY NUMERICAL FACTORS (NOT GFRMI OR GPT1)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VNUCLS(I,J) = CONE*VNUCLS(I,J)/TW12
          VNUCSL(I,J) =-CONE*VNUCSL(I,J)/TW12
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,EMPTY,VNUCLS,VNUCSL,EMPTY,NORD)
C
C     MATRIX ELEMENT (MULTIPLIED BY GFRMI) IN HARTEE
      WPAU = ABS(V1(NSKP+IOCC,NSKP+IOCC))*GFRMI
C
C     MATRIX ELEMENT IN HERTZ
      WPHZ = WPAU*CHZ
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_SCLPTEN_V.dat',STATUS='UNKNOWN')
      WRITE(11, *) V1(IOCC,IOCC)
      CLOSE(UNIT=11)
C
29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
30    FORMAT(25X,ES17.10,1X,A)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
      WRITE(7,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
      WRITE(6,30)                                 WPHZ,'Hz'
      WRITE(7,30)                                 WPHZ,'Hz'
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE VECPTEN(IZ,IOCC,ISPN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     VV    VV EEEEEEEE CCCCCC  PPPPPPP TTTTTTTT EEEEEEEE NN    NN     C
C     VV    VV EE      CC    CC PP    PP   TT    EE       NNN   NN     C
C     VV    VV EE      CC       PP    PP   TT    EE       NNNN  NN     C
C     VV    VV EEEEEE  CC       PP    PP   TT    EEEEEE   NN NN NN     C
C      VV  VV  EE      CC       PPPPPPP    TT    EE       NN  NNNN     C
C       VVVV   EE      CC    CC PP         TT    EE       NN   NNN     C
C        VV    EEEEEEEE CCCCCC  PP         TT    EEEEEEEE NN    NN     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VECPTEN GIVES A VECTOR PT-ODD ELECTRON-NUCLEUS INTERACTION ANALYSIS.C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 CONE
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 VXLS(MDM,MDM),VYLS(MDM,MDM),VZLS(MDM,MDM),VLS(MDM,MDM),
     &           VXSL(MDM,MDM),VYSL(MDM,MDM),VZSL(MDM,MDM),VSL(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In VECPTEN: not possible for this Hamiltonian!'
        WRITE(7, *) 'In VECPTEN: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     INITIALISE TEMPORARY STORAGE ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
C
          VXLS(I,J) = DCMPLX(0.0D0,0.0D0)
          VYLS(I,J) = DCMPLX(0.0D0,0.0D0)
          VZLS(I,J) = DCMPLX(0.0D0,0.0D0)
C
          VXSL(I,J) = DCMPLX(0.0D0,0.0D0)
          VYSL(I,J) = DCMPLX(0.0D0,0.0D0)
          VZSL(I,J) = DCMPLX(0.0D0,0.0D0)
C
          VLS(I,J)  = DCMPLX(0.0D0,0.0D0)
          VSL(I,J)  = DCMPLX(0.0D0,0.0D0)
C
        ENDDO
      ENDDO
C
C     EFFECTIVE NUCLEAR CHARGE (USING THE NORMALISED DISTRIBUTION HERE)
      ZCNT = 1.0D0
C
C     GENERATE NUCLEAR ATTRACTION OVERLAP INTEGRALS
      CALL VNCATRC(VXLS,ZCNT,IZ,2,1,1,2)
      CALL VNCATRC(VYLS,ZCNT,IZ,2,2,1,2)
      CALL VNCATRC(VZLS,ZCNT,IZ,2,3,1,2)
      CALL VNCATRC(VXSL,ZCNT,IZ,3,1,1,2)
      CALL VNCATRC(VYSL,ZCNT,IZ,3,2,1,2)
      CALL VNCATRC(VZSL,ZCNT,IZ,3,3,1,2)
C
C     MULTIPLY RESULTS BY NUMERICAL FACTORS (NOT GFRMI OR GPT1)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
          VLS(I,J) = VXLS(I,J)+VYLS(I,J)+VZLS(I,J)
          VSL(I,J) = VXSL(I,J)+VYSL(I,J)+VZSL(I,J)
C
          VLS(I,J) = 0.5D0*CONE*VLS(I,J)*DFLOAT(ISPN)/TW12
          VSL(I,J) =-0.5D0*CONE*VSL(I,J)*DFLOAT(ISPN)/TW12
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,EMPTY,VLS,VSL,EMPTY,NORD)
C
C     MATRIX ELEMENT (MULTIPLIED BY GFRMI) IN HARTEE
      WPAU = ABS(V1(NSKP+IOCC,NSKP+IOCC))*GFRMI
C
C     MATRIX ELEMENT IN HERTZ
      WPHZ = WPAU*CHZ
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_VECPTEN_V.dat',STATUS='UNKNOWN')
      WRITE(11, *) V1(IOCC,IOCC)
      CLOSE(UNIT=11)
C
29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
30    FORMAT(25X,ES17.10,1X,A)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
      WRITE(7,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
      WRITE(6,30)                                 WPHZ,'Hz'
      WRITE(7,30)                                 WPHZ,'Hz'
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE NUCMAGQ(IZ,ISPN,LPRT,IOCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C NN    NN UU    UU  CCCCCC  MM       MM    AA     GGGGGG    QQQQQQ    C
C NNN   NN UU    UU CC    CC MMM     MMM   AAAA   GG    GG  QQ    QQ   C
C NNNN  NN UU    UU CC       MMMM   MMMM  AA  AA  GG       QQ      QQ  C
C NN NN NN UU    UU CC       MM MM MM MM AA    AA GG       QQ      QQ  C
C NN  NNNN UU    UU CC       MM  MMM  MM AAAAAAAA GG   GGG QQ      QQ  C
C NN   NNN UU    UU CC    CC MM   M   MM AA    AA GG    GG  QQ    QQ   C
C NN    NN  UUUUUU   CCCCCC  MM       MM AA    AA  GGGGGG    QQQQQQ QQ C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCMAGQ GIVES A NUCLEAR MAGNETIC QUADRUPOLE INTERACTION ANALYSIS    C
C  AS A SINGLE UNPAIRED PROTON IN A SPHERICAL NUCLEUS INTERACTS WITH   C
C  THE MAGNETIC FIELD OF ELECTRONS IN THE SYSTEM. THE PROTON HAS MASS  C
C  PMSS AS WELL AS AN UNKNOWN EDM (PEDM) AND AN ORBITAL NUMBER LPRT,   C
C  WHILE ITS PARENT NUCLEUS HAS NUCLEAR SPIN ISPN (2*THE ACTUAL VALUE).C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 CONE
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 VXLS(MDM,MDM),VYLS(MDM,MDM),VZLS(MDM,MDM),VLS(MDM,MDM),
     &           VXSL(MDM,MDM),VYSL(MDM,MDM),VZSL(MDM,MDM),VSL(MDM,MDM)
C
      DIMENSION QMT(3,3),VECI(3)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In NUCMAGQ: not possible for this Hamiltonian!'
        WRITE(7, *) 'In NUCMAGQ: not possible for this Hamiltonian!'
      ENDIF
C
C     ANGULAR QUANTUM NUMBER FOR THE VALENCE PROTON
      IPOW = (ISPN+1-LPRT)/2
      KPRT = (-1)**IPOW
      KPRT = KPRT*(ISPN+1)/2
C
C     INTERACTION CONSTANT (NOT INCLUDING PROTON EDM)
      MNUM = (ISPN-1)*(1-2*KPRT)
      MDEN = ISPN+2
      CALM = DFLOAT(MNUM)/(CV*PMSS*DFLOAT(MDEN))
C
C     PRE-FACTOR FOR NUCLEAR MAGNETIC QUADRUPOLE MOMENT TENSOR
      IF(ISPN.NE.1) THEN
        PRE = 3.0D0*CALM/DFLOAT(ISPN*(ISPN-1))
      ELSE
        PRE = 0.0D0
      ENDIF

      WRITE(*,*) ISPN,LPRT,KPRT,CALM,PRE
C
C     NUCLEAR SPIN AS A VECTOR
      VECI(1) = 0.0D0
      VECI(2) = 0.0D0
      VECI(3) = 0.5D0*DFLOAT(ISPN)
C
C     QUADRUPOLE MOMENT TENSOR
      DO I=1,3
        DO J=1,3
          T1 = VECI(I)*VECI(J)
          T2 = VECI(J)*VECI(I)
          IF(I.EQ.J) THEN
            T3 = DFLOAT(ISPN*(ISPN+2))/6.0D0
          ELSE
            T3 = 0.0D0
          ENDIF
          QMT(I,J) = T1+T2+T3
        ENDDO
      ENDDO
C
C     PRINT BARE NUCLEAR QUADRUPOLE MOMENT TENSOR TIJ
      DO I=1,3
        WRITE(*,*) (QMT(I,J),J=1,3)
      ENDDO
C
      DO I=1,3
        DO J=1,3
          QMT(I,J) = PRE*QMT(I,J)
        ENDDO
      ENDDO
      
      WRITE(*,*) '----'
C
C     PRINT NUCLEAR QUADRUPOLE MOMENT TENSOR TIJ
      DO I=1,3
        WRITE(*,*) (QMT(I,J),J=1,3)
      ENDDO

      STOP
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     INITIALISE TEMPORARY STORAGE ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
C
          VXLS(I,J) = DCMPLX(0.0D0,0.0D0)
          VYLS(I,J) = DCMPLX(0.0D0,0.0D0)
          VZLS(I,J) = DCMPLX(0.0D0,0.0D0)
C
          VXSL(I,J) = DCMPLX(0.0D0,0.0D0)
          VYSL(I,J) = DCMPLX(0.0D0,0.0D0)
          VZSL(I,J) = DCMPLX(0.0D0,0.0D0)
C
          VLS(I,J)  = DCMPLX(0.0D0,0.0D0)
          VSL(I,J)  = DCMPLX(0.0D0,0.0D0)
C
        ENDDO
      ENDDO
C
C     EFFECTIVE NUCLEAR CHARGE (USING THE NORMALISED DISTRIBUTION HERE)
      ZCNT = 1.0D0
C
C     GENERATE NUCLEAR ATTRACTION OVERLAP INTEGRALS
      CALL VNCATRC(VXLS,ZCNT,IZ,2,1,1,2)
      CALL VNCATRC(VYLS,ZCNT,IZ,2,2,1,2)
      CALL VNCATRC(VZLS,ZCNT,IZ,2,3,1,2)
      CALL VNCATRC(VXSL,ZCNT,IZ,3,1,1,2)
      CALL VNCATRC(VYSL,ZCNT,IZ,3,2,1,2)
      CALL VNCATRC(VZSL,ZCNT,IZ,3,3,1,2)
C
C     MULTIPLY RESULTS BY NUMERICAL FACTORS (NOT GFRMI OR GPT1)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
          VLS(I,J) = VXLS(I,J)+VYLS(I,J)+VZLS(I,J)
          VSL(I,J) = VXSL(I,J)+VYSL(I,J)+VZSL(I,J)
C
          VLS(I,J) = 0.5D0*CONE*VLS(I,J)*DFLOAT(ISPN)/TW12
          VSL(I,J) =-0.5D0*CONE*VSL(I,J)*DFLOAT(ISPN)/TW12
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,EMPTY,VLS,VSL,EMPTY,NORD)
C
C     MATRIX ELEMENT (MULTIPLIED BY GFRMI) IN HARTEE
      WPAU = ABS(V1(NSKP+IOCC,NSKP+IOCC))*GFRMI
C
C     MATRIX ELEMENT IN HERTZ
      WPHZ = WPAU*CHZ
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_NUCMAGQ_V.dat',STATUS='UNKNOWN')
      WRITE(11, *) V1(IOCC,IOCC)
      CLOSE(UNIT=11)
C
29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
30    FORMAT(25X,ES17.10,1X,A)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
      WRITE(7,29) 'For IOCC =',IOCC,', W_{PT} = ',WPAU,'au'
      WRITE(6,30)                                 WPHZ,'Hz'
      WRITE(7,30)                                 WPHZ,'Hz'
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE PVIOLTN(NEUT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       PPPPPPP  VV    VV IIII OOOOOO  LL      TTTTTTTT NN    NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NNN   NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NNNN  NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NN NN NN       C
C       PPPPPPP   VV  VV   II OO    OO LL         TT    NN  NNNN       C
C       PP         VVVV    II OO    OO LL         TT    NN   NNN       C
C       PP          VV    IIII OOOOOO  LLLLLLLL   TT    NN    NN       C
C                                                                      C
C -------------------------------------------------------------------- C
C  PVIOLTN PERFORMS A P-ODD EFFECTIVE OPERATOR ANALYSIS.               C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ NEUT: LIST OF NEUTRON NUMBERS FOR EACH OF THE NUCLEAR CENTRES.    C
C -------------------------------------------------------------------- C
C TODO: THE IMAGINARY COMPONENTS OF EORB DO NOT SUM TO ZERO -- A       C
C       RELIC OF INTER-ATOMIC MATRIX ELEMENTS AND THE ASSIGNMENT OF    C
C       PHASE `CONE' TO THE SMALL COMPONENT TO ENSURE REAL ATOM-       C
C       CENTRED RESULTS. FOR DISCUSSIONS ON THIS, SEE:                 C
C       Phys. Chem. Chem. Phys., 2011, 13, 864–876                     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*2  ELMT(120),ELA
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 TITLE
C
      COMPLEX*16 ETOT,ETKR
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 VNUCLS(MDM,MDM),VNUCSL(MDM,MDM)
      COMPLEX*16 EORB(MCT,MDM)
      COMPLEX*16 ECNT(MCT),EKRM(MCT),EIOCC(MDM)
C
      DIMENSION QWNI(MCT),NEUT(MCT),NUCL(MCT),LF(MCT)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MDLV/ELMT
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In PVIOLTN: not possible for this Hamiltonian!'
        WRITE(7, *) 'In PVIOLTN: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE MATRICES
      DO IZ=1,NCNT
        DO IOCC=1,NOCC
          EORB(IZ,IOCC) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     PRE-FACTOR
      PRE = GFRMI*CHZ*0.5D0/TW12
C
C     LOOP OVER NUCLEAR CENTRES
      DO IZ=1,NCNT
C
C       NUMBER OF NUCLEONS NUCL AND WEAK NUCLEAR CHARGE QWNI
        NUCL(IZ) = INT(ZNUC(IZ))+NEUT(IZ)
        QWNI(IZ) =-DFLOAT(NEUT(IZ))+ZNUC(IZ)*(1.0D0-4.0D0*WEIN)
C
C       GENERATE NUCLEAR ATTRACTION OVERLAP INTEGRALS
        CALL VNCOLAP(VNUCLS,IZ,2,0,1,2)
        CALL VNCOLAP(VNUCSL,IZ,3,0,1,2)
C
C       LOOP OVER DISTINCT OCCUPIED KRAMERS ORBITALS
        DO IOCC=1,NOCC
C
C         OCCUPIED LABEL
          ISKP = IOCC+NSKP
C
C         LOOP OVER FOCK MATRIX ADDRESSES
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
C
C             LARGE AND SMALL CONTRIBUTIONS
              EORB(IZ,IOCC) = EORB(IZ,IOCC)
     &        + DCONJG(COEF(I     ,ISKP))*COEF(J+NSKP,ISKP)*VNUCLS(I,J)
     &        + DCONJG(COEF(I+NSKP,ISKP))*COEF(J     ,ISKP)*VNUCSL(I,J)
C
            ENDDO
          ENDDO
C
        ENDDO
C
      ENDDO
C
C     MULTIPLY BY PRE-FACTOR AND WEAK NUCLEAR CHARGE
      DO IZ=1,NCNT
        DO IOCC=1,NOCC
          EORB(IZ,IOCC) = PRE*QWNI(IZ)*EORB(IZ,IOCC)
        ENDDO
      ENDDO
C
C     TOTAL FOR EACH ELECTRON
      DO IOCC=1,NOCC
        EIOCC(IOCC) = DCMPLX(0.0D0,0.0D0)
        DO IZ=1,NCNT
          EIOCC(IOCC) = EIOCC(IOCC) + EORB(IZ,IOCC)
        ENDDO
      ENDDO
C
C     TOTAL FOR EACH NUCLEUS
      DO IZ=1,NCNT
        ECNT(IZ) = DCMPLX(0.0D0,0.0D0)
        DO IOCC=1,NOCC
          ECNT(IZ) = ECNT(IZ) + EORB(IZ,IOCC)
        ENDDO
      ENDDO
C
C     KRAMERS TOTAL FOR EACH NUCLEUS
      DO IZ=1,NCNT
        EKRM(IZ) = DCMPLX(0.0D0,0.0D0)
        DO IOCC=1,NOCC,2
          EKRM(IZ) = EKRM(IZ) + EORB(IZ,IOCC)
        ENDDO
      ENDDO
C
C     GRAND TOTAL
      ETOT = DCMPLX(0.0D0,0.0D0)
      ETKR = DCMPLX(0.0D0,0.0D0)
      DO IZ=1,NCNT
        ETOT = ETOT + ECNT(IZ)
        ETKR = ETKR + EKRM(IZ)
      ENDDO
C
C     LENGTH OF SPACINGS IN RESULTS TABLE
      LTB = 40+18*NCNT
      DO IZ=1,NCNT
        LF(IZ) = 14-LEN(TRIM(ELMT(INT(ZNUC(IZ)))))
      ENDDO
C
      WRITE(6, *) 'P-odd effective operator analysis (given in Hz):'
      WRITE(7, *) 'P-odd effective operator analysis (given in Hz):'
      WRITE(6, *) ''
      WRITE(7, *) ''
      WRITE(6, *) 'Table of real components ℜ (E):'
      WRITE(7, *) 'Table of real components ℜ (E):'
      WRITE(6, *) REPEAT('=',LTB)
      WRITE(7, *) REPEAT('=',LTB)
C
86    FORMAT(1X,A,3X,A,' |',5(A,I3,' ',A),1X,'|',12X,'Total')
87    FORMAT(2X,I3,1X,F14.6,1X,'|',1X,5(F17.6,1X),'|',F17.6)
88    FORMAT(1X,A,13X,'|',1X,5(F17.6,1X),'|',F17.6)
C
      WRITE(6,86) 'IOCC','Eigen (a.u.)',
     & (REPEAT(' ',LF(IZ)),NUCL(IZ),TRIM(ELMT(INT(ZNUC(IZ)))),IZ=1,NCNT)
      WRITE(7,86) 'IOCC','Eigen (a.u.)',
     & (REPEAT(' ',LF(IZ)),NUCL(IZ),TRIM(ELMT(INT(ZNUC(IZ)))),IZ=1,NCNT)
      WRITE(6, *) REPEAT('-',LTB)
      WRITE(7, *) REPEAT('-',LTB)
      DO IOCC=1,NOCC
        ISKP = IOCC+NSKP
        WRITE(6,87) IOCC,EIGN(ISKP),(DREAL(EORB(IZ,IOCC)),IZ=1,NCNT),
     &                                               DREAL(EIOCC(IOCC))
        WRITE(7,87) IOCC,EIGN(ISKP),(DREAL(EORB(IZ,IOCC)),IZ=1,NCNT),
     &                                               DREAL(EIOCC(IOCC))
      ENDDO
      WRITE(6, *) REPEAT('-',LTB)
      WRITE(7, *) REPEAT('-',LTB)
      WRITE(6,88) 'Nucleus',(DREAL(ECNT(IZ)),IZ=1,NCNT),DREAL(ETOT)
      WRITE(7,88) 'Nucleus',(DREAL(ECNT(IZ)),IZ=1,NCNT),DREAL(ETOT)
      WRITE(6,88) 'Kramers',(DREAL(EKRM(IZ)),IZ=1,NCNT),DREAL(ETKR)
      WRITE(7,88) 'Kramers',(DREAL(EKRM(IZ)),IZ=1,NCNT),DREAL(ETKR)
C
      WRITE(6, *) REPEAT('=',LTB)
      WRITE(7, *) REPEAT('=',LTB)
      WRITE(6, *) ''
      WRITE(7, *) ''
      WRITE(6, *) 'Table of imaginary components ℑ (E):'
      WRITE(7, *) 'Table of imaginary components ℑ (E):'
      WRITE(6, *) REPEAT('=',LTB)
      WRITE(7, *) REPEAT('=',LTB)
C
      WRITE(6,86) 'IOCC','Eigen (a.u.)',
     & (REPEAT(' ',LF(IZ)),NUCL(IZ),TRIM(ELMT(INT(ZNUC(IZ)))),IZ=1,NCNT)
      WRITE(7,86) 'IOCC','Eigen (a.u.)',
     & (REPEAT(' ',LF(IZ)),NUCL(IZ),TRIM(ELMT(INT(ZNUC(IZ)))),IZ=1,NCNT)
      WRITE(6, *) REPEAT('-',LTB)
      WRITE(7, *) REPEAT('-',LTB)
      DO IOCC=1,NOCC
        ISKP = IOCC+NSKP
        WRITE(6,87) IOCC,EIGN(ISKP),(DIMAG(EORB(IZ,IOCC)),IZ=1,NCNT),
     &                                               DIMAG(EIOCC(IOCC))
        WRITE(7,87) IOCC,EIGN(ISKP),(DIMAG(EORB(IZ,IOCC)),IZ=1,NCNT),
     &                                               DIMAG(EIOCC(IOCC))
      ENDDO
      WRITE(6, *) REPEAT('-',LTB)
      WRITE(7, *) REPEAT('-',LTB)
      WRITE(6,88) 'Nucleus',(DIMAG(ECNT(IZ)),IZ=1,NCNT),DIMAG(ETOT)
      WRITE(7,88) 'Nucleus',(DIMAG(ECNT(IZ)),IZ=1,NCNT),DIMAG(ETOT)
      WRITE(6,88) 'Kramers',(DIMAG(EKRM(IZ)),IZ=1,NCNT),DIMAG(ETKR)
      WRITE(7,88) 'Kramers',(DIMAG(EKRM(IZ)),IZ=1,NCNT),DIMAG(ETKR)
C
      WRITE(6, *) REPEAT('=',LTB)
      WRITE(7, *) REPEAT('=',LTB)
C
      RETURN
      END
C
C
      SUBROUTINE BETADCY(IZ,ZDCY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     BBBBBBB  EEEEEEEE TTTTTTTT   AA    DDDDDDD   CCCCCC  YY    YY    C
C     BB    BB EE          TT     AAAA   DD    DD CC    CC YY    YY    C
C     BB    BB EE          TT    AA  AA  DD    DD CC        YY  YY     C
C     BBBBBBB  EEEEEE      TT   AA    AA DD    DD CC         YYYY      C
C     BB    BB EE          TT   AAAAAAAA DD    DD CC          YY       C
C     BB    BB EE          TT   AA    AA DD    DD CC    CC    YY       C
C     BBBBBBB  EEEEEEEE    TT   AA    AA DDDDDDD   CCCCCC     YY       C
C                                                                      C
C -------------------------------------------------------------------- C
C  BETADCY TAKES THE RADIOACTIVE DECAY PROCESS IN WHICH ATOMIC CENTRE  C
C  IZ LOSES AN AMOUNT OF CHARGE ZDCY, AND PERFORMS AN ANALYSIS.        C
C -------------------------------------------------------------------- C
C  ▶ NUCLEAR RADII REMAIN UNCHANGED IN THIS ANALYSIS.                  C
C  ▶ RESULTS MAKE MOST SENSE FOR A ONE-ELECTRON PROBLEM.               C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION XYZ(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 VNUCLL(MDM,MDM),VNUCSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
C
C     ADJUST NUCLEAR CHARGE OF CENTRE IZ
      DO IX=1,3
        XYZ(IX) = BXYZ(IX,IZ)
      ENDDO
C
C     NEW NUCLEAR CHARGE OF DECAYED CENTRE
      ZNEW = ZNUC(IZ)-ZDCY
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE NUCLEAR ATTRACTION OVERLAP MATRICES
      CALL VNCATRC(VNUCLL,ZDCY,IZ,1,0,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VNCATRC(VNUCSS,ZDCY,IZ,4,0,1,2)
      ENDIF
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,VNUCLL,EMPTY,EMPTY,VNUCSS)
C
      WRITE(6, *) 'Beta decay analysis:'
      WRITE(7, *) 'Beta decay analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE ENERGY DIFFERENCE EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Energy difference = ',DREAL(E1(5))
      WRITE(7,20) 'Energy difference = ',DREAL(E1(5))
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 4
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,VNUCLL,EMPTY,EMPTY,VNUCSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_BETADCY_V.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC
      WRITE(7,40) IOCC
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
      RETURN
      END
C
C
      SUBROUTINE NUCOLAP(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   OOOOOO  LL          AA    PPPPPPP     C
C    NNN   NN UU    UU CC    CC OO    OO LL         AAAA   PP    PP    C
C    NNNN  NN UU    UU CC       OO    OO LL        AA  AA  PP    PP    C
C    NN NN NN UU    UU CC       OO    OO LL       AA    AA PP    PP    C
C    NN  NNNN UU    UU CC       OO    OO LL       AAAAAAAA PPPPPPP     C
C    NN   NNN UU    UU CC    CC OO    OO LL       AA    AA PP          C
C    NN    NN  UUUUUU   CCCCCC   OOOOOO  LLLLLLLL AA    AA PP          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCOLAP CALCULATES THE INTEGRAL OF THE NUCLEAR DENSITY FUNCTION AND C
C  OCCUPIED ORBITAL DENSITY (GAUSSIAN NUCLEAR MODEL.)                  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ - NUCLEAR CENTRE OF INTEREST.                                  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VNCOLAP(OLAPLL,IZ,1,0,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VNCOLAP(OLAPSS,IZ,4,0,1,2)
      ENDIF
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
      WRITE(6, *) 'Direct overlap analysis:'
      WRITE(7, *) 'Direct overlap analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,'Component ',A,' charge density overlap with centre',
     &                                              I2,3X,' = ',F15.10)
21    FORMAT(' Total electron density overlap with centre',
     &                                             I2,10X,' = ',F15.10)
      IF(HMLT.EQ.'NORL') GOTO 22
      WRITE(6,20) '{LL}',IZ,DREAL(E1(1))
      WRITE(7,20) '{LL}',IZ,DREAL(E1(1))
      WRITE(6,20) '{LS}',IZ,DREAL(E1(2))
      WRITE(7,20) '{LS}',IZ,DREAL(E1(2))
      WRITE(6,20) '{SL}',IZ,DREAL(E1(3))
      WRITE(7,20) '{SL}',IZ,DREAL(E1(3))
      WRITE(6,20) '{SS}',IZ,DREAL(E1(4))
      WRITE(7,20) '{SS}',IZ,DREAL(E1(4))
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
22    CONTINUE
      WRITE(6,21) IZ,DREAL(E1(5))
      WRITE(7,21) IZ,DREAL(E1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCOLAP_V1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCOLAP_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON V1
          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE COREPOLHYP(IV,IZ,RNMU,ISPN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     CCCCCC   OOOOOO  RRRRRRR  EEEEEEEE PPPPPPP   OOOOOO  LL          C
C    CC    CC OO    OO RR    RR EE       PP    PP OO    OO LL          C
C    CC       OO    OO RR    RR EE       PP    PP OO    OO LL          C
C    CC       OO    OO RR    RR EEEEEE   PP    PP OO    OO LL          C
C    CC       OO    OO RRRRRRR  EE       PPPPPPP  OO    OO LL          C
C    CC    CC OO    OO RR    RR EE       PP       OO    OO LL          C
C     CCCCCC   OOOOOO  RR    RR EEEEEEEE PP        OOOOOO  LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  COREPOL CALCULATES THE FIRST-ORDER CORRECTION TO THE EXPECTATION    C
C  VALUE OF A ONE-BODY INTERACTION HAMILTONIAN (WHICH MUST BE APPLIED  C
C  MANUALLY INSIDE THIS ROUTINE DUE TO FORTRAN RESTRICTIONS) WHEN THE  C
C  EFFECTS OF CORE POLARISATION ARE CONSIDERED. ONE MAY APPLY THIS TO  C
C  A SINGLE ORBITAL IN THE VALENCE REGION, AND CONVERGENCE PROPERTIES  C
C  OF THE RESULT ARE ENHANCED IF THE STATE POSSESSES S-TYPE STRUCTURE. C
C  (THIS LIES SOMEWHERE BETWEEN MBPT AND PT1BODY TREATMENTS.)          C
C -------------------------------------------------------------------- C
C  W(1)       = <V|H(1)|V>                                             C
C  W(1)^CP[D] = 2 SUM_{AR} <VA|1/R_{12}|VR><R|H(1)|A>/(EA-ER)          C
C  W(1)^CP[E] =-2 SUM_{AR} <AV|1/R_{12}|VR><R|H(1)|A>/(EA-ER)          C
C                                                                      C
C  WHERE V = IV, A = CORE ORBITAL, R = VIRTUAL ORBITAL,                C
C  H(1)=ONE-BODY INTERACTION HAMILTONIAN, R_{12} = COULOMB OPERATOR    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IV - A VIRTUAL ORBITAL (MUST BE UNOCCUPIED IN THE DHF PROCEDURE). C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 TITLE
C
      DIMENSION RNLOC(3),ABC(MDM,MDM)
C
      COMPLEX*16 WX,WY,WZ
      COMPLEX*16 WDX,WKX,WDY,WKY,WDZ,WKZ
      COMPLEX*16 CONE
      COMPLEX*16 VSUMX,VSUMY,VSUMZ
      COMPLEX*16 VX(MDM),VY(MDM),VZ(MDM)
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
     &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
      COMPLEX*16 VHX(MDM,MDM),VHY(MDM,MDM),VHZ(MDM,MDM)
      COMPLEX*16 VVAR(MDM,MDM),AVVR(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In COREPOL: not possible for this Hamiltonian!'
        WRITE(7, *) 'In COREPOL: not possible for this Hamiltonian!'
      ENDIF
C
C     CHECK THAT THE SUPPLIED VIRTUAL ORBITAL IS A VALID CHOICE
      IF(IV.LE.NOCC) THEN
        WRITE(6, *) 'In COREPOL: supply a valid orbital reference!',IV
        WRITE(7, *) 'In COREPOL: supply a valid orbital reference!',IV
        RETURN
      ENDIF
C
C     NUMBER OF OCCUPIED AND UNOCCUPIED ORBITALS
      NUMO = NOCC
      NUMV = NDIM-NOCC
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE OTHER ARRAYS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
          DXYLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DXZLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DYXLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DYZLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DZXLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DZYLS(I,J) = DCMPLX(0.0D0,0.0D0)
          DXYSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DXZSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DYXSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DYZSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DZXSL(I,J) = DCMPLX(0.0D0,0.0D0)
          DZYSL(I,J) = DCMPLX(0.0D0,0.0D0)
C
          WXLS(I,J) = DCMPLX(0.0D0,0.0D0)
          WYLS(I,J) = DCMPLX(0.0D0,0.0D0)
          WZLS(I,J) = DCMPLX(0.0D0,0.0D0)
          WXSL(I,J) = DCMPLX(0.0D0,0.0D0)
          WYSL(I,J) = DCMPLX(0.0D0,0.0D0)
          WZSL(I,J) = DCMPLX(0.0D0,0.0D0)
C
        ENDDO
      ENDDO
C
C     LOCATION OF NUCLEUS WITH MAGNETIC MOMENT
      DO IX=1,3
        RNLOC(IX) = BXYZ(IX,IZ)
      ENDDO
C
C     PRE-FACTOR FOR MATRIX ELEMENTS
      RI2 = DFLOAT(ISPN)/2.D0
      PRE =-CHZ*1.0D-6/(PMSS*CV*RI2)
C
C**********************************************************************C
C     PREPARATION OF INTEGRALS OVER H(1) -- CAN EDIT THIS BIT          C
C**********************************************************************C
C
C     MATRIX ELEMENT INTEGRALS
      CALL VMNPOLE(DXYLS,RNLOC,2,1,2,1,2)
      CALL VMNPOLE(DXZLS,RNLOC,2,1,3,1,2)
      CALL VMNPOLE(DYXLS,RNLOC,2,2,1,1,2)
      CALL VMNPOLE(DYZLS,RNLOC,2,2,3,1,2)
      CALL VMNPOLE(DZXLS,RNLOC,2,3,1,1,2)
      CALL VMNPOLE(DZYLS,RNLOC,2,3,2,1,2)
C
      CALL VMNPOLE(DXYSL,RNLOC,3,1,2,1,2)
      CALL VMNPOLE(DXZSL,RNLOC,3,1,3,1,2)
      CALL VMNPOLE(DYXSL,RNLOC,3,2,1,1,2)
      CALL VMNPOLE(DYZSL,RNLOC,3,2,3,1,2)
      CALL VMNPOLE(DZXSL,RNLOC,3,3,1,1,2)
      CALL VMNPOLE(DZYSL,RNLOC,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC MOMENT DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          WXLS(I,J) = DYZLS(I,J)-DZYLS(I,J)
          WYLS(I,J) = DZXLS(I,J)-DXZLS(I,J)
          WZLS(I,J) = DXYLS(I,J)-DYXLS(I,J)
C
C         COMPONENT OVERLAP SL
          WXSL(I,J) = DYZSL(I,J)-DZYSL(I,J)
          WYSL(I,J) = DZXSL(I,J)-DXZSL(I,J)
          WZSL(I,J) = DXYSL(I,J)-DYXSL(I,J)
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ONE-BODY EXPECTATION VALUE FOR IV                                C
C**********************************************************************C
C
      WX = DCMPLX(0.0D0,0.0D0)
C
      IF(MOD(IV,2).EQ.0) THEN
        NP =-1
      ELSE
        NP = 1
      ENDIF
C
C     LOOP OVER FOCK MATRIX ADDRESSES BY BLOCK
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
          K = I+NSKP
          L = J+NSKP
C
C         ACCOUNT FOR ALL COMPONENT OVERLAP COMBINATIONS {TT'}
          WX = WX + DCONJG(COEF(I,IV+NSKP))*COEF(L,IV+NSKP+NP)*WXLS(I,J)
     &            + DCONJG(COEF(K,IV+NSKP))*COEF(J,IV+NSKP+NP)*WXSL(I,J)
          WY = WY + DCONJG(COEF(I,IV+NSKP))*COEF(L,IV+NSKP+NP)*WYLS(I,J)
     &            + DCONJG(COEF(K,IV+NSKP))*COEF(J,IV+NSKP+NP)*WYSL(I,J)
          WZ = WZ + DCONJG(COEF(I,IV+NSKP))*COEF(L,IV+NSKP   )*WZLS(I,J)
     &            + DCONJG(COEF(K,IV+NSKP))*COEF(J,IV+NSKP   )*WZSL(I,J)
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MATRIX ELEMENTS OVER FIRST-ORDER TERMS -- REQUIRE (IR,IA) ONLY   C
C**********************************************************************C
C
C     INITIALISE VH ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
          VHX(I,J) = DCMPLX(0.0D0,0.0D0)
          VHY(I,J) = DCMPLX(0.0D0,0.0D0)
          VHZ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER ALL ORBITAL COMBINATIONS
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         MATRIX ADDRESSES
          IA = NSKP+IOCCA
          IF(IVRTR.LE.NSKP) THEN
            IR = IVRTR
          ELSE
            IR = IVRTR+NUMO
          ENDIF
C
          IF(MOD(IA,2).EQ.0) THEN
            NP =-1
          ELSE
            NP = 1
          ENDIF
C
C         INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
          VSUMX = DCMPLX(0.0D0,0.0D0)
          VSUMY = DCMPLX(0.0D0,0.0D0)
          VSUMZ = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FOCK MATRIX ADDRESSES
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
C
C             SMALL-COMPONENT ADDRESSES
              K = I+NSKP
              L = J+NSKP
C
              VSUMX = VSUMX + DCONJG(COEF(I,IR))*COEF(L,IA+NP)*WXLS(I,J)
     &                      + DCONJG(COEF(K,IR))*COEF(J,IA+NP)*WXSL(I,J)
              VSUMY = VSUMY + DCONJG(COEF(I,IR))*COEF(L,IA+NP)*WYLS(I,J)
     &                      + DCONJG(COEF(K,IR))*COEF(J,IA+NP)*WYSL(I,J)
              VSUMZ = VSUMZ + DCONJG(COEF(I,IR))*COEF(L,IA   )*WZLS(I,J)
     &                      + DCONJG(COEF(K,IR))*COEF(J,IA   )*WZSL(I,J)
C
            ENDDO
          ENDDO
C
C         SAVE COUNTERS TO MATRICES
          VHX(IR,IA) = VSUMX
          VHY(IR,IA) = VSUMY
          VHZ(IR,IA) = VSUMZ
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     COULOMB MATRIX ELEMENTS  -- REQUIRE (VV|AR) AND (AV|VR) ONLY     C
C**********************************************************************C
C
C     GENERATE CONTRACTED COULOMB MATRIX ELEMENTS
      CALL COREINT(VVAR,AVVR,NUMO,NUMV,IV)
C
C**********************************************************************C
C     CALCULATION OF CORE-POLARISATION CORRECTIONS, WDIR AND WXCH.     C
C**********************************************************************C
C
C     INITIALISE COUNTERS
      WDX = DCMPLX(0.0D0,0.0D0)
      WKX = DCMPLX(0.0D0,0.0D0)
      WDY = DCMPLX(0.0D0,0.0D0)
      WKY = DCMPLX(0.0D0,0.0D0)
      WDZ = DCMPLX(0.0D0,0.0D0)
      WKZ = DCMPLX(0.0D0,0.0D0)
C
C     LOOP OVER ALL ORBITAL COMBINATIONS
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         MATRIX ADDRESSES
          IA = NSKP+IOCCA
          IF(IVRTR.LE.NSKP) THEN
            IR = IVRTR
          ELSE
            IR = IVRTR+NUMO
          ENDIF
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EIGN(IA)-EIGN(IR)
C
C         ADD TO THE CORE-POLARISATION COUNTERS
          WDX = WDX + 2.0D0*VVAR(IA,IR)*VHX(IR,IA)/EAK
          WKX = WKX - 2.0D0*AVVR(IA,IR)*VHX(IR,IA)/EAK
          WDY = WDY + 2.0D0*VVAR(IA,IR)*VHY(IR,IA)/EAK
          WKY = WKY - 2.0D0*AVVR(IA,IR)*VHY(IR,IA)/EAK
          WDZ = WDZ + 2.0D0*VVAR(IA,IR)*VHZ(IR,IA)/EAK
          WKZ = WKZ - 2.0D0*AVVR(IA,IR)*VHZ(IR,IA)/EAK
C
        ENDDO
      ENDDO

      DO I=1,NDIM
        DO J=1,NDIM
          ABC(I,J) = 0.0D0
        ENDDO
      ENDDO
      
      X = 0.0D0
      DO IA=1,NDIM
        DO IR=1,NDIM
          IF(IA.LE.NSKP.OR.IA.GT.NSKP+NUMO) GOTO 150
          IF(IR.GT.NSKP.AND.IR.LE.NSKP+NUMO) GOTO 150
          EAK = EIGN(IA)-EIGN(IR)
          ABC(IA,IR) = ABS(2.0D0*VVAR(IA,IR)*VHZ(IR,IA)/EAK
     &               -     2.0D0*AVVR(IA,IR)*VHZ(IR,IA)/EAK)
150       CONTINUE
        ENDDO
      ENDDO
      TITLE = 'COREPOL'
      CALL GNUMTRX(ABC,TITLE,NDIM)
C
C**********************************************************************C
C     PRINT RESULTS                                                    C
C**********************************************************************C
C
C     ASSUME RESULTS ARE REAL FOR NOW
      W1AU = PRE*RNMU*DREAL(WZ)
      WDAU = PRE*RNMU*DREAL(WDZ)
      WKAU = PRE*RNMU*DREAL(WKZ)
      WTAU = W1AU+WDAU+WKAU
      W1HZ = CHZ*1.0D-6*W1AU
      WDHZ = CHZ*1.0D-6*WDAU
      WKHZ = CHZ*1.0D-6*WKAU
      WTHZ = CHZ*1.0D-6*WTAU
C
21    FORMAT(1X,A,I3)
22    FORMAT(1X,A,7X,'|',4X,ES17.10,' au',5X,'|',4X,ES17.10,' MHz')
      WRITE(6,21) 'Core polarisation corrections to IV = ',IV
      WRITE(7,21) 'Core polarisation corrections to IV = ',IV
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'W(1)      ',W1AU,W1HZ
      WRITE(7,22) 'W(1)      ',W1AU,W1HZ
      WRITE(6,22) 'W(1)^CP[D]',WDAU,WDHZ
      WRITE(7,22) 'W(1)^CP[D]',WDAU,WDHZ
      WRITE(6,22) 'W(1)^CP[X]',WKAU,WKHZ
      WRITE(7,22) 'W(1)^CP[X]',WKAU,WKHZ
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'W(1) [TOT]',WTAU,WTHZ
      WRITE(7,22) 'W(1) [TOT]',WTAU,WTHZ
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE COREPOL(IV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     CCCCCC   OOOOOO  RRRRRRR  EEEEEEEE PPPPPPP   OOOOOO  LL          C
C    CC    CC OO    OO RR    RR EE       PP    PP OO    OO LL          C
C    CC       OO    OO RR    RR EE       PP    PP OO    OO LL          C
C    CC       OO    OO RR    RR EEEEEE   PP    PP OO    OO LL          C
C    CC       OO    OO RRRRRRR  EE       PPPPPPP  OO    OO LL          C
C    CC    CC OO    OO RR    RR EE       PP       OO    OO LL          C
C     CCCCCC   OOOOOO  RR    RR EEEEEEEE PP        OOOOOO  LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  COREPOL CALCULATES THE FIRST-ORDER CORRECTION TO THE EXPECTATION    C
C  VALUE OF A ONE-BODY INTERACTION HAMILTONIAN (WHICH MUST BE APPLIED  C
C  MANUALLY INSIDE THIS ROUTINE DUE TO FORTRAN RESTRICTIONS) WHEN THE  C
C  EFFECTS OF CORE POLARISATION ARE CONSIDERED. ONE MAY APPLY THIS TO  C
C  A SINGLE ORBITAL IN THE VALENCE REGION, AND CONVERGENCE PROPERTIES  C
C  OF THE RESULT ARE ENHANCED IF THE STATE POSSESSES S-TYPE STRUCTURE. C
C  (THIS LIES SOMEWHERE BETWEEN MBPT AND PT1BODY TREATMENTS.)          C
C -------------------------------------------------------------------- C
C  W(1)       = <V|H(1)|V>                                             C
C  W(1)^CP[D] = 2 SUM_{AR} <VA|1/R_{12}|VR><R|H(1)|A>/(EA-ER)          C
C  W(1)^CP[E] =-2 SUM_{AR} <AV|1/R_{12}|VR><R|H(1)|A>/(EA-ER)          C
C                                                                      C
C  WHERE V = IV, A = CORE ORBITAL, R = VIRTUAL ORBITAL,                C
C  H(1)=ONE-BODY INTERACTION HAMILTONIAN, R_{12} = COULOMB OPERATOR    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IV - A VIRTUAL ORBITAL (MUST BE UNOCCUPIED IN THE DHF PROCEDURE). C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 TITLE
C
      DIMENSION ABC(MDM,MDM),CLOC(3)
C
      COMPLEX*16 CONE,VSUM1,VSUM2
      COMPLEX*16 WD,WX,W1
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 VLL(MDM,MDM),VLS(MDM,MDM),VSL(MDM,MDM),VSS(MDM,MDM)
      COMPLEX*16 VH1(MDM,MDM),VVAR(MDM,MDM),AVVR(MDM,MDM)
      COMPLEX*16 V1(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THIS IS A MANY-BODY CORRECTION
      IF(HMLT.EQ.'BARE') THEN
        WRITE(6, *) 'In COREPOL: core polarisation does not exist!',HMLT
        WRITE(7, *) 'In COREPOL: core polarisation does not exist!',HMLT
        RETURN
      ENDIF
C
C     CHECK THAT THE SUPPLIED VIRTUAL ORBITAL IS A VALID CHOICE
      IF(IV.LE.NOCC) THEN
        WRITE(6, *) 'In COREPOL: supply a valid orbital reference!',IV
        WRITE(7, *) 'In COREPOL: supply a valid orbital reference!',IV
        RETURN
      ENDIF
C
C     NUMBER OF OCCUPIED AND UNOCCUPIED ORBITALS
      NUMO = NOCC
      NUMV = NDIM-NOCC
C
C**********************************************************************C
C     PREPARATION OF INTEGRALS OVER H(1) -- CAN EDIT THIS BIT          C
C**********************************************************************C
C
C     INITIALISE ALL MATRIX ELEMENT ARRAYS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VLL(I,J) = DCMPLX(0.0D0,0.0D0)
          VLS(I,J) = DCMPLX(0.0D0,0.0D0)
          VSL(I,J) = DCMPLX(0.0D0,0.0D0)
          VSS(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
      CLOC(1) = 0.0D0
      CLOC(2) = 0.0D0
      CLOC(3) = 0.0D0
Cc
Cc     direct overlap matrix elements
C      call VMOMNT0(VLL,1,0,1,2)
C      call VMOMNT0(VSS,4,0,1,2)
      call VMOMNT1(VLL,CLOC,1,0,3,1,2)
      call VMOMNT1(VSS,CLOC,4,0,3,1,2)
C
C     LAPLACIAN MATRIX ELEMENTS
C      CALL VLPLACE(VLS,2,0,1,2)
C      CALL VLPLACE(VSL,3,0,1,2)
C
C     CONSTRUCT EFFECTIVE EDM OPERATOR BY MULTIPLICATION
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VLS(I,J) = 2.0D0*CV*CONE*VLS(I,J)
          VSL(I,J) =-2.0D0*CV*CONE*VSL(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ONE-BODY EXPECTATION VALUE FOR IV                                C
C**********************************************************************C
C
      W1 = DCMPLX(0.0D0,0.0D0)
C
C     LOOP OVER FOCK MATRIX ADDRESSES BY BLOCK
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
          K = I+NSKP
          L = J+NSKP
C
C         ACCOUNT FOR ALL COMPONENT OVERLAP COMBINATIONS {TT'}
          W1 = W1 + DCONJG(COEF(I,IV+NSKP))*COEF(J,IV+NSKP)*VLL(I,J)
          IF(HMLT.NE.'NORL') THEN
            W1 = W1 + DCONJG(COEF(I,IV+NSKP))*COEF(L,IV+NSKP)*VLS(I,J)
     &              + DCONJG(COEF(K,IV+NSKP))*COEF(J,IV+NSKP)*VSL(I,J)
     &              + DCONJG(COEF(K,IV+NSKP))*COEF(L,IV+NSKP)*VSS(I,J)
          ENDIF
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MATRIX ELEMENTS OVER FIRST-ORDER TERMS -- REQUIRE (IR,IA) ONLY   C
C**********************************************************************C
C
C     INITIALISE VH1 ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          VH1(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER ALL ORBITAL COMBINATIONS
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         MATRIX ADDRESSES
          IA = NSKP+IOCCA
          IF(IVRTR.LE.NSKP) THEN
            IR = IVRTR
          ELSE
            IR = IVRTR+NUMO
          ENDIF
C
C         INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
          VSUM1 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FOCK MATRIX ADDRESSES
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
C
C             SMALL-COMPONENT ADDRESSES
              K = I+NSKP
              L = J+NSKP
C
              VSUM1 = VSUM1 + DCONJG(COEF(I,IR))*COEF(J,IA)*VLL(I,J)
              IF(HMLT.NE.'NORL') THEN
                VSUM1 = VSUM1 + DCONJG(COEF(I,IR))*COEF(L,IA)*VLS(I,J)
     &                        + DCONJG(COEF(K,IR))*COEF(J,IA)*VSL(I,J)
     &                        + DCONJG(COEF(K,IR))*COEF(L,IA)*VSS(I,J)
              ENDIF
            ENDDO
          ENDDO
C
C         SAVE COUNTERS TO MATRICES
          VH1(IR,IA) = VSUM1
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     COULOMB MATRIX ELEMENTS  -- REQUIRE (VV|AR) AND (AV|VR) ONLY     C
C**********************************************************************C
C
C     GENERATE CONTRACTED COULOMB MATRIX ELEMENTS
      CALL COREINT(VVAR,AVVR,NUMO,NUMV,IV)
C
C**********************************************************************C
C     CALCULATION OF CORE-POLARISATION CORRECTIONS, WDIR AND WXCH.     C
C**********************************************************************C
C
C     INITIALISE COUNTERS
      WD = DCMPLX(0.0D0,0.0D0)
      WX = DCMPLX(0.0D0,0.0D0)
C
C     LOOP OVER ALL ORBITAL COMBINATIONS
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         MATRIX ADDRESSES
          IA = NSKP+IOCCA
          IF(IVRTR.LE.NSKP) THEN
            IR = IVRTR
          ELSE
            IR = IVRTR+NUMO
          ENDIF
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EIGN(IA)-EIGN(IR)
C
C         ADD TO THE CORE-POLARISATION COUNTERS
          WD = WD + 2.0D0*VVAR(IA,IR)*VH1(IR,IA)/EAK
          WX = WX - 2.0D0*AVVR(IA,IR)*VH1(IR,IA)/EAK
C
        ENDDO
      ENDDO

      DO I=1,NDIM
        DO J=1,NDIM
          ABC(I,J) = 0.0D0
        ENDDO
      ENDDO
      
      X = 0.0D0
      DO IA=1,NDIM
        DO IR=1,NDIM
          IF(IA.LE.NSKP.OR.IA.GT.NSKP+NUMO) GOTO 150
          IF(IR.GT.NSKP.AND.IR.LE.NSKP+NUMO) GOTO 150
          EAK = EIGN(IA)-EIGN(IR)
          ABC(IA,IR) = ABS(2.0D0*VVAR(IA,IR)*VH1(IR,IA)/EAK
     &               -     2.0D0*AVVR(IA,IR)*VH1(IR,IA)/EAK)
150       CONTINUE
        ENDDO
      ENDDO
      TITLE = 'COREPOL'
      CALL GNUMTRX(ABC,TITLE,NDIM)
C
C**********************************************************************C
C     PRINT RESULTS                                                    C
C**********************************************************************C
C
C     ASSUME RESULTS ARE REAL FOR NOW
      W1AU = DREAL(W1)
      WDAU = DREAL(WD)
      WXAU = DREAL(WX)
      WTAU = W1AU+WDAU+WXAU
      W1HZ = CHZ*W1AU
      WDHZ = CHZ*WDAU
      WXHZ = CHZ*WXAU
      WTHZ = CHZ*WTAU
C
21    FORMAT(1X,A,I3)
22    FORMAT(1X,A,7X,'|',4X,ES17.10,' au',5X,'|',4X,ES17.10,' Hz')
      WRITE(6,21) 'Core polarisation corrections to IV = ',IV
      WRITE(7,21) 'Core polarisation corrections to IV = ',IV
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'W(1)      ',W1AU,W1HZ
      WRITE(7,22) 'W(1)      ',W1AU,W1HZ
      WRITE(6,22) 'W(1)^CP[D]',WDAU,WDHZ
      WRITE(7,22) 'W(1)^CP[D]',WDAU,WDHZ
      WRITE(6,22) 'W(1)^CP[X]',WXAU,WXHZ
      WRITE(7,22) 'W(1)^CP[X]',WXAU,WXHZ
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'W(1) [TOT]',WTAU,WTHZ
      WRITE(7,22) 'W(1) [TOT]',WTAU,WTHZ
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE COREINT(VVAR,AVVR,NUMO,NUMV,IVRTV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       CCCCCC   OOOOOO  RRRRRRR  EEEEEEEE IIII NN    NN TTTTTTTT      C
C      CC    CC OO    OO RR    RR EE        II  NNN   NN    TT         C
C      CC       OO    OO RR    RR EE        II  NNNN  NN    TT         C
C      CC       OO    OO RR    RR EEEEEE    II  NN NN NN    TT         C
C      CC       OO    OO RRRRRRR  EE        II  NN  NNNN    TT         C
C      CC    CC OO    OO RR    RR EE        II  NN   NNN    TT         C
C       CCCCCC   OOOOOO  RR    RR EEEEEEEE IIII NN    NN    TT         C
C                                                                      C
C -------------------------------------------------------------------- C
C  COREINT EVALUATES COULOUMB INTEGRALS MATRIX ELEMENTS AS REQUIRED    C
C  FOR USE IN COREPOL WITH CONTRIBUTIONS FROM NEGATIVE-ENERGY SPECTRUM.C
C  CONTRACTIONS CAN BE ARRANGED IN A TIME-SAVING WAY, SO THAT IT IS    C
C  MORE USEFUL TO CUT DOWN ON ERI GENERATION TIME (USE SWAP SYMMETRY). C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IVRTV - VIRTUAL STATE TO CONTRACT OVER (DO NOT INCLUDE NSKP).     C
C  OUTPUT:                                                             C
C  ▶ VVAR  - DIRECT COULOMB MATRIX ELEMENTS, CONTRACTED OVER IVRTV.    C
C  ▶ AVVR  - EXCHANGE COULOMB MATRIX ELEMENTS, CONTRACTED OVER IVRTV.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION INDEX(MCT,-(MEL+1):MEL,MKP)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 V1(MBS,8),V2(MBS,8)
      COMPLEX*16 VV(MB2,4),AV(MB2,NUMO,4)
      COMPLEX*16 RVV1(MBS,NUMV,2),RVV2(MBS,NUMV,2),
     &           RAV1(MBS,NUMO*NUMV,2),RAV2(MBS,NUMO*NUMV,2)
      COMPLEX*16 ARVV(NUMO,NUMV),VRAV(NUMO,NUMV)
      COMPLEX*16 VVAR(MDM,MDM),AVVR(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      RCFILE = .FALSE.
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     CLEAR THE GLOBAL DIRECT AND EXCHANGE ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
          VVAR(I,J) = DCMPLX(0.0D0,0.0D0)
          AVVR(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CLEAR THE LOCAL DIRECT AND EXCHANGE ARRAYS
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
          ARVV(IOCCA,IVRTR) = DCMPLX(0.0D0,0.0D0)
          VRAV(IOCCA,IVRTR) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     FOCK MATRIX ADDRESS FOR IVRTV
      IV = NSKP+IVRTV
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS TT(AB) (USE INDEX 1000)       C
C**********************************************************************C
C
C     COMPONENT LABEL FOR A AND B: TT = LL(1) or SS(4) <- COULOMB
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 1000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(ITN(1).EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF A (USE INDEX 2000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     INDEX ASSIGNMENT
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON A
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF B (USE INDEX 3000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE B
      DO 3000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(B) VALUES
      DO 3000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1, NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     INDEX ASSIGNMENT
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON B
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDAB
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
      IEAB = 1
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ1.LT.IQ2) GOTO 3001
C
C     CLEAR ARRAY FOR SECOND CONTRACTION (KL->AR)
      DO MIJ=1,NBAS(1)*NBAS(2)
        DO IJSPIN=1,4
          VV(MIJ,IJSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CLEAR ARRAY FOR SECOND CONTRACTION (KL->VR)
      DO MIJ=1,NBAS(1)*NBAS(2)
        DO IOCCA=1,NUMO
          DO IJSPIN=1,4
            AV(MIJ,IOCCA,IJSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) (INDEX 4000)               C
C**********************************************************************C
C
      DO 4000 IBAS=1,NBAS(1)
      DO 4000 JBAS=1,NBAS(2)
C
C     LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
      MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS TT(CD) (USE INDEX 5000)       C
C**********************************************************************C
C
C     COMPONENT LABEL FOR C AND D: TT = LL(1) or SS(4)
      DO 5000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(ITN(2).EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF C (USE INDEX 6000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE C
      DO 6000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER KQN(C) VALUES
      DO 6000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER |MQN(C)| VALUES
      DO 6000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     INDEX ASSIGNMENT
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON C
      NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDCD
      NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF D (USE INDEX 7000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE D
      DO 7000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     LOOP OVER KQN(D) VALUES
      DO 7000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C     LOOP OVER |MQN(D)| VALUES
      DO 7000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     INDEX ASSIGNMENT
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON D
      ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDCD
      ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDCD
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C     FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
      IECD = 1
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ3.LT.IQ4) GOTO 7001
C
C**********************************************************************C
C     ALL LOOPS NOW COMPLETE -- GENERATE BATCH OF ERIs AND CONTRACT    C
C**********************************************************************C
C
C     RESET SCREENING COUNTERS
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
      ENDDO

C     BATCH OF ELECTRON INTERACTION INTEGRALS (IJ|KL) FOR FIXED (IJ)
      CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (L->R)
      DO MKV=1,NBAS(3)
        DO IJKSPIN=1,8
          V1(MKV,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (K->R)
      DO MLV=1,NBAS(4)
        DO IJKSPIN=1,8
          V2(MLV,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST CONTRACTION:                                               C
C     (IJ;T|KL;T') -> (IJ;T|KV;T')  AND  (IJ;T|LK;T') -> (IJ;T|LV;T')  C
C**********************************************************************C
C
C     FIRST CONTRACTION (NORMAL): (IJ;T|KL;T') -> (IJ;T|KV;T')
C
C     LOOP OVER BASIS FUNCTIONS IN BLOCK C AND FOR THIS IV
      DO KBAS=1,NBAS(3)
C
C       CONTRACT OVER ALL LBAS IN BLOCK D
        DO LBAS=1,NBAS(4)
C
C         LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
          M = (KBAS-1)*NBAS(4) + LBAS
C
C         (--|-V) = (--|--) + (--|-+)
          V1(KBAS,1) = V1(KBAS,1) + RR(M, 1)*COEF(ND1+LBAS,IV)
     &                            + RR(M, 2)*COEF(ND2+LBAS,IV)
C
C         (+-|-V) = (+-|--) + (+-|-+)
          V1(KBAS,2) = V1(KBAS,2) + RR(M, 3)*COEF(ND1+LBAS,IV)
     &                            + RR(M, 4)*COEF(ND2+LBAS,IV)
C
C         (-+|-V) = (-+|--) + (-+|-+)
          V1(KBAS,3) = V1(KBAS,3) + RR(M, 5)*COEF(ND1+LBAS,IV)
     &                            + RR(M, 6)*COEF(ND2+LBAS,IV)
C
C         (++|-V) = (++|--) + (++|-+)
          V1(KBAS,4) = V1(KBAS,4) + RR(M, 7)*COEF(ND1+LBAS,IV)
     &                            + RR(M, 8)*COEF(ND2+LBAS,IV)
C
C         (--|+V) = (--|+-) + (--|++)
          V1(KBAS,5) = V1(KBAS,5) + RR(M, 9)*COEF(ND1+LBAS,IV)
     &                            + RR(M,10)*COEF(ND2+LBAS,IV)
C
C         (+-|+V) = (+-|+-) + (+-|++)
          V1(KBAS,6) = V1(KBAS,6) + RR(M,11)*COEF(ND1+LBAS,IV)
     &                            + RR(M,12)*COEF(ND2+LBAS,IV)
C
C         (-+|+V) = (-+|+-) + (-+|++)
          V1(KBAS,7) = V1(KBAS,7) + RR(M,13)*COEF(ND1+LBAS,IV)
     &                            + RR(M,14)*COEF(ND2+LBAS,IV)
C
C         (++|+V) = (++|+-) + (++|++)
          V1(KBAS,8) = V1(KBAS,8) + RR(M,15)*COEF(ND1+LBAS,IV)
     &                            + RR(M,16)*COEF(ND2+LBAS,IV)
C
        ENDDO
C
      ENDDO
C
C     UTILISE R-INTEGRAL SYMMETRY OF (CD) SWAP
      IF(IQ3.NE.IQ4) THEN
C
C       FIRST CONTRACTION (SWAP): (JI;T|KL;T') -> (JI;T|KV;T')
C
C       CONTRACT OVER ALL LBAS IN BLOCK D
        DO LBAS=1,NBAS(4)
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK C AND FOR THIS IV
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|-V)' = PCD1*(--|--) + PCD2*(--|-+)
            V2(LBAS,1) = V2(LBAS,1)
     &                        + PCD1*RR(M, 4)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + PCD2*RR(M, 2)*DCONJG(COEF(NC2+KBAS,IV))
C
C           (--|+V)' = PCD2*(--|+-) + PCD1*(--|++)
            V2(LBAS,2) = V2(LBAS,2)
     &                        + PCD2*RR(M, 3)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + PCD1*RR(M, 1)*DCONJG(COEF(NC2+KBAS,IV))
C
C           (-+|-V)' = PCD1*(-+|--) + PCD2*(-+|-+)
            V2(LBAS,3) = V2(LBAS,3)
     &                        + PCD1*RR(M, 8)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + PCD2*RR(M, 6)*DCONJG(COEF(NC2+KBAS,IV))
C
C           (-+|+V)' = PCD2*(-+|+-) + PCD1*(-+|++)
            V2(LBAS,4) = V2(LBAS,4)
     &                        + PCD2*RR(M, 7)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + PCD1*RR(M, 5)*DCONJG(COEF(NC2+KBAS,IV))
C
C           (+-|-V)' = PCD1*(+-|--) + PCD2*(+-|-+)
            V2(LBAS,5) = V2(LBAS,5)
     &                        + PCD1*RR(M,12)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + PCD2*RR(M,10)*DCONJG(COEF(NC2+KBAS,IV))
C
C           (+-|+V)' = PCD2*(+-|+-) + PCD1*(+-|++)
            V2(LBAS,6) = V2(LBAS,6)
     &                        + PCD2*RR(M,11)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + PCD1*RR(M, 9)*DCONJG(COEF(NC2+KBAS,IV))
C
C           (++|-V)' = PCD1*(++|--) + PCD2*(++|-+)
            V2(LBAS,7) = V2(LBAS,7)
     &                        + PCD1*RR(M,16)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + PCD2*RR(M,14)*DCONJG(COEF(NC2+KBAS,IV))
C
C           (++|+V)' = PCD2*(++|+-) + PCD1*(++|++)
            V2(LBAS,8) = V2(LBAS,8)
     &                        + PCD2*RR(M,15)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + PCD1*RR(M,13)*DCONJG(COEF(NC2+KBAS,IV))
C
          ENDDO
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     SECOND CONTRACTION:                                   ~          C
C     (IJ;T|KV;T') -> (IJ;T|VV)  AND  (IJ;T|LV;T') -> (IJ;T|VV)        C
C     (IJ;T|KV;T') -> (IJ;T|AV)  AND  (IJ;T|LV;T') -> (IJ;T|AV)        C
C**********************************************************************C
C
C     SECOND CONTRACTION (NORMAL) DIRECT: (IJ;T|KV;T') -> (IJ;T|VV;T')
C
C     CONTRACT OVER ALL KBAS IN BLOCK C
      DO KBAS=1,NBAS(3)
C
C       (--|VV) = (--|-V) + (--|+V)
        VV(MIJ,1) = VV(MIJ,1) + V1(KBAS,1)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + V1(KBAS,2)*DCONJG(COEF(NC2+KBAS,IV))
C
C       (-+|VV) = (-+|-V) + (-+|+V)
        VV(MIJ,2) = VV(MIJ,2) + V1(KBAS,3)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + V1(KBAS,4)*DCONJG(COEF(NC2+KBAS,IV))
C
C       (+-|VV) = (+-|-V) + (+-|+V)
        VV(MIJ,3) = VV(MIJ,3) + V1(KBAS,5)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + V1(KBAS,6)*DCONJG(COEF(NC2+KBAS,IV))
C
C       (++|VV) = (++|-V) + (++|+V)
        VV(MIJ,4) = VV(MIJ,4) + V1(KBAS,7)*DCONJG(COEF(NC1+KBAS,IV))
     &                        + V1(KBAS,8)*DCONJG(COEF(NC2+KBAS,IV))
C
      ENDDO
C
C     SECOND CONTRACTION (NORMAL) EXCHANGE: (IJ;T|KV;T') -> (IJ;T|AV;T')
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = NSKP+IOCCA
C
C       CONTRACT OVER ALL KBAS IN BLOCK C
        DO KBAS=1,NBAS(3)
C
C         (--|AV) = (--|-V)' + (--|+V)'
          AV(MIJ,IOCCA,1) = AV(MIJ,IOCCA,1)
     &                           + V1(KBAS,1)*DCONJG(COEF(NC1+KBAS,IA))
     &                           + V1(KBAS,2)*DCONJG(COEF(NC2+KBAS,IA))
C
C         (-+|AV) = (-+|-V)' + (-+|+V)'
          AV(MIJ,IOCCA,2) = AV(MIJ,IOCCA,2)
     &                           + V1(KBAS,3)*DCONJG(COEF(NC1+KBAS,IA))
     &                           + V1(KBAS,4)*DCONJG(COEF(NC2+KBAS,IA))
C
C         (+-|AV) = (+-|-V)' + (+-|+V)'
          AV(MIJ,IOCCA,3) = AV(MIJ,IOCCA,3)
     &                           + V1(KBAS,5)*DCONJG(COEF(NC1+KBAS,IA))
     &                           + V1(KBAS,6)*DCONJG(COEF(NC2+KBAS,IA))
C
C         (++|AV) = (++|-V)' + (++|+V)'
          AV(MIJ,IOCCA,4) = AV(MIJ,IOCCA,4)
     &                           + V1(KBAS,7)*DCONJG(COEF(NC1+KBAS,IA))
     &                           + V1(KBAS,8)*DCONJG(COEF(NC2+KBAS,IA))
C
        ENDDO
C
      ENDDO
C
C     UTILISE R-INTEGRAL SYMMETRY OF (CD) SWAP
      IF(IQ3.NE.IQ4) THEN
C
C       SECOND CONTRACTION (SWAP) DIRECT: (IJ;T|KV;T') -> (IJ;T|VV;T')
        DO LBAS=1,NBAS(4)
C
C         (--|VV) = (--|-V) + (--|+V)
          VV(MIJ,1) = VV(MIJ,1) + V2(LBAS,1)*COEF(ND1+LBAS,IV)
     &                          + V2(LBAS,2)*COEF(ND2+LBAS,IV)
C
C         (-+|VV) = (-+|-V) + (-+|+V)
          VV(MIJ,2) = VV(MIJ,2) + V2(LBAS,3)*COEF(ND1+LBAS,IV)
     &                          + V2(LBAS,4)*COEF(ND2+LBAS,IV)
C
C         (+-|VV) = (+-|-V) + (+-|+V)
          VV(MIJ,3) = VV(MIJ,3) + V2(LBAS,5)*COEF(ND1+LBAS,IV)
     &                          + V2(LBAS,6)*COEF(ND2+LBAS,IV)
C
C         (++|VV) = (++|-V) + (++|+V)
          VV(MIJ,4) = VV(MIJ,4) + V2(LBAS,7)*COEF(ND1+LBAS,IV)
     &                          + V2(LBAS,8)*COEF(ND2+LBAS,IV)
C
        ENDDO
C
C       SECOND CONTRACTION (SWAP) EXCHANGE: (IJ;T|KV;T') -> (IJ;T|AV;T')
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCA
          IA = NSKP+IOCCA
C
C         CONTRACT OVER ALL KBAS IN BLOCK C
          DO LBAS=1,NBAS(4)
C
C           (--|AV) = (--|-V)' + (--|+V)'
            AV(MIJ,IOCCA,1) = AV(MIJ,IOCCA,1)
     &                                   + V2(LBAS,1)*COEF(ND1+LBAS,IA)
     &                                   + V2(LBAS,2)*COEF(ND2+LBAS,IA)
C
C           (-+|AV) = (-+|-V)' + (-+|+V)'
            AV(MIJ,IOCCA,2) = AV(MIJ,IOCCA,2)
     &                                   + V2(LBAS,3)*COEF(ND1+LBAS,IA)
     &                                   + V2(LBAS,4)*COEF(ND2+LBAS,IA)
C
C           (+-|AV) = (+-|-V)' + (+-|+V)'
            AV(MIJ,IOCCA,3) = AV(MIJ,IOCCA,3)
     &                                   + V2(LBAS,5)*COEF(ND1+LBAS,IA)
     &                                   + V2(LBAS,6)*COEF(ND2+LBAS,IA)
C
C           (++|AV) = (++|-V)' + (++|+V)'
            AV(MIJ,IOCCA,4) = AV(MIJ,IOCCA,4)
     &                                   + V2(LBAS,7)*COEF(ND1+LBAS,IA)
     &                                   + V2(LBAS,8)*COEF(ND2+LBAS,IA)
C
          ENDDO
C
        ENDDO
C
      ENDIF
C
C     SKIP POINT FOR IQ3.LT.IQ4
7001  CONTINUE
C
C     ALL CONTRIBUTIONS FROM THIS CLASS (C,D) NOW ACCOUNTED FOR
7000  CONTINUE
6000  CONTINUE
C
C     END LOOP OVER COMPONENT TYPE T'T'
5000  CONTINUE
C
C     FULL BLOCK (C,D) FOR EACH (IBAS,JBAS) AND T'T' NOW FINISHED
4000  CONTINUE
C
C**********************************************************************C
C     THIRD CONTRACTION:                                               C
C     (IJ;T|VV) -> (IR;T|VV)  AND  (IJ;T|AV) -> (IR;T|AV)              C
C     (JI;T|VV) -> (JR;T|VV)  AND  (JI;T|AV) -> (JR;T|AV)              C
C**********************************************************************C
C
C     THIRD CONTRACTION (NORMAL) DIRECT: (IJ;T|VV) -> (IR;T|VV)
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (NORMAL) DIRECT
      DO IBAS=1,NBAS(1)
        DO IVRTR=1,NUMV
          DO ISPIN=1,2
            RVV1(IBAS,IVRTR,ISPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER VIRTUAL STATES IVRTR
      DO IVRTR=1,NUMV
C
C       FOCK MATRIX ADDRESS FOR IVRTR
        IF(IVRTR.LE.NSKP) THEN
          IR = IVRTR
        ELSE
          IR = IVRTR+NUMO
        ENDIF
C
C       CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
C
C           LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
            MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C           (-R|VV) = (--|VV) + (-+|VV)
            RVV1(IBAS,IVRTR,1) = RVV1(IBAS,IVRTR,1)
     &                               +      VV(MIJ,1)*COEF(NB1+JBAS,IR)
     &                               +      VV(MIJ,2)*COEF(NB2+JBAS,IR)
C
C           (+R|VV) = (+-|VV) + (++|VV)
            RVV1(IBAS,IVRTR,2) = RVV1(IBAS,IVRTR,2)
     &                               +      VV(MIJ,3)*COEF(NB1+JBAS,IR)
     &                               +      VV(MIJ,4)*COEF(NB2+JBAS,IR)
C
          ENDDO
        ENDDO
      ENDDO
C
C     THIRD CONTRACTION (NORMAL) EXCHANGE: (IJ;T|AV) -> (IR;T|AV)
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (NORMAL) EXCHANGE
      DO IBAS=1,NBAS(1)
        DO MRA=1,NUMO*NUMV
          DO ISPIN=1,2
            RAV1(IBAS,MRA,ISPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER VIRTUAL STATES IVRTR
      DO IVRTR=1,NUMV
C
C       FOCK MATRIX ADDRESS FOR IVRTR
        IF(IVRTR.LE.NSKP) THEN
          IR = IVRTR
        ELSE
          IR = IVRTR+NUMO
        ENDIF
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         LIST ADDRESS FOR THIS IOCCA,IVRTR COMBINATION IN RAV
          MRA = (IOCCA-1)*NUMV + IVRTR
C
C         CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
C
C             LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
              MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C             (-R|AV) = (--|AV) + (-+|AV)
              RAV1(IBAS,MRA,1) = RAV1(IBAS,MRA,1)
     &                         +      AV(MIJ,IOCCA,1)*COEF(NB1+JBAS,IR)
     &                         +      AV(MIJ,IOCCA,2)*COEF(NB2+JBAS,IR)
C
C             (+R|AV) = (+-|AV) + (++|AV)
              RAV1(IBAS,MRA,2) = RAV1(IBAS,MRA,2)
     &                         +      AV(MIJ,IOCCA,3)*COEF(NB1+JBAS,IR)
     &                         +      AV(MIJ,IOCCA,4)*COEF(NB2+JBAS,IR)
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     UTILISE R-INTEGRAL SYMMETRY OF (AB) SWAP
      IF(IQ1.NE.IQ2) THEN
C
C       THIRD CONTRACTION (NORMAL) DIRECT: (JI;T|VV) -> (JR;T|VV)
C
C       CLEAR ARRAYS FOR THIRD CONTRACTION (SWAP) DIRECT
        DO JBAS=1,NBAS(2)
          DO IVRTR=1,NUMV
            DO ISPIN=1,2
              RVV2(JBAS,IVRTR,ISPIN) = DCMPLX(0.0D0,0.0D0)
            ENDDO
          ENDDO
        ENDDO
C
C       LOOP OVER VIRTUAL STATES IVRTR
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESS FOR IVRTR
          IF(IVRTR.LE.NSKP) THEN
            IR = IVRTR
          ELSE
            IR = IVRTR+NUMO
          ENDIF
C
C         CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
C
C             LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
              MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C             (-R|VV)' = PAB1*(--|VV) + PAB2*(-+|VV)
              RVV2(JBAS,IVRTR,1) = RVV2(JBAS,IVRTR,1)
     &                       + PAB1*VV(MIJ,4)*DCONJG(COEF(NA1+IBAS,IR))
     &                       + PAB2*VV(MIJ,2)*DCONJG(COEF(NA2+IBAS,IR))
C
C             (+R|VV)' = PAB2*(+-|VV) + PAB1*(++|VV)
              RVV2(JBAS,IVRTR,2) = RVV2(JBAS,IVRTR,2)
     &                       + PAB2*VV(MIJ,3)*DCONJG(COEF(NA1+IBAS,IR))
     &                       + PAB1*VV(MIJ,1)*DCONJG(COEF(NA2+IBAS,IR))
C
            ENDDO
          ENDDO
        ENDDO
C
C       THIRD CONTRACTION (NORMAL) EXCHANGE: (JI;T|AV) -> (JR;T|AV)
C
C       CLEAR ARRAYS FOR THIRD CONTRACTION (SWAP) EXCHANGE
        DO JBAS=1,NBAS(2)
          DO MRA=1,NUMO*NUMV
            DO ISPIN=1,2
              RAV2(JBAS,MRA,ISPIN) = DCMPLX(0.0D0,0.0D0)
            ENDDO
          ENDDO
        ENDDO
C
C       LOOP OVER VIRTUAL STATES IVRTR
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESS FOR IVRTR
          IF(IVRTR.LE.NSKP) THEN
            IR = IVRTR
          ELSE
            IR = IVRTR+NUMO
          ENDIF
C
C         LOOP OVER OCCUPIED STATES IOCCA
          DO IOCCA=1,NUMO
C
C           LIST ADDRESS FOR THIS IOCCA,IVRTR COMBINATION IN RAV
            MRA = (IOCCA-1)*NUMV + IVRTR
C
C           CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-R|AV)' = PAB1*(--|AV) + PAB2*(-+|AV)
                RAV2(JBAS,MRA,1) = RAV2(JBAS,MRA,1)
     &                 + PAB1*AV(MIJ,IOCCA,4)*DCONJG(COEF(NA1+IBAS,IR))
     &                 + PAB2*AV(MIJ,IOCCA,2)*DCONJG(COEF(NA2+IBAS,IR))
C
C               (+R|AV)' = PAB2*(+-|AV) + PAB1*(++|AV)
                RAV2(JBAS,MRA,2) = RAV2(JBAS,MRA,2)
     &                 + PAB2*AV(MIJ,IOCCA,3)*DCONJG(COEF(NA1+IBAS,IR))
     &                 + PAB1*AV(MIJ,IOCCA,1)*DCONJG(COEF(NA2+IBAS,IR))
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     FOURTH CONTRACTION:                      ~                       C
C     (IR;T|VV) -> (AR|VV)  AND  (JR;T|VV) -> (AR|VV)                  C
C     (IR;T|AV) -> (VR|AV)  AND  (JR;T|AV) -> (VR|AV)                  C
C**********************************************************************C
C
C     FOURTH CONTRACTION (NORMAL) DIRECT: (IR;T|VV) -> (AR|VV)
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = NSKP+IOCCA
C
C       LOOP OVER VIRTUAL STATES IVRTR
        DO IVRTR=1,NUMV
C
C         CONTRACT OVER ALL IBAS IN BLOCK A
          DO IBAS=1,NBAS(1)
C
C           (AR|VV) = (-R|VV) + (+R|VV)
            ARVV(IOCCA,IVRTR) = ARVV(IOCCA,IVRTR)
     &                   + RVV1(IBAS,IVRTR,1)*DCONJG(COEF(NA1+IBAS,IA))
     &                   + RVV1(IBAS,IVRTR,2)*DCONJG(COEF(NA2+IBAS,IA))
C
          ENDDO
        ENDDO
      ENDDO
C
C     FOURTH CONTRACTION (NORMAL) EXCHANGE: (IR;T|AV) -> (VR|AV)
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       LOOP OVER VIRTUAL STATES IVRTR
        DO IVRTR=1,NUMV
C
C         LIST ADDRESS FOR THIS IOCCA,IVRTR COMBINATION IN RAV
          MRA = (IOCCA-1)*NUMV + IVRTR
C
C         CONTRACT OVER ALL IBAS IN BLOCK A
          DO IBAS=1,NBAS(1)
C
C           (VR|AV) = (-R|AV) + (+R|AV)
            VRAV(IOCCA,IVRTR) = VRAV(IOCCA,IVRTR)
     &                    + RAV1(IBAS,MRA,1)*DCONJG(COEF(NA1+IBAS,IV))
     &                    + RAV1(IBAS,MRA,2)*DCONJG(COEF(NA2+IBAS,IV))
C
          ENDDO
        ENDDO
      ENDDO
C
C     UTILISE R-INTEGRAL SYMMETRY OF (AB) SWAP
      IF(IQ1.NE.IQ2) THEN
C                                                     ~
C       FOURTH CONTRACTION (SWAP) DIRECT: (JR;T|VV) -> (AR|VV)
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCA
          IA = NSKP+IOCCA
C
C         LOOP OVER VIRTUAL STATES IVRTR AND OCCUPIED STATES
          DO IVRTR=1,NUMV
C
C           CONTRACT OVER ALL IBAS IN BLOCK A
            DO JBAS=1,NBAS(2)
C
C             (AR|VV) = (-R|VV)' + (+R|VV)'
              ARVV(IOCCA,IVRTR) = ARVV(IOCCA,IVRTR)
     &                           + RVV2(JBAS,IVRTR,1)*COEF(NB1+JBAS,IA)
     &                           + RVV2(JBAS,IVRTR,2)*COEF(NB2+JBAS,IA)
C
            ENDDO
          ENDDO
        ENDDO
C                                                       ~
C       FOURTH CONTRACTION (SWAP) EXCHANGE: (JR;T|AV) -> (VR|AV)
C
C       LOOP OVER OCCUPIED STATES IOCCA
        DO IOCCA=1,NUMO
C
C         LOOP OVER VIRTUAL STATES IVRTR AND OCCUPIED STATES
          DO IVRTR=1,NUMV
C
C           LIST ADDRESS FOR THIS IOCCA,IVRTR COMBINATION IN RAV
            MRA = (IOCCA-1)*NUMV + IVRTR
C
C           CONTRACT OVER ALL IBAS IN BLOCK A
            DO JBAS=1,NBAS(2)
C
C             (VR|AV) = (-R|AV)' + (+R|AV)'
              VRAV(IOCCA,IVRTR) = VRAV(IOCCA,IVRTR)
     &                             + RAV2(JBAS,MRA,1)*COEF(NB1+JBAS,IV)
     &                             + RAV2(JBAS,MRA,2)*COEF(NB2+JBAS,IV)
C
            ENDDO
          ENDDO
        ENDDO
C
      ENDIF
C
C     SKIP POINT FOR IQ1.LT.IQ2
3001  CONTINUE
C
C     ALL CONTRIBUTIONS FROM THIS CLASS (A,B) NOW ACCOUNTED FOR
3000  CONTINUE
2000  CONTINUE
C
C     END LOOP OVER COMPONENT OVERLAP TYPE TT
1000  CONTINUE
C
C**********************************************************************C
C     ALL CONTRACTIONS COMPLETE -- LEFT WITH (AR|VV) AND (VR|AV)       C
C**********************************************************************C
C
C     CONSTRUCT VVAR AND AVVR IN FOCK ADDRESSES BY COMPLEX CONJUGATION
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESSES FOR IOCCA AND IVRTR
          IA = NSKP+IOCCA
          IF(IVRTR.LE.NSKP) THEN
            IR = IVRTR
          ELSE
            IR = IVRTR+NUMO
          ENDIF
C
          VVAR(IA,IR) = ARVV(IOCCA,IVRTR)
          AVVR(IA,IR) = VRAV(IOCCA,IVRTR)
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE VMOMNT0(VIJ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 000000   C
C VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   00   000  C
C VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT   00  0000  C
C VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT   00 00 00  C
C  VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT   0000  00  C
C   VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT   000   00  C
C    VV    MM       MM  OOOOOO  MM       MM NN    NN    TT    000000   C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMOMNT0 CONSTRUCTS A MATRIX OF (μ,T|σ_Q|ν,T') ZEROTH MOMENT         C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS.                            C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 TMP(MBS,MBS,4)
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     GENERATE ELLQ COEFFICIENTS (IPHS = +1)
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMOMNT0: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMOMNT0: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXL(IBAS,1)+EXL(JBAS,2)
          ERT = DSQRT(PI/EIJ)**3
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*E11(M,1)
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*E21(M,1)
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VMOMNT1(VIJ,CLOC,ITT,IQ,IX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 11     C
C   VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   111     C
C   VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT    11     C
C   VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT    11     C
C    VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT    11     C
C     VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT    11     C
C      VV    MM       MM  OOOOOO  MM       MM NN    NN    TT   1111    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMOMNT1 CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X|ν,T') FIRST MOMENT        C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATE X.          C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ CLOC    = LOCAL ORIGIN OVER WHICH MOMENT IX IS TO BE EVALUATED.   C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN WEIGHTING FACTOR.        C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION CLOC(3),IVCT(3)
      DIMENSION APH(MB2),CP(MB2,3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX INTO A VECTOR
      CALL NCART(IVCT,IX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMOMNT1: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMOMNT1: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     FINITE SUM ADDRESSES FOR CARTESIAN OVERLAPS OF INTEREST
      IAD0 = IABC(     0 ,     0 ,     0 )
      IAD1 = IABC(IVCT(1),IVCT(2),IVCT(3))
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX  = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY  = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ  = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          CP(M,1) = PX-CLOC(1)
          CP(M,2) = PY-CLOC(2)
          CP(M,3) = PZ-CLOC(3)
C
C         FACTORS
          ERT = DSQRT(PI/EIJ)**3
C
C         INTEGRALS FOR THIS BLOCK
          TA1 = CP(M,IX)*E11(M,IAD0) + E11(M,IAD1)
          TA2 = CP(M,IX)*E11(M,IAD0) + E21(M,IAD1)
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VMOMNT2(VIJ,CLOC,DLOC,ITT,IQ,IX,JX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 222222   C
C VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   22    22  C
C VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT         22  C
C VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT       22    C
C  VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT     22      C
C   VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT   22        C
C    VV    MM       MM  OOOOOO  MM       MM NN    NN    TT   22222222  C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMOMNT2 CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X.X'|ν,T') SECOND MOMENT    C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATES X AND X'.  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ CLOC    = LOCAL ORIGIN OVER WHICH MOMENT IX IS TO BE EVALUATED.   C
C  ▶ DLOC    = LOCAL ORIGIN OVER WHICH MOMENT JX IS TO BE EVALUATED.   C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z} 1ST CARTESIAN WEIGHTING FACTOR.    C
C  ▶ JX      = {1,2,3}   -> {X,Y,Z} 2ND CARTESIAN WEIGHTING FACTOR.    C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION CLOC(3),DLOC(3),IVCT(3),JVCT(3)
      DIMENSION CP(MB2,3),DP(MB2,3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX AND JX INTO VECTORS
      CALL NCART(IVCT,IX)
      CALL NCART(JVCT,JX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMOMNT2: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMOMNT2: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     FINITE SUM ADDRESSES FOR CARTESIAN OVERLAPS OF INTEREST
      IAD00 = IABC(             0 ,             0 ,             0 )
      IAD10 = IABC(IVCT(1)        ,IVCT(2)        ,IVCT(3)        )
      IAD01 = IABC(        JVCT(1),        JVCT(2),        JVCT(3))
      IAD11 = IABC(IVCT(1)+JVCT(1),IVCT(2)+JVCT(2),IVCT(3)+JVCT(3))
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          CP(M,1) = PX-CLOC(1)
          CP(M,2) = PY-CLOC(2)
          CP(M,3) = PZ-CLOC(3)
          DP(M,1) = PX-DLOC(1)
          DP(M,2) = PY-DLOC(2)
          DP(M,3) = PZ-DLOC(3)
C
C         FACTORS
          ERT = DSQRT(PI/EIJ)**3
C
C         INTEGRALS FOR THIS BLOCK
          IF(IX.EQ.JX) THEN
            TA1 = 2.0D0*CP(M,IX)*DP(M,JX)*E11(M,IAD00)
            TA2 = 2.0D0*CP(M,IX)*DP(M,JX)*E21(M,IAD00)
          ELSE
            TA1 =       CP(M,IX)*DP(M,JX)*E11(M,IAD00)
            TA2 =       CP(M,IX)*DP(M,JX)*E21(M,IAD00)
          ENDIF
          IF(NTUV.GT.1) THEN
            TA1 = TA1 + DP(M,JX)*E11(M,IAD10)+CP(M,IX)*E11(M,IAD01)
            TA2 = TA2 + DP(M,JX)*E21(M,IAD10)+CP(M,IX)*E21(M,IAD01)
          ENDIF
          IF(NTUV.GT.2) THEN
            TA1 = TA1 + E11(M,IAD11)
            TA2 = TA2 + E21(M,IAD11)
          ENDIF
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOPS OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VMNPOLE(VIJ,CLOC,ITT,IQ,IX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  VV    VV MM       MM NN    NN PPPPPPP   OOOOOO  LL       EEEEEEEE   C
C  VV    VV MMM     MMM NNN   NN PP    PP OO    OO LL       EE         C
C  VV    VV MMMM   MMMM NNNN  NN PP    PP OO    OO LL       EE         C
C  VV    VV MM MM MM MM NN NN NN PP    PP OO    OO LL       EEEEEE     C
C   VV  VV  MM  MMM  MM NN  NNNN PPPPPPP  OO    OO LL       EE         C
C    VVVV   MM   M   MM NN   NNN PP       OO    OO LL       EE         C
C     VV    MM       MM NN    NN PP        OOOOOO  LLLLLLLL EEEEEEEE   C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMNPOLE CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X/R^3|ν,T') FIELD           C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATE X.          C
C  EXAMPLE: VALUE OF THE ELECTRIC FIELD AT COORDINATE CVEC.            C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ CLOC    = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                  C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC.          C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION CLOC(3),IVCT(3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX INTO A VECTOR
      CALL NCART(IVCT,IX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMNPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMNPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT C_LOC
          CP(M,1) = CLOC(1)-PX
          CP(M,2) = CLOC(2)-PY
          CP(M,3) = CLOC(3)-PZ
C
C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
          APH(M) = EIJ
          PNC(M) = 2.0D0*PI/EIJ
C
        ENDDO
      ENDDO
C
C     GENERATE A BATCH OF R-INTEGRALS (ADD ONE TO USUAL SUM ORDER)
      CALL CPU_TIME(TDM1)
      CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
      CALL CPU_TIME(TDM2)
C
C     ADD TO RELEVANT TIME COUNTER
      IF(ITT.EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITT.EQ.2) THEN
        TRLS = TRLS+TDM2-TDM1
      ELSEIF(ITT.EQ.3) THEN
        TRSL = TRSL+TDM2-TDM1
      ELSEIF(ITT.EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FINITE EXPANSION ADDRESSES
          DO ITUV=1,NTUV
C
C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
            IT = IA(ITUV)
            IU = IB(ITUV)
            IV = IC(ITUV)
C
C           ADD CARTESTIAN COMPONENT IX TO OVERALL ADDRESS (R-INTS)
            ITV1 = IABC(IT+IVCT(1),IU+IVCT(2),IV+IVCT(3))
C
C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
            TA1 = TA1 - E11(M,ITUV)*RC(M,ITV1)
            TA2 = TA2 - E21(M,ITUV)*RC(M,ITV1)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VDIPOLE(VIJ,CLOC,DLOC,ITT,IQ,IX,JX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       VV    VV DDDDDDD IIII PPPPPPP   OOOOOO  LL      EEEEEEEE       C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EE             C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EE             C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EEEEEE         C
C        VV  VV  DD    DD II  PPPPPPP  OO    OO LL      EE             C
C         VVVV   DD    DD II  PP       OO    OO LL      EE             C
C          VV    DDDDDDD IIII PP        OOOOOO  LLLLLLL EEEEEEEE       C
C                                                                      C
C -------------------------------------------------------------------- C
C  VDIPOLE CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X'.X/R^3|ν,T') FIELD        C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATES X AND X'.  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ CLOC    = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                  C
C  ▶ DLOC    = LOCAL ORIGIN FOR FIRST MOMENT FIELD POINT.              C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC (FIELD).  C
C  ▶ JX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR DLOC (MOMENT). C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION CLOC(3),DLOC(3),IVCT(3),JVCT(3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),PD(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX AND JX INTO VECTORS
      CALL NCART(IVCT,IX)
      CALL NCART(JVCT,JX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VDIPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VDIPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT CLOC
          CP(M,1) = CLOC(1)-PX
          CP(M,2) = CLOC(2)-PY
          CP(M,3) = CLOC(3)-PZ
C
C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
          PD(M,1) = PX-DLOC(1)
          PD(M,2) = PY-DLOC(2)
          PD(M,3) = PZ-DLOC(3)
C
C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
          APH(M) = EIJ
          PNC(M) = 2.0D0*PI/EIJ
C
        ENDDO
      ENDDO
C
C     GENERATE A BATCH OF R-INTEGRALS (ADD TWO TO SUM ORDER)
      CALL CPU_TIME(TDM1)
      CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+2)
      CALL CPU_TIME(TDM2)
C
C     ADD TO RELEVANT TIME COUNTER
      IF(ITT.EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITT.EQ.2) THEN
        TRLS = TRLS+TDM2-TDM1
      ELSEIF(ITT.EQ.3) THEN
        TRSL = TRSL+TDM2-TDM1
      ELSEIF(ITT.EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ENDIF
C
C     ELECTRIC FIELD MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FINITE EXPANSION ADDRESSES
          DO ITUV=1,NTUV
C
C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
            IT = IA(ITUV)
            IU = IB(ITUV)
            IV = IC(ITUV)
C
C           FIRST TERM
            IT1 = IT+IVCT(1)+JVCT(1)
            IU1 = IU+IVCT(2)+JVCT(2)
            IV1 = IV+IVCT(3)+JVCT(3)
            R1  = 0.5D0*RC(M,IABC(IT1,IU1,IV1))/APH(M)
C
C           SECOND TERM
            IT2 = IT+IVCT(1)
            IU2 = IU+IVCT(2)
            IV2 = IV+IVCT(3)
            R2  = PD(M,JX)*RC(M,IABC(IT2,IU2,IV2))
C
C           THIRD TERM
            IT3 = IT+IVCT(1)-JVCT(1)
            IU3 = IU+IVCT(2)-JVCT(2)
            IV3 = IV+IVCT(3)-JVCT(3)
            IF(IT3.GE.0.AND.IU3.GE.0.AND.IV3.GE.0) THEN
              ID3 = IT*JVCT(1) + IU*JVCT(2) + IV*JVCT(3)
              R3  = DFLOAT(ID3)*RC(M,IABC(IT3,IU3,IV3))
            ELSE
              R3  = 0.0D0
            ENDIF
C
C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
            TA1 = TA1 - E11(M,ITUV)*(R1+R2+R3)
            TA2 = TA2 - E21(M,ITUV)*(R1+R2+R3)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VSETGTN(VX,VY,VZ,ZORI,IQ,IX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     VV    VV  SSSSSS  EEEEEEEE TTTTTTTT GGGGGG TTTTTTTT NN    NN     C
C     VV    VV SS    SS EE          TT   GG    GG   TT    NNN   NN     C
C     VV    VV SS       EE          TT   GG         TT    NNNN  NN     C
C     VV    VV  SSSSSS  EEEEEE      TT   GG         TT    NN NN NN     C
C      VV  VV        SS EE          TT   GG   GGG   TT    NN  NNNN     C
C       VVVV   SS    SS EE          TT   GG    GG   TT    NN   NNN     C
C        VV     SSSSSS  EEEEEEEE    TT    GGGGGG    TT    NN    NN     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VSETGTN IS A MODIFIED VERSION OF VDIPOLE FOR USE IN THE GTENSOR     C
C  ROUTINE. IT CONSTRUCTS (μ,T|σ_Q.X'.X/R^3|ν,T') FOR IQ, IX, THE      C
C  NUCLEAR ORIGIN ZORI, AND THE FULL SET JX = {X,Y,Z}.                 C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ZORI  = LOCATION OF NUCLEUS (ORIGIN OF JX MOMENT).                C
C  ▶ IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.             C
C  ▶ IX    = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR FIELD TERM.      C
C  OUTPUT:                                                             C
C  ▶ VX - FULL MATRIX OF ELEMENTS WITH JX = X.                         C
C  ▶ VY - FULL MATRIX OF ELEMENTS WITH JX = Y.                         C
C  ▶ VZ - FULL MATRIX OF ELEMENTS WITH JX = Z.                         C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION ZORI(3),IVCT(3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),PD(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 TXLS1,TXLS2,TYLS1,TYLS2,TZLS1,TZLS2
      COMPLEX*16 TXSL1,TXSL2,TYSL1,TYSL2,TZSL1,TZSL2
      COMPLEX*16 ELS11(MB2,MEQ),ELS21(MB2,MEQ)
      COMPLEX*16 ESL11(MB2,MEQ),ESL21(MB2,MEQ)
      COMPLEX*16 VX(MDM,MDM),VY(MDM,MDM),VZ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MATRIX ELEMENT ARRAYS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VX(I,J) = DCMPLX(0.0D0,0.0D0)
          VY(I,J) = DCMPLX(0.0D0,0.0D0)
          VZ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX INTO A VECTOR
      CALL NCART(IVCT,IX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDER FOR SL/LS OVERLAP
      LAM = LQN(1)+LQN(2)+1
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLSMK(ELS11,ELS21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,IQ)
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSLMK(ESL11,ESL21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,IQ)
      CALL CPU_TIME(TDM2)
      TESL = TESL+TDM2-TDM1
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1)+EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1)+EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1)+EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT
          CP(M,1) = ZORI(1)-PX
          CP(M,2) = ZORI(2)-PY
          CP(M,3) = ZORI(3)-PZ
C
C         RELATIVE COORDINATES OF MOMENT ORIGIN (ZERO HERE)
          PD(M,1) = PX
          PD(M,2) = PY
          PD(M,3) = PZ
C
C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
          APH(M) = EIJ
          PNC(M) = 2.0D0*PI/EIJ
C
        ENDDO
      ENDDO
C
C     GENERATE A BATCH OF R-INTEGRALS (ADD TWO TO SUM ORDER)
      CALL CPU_TIME(TDM1)
      CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+2)
      CALL CPU_TIME(TDM2)
C
C     ADD TO RELEVANT TIME COUNTER
      TRLS = TRLS + 0.5D0*(TDM2-TDM1)
      TRSL = TRSL + 0.5D0*(TDM2-TDM1)
C
C     ELECTRIC FIELD MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
          TXLS1 = DCMPLX(0.0D0,0.0D0)
          TXLS2 = DCMPLX(0.0D0,0.0D0)
          TYLS1 = DCMPLX(0.0D0,0.0D0)
          TYLS2 = DCMPLX(0.0D0,0.0D0)
          TZLS1 = DCMPLX(0.0D0,0.0D0)
          TZLS2 = DCMPLX(0.0D0,0.0D0)
          TXSL1 = DCMPLX(0.0D0,0.0D0)
          TXSL2 = DCMPLX(0.0D0,0.0D0)
          TYSL1 = DCMPLX(0.0D0,0.0D0)
          TYSL2 = DCMPLX(0.0D0,0.0D0)
          TZSL1 = DCMPLX(0.0D0,0.0D0)
          TZSL2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FINITE EXPANSION ADDRESSES
          DO ITUV=1,NTUV
C
C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
            IT = IA(ITUV)
            IU = IB(ITUV)
            IV = IC(ITUV)
C
C           ELECTRIC FIELD OFFSET
            IT1 = IT+IVCT(1)
            IU1 = IU+IVCT(2)
            IV1 = IV+IVCT(3)
C
C           FIRST TERM
            R1X = 0.5D0*RC(M,IABC(IT1+1,IU1  ,IV1  ))/APH(M)
            R1Y = 0.5D0*RC(M,IABC(IT1  ,IU1+1,IV1  ))/APH(M)
            R1Z = 0.5D0*RC(M,IABC(IT1  ,IU1  ,IV1+1))/APH(M)
C
C           SECOND TERM
            R2X = PD(M,1)*RC(M,IABC(IT1  ,IU1  ,IV1  ))
            R2Y = PD(M,2)*RC(M,IABC(IT1  ,IU1  ,IV1  ))
            R2Z = PD(M,3)*RC(M,IABC(IT1  ,IU1  ,IV1  ))
C
C           THIRD TERM
            IF(IT1.GE.0.AND.IU1.GE.0.AND.IV1.GE.0) THEN
              R3X  = DFLOAT(IT)*RC(M,IABC(IT1-1,IU1  ,IV1  ))
            ELSE
              R3X  = 0.0D0
            ENDIF
            IF(IT1.GE.0.AND.IU1.GE.0.AND.IV1.GE.0) THEN
              R3Y  = DFLOAT(IU)*RC(M,IABC(IT1  ,IU1-1,IV1  ))
            ELSE
              R3Y  = 0.0D0
            ENDIF
            IF(IT1.GE.0.AND.IU1.GE.0.AND.IV1.GE.0) THEN
              R3Z  = DFLOAT(IV)*RC(M,IABC(IT1  ,IU1  ,IV1-1))
            ELSE
              R3Z  = 0.0D0
            ENDIF
C
C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
            TXLS1 = TXLS1 - ELS11(M,ITUV)*(R1X+R2X+R3X)
            TXLS2 = TXLS2 - ELS21(M,ITUV)*(R1X+R2X+R3X)
            TYLS1 = TYLS1 - ELS11(M,ITUV)*(R1Y+R2Y+R3Y)
            TYLS2 = TYLS2 - ELS21(M,ITUV)*(R1Y+R2Y+R3Y)
            TZLS1 = TZLS1 - ELS11(M,ITUV)*(R1Z+R2Z+R3Z)
            TZLS2 = TZLS2 - ELS21(M,ITUV)*(R1Z+R2Z+R3Z)
C
            TXSL1 = TXSL1 - ESL11(M,ITUV)*(R1X+R2X+R3X)
            TXSL2 = TXSL2 - ESL21(M,ITUV)*(R1X+R2X+R3X)
            TYSL1 = TYSL1 - ESL11(M,ITUV)*(R1Y+R2Y+R3Y)
            TYSL2 = TYSL2 - ESL21(M,ITUV)*(R1Y+R2Y+R3Y)
            TZSL1 = TZSL1 - ESL11(M,ITUV)*(R1Z+R2Z+R3Z)
            TZSL2 = TZSL2 - ESL21(M,ITUV)*(R1Z+R2Z+R3Z)
C
          ENDDO
C
C         SMALL-COMPONENT ADDRESSES
          KBAS = IBAS+NSKP
          LBAS = JBAS+NSKP
C
C         MATRIX ELEMENTS
          VX(NA1+IBAS,NB1+LBAS) = PNC(M)*TXLS1
          VX(NA2+IBAS,NB1+LBAS) = PNC(M)*TXLS2
          VX(NA1+IBAS,NB2+LBAS) =-PHS*DCONJG(VX(NA2+IBAS,NB1+LBAS))
          VX(NA2+IBAS,NB2+LBAS) = PHS*DCONJG(VX(NA1+IBAS,NB1+LBAS))
C
          VY(NA1+IBAS,NB1+LBAS) = PNC(M)*TYLS1
          VY(NA2+IBAS,NB1+LBAS) = PNC(M)*TYLS2
          VY(NA1+IBAS,NB2+LBAS) =-PHS*DCONJG(VY(NA2+IBAS,NB1+LBAS))
          VY(NA2+IBAS,NB2+LBAS) = PHS*DCONJG(VY(NA1+IBAS,NB1+LBAS))
C
          VZ(NA1+IBAS,NB1+LBAS) = PNC(M)*TZLS1
          VZ(NA2+IBAS,NB1+LBAS) = PNC(M)*TZLS2
          VZ(NA1+IBAS,NB2+LBAS) =-PHS*DCONJG(VZ(NA2+IBAS,NB1+LBAS))
          VZ(NA2+IBAS,NB2+LBAS) = PHS*DCONJG(VZ(NA1+IBAS,NB1+LBAS))
C
          VX(NA1+KBAS,NB1+JBAS) = PNC(M)*TXSL1
          VX(NA2+KBAS,NB1+JBAS) = PNC(M)*TXSL2
          VX(NA1+KBAS,NB2+JBAS) =-PHS*DCONJG(VX(NA2+KBAS,NB1+JBAS))
          VX(NA2+KBAS,NB2+JBAS) = PHS*DCONJG(VX(NA1+KBAS,NB1+JBAS))
C
          VY(NA1+KBAS,NB1+JBAS) = PNC(M)*TYSL1
          VY(NA2+KBAS,NB1+JBAS) = PNC(M)*TYSL2
          VY(NA1+KBAS,NB2+JBAS) =-PHS*DCONJG(VY(NA2+KBAS,NB1+JBAS))
          VY(NA2+KBAS,NB2+JBAS) = PHS*DCONJG(VY(NA1+KBAS,NB1+JBAS))
C
          VZ(NA1+KBAS,NB1+JBAS) = PNC(M)*TZSL1
          VZ(NA2+KBAS,NB1+JBAS) = PNC(M)*TZSL2
          VZ(NA1+KBAS,NB2+JBAS) =-PHS*DCONJG(VZ(NA2+KBAS,NB1+JBAS))
          VZ(NA2+KBAS,NB2+JBAS) = PHS*DCONJG(VZ(NA1+KBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     MULTIPLY EQLS COEFFICIENTS BY +i AND EQSL COEFFICIENTS BY -i
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VX(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
          VY(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
          VZ(I     ,J     ) = DCMPLX(0.0D0,0.0D0)
          VX(I+NSKP,J     ) = CONE*VX(I+NSKP,J     )
          VY(I+NSKP,J     ) = CONE*VY(I+NSKP,J     )
          VZ(I+NSKP,J     ) = CONE*VZ(I+NSKP,J     )
          VX(I     ,J+NSKP) =-CONE*VX(I     ,J+NSKP)
          VY(I     ,J+NSKP) =-CONE*VY(I     ,J+NSKP)
          VZ(I     ,J+NSKP) =-CONE*VZ(I     ,J+NSKP)
          VX(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)
          VY(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)        
          VZ(I+NSKP,J+NSKP) = DCMPLX(0.0D0,0.0D0)        
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE VQDPOLE(VIJ,CLOC,DLOC,ELOC,ITT,IQ,IX,JX,KX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   VV    VV   QQQQQQ    DDDDDDD  PPPPPPP   OOOOOO  LL      EEEEEEEE   C
C   VV    VV  QQ    QQ   DD    DD PP    PP OO    OO LL      EE         C
C   VV    VV QQ      QQ  DD    DD PP    PP OO    OO LL      EE         C
C   VV    VV QQ      QQ  DD    DD PP    PP OO    OO LL      EEEEEE     C
C    VV  VV  QQ      QQ  DD    DD PPPPPPP  OO    OO LL      EE         C
C     VVVV    QQ    QQ   DD    DD PP       OO    OO LL      EE         C
C      VV      QQQQQQ QQ DDDDDDD  PP        OOOOOO  LLLLLLL EEEEEEEE   C
C                                                                      C
C -------------------------------------------------------------------- C
C  VQDPOLE CONSTRUCTS A MATRIX OF (μ,T|σ_Q.X'.X''.X/R^3|ν,T') FIELD    C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDS X, X' AND X''.  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ CLOC    = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                  C
C  ▶ DLOC    = LOCAL ORIGIN FOR SECOND MOMENT FIELD POINT (PART 1).    C
C  ▶ ELOC    = LOCAL ORIGIN FOR SECOND MOMENT FIELD POINT (PART 2).    C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC (FIELD).  C
C  ▶ JX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR DLOC (MOMENT). C
C  ▶ KX      = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR ELOC (MOMENT). C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION CLOC(3),DLOC(3),ELOC(3),IVCT(3),JVCT(3),KVCT(3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),PD(MB2,3),PE(MB2,3)
      DIMENSION APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX, JX AND KX INTO VECTORS
      CALL NCART(IVCT,IX)
      CALL NCART(JVCT,JX)
      CALL NCART(KVCT,KX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VQDPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VQDPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT CLOC
          CP(M,1) = CLOC(1)-PX
          CP(M,2) = CLOC(2)-PY
          CP(M,3) = CLOC(3)-PZ
C
C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
          PD(M,1) = PX-DLOC(1)
          PD(M,2) = PY-DLOC(2)
          PD(M,3) = PZ-DLOC(3)
C
C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
          PE(M,1) = PX-ELOC(1)
          PE(M,2) = PY-ELOC(2)
          PE(M,3) = PZ-ELOC(3)
C
C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
          APH(M) = EIJ
          PNC(M) = 2.0D0*PI/EIJ
C
        ENDDO
      ENDDO
C
C     GENERATE A BATCH OF R-INTEGRALS (ADD THREE TO SUM ORDER)
      CALL CPU_TIME(TDM1)
      CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+3)
      CALL CPU_TIME(TDM2)
C
C     ADD TO RELEVANT TIME COUNTER
      IF(ITT.EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITT.EQ.2) THEN
        TRLS = TRLS+TDM2-TDM1
      ELSEIF(ITT.EQ.3) THEN
        TRSL = TRSL+TDM2-TDM1
      ELSEIF(ITT.EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FINITE EXPANSION ADDRESSES
          DO ITUV=1,NTUV
C
C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
            IT = IA(ITUV)
            IU = IB(ITUV)
            IV = IC(ITUV)
C
C           FIRST TERM
            IT1 = IT+IVCT(1)+JVCT(1)+KVCT(1)
            IU1 = IU+IVCT(2)+JVCT(2)+KVCT(2)
            IV1 = IV+IVCT(3)+JVCT(3)+KVCT(3)
            R1  = 0.25D0*RC(M,IABC(IT1,IU1,IV1))/(APH(M)*APH(M))
C
C           SECOND TERM
            IT2 = IT+IVCT(1)+JVCT(1)
            IU2 = IU+IVCT(2)+JVCT(2)
            IV2 = IV+IVCT(3)+JVCT(3)
            R2  = 0.5D0*PE(M,KX)*RC(M,IABC(IT2,IU2,IV2))/APH(M)
C
C           THIRD TERM
            IT3 = IT+IVCT(1)+JVCT(1)-KVCT(1)
            IU3 = IU+IVCT(2)+JVCT(2)-KVCT(2)
            IV3 = IV+IVCT(3)+JVCT(3)-KVCT(3)
            IF(IT3.GT.0.AND.IU3.GT.0.AND.IV3.GT.0) THEN
              ID3 = (IT+JVCT(1))*KVCT(1)+(IU+JVCT(2))*KVCT(2)
     &                                  +(IV+JVCT(3))*KVCT(3)
              R3  = 0.5D0*ID3*RC(M,IABC(IT3,IU3,IV3))/APH(M)
            ELSE
              R3  = 0.0D0
            ENDIF
C
C           FOURTH TERM
            IT4 = IT+IVCT(1)        +KVCT(1)
            IU4 = IU+IVCT(2)        +KVCT(2)
            IV4 = IV+IVCT(3)        +KVCT(3)
            R4  = 0.5D0*PD(M,JX)*RC(M,IABC(IT4,IU4,IV4))/APH(M)
C
C           FIFTH TERM
            IT5 = IT+IVCT(1)
            IU5 = IU+IVCT(2)
            IV5 = IV+IVCT(3)
            R5  = PD(M,JX)*PE(M,KX)*RC(M,IABC(IT5,IU5,IV5))
C
C           SIXTH TERM
            IT6 = IT+IVCT(1)-KVCT(1)
            IU6 = IU+IVCT(2)-KVCT(2)
            IV6 = IV+IVCT(3)-KVCT(3)
            IF(IT6.GT.0.AND.IU6.GT.0.AND.IV6.GT.0) THEN
              ID6 = IT*KVCT(1)+IU*KVCT(2)+IV*KVCT(3)
              R6  = ID6*PD(M,JX)*RC(M,IABC(IT6,IU6,IV6))
            ELSE
              R6  = 0.0D0
            ENDIF
C
C           SEVENTH TERM
            IT7 = IT+IVCT(1)-JVCT(1)+KVCT(1)
            IU7 = IU+IVCT(2)-JVCT(2)+KVCT(2)
            IV7 = IV+IVCT(3)-JVCT(3)+KVCT(3)
            IF(IT7.GT.0.AND.IU7.GT.0.AND.IV7.GT.0) THEN
              ID7 = IT*JVCT(1)+IU*JVCT(2)+IV*JVCT(3)
              R7  = 0.5D0*ID7*RC(M,IABC(IT7,IU7,IV7))/APH(M)
            ELSE
              R7  = 0.0D0
            ENDIF
C
C           EIGHTH TERM
            IT8 = IT+IVCT(1)-JVCT(1)
            IU8 = IU+IVCT(2)-JVCT(2)
            IV8 = IV+IVCT(3)-JVCT(3)
            IF(IT8.GT.0.AND.IU8.GT.0.AND.IV8.GT.0) THEN
              ID8 = IT*JVCT(1)+IU*JVCT(2)+IV*JVCT(3)
              R8  = ID8*PE(M,KX)*RC(M,IABC(IT8,IU8,IV8))
            ELSE
              R8  = 0.0D0
            ENDIF
C
C           NINTH TERM
            IT9 = IT+IVCT(1)-JVCT(1)-KVCT(1)
            IU9 = IU+IVCT(2)-JVCT(2)-KVCT(2)
            IV9 = IV+IVCT(3)-JVCT(3)-KVCT(3)
            IF(IT9.GT.0.AND.IU9.GT.0.AND.IV9.GT.0) THEN
              ID9 = IT*JVCT(1)+IU*JVCT(2)+IV*JVCT(3)
              JD9 = (IT-JVCT(1))*KVCT(1)+(IU-JVCT(2))*KVCT(2)
     &                                  +(IV-JVCT(3))*KVCT(3)
              R9  = ID9*JD9*PE(M,KX)*RC(M,IABC(IT9,IU9,IV9))
            ELSE
              R9  = 0.0D0
            ENDIF
C
C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
            TA1 = TA1 - E11(M,ITUV)*(R1+R2+R3+R4+R5+R6+R7+R8+R9)
            TA2 = TA2 - E21(M,ITUV)*(R1+R2+R3+R4+R5+R6+R7+R8+R9)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VNCATRC(VIJ,ZEFF,IZ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC     AA   TTTTTTTT RRRRRRR   CCCCCC      C
C    VV    VV NNN   NN CC    CC   AAAA     TT    RR    RR CC    CC     C
C    VV    VV NNNN  NN CC        AA  AA    TT    RR    RR CC           C
C    VV    VV NN NN NN CC       AA    AA   TT    RR    RR CC           C
C     VV  VV  NN  NNNN CC       AAAAAAAA   TT    RRRRRRR  CC           C
C      VVVV   NN   NNN CC    CC AA    AA   TT    RR    RR CC    CC     C
C       VV    NN    NN  CCCCCC  AA    AA   TT    RR    RR  CCCCCC      C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCATRC CONSTRUCTS A MATRIX OF (μ,T|V_nuc|ν,T') OVERLAP             C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C  NOTE: DOES NOT INCLUDE NUCLEAR CHARGE OF IZ -- APPLY EXTERNALLY.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ      = NUCLEAR CENTRE OF INTEREST, AS LISTED IN INPUT FILE.    C
C  ▶ ZEFF    = EFFECTIVE CHARGE OF NUCLEAR CENTRE IZ.                  C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT C_LOC
          CP(M,1) = BXYZ(1,IZ)-PX
          CP(M,2) = BXYZ(2,IZ)-PY
          CP(M,3) = BXYZ(3,IZ)-PZ
C
        ENDDO
      ENDDO
C
      IF(NNUC(IZ).EQ.0) THEN
C     POINT-NUCLEAR APPROXIMATION
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           POINT-NUCLEUS EFFECTIVE PARAMETERS
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
            APH(M) = EIJ
            PNC(M) = 2.0D0*ZEFF*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
        CALL CPU_TIME(TDM2)
C
C       ADD TO RELEVANT TIME COUNTER
        IF(ITT.EQ.1) THEN
          TRLL = TRLL+TDM2-TDM1
        ELSEIF(ITT.EQ.2) THEN
          TRLS = TRLS+TDM2-TDM1
        ELSEIF(ITT.EQ.3) THEN
          TRSL = TRSL+TDM2-TDM1
        ELSEIF(ITT.EQ.4) THEN
          TRSS = TRSS+TDM2-TDM1
        ENDIF
C
C       CALCULATE OVERLAP MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
            DO ITUV=1,NTUV
              TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
            VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
            VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
C
          ENDDO
        ENDDO
C
      ELSE
C     BEST-FIT EXPANSION
C
C       LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
        DO IFT=1,NNUC(IZ)
C
C         GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
          XI = XNUC(IZ,IFT)
          FC = FNUC(IZ,IFT)
C
C         PREPARE ELEMENTS FOR RMAKE
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
              EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
              ESM    = EIJ+XI
              APH(M) = EIJ*XI/ESM
              PNC(M) = 2.0D0*PI*ZEFF*FC*DSQRT(XI/ESM)/EIJ
C
            ENDDO
          ENDDO
C
C         GENERATE A BATCH OF R-INTEGRALS
          CALL CPU_TIME(TDM1)
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
          CALL CPU_TIME(TDM2)
C
C         ADD TO RELEVANT TIME COUNTER
          IF(ITT.EQ.1) THEN
            TRLL = TRLL+TDM2-TDM1
          ELSEIF(ITT.EQ.2) THEN
            TRLS = TRLS+TDM2-TDM1
          ELSEIF(ITT.EQ.3) THEN
            TRSL = TRSL+TDM2-TDM1
          ELSEIF(ITT.EQ.4) THEN
            TRSS = TRSS+TDM2-TDM1
          ENDIF
C
C         CALCULATE OVERLAP MATRIX ELEMENTS
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
              TA1 = DCMPLX(0.0D0,0.0D0)
              TA2 = DCMPLX(0.0D0,0.0D0)
              DO ITUV=1,NTUV
                TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
                TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
              ENDDO
C
C             MATRIX ELEMENTS
              VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
              VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
              VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
              VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
C
            ENDDO
          ENDDO
C
C       END LOOP OVER NUCLEAR BASIS FOR IZ
        ENDDO
C            
      ENDIF
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VPTNCD1(VIJ,IZ,ITT,IQ,IX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      VV    VV PPPPPPP TTTTTTTT NN    NN  CCCCCC  DDDDDDD   11        C
C      VV    VV PP    PP   TT    NNN   NN CC    CC DD    DD 111        C
C      VV    VV PP    PP   TT    NNNN  NN CC       DD    DD  11        C
C      VV    VV PP    PP   TT    NN NN NN CC       DD    DD  11        C
C       VV  VV  PPPPPPP    TT    NN  NNNN CC       DD    DD  11        C
C        VVVV   PP         TT    NN   NNN CC    CC DD    DD  11        C
C         VV    PP         TT    NN    NN  CCCCCC  DDDDDDD  1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCATRC CONSTRUCTS A MATRIX OF (μ,T|V_nuc|ν,T') OVERLAP             C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C  NOTE: DOES NOT INCLUDE NUCLEAR CHARGE OF IZ -- APPLY EXTERNALLY.    C
C -------------------------------------------------------------------- C
C  TODO: THIS IS UNFINISHED -- CURRENTLY JUST VNCATRC.                 C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ      = NUCLEAR CENTRE OF INTEREST, AS LISTED IN INPUT FILE.    C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT C_LOC
          CP(M,1) = BXYZ(1,IZ)-PX
          CP(M,2) = BXYZ(2,IZ)-PY
          CP(M,3) = BXYZ(3,IZ)-PZ
C
        ENDDO
      ENDDO
C
C     LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
      DO IFT=1,NNUC(IZ)
C
C       GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
        XI = XNUC(IZ,IFT)
        FC = FNUC(IZ,IFT)
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER (ZEFF MISSING)
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
            ESM    = EIJ+XI
            APH(M) = EIJ*XI/ESM
            PNC(M) = 2.0D0*PI*FC*DSQRT(XI/ESM)/EIJ
C
C           POINT-NUCLEUS OPTIONS (MUST MANUALLY SET NNUC(IZ=1) HERE)
C           APH(M) = EIJ
C           PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
        CALL CPU_TIME(TDM2)
C
C       ADD TO RELEVANT TIME COUNTER
        IF(ITT.EQ.1) THEN
          TRLL = TRLL+TDM2-TDM1
        ELSEIF(ITT.EQ.2) THEN
          TRLS = TRLS+TDM2-TDM1
        ELSEIF(ITT.EQ.3) THEN
          TRSL = TRSL+TDM2-TDM1
        ELSEIF(ITT.EQ.4) THEN
          TRSS = TRSS+TDM2-TDM1
        ENDIF
C
C       CALCULATE OVERLAP MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
            DO ITUV=1,NTUV
              TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
            VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
            VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
C
          ENDDO
        ENDDO
C
C     END LOOP OVER NUCLEAR BASIS FOR IZ
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VPTNCD2(VIJ,IZ,ITT,IQ,IX,JX,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV PPPPPPP TTTTTTTT NN    NN  CCCCCC  DDDDDDD   222222      C
C    VV    VV PP    PP   TT    NNN   NN CC    CC DD    DD 22    22     C
C    VV    VV PP    PP   TT    NNNN  NN CC       DD    DD       22     C
C    VV    VV PP    PP   TT    NN NN NN CC       DD    DD     22       C
C     VV  VV  PPPPPPP    TT    NN  NNNN CC       DD    DD   22         C
C      VVVV   PP         TT    NN   NNN CC    CC DD    DD 22           C
C       VV    PP         TT    NN    NN  CCCCCC  DDDDDDD  22222222     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCATRC CONSTRUCTS A MATRIX OF (μ,T|V_nuc|ν,T') OVERLAP             C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C  NOTE: DOES NOT INCLUDE NUCLEAR CHARGE OF IZ -- APPLY EXTERNALLY.    C
C -------------------------------------------------------------------- C
C  TODO: THIS IS UNFINISHED -- CURRENTLY JUST VNCATRC.                 C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ      = NUCLEAR CENTRE OF INTEREST, AS LISTED IN INPUT FILE.    C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT C_LOC
          CP(M,1) = BXYZ(1,IZ)-PX
          CP(M,2) = BXYZ(2,IZ)-PY
          CP(M,3) = BXYZ(3,IZ)-PZ
C
        ENDDO
      ENDDO
C
      IF(NNUC(IZ).EQ.0) THEN
C     POINT-NUCLEUS APPROXIMATION
C
C       PREPARE ELEMENTS FOR RMAKE
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           POINT-NUCLEUS EFFECTIVE PARAMETERS
            EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
            APH(M) = EIJ
            PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
        CALL CPU_TIME(TDM2)
C
C       ADD TO RELEVANT TIME COUNTER
        IF(ITT.EQ.1) THEN
          TRLL = TRLL+TDM2-TDM1
        ELSEIF(ITT.EQ.2) THEN
          TRLS = TRLS+TDM2-TDM1
        ELSEIF(ITT.EQ.3) THEN
          TRSL = TRSL+TDM2-TDM1
        ELSEIF(ITT.EQ.4) THEN
          TRSS = TRSS+TDM2-TDM1
        ENDIF
C
C       CALCULATE OVERLAP MATRIX ELEMENTS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
            DO ITUV=1,NTUV
              TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
            VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
            VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
C
          ENDDO
        ENDDO
C
      ELSE
C
C       LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
        DO IFT=1,NNUC(IZ)
C
C         GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
          XI = XNUC(IZ,IFT)
          FC = FNUC(IZ,IFT)
C
C         PREPARE ELEMENTS FOR RMAKE
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER
              EIJ    = EXL(IBAS,1)+EXL(JBAS,2)
              ESM    = EIJ+XI
              APH(M) = EIJ*XI/ESM
              PNC(M) = 2.0D0*PI*ZEFF*FC*DSQRT(XI/ESM)/EIJ
C
            ENDDO
          ENDDO
C
C         GENERATE A BATCH OF R-INTEGRALS
          CALL CPU_TIME(TDM1)
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
          CALL CPU_TIME(TDM2)
C
C         ADD TO RELEVANT TIME COUNTER
          IF(ITT.EQ.1) THEN
            TRLL = TRLL+TDM2-TDM1
          ELSEIF(ITT.EQ.2) THEN
            TRLS = TRLS+TDM2-TDM1
          ELSEIF(ITT.EQ.3) THEN
            TRSL = TRSL+TDM2-TDM1
          ELSEIF(ITT.EQ.4) THEN
            TRSS = TRSS+TDM2-TDM1
          ENDIF
C
C         CALCULATE OVERLAP MATRIX ELEMENTS
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
              TA1 = DCMPLX(0.0D0,0.0D0)
              TA2 = DCMPLX(0.0D0,0.0D0)
              DO ITUV=1,NTUV
                TA1 = TA1 - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
                TA2 = TA2 - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
              ENDDO
C
C             MATRIX ELEMENTS
              VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) +     TA1
              VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) +     TA2
              VIJ(NA1+IBAS,NB2+JBAS) = VIJ(NA1+IBAS,NB2+JBAS) - PHS*TA2
              VIJ(NA2+IBAS,NB2+JBAS) = VIJ(NA2+IBAS,NB2+JBAS) + PHS*TA1
C
            ENDDO
          ENDDO
C
C       END LOOP OVER NUCLEAR BASIS FOR IZ
        ENDDO
C
      ENDIF
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VNCOLAP(VIJ,IZ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   OOOOOO  LL          AA    PPPPPPP     C
C    VV    VV NNN   NN CC    CC OO    OO LL         AAAA   PP    PP    C
C    VV    VV NNNN  NN CC       OO    OO LL        AA  AA  PP    PP    C
C    VV    VV NN NN NN CC       OO    OO LL       AA    AA PP    PP    C
C     VV  VV  NN  NNNN CC       OO    OO LL       AAAAAAAA PPPPPPP     C
C      VVVV   NN   NNN CC    CC OO    OO LL       AA    AA PP          C
C       VV    NN    NN  CCCCCC   OOOOOO  LLLLLLLL AA    AA PP          C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCOLAP CONSTRUCTS A MATRIX OF (μ,T|rho_nuc|ν,T') OVERLAP           C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ IZ                  -> NUCLEAR CENTRE OF INTEREST.                C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCOLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCOLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RPX = PX-BXYZ(1,IZ)
          RPY = PY-BXYZ(2,IZ)
          RPZ = PZ-BXYZ(3,IZ)
C
C         LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
          DO IFT=1,NNUC(IZ)
C
C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
            XI = XNUC(IZ,IFT)
            FC = FNUC(IZ,IFT)
C
C           INCLUDE NUCLEAR EXPONENT
            ESM = EIJ + XI
            ECP = EIJ*XI/ESM
            E12 = DSQRT(XI/ESM)
            E32 = E12*E12*E12
C
C           GAUSSIAN COMPONENT OF HGTF
            GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C           INITIALISE TEMPORARY STORAGE ARRAYS
            TA1 = DCMPLX(0.0D0,0.0D0)
            TA2 = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER ALL {A,B,C}
            DO ITUV=1,NTUV
C
C             CARTESIAN HERMITE POLYNOMIAL VALUES
              HALPH = HERMITE(ECP,RPX,IA(ITUV))
              HBETA = HERMITE(ECP,RPY,IB(ITUV))
              HGAMA = HERMITE(ECP,RPZ,IC(ITUV))
C
C             HGTF IS A PRODUCT OF THESE
              HABC = HALPH*HBETA*HGAMA*GSS
C
C             MULTIPLY BY EQ-COEFF AND ADD TO TOTAL
              TA1 = TA1 + FC*E11(M,ITUV)*HABC
              TA2 = TA2 + FC*E21(M,ITUV)*HABC
C
            ENDDO
C
C           MATRIX ELEMENTS
            VIJ(NA1+IBAS,NB1+JBAS) = VIJ(NA1+IBAS,NB1+JBAS) + E32*TA1
            VIJ(NA2+IBAS,NB1+JBAS) = VIJ(NA2+IBAS,NB1+JBAS) + E32*TA2
C
          ENDDO
C
C         OTHER MATRIX ELEMENTS COME FROM SYMMETRY RELATIONS
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VKNETIC(VIJ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      VV    VV KK    KK NN    NN EEEEEEEE TTTTTTTT IIII CCCCCC        C
C      VV    VV KK   KK  NNN   NN EE          TT     II CC    CC       C
C      VV    VV KK  KK   NNNN  NN EE          TT     II CC             C
C      VV    VV KKKKK    NN NN NN EEEEEE      TT     II CC             C
C       VV  VV  KK  KK   NN  NNNN EE          TT     II CC             C
C        VVVV   KK   KK  NN   NNN EE          TT     II CC    CC       C
C         VV    KK    KK NN    NN EEEEEEEE    TT    IIII CCCCCC        C
C                                                                      C
C -------------------------------------------------------------------- C
C  VKNETIC CONSTRUCTS A MATRIX OF (μ,T|σ_Q(σ.P)|ν,T') OVERLAP          C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION APH(MB2),CP(MB2,3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELSQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELLQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VKNETIC: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VKNETIC: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RPX = PX-XYZ(1,2)
          RPY = PY-XYZ(2,2)
          RPZ = PZ-XYZ(3,2)
          RP2 = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C         FACTORS
          ERT = (DSQRT(PI/EIJ)**3)
          PRE = 8.0D0*DSQRT(EJ*EJ*EJ/(DFLOAT(2*LQN(2))+3.0D0))
C
C         INTEGRALS FOR THIS BLOCK
          IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
            X10 = 0.125D0*(2*LQN(2)+3.0D0)/EJ
          ELSE
            X10 = 0.250D0*(2*LQN(2)+3.0D0)/EJ - 0.5D0*RP2 - 0.75D0/EIJ
          ENDIF
          TA1 = X10*E11(M,1)
          TA2 = X10*E21(M,1)
          IF(ITT.EQ.2.OR.ITT.EQ.4) THEN
            IF(LQN(1)+LQN(2).GT.0) THEN
              TA1 = TA1 - RPX*E11(M,4) - RPY*E11(M,3) - RPZ*E11(M,2)
              TA2 = TA2 - RPX*E21(M,4) - RPY*E21(M,3) - RPZ*E21(M,2)
            ENDIF
            IF(LQN(1)+LQN(2).GT.1) THEN
              TA1 = TA1 - E11(M,10) - E11(M, 7) - E11(M, 5)
              TA2 = TA2 - E21(M,10) - E21(M, 7) - E21(M, 5)
            ENDIF
          ENDIF
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*PRE*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*PRE*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.1) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.4) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VLPLACE(VIJ,ITT,IQ,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV LL       PPPPPPP  LL          AA     CCCCCC  EEEEEEEE    C
C    VV    VV LL       PP    PP LL         AAAA   CC    CC EE          C
C    VV    VV LL       PP    PP LL        AA  AA  CC       EE          C
C    VV    VV LL       PP    PP LL       AA    AA CC       EEEEEE      C
C     VV  VV  LL       PPPPPPP  LL       AAAAAAAA CC       EE          C
C      VVVV   LL       PP       LL       AA    AA CC    CC EE          C
C       VV    LLLLLLLL PP       LLLLLLLL AA    AA  CCCCCC  EEEEEEEE    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VLPLACE CONSTRUCTS A MATRIX OF (μ,T|σ_Q ∇^2|ν,T') OVERLAP           C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION APH(MB2),CP(MB2,3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM),VTEMP(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J)   = DCMPLX(0.0D0,0.0D0)
          VTEMP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VLPLACE: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VLPLACE: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX  = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY  = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ  = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RPX = PX-XYZ(1,2)
          RPY = PY-XYZ(2,2)
          RPZ = PZ-XYZ(3,2)
          RP2 = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C         FACTORS
          ERT = DSQRT(PI/EIJ)**3
          PRE = 8.0D0*EJ*EJ
C
C         INTEGRALS FOR THIS BLOCK
          IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
            X10 = 0.5D0*RP2 + 0.75D0/EIJ - 0.25D0*(2*LQN(2)+3.0D0)/EJ
          ELSE
            X10 = 0.5D0*RP2 + 0.75D0/EIJ - 0.25D0*(2*LQN(2)+5.0D0)/EJ
          ENDIF
          TA1 = X10*E11(M,1)
          TA2 = X10*E21(M,1)
          IF(LQN(1)+LQN(2).GT.0) THEN
            TA1 = TA1 + RPX*E11(M,4) + RPY*E11(M,3) + RPZ*E11(M,2)
            TA2 = TA2 + RPX*E21(M,4) + RPY*E21(M,3) + RPZ*E21(M,2)
          ENDIF
          IF(LQN(1)+LQN(2).GT.1) THEN
            TA1 = TA1 + E11(M,10) + E11(M, 7) + E11(M, 5)
            TA2 = TA2 + E21(M,10) + E21(M, 7) + E21(M, 5)
          ENDIF
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*PRE*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*PRE*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER MQNS
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     MODIFIED SPECIAL CODE FOR VTS ELEMENTS WITH KQN(2)>0.            C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1500 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1500 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2500 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2500 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
        IF(MOD(KB,2).EQ.0.AND.(ITT.EQ.2.OR.ITT.EQ.4)) THEN
C
C         QUANTUM NUMBERS FOR BLOCK B (KQN(2)' = -KQN(2))
          KQN(2) = KAPA(KB-1,ICNTB)
          IF(KQN(2).LT.0) THEN
            LQN(2) =-KQN(2)-1
          ELSE
            LQN(2) = KQN(2)
          ENDIF
C
C         BASIS EXPONENTS FOR BLOCK B
          NBAS(2) = NFNC(LQN(2),ICNTB)
          DO JBAS=1,NBAS(2)
            EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
          ENDDO
C
C         LOOP OVER |MQN(A)| VALUES
          DO 3500 MA=1,IABS(KQN(1))
            MJA    = 2*MA-1
            MQN(1) = MJA
C
C         LOOP OVER |MQN(B)| VALUES
          DO 3500 MB=1,IABS(KQN(2))
            MJB    = 2*MB-1
            MQN(2) = MJB
C
C         CALCULATE COMPONENT OFFSETS (KQN(2)' = -KQN(2))
          NA1 = LRGE(ICNTA,KA  ,2*MA-1)
          NA2 = LRGE(ICNTA,KA  ,2*MA  )
          NB1 = LRGE(ICNTB,KB-1,2*MB-1)
          NB2 = LRGE(ICNTB,KB-1,2*MB  )
C
C         THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
          PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C         OVERLAP TYPE {LS} --> GENERATE ELLQ COEFFICIENTS
          IF(ITT.EQ.2) THEN
            CALL CPU_TIME(TDM1)
            CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
            CALL CPU_TIME(TDM2)
            TELL = TELL+TDM2-TDM1
C         OVERLAP TYPE {SS} --> GENERATE ESLQ COEFFICIENTS
          ELSEIF(ITT.EQ.4) THEN
            CALL CPU_TIME(TDM1)
            CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
            CALL CPU_TIME(TDM2)
            TESL = TESL+TDM2-TDM1
          ENDIF
C
C         CALCULATE OVERLAP MATRIX ELEMENTS
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             EXPONENT COMBINATIONS
              EI  = EXL(IBAS,1)
              EJ  = EXL(JBAS,2)
              EIJ = EI+EJ
C
C             FACTORS
              PRE = 8.0D0*EJ*EJ*DSQRT(PI/EIJ)**3
C
C             INTEGRALS FOR THIS BLOCK
              X10 = CONE*DSQRT((2*LQN(2)+1.0D0)/(2*LQN(2)+3.0D0))/EJ
              TA1 = X10*E11(M,1)
              TA2 = X10*E21(M,1)
C
C             MATRIX ELEMENTS
              VTEMP(NA1+IBAS,NB1+JBAS) = PRE*TA1
              VTEMP(NA2+IBAS,NB1+JBAS) = PRE*TA2
              VTEMP(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(PRE*TA2)
              VTEMP(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(PRE*TA1)
C
            ENDDO
          ENDDO
C
C       END LOOP OVER BLOCKS IN SPECIAL CASE
3500    CONTINUE
C
C     END OF CONDITIONAL FOR SPECIAL CASE
      ENDIF
C
2500  CONTINUE
1500  CONTINUE
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.4) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VTEMP(I,J) =-CONE*VTEMP(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     ADD THESE TO THE VIJ ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = VIJ(I,J) + VTEMP(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     END OF MODIFIED SPECIAL CODE.                                    C
C**********************************************************************C
C
      RETURN
      END
C
C
      SUBROUTINE VPLNWAV(VIJ,ITT,IQ,GLOC,WAVK,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  VV    VV PPPPPPP  LL       NN    NN WW         WW    AA    VV    VV C
C  VV    VV PP    PP LL       NNN   NN WW         WW   AAAA   VV    VV C
C  VV    VV PP    PP LL       NNNN  NN WW         WW  AA  AA  VV    VV C
C  VV    VV PP    PP LL       NN NN NN WW    W    WW AA    AA VV    VV C
C   VV  VV  PPPPPPP  LL       NN  NNNN  WW  WWW  WW  AAAAAAAA  VV  VV  C
C    VVVV   PP       LL       NN   NNN   WWWW WWWW   AA    AA   VVVV   C
C     VV    PP       LLLLLLLL NN    NN    WW   WW    AA    AA    VV    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VPLNWAV CONSTRUCTS A MATRIX OF (μ,T|σ_Q exp(i.K.RG)|ν,T')           C
C  OVERLAP INTEGRALS OVER ALL BASIS FUNCTIONS.                         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITT     = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.       C
C  ▶ IQ      = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING σ MATRIX.           C
C  ▶ GLOC    = (GX,GY,GZ) -> FIXED GAUGE ORIGIN.                       C
C  ▶ WAVK    = (KX,KY,KZ) -> PHOTON WAVE THREE-VECTOR.                 C
C  ▶ IA1,IA2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION GLOC(3),WAVK(3)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,EKP,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 TMP(MBS,MBS,4)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     SQUARE OF WAVK
      WK2 = WAVK(1)*WAVK(1) + WAVK(2)*WAVK(2) + WAVK(3)*WAVK(3)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C       FINITE SUM TERMINATING ORDERS
        IF(ITT.EQ.1) THEN
          LAM = LQN(1)+LQN(2)
        ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
          LAM = LQN(1)+LQN(2)+1
        ELSEIF(ITT.EQ.4) THEN
          LAM = LQN(1)+LQN(2)+2
        ENDIF
C
C       NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,IA1,IA2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VPLNWAV: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VPLNWAV: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS,1)
          EJ  = EXL(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          PGX = PX-GLOC(1)
          PGY = PY-GLOC(2)
          PGZ = PZ-GLOC(3)
C
C         FACTORS
          ERT = DSQRT(PI/EIJ)**3
          DKP = WAVK(1)*PGX + WAVK(2)*PGY + WAVK(3)*PGZ
          EKP = DCOS(DKP) + CONE*DSIN(DKP)
          EKL = DEXP(-0.25D0*WK2/EIJ)
C
C         LOOP OVER TERMS (A,B,C) IN FINITE EXPANSION
          DO ITUV=1,NTUV
C
C           EXPANSION ADDRESSES
            IT = IA(ITUV)
            IU = IB(ITUV)
            IV = IC(ITUV)
            IL = ILAM(ITUV)
C
C           PRODUCT (KX)^A*(KY)^B*(KZ)^C
            EKA = (WAVK(1)**IT)*(WAVK(2)**IU)*(WAVK(3)**IV)
C
C           CONTRIBUTION INVOLVES EKA, CONE**IL AND AN EQ-COEFFICIENT
            TA1 = TA1 + (CONE**IL)*EKA*E11(M,ITUV)
            TA2 = TA2 + (CONE**IL)*EKA*E21(M,ITUV)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*EKP*EKL*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*EKP*EKL*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [10] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] FIELDS: CALCULATE AMPLITUDES, FIELDS AND POTENTIALS.           C
C   [B] GNUMTRX: EXPORT A MATRIX TO AN EXTERNAL DATA FILE AND PLOT IT. C
C   [C] ORBCOEF: PRINT LIST OF EXPANSION COEFFICIENTS FOR AN ORBITAL.  C
C   [D] AMPLTDE: PLOT A DIRAC SPINOR AMPLITUDE ALONG ONE DIRECTION.    C
C   [E] DENSMAP: HEAT MAP OF ELECTRONIC CHARGE DENSITY (ON A 2D GRID). C
C   [F] J4CRRNT: PLOT 4-CURRENT ALONG ONE DIRECTION.                   C
C   [G] POTENTL: PLOT 4-POTENTIAL ALONG ONE DIRECTION.                 C
C   [H] ELCTRCF: PLOT E FIELD ALONG ONE DIRECTION.                     C
C   [I] MAGNTCF: PLOT B FIELD ALONG ONE DIRECTION.                     C
C   [J] FRMFCTR: PLOT THE ELECTRON SCATTERING FORM FACTOR.             C
C   [K] GNULINE: GENERATE A GNUPLOT LINE PLOT MAKE FILE FOR DATA SET.  C
C   [L] GNUDENS: GENERATE A GNUPLOT MATRIX PLOT MAKE FILE FOR DENSITY. C
C   [M] CLEBSCH: CLEBSCH-GORDAN COEFFICIENT FOR KQN,MQN.               C
C   [N] SPHHRM: VALUE OF Y_L^M AT TWO GIVEN ANGLES.                    C
C   [O] PLGNDR: RETURNS AN ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).    C
C   [P] NFACT: INTEGER RESULT OF FACTORIAL N!                          C
C**********************************************************************C
C
C
      SUBROUTINE FIELDS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          FFFFFFFF IIII EEEEEEEE LL       DDDDDDD   SSSSSS            C
C          FF        II  EE       LL       DD    DD SS    SS           C
C          FF        II  EE       LL       DD    DD SS                 C
C          FFFFFF    II  EEEEEE   LL       DD    DD  SSSSSS            C
C          FF        II  EE       LL       DD    DD       SS           C
C          FF        II  EE       LL       DD    DD SS    SS           C
C          FF       IIII EEEEEEEE LLLLLLLL DDDDDDD   SSSSSS            C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  FIELDS CALCULATES AMPLITUDES, EM FIELDS AND POTENTIALS, STORES IN   C
C  EXTERNAL DATA FILES AND PLOTS WHEN CALLED.                          C
C -------------------------------------------------------------------- C
C  FOR NOW PLOTS ARE GENERATED ALONG ONE DIRECTION ONLY FOR ELECTRONIC C
C  CONTRIBUTIONS OVER THE WHOLE MOLECULE. THIS CAN BE EXTENDED TO      C
C  SURFACE AND DENSITY PLOTS.                                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*7  PTYPE(10)
      CHARACTER*16 HMS
C
      DIMENSION XYZI(3),XYZF(3),XYZEDGE(3,3)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/PLOT/NPTYPE,PTYPE
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
      COMMON/TPLT/EMTY
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     EQ-COEFF AND R-INT TIME INITIALISATION
      TELL = 0.0D0
      TESS = 0.0D0
      TELS = 0.0D0
      TESL = 0.0D0
C
C     CALCULATE MOLECULAR DENSITY
      CALL DENSTY
C
C     LOOP OVER NUMBER OF REQUESTED FIELD PLOTS
      DO N=1,NPTYPE
C
C       PRINT A TITLE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) 'Plot for PTYPE = ',PTYPE(N)
        WRITE(7, *) 'Plot for PTYPE = ',PTYPE(N)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       NUMBER OF DATA POINTS
        NPTS = 500
C
C       INITIAL AND FINAL COORDINATES
        DO IX=1,3
          XYZI(IX) = 0.0D0
          XYZF(IX) = 0.0D0
        ENDDO
        XYZI(3) =-1.00D0
        XYZF(3) = 2.40D0
C
        IF(PTYPE(N).EQ.'ORBCOEF') THEN
          CALL ORBCOEF(NSKP+5)
        ELSEIF(PTYPE(N).EQ.'AMPLTDE') THEN
          CALL AMPLTDE(XYZI,XYZF,NPTS,NSKP+9)
        ELSEIF(PTYPE(N).EQ.'DENSMAP') THEN
C
C         NUMBER OF HORIZONTAL AND VERTICAL CELLS
          NHRZ = 1000
          NVRT = 1000
C
C         LOCATION OF VERTEX 1
          XYZEDGE(1,1) =-3.0D0
          XYZEDGE(2,1) = 0.0D0
          XYZEDGE(3,1) = 3.0D0
C
C         LOCATION OF VERTEX 2
          XYZEDGE(1,2) =-3.0D0
          XYZEDGE(2,2) = 0.0D0
          XYZEDGE(3,2) =-3.0D0
C
C         LOCATION OF VERTEX 3
          XYZEDGE(1,3) = 3.0D0
          XYZEDGE(2,3) = 0.0D0
          XYZEDGE(3,3) = 3.0D0
C
C         GENERATE DENSITY MAP
          CALL DENSMAP(XYZEDGE,NHRZ,NVRT)
C
        ELSEIF(PTYPE(N).EQ.'J4CRRNT') THEN
          CALL J4CRRNT(XYZI,XYZF,NPTS)
        ELSEIF(PTYPE(N).EQ.'POTENTL') THEN
          CALL POTENTL(XYZI,XYZF,NPTS)
        ELSEIF(PTYPE(N).EQ.'ELCTRCF') THEN
          CALL ELCTRCF(XYZI,XYZF,NPTS)
        ELSEIF(PTYPE(N).EQ.'MAGNTCF') THEN
          CALL MAGNTCF(XYZI,XYZF,NPTS)
        ELSEIF(PTYPE(N).EQ.'FRMFCTR') THEN
          CALL FRMFCTR(XYZI,XYZF,NPTS)
        ELSE
          WRITE(6, *) 'In FIELDS: plotting option is not available.'
          WRITE(7, *) 'In FIELDS: plotting option is not available.'
        ENDIF
C
C     END LOOP OVER FIELD PLOTS
      ENDDO
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TPLT)
      TPLT = TPLT-TDUM
C
20    FORMAT(1X,A,37X,A)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      IF(TELL.GT.0.3D0) THEN
        WRITE(6,20) 'Time in EMAKE (LL):',HMS(TELL)
        WRITE(7,20) 'Time in EMAKE (LL):',HMS(TELL)
      ENDIF
      IF(TELS.GT.0.3D0) THEN
        WRITE(6,20) 'Time in EMAKE (LS):',HMS(TELS)
        WRITE(7,20) 'Time in EMAKE (LS):',HMS(TELS)
      ENDIF
      IF(TESL.GT.0.3D0) THEN
        WRITE(6,20) 'Time in EMAKE (SL):',HMS(TESL)
        WRITE(7,20) 'Time in EMAKE (SL):',HMS(TESL)
      ENDIF
      IF(TESS.GT.0.3D0) THEN
        WRITE(6,20) 'Time in EMAKE (SS):',HMS(TESS)
        WRITE(7,20) 'Time in EMAKE (SS):',HMS(TESS)
      ENDIF
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE GNUMTRX(ARRAY,TITLE,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   GGGGGG  NN    NN UU    UU MM       MM TTTTTTTT RRRRRRR  XX     XX  C
C  GG    GG NNN   NN UU    UU MMM     MMM    TT    RR    RR  XX   XX   C
C  GG       NNNN  NN UU    UU MMMM   MMMM    TT    RR    RR   XX XX    C
C  GG       NN NN NN UU    UU MM MM MM MM    TT    RR    RR    XXX     C
C  GG   GGG NN  NNNN UU    UU MM  MMM  MM    TT    RRRRRRR    XX XX    C
C  GG    GG NN   NNN UU    UU MM   M   MM    TT    RR    RR  XX   XX   C
C   GGGGGG  NN    NN  UUUUUU  MM       MM    TT    RR    RR XX     XX  C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNUMTRX EXPORTS AN ARRAY TO AN EXTERNAL DATA FILE AND PLOTS IT.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*80 TITLE
C
      DIMENSION ARRAY(MDM,MDM)
C
C     PRINT TO EXTERNAL DATA FILE
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//".dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (ARRAY(I,J),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
      XEND = DFLOAT(NDIM)-0.5D0
      YEND = DFLOAT(NDIM)-0.5D0
C
C     WRITE GNUPLOT MAKE FILE
      OPEN(UNIT=9,FILE='plots/'//TRIM(TITLE)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(TITLE)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(TITLE)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf size 4,4'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(TITLE)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') 'load "plots/pals/rdylgn.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A,F6.1,A)') 'set xrange [-0.5:',XEND,']'
      WRITE(9,'(A,F6.1,A)') 'set yrange [',YEND,':-0.5] reverse'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(TITLE)//'.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(TITLE)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(TITLE)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE ORBCOEF(IORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      OOOOOO  RRRRRRR  BBBBBBB   CCCCCC   OOOOOO  EEEEEEE FFFFFFF     C
C     OO    OO RR    RR BB    BB CC    CC OO    OO EE      FF          C
C     OO    OO RR    RR BB    BB CC       OO    OO EE      FF          C
C     OO    OO RR    RR BBBBBBB  CC       OO    OO EEEEE   FFFFF       C
C     OO    OO RRRRRRR  BB    BB CC       OO    OO EE      FF          C
C     OO    OO RR    RR BB    BB CC    CC OO    OO EE      FF          C
C      OOOOOO  RR    RR BBBBBBB   CCCCCC   OOOOOO  EEEEEEE FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ORBCOEF PRINTS OUT THE EXPANSION COEFFICIENTS FOR IORB, GROUPED     C
C  BY QUANTUM NUMBERS OF BASIS FUNCTIONS.                              C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*2 ELMT(120),ELA
      CHARACTER*5 NMDL
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/MDLV/ELMT
C
C     HEADER FOR COEFFICIENT LIST
20    FORMAT(1X,'****************',A,I3,'  ****************')
21    FORMAT(1X,'Centre ',I2,4X,'(',A,')',5X,'#fns = ',I2,6X,'KQN =',
     &                           I2,6X,'LQN = ',I1,6X,'MQN =',A,I1,'/2')
22    FORMAT(1X,'IADD',9X,'Exponent',10X,A,7X,A)
23    FORMAT(1X,I4,4X,ES13.6,10X,ES17.10,7X,ES17.10)
      WRITE(6,20) '  Expansion coefficients for IORB =',IORB
      WRITE(7,20) '  Expansion coefficients for IORB =',IORB
C
      I = IORB
C
C     LOOP OVER ATOMIC CENTRES
      DO IZ=1,NCNT
C
C       SAVE ELEMENT LABEL
        ELA = ELMT(INT(ZNUC(IZ)))
C
C       LOOP OVER ALL MQNS FOR THIS CENTRE
        MMAX = (NKAP(IZ)+1)/2
        DO IM=1,MMAX
C
C         MAGNITUDE OF THIS MQN
          MQN = 2*IM-1
C
C         MQN < 0: LOOP OVER ALL KQN WITH THIS |MQN|
          DO IK=MQN,NKAP(IZ)
C
C           LARGE-COMPONENT ADDRESS OFFSET
            IAD = LRGE(IZ,IK,MQN  )
C
C           LQN AND KQN VALUES
            IF(MOD(IK,2).EQ.0) THEN
              KQN = IK/2
              LQN = KQN
            ELSE
              KQN =-(IK+1)/2
              LQN =-KQN-1
            ENDIF
C
C           NUMBER OF BASIS FUNCTIONS FOR THIS LQN
            NBAS = NFNC(LQN,IZ)
C
C           ATOMIC ADDRESS DETAILS
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,21) IZ,ELA,NBAS,KQN,LQN,'-',MQN
            WRITE(7,21) IZ,ELA,NBAS,KQN,LQN,'-',MQN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(7,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
C
C           LIST THE EXPONENTS AND CORRESPONDING EXP. COEFFS
            DO IBAS=1,NBAS
              CL = DREAL(COEF(IAD+IBAS     ,IORB))
              CS = DREAL(COEF(IAD+IBAS+NSKP,IORB))
              WRITE(6,23) IAD+IBAS,BEXL(IBAS,LQN,IZ),CL,CS
              WRITE(7,23) IAD+IBAS,BEXL(IBAS,LQN,IZ),CL,CS
            ENDDO
          ENDDO
C
C         MQN > 0: LOOP OVER ALL KQN WITH THIS |MQN|
          DO IK=MQN,NKAP(IZ)
C
C           LARGE-COMPONENT ADDRESS OFFSET
            IAD = LRGE(IZ,IK,MQN+1)
C
C           LQN AND KQN VALUES
            IF(MOD(IK,2).EQ.0) THEN
              KQN = IK/2
              LQN = KQN
            ELSE
              KQN =-(IK+1)/2
              LQN =-KQN-1
            ENDIF
C
C           NUMBER OF BASIS FUNCTIONS FOR THIS LQN
            NBAS = NFNC(LQN,IZ)
C
C           ATOMIC ADDRESS DETAILS
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,21) IZ,ELA,NBAS,KQN,LQN,'+',MQN
            WRITE(7,21) IZ,ELA,NBAS,KQN,LQN,'+',MQN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(7,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
C
C           LIST THE EXPONENTS AND CORRESPONDING EXP. COEFFS
            DO IBAS=1,NBAS
              CL = DREAL(COEF(IAD+IBAS     ,IORB))
              CS = DREAL(COEF(IAD+IBAS+NSKP,IORB))
              WRITE(6,23) IAD+IBAS,BEXL(IBAS,LQN,IZ),CL,CS
              WRITE(7,23) IAD+IBAS,BEXL(IBAS,LQN,IZ),CL,CS
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE AMPLTDE(XYZI,XYZF,NPTS,IORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      AA    MM       MM PPPPPPP  LL      TTTTTTTT DDDDDDD  EEEEEEEE   C
C     AAAA   MMM     MMM PP    PP LL         TT    DD    DD EE         C
C    AA  AA  MMMM   MMMM PP    PP LL         TT    DD    DD EE         C
C   AA    AA MM MM MM MM PP    PP LL         TT    DD    DD EEEEEE     C
C   AAAAAAAA MM  MMM  MM PPPPPPP  LL         TT    DD    DD EE         C
C   AA    AA MM   M   MM PP       LL         TT    DD    DD EE         C
C   AA    AA MM       MM PP       LLLLLLLL   TT    DDDDDDD  EEEEEEEE   C
C                                                                      C
C -------------------------------------------------------------------- C
C  AMPLTDE GENERATES A DATA SET AND GNUPLOT MAKE FILE FOR THE DIRAC    C
C  SPINOR AMPLITUDE OF ORBITAL IORB, ALONG THE Z-AXIS.                 C
C -------------------------------------------------------------------- C
C  TODO: NOT FINISHED.                                                 C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      DIMENSION EXL(MBS),XYZ(3)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
C
      COMPLEX*16 CONE,SPHHRM,CHI1,CHI2,CHI3,CHI4
      COMPLEX*16 PSI(4,0:NPTS)
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EIGC/COEF
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO MU=1,4
          PSI(MU,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER NUCLEAR CENTRES
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE
        XYZ(1) = BXYZ(1,ICNTA)
        XYZ(2) = BXYZ(2,ICNTA)
        XYZ(3) = BXYZ(3,ICNTA)
C
C     LOOP OVER KQN VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       ORBITAL QUANTUM NUMBERS
        KQN = KAPA(KA,ICNTA)
        JQN = 2*IABS(KQN)-1
        IF(KQN.LT.0) THEN
          LQN =-KQN-1
        ELSE
          LQN = KQN
        ENDIF
C
C       BASIS EXPONENTS
        NBAS = NFNC(LQN,ICNTA)
        DO IBAS=1,NBAS
          EXL(IBAS) = BEXL(IBAS,LQN,ICNTA)
        ENDDO
C
C     LOOP OVER |MQN| VALUES
      DO 3000 MA=1,IABS(KQN)
        MJA = 2*MA-1
        MQN = MJA
C
C     EXPANSION COEFFICIENT MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       LOCAL CARTESIAN COORDINATES FOR THIS NUCLEAR CENTRE
        X = XYZEVAL(1)-XYZ(1)
        Y = XYZEVAL(2)-XYZ(2)
        Z = XYZEVAL(3)-XYZ(3)
C
C       LOCAL SPHERICAL COORDINATES FOR THIS NUCLEAR CENTRE
        RAD = DSQRT(X*X+Y*Y+Z*Z)
        THE = DACOS(Z/RAD)
        PHI = DATAN(Y/X)
C
C       PRE-FACTORS FOR NORMALISATION CONSTANTS
        RL = DFLOAT(LQN)
        G1 = TWLG-GAMLOG(2*LQN+3)
        G2 = TWLG-GAMLOG(2*LQN+5)
        R1 = RL+1.5D0
        R2 = RL+0.5D0
C
C       LOOP OVER BASIS FUNCTIONS
        DO IBAS=1,NBAS
C
C         NORMALISATION CONSTANTS
          ELOG = DLOG(2.0D0*EXL(IBAS))
          RNL  = DEXP(0.5D0*(G1+R1*ELOG))
          RNS  = DEXP(0.5D0*(G2+R2*ELOG))
C
C         LARGE AND SMALL RADIAL AMPLITUDES
          FL = RNL*(RAD**(LQN+1))*DEXP(-EXL(IBAS)*RAD*RAD)
          FS = RNS*(KQN+LQN+1.0D0-2.0D0*EXL(IBAS)*RAD*RAD)
     &                          *(RAD**(LQN))*DEXP(-EXL(IBAS)*RAD*RAD)
C
C         CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
          IF(KQN.LT.0) THEN
            CLU  = DSQRT(DFLOAT(JQN+MQN  )/DFLOAT(2*JQN  ))
            CLL  = DSQRT(DFLOAT(JQN-MQN  )/DFLOAT(2*JQN  ))
            CSU  =-DSQRT(DFLOAT(JQN-MQN+2)/DFLOAT(2*JQN+4))
            CSL  = DSQRT(DFLOAT(JQN+MQN+2)/DFLOAT(2*JQN+4))
            CHI1 = CLU*SPHHRM(THE,PHI,(JQN+1)/2,(MQN-1)/2)
            CHI2 = CLL*SPHHRM(THE,PHI,(JQN+1)/2,(MQN+1)/2)
c            CHI3 = CSU*SPHHRM(THE,PHI,(JQN+1)/2,(MQN-1)/2)
c            CHI4 = CSL*SPHHRM(THE,PHI,(JQN+1)/2,(MQN+1)/2)
            CHI3 = CONE
            CHI4 = CONE
          ELSE
            CLU  =-DSQRT(DFLOAT(JQN-MQN+2)/DFLOAT(2*JQN+4))
            CLL  = DSQRT(DFLOAT(JQN+MQN+2)/DFLOAT(2*JQN+4))
            CSU  = DSQRT(DFLOAT(JQN+MQN  )/DFLOAT(2*JQN  ))
            CSL  = DSQRT(DFLOAT(JQN-MQN  )/DFLOAT(2*JQN  ))
            CHI1 = CLU*SPHHRM(THE,PHI,(JQN+1)/2,(MQN-1)/2)
            CHI2 = CLL*SPHHRM(THE,PHI,(JQN+1)/2,(MQN+1)/2)
C            CHI1 = CLU*SPHHRM(THE,PHI,(JQN-1)/2,(MQN-1)/2)
C            CHI2 = CLL*SPHHRM(THE,PHI,(JQN-1)/2,(MQN+1)/2)
c            CHI3 = CSU*SPHHRM(THE,PHI,(JQN-1)/2,(MQN-1)/2)
c            CHI4 = CSL*SPHHRM(THE,PHI,(JQN-1)/2,(MQN+1)/2)
            CHI3 = CONE
            CHI4 = CONE
          ENDIF
C
C         ADDRESS OFFSETS FOR SMALL-COMPONENTS
          KBAS = IBAS+NSKP
C
C         MULTIPLY BY CORRESPONDING EXPANSION COEFFICIENT ELEMENTS
          PSI(1,IPTS) = PSI(1,IPTS) + COEF(NA1+IBAS,IORB)*FL*CHI1/RAD
          PSI(2,IPTS) = PSI(2,IPTS) + COEF(NA2+IBAS,IORB)*FL*CHI2/RAD
C
          IF(HMLT.EQ.'NORL') GOTO 100
C
          PSI(3,IPTS) = PSI(3,IPTS) + COEF(NA1+KBAS,IORB)*FS*CHI3/RAD
          PSI(4,IPTS) = PSI(4,IPTS) + COEF(NA2+KBAS,IORB)*FS*CHI4/RAD
C          
100       CONTINUE
C
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS QUANTUM NUMBERS
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'AMPLTDE'
      TITLE  = 'Amplitude for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{/Symbol y}(z)'
      KEY(1) = '{/Symbol y}^{L}_{u}(z)'
      KEY(2) = '{/Symbol y}^{L}_{d}(z)'
      KEY(3) = '{/Symbol y}^{S}_{u}(z)'
      KEY(4) = '{/Symbol y}^{S}_{d}(z)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(ABS(PSI(MU,IPTS)),MU=1,4)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE DENSMAP(XYZEDGE,NHRZ,NVTC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  DDDDDDD  EEEEEEEE NN    NN  SSSSSS  MM       MM    AA    PPPPPPP    C
C  DD    DD EE       NNN   NN SS    SS MMM     MMM   AAAA   PP    PP   C
C  DD    DD EE       NNNN  NN SS       MMMM   MMMM  AA  AA  PP    PP   C
C  DD    DD EEEEEE   NN NN NN  SSSSSS  MM MM MM MM AA    AA PP    PP   C
C  DD    DD EE       NN  NNNN       SS MM  MMM  MM AAAAAAAA PPPPPPP    C
C  DD    DD EE       NN   NNN SS    SS MM   M   MM AA    AA PP         C
C  DDDDDDD  EEEEEEEE NN    NN  SSSSSS  MM       MM AA    AA PP         C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSMAP GENERATES AND PLOTS A RECTANGULAR ARRAY OF VALUES FOR THE   C
C  ELECTRON CHARGE DENSITY FROM AN SCF SOLUTION. (CHARGE DENSITY IS    C
C  SAVED ON A LOG SCALE TO MAKE VALENCE REGION MORE VISIBLE.)          C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZEDGE(3,3),XYZD(3),XYZEVAL(3),STPHRZ(3),STPVTC(3)
      DIMENSION CART(3,0:NHRZ,0:NVTC)
C
      COMPLEX*16 T11,T12,T21,T22,S11,S12,S21,S22
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ)
      COMPLEX*16 DMAP(0:NHRZ,0:NVTC)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       SELECT AN APPROPRIATE HORIZONAL STEP VALUE (EQUALLY-SPACED GRID)
        IF(NHRZ.EQ.0) THEN
          STPHRZ(IX) = 0.0D0
        ELSE
          STPHRZ(IX) = (XYZEDGE(IX,2)-XYZEDGE(IX,1))/DFLOAT(NHRZ)
        ENDIF
C
C       SELECT AN APPROPRIATE VERTICAL STEP VALUE (EQUALLY-SPACED GRID)
        IF(NVTC.EQ.0) THEN
          STPVTC(IX) = 0.0D0
        ELSE
          STPVTC(IX) = (XYZEDGE(IX,3)-XYZEDGE(IX,1))/DFLOAT(NVTC)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NHRZ
          DO JPTS=0,NVTC
            CART(IX,IPTS,JPTS) = XYZEDGE(IX,1) + IPTS*STPHRZ(IX)
     &                                         + JPTS*STPVTC(IX)
          ENDDO
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NHRZ
        DO JPTS=0,NVTC
          DMAP(IPTS,JPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLLMK(ELL011,ELL021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSSMK(ESS011,ESS021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NHRZ
        DO JPTS=0,NVTC
C
C         SPECIFY CARTESIAN COORDINATES
          DO IX=1,3
            XYZEVAL(IX) = CART(IX,IPTS,JPTS)
          ENDDO
C
C         GENERATE A BATCH OF HGTFS FOR THIS LOCATION
          IF(HMLT.EQ.'NORL') THEN
            CALL HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAMLL)
          ELSE
            CALL HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAMSS)
          ENDIF
C
C         LOOP OVER BASIS FUNCTION PAIRS
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             INITIALISE THE CARTESIAN EXPANSION COUNTERS
              T11 = DCMPLX(0.0D0,0.0D0)
              T12 = DCMPLX(0.0D0,0.0D0)
              T21 = DCMPLX(0.0D0,0.0D0)
              T22 = DCMPLX(0.0D0,0.0D0)
              S11 = DCMPLX(0.0D0,0.0D0)
              S12 = DCMPLX(0.0D0,0.0D0)
              S21 = DCMPLX(0.0D0,0.0D0)
              S22 = DCMPLX(0.0D0,0.0D0)
C
C             ADDRESS OFFSETS FOR SMALL-COMPONENTS
              KBAS = IBAS+NSKP
              LBAS = JBAS+NSKP
C
C             ELL0
              DO ITUV=1,NTUVLL
                T11 = T11 +            ELL011(M,ITUV)*HABC(M,ITUV)
                T12 = T12 - PHS*DCONJG(ELL021(M,ITUV)*HABC(M,ITUV))
                T21 = T21 +            ELL021(M,ITUV)*HABC(M,ITUV)
                T22 = T22 + PHS*DCONJG(ELL011(M,ITUV)*HABC(M,ITUV))
              ENDDO
C
C             MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
              DMAP(IPTS,JPTS) = DMAP(IPTS,JPTS)
     &                                   + DENT(NA1+IBAS,NB1+JBAS)*T11
     &                                   + DENT(NA1+IBAS,NB2+JBAS)*T12
     &                                   + DENT(NA2+IBAS,NB1+JBAS)*T21
     &                                   + DENT(NA2+IBAS,NB2+JBAS)*T22
C
              IF(HMLT.EQ.'NORL') GOTO 100
C
C             ESS0
              DO ITUV=1,NTUVSS
                S11 = S11 +            ESS011(M,ITUV)*HABC(M,ITUV)
                S12 = S12 - PHS*DCONJG(ESS021(M,ITUV)*HABC(M,ITUV))
                S21 = S21 +            ESS021(M,ITUV)*HABC(M,ITUV)
                S22 = S22 + PHS*DCONJG(ESS011(M,ITUV)*HABC(M,ITUV))
              ENDDO
C
C             MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
              DMAP(IPTS,JPTS) = DMAP(IPTS,JPTS)
     &                                   + DENT(NA1+KBAS,NB1+LBAS)*S11
     &                                   + DENT(NA1+KBAS,NB2+LBAS)*S12
     &                                   + DENT(NA2+KBAS,NB1+LBAS)*S21
     &                                   + DENT(NA2+KBAS,NB2+LBAS)*S22
C          
100           CONTINUE
C
            ENDDO
          ENDDO
C
C       CLOSE LOOP OVER GRID COORDINATES
        ENDDO
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'DENSMAP'
      TITLE  = 'DENSMAP'//' for '//TRIM(MOLCL)//' of type '//HMLT
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NHRZ
C
C         SAVE MATRIX ELEMENTS
          WRITE(8,*) (DLOG(DREAL(DMAP(IPTS,JPTS))),JPTS=0,NVTC)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NHRZ.EQ.0.OR.NVTC.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNUDENS(XOUT,TITLE,NHRZ,NVTC)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE J4CRRNT(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        JJJJJ    44    CCCCCC  RRRRRRR  RRRRRRR  NN    NN TTTTTTTT    C
C          JJ    44    CC    CC RR    RR RR    RR NNN   NN    TT       C
C          JJ   44     CC       RR    RR RR    RR NNNN  NN    TT       C
C          JJ  44 44   CC       RR    RR RR    RR NN NN NN    TT       C
C          JJ 44444444 CC       RRRRRRR  RRRRRRR  NN  NNNN    TT       C
C    JJ    JJ     44   CC    CC RR    RR RR    RR NN   NNN    TT       C
C     JJJJJJ      44    CCCCCC  RR    RR RR    RR NN    NN    TT       C
C                                                                      C
C -------------------------------------------------------------------- C
C  J4CRRNT CREATES A PLOT OF THE ELECTRONIC 4-CURRENT BETWEEN COORDS   C
C  XYZI(3) AND XYZF(3), IN A STRAIGHT LINE, WITH NPTS DATA POINTS.     C
C  THIS METHOD USES EQ-COEFFICIENTS AND THE GAUSSIAN PRODUCT THEOREM.  C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
C
      COMPLEX*16 CONE,T11(8),T12(8),T21(8),T22(8)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ),
     &           ELSX11(MB2,MEQ),ELSX21(MB2,MEQ),
     &           ELSY11(MB2,MEQ),ELSY21(MB2,MEQ),
     &           ELSZ11(MB2,MEQ),ELSZ21(MB2,MEQ),
     &           ESLX11(MB2,MEQ),ESLX21(MB2,MEQ),
     &           ESLY11(MB2,MEQ),ESLY21(MB2,MEQ),
     &           ESLZ11(MB2,MEQ),ESLZ21(MB2,MEQ)
      COMPLEX*16 CURRNT(0:3,0:NPTS)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     SET THIS TO ZERO IF YOU ONLY WANT THE CHARGE DENSITY
      JTOG = 0
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO MU=0,3
          CURRNT(MU,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMLS = LQN(1)+LQN(2)+1
      LAMSL = LQN(1)+LQN(2)+1
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLLMK(ELL011,ELL021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSSMK(ESS011,ESS021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
      IF(JTOG.EQ.0) GOTO 50
C
C     ELSX, ELSY AND ELSZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLSMK(ELSX11,ELSX21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQLSMK(ELSY11,ELSY21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQLSMK(ELSZ11,ELSZ21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     ESLX, ESLY AND ESLZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSLMK(ESLX11,ESLX21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQSLMK(ESLY11,ESLY21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQSLMK(ESLZ11,ESLZ21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TESL = TESL+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       GENERATE A BATCH OF HGTFS FOR THIS LOCATION
        IF(HMLT.EQ.'NORL') THEN
          CALL HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAMLL)
        ELSE
          CALL HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAMSS)
        ENDIF
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,8
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C     CHARGE DENSITY RHO(X,Y,Z)                                        C
C**********************************************************************C
C
C           ELL0
            DO ITUV=1,NTUVLL
              T11(1) = T11(1) +            ELL011(M,ITUV)*HABC(M,ITUV)
              T12(1) = T12(1) - PHS*DCONJG(ELL021(M,ITUV)*HABC(M,ITUV))
              T21(1) = T21(1) +            ELL021(M,ITUV)*HABC(M,ITUV)
              T22(1) = T22(1) + PHS*DCONJG(ELL011(M,ITUV)*HABC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            CURRNT(0,IPTS) = CURRNT(0,IPTS)
     &                      - DENT(NA1+IBAS,NB1+JBAS)*T11(1)
     &                      - DENT(NA1+IBAS,NB2+JBAS)*T12(1)
     &                      - DENT(NA2+IBAS,NB1+JBAS)*T21(1)
     &                      - DENT(NA2+IBAS,NB2+JBAS)*T22(1)
C
            IF(HMLT.EQ.'NORL') GOTO 100
C
C           ESS0
            DO ITUV=1,NTUVSS
              T11(2) = T11(2) +            ESS011(M,ITUV)*HABC(M,ITUV)
              T12(2) = T12(2) - PHS*DCONJG(ESS021(M,ITUV)*HABC(M,ITUV))
              T21(2) = T21(2) +            ESS021(M,ITUV)*HABC(M,ITUV)
              T22(2) = T22(2) + PHS*DCONJG(ESS011(M,ITUV)*HABC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            CURRNT(0,IPTS) = CURRNT(0,IPTS)
     &                      - DENT(NA1+KBAS,NB1+LBAS)*T11(2)
     &                      - DENT(NA1+KBAS,NB2+LBAS)*T12(2)
     &                      - DENT(NA2+KBAS,NB1+LBAS)*T21(2)
     &                      - DENT(NA2+KBAS,NB2+LBAS)*T22(2)
C
            IF(JTOG.EQ.0) GOTO 100
C
C**********************************************************************C
C     CURRENT DENSITY VECTOR J_X(X,Y,Z)                                C
C**********************************************************************C
C
C           ELSX, ELSY AND ELSZ
            DO ITUV=1,NTUVLS
              T11(3) = T11(3) +            ELSX11(M,ITUV)*HABC(M,ITUV)
              T12(3) = T12(3) - PHS*DCONJG(ELSX21(M,ITUV)*HABC(M,ITUV))
              T21(3) = T21(3) +            ELSX21(M,ITUV)*HABC(M,ITUV)
              T22(3) = T22(3) + PHS*DCONJG(ELSX11(M,ITUV)*HABC(M,ITUV))
              T11(4) = T11(4) +            ELSY11(M,ITUV)*HABC(M,ITUV)
              T12(4) = T12(4) - PHS*DCONJG(ELSY21(M,ITUV)*HABC(M,ITUV))
              T21(4) = T21(4) +            ELSY21(M,ITUV)*HABC(M,ITUV)
              T22(4) = T22(4) + PHS*DCONJG(ELSY11(M,ITUV)*HABC(M,ITUV))
              T11(5) = T11(5) +            ELSZ11(M,ITUV)*HABC(M,ITUV)
              T12(5) = T12(5) - PHS*DCONJG(ELSZ21(M,ITUV)*HABC(M,ITUV))
              T21(5) = T21(5) +            ELSZ21(M,ITUV)*HABC(M,ITUV)
              T22(5) = T22(5) + PHS*DCONJG(ELSZ11(M,ITUV)*HABC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (+i FOR EQLS)
            CURRNT(1,IPTS) = CURRNT(1,IPTS)
     &                      - CONE*DENT(NA1+IBAS,NB1+LBAS)*T11(3)
     &                      - CONE*DENT(NA1+IBAS,NB2+LBAS)*T12(3)
     &                      - CONE*DENT(NA2+IBAS,NB1+LBAS)*T21(3)
     &                      - CONE*DENT(NA2+IBAS,NB2+LBAS)*T22(3)
            CURRNT(2,IPTS) = CURRNT(2,IPTS)
     &                      - CONE*DENT(NA1+IBAS,NB1+LBAS)*T11(4)
     &                      - CONE*DENT(NA1+IBAS,NB2+LBAS)*T12(4)
     &                      - CONE*DENT(NA2+IBAS,NB1+LBAS)*T21(4)
     &                      - CONE*DENT(NA2+IBAS,NB2+LBAS)*T22(4)
            CURRNT(3,IPTS) = CURRNT(3,IPTS)
     &                      - CONE*DENT(NA1+IBAS,NB1+LBAS)*T11(5)
     &                      - CONE*DENT(NA1+IBAS,NB2+LBAS)*T12(5)
     &                      - CONE*DENT(NA2+IBAS,NB1+LBAS)*T21(5)
     &                      - CONE*DENT(NA2+IBAS,NB2+LBAS)*T22(5)
C
C           ESLX, ESLY AND ESLZ
            DO ITUV=1,NTUVSL
              T11(6) = T11(6) +            ESLX11(M,ITUV)*HABC(M,ITUV)
              T12(6) = T12(6) - PHS*DCONJG(ESLX21(M,ITUV)*HABC(M,ITUV))
              T21(6) = T21(6) +            ESLX21(M,ITUV)*HABC(M,ITUV)
              T22(6) = T22(6) + PHS*DCONJG(ESLX11(M,ITUV)*HABC(M,ITUV))
              T11(7) = T11(7) +            ESLY11(M,ITUV)*HABC(M,ITUV)
              T12(7) = T12(7) - PHS*DCONJG(ESLY21(M,ITUV)*HABC(M,ITUV))
              T21(7) = T21(7) +            ESLY21(M,ITUV)*HABC(M,ITUV)
              T22(7) = T22(7) + PHS*DCONJG(ESLY11(M,ITUV)*HABC(M,ITUV))
              T11(8) = T11(8) +            ESLZ11(M,ITUV)*HABC(M,ITUV)
              T12(8) = T12(8) - PHS*DCONJG(ESLZ21(M,ITUV)*HABC(M,ITUV))
              T21(8) = T21(8) +            ESLZ21(M,ITUV)*HABC(M,ITUV)
              T22(8) = T22(8) + PHS*DCONJG(ESLZ11(M,ITUV)*HABC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (-i FOR EQSL)
            CURRNT(1,IPTS) = CURRNT(1,IPTS)
     &                      + CONE*DENT(NA1+KBAS,NB1+JBAS)*T11(6)
     &                      + CONE*DENT(NA1+KBAS,NB2+JBAS)*T12(6)
     &                      + CONE*DENT(NA2+KBAS,NB1+JBAS)*T21(6)
     &                      + CONE*DENT(NA2+KBAS,NB2+JBAS)*T22(6)
            CURRNT(2,IPTS) = CURRNT(2,IPTS)
     &                      + CONE*DENT(NA1+KBAS,NB1+JBAS)*T11(7)
     &                      + CONE*DENT(NA1+KBAS,NB2+JBAS)*T12(7)
     &                      + CONE*DENT(NA2+KBAS,NB1+JBAS)*T21(7)
     &                      + CONE*DENT(NA2+KBAS,NB2+JBAS)*T22(7)
            CURRNT(3,IPTS) = CURRNT(3,IPTS)
     &                      + CONE*DENT(NA1+KBAS,NB1+JBAS)*T11(8)
     &                      + CONE*DENT(NA1+KBAS,NB2+JBAS)*T12(8)
     &                      + CONE*DENT(NA2+KBAS,NB1+JBAS)*T21(8)
     &                      + CONE*DENT(NA2+KBAS,NB2+JBAS)*T22(8)
C          
100         CONTINUE
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     CURRENT-DENSITY ENTRIES MUST BE MULTIPLIED BY CONE*CV
      DO IX=1,3
        DO IPTS=1,NPTS
          CURRNT(IX,IPTS) = CV*CONE*CURRNT(IX,IPTS)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     NUCLEAR CENTRE CONTRIBUTIONS (CAN SKIP THIS PART)                C
C**********************************************************************C
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       BEGIN LOOP OVER ALL NUCLEAR CENTRES UP TO NCNT
        DO IZ=1,NCNT
C
C         LIST DIMENSION
          NBAS(1) = 1
          NBAS(2) = 1
C
C         CARTESIAN COORDINATES OF CENTRE A
          XYZ(1,1) = BXYZ(1,IZ)
          XYZ(2,1) = BXYZ(2,IZ)
          XYZ(3,1) = BXYZ(3,IZ)
C
C         CARTESIAN COORDINATES OF CENTRE B
          XYZ(1,2) = 0.0D0
          XYZ(2,2) = 0.0D0
          XYZ(3,2) = 0.0D0
C
C         LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
          DO IFT=1,NNUC(IZ)
C
C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
            XI = XNUC(IZ,IFT)
            FC = FNUC(IZ,IFT)
C
C           NUCLEAR WIDTH EXPONENTS
            EXL(1,1) = XI
            EXL(1,2) = 0.0D0
C
C           GENERATE A BATCH OF HGTFS FOR THIS LOCATION
            CALL HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,0)
C
C           PRE-FACTOR FOR NUCLEAR CHARGE AND WIDTH
            GSFC = DSQRT(XI/PI)
            GSFC = ZNUC(IZ)*(GSFC**3)
C
C           ADD VALUE OF DENSITY AT THESE COORDINATES TO DATA BIN
            CURRNT(0,IPTS) = CURRNT(0,IPTS) + GSFC*FC*HABC(1,1)
C
C         END LOOP OVER NUCLEAR BASIS FOR IZ
          ENDDO
C
C       END LOOP OVER NUCLEAR CENTRES
        ENDDO
C
C     END LOOP OVER ALL GRID COORDINATES
      ENDDO
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'J4CRRNT'
      TITLE  = 'J4CRRNT'//' for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'd (a.u.)'
      YAXIS  = '{j}_{/Symbol u}(d)'
      KEY(1) = '{/Symbol r}(d)'
      KEY(2) = 'j_{x}(d)'
      KEY(3) = 'j_{y}(d)'
      KEY(4) = 'j_{z}(d)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(DREAL(CURRNT(MU,IPTS)),MU=0,3)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE POTENTL(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP   OOOOOO TTTTTTTT EEEEEEEE NN    NN TTTTTTTT LL          C
C     PP    PP OO    OO   TT    EE       NNN   NN    TT    LL          C
C     PP    PP OO    OO   TT    EE       NNNN  NN    TT    LL          C
C     PP    PP OO    OO   TT    EEEEEE   NN NN NN    TT    LL          C
C     PPPPPPP  OO    OO   TT    EE       NN  NNNN    TT    LL          C
C     PP       OO    OO   TT    EE       NN   NNN    TT    LL          C
C     PP        OOOOOO    TT    EEEEEEEE NN    NN    TT    LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  POTENTL CREATES A PLOT OF THE 4-POTENTIAL OVERLAP BETWEEN COORDS    C
C  XYZI(3) AND XYZF(3), IN A STRAIGHT LINE, WITH NPTS DATA POINTS.     C
C  THIS METHOD USES EQ-COEFFICIENTS AND THE GAUSSIAN PRODUCT THEOREM.  C
C -------------------------------------------------------------------- C
C  TODO: NUCLEAR CONTRIBUTIONS ARE POINT-LIKE -- CAN EXTEND.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,T11(8),T12(8),T21(8),T22(8)
      COMPLEX*16 A4(0:3,0:NPTS)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ),
     &           ELSX11(MB2,MEQ),ELSX21(MB2,MEQ),
     &           ELSY11(MB2,MEQ),ELSY21(MB2,MEQ),
     &           ELSZ11(MB2,MEQ),ELSZ21(MB2,MEQ),
     &           ESLX11(MB2,MEQ),ESLX21(MB2,MEQ),
     &           ESLY11(MB2,MEQ),ESLY21(MB2,MEQ),
     &           ESLZ11(MB2,MEQ),ESLZ21(MB2,MEQ)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     SET THIS TO ZERO IF YOU ONLY WANT THE CHARGE DENSITY
      JTOG = 0
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO MU=0,3
          A4(MU,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMLS = LQN(1)+LQN(2)+1
      LAMSL = LQN(1)+LQN(2)+1
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLLMK(ELL011,ELL021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSSMK(ESS011,ESS021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
      IF(JTOG.EQ.0) GOTO 50
C
C     ELSX, ELSY AND ELSZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLSMK(ELSX11,ELSX21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQLSMK(ELSY11,ELSY21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQLSMK(ELSZ11,ELSZ21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     ESLX, ESLY AND ESLZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSLMK(ESLX11,ESLX21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQSLMK(ESLY11,ESLY21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQSLMK(ESLZ11,ESLZ21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TESL = TESL+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       PREPARE DATA FOR BATCH OF R-INTEGRALS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = XYZEVAL(1)-PX
            CP(M,2) = XYZEVAL(2)-PY
            CP(M,3) = XYZEVAL(3)-PZ
C
C           POINT-NUCLEUS OPTIONS
            APH(M) = EIJ
            PNC(M) = 2.0D0*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        IF(HMLT.EQ.'NORL') THEN
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMLL)
        ELSE
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMSS)
        ENDIF
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,8
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C     SCALAR POTENTIAL PHI(X,Y,Z)                                      C
C**********************************************************************C
C
C           ELL0
            DO ITUV=1,NTUVLL
              T11(1) = T11(1) +            ELL011(M,ITUV)*RC(M,ITUV)
              T12(1) = T12(1) - PHS*DCONJG(ELL021(M,ITUV)*RC(M,ITUV))
              T21(1) = T21(1) +            ELL021(M,ITUV)*RC(M,ITUV)
              T22(1) = T22(1) + PHS*DCONJG(ELL011(M,ITUV)*RC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            A4(0,IPTS) = A4(0,IPTS)
     &                          - DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(1)
     &                          - DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(1)
     &                          - DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(1)
     &                          - DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(1)
C
            IF(HMLT.EQ.'NORL') GOTO 100
C
C           ESS0
            DO ITUV=1,NTUVSS
              T11(2) = T11(2) +            ESS011(M,ITUV)*RC(M,ITUV)
              T12(2) = T12(2) - PHS*DCONJG(ESS021(M,ITUV)*RC(M,ITUV))
              T21(2) = T21(2) +            ESS021(M,ITUV)*RC(M,ITUV)
              T22(2) = T22(2) + PHS*DCONJG(ESS011(M,ITUV)*RC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            A4(0,IPTS) = A4(0,IPTS) 
     &                          - DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(2)
     &                          - DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(2)
     &                          - DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(2)
     &                          - DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(2)
C
            IF(JTOG.EQ.0) GOTO 100
C
C**********************************************************************C
C     VECTOR POTENTIAL A(X,Y,Z)                                        C
C**********************************************************************C
C
C           ELSX, ELSY AND ELSZ
            DO ITUV=1,NTUVLS
              T11(3) = T11(3) +            ELSX11(M,ITUV)*RC(M,ITUV)
              T12(3) = T12(3) - PHS*DCONJG(ELSX21(M,ITUV)*RC(M,ITUV))
              T21(3) = T21(3) +            ELSX21(M,ITUV)*RC(M,ITUV)
              T22(3) = T22(3) + PHS*DCONJG(ELSX11(M,ITUV)*RC(M,ITUV))
              T11(4) = T11(4) +            ELSY11(M,ITUV)*RC(M,ITUV)
              T12(4) = T12(4) - PHS*DCONJG(ELSY21(M,ITUV)*RC(M,ITUV))
              T21(4) = T21(4) +            ELSY21(M,ITUV)*RC(M,ITUV)
              T22(4) = T22(4) + PHS*DCONJG(ELSY11(M,ITUV)*RC(M,ITUV))
              T11(5) = T11(5) +            ELSZ11(M,ITUV)*RC(M,ITUV)
              T12(5) = T12(5) - PHS*DCONJG(ELSZ21(M,ITUV)*RC(M,ITUV))
              T21(5) = T21(5) +            ELSZ21(M,ITUV)*RC(M,ITUV)
              T22(5) = T22(5) + PHS*DCONJG(ELSZ11(M,ITUV)*RC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (+i FOR EQLS)
            A4(1,IPTS) = A4(1,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+LBAS)*PNC(M)*T11(3)
     &                     - CONE*DENT(NA1+IBAS,NB2+LBAS)*PNC(M)*T12(3)
     &                     - CONE*DENT(NA2+IBAS,NB1+LBAS)*PNC(M)*T21(3)
     &                     - CONE*DENT(NA2+IBAS,NB2+LBAS)*PNC(M)*T22(3)
            A4(2,IPTS) = A4(2,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+LBAS)*PNC(M)*T11(4)
     &                     - CONE*DENT(NA1+IBAS,NB2+LBAS)*PNC(M)*T12(4)
     &                     - CONE*DENT(NA2+IBAS,NB1+LBAS)*PNC(M)*T21(4)
     &                     - CONE*DENT(NA2+IBAS,NB2+LBAS)*PNC(M)*T22(4)
            A4(3,IPTS) = A4(3,IPTS) 
     &                     - CONE*DENT(NA1+IBAS,NB1+LBAS)*PNC(M)*T11(5)
     &                     - CONE*DENT(NA1+IBAS,NB2+LBAS)*PNC(M)*T12(5)
     &                     - CONE*DENT(NA2+IBAS,NB1+LBAS)*PNC(M)*T21(5)
     &                     - CONE*DENT(NA2+IBAS,NB2+LBAS)*PNC(M)*T22(5)
C
C           ESLX, ESLY AND ESLZ
            DO ITUV=1,NTUVSL
              T11(6) = T11(6) +            ESLX11(M,ITUV)*RC(M,ITUV)
              T12(6) = T12(6) - PHS*DCONJG(ESLX21(M,ITUV)*RC(M,ITUV))
              T21(6) = T21(6) +            ESLX21(M,ITUV)*RC(M,ITUV)
              T22(6) = T22(6) + PHS*DCONJG(ESLX11(M,ITUV)*RC(M,ITUV))
              T11(7) = T11(7) +            ESLY11(M,ITUV)*RC(M,ITUV)
              T12(7) = T12(7) - PHS*DCONJG(ESLY21(M,ITUV)*RC(M,ITUV))
              T21(7) = T21(7) +            ESLY21(M,ITUV)*RC(M,ITUV)
              T22(7) = T22(7) + PHS*DCONJG(ESLY11(M,ITUV)*RC(M,ITUV))
              T11(8) = T11(8) +            ESLZ11(M,ITUV)*RC(M,ITUV)
              T12(8) = T12(8) - PHS*DCONJG(ESLZ21(M,ITUV)*RC(M,ITUV))
              T21(8) = T21(8) +            ESLZ21(M,ITUV)*RC(M,ITUV)
              T22(8) = T22(8) + PHS*DCONJG(ESLZ11(M,ITUV)*RC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (-i FOR EQSL)
            A4(1,IPTS) = A4(1,IPTS)
     &                     + CONE*DENT(NA1+KBAS,NB1+JBAS)*PNC(M)*T11(6)
     &                     + CONE*DENT(NA1+KBAS,NB2+JBAS)*PNC(M)*T12(6)
     &                     + CONE*DENT(NA2+KBAS,NB1+JBAS)*PNC(M)*T21(6)
     &                     + CONE*DENT(NA2+KBAS,NB2+JBAS)*PNC(M)*T22(6)
            A4(2,IPTS) = A4(2,IPTS)
     &                     + CONE*DENT(NA1+KBAS,NB1+JBAS)*PNC(M)*T11(7)
     &                     + CONE*DENT(NA1+KBAS,NB2+JBAS)*PNC(M)*T12(7)
     &                     + CONE*DENT(NA2+KBAS,NB1+JBAS)*PNC(M)*T21(7)
     &                     + CONE*DENT(NA2+KBAS,NB2+JBAS)*PNC(M)*T22(7)
            A4(3,IPTS) = A4(3,IPTS)
     &                     + CONE*DENT(NA1+KBAS,NB1+JBAS)*PNC(M)*T11(8)
     &                     + CONE*DENT(NA1+KBAS,NB2+JBAS)*PNC(M)*T12(8)
     &                     + CONE*DENT(NA2+KBAS,NB1+JBAS)*PNC(M)*T21(8)
     &                     + CONE*DENT(NA2+KBAS,NB2+JBAS)*PNC(M)*T22(8)
C
100         CONTINUE
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     FOUR-POTENTIAL ENTRIES MUST BE MULTIPLIED BY CONE*CV
      DO IX=1,3
        DO IPTS=1,NPTS
          A4(IX,IPTS) = CV*CONE*A4(IX,IPTS)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     NUCLEAR CENTRE CONTRIBUTIONS (CAN SKIP THIS PART)                C
C**********************************************************************C
C
      GOTO 300
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       BEGIN LOOP OVER ALL NUCLEAR CENTRES UP TO NCNT
        DO IZ=1,NCNT
C
C         LIST DIMENSION
          NBAS(1) = 1
          NBAS(2) = 1
C
C         CARTESIAN COORDINATES OF CENTRE A
          XYZ(1,1) = BXYZ(1,IZ)
          XYZ(2,1) = BXYZ(2,IZ)
          XYZ(3,1) = BXYZ(3,IZ)
C
C         CARTESIAN COORDINATES OF CENTRE B
          XYZ(1,2) = 0.0D0
          XYZ(2,2) = 0.0D0
          XYZ(3,2) = 0.0D0
C
C         LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
          DO IFT=1,NNUC(IZ)
C
C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
            XI = XNUC(IZ,IFT)
            FC = FNUC(IZ,IFT)
C
C           NUCLEAR WIDTH EXPONENTS
            EXL(1,1) = XI
            EXL(1,2) = 0.0D0
C
C           PREPARE DATA FOR BATCH OF R-INTEGRALS
            EIJ = EXL(1,1)+EXL(1,2)
            PX  = (XYZ(1,1)*EXL(1,1)+XYZ(1,2)*EXL(2,2))/EIJ
            PY  = (XYZ(2,1)*EXL(1,1)+XYZ(2,2)*EXL(2,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(1,1)+XYZ(3,2)*EXL(2,2))/EIJ
            CP(1,1) = XYZEVAL(1)-PX
            CP(1,2) = XYZEVAL(2)-PY
            CP(1,3) = XYZEVAL(3)-PZ
C
C           POINT-NUCLEUS OPTIONS
            APH(1) = EIJ
            PNC(1) = 2.0D0*PI/EIJ
C
C           GENERATE A BATCH OF R-INTEGRALS
            CALL CPU_TIME(TDM1)
            CALL RMAKE(RC,CP,APH,1,0)
            CALL CPU_TIME(TDM2)
            TRLL = TRLL+TDM2-TDM1
C
C           PRE-FACTOR FOR NUCLEAR CHARGE AND WIDTH
            GSFC = DSQRT(XI/PI)
            GSFC = FC*ZNUC(IZ)*(GSFC**3)
C
C           ADD VALUE OF DENSITY AT THESE COORDINATES TO DATA BIN
            A4(0,IPTS) = A4(0,IPTS) + GSFC*PNC(1)*RC(1,1)
C
C         END LOOP OVER NUCLEAR BASIS FOR IZ
          ENDDO
C
C       END LOOP OVER NUCLEAR CENTRES
        ENDDO
C
C     END LOOP OVER ALL GRID COORDINATES
      ENDDO
C
300   CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'A4EQSUM'
      TITLE  = 'POTENTL'//' for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{A}_{/Symbol u}(z)'
      KEY(1) = '{/Symbol f}(z)'
      KEY(2) = 'A_{x}(z)'
      KEY(3) = 'A_{y}(z)'
      KEY(4) = 'A_{z}(z)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(DREAL(A4(MU,IPTS)),MU=0,3)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE ELCTRCF(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     EEEEEEEE LL       CCCCCC TTTTTTTT RRRRRRR   CCCCCC  FFFFFFFF     C
C     EE       LL      CC    CC   TT    RR    RR CC    CC FF           C
C     EE       LL      CC         TT    RR    RR CC       FF           C
C     EEEEEE   LL      CC         TT    RR    RR CC       FFFFFF       C
C     EE       LL      CC         TT    RRRRRRR  CC       FF           C
C     EE       LL      CC    CC   TT    RR    RR CC    CC FF           C
C     EEEEEEEE LLLLLLLL CCCCCC    TT    RR    RR  CCCCCC  FF           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCTRCF CREATES A PLOT OF THE MOLECULAR ELECTRIC FIELD VECTOR BY    C
C  USE OF THE EQ-COEFFICIENTS AND BOYS INTEGRALS.                      C
C -------------------------------------------------------------------- C
C  TODO: NUCLEAR CONTRIBUTIONS ARE POINT-LIKE -- CAN EXTEND.           C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(3)
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,T11(6),T12(6),T21(6),T22(6)
      COMPLEX*16 EFIELD(3,0:NPTS)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO IJK=1,3
          EFIELD(IJK,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLLMK(ELL011,ELL021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSSMK(ESS011,ESS021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       PREPARE DATA FOR BATCH OF R-INTEGRALS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = XYZEVAL(1)-PX
            CP(M,2) = XYZEVAL(2)-PY
            CP(M,3) = XYZEVAL(3)-PZ
C
C           POINT-NUCLEUS OPTIONS
            APH(M) = EIJ
            PNC(M) = 2.0D0*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        IF(HMLT.EQ.'NORL') THEN
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMLL+1)
        ELSE
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMSS+1)
        ENDIF
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,6
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C     ELECTRIC FIELD VECTOR E(X,Y,Z)                                   C
C**********************************************************************C
C
C           ELL0
            DO ITUV=1,NTUVLL
              IXDR = IABC(IA(ITUV)+1,IB(ITUV)  ,IC(ITUV)  )
              IYDR = IABC(IA(ITUV)  ,IB(ITUV)+1,IC(ITUV)  )
              IZDR = IABC(IA(ITUV)  ,IB(ITUV)  ,IC(ITUV)+1)
              T11(1) = T11(1) +            ELL011(M,ITUV)*RC(M,IXDR)
              T12(1) = T12(1) - PHS*DCONJG(ELL021(M,ITUV)*RC(M,IXDR))
              T21(1) = T21(1) +            ELL021(M,ITUV)*RC(M,IXDR)
              T22(1) = T22(1) + PHS*DCONJG(ELL011(M,ITUV)*RC(M,IXDR))
              T11(2) = T11(2) +            ELL011(M,ITUV)*RC(M,IYDR)
              T12(2) = T12(2) - PHS*DCONJG(ELL021(M,ITUV)*RC(M,IYDR))
              T21(2) = T21(2) +            ELL021(M,ITUV)*RC(M,IYDR)
              T22(2) = T22(2) + PHS*DCONJG(ELL011(M,ITUV)*RC(M,IYDR))
              T11(3) = T11(3) +            ELL011(M,ITUV)*RC(M,IZDR)
              T12(3) = T12(3) - PHS*DCONJG(ELL021(M,ITUV)*RC(M,IZDR))
              T21(3) = T21(3) +            ELL021(M,ITUV)*RC(M,IZDR)
              T22(3) = T22(3) + PHS*DCONJG(ELL011(M,ITUV)*RC(M,IZDR))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            EFIELD(1,IPTS) = EFIELD(1,IPTS)
     &                          - DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(1)
     &                          - DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(1)
     &                          - DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(1)
     &                          - DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(1)
            EFIELD(2,IPTS) = EFIELD(2,IPTS)
     &                          - DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(2)
     &                          - DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(2)
     &                          - DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(2)
     &                          - DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(2)
            EFIELD(3,IPTS) = EFIELD(3,IPTS)
     &                          - DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(3)
     &                          - DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(3)
     &                          - DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(3)
     &                          - DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(3)
C
            IF(HMLT.EQ.'NORL') GOTO 100
C
C           ESS0
            DO ITUV=1,NTUVSS
              IXDR = IABC(IA(ITUV)+1,IB(ITUV)  ,IC(ITUV)  )
              IYDR = IABC(IA(ITUV)  ,IB(ITUV)+1,IC(ITUV)  )
              IZDR = IABC(IA(ITUV)  ,IB(ITUV)  ,IC(ITUV)+1)
              T11(4) = T11(4) +            ESS011(M,ITUV)*RC(M,IXDR)
              T12(4) = T12(4) - PHS*DCONJG(ESS021(M,ITUV)*RC(M,IXDR))
              T21(4) = T21(4) +            ESS021(M,ITUV)*RC(M,IXDR)
              T22(4) = T22(4) + PHS*DCONJG(ESS011(M,ITUV)*RC(M,IXDR))
              T11(5) = T11(5) +            ESS011(M,ITUV)*RC(M,IYDR)
              T12(5) = T12(5) - PHS*DCONJG(ESS021(M,ITUV)*RC(M,IYDR))
              T21(5) = T21(5) +            ESS021(M,ITUV)*RC(M,IYDR)
              T22(5) = T22(5) + PHS*DCONJG(ESS011(M,ITUV)*RC(M,IYDR))
              T11(6) = T11(6) +            ESS011(M,ITUV)*RC(M,IZDR)
              T12(6) = T12(6) - PHS*DCONJG(ESS021(M,ITUV)*RC(M,IZDR))
              T21(6) = T21(6) +            ESS021(M,ITUV)*RC(M,IZDR)
              T22(6) = T22(6) + PHS*DCONJG(ESS011(M,ITUV)*RC(M,IZDR))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            EFIELD(1,IPTS) = EFIELD(1,IPTS) 
     &                          - DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(4)
     &                          - DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(4)
     &                          - DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(4)
     &                          - DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(4)
            EFIELD(2,IPTS) = EFIELD(2,IPTS) 
     &                          - DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(5)
     &                          - DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(5)
     &                          - DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(5)
     &                          - DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(5)
            EFIELD(3,IPTS) = EFIELD(3,IPTS) 
     &                          - DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(6)
     &                          - DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(6)
     &                          - DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(6)
     &                          - DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(6)
C
100         CONTINUE
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     NUCLEAR CENTRE CONTRIBUTIONS (CAN SKIP THIS PART)                C
C**********************************************************************C
C
      GOTO 300
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       BEGIN LOOP OVER ALL NUCLEAR CENTRES UP TO NCNT
        DO IZ=1,NCNT
C
C         LIST DIMENSION
          NBAS(1) = 1
          NBAS(2) = 1
C
C         CARTESIAN COORDINATES OF CENTRE A
          XYZ(1,1) = BXYZ(1,IZ)
          XYZ(2,1) = BXYZ(2,IZ)
          XYZ(3,1) = BXYZ(3,IZ)
C
C         CARTESIAN COORDINATES OF CENTRE B
          XYZ(1,2) = 0.0D0
          XYZ(2,2) = 0.0D0
          XYZ(3,2) = 0.0D0
C
C         LOOP OVER GAUSSIANS FOR THIS NUCLEAR CENTRE
          DO IFT=1,NNUC(IZ)
C
C           GAUSSIAN EXPONENT AND FRACTIONAL CONTRIBUTION
            XI = XNUC(IZ,IFT)
            FC = FNUC(IZ,IFT)
C
C           NUCLEAR WIDTH EXPONENTS
            EXL(1,1) = XI
            EXL(1,2) = 0.0D0
C
C           PREPARE DATA FOR BATCH OF R-INTEGRALS
            EIJ = EXL(1,1)+EXL(1,2)
            PX  = (XYZ(1,1)*EXL(1,1)+XYZ(1,2)*EXL(2,2))/EIJ
            PY  = (XYZ(2,1)*EXL(1,1)+XYZ(2,2)*EXL(2,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(1,1)+XYZ(3,2)*EXL(2,2))/EIJ
            CP(1,1) = XYZEVAL(1)-PX
            CP(1,2) = XYZEVAL(2)-PY
            CP(1,3) = XYZEVAL(3)-PZ
C
C           POINT-NUCLEUS OPTIONS
            APH(1) = EIJ
            PNC(1) = 2.0D0*PI/EIJ
C
C           GENERATE A BATCH OF R-INTEGRALS
            CALL CPU_TIME(TDM1)
            CALL RMAKE(RC,CP,APH,1,1)
            CALL CPU_TIME(TDM2)
            TRLL = TRLL+TDM2-TDM1
C
C           PRE-FACTOR FOR NUCLEAR CHARGE AND WIDTH
            GSFC = DSQRT(XI/PI)
            GSFC = FC*ZNUC(IZ)*(GSFC**3)
C
C           ADD VALUE OF DENSITY AT THESE COORDINATES TO DATA BIN
            IXDR = IABC(1,0,0)
            IYDR = IABC(0,1,0)
            IZDR = IABC(0,0,1)
            EFIELD(1,IPTS) = EFIELD(1,IPTS) + GSFC*PNC(1)*RC(1,IXDR)
            EFIELD(2,IPTS) = EFIELD(2,IPTS) + GSFC*PNC(1)*RC(1,IYDR)
            EFIELD(3,IPTS) = EFIELD(3,IPTS) + GSFC*PNC(1)*RC(1,IZDR)
C
C         END LOOP OVER NUCLEAR BASIS FOR IZ
          ENDDO
C
C       END LOOP OVER NUCLEAR CENTRES
        ENDDO
C
C     END LOOP OVER ALL GRID COORDINATES
      ENDDO
C
300   CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'ELCTRCF'
      TITLE  = 'Electric field for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{E}_{i}(z)'
      KEY(1) = 'E_{x}(z)'
      KEY(2) = 'E_{y}(z)'
      KEY(3) = 'E_{z}(z)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(DREAL(EFIELD(IJK,IPTS)),IJK=1,3)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,3,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE MAGNTCF(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   MM       MM    AA     GGGGGG  NN    NN TTTTTTTT CCCCCC  FFFFFFFF   C
C   MMM     MMM   AAAA   GG    GG NNN   NN    TT   CC    CC FF         C
C   MMMM   MMMM  AA  AA  GG       NNNN  NN    TT   CC       FF         C
C   MM MM MM MM AA    AA GG       NN NN NN    TT   CC       FFFFFF     C
C   MM  MMM  MM AAAAAAAA GG   GGG NN  NNNN    TT   CC       FF         C
C   MM   M   MM AA    AA GG    GG NN   NNN    TT   CC    CC FF         C
C   MM       MM AA    AA  GGGGGG  NN    NN    TT    CCCCCC  FF         C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGNTCF CREATES A PLOT OF THE MOLECULAR MAGNETIC FIELD VECTOR BY    C
C  USE OF THE EQ-COEFFICIENTS AND BOYS INTEGRALS.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(3)
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,T11(6),T12(6),T21(6),T22(6)
      COMPLEX*16 BFIELD(3,0:NPTS)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELSX11(MB2,MEQ),ELSX21(MB2,MEQ),
     &           ELSY11(MB2,MEQ),ELSY21(MB2,MEQ),
     &           ELSZ11(MB2,MEQ),ELSZ21(MB2,MEQ),
     &           ESLX11(MB2,MEQ),ESLX21(MB2,MEQ),
     &           ESLY11(MB2,MEQ),ESLY21(MB2,MEQ),
     &           ESLZ11(MB2,MEQ),ESLZ21(MB2,MEQ)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO IJK=1,3
          BFIELD(IJK,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLS = LQN(1)+LQN(2)+1
      LAMSL = LQN(1)+LQN(2)+1
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C     ELSX, ELSY AND ELSZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLSMK(ELSX11,ELSX21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQLSMK(ELSY11,ELSY21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQLSMK(ELSZ11,ELSZ21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     ESLX, ESLY AND ESLZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSLMK(ESLX11,ESLX21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQSLMK(ESLY11,ESLY21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQSLMK(ESLZ11,ESLZ21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TESL = TESL+TDM2-TDM1
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       PREPARE DATA FOR BATCH OF R-INTEGRALS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
            EIJ = EXL(IBAS,1)+EXL(JBAS,2)
            PX  = (XYZ(1,1)*EXL(IBAS,1)+XYZ(1,2)*EXL(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXL(IBAS,1)+XYZ(2,2)*EXL(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXL(IBAS,1)+XYZ(3,2)*EXL(JBAS,2))/EIJ
            CP(M,1) = XYZEVAL(1)-PX
            CP(M,2) = XYZEVAL(2)-PY
            CP(M,3) = XYZEVAL(3)-PZ
C
C           POINT-NUCLEUS OPTIONS
            APH(M) = EIJ
            PNC(M) = 2.0D0*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMLS+1)
        CALL CPU_TIME(TDM2)
        TRLS = TRLS + TDM2 - TDM1
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,6
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C     MAGNETIC FIELD VECTOR B(X,Y,Z)                                   C
C**********************************************************************C
C
C           ELSI
            DO ITUV=1,NTUVLS
              IXDR = IABC(IA(ITUV)+1,IB(ITUV)  ,IC(ITUV)  )
              IYDR = IABC(IA(ITUV)  ,IB(ITUV)+1,IC(ITUV)  )
              IZDR = IABC(IA(ITUV)  ,IB(ITUV)  ,IC(ITUV)+1)
              T11(1) = T11(1) +            ELSZ11(M,ITUV)*RC(M,IYDR)
     &                                   - ELSY11(M,ITUV)*RC(M,IZDR)
              T12(1) = T12(1) - PHS*DCONJG(ELSZ21(M,ITUV)*RC(M,IYDR)
     &                                   - ELSY11(M,ITUV)*RC(M,IZDR))
              T21(1) = T21(1) +            ELSZ21(M,ITUV)*RC(M,IYDR)
     &                                   - ELSY21(M,ITUV)*RC(M,IZDR)
              T22(1) = T22(1) + PHS*DCONJG(ELSZ11(M,ITUV)*RC(M,IYDR)
     &                                   - ELSY11(M,ITUV)*RC(M,IZDR))
              T11(2) = T11(2) +            ELSX11(M,ITUV)*RC(M,IZDR)
     &                                   - ELSZ11(M,ITUV)*RC(M,IXDR)
              T12(2) = T12(2) - PHS*DCONJG(ELSX21(M,ITUV)*RC(M,IZDR)
     &                                   - ELSZ21(M,ITUV)*RC(M,IXDR))
              T21(2) = T21(2) +            ELSX21(M,ITUV)*RC(M,IZDR)
     &                                   - ELSZ21(M,ITUV)*RC(M,IXDR)
              T22(2) = T22(2) + PHS*DCONJG(ELSX11(M,ITUV)*RC(M,IZDR)
     &                                   - ELSZ11(M,ITUV)*RC(M,IXDR))
              T11(3) = T11(3) +            ELSY11(M,ITUV)*RC(M,IXDR)
     &                                   - ELSX11(M,ITUV)*RC(M,IYDR)
              T12(3) = T12(3) - PHS*DCONJG(ELSY21(M,ITUV)*RC(M,IXDR)
     &                                   - ELSX21(M,ITUV)*RC(M,IYDR))
              T21(3) = T21(3) +            ELSY21(M,ITUV)*RC(M,IXDR)
     &                                   - ELSX21(M,ITUV)*RC(M,IYDR)
              T22(3) = T22(3) + PHS*DCONJG(ELSY11(M,ITUV)*RC(M,IXDR)
     &                                   - ELSX11(M,ITUV)*RC(M,IYDR))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (+i FOR EQLS)
            BFIELD(1,IPTS) = BFIELD(1,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(1)
     &                     - CONE*DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(1)
     &                     - CONE*DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(1)
     &                     - CONE*DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(1)
            BFIELD(2,IPTS) = BFIELD(2,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(2)
     &                     - CONE*DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(2)
     &                     - CONE*DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(2)
     &                     - CONE*DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(2)
            BFIELD(3,IPTS) = BFIELD(3,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(3)
     &                     - CONE*DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(3)
     &                     - CONE*DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(3)
     &                     - CONE*DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(3)
C
C           ESLI
            DO ITUV=1,NTUVSL
              IXDR = IABC(IA(ITUV)+1,IB(ITUV)  ,IC(ITUV)  )
              IYDR = IABC(IA(ITUV)  ,IB(ITUV)+1,IC(ITUV)  )
              IZDR = IABC(IA(ITUV)  ,IB(ITUV)  ,IC(ITUV)+1)
              T11(4) = T11(4) +            ESLZ11(M,ITUV)*RC(M,IYDR)
     &                                   - ESLY11(M,ITUV)*RC(M,IZDR)
              T12(4) = T12(4) - PHS*DCONJG(ESLZ21(M,ITUV)*RC(M,IYDR)
     &                                   - ESLY11(M,ITUV)*RC(M,IZDR))
              T21(4) = T21(4) +            ESLZ21(M,ITUV)*RC(M,IYDR)
     &                                   - ESLY21(M,ITUV)*RC(M,IZDR)
              T22(4) = T22(4) + PHS*DCONJG(ESLZ11(M,ITUV)*RC(M,IYDR)
     &                                   - ESLY11(M,ITUV)*RC(M,IZDR))
              T11(5) = T11(5) +            ESLX11(M,ITUV)*RC(M,IZDR)
     &                                   - ESLZ11(M,ITUV)*RC(M,IXDR)
              T12(5) = T12(5) - PHS*DCONJG(ESLX21(M,ITUV)*RC(M,IZDR)
     &                                   - ESLZ21(M,ITUV)*RC(M,IXDR))
              T21(5) = T21(5) +            ESLX21(M,ITUV)*RC(M,IZDR)
     &                                   - ESLZ21(M,ITUV)*RC(M,IXDR)
              T22(5) = T22(5) + PHS*DCONJG(ESLX11(M,ITUV)*RC(M,IZDR)
     &                                   - ESLZ11(M,ITUV)*RC(M,IXDR))
              T11(6) = T11(6) +            ESLY11(M,ITUV)*RC(M,IXDR)
     &                                   - ESLX11(M,ITUV)*RC(M,IYDR)
              T12(6) = T12(6) - PHS*DCONJG(ESLY21(M,ITUV)*RC(M,IXDR)
     &                                   - ESLX21(M,ITUV)*RC(M,IYDR))
              T21(6) = T21(6) +            ESLY21(M,ITUV)*RC(M,IXDR)
     &                                   - ESLX21(M,ITUV)*RC(M,IYDR)
              T22(6) = T22(6) + PHS*DCONJG(ESLY11(M,ITUV)*RC(M,IXDR)
     &                                   - ESLX11(M,ITUV)*RC(M,IYDR))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (-i FOR EQSL)
            BFIELD(1,IPTS) = BFIELD(1,IPTS) 
     &                     + CONE*DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(4)
     &                     + CONE*DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(4)
     &                     + CONE*DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(4)
     &                     + CONE*DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(4)
            BFIELD(2,IPTS) = BFIELD(2,IPTS) 
     &                     + CONE*DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(5)
     &                     + CONE*DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(5)
     &                     + CONE*DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(5)
     &                     + CONE*DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(5)
            BFIELD(3,IPTS) = BFIELD(3,IPTS) 
     &                     + CONE*DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(6)
     &                     + CONE*DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(6)
     &                     + CONE*DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(6)
     &                     + CONE*DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(6)
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     MULTIPLY BY CONE
      DO IX=1,3
        DO IPTS=1,NPTS
          BFIELD(IX,IPTS) = CONE*BFIELD(IX,IPTS)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'MAGNTCF'
      TITLE  = 'Magnetic field for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{B}_{i}(z)'
      KEY(1) = 'B_{x}(z)'
      KEY(2) = 'B_{y}(z)'
      KEY(3) = 'B_{z}(z)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(ABS(BFIELD(IJK,IPTS)),IJK=1,3)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,3,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE FRMFCTR(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   FFFFFFFF RRRRRRR  MM       MM FFFFFFFF CCCCCC TTTTTTTT RRRRRRR     C
C   FF       RR    RR MMM     MMM FF      CC    CC   TT    RR    RR    C
C   FF       RR    RR MMMM   MMMM FF      CC         TT    RR    RR    C
C   FFFFFF   RR    RR MM MM MM MM FFFFFF  CC         TT    RR    RR    C
C   FF       RRRRRRR  MM  MMM  MM FF      CC         TT    RRRRRRR     C
C   FF       RR    RR MM   M   MM FF      CC    CC   TT    RR    RR    C
C   FF       RR    RR MM       MM FF       CCCCCC    TT    RR    RR    C
C                                                                      C
C -------------------------------------------------------------------- C
C  FRMFCTR CREATES A PLOT OF THE ELECTRON SCATTERING FORM FACTOR FOR   C
C  A MOLECULAR CHARGE DENSITY BY USE OF THE EQ-COEFFICIENTS AND A      C
C  FOURIER TRANSFORM OVER THE HGTFS.                                   C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(2)
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
C
      COMPLEX*16 CONE,T11(2),T12(2),T21(2),T22(2)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ)
      COMPLEX*16 HABC(MB2,MEQ)
      COMPLEX*16 GE(0:NPTS)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = XYZI(3) + IPTS*RS
      ENDDO
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        GE(IPTS) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL BLOCKS (INDICES 1000-3000)                         C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQLLMK(ELL011,ELL021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EQSSMK(ESS011,ESS021,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     LOOP OVER EACH GRID COORDINATE                                   C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       GENERATE A BATCH OF HGTF TRANSFORMS FOR THIS LOCATION
        IF(HMLT.EQ.'NORL') THEN
C         CALL HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAMLL)
          CALL HTFRMS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAMLL)
        ELSE
C         CALL HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAMSS)
          CALL HTFRMS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAMSS)
        ENDIF
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,2
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C           CHARGE DENSITY RHO(X,Y,Z)                                  C
C**********************************************************************C
C
C           ELL0: BASIS FUNCTION OVERLAP PRODUCT
            DO ITUV=1,NTUVLL
              T11(1) = T11(1) +            ELL011(M,ITUV) *HABC(M,ITUV)
              T12(1) = T12(1) - PHS*DCONJG(ELL021(M,ITUV))*HABC(M,ITUV)
              T21(1) = T21(1) +            ELL021(M,ITUV) *HABC(M,ITUV)
              T22(1) = T22(1) + PHS*DCONJG(ELL011(M,ITUV))*HABC(M,ITUV)
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            GE(IPTS) = GE(IPTS) + DENT(NA1+IBAS,NB1+JBAS)*T11(1)
     &                          + DENT(NA1+IBAS,NB2+JBAS)*T12(1)
     &                          + DENT(NA2+IBAS,NB1+JBAS)*T21(1)
     &                          + DENT(NA2+IBAS,NB2+JBAS)*T22(1)
C
            IF(HMLT.EQ.'NORL') GOTO 100
C
C           ESS0: BASIS FUNCTION OVERLAP PRODUCT
            DO ITUV=1,NTUVSS
              T11(2) = T11(2) +            ESS011(M,ITUV) *HABC(M,ITUV)
              T12(2) = T12(2) - PHS*DCONJG(ESS021(M,ITUV))*HABC(M,ITUV)
              T21(2) = T21(2) +            ESS021(M,ITUV) *HABC(M,ITUV)
              T22(2) = T22(2) + PHS*DCONJG(ESS011(M,ITUV))*HABC(M,ITUV)
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            GE(IPTS) = GE(IPTS) + DENT(NA1+KBAS,NB1+LBAS)*T11(2)
     &                          + DENT(NA1+KBAS,NB2+LBAS)*T12(2)
     &                          + DENT(NA2+KBAS,NB1+LBAS)*T21(2)
     &                          + DENT(NA2+KBAS,NB2+LBAS)*T22(2)
C          
100         CONTINUE
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'FRMFCTR'
      TITLE  = 'Form factor for '//TRIM(MOLCL)//
     &                                   ' under HMLT = '//HMLT
      XAXIS  = 'q_{z} (a.u.)'
      YAXIS  = '{G}_{E}(q_{z})'
      KEY(1) = 'Re [{G}_{E}(q_{z})]'
      KEY(2) = 'Im [{G}_{E}(q_{z})]'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       PRINT DISTANCE ALONG PATH AND FORM FACTOR
        DO IPTS=0,NPTS
          WRITE(8, *) D(IPTS),DREAL(GE(IPTS)),IMAG(GE(IPTS))
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,2,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE GNULINE(XOUT,TITLE,XAXIS,YAXIS,NDAT,KEY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       GGGGGG  NN    NN UU    UU LL       IIII NN    NN EEEEEEEE      C
C      GG    GG NNN   NN UU    UU LL        II  NNN   NN EE            C
C      GG       NNNN  NN UU    UU LL        II  NNNN  NN EE            C
C      GG       NN NN NN UU    UU LL        II  NN NN NN EEEEEE        C
C      GG   GGG NN  NNNN UU    UU LL        II  NN  NNNN EE            C
C      GG    GG NN   NNN UU    UU LL        II  NN   NNN EE            C
C       GGGGGG  NN    NN  UUUUUU  LLLLLLLL IIII NN    NN EEEEEEEE      C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNULINE IS A CONTROLLING ROUTINE THAT GENERATES A GNUPLOT MAKE FILE C
C  FOR A SET OF DATA POINTS.                                           C
C**********************************************************************C
C
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(NDAT)
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(XOUT)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot raw data'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ENDIF
      ENDDO
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf enhance font "palatino,10"'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(XOUT)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Load line style definitions'
      WRITE(9,'(A)') 'load "plots/plotstyles.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A)') 'set xlabel "'//TRIM(XAXIS)//'"'
      WRITE(9,'(A)') 'set ylabel "'//TRIM(YAXIS)//'"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plotting range'
      WRITE(9,'(A)') 'xmin = GPVAL_X_MIN'
      WRITE(9,'(A)') 'xmax = GPVAL_X_MAX'
      WRITE(9,'(A)') 'ymin = GPVAL_Y_MIN'
      WRITE(9,'(A)') 'ymax = GPVAL_Y_MAX'
      WRITE(9,'(A)') 'set xrange [xmin:xmax] noreverse nowriteback'
      WRITE(9,'(A)') 'set yrange [ymin:ymax] noreverse nowriteback'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Grid style'
      WRITE(9,'(A)') 'set style line 102 lc rgb"#808080" lt 0 lw 1'
      WRITE(9,'(A)') 'set grid back ls 102'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ENDIF
      ENDDO
      CLOSE(UNIT=9)
C
      WRITE(6, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
      WRITE(7, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
C
      RETURN
      END
C
C
      SUBROUTINE GNUDENS(XOUT,TITLE,NHRZ,NVTC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     GGGGGG  NN    NN UU    UU DDDDDDD  EEEEEEEE NN    NN  SSSSSS     C
C    GG    GG NNN   NN UU    UU DD    DD EE       NNN   NN SS    SS    C
C    GG       NNNN  NN UU    UU DD    DD EE       NNNN  NN SS          C
C    GG       NN NN NN UU    UU DD    DD EEEEEE   NN NN NN  SSSSSS     C
C    GG   GGG NN  NNNN UU    UU DD    DD EE       NN  NNNN       SS    C
C    GG    GG NN   NNN UU    UU DD    DD EE       NN   NNN SS    SS    C
C     GGGGGG  NN    NN  UUUUUU  DDDDDDD  EEEEEEEE NN    NN  SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNUDENS IS A CONTROLLING ROUTINE THAT GENERATES A GNUPLOT MAKE FILE C
C  FOR A DENSITY MAP.                                                  C
C**********************************************************************C
C
      CHARACTER*80 XOUT,TITLE
C
      RATIO = DFLOAT(NVTC)/DFLOAT(NHRZ)
      SZHRZ = 10.0D0
      SZVTC = 10.0D0*RATIO
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(XOUT)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A,F5.2)') 'set size ratio ',RATIO
      WRITE(9,'(A,F5.2,A,F5.2,A)') 'set terminal pdf size ',SZHRZ,'cm,',
     &                                     SZVTC,'cm font "palatino,10"'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(XOUT)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Load line style definitions'
      WRITE(9,'(A)') 'load "plots/pals/jet.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A)') 'set xlabel "NHRZ"'
      WRITE(9,'(A)') 'set ylabel "NVTC"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Grid style'
      WRITE(9,'(A)') 'set style line 102 lc rgb"#808080" lt 0 lw 1'
      WRITE(9,'(A)') 'set grid back ls 102'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plotting options'
      WRITE(9,'(A)') 'set view map'
      WRITE(9,'(A)') 'set palette model RGB'
      WRITE(9,'(A)') 'set palette defined'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2)') 'splot "plots/'//TRIM(XOUT)//'.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
      WRITE(6, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
      WRITE(7, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
C
      RETURN
      END
C
C
      FUNCTION CLEBSCH(KQN,MQN,NSGN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     CCCCCC  LL       EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C    CC       LL       EE       BB    BB SS       CC       HH    HH    C
C    CC       LL       EEEEEE   BBBBBBB   SSSSSS  CC       HHHHHHHH    C
C    CC       LL       EE       BB    BB       SS CC       HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C     CCCCCC  LLLLLLLL EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLEBSCH DETERMINES A CLEBSCH-GORDAN COEFFICIENT FOR KQN AND MQN.    C
C -------------------------------------------------------------------- C
C  KQN IS FINE BUT MQN IS DOUBLE THE ACTUAL VALUE, AND NSGN IS THE     C
C  PARITY NUMBER.                                                      C
C**********************************************************************C
C
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
C
      T1 = 2.0D0*LQN + 1.0D0 + MQN*NSGN
      T2 = 4.0D0*LQN + 2.0D0
C
      CLEBSCH = DSQRT(T1/T2)
C
      RETURN
      END
C
C
      FUNCTION SPHHRM(THETA,PHI,L,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        SSSSSS  PPPPPPP  HH    HH HH    HH RRRRRRR  MM       MM       C
C       SS    SS PP    PP HH    HH HH    HH RR    RR MMM     MMM       C
C       SS       PP    PP HH    HH HH    HH RR    RR MMMM   MMMM       C
C        SSSSSS  PP    PP HHHHHHHH HHHHHHHH RR    RR MM MM MM MM       C
C             SS PPPPPPP  HH    HH HH    HH RRRRRRR  MM  MMM  MM       C
C       SS    SS PP       HH    HH HH    HH RR    RR MM   M   MM       C
C        SSSSSS  PP       HH    HH HH    HH RR    RR MM       MM       C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPHHRM RETURNS A COMPLEX*16 SPHERICAL HARMONIC Y_L^M (θ,φ).         C
C -------------------------------------------------------------------- C
C  PARAMETERS:                                                         C
C   INPUT  θ - ZENITH ANGLE (FROM POSITIVE Z DOWN).                    C
C          φ - AZIMUTH ANGLE (FROM POSITIVE X TOWARD POSITIVE Y).      C
C          L - ORBITAL QUANTUM NUMBER (0,1,...).                       C
C          M - MAGNETIC QUANTUM NUMBER (-L,...,0,...,+L).              C
C  OUTPUT  SPHHRM - DOUBLE COMPLEX NUMBER.                             C
C**********************************************************************C
C
      COMPLEX*16 SPHHRM
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     FOR CONDON-SHORTLEY PHASE CONVENTION
      MTEMP = M
      IF(M.LT.0) THEN
        M  =-M
        IP =(-1)**M
      ENDIF
C
      DEN = 4.0D0*PI*NFACT(L+M)
      FCT = NFACT(L-M)*(2.0D0*L+1.0D0)/DEN
      FCT = DSQRT(FCT)
      AZR = DCOS(M*PHI)
      AZI = DSIN(M*PHI)
      ARG = DCOS(THETA)
      PLM = PLGNDR(L,M,ARG)
C
      IF(M.GE.0) THEN
        SPHHRM = DCMPLX(   FCT*PLM*AZR,    FCT*PLM*AZI)
      ELSEIF(M.LT.0) THEN
        SPHHRM = DCMPLX(IP*FCT*PLM*AZR,-IP*FCT*PLM*AZI)
      ENDIF

      M = MTEMP
C
      RETURN
      END
C
C
      FUNCTION PLGNDR(L,M,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        PPPPPPP  LL       GGGGGG  NN    NN DDDDDDD  RRRRRRR           C
C        PP    PP LL      GG    GG NNN   NN DD    DD RR    RR          C
C        PP    PP LL      GG    GG NNNN  NN DD    DD RR    RR          C
C        PP    PP LL      GG       NN NN NN DD    DD RR    RR          C
C        PPPPPPP  LL      GG   GGG NN  NNNN DD    DD RRRRRRR           C
C        PP       LL      GG    GG NN   NNN DD    DD RR    RR          C
C        PP       LLLLLLLL GGGGGG  NN    NN DDDDDDD  RR    RR          C
C                                                                      C
C -------------------------------------------------------------------- C
C  PLGNDR RETURNS AN ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).          C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ X      - ARGUMENT WITH -1 <= X <= 1.                              C
C  ▶ L      - ORBITAL QUANTUM NUMBER (0,1,...).                        C
C  ▶ M      - MAGNETIC QUANTUM NUMBER (0,...,+L).                      C
C  OUTPUT:                                                             C
C  ▶ PLGNDR - ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).                 C
C**********************************************************************C
C
C     CHECK VALIDITY OF ARGUMENTS
      IF(M.LT.0) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - M < 0.'
        WRITE(7, *) 'In PLGNDR: bad argument - M < 0.'
        STOP
      ELSEIF(M.GT.L) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - L < M: ',L,'<',M
        WRITE(7, *) 'In PLGNDR: bad argument - L < M: ',L,'<',M
        STOP
      ELSEIF(DABS(X).GT.1) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - X NOTIN [-1,+1].'
        WRITE(7, *) 'In PLGNDR: bad argument - X NOTIN [-1,+1].'
        STOP
      ENDIF
C
C     COMPUTE P^M_M (X)
      PMM = 1.0D0
      IF(M.GT.0) THEN
        SOMX2 = DSQRT((1.0D0-X)*(1.0D0+X))
        FACT  = 1.0D0
        DO I=1,M
          PMM  =-PMM*FACT*SOMX2
          FACT = FACT + 2.0D0
        ENDDO
      ENDIF
C
C     APPLY RECURRENCE RELATION UNTIL WE HAVE P^M_L
      IF(L.EQ.M) THEN
        PLGNDR = PMM
      ELSE
        PMMP1 = X*PMM*(2*M+1)
        IF(L.EQ.M+1) THEN
C         COMPUTE P^M_M+1
          PLGNDR = PMMP1
        ELSE
C         COMPUTE P^M_L, L>M+1
          DO LL=M+2,L
            LLM   = LL-M
            PLL   = (X*(2*LL-1)*PMMP1-(LL+M-1)*PMM)/LLM
            PMM   = PMMP1
            PMMP1 = PLL
          ENDDO
          PLGNDR = PLL
        ENDIF
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION NFACT(N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              NN    NN FFFFFFFF   AA     CCCCCC TTTTTTTT              C
C              NNN   NN FF        AAAA   CC    CC   TT                 C
C              NNNN  NN FF       AA  AA  CC         TT                 C
C              NN NN NN FFFFFF  AA    AA CC         TT                 C
C              NN  NNNN FF      AAAAAAAA CC         TT                 C
C              NN   NNN FF      AA    AA CC    CC   TT                 C
C              NN    NN FF      AA    AA  CCCCCC    TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  NFACT(N) RETURNS THE INTEGER RESTULT OF THE FACTORIAL N! UP TO 30!. C
C**********************************************************************C
C
C     CHECK THAT ARGUMENT IS VALID
      IF(N.LT.0) THEN
        WRITE(6, *) 'In NFACT: negative input number.',N
        WRITE(7, *) 'In NFACT: negative input number.',N
        STOP
      ELSEIF(N.GT.30) THEN
        WRITE(6, *) 'In NFACT: N too large. N = ',N
        WRITE(7, *) 'In NFACT: N too large. N = ',N
        STOP
      ENDIF
C
C     FACTORIAL AS A PRODUCT OF INTEGERS
      NFACT = 1
      DO M=1,N
        NFACT = M*NFACT
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [11] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] RMAKE: BATCH OF R-INTEGRALS FOR BASIS FUNCTION OVERLAPS.       C
C   [B] FUNFM: LIST OF BOYS INTEGRALS FOR USE IN RMAKE.                C
C   [C] BOYSGEN: OUTPUT DATA FILE WITH FAMILY OF BOYS FUNCTIONS.       C
C   [D] HGTFS: BATCH OF HGTF AMPLITUDES EVALUATED AT (X,Y,Z).          C
C   [E] HERMITE: EVALUATION OF H_I (P,X) BY RECURRENCE.                C
C   [F] HTFRMS: BATCH OF HGTF FOURIER TRANSFORMS AT (QX,QY,QZ).        C
C**********************************************************************C
C
C
      SUBROUTINE RMAKE(RC,QP,APH,MAXM,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           RRRRRRR  MM       MM    AA    KK    KK EEEEEEEE            C
C           RR    RR MMM     MMM   AAAA   KK   KK  EE                  C
C           RR    RR MMMM   MMMM  AA  AA  KK  KK   EE                  C
C           RR    RR MM MM MM MM AA    AA KKKKK    EEEEEE              C
C           RRRRRRR  MM  MMM  MM AAAAAAAA KK  KK   EE                  C
C           RR    RR MM   M   MM AA    AA KK   KK  EE                  C
C           RR    RR MM       MM AA    AA KK    KK EEEEEEEE            C
C                                                                      C
C -------------------------------------------------------------------- C
C  RMAKE GENERATES A COMPLETE SET OF R-INTEGRALS REQUIRED IN THE       C
C  FINITE SUM REPRESENTATION OF A MULTI-CENTRE GAUSSIAN OVERLAP.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION FS(MB2,ML4),APH(MB2),QP(MB2,3),RC(MB2,MRC),RC2(MB2,MRC)
      DIMENSION F1(MB2,ML4),F2(MB2,ML4),F3(MB2,ML4),F4(MB2,ML4)
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2),
     &          I1(MB2),I2(MB2),I3(MB2),I4(MB2)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     VALUES WHICH DETERMINE EVALUATION METHOD
      EPSZR = 1.0D-11
      EPSPL = 1.7D+01
      EPSAS = 3.0D+01
C
C**********************************************************************C
C     THE FIRST STEP OF THIS ROUTINE IS TO EVALUATE THE REQUIRED       C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
C     INITIALISE COUNTERS FOR EVALUATION METHODS IN BATCH
      N1 = 0
      N2 = 0
      N3 = 0
      N4 = 0
C
C     FOR EACH PAIR OF BASIS FUNCTIONS (EXPONENTS EI AND EJ IN 'M'),
C     DETERMINE THE BEST WAY TO EVALUATE THE BOYS FUNCTION
      DO M=1,MAXM
C
        X = QP(M,1)*QP(M,1) + QP(M,2)*QP(M,2) + QP(M,3)*QP(M,3)
        X = X*APH(M)
C
C       CASE 1: IF X=0.0D0 USE EXACT FORMULA
        IF(X.LE.EPSZR) THEN
C
          N1     = N1+1
          X1(N1) = X
          I1(N1) = M
C
C       CASE 2: IF X<EPSPL USE A POLYNOMIAL EXPANSION
        ELSEIF(X.GT.EPSZR.AND.X.LE.EPSPL) THEN
C
          N2     = N2+1
          X2(N2) = X
          I2(N2) = M
C
C       CASE 3: IF X<EPSAS USE ASYMPTOIC FORMULA WITH EXPONENTIAL
        ELSEIF(X.GT.EPSPL.AND.X.LE.EPSAS) THEN
C
          N3     = N3+1
          X3(N3) = X
          I3(N3) = M
C
C       CASE 4: IF X>EPSAS USE ASYMPTOIC FORMULA WITHOUT EXPONENTIAL
        ELSE
C
          N4     = N4+1
          X4(N4) = X
          I4(N4) = M
C
        ENDIF
C
      ENDDO
C
C     EVALUATE THE BOYS INTEGRALS -- A BATCH FOR EACH ITYPE
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS X=0.0D0.
C     THE VALUE OF THIS FUNCTION IS 2N+1 (DONE IN FUNFM).
      IF(N1.GT.0) THEN
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO K=1,LAM+1
          DO M=1,N1
            FS(I1(M),K) = F1(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=EPSPL.
C     EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C     AND RECURRENCE IN DIRECTION OF DECREASING M.
      IF(N2.GT.0) THEN
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO K=1,LAM+1
          DO M=1,N2
            FS(I2(M),K) = F2(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=EPSAS.
C     EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      IF(N3.GT.0) THEN
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO K=1,LAM+1
          DO M=1,N3
            FS(I3(M),K) = F3(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 4: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=EPSAS.
C     EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      IF(N4.GT.0) THEN
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO K=1,LAM+1
          DO M=1,N4
            FS(I4(M),K) = F4(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     WITH THE FULL SET OF BOYS' INTEGRALS WE NOW APPLY RECURRENCE     C
C     RELATIONS TO F_N (X) AND EVALUATE THE R-INTEGRALS.               C
C**********************************************************************C
C
C     CONSTRUCT TOP LEVEL (FOR MAXIMUM LAM VALUE)
      DO M=1,MAXM
        RC(M,1)= (-2.0D0*APH(M))**LAM
        RC(M,1) = RC(M,1)*FS(M,LAM+1)
      ENDDO
C
C     MINIMUM LEVEL ILV BASED ON LAM VALUE
      IF(MOD(LAM,2).EQ.0) THEN
       ITUVMIN = 1
      ELSE
       ITUVMIN = 2
      ENDIF
C
C     INITIALISE ITUV COUNTER (RELATES TO # CARTESIAN INDICES FOR lam)
      ITUV=-1
C
C     MAIN LOOP: LEVEL 'ILV' STARTING AT LAM-1 AND WORKING BACKWARDS
      DO ILV=LAM-1,ITUVMIN,-2
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT = DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU = DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV = DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
        DO M=1,MAXM
          RC2(M,1) = (-2.0D0*APH(M))**ILV
          RC2(M,1) = RC2(M,1)*FS(M,ILV+1)
        ENDDO
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT = DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU = DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV = DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXM
                 RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                 RC(M,N2) =-QP(M,2)*RC2(M,K1)
                 RC(M,N3) =-QP(M,3)*RC2(M,K1)
               ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXM
          RC(M,1) = (-2.0D0*APH(M))**(ILV-1)
          RC(M,1) = RC(M,1)*FS(M,ILV)
        ENDDO
C
      ENDDO
C
C
C     AN ADDITIONAL LOOP OVER ADDRESSES (WHEN LAM IS ODD)
      IF(MOD(LAM,2).EQ.1) THEN
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT=DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = IABC(IT+1,IU  ,IV  )
              N2 = IABC(IT  ,IU+1,IV  )
              N3 = IABC(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M1 = IABC(IT-1,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M2 = IABC(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                M3 = IABC(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
C
                K1 = IABC(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILV
            ENDDO
C
          ENDDO
C
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXM
          RC2(M,1) = FS(M,1)
        ENDDO
C
C       MOVE THE RC2 ARRAY INTO RC
C
        ITMAX = (LAM+1)*(LAM+2)*(LAM+3)/6
        DO IT=1,ITMAX
          DO M=1,MAXM
            RC(M,IT) = RC2(M,IT)
          ENDDO
        ENDDO
C
C     END IF STATEMENT FOR THE ODD LAM CASE
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FUNFM(FM,T,N,LAM,ITYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           FFFFFFFF UU    UU NN    NN FFFFFFFF MM       MM            C
C           FF       UU    UU NNN   NN FF       MMM     MMM            C
C           FF       UU    UU NNNN  NN FF       MMMM   MMMM            C
C           FFFFFF   UU    UU NN NN NN FFFFFF   MM MM MM MM            C
C           FF       UU    UU NN  NNNN FF       MM  MMM  MM            C
C           FF       UU    UU NN   NNN FF       MM   M   MM            C
C           FF        UUUUUU  NN    NN FF       MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  FUNFM EVALUATES INTEGRAL [INT_{0}^{1} U^{2M} EXP(-T*U^{2}) dU]      C
C  FOR VARIABLE T > 0 FOR ALL ORDERS 0 < M < LAM.                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ITYPE = 1 - SPECIAL CASE X = 0.0D0.                               C
C  ▶ ITYPE = 2 - POWER SERIES AND REVERSE RECURRENCE.                  C
C                (60 TERMS WILL BE USED, SO USE MUST SUPPLY A VALUE    C
C                 APPROPRIATE TO THE MAX VALUE OF X IN BATCH).         C
C  ▶ ITYPE = 3 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C  ▶ ITYPE = 4 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C                ALL TERMS DEPENDING ON EXP(-X) ARE OMITTED TO AVOID   C
C                NUMERICAL UNDERFLOW PROBLEMS.                         C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION FM(MB2,ML4),T(MB2),TLAM(MB2),TT2(MB2),
     &          TXP(MB2),TRT(MB2)
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      DATA A0,B0/4.994501191201870D-1,4.551838436668326D-1/
C
C**********************************************************************C
C     ITYPE = 1: SPECIAL CASE FOR T = 0.0D0                            C
C**********************************************************************C
C
      IF(ITYPE.EQ.1) THEN
C
        DO K=1,LAM+1
          MVAL  = K-1
          VALUE = 1.0D0/DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,K) = VALUE
          ENDDO
        ENDDO
        RETURN
C
C**********************************************************************C
C     ITYPE = 2: POWER SERIES EVALUATION                               C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.2) THEN
C
C       INITIALISE THE POWER SERIES FOR M = LAM
        DO M=1,N
          TXP(M)      = DEXP(-T(M))
          TT2(M)      = 2.0D0*T(M)
          TLAM(M)     = 1.0D0
          FM(M,LAM+1) = 1.0D0
        ENDDO
C
C       LOOP OVER TERMS IN THE POWER SERIES
        DO K=1,60
          DLAM = DFLOAT(2*LAM+2*K+1)
          DO M=1,N
            TLAM(M)     = TLAM(M)*TT2(M)/DLAM
            FM(M,LAM+1) = FM(M,LAM+1) + TLAM(M)
          ENDDO
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DEN = DFLOAT(2*LAM+1)
        DO M=1,N
          FM(M,LAM+1) = FM(M,LAM+1)*TXP(M)/DEN
        ENDDO
C
C       NOW COMPLETE TABLE BY BACKWARDS RECURRENCE
        DO I=1,LAM
          MIND  = LAM-I+1
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND) = (TT2(M)*FM(M,MIND+1) + TXP(M))/COEFF
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 3: ASYMPTOTIC EXPANSION WITH EXPONENTIAL ARGUMENT.       C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.3) THEN
C
C       INITIALISE THE ASYMPTOTIC EXPANSION
        DO M=1,N
          TXP(M) = DEXP(-T(M))
          TT2(M) = 2.0D0*T(M)
          TRT(M) = DSQRT(T(M))
        ENDDO
C
C       SEED VALUES
        DO M=1,N
          FM(M,1) = A0/(B0+T(M))
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DO M=1,N
          FM(M,1) = 0.5D0*PI12/TRT(M) - TXP(M)*FM(M,1)
        ENDDO
C
C       NOW COMPLETE TABLE BY FORWARD RECURRENCE
        DO MIND=1,LAM
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND+1) = (COEFF*FM(M,MIND) - TXP(M))/TT2(M)
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 4: ASYMPTOTIC EXPANSION WITH VERY LARGE ARGUMENT         C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.4) THEN
C
C       INITIALISE THE ASYMPTOTIC EXPANSION
        DO M=1,N
          TT2(M)  = 2.0D0*T(M)
          FM(M,1) = 0.5D0*PI12/DSQRT(T(M))
        ENDDO
C
C       NOW COMPLETE TABLE BY FORWARD RECURRENCE
        DO MIND=1,LAM
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND+1) = COEFF*FM(M,MIND)/TT2(M)
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE OUT OF RANGE: INVALID INPUT TO FUNFM                       C
C**********************************************************************C
C
      ELSE
91      FORMAT(2X,'In FUNFM: invalid type (must be 1-4)',I4)
        WRITE(6,91) ITYPE
        WRITE(7,91) ITYPE
        STOP
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BOYSGEN(LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB   OOOOOO  YY    YY  SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C    BB    BB OO    OO YY    YY SS    SS GG    GG EE       NNN   NN    C
C    BB    BB OO    OO  YY  YY  SS       GG       EE       NNNN  NN    C
C    BBBBBBB  OO    OO   YYYY    SSSSSS  GG       EEEEEE   NN NN NN    C
C    BB    BB OO    OO    YY          SS GG   GGG EE       NN  NNNN    C
C    BB    BB OO    OO    YY    SS    SS GG    GG EE       NN   NNN    C
C    BBBBBBB   OOOOOO     YY     SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  BOYSGEN PRODUCES A DATA FILE WHICH CONTAINS A FAMILY OF BOYS        C
C  FUNCTIONS OVER A SPECIFIED REGION, GIVEN A MAXIMUM FAMILY           C
C  PARAMETER DETERMINED BY LAM.                                        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2)
      DIMENSION F1(MB2,ML4),F2(MB2,ML4),F3(MB2,ML4),
     &          F4(MB2,ML4),FS(MB2,ML4)
C
C     EVALUATION PARAMETERS
      NTOT = 400
      XMIN = 0.00D0
      XMAX = 4.00D1
      HSTP = (XMAX-XMIN)/NTOT
C
C     VALUES WHICH DETERMINE EVALUATION METHOD
      EPSZR = 1.0D-11
      EPSPL = 1.7D+01
      EPSAS = 3.0D+01
C
C**********************************************************************C
C     THE FIRST STEP OF THIS SUBROUTINE IS TO EVALUATE THE REQUIRED    C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
      OPEN(UNIT=8,FILE='plots/boysfunction.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO NX=0,NTOT
C
      X = XMIN + HSTP*NX
C
C     CASE 0: ARGUMENT OF THE BOYS FUNCTION IS X = 0.
C             THE VALUE OF THIS FUNCTION IS (2N+1).
      IF(X.LE.EPSZR) THEN
C
        N1     = 1
        X1(N1) = X
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO JJ=1,LAM+1
          FS(N1,JJ) = F1(N1,JJ)
        ENDDO
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=17.
C             EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C             AND RECURRENCE IN DIRECTION OF DECREASING M.
      ELSEIF(X.GT.EPSZR.AND.X.LE.EPSPL) THEN
C
        N2     = 1
        X2(N2) = X
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO JJ=1,LAM+1
          FS(N2,JJ) = F2(N2,JJ)
        ENDDO
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      ELSEIF(X.GT.EPSPL.AND.X.LE.EPSAS) THEN
C
        N3     = 1
        X3(N3) = X
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO JJ=1,LAM+1
          FS(N3,JJ) = F3(N3,JJ)
        ENDDO
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      ELSE
C
        N4     = 1
        X4(N4) = X
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO JJ=1,LAM+1
          FS(N4,JJ) = F4(N4,JJ)
        ENDDO
C
      ENDIF
C
      WRITE(8, *) X,(FS(1,L),L=1,LAM+1)
C
      ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE HGTFS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              HH    HH  GGGGGG TTTTTTTT FFFFFFFF SSSSSS               C
C              HH    HH GG    GG   TT    FF      SS    SS              C
C              HH    HH GG         TT    FF      SS                    C
C              HHHHHHHH GG         TT    FFFFFF   SSSSSS               C
C              HH    HH GG   GGG   TT    FF            SS              C
C              HH    HH GG    GG   TT    FF      SS    SS              C
C              HH    HH  GGGGGG    TT    FF       SSSSSS               C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTFS GENERATES AN ARRAY OF HGTF FUNCTIONS EVALUATED AT A SET OF    C
C  COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM TO       C
C  TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A        C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTRE, RP.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION EXL(MBS,2),NBAS(2)
      DIMENSION XYZEVAL(3),XYZ(3,2)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     CALCULATE NUMBER OF UNIQUE CONTRIBUTIONS TO FINITE EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OF EXPONENTS
          PAB  = EXL(IBAS,1)+EXL(JBAS,2)
C
C         HGTF CENTRE COORDINATES
          PX = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/PAB
          PY = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/PAB
          PZ = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/PAB
C
C         COORDINATES WRT LOCAL ORIGIN
          RPX = XYZEVAL(1)-PX
          RPY = XYZEVAL(2)-PY
          RPZ = XYZEVAL(3)-PZ
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS  = DEXP(-PAB*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C         CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            HALPH = HERMITE(PAB,RPX,IA(ITUV))
            HBETA = HERMITE(PAB,RPY,IB(ITUV))
            HGAMA = HERMITE(PAB,RPZ,IC(ITUV))
C
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = HALPH*HBETA*HGAMA*GSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION HERMITE(P,X,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    HH    HH EEEEEEEE RRRRRRR  MM       MM IIII TTTTTTTT EEEEEEEE     C
C    HH    HH EE       RR    RR MMM     MMM  II     TT    EE           C
C    HH    HH EE       RR    RR MMMM   MMMM  II     TT    EE           C
C    HHHHHHHH EEEEEE   RR    RR MM MM MM MM  II     TT    EEEEEE       C
C    HH    HH EE       RRRRRRR  MM  MMM  MM  II     TT    EE           C
C    HH    HH EE       RR    RR MM   M   MM  II     TT    EE           C
C    HH    HH EEEEEEEE RR    RR MM       MM IIII    TT    EEEEEEEE     C
C                                                                      C
C -------------------------------------------------------------------- C
C  HERMITE EVALUATES HERMITE POLYNOMIAL H_I (P,X) BY RECURRENCE.       C
C**********************************************************************C
C
      IF(I.LT.0) THEN
        WRITE(6, *) 'In HERMITE: index less than zero. I = ',I
        WRITE(7, *) 'In HERMITE: index less than zero. I = ',I
        STOP
      ENDIF
C
      IF(I.GT.40) THEN
        WRITE(6, *) 'In HERMITE: index greater than 40. I = ',I
        WRITE(7, *) 'In HERMITE: index greater than 40. I = ',I
        STOP
      ENDIF
C
C     NEED FIRST TWO VALUES TO ESTABLISH RECURRENCE RELATION
      TEMP1 = 1.0D0
      TEMP2 = 2.0D0*P*X
C
      IF(I.EQ.0) THEN
        HERMITE = TEMP1
      ELSEIF(I.EQ.1) THEN
        HERMITE = TEMP2
      ELSEIF(I.GT.1) THEN
        DO N=2,I
          TEMP3 = 2.0D0*P*(X*TEMP2 - (N-1)*TEMP1)
          TEMP1 = TEMP2
          TEMP2 = TEMP3
        ENDDO
        HERMITE = TEMP2
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE HTFRMS(HABC,XYZEVAL,EXL,XYZ,NBAS,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       HH    HH TTTTTTTT FFFFFFFF RRRRRRR  MM       MM  SSSSSS        C
C       HH    HH    TT    FF       RR    RR MMM     MMM SS    SS       C
C       HH    HH    TT    FF       RR    RR MMMM   MMMM SS             C
C       HHHHHHHH    TT    FFFFFF   RR    RR MM MM MM MM  SSSSSS        C
C       HH    HH    TT    FF       RRRRRRR  MM  MMM  MM       SS       C
C       HH    HH    TT    FF       RR    RR MM   M   MM SS    SS       C
C       HH    HH    TT    FF       RR    RR MM       MM  SSSSSS        C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTFS GENERATES AN ARRAY OF HGTF FOURIER TRANSFORMS EVALUATED AT A  C
C  SET OF COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM   C
C  TO TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A     C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTRE, RP.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,2),KQN(2),NBAS(2)
      DIMENSION XYZEVAL(3),XYZ(3,2)
C
      COMPLEX*16 CONE,PHS,PHSQP
      COMPLEX*16 HABC(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CALCULATE NUMBER OF UNIQUE CONTRIBUTIONS TO FINITE EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OF EXPONENTS
          PAB  = EXL(IBAS,1)+EXL(JBAS,2)
C
C         HGTF CENTRE COORDINATES
          PX = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/PAB
          PY = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/PAB
          PZ = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/PAB
C
C         COORDINATES WRT LOCAL ORIGIN
          QPX = XYZEVAL(1)*PX
          QPY = XYZEVAL(2)*PY
          QPZ = XYZEVAL(3)*PZ
C
C         DOT PRODUCT FACTOR (COMPLEX WITH UNIT MAGNITUDE)
          QPVEC = QPX+QPY+QPZ
C         PHSQP = DEXP(-CONE*QPVEC)
          PHSQP = DCOS(QPVEC) + CONE*DSIN(QPVEC)
C
C         GAUSSIAN COMPONENT OF HTFRM
          QX2 = XYZEVAL(1)*XYZEVAL(1)
          QY2 = XYZEVAL(2)*XYZEVAL(2)
          QZ2 = XYZEVAL(3)*XYZEVAL(3)
          GSS = DEXP(-0.75D0*(QX2*QX2+QY2*QY2+QZ2*QZ2)/PAB)
C
C         INTEGRAL TRANSFORM TERM
          PRT = PAB*DSQRT(PAB)
          SCL = PI*PI12/PRT
C
C         CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           TEST TO DETERMINE MULTIPLICATIVE FACTOR
            IF(MOD(ILAM(ITUV),4).EQ.0) THEN
              PHS = DCMPLX(1.0D0,0.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.1) THEN
              PHS =-DCMPLX(0.0D0,1.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.2) THEN
              PHS =-DCMPLX(1.0D0,0.0D0)
            ELSEIF(MOD(ILAM(ITUV),4).EQ.3) THEN
              PHS = DCMPLX(0.0D0,1.0D0)
            ENDIF
C
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            QXA = XYZEVAL(1)**(IA(ITUV))
            QXB = XYZEVAL(2)**(IB(ITUV))
            QXC = XYZEVAL(3)**(IC(ITUV))
C
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = SCL*PHS*QXA*QXB*QXC*PHSQP*GSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [12] EQ-COEFFS: FINITE BASIS OVERLAP SPIN STRUCTURE FACTORS.        C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] EQSAVE: MAIN ROUTINE FOR BUILDING A GLOBAL FILE OF EQ-COEFFS.  C
C   [B] E0LLGN: GENERATE FULL SET OF E0LL COEFFICIENTS AND SAVE.       C
C   [C] E0SSGN: GENERATE FULL SET OF E0SS COEFFICIENTS AND SAVE.       C
C   [D] EILSGN: GENERATE FULL SET OF EILS COEFFICIENTS AND SAVE.       C
C   [E] EISLGN: GENERATE FULL SET OF EISL COEFFICIENTS AND SAVE.       C
C   [E] EQLLMK: GENERATE A BATCH OF EQLL COEFFICIENTS: (--) AND (+-).  C
C   [F] EQSSMK: GENERATE A BATCH OF EQSS COEFFICIENTS: (--) AND (+-).  C
C   [G] EQLSMK: GENERATE A BATCH OF EQLS COEFFICIENTS: (--) AND (+-).  C
C   [H] EQSLMK: GENERATE A BATCH OF EQSL COEFFICIENTS: (--) AND (+-).  C
C   [I] EILSB3: GENERATE A VECTOR BATCH OF EILS COEFFICIENTS FOR BREIT.C
C   [J] EISLB3: GENERATE A VECTOR BATCH OF EISL COEFFICIENTS FOR BREIT.C
C   [K] EQLL: A RAW BLOCK OF EQLL COEFFICIENTS FOR EQLLMK.             C
C   [L] EQSS: A RAW BLOCK OF EQSS COEFFICIENTS FOR EQSSMK.             C
C   [M] EQLS: A RAW BLOCK OF EQLS COEFFICIENTS FOR EQLSMK.             C
C   [N] EQSL: A RAW BLOCK OF EQSL COEFFICIENTS FOR EQSLMK.             C
C   [O] ESGTF: SET OF ES-COEFFS OVER SPHERICAL HARMONICS AND HGTFS.    C
C   [P] VRS: EXPANSION COEFFS IN HGTF OVERLAPS, CALLED IN ESGTF.       C
C   [Q] STEPLM: SIMULTANEOUS INCREASE IN (L,M) FOR USE IN VRS.         C
C   [R] STEPL: INCREMENT IN L FOR USE IN VRS.                          C
C   [S] STEPN: INCREMENT IN N FOR USE IN VRS.                          C
C   [T] RNLL: A BLOCK OF LL NORMALISATION COEFFS.                      C
C   [U] RNSS: A BLOCK OF SS NORMALISATION COEFFS.                      C
C   [V] RNLS: A BLOCK OF LS NORMALISATION COEFFS.                      C
C   [W] DNORM: NORM FOR A REAL OR COMPLEX PART OF EQ-COEFF LIST.       C
C**********************************************************************C
C
C
      SUBROUTINE EQSAVE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        EEEEEEEE  QQQQQQ    SSSSSS     AA    VV    VV EEEEEEEE        C
C        EE       QQ    QQ  SS    SS   AAAA   VV    VV EE              C
C        EE      QQ      QQ SS        AA  AA  VV    VV EE              C
C        EEEEEE  QQ      QQ  SSSSSS  AA    AA VV    VV EEEEEE          C
C        EE      QQ      QQ       SS AAAAAAAA  VV  VV  EE              C
C        EE       QQ    QQ  SS    SS AA    AA   VVVV   EE              C
C        EEEEEEEE  QQQQQQ QQ SSSSSS  AA    AA    VV    EEEEEEEE        C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSAVE CONSTRUCTS A SET OF COMMON ARRAYS FOR ALL REQUIRED EQTT'     C
C  COEFFICIENTS IN A CALCULATION THAT RESTS WITHIN QED.                C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION NTUV(0:MKP,4),NTRM(0:MKP,4),NWRD(0:MKP,4),SPCE(0:MKP,4)
      DIMENSION NTUVT(4),NTRMT(4),NWRDT(4),SPCET(4)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRSL,TRBR
C
C     MAXIMUM REQUIRED COMPONENT TYPES
      IF(HMLT.EQ.'NORL') THEN
        ITTMAX = 1
      ELSEIF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') THEN
        ITTMAX = 2
      ELSEIF(TREE.NE.'MBPT2') THEN
        ITTMAX = 3
      ELSE
        ITTMAX = 4
      ENDIF
C
C**********************************************************************C
C     LOOP OVER FOCK BLOCK AND COUNT ALL REQUIRED EQ-WORDS.            C
C**********************************************************************C
C
C     INITIALISE MAXIMUM LAMBDA
      LAMMX = 0
C
C     INITIALISE TOTAL COEFFICIENT COUNTERS
      DO ITT=1,4
        DO LAM=0,MKP+1
          NTUV(LAM,ITT) = 0
          NTRM(LAM,ITT) = 0
          NWRD(LAM,ITT) = 0
          SPCE(LAM,ITT) = 0.0D0
        ENDDO
        NTUVT(ITT) = 0
        NTRMT(ITT) = 0
        NWRDT(ITT) = 0
        SPCET(ITT) = 0.0D0
      ENDDO
C
C     LOOP OVER CENTRES A AND B
      DO ICNTA=1,NCNT
        DO ICNTB=1,NCNT
C
C         LOOP OVER KQNA VALUES
          DO KA=1,NKAP(ICNTA)
C
C           QUANTUM NUMBERS FOR BLOCK A
            IF(KAPA(KA,ICNTA).LT.0) THEN
              LQNA =-KAPA(KA,ICNTA)-1
            ELSE
              LQNA = KAPA(KA,ICNTA)
            ENDIF
            NBASA = NFNC(LQNA,ICNTA)
C
C           LOOP OVER KQNB VALUES
            DO KB=1,NKAP(ICNTB)
C
C             QUANTUM NUMBERS FOR BLOCK B
              IF(KAPA(KB,ICNTB).LT.0) THEN
                LQNB =-KAPA(KB,ICNTB)-1
              ELSE
                LQNB = KAPA(KB,ICNTB)
              ENDIF
              NBASB = NFNC(LQNB,ICNTB)
C
C             LOOP OVER |MQNA| VALUES
              DO MA=1,IABS(KAPA(KA,ICNTA))
                MJA = 2*MA-1
C
C               LOOP OVER |MQNB| VALUES
                DO MB=1,IABS(KAPA(KB,ICNTB))
                  MJB = 2*MB-1
C
C                 NUMBER OF BASIS FUNCTION OVERLAPS
                  MAXAB = NBASA*NBASB
C
C                 CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
                  LAM  = LQNA+LQNB
C
C                 NUMBER OF TERMS IN EXPANSIONS OF THIS LENGTH
                  NTUV(LAM  ,1) = (LAM+1)*(LAM+2)*(LAM+3)/6
                  NTUV(LAM+2,2) = (LAM+3)*(LAM+4)*(LAM+5)/6
                  NTUV(LAM+1,3) = (LAM+2)*(LAM+3)*(LAM+4)/6
                  NTUV(LAM+1,4) = (LAM+2)*(LAM+3)*(LAM+4)/6
C
C                 INCREASE NUMBER OF WORDS FOR THIS LAMBDA VALUE
                  NTRM(LAM  ,1) = NTRM(LAM  ,1) + NTUV(LAM  ,1)*MAXAB
                  NTRM(LAM+2,2) = NTRM(LAM+2,2) + NTUV(LAM+2,2)*MAXAB
                  NTRM(LAM+1,3) = NTRM(LAM+1,3) + NTUV(LAM+1,3)*MAXAB
                  NTRM(LAM+1,4) = NTRM(LAM+1,4) + NTUV(LAM+1,4)*MAXAB
C
C                 UPDATE LARGEST LAMBDA VALUE
                  IF(LAM.GT.LAMMX) THEN
                    LAMMX = LAM
                  ENDIF
C
C               END LOOPS OVER |MQNA| AND |MQNB|
                ENDDO
              ENDDO
C
C           END LOOPS OVER KQNA AND KQNB
            ENDDO
          ENDDO
C
C       END LOOPS OVER ICNTA AND ICNTB
        ENDDO
      ENDDO
C
C     NUMBER OF WORDS IN SET AND SPACE REQUIRED
      DO LAM=0,LAMMX+2
        NWRD(LAM,1) =  4*NTRM(LAM,1)
        NWRD(LAM,2) =  4*NTRM(LAM,2)
        NWRD(LAM,3) = 12*NTRM(LAM,3)
        NWRD(LAM,4) = 12*NTRM(LAM,4)
        DO ITT=1,ITTMAX
          SPCE(LAM,ITT) = 8.0D-6*NWRD(LAM,ITT)
        ENDDO
      ENDDO
C
C     CALCULATE TOTALS
      DO ITT=1,ITTMAX
        DO LAM=0,LAMMX+2
          NTUVT(ITT) = NTUVT(ITT) + NTUV(LAM,ITT)
          NTRMT(ITT) = NTRMT(ITT) + NTRM(LAM,ITT)
          NWRDT(ITT) = NWRDT(ITT) + NWRD(LAM,ITT)
          SPCET(ITT) = SPCET(ITT) + SPCE(LAM,ITT)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     SUMMARY OF WORD ANALYSIS                                         C
C**********************************************************************C
C
C     SECTION TITLE
20    FORMAT(1X,A,9X,A,4X,A,6X,A,8X,A,8X,A,6X,A)
21    FORMAT(1X,A,8X,I2,4X,I5,3X,I9,7X,I2,3X,I10,5X,F10.3)
22    FORMAT(1X,A,13X,I10,7X,I2,3X,I10,5X,F10.3)
23    FORMAT(1X,A,9X,I2,3X,I5,3X,I9,7X,I2,3X,I10,5X,F10.3)
24    FORMAT(1X,A,5X,A,3X,A,6X,A,8X,A,8X,A,6X,A)
25    FORMAT(1X,A,40X,I10,5X,F10.3)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',22),'Eq-coefficient word analysis'
      WRITE(7, *) REPEAT(' ',22),'Eq-coefficient word analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) 'Type','Λ','Terms','Length','#','Words','Size (MB)'
      WRITE(7,20) 'Type','Λ','Terms','Length','#','Words','Size (MB)'
C
C     E0LL ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=0,LAMMX
        IF(LAM.EQ.0) THEN
          WRITE(6,21) 'E0LL',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
          WRITE(7,21) 'E0LL',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
          WRITE(7,21) '    ',LAM,NTUV(LAM,1),NTRM(LAM,1), 4,NWRD(LAM,1),
     &                                                      SPCE(LAM,1)
        ENDIF
      ENDDO
C
      IF(HMLT.EQ.'NORL') GOTO 100
C
C     E0SS ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=2,LAMMX+2
        IF(LAM.EQ.2) THEN
          WRITE(6,21) 'E0SS',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
          WRITE(7,21) 'E0SS',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
          WRITE(7,21) '    ',LAM,NTUV(LAM,2),NTRM(LAM,2), 4,NWRD(LAM,2),
     &                                                      SPCE(LAM,2)
        ENDIF
      ENDDO
C
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 100
C
C     E0SS ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=1,LAMMX+1
        IF(LAM.EQ.1) THEN
          WRITE(6,21) 'EILS',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
          WRITE(7,21) 'EILS',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
          WRITE(7,21) '    ',LAM,NTUV(LAM,3),NTRM(LAM,3),12,NWRD(LAM,3),
     &                                                      SPCE(LAM,3)
        ENDIF
      ENDDO
C
      IF(TREE.NE.'MBPT2') GOTO 100
C
C     EISL ANALYSIS
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LAM=1,LAMMX+1
        IF(LAM.EQ.1) THEN
          WRITE(6,21) 'EISL',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
          WRITE(7,21) 'EISL',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
        ELSE
          WRITE(6,21) '    ',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
          WRITE(7,21) '    ',LAM,NTUV(LAM,4),NTRM(LAM,4),12,NWRD(LAM,4),
     &                                                      SPCE(LAM,4)
        ENDIF
      ENDDO
C
100   CONTINUE
C
C     SUMMARY OF TOTALS
      NWRDNET = 0
      SPCENET = 0.0D0
      DO ITT=1,ITTMAX
        NWRDNET = NWRDNET + NWRDT(ITT)
        SPCENET = SPCENET + SPCET(ITT)
      ENDDO
C
C     FIGURE OUT HOW MUCH SPACE IS ALLOWED BY PARAMETERS
      IF(HMLT.EQ.'NORL') THEN
        MWRD = 4
        MARR = 1
      ENDIF
      IF(HMLT.EQ.'DHFR') THEN
        MWRD = 8
        MARR = 2
      ENDIF
      IF(HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
        MWRD = 20
        MARR = 3
      ENDIF
      IF(TREE.EQ.'MBPT2') THEN
        IF(HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
          MWRD = 32
          MARR = 4
        ENDIF
      ENDIF
      SPCEMFL = 8.0D-6*MARR*MWRD*MFL
C
C     SUMMARISE TOTALS BY OVERLAP TYPE
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,24) 'Total','Λ_max','Terms','Length','#',
     &                                              'Words','Size (MB)'
      WRITE(7,24) 'Total','Λ_max','Terms','Length','#',
     &                                              'Words','Size (MB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'E0LL',LAMMX  ,NTUVT(1),NTRMT(1), 4,NWRDT(1),SPCET(1)
      WRITE(7,23) 'E0LL',LAMMX  ,NTUVT(1),NTRMT(1), 4,NWRDT(1),SPCET(1)
      IF(HMLT.EQ.'NORL') GOTO 200
      WRITE(6,23) 'E0SS',LAMMX+2,NTUVT(2),NTRMT(2), 4,NWRDT(2),SPCET(2)
      WRITE(7,23) 'E0SS',LAMMX+2,NTUVT(2),NTRMT(2), 4,NWRDT(2),SPCET(2)
      IF(HMLT.EQ.'DHFR') GOTO 200
      WRITE(6,23) 'EILS',LAMMX+1,NTUVT(3),NTRMT(3),12,NWRDT(3),SPCET(3)
      WRITE(7,23) 'EILS',LAMMX+1,NTUVT(3),NTRMT(3),12,NWRDT(3),SPCET(3)
      IF(TREE.NE.'MBPT2') GOTO 200
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 200
      WRITE(6,23) 'EISL',LAMMX+1,NTUVT(4),NTRMT(4),12,NWRDT(4),SPCET(4)
      WRITE(7,23) 'EISL',LAMMX+1,NTUVT(4),NTRMT(4),12,NWRDT(4),SPCET(4)
200   CONTINUE
C      
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,25) '       ',NWRDNET,SPCENET
      WRITE(7,25) '       ',NWRDNET,SPCENET
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'parameters.h',MFL,MWRD,MWRD*MFL,SPCEMFL
      WRITE(7,22) 'parameters.h',MFL,MWRD,MWRD*MFL,SPCEMFL
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     OPTION WHEN NUMBER OF WORDS EXCEEDS ALLOCATED SIZE LIMIT
      IF(NTRMT(1).GT.MFL) THEN
        WRITE(6, *) 'In EQSAVE: E0LL words exceed allocated limit.'
        WRITE(7, *) 'In EQSAVE: E0LL words exceed allocated limit.'
        GOTO 150
      ENDIF
C
      IF(HMLT.NE.'NORL') THEN
        IF(NTRMT(2).GT.MFL) THEN
          WRITE(6, *) 'In EQSAVE: E0SS words exceed allocated limit.'
          WRITE(7, *) 'In EQSAVE: E0SS words exceed allocated limit.'
          GOTO 150
        ENDIF
      ENDIF
C     NO NEED TO ASK ABOUT EILS OR EISL! E0SS IS LARGER THAN EITHER.
C
C     SIZE LIMITS ARE ALL OK -- SKIP TO BATCH GENERATION
      GOTO 250
C
C     ONE OF THE CLASSES EXCEEDS WORD LIMIT
150   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     HAVE TO GENERATE E COEFFICIENTS BY BATCH
      WRITE(6, *) 'In EQSAVE: Eq-coefficients to be generated by batch.'
      WRITE(7, *) 'In EQSAVE: Eq-coefficients to be generated by batch.'
C
C     FLIP THE EQ-GENERATION TOGGLE AND EXIT
      EQFILE = .FALSE.
      GOTO 300
C
250   CONTINUE
C
C**********************************************************************C
C     GENERATE COMPLETE BATCHES OF EQ-COEFFS                           C
C**********************************************************************C
C
C     SECTION TITLE
      WRITE(6, *) REPEAT(' ',18),'Generating Eq-coefficient data files'
      WRITE(7, *) REPEAT(' ',18),'Generating Eq-coefficient data files'
C
C     E0LL COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL E0LLGN
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 300
C
C     E0SS COEFFICIENTS
      CALL E0SSGN
      CALL CPU_TIME(TDM3)
      TESS = TELL+TDM3-TDM2
C
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 300
C
C     EILS COEFFICIENTS
      CALL EILSGN
      CALL CPU_TIME(TDM4)
      TELS = TELS+TDM4-TDM3
C
      IF(TREE.NE.'MBPT2') GOTO 300
C
C     EISL COEFFICIENTS
      CALL EISLGN
      CALL CPU_TIME(TDM5)
      TESL = TESL+TDM5-TDM4
C
300   CONTINUE
C
C     END OF SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE E0LLGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE 000000  LL       LL       GGGGGG  NN    NN          C
C         EE      00   000 LL       LL      GG    GG NNN   NN          C
C         EE      00  0000 LL       LL      GG       NNNN  NN          C
C         EEEEEE  00 00 00 LL       LL      GG       NN NN NN          C
C         EE      0000  00 LL       LL      GG   GGG NN  NNNN          C
C         EE      000   00 LL       LL      GG    GG NN   NNN          C
C         EEEEEEEE 000000  LLLLLLLL LLLLLLLL GGGGGG  NN    NN          C
C                                                                      C
C -------------------------------------------------------------------- C
C  E0LLGN GENERATES A FULL SET OF E0LL COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY E0LL, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)
      NTUVLL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ELL0(AB) COEFFICIENTS
      CALL EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ELL0(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLL
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0LLFL(IAD+M,1) = DREAL(E11(M,ITUV))
          E0LLFL(IAD+M,2) = DIMAG(E11(M,ITUV))
          E0LLFL(IAD+M,3) = DREAL(E21(M,ITUV))
          E0LLFL(IAD+M,4) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLL*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE E0SSGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE 000000   SSSSSS   SSSSSS   GGGGGG  NN    NN         C
C         EE      00   000 SS    SS SS    SS GG    GG NNN   NN         C
C         EE      00  0000 SS       SS       GG       NNNN  NN         C
C         EEEEEE  00 00 00  SSSSSS   SSSSSS  GG       NN NN NN         C
C         EE      0000  00       SS       SS GG   GGG NN  NNNN         C
C         EE      000   00 SS    SS SS    SS GG    GG NN   NNN         C
C         EEEEEEEE 000000   SSSSSS   SSSSSS   GGGGGG  NN    NN         C
C                                                                      C
C -------------------------------------------------------------------- C
C  E0SSGN GENERATES A FULL SET OF E0SS COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY E0SS, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ESS0(AB) COEFFICIENTS
      CALL EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ESS0(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVSS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0SSFL(IAD+M,1) = DREAL(E11(M,ITUV))
          E0SSFL(IAD+M,2) = DIMAG(E11(M,ITUV))
          E0SSFL(IAD+M,3) = DREAL(E21(M,ITUV))
          E0SSFL(IAD+M,4) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVSS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EILSGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII LL       SSSSSS   GGGGGG  NN    NN           C
C           EE        II  LL      SS    SS GG    GG NNN   NN           C
C           EE        II  LL      SS       GG       NNNN  NN           C
C           EEEEEE    II  LL       SSSSSS  GG       NN NN NN           C
C           EE        II  LL            SS GG   GGG NN  NNNN           C
C           EE        II  LL      SS    SS GG    GG NN   NNN           C
C           EEEEEEEE IIII LLLLLLLL SSSSSS   GGGGGG  NN    NN           C
C                                                                      C
C -------------------------------------------------------------------- C
C  EILSGN GENERATES A FULL SET OF EILS COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY EILS, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+1
      NTUVLS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IADILS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE EILS(AB) COEFFICIENTS
      CALL EQLSMK(E11X,E21X,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQLSMK(E11Y,E21Y,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQLSMK(E11Z,E21Z,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
C
C     WRITE EILS(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          EILSFL(IAD+M, 1) = DREAL(E11X(M,ITUV))
          EILSFL(IAD+M, 2) = DIMAG(E11X(M,ITUV))
          EILSFL(IAD+M, 3) = DREAL(E21X(M,ITUV))
          EILSFL(IAD+M, 4) = DIMAG(E21X(M,ITUV))
          EILSFL(IAD+M, 5) = DREAL(E11Y(M,ITUV))
          EILSFL(IAD+M, 6) = DIMAG(E11Y(M,ITUV))
          EILSFL(IAD+M, 7) = DREAL(E21Y(M,ITUV))
          EILSFL(IAD+M, 8) = DIMAG(E21Y(M,ITUV))
          EILSFL(IAD+M, 9) = DREAL(E11Z(M,ITUV))
          EILSFL(IAD+M,10) = DIMAG(E11Z(M,ITUV))
          EILSFL(IAD+M,11) = DREAL(E21Z(M,ITUV))
          EILSFL(IAD+M,12) = DIMAG(E21Z(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EISLGN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII  SSSSSS  LL       GGGGGG  NN    NN           C
C           EE        II  SS    SS LL      GG    GG NNN   NN           C
C           EE        II  SS       LL      GG       NNNN  NN           C
C           EEEEEE    II   SSSSSS  LL      GG       NN NN NN           C
C           EE        II        SS LL      GG   GGG NN  NNNN           C
C           EE        II  SS    SS LL      GG    GG NN   NNN           C
C           EEEEEEEE IIII  SSSSSS  LLLLLLLL GGGGGG  NN    NN           C
C                                                                      C
C -------------------------------------------------------------------- C
C  EISLGN GENERATES A FULL SET OF EISL COEFFICIENTS AND SAVES TO A     C
C  COMMON ARRAY EISL, INCLUDING AN ADDRESS INDEX.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+1
      NTUVSL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IADISL(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE EISL(AB) COEFFICIENTS
      CALL EQSLMK(E11X,E21X,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EQSLMK(E11Y,E21Y,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EQSLMK(E11Z,E21Z,EXL,XYZ,KQN,MQN,NBAS,+1,1,2,3)
C
C     WRITE EISL(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVSL
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          EISLFL(IAD+M, 1) = DREAL(E11X(M,ITUV))
          EISLFL(IAD+M, 2) = DIMAG(E11X(M,ITUV))
          EISLFL(IAD+M, 3) = DREAL(E21X(M,ITUV))
          EISLFL(IAD+M, 4) = DIMAG(E21X(M,ITUV))
          EISLFL(IAD+M, 5) = DREAL(E11Y(M,ITUV))
          EISLFL(IAD+M, 6) = DIMAG(E11Y(M,ITUV))
          EISLFL(IAD+M, 7) = DREAL(E21Y(M,ITUV))
          EISLFL(IAD+M, 8) = DIMAG(E21Y(M,ITUV))
          EISLFL(IAD+M, 9) = DREAL(E11Z(M,ITUV))
          EISLFL(IAD+M,10) = DIMAG(E11Z(M,ITUV))
          EISLFL(IAD+M,11) = DREAL(E21Z(M,ITUV))
          EISLFL(IAD+M,12) = DIMAG(E21Z(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVSL*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EQLLMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    LL       LL       MM       MM KK    KK      C
C      EE       QQ    QQ   LL       LL       MMM     MMM KK   KK       C
C      EE      QQ      QQ  LL       LL       MMMM   MMMM KK  KK        C
C      EEEEEE  QQ      QQ  LL       LL       MM MM MM MM KKKKK         C
C      EE      QQ      QQ  LL       LL       MM  MMM  MM KK  KK        C
C      EE       QQ    QQ   LL       LL       MM   M   MM KK   KK       C
C      EEEEEEEE  QQQQQQ QQ LLLLLLLL LLLLLLLL MM       MM KK    KK      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLLMK GENERATES A BACTCH OF EQLL COEFFICIENTS FOR BASIS FUNCTION   C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,4),XY2(3,4),KQ2(4),MQ2(4),NB2(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLL  = LA+LB
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLL BY PHASE TERM IF EQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLL BY PHASE TERM IF EQLL ARE NEEDED
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EQSSMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    SSSSSS   SSSSSS  MM       MM KK    KK       C
C      EE       QQ    QQ  SS    SS SS    SS MMM     MMM KK   KK        C
C      EE      QQ      QQ SS       SS       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  SSSSSS   SSSSSS  MM MM MM MM KKKKK          C
C      EE      QQ      QQ       SS       SS MM  MMM  MM KK  KK         C
C      EE       QQ    QQ  SS    SS SS    SS MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ SSSSSS   SSSSSS  MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSSMK GENERATES A BACTCH OF EQLL COEFFICIENTS FOR BASIS FUNCTION   C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+2 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSS  = LA+LB+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSS BY PHASE TERM IF EQSS ARE NEEDED
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSS BY PHASE TERM IF EQSS ARE NEEDED
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY SIMPLE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EQLSMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    LL       SSSSSS  MM       MM KK    KK       C
C      EE       QQ    QQ   LL      SS    SS MMM     MMM KK   KK        C
C      EE      QQ      QQ  LL      SS       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  LL       SSSSSS  MM MM MM MM KKKKK          C
C      EE      QQ      QQ  LL            SS MM  MMM  MM KK  KK         C
C      EE       QQ    QQ   LL      SS    SS MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS  MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLSMK GENERATES A BACTCH OF EQLL COEFFICIENTS FOR BASIS FUNCTION   C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+1
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EQSLMK(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE  QQQQQQ    SSSSSS  LL       MM       MM KK    KK       C
C      EE       QQ    QQ  SS    SS LL       MMM     MMM KK   KK        C
C      EE      QQ      QQ SS       LL       MMMM   MMMM KK  KK         C
C      EEEEEE  QQ      QQ  SSSSSS  LL       MM MM MM MM KKKKK          C
C      EE      QQ      QQ       SS LL       MM  MMM  MM KK  KK         C
C      EE       QQ    QQ  SS    SS LL       MM   M   MM KK   KK        C
C      EEEEEEEE  QQQQQQ QQ SSSSSS  LLLLLLLL MM       MM KK    KK       C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSLMK GENERATES A BACTCH OF EQLL COEFFICIENTS FOR BASIS FUNCTION   C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - BASIS INDICES TO CONSTRUCT EQ-BLOCK FROM.               C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSL  = LA+LB+1
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E11,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E21,EX2,XY2,KQ2,MQ2,NB2,IQ)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EILSB3(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           EEEEEEEE IIII LL       SSSSSS  BBBBBBB   333333            C
C           EE        II  LL      SS    SS BB    BB 33    33           C
C           EE        II  LL      SS       BB    BB       33           C
C           EEEEEE    II  LL       SSSSSS  BBBBBBB    33333            C
C           EE        II  LL            SS BB    BB       33           C
C           EE        II  LL      SS    SS BB    BB 33    33           C
C           EEEEEEEE IIII LLLLLLLL SSSSSS  BBBBBBB   333333            C
C                                                                      C
C -------------------------------------------------------------------- C
C  EILSB3 GENERATES A BACTCH OF EQLL COEFFICIENTS FOR BASIS FUNCTION   C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C  THIS ACTUALLY MAKES A VECTOR LIST OF EQLS NEEDED FOR BREIT.         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     &           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+1
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E11X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQLS(E11Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQLS(E11Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV,1) = PHS*E11X(M,ITUV)
          E11(M,ITUV,2) = PHS*E11Y(M,ITUV)
          E11(M,ITUV,3) = PHS*E11Z(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)

C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E21X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQLS(E21Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQLS(E21Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQLS BY PHASE TERM IF EQLS ARE NEEDED
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV,1) = PHS*E21X(M,ITUV)
          E21(M,ITUV,2) = PHS*E21Y(M,ITUV)
          E21(M,ITUV,3) = PHS*E21Z(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EISLB3(E11,E21,EXL,XYZ,KQN,MQN,NBS,IPHS,IA1,IA2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          EEEEEEEE IIII  SSSSSS  LL       BBBBBBB   333333            C
C          EE        II  SS    SS LL       BB    BB 33    33           C
C          EE        II  SS       LL       BB    BB       33           C
C          EEEEEE    II   SSSSSS  LL       BBBBBBB    33333            C
C          EE        II        SS LL       BB    BB       33           C
C          EE        II  SS    SS LL       BB    BB 33    33           C
C          EEEEEEEE IIII  SSSSSS  LLLLLLLL BBBBBBB   333333            C
C                                                                      C
C -------------------------------------------------------------------- C
C  EISLB3 GENERATES A BACTCH OF EQLL COEFFICIENTS FOR BASIS FUNCTION   C
C  OVERLAPS, WITH A FINITE EXPANSION OF LENGTH Λ = (λ+1)(λ+2)(λ+3)/6   C
C  WHERE Λ = LA+LB+1 -- THIS USES THE ALGORITHM OF V.R. SAUNDERS.      C
C  THIS ACTUALLY MAKES A VECTOR LIST OF EQSL NEEDED FOR BREIT (MBPT).  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL     - FULL LIST OF BASIS SET PARAMETERS.                      C
C  ▶ XYZ     - FULL LIST OF BASIS FUNCTION CARTESIAN CENTRES.          C
C  ▶ KQN     - FULL LIST OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.      C
C  ▶ MQN     - FULL LIST OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.   C
C  ▶ NBS     - FULL LIST OF BASIS FUNCTION BLOCK LENGTHS.              C
C  ▶ IPHS    - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IA1/IA2 - EQ-COEFFICIENT PHASE (NON-TRIVIAL FOR COULOMB/BREIT).   C
C  ▶ IQ      - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.         C
C  OUTPUT:                                                             C
C  ▶ E11     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (-|MA|,-|MB|)      C
C  ▶ E21     - UNIQUE EQ-COEFFICIENTS FOR MQN PAIRS (+|MA|,-|MB|)      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBS(4)
      DIMENSION EX2(MBS,2),XY2(3,2),KQ2(2),MQ2(2),NB2(2)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
      COMPLEX*16 E11X(MB2,MEQ),E11Y(MB2,MEQ),E11Z(MB2,MEQ),
     ^           E21X(MB2,MEQ),E21Y(MB2,MEQ),E21Z(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        XY2(IX,1) = XYZ(IX,IA1)
        XY2(IX,2) = XYZ(IX,IA2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KQ2(1) = KQN(IA1)
      KQ2(2) = KQN(IA2)
C
C     CALCULATE LQN VALUES
      IF(KQ2(1).LT.0) THEN
        LA =-KQ2(1)-1
      ELSE
        LA = KQ2(1)
      ENDIF
      IF(KQ2(2).LT.0) THEN
        LB =-KQ2(2)-1
      ELSE
        LB = KQ2(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NB2(1) = NBS(IA1)
      DO IBAS=1,NB2(1)
        EX2(IBAS,1) = EXL(IBAS,IA1)
      ENDDO
C
      NB2(2) = NBS(IA2)
      DO JBAS=1,NB2(2)
        EX2(JBAS,2) = EXL(JBAS,IA2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSL  = LA+LB+1
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR MQN PAIRS (-|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) =-MQN(IA1)
      MQ2(2) =-MQN(IA2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E11X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQSL(E11Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQSL(E11Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E11(M,ITUV,1) = PHS*E11X(M,ITUV)
          E11(M,ITUV,2) = PHS*E11Y(M,ITUV)
          E11(M,ITUV,3) = PHS*E11Z(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR MQN PAIRS (+|MA|,-|MB|)           C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MQ2(1) = MQN(IA1)
      MQ2(2) =-MQN(IA2)

C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E21X,EX2,XY2,KQ2,MQ2,NB2,1)
      CALL EQSL(E21Y,EX2,XY2,KQ2,MQ2,NB2,2)
      CALL EQSL(E21Z,EX2,XY2,KQ2,MQ2,NB2,3)
C                                    ~
C     MULTIPLY EQSL BY PHASE TERM IF EQSL ARE NEEDED
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(ILAM(ITUV)))
        DO M=1,NB2(1)*NB2(2)
          E21(M,ITUV,1) = PHS*E21X(M,ITUV)
          E21(M,ITUV,2) = PHS*E21Y(M,ITUV)
          E21(M,ITUV,3) = PHS*E21Z(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ELSQ FROM ESLQ.
C
      RETURN
      END
C
C
      SUBROUTINE EQLL(ELL,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                EEEEEEEE  QQQQQQ    LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EEEEEE  QQ      QQ  LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EEEEEEEE  QQQQQQ QQ LLLLLLLL LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLL GENERATES A BLOCK OF RAW EQLL-COEFFICIENTS FOR A PARTICULAR    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQLLMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL - PAIR OF BASIS SET PARAMETER LISTS.                          C
C  ▶ XYZ - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                   C
C  ▶ KQN - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.               C
C  ▶ MQN - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.            C
C  ▶ NBS - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                       C
C  ▶ IQ  - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.             C
C  OUTPUT:                                                             C
C  ▶ ELL - RAW EQLL-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).            C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RN(MBS,2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELL(MB2,MEQ),ESG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO ITUV=1,MEQ
        DO M=1,MB2
          ELL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     BASIS FUNCTION OVERLAP LIST LENGTH
      MAXM = NBS(1)*NBS(2)
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: ALL KQN(1) AND KQN(2) TYPES.                             C
C**********************************************************************C
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELL0 AND ELLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELL0 OR ELLZ: UPPER-UPPER
          DO ITUV=1,NTUV0
            DO M=1,MAXM
              ELL(M,ITUV) = ELL(M,ITUV) +    CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELL0 OR ELLZ: LOWER-LOWER
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELLX AND ELLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELLX OR ELLY: UPPER-LOWER
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELLX OR ELLY: LOWER-UPPER
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) +    CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM0  = LQLAB(1)+LQLAB(2)
      NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C     GENERATE RNLL NORMALISATION CONSTANTS
      CALL RNLL(RN,EXL,LQN,NBS)
C
C     NORMALISE THE ELLQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M   = M+1
          RLL = RN(IBAS,1)*RN(JBAS,2)
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = RLL*ELL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ELLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = CONE*ELL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQSS(ESS,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS   SSSSSS                  C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EE      QQ      QQ SS       SS                       C
C                 EEEEEE  QQ      QQ  SSSSSS   SSSSSS                  C
C                 EE      QQ      QQ       SS       SS                 C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS   SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSS GENERATES A BLOCK OF RAW EQSS-COEFFICIENTS FOR A PARTICULAR    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQSSMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL - PAIR OF BASIS SET PARAMETER LISTS.                          C
C  ▶ XYZ - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                   C
C  ▶ KQN - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.               C
C  ▶ MQN - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.            C
C  ▶ NBS - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                       C
C  ▶ IQ  - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.             C
C  OUTPUT:                                                             C
C  ▶ ESS - RAW EQ-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).              C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RN(MBS,2)
      DIMENSION T22(MB2),T20(MB2),T02(MB2),T00(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      RL1 = DFLOAT(2*LQN(1)+1)
      RL2 = DFLOAT(2*LQN(2)+1)
C
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T22(M) = 4.0D0*EXL(IBAS,1)*EXL(JBAS,2)
          T20(M) =-2.0D0*RL2*EXL(IBAS,1)
          T02(M) =-2.0D0*RL1*EXL(JBAS,2)
          T00(M) = RL1*RL2
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(1).LT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF

      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +    TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).LT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +    TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
200   CONTINUE
C
C**********************************************************************C
C     CASE 3: KQN(1).GT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).GT.0) GOTO 300
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

300   CONTINUE      
C
C**********************************************************************C
C     CASE 4: KQN(1).GT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).LT.0) GOTO 400
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL STEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL STEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL STEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL STEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM4  = LQLAB(1)+LQLAB(2)+4
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
400   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     GENERATE RNSS NORMALISATION CONSTANTS
      CALL RNSS(RN,EXL,LQN,NBS)
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM4  = LQN(1)+LQN(2)+2
      NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C     NORMALISE THE ESSQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M   = M+1
          RSS = RN(IBAS,1)*RN(JBAS,2)
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = RSS*ESS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ESSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = CONE*ESS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQLS(ELS,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                EEEEEEEE  QQQQQQ    LL       SSSSSS                   C
C                EE       QQ    QQ   LL      SS    SS                  C
C                EE      QQ      QQ  LL      SS                        C
C                EEEEEE  QQ      QQ  LL       SSSSSS                   C
C                EE      QQ      QQ  LL            SS                  C
C                EE       QQ    QQ   LL      SS    SS                  C
C                EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLS GENERATES A BLOCK OF RAW EQLS-COEFFICIENTS FOR A PARTICULAR    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQLSMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL - PAIR OF BASIS SET PARAMETER LISTS.                          C
C  ▶ XYZ - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                   C
C  ▶ KQN - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.               C
C  ▶ MQN - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.            C
C  ▶ NBS - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                       C
C  ▶ IQ  - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.             C
C  OUTPUT:                                                             C
C  ▶ ELS - RAW EQ-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).              C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RN(MBS,2)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ELS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(JBAS,2)
          T0(M) = DFLOAT(2*LQN(2)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-EXL(IBAS,1)*EXL(JBAS,2)*AB2/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: UPPER-UPPER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: LOWER-LOWER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: UPPER-LOWER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: LOWER-UPPER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(2).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)
      LQLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: UPPER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: LOWER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: UPPER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: LOWER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+1
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNLS NORMALISATION CONSTANTS
      CALL RNLS(RN,EXL,LQN,NBS)
C
C     NORMALISE THE ELSQ COEFFICIENT BLOCK AND MULTIPLY BY FACTOR i
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M   = M+1
          RLS = RN(IBAS,1)*RN(JBAS,2)
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = RLS*CONE*ELS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ELSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = CONE*ELS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQSL(ESL,EXL,XYZ,KQN,MQN,NBS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS  LL                       C
C                 EE       QQ    QQ  SS    SS LL                       C
C                 EE      QQ      QQ SS       LL                       C
C                 EEEEEE  QQ      QQ  SSSSSS  LL                       C
C                 EE      QQ      QQ       SS LL                       C
C                 EE       QQ    QQ  SS    SS LL                       C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS  LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSL GENERATES A BLOCK OF RAW EQSL-COEFFICIENTS FOR A PARTICULAR    C
C  COMBINATION OF MQNS (WITH SIGN), TO BE USED BY EQSLMK.              C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL - PAIR OF BASIS SET PARAMETER LISTS.                          C
C  ▶ XYZ - PAIR OF BASIS FUNCTION CARTESIAN CENTRES.                   C
C  ▶ KQN - PAIR OF BASIS FUNCTION KAPPA QUANTUM NUMBERS.               C
C  ▶ MQN - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.            C
C  ▶ NBS - PAIR OF BASIS FUNCTION BLOCK LENGTHS.                       C
C  ▶ IQ  - PAULI SIGMA COUPLING MATRIX FOR SPINOR OVERLAP.             C
C  OUTPUT:                                                             C
C  ▶ ESL - RAW EQ-COEFFICIENTS FOR THIS MQN PAIR (MA,MB).              C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION LQLAB(2),MQLAB(2)
      DIMENSION EXL(MBS,2),XYZ(3,2),KQN(2),LQN(2),JQN(2),MQN(2),NBS(2)
      DIMENSION RN(MBS,2)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESL(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CLEBSCH-GORDAN SENSITIVITY PARAMETER
      DATA SENS/1.0D-14/
C
C     SIGN MULITPLIER FOR σ COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBS(1)*NBS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(IBAS,1)
          T0(M) = DFLOAT(2*LQN(1)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRIC INFORMATION                          C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)+1
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESL0 AND ESLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: UPPER-UPPER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: LOWER-LOWER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESLX AND ESLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: UPPER-LOWER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: LOWER-UPPER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LQLAB(1) = LQN(1)-1
      LQLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESL0 AND ESLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: UPPER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: LOWER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESLX AND ESLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)-1)/2
        MQLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: UPPER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MQLAB(1) = (MQN(1)+1)/2
        MQLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LQLAB,MQLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LQLAB(1)+LQLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LQLAB(1)+LQLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: LOWER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+1
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNSL NORMALISATION CONSTANTS
      CALL RNSL(RN,EXL,LQN,NBS)
C
C     NORMALISE THE ESLQ COEFFICIENT BLOCK AND MULTIPLY BY FACTOR -i
      M = 0
      DO IBAS=1,NBS(1)
        DO JBAS=1,NBS(2)
          M   = M+1
          RSL = RN(IBAS,1)*RN(JBAS,2)
          DO ITUV=1,NTUV2
            ESL(M,ITUV) =-RSL*CONE*ESL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     σ_Y SPECIAL CASE: MULTIPLY ESLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV2
            ESL(M,ITUV) = CONE*ESL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ESGTF(ESG,LQN,MQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              EEEEEEEE SSSSSS   GGGGGG TTTTTTTT FFFFFFFF              C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EE      SS       GG         TT    FF                    C
C              EEEEEE   SSSSSS  GG         TT    FFFFFF                C
C              EE            SS GG   GGG   TT    FF                    C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EEEEEEEE SSSSSS   GGGGGG    TT    FF                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESGTF CONSTRUCTS THE EXPANSION COEFFICIENTS OF THE OVERLAP DENSITY  C
C  OF TWO SPHERICAL HARMONIC FUNCTIONS IN AN AUXILIARY HGTF BASIS.     C
C                                                                      C
C  THE OVERLAP DENSITY IS DEFINED BY Y*[L,M]Y[L',M'], WHERE Y[L,M] ARE C
C  SPHERICAL HARMONICS FOLLOWING THE CONDON-SHORTLEY PHASE CONVENTION. C
C                                                                      C
C  THE REQUIRED COEFFICIENTS ARE GENERATED BY A CALL TO VRS, WHICH IS  C
C  CONSTRUCTED ACCORDING TO THE RECURRENCE RELATIONS DEFINED BY        C
C  V.R.SAUNDERS. THE OUTPUT OF VRS IS THEN ADJUSTED TO INCLUDE THE     C
C  ANGULAR NORMALISATION CONSTANTS, AS WELL AS A PHASE FACTOR TO       C
C  CONVERT FROM THE SCHIFF TO THE CONDON-SHORTLEY PHASE CONVENTION.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LQN  - PAIR OF BASIS SET ORBITAL QUANTUM NUMBERS.                 C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ MAXM - SIZE OF THIS BLOCK.                                        C
C  OUTPUT:                                                             C
C  ▶ ESG  - EXPANSION COEFFICIENTS FOR EACH OVERLAP IN THE BLOCK.      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION FACT(MKP),LQN(2),MQN(2),MQNLAB(2)
C
      COMPLEX*16 ESG(MB2,MEQ)
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     CALCULATE THE FACTORIAL FUNCTIONS
      LMAX = MAX(LQN(1),LQN(2))
      FACT(1) = 1.0D0
      DO M=1,2*LMAX
        FACT(M+1) = FACT(M)*DFLOAT(M)
      ENDDO
C
C     VRS IS CALLED WITH THE SIGN OF MQN(1) REVERSED
C     TO AFFECT COMPLEX CONJUGATION, ALONG WITH THE REQUISITE
C     PHASE, WHICH IS CALCULATED LATER.
      MQNLAB(1) =-MQN(1)
      MQNLAB(2) = MQN(2)
C
C     TRAP CASES FOR WHICH |MQN| EXCEEDS LQN (COULD BE CALLED BUT
C     WITH A ZERO MULTIPLICATIVE CONSTANT)
      IF(IABS(MQN(1)).GT.LQN(1).OR.IABS(MQN(2)).GT.LQN(2)) THEN
        LAM  = LQN(1)+LQN(2)
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
        DO ITUV=1,NTUV
          DO M=1,MAXM
            ESG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
        RETURN
      ELSE
        CALL VRS(ESG,LQN,MQNLAB,MAXM)
      ENDIF
C
C     IMPORT L AND BASIS PAIR MQNS
      L1 = LQN(1)
      L2 = LQN(2)
      M1 = IABS(MQN(1))
      M2 = IABS(MQN(2))
C
C     SPECIFY THE UPPER TERMINAL ON SUMMATION, AND CG COEFFICIENTS
      LAM    = LQN(1)+LQN(2)
      PREFAC = DFLOAT((2*L1+1)*(2*L2+1))
      PREFAC = PREFAC*FACT(L1-M1+1)/FACT(L1+M1+1)
      PREFAC = PREFAC*FACT(L2-M2+1)/FACT(L2+M2+1)
      PREFAC = DSQRT(PREFAC)
C     PHASE  = (-1.0D0)**(M1+M2+MQN(2))
      PHASE  = (-1.0D0)**((MQN(1)+MQN(2)+M1+M2)/2)
      PREFAC = 0.25D0*PREFAC*PHASE/PI
C
C     THERE ARE NTUV TOTAL TERMS IN THE SUM OVER A,B,C
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ESG(M,ITUV) = PREFAC*ESG(M,ITUV)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE VRS(ESG,LQN,MQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                      VV    VV RRRRRRR   SSSSSS                       C
C                      VV    VV RR    RR SS    SS                      C
C                      VV    VV RR    RR SS                            C
C                      VV    VV RR    RR  SSSSSS                       C
C                       VV  VV  RRRRRRR        SS                      C
C                        VVVV   RR    RR SS    SS                      C
C                         VV    RR    RR  SSSSSS                       C
C                                                                      C
C -------------------------------------------------------------------- C
C  VRS EVALUATES THE EXPANSION COEFFICIENTS OF THE OVERLAP CHARGE      C
C  DENSITY OF SGTFS IN AN AUXILIARY HGTF. COEFFICIENTS ARE EVALUATED   C
C  USING THE RECURRENCE RELATIONS DEFINED BY VIC SAUNDERS IN:          C
C                                                                      C
C  V.R.SAUNDERS,"MOLECULAR INTEGRALS FOR GAUSSIAN-TYPE FUNCTIONS",     C
C  METHODS OF COMPUTATIONAL MOLECULAR PHYSICS, ED G.H.F.DIERCKSEN AND  C
C  S.WILSON, pp 1-26, REIDEL PUBLISHING, DORDRECHT (1983).             C
C                                                                      C
C  THE EQ-COEFFS IN THIS PROCEDURE ARE FOR AN UN-NORMALISED SGTF.      C
C  THE COEFFICIENTS ARE DETERMINED ACCORDING TO THE SAME RULES AS      C
C  DEFINED IN THE ABOVE ARTICLE. CONSEQUENTLY, IT SHOULD BE NOTED THAT C
C  THE COEFFICIENTS ARE THOSE OF SPHERICAL HARMONIC FUNCTIONS THAT ARE C
C   ▶ UN-NORMALISED                                                    C
C   ▶ SATISFY THE SCHIFF PHASE CONVENTION.                             C
C                                                                      C
C  THE OUTLINE FOR THE GENERATION OF EQ-COEFFICIENTS IS TAKEN FROM p16 C
C  OF THE ABOVE ARTICLE. EQUATION NUMBERS ARE GIVEN IN COMMENTS.       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LQN  - PAIR OF BASIS SET ORBITAL QUANTUM NUMBERS.                 C
C  ▶ MQN  - PAIR OF BASIS FUNCTION MAGNETIC QUANTUM NUMBERS.           C
C  ▶ MAXM - SIZE OF THIS BLOCK.                                        C
C  OUTPUT:                                                             C
C  ▶ ESG  - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION NBAS(2),LQN(2),MQN(2)
C
      COMPLEX*16 ESG(MB2,MEQ),ETEMP(MB2*MRC)
C
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     IMPORT LQN AND BASIS PAIR MQNS FOR LOCAL USE
      LQNA = LQN(1)
      LQNB = LQN(2)
      MQNA = MQN(1)
      MQNB = MQN(2)
      LMAX = LQNA+LQNB
C
C     CHECK THAT LMAX IS WITHIN THE BOUNDS OF MKP
      IF(LMAX.GT.MKP+1) THEN
        WRITE(6,20) LMAX,MKP+1
        WRITE(7,20) LMAX,MKP+1
        STOP
      ENDIF
20    FORMAT(2X,'Required value of LAMBDA = ',I3/
     &       2X,'Maximum allowed value of LAMBDA = ',I3//
     &       2X,'Reset MKP and recompile: terminating...'/)
C
C      SET INITIAL VALUES TO E[0,0;0,0;0,0,0,0] = RKAB
       DO M=1,MB2*MRC
         ETEMP(M) = DCMPLX(0.0D0,0.0D0)
       ENDDO
C
       DO M=1,MAXM
         ETEMP(M) = DCMPLX(RKAB(M),0.0D0)
       ENDDO
C
C      STEP 1:
C      GENERATE E[|MQNA|,MQNA;0,0] FROM E[0,0;0,0] USING
C      SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE A
       ISTART = 0
       LAM    = 0
       IF(IABS(MQNA).NE.0) THEN
         CALL STEPLM(ETEMP,LAM,ISTART,MQNA,MAXM,1)
       ENDIF
C
C      STEP 2:
C      GENERATE E[LQNA,MQNA;0,0] FROM E[|MQNA|,MQNA;0,0]
C      USING THE STEP OF LQN ONLY ON CENTRE A
       IF(LQNA.GT.IABS(MQNA)) THEN
         CALL STEPL(ETEMP,LAM,ISTART,LQNA,MQNA,MAXM,1)
       ENDIF
C
C      STEP 3:
C      GENERATE E[LQNA,MQNA;|MQNB|,MQNB] FROM E[LQNA,MQNA;0,0]
C      USING SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE B
       IF(IABS(MQNB).GT.0) THEN
         CALL STEPLM(ETEMP,LAM,ISTART,MQNB,MAXM,2)
       ENDIF
C
C      STEP 4:
C      GENERATE E[LQNA,MQNA;LQNB,MQNB] FROM E[LQNA,MQNA;|MQNB|,MQNB]
C      USING THE STEP OF LQN ONLY ON CENTRE B
       IF(LQNB.GT.IABS(MQNB)) THEN
         CALL STEPL(ETEMP,LAM,ISTART,LQNB,MQNB,MAXM,2)
       ENDIF
C
C      STEP 5:
C      COPY FINAL BLOCK OF ENTRIES AS THE REQUIRED OUTPUT
       ISTART0 = ISTART
       NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
C
       K = 0
       DO ITUV=1,NTUV
         DO M=1,MAXM
           K = K+1
           ESG(M,ITUV) = ETEMP(ISTART0+K)
         ENDDO
       ENDDO
C
       RETURN
       END
C
C
      SUBROUTINE STEPLM(ETEMP,LAM,ISTART,MQN,MAXM,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL       MM       MM        C
C       SS    SS   TT    EE       PP    PP LL       MMM     MMM        C
C       SS         TT    EE       PP    PP LL       MMMM   MMMM        C
C        SSSSSS    TT    EEEEEE   PP    PP LL       MM MM MM MM        C
C             SS   TT    EE       PPPPPPP  LL       MM  MMM  MM        C
C       SS    SS   TT    EE       PP       LL       MM   M   MM        C
C        SSSSSS    TT    EEEEEEEE PP       LLLLLLLL MM       MM        C
C                                                                      C
C -------------------------------------------------------------------- C
C   SIMULTANEOUSLY INCREMENT UP/DOWN THE QUANTUM NUMBERS (LQN,MQN):    C
C               E[L, L;IT,IU,IV] -> E[L+1,L+1;IT,IU,IV]                C
C               E[L,-L;IT,IU,IV] -> E[L+1,L-1;IT,IU,IV]                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LAM    - LENGTH OF THE INPUT HGTF EXPANSION.                      C
C  ▶ ISTART - COUNTER TO TRACK THE START OF THIS PORTION OF THE LIST.  C
C  ▶ MQN    - MAGNETIC QUANTUM NUMBER.                                 C
C  ▶ MAXM   - NUMBER OF EXPONENT/DENSITY PAIRS.                        C
C  ▶ IZ     - CENTRE TO STEP UP.                                       C
C  OUTPUT:                                                             C
C  ▶  ETEMP - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PX(MB2),PY(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(*)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PX(M) = PAX(M)
          PY(M) = PAY(M)
        ELSEIF(IZ.EQ.2) THEN
          PX(M) = PBX(M)
          PY(M) = PBY(M)
        ENDIF
      ENDDO
C
C     MAIN LOOP: FOR EACH M-QUANTUM NUMBER ON THIS CENTRE
      DO MVAL=0,IABS(MQN)-1
C
C**********************************************************************C
C       COMPUTE THE BLOCK INDICES. THE RECURRENCE WILL RUN OVER        C
C       (LAM+1)*(LAM+2)*(LAM+3)/6 VALUES AND WILL GENERATE             C
C       (LAM+2)*(LAM+3)*(LAM+4)/6 VALUES IN THE NEXT LAYER             C
C**********************************************************************C
C
        RL1     = DFLOAT(2*IABS(MVAL)+1)
        NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
        ISTART1 = ISTART
        ISTART2 = ISTART1 + NTUV*MAXM
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C       I0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                               C
C       I1-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                               C
C       I2-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                               C
C       I3-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                               C
C       I4-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                               C
C       I5-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                               C
C**********************************************************************C
C
C       INCREMENT THE M-QUANTUM NUMBER IF MQN > 0
        IF(MQN.GT.0) THEN
C
C         LOOP OVER THE HGTF INDICES OF THE SEED LAYER
          DO IOUTER=0,LAM
            DO IT=0,IOUTER
              DO IU=0,IOUTER-IT
                IV = IOUTER-IT-IU
                I0 = ISTART1 + (IABC(IT  ,IU  ,IV)-1)*MAXM
                I1 = ISTART2 + (IABC(IT  ,IU  ,IV)-1)*MAXM
                I2 = ISTART2 + (IABC(IT+1,IU  ,IV)-1)*MAXM
                I3 = ISTART2 + (IABC(IT  ,IU+1,IV)-1)*MAXM
C
                DO M=1,MAXM
                   T1 = RL1/P2(M)
                   TX = RL1*PX(M)
                   TY = RL1*PY(M)
                   ETEMP(I1+M) = ETEMP(I1+M) + TX*ETEMP(I0+M)
     &                                       + TY*ETEMP(I0+M)*CONE
                   ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                   ETEMP(I3+M) = ETEMP(I3+M) + T1*ETEMP(I0+M)*CONE
                ENDDO
C
C               SPECIAL CASE EXCLUDES IT=0
                IF(IT.NE.0) THEN
                  I4 = ISTART2 + (IABC(IT-1,IU  ,IV  )-1)*MAXM
                  RT = DFLOAT(IT)
                  FACTOR = RT*RL1
                  DO M=1,MAXM
                    ETEMP(I4+M) = ETEMP(I4+M) + FACTOR*ETEMP(I0+M)
                  ENDDO
                ENDIF
C
C               SPECIAL CASE EXCLUDES IU=0
                IF(IU.NE.0) THEN
                  I5 = ISTART2 + (IABC(IT  ,IU-1,IV  )-1)*MAXM
                  RU = DFLOAT(IU)
                  FACTOR = RL1*RU
                  DO M=1,MAXM
                    ETEMP(I5+M) = ETEMP(I5+M) + FACTOR*ETEMP(I0+M)*CONE
                  ENDDO
                ENDIF
C
C             END OF LOOPS OVER HGTF INDICES
              ENDDO
            ENDDO
          ENDDO
C
C       DECREMENT THE M-QUANTUM NUMBER IF MQN < 0
        ELSE
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C         ISTART0 LABELS THE PREVIOUS LQN VALUE                        C
C         ISTART1 LABELS THE CURRENT  LQN VALUE                        C
C         ISTART2 LABELS THE NEXT     LQN VALUE                        C
C -------------------------------------------------------------------- C
C         I0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                             C
C         I1-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                             C
C         I2-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                             C
C         I3-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                             C
C         I4-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                             C
C         I5-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                             C
C**********************************************************************C
C
C         LOOP OVER THE HGTF INDICES OF THE SEED LAYER
          DO IOUTER=0,LAM
            DO IT=0,IOUTER
              DO IU=0,IOUTER-IT
                IV = IOUTER-IT-IU
                I0 = ISTART1 + (IABC(IT  ,IU  ,IV)-1)*MAXM
                I1 = ISTART2 + (IABC(IT  ,IU  ,IV)-1)*MAXM
                I2 = ISTART2 + (IABC(IT+1,IU  ,IV)-1)*MAXM
                I3 = ISTART2 + (IABC(IT  ,IU+1,IV)-1)*MAXM
C
                DO M=1,MAXM
                  T1 = RL1/P2(M)
                  TX = RL1*PX(M)
                  TY = RL1*PY(M)
                  ETEMP(I1+M) = ETEMP(I1+M) + TX*ETEMP(I0+M)
     &                                      - TY*ETEMP(I0+M)*CONE
                  ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                  ETEMP(I3+M) = ETEMP(I3+M) - T1*ETEMP(I0+M)*CONE
                ENDDO
C
C               SPECIAL CASE EXCLUDES IT=0
                IF(IT.NE.0) THEN
                  I4 = ISTART2 + (IABC(IT-1,IU  ,IV  )-1)*MAXM
                  RT = DFLOAT(IT)
                  FACTOR = RT*RL1
                  DO M=1,MAXM
                    ETEMP(I4+M) = ETEMP(I4+M) + FACTOR*ETEMP(I0+M)
                  ENDDO
                ENDIF
C
C               SPECIAL CASE EXCLUDES IU=0
                IF(IU.NE.0) THEN
                  I5 = ISTART2 + (IABC(IT  ,IU-1,IV  )-1)*MAXM
                  RU = DFLOAT(IU)
                  FACTOR = RL1*RU
                  DO M=1,MAXM
                    ETEMP(I5+M) = ETEMP(I5+M) - FACTOR*ETEMP(I0+M)*CONE
                  ENDDO
                ENDIF
C
C               END OF LOOPS OVER HGTF INDICES
              ENDDO
            ENDDO
          ENDDO
        ENDIF
C
C**********************************************************************C
C       END OF LOOP OVER MQN COUNTER. UPDATE THE VALUE OF LAM, AND     C
C       THE COUNTER THAT KEEPS TRACK OF THE BLOCKS OF EQ-COEFFICIENTS  C
C**********************************************************************C
C
        ISTART = ISTART + NTUV*MAXM
        LAM    = LAM+1
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE STEPL(ETEMP,LAM,ISTART,LQN,MQN,MAXM,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL                    C
C             SS    SS   TT    EE       PP    PP LL                    C
C             SS         TT    EE       PP    PP LL                    C
C              SSSSSS    TT    EEEEEE   PP    PP LL                    C
C                   SS   TT    EE       PPPPPPP  LL                    C
C             SS    SS   TT    EE       PP       LL                    C
C              SSSSSS    TT    EEEEEEEE PP       LLLLLLLL              C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE LQN, STARTING AT E[L, L] OR E[L,-L].                  C
C -------------------------------------------------------------------- C
C  ▶ FIRST APPLICATION OF EQ(64a) MAPS E[L, L] -> E[L+1, M]            C
C                                   OR E[L,-L] -> E[L+1,-L]            C
C  AND IS TREATED SEPARATELY. SUBSEQUENT STEPS MAP                     C
C                                     {E[L,L], E[L-1,L]} -> E[L+1,L].  C
C  ▶ FINAL APPLICATION OF THIS RULE GENERATES E[LMAX,L;0,0;T,U,V].     C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ LAM    - LENGTH OF THE INPUT HGTF EXPANSION.                      C
C  ▶ ISTART - COUNTER TO TRACK THE START OF THIS PORTION OF THE LIST.  C
C  ▶ LQN    - ORBITAL QUANTUM NUMBER.                                  C
C  ▶ MQN    - MAGNETIC QUANTUM NUMBER.                                 C
C  ▶ MAXM   - NUMBER OF EXPONENT/DENSITY PAIRS.                        C
C  ▶ IZ     - CENTRE TO STEP UP.                                       C
C  OUTPUT:                                                             C
C  ▶  ETEMP - UN-NORMALISED EXPANSION COEFFICIENTS FOR THIS BLOCK.     C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(*)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(IZ.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C**********************************************************************C
C      THE FIRST STEP IS ALWAYS PERFORMED. IT MAPS THE INDEX SETS      C
C      E[MQN+1,MQN] <- E[MQN1,MQN1] FROM THE DATA OBTAINED IN STEPLM.  C
C**********************************************************************C
C
C     IF STEPL IS ENTERED WITH LQN.LE.|MQN| CONTROL IS RETURNED
C     AND NO COUNTERS ARE UPDATED
      IF(LQN.LE.IABS(MQN)) RETURN
C
      NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
      ISTART1 = ISTART
      ISTART2 = ISTART1 + NTUV*MAXM
      RFACT1  = DFLOAT(2*IABS(MQN)+1)
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C       I0-> E[MQN  ,MQN;IT  ,IU  ,IV  ]                               C
C       I1-> E[MQN+1,MQN;IT  ,IU  ,IV  ]                               C
C       I2-> E[MQN+1,MQN;IT  ,IU  ,IV+1]                               C
C       I3-> E[MQN+1,MQN;IT  ,IU  ,IV-1]                               C
C**********************************************************************C
C
C     LOOP OVER THE HGTF INDICES OF THE SEED LAYER
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
            I0 = ISTART1 + (IABC(IT  ,IU  ,IV  )-1)*MAXM
            I1 = ISTART2 + (IABC(IT  ,IU  ,IV  )-1)*MAXM
            I2 = ISTART2 + (IABC(IT  ,IU  ,IV+1)-1)*MAXM
            DO M=1,MAXM
              TZ = RFACT1*PZ(M)
              TP = RFACT1/P2(M)
              ETEMP(I1+M) = ETEMP(I1+M) + TZ*ETEMP(I0+M)
              ETEMP(I2+M) = ETEMP(I2+M) + TP*ETEMP(I0+M)
            ENDDO
            IF(IV.GE.1) THEN
              I3 = ISTART2 + (IABC(IT  ,IU  ,IV-1)-1)*MAXM
              FACTOR = RFACT1*DFLOAT(IV)
              DO M=1,MAXM
                ETEMP(I3+M) = ETEMP(I3+M) + ETEMP(I0+M)*FACTOR
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDDO
C
C     UPDATE LAM INDEX AND BLOCK LOCATOR
      ISTART0 = ISTART
      ISTART  = ISTART + NTUV*MAXM
      LAM     = LAM+1
C
      IF(LQN.EQ.IABS(MQN)+1) RETURN
C
C**********************************************************************C
C     SECOND AND SUBSEQUENT STEPS IN THIS RECURRENCE INVOLVE THREE     C
C     LAYERS OF COEFFICIENTS:                                          C
C     E[LQN1+1,MQN1] <- {E[LQN1,MQN1],E[LQN-1,MQN1]}                   C
C**********************************************************************C
C
      DO LQN1=IABS(MQN)+1,LQN-1
        RL1M1   = DFLOAT(LQN1-IABS(MQN)+1)
        RFACT1  = DFLOAT(2*LQN1+1)/RL1M1
        NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
        ISTART1 = ISTART
        ISTART2 = ISTART + MAXM*NTUV
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C     I0-> E[LQN  ,MQN;IT  ,IU  ,IV  ]                                 C
C     I1-> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                 C
C     I2-> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                 C
C     I3-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                 C
C**********************************************************************C
C
C       THE FIRST LOOP OVER ITUV INCLUDES ALL HGTF INDICES ON THE
C       LAYER CORRESPONDING TO THE CURRENT VALUE OF LQN1
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART1 + (IABC(IT  ,IU  ,IV  )-1)*MAXM
              I1 = ISTART2 + (IABC(IT  ,IU  ,IV  )-1)*MAXM
              I2 = ISTART2 + (IABC(IT  ,IU  ,IV+1)-1)*MAXM
              DO M=1,MAXM
                TZ = RFACT1*PZ(M)
                TP = RFACT1/P2(M)
                ETEMP(I1+M) = ETEMP(I1+M) + TZ*ETEMP(I0+M)
                ETEMP(I2+M) = ETEMP(I2+M) + TP*ETEMP(I0+M)
              ENDDO
              IF(IV.GE.1) THEN
                I3 = ISTART2 + (IABC(IT  ,IU  ,IV-1)-1)*MAXM
                FACTOR = RFACT1*DFLOAT(IV)
                DO M=1,MAXM
                  ETEMP(I3+M) = ETEMP(I3+M) + ETEMP(I0+M)*FACTOR
                ENDDO
              ENDIF
            ENDDO
          ENDDO
        ENDDO
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C     I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                                C
C     I1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                                C
C     I2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                                C
C     I3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                                C
C     I4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                                C
C     I5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                                C
C     I6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                C
C     I7 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                C
C     I8 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                                C
C     I9 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                                C
C     I10-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                C
C     I11-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                                C
C     I12-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                                C
C     I13-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                                C
C**********************************************************************C
C
C       THE SECOND LOOP OVER ITUV INCLUDES ALL HGTF INDICES ON THE
C       LAYER CORRESPONDING TO (LQN1-1)
        RFACT1 =-DFLOAT(LQN1+IABS(MQN))/DBLE(LQN1-IABS(MQN)+1)
        DO IOUTER=0,LAM-1
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART0+(IABC(IT  ,IU  ,IV  )-1)*MAXM
              I1 = ISTART2+(IABC(IT+2,IU  ,IV  )-1)*MAXM
              I2 = ISTART2+(IABC(IT  ,IU+2,IV  )-1)*MAXM
              I3 = ISTART2+(IABC(IT  ,IU  ,IV+2)-1)*MAXM
              I4 = ISTART2+(IABC(IT+1,IU  ,IV  )-1)*MAXM
              I5 = ISTART2+(IABC(IT  ,IU+1,IV  )-1)*MAXM
              I6 = ISTART2+(IABC(IT  ,IU  ,IV+1)-1)*MAXM
              I7 = ISTART2+(IABC(IT  ,IU  ,IV  )-1)*MAXM
              TI = DFLOAT(2*(IT+IU+IV)+3)
              DO M=1,MAXM
                T1 = RFACT1/P22(M)
                T0 = RFACT1/P(M)
                TX = T0*PX(M)
                TY = T0*PY(M)
                TZ = T0*PZ(M)
                TT = RFACT1*(PP(M)+TI/P2(M))
                ETEMP(I1+M) = ETEMP(I1+M) + T1*ETEMP(I0+M)
                ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                ETEMP(I3+M) = ETEMP(I3+M) + T1*ETEMP(I0+M)
                ETEMP(I4+M) = ETEMP(I4+M) + TX*ETEMP(I0+M)
                ETEMP(I5+M) = ETEMP(I5+M) + TY*ETEMP(I0+M)
                ETEMP(I6+M) = ETEMP(I6+M) + TZ*ETEMP(I0+M)
                ETEMP(I7+M) = ETEMP(I7+M) + TT*ETEMP(I0+M)
              ENDDO
              IF(IT.GE.1) THEN
                I8 = ISTART2 + (IABC(IT-1,IU  ,IV  )-1)*MAXM
                T1 = RFACT1*DFLOAT(2*IT)
                DO M=1,MAXM
                  TX = T1*PX(M)
                  ETEMP(I8+M) = ETEMP(I8+M) + TX*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IU.GE.1) THEN
                I9 = ISTART2 + (IABC(IT  ,IU-1,IV  )-1)*MAXM
                T1 = RFACT1*DFLOAT(2*IU)
                DO M=1,MAXM
                  TY = T1*PY(M)
                  ETEMP(I9+M) = ETEMP(I9+M) + TY*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IV.GE.1) THEN
                I10 = ISTART2 + (IABC(IT  ,IU  ,IV-1)-1)*MAXM
                T1  = RFACT1*DFLOAT(2*IV)
                DO M=1,MAXM
                  TZ = T1*PZ(M)
                  ETEMP(I10+M) = ETEMP(I10+M) + TZ*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IT.GE.2) THEN
                I11 = ISTART2 + (IABC(IT-2,IU  ,IV  )-1)*MAXM
                T1  = RFACT1*DFLOAT(IT*(IT-1))
                DO M=1,MAXM
                  ETEMP(I11+M) = ETEMP(I11+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IU.GE.2) THEN
                I12 = ISTART2 + (IABC(IT  ,IU-2,IV  )-1)*MAXM
                T1  = RFACT1*DFLOAT(IU*(IU-1))
                DO M=1,MAXM
                  ETEMP(I12+M) = ETEMP(I12+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IV.GE.2) THEN
                I13 = ISTART2 + (IABC(IT  ,IU  ,IV-2)-1)*MAXM
                T1  = RFACT1*DFLOAT(IV*(IV-1))
                DO M=1,MAXM
                  ETEMP(I13+M) = ETEMP(I13+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
        ENDDO
C
C       END OF LOOP OVER LQN1 FOR FIXED MQN
C
        LAM     = LAM+1
        ISTART0 = ISTART
        ISTART  = ISTART+MAXM*NTUV
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE STEPN(ESG,ENSG,LAM,MAXM,IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  NN    NN              C
C             SS    SS   TT    EE       PP    PP NNN   NN              C
C             SS         TT    EE       PP    PP NNNN  NN              C
C              SSSSSS    TT    EEEEEE   PP    PP NN NN NN              C
C                   SS   TT    EE       PPPPPPP  NN  NNNN              C
C             SS    SS   TT    EE       PP       NN   NNN              C
C              SSSSSS    TT    EEEEEEEE PP       NN    NN              C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE NQN, E[NQN,LQN,MQN] -> E[NQN+1,LQN,MQN].              C
C                                                                      C
C  ▶ STEPN WILL ONLY PERFORM A SINGLE STEP IN NQN. IT USES AS INPUT A  C
C    SET OF PROCESSED EQ-COEFFICIENTS FROM VRS (ESGTFR,ESGTFI),        C
C    AND OUTPUTS THE INCREMENTED SET (ENSGTFR,ENSGTFI).                C
C -------------------------------------------------------------------- C
C  ▶ LAM IS THE EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE INPUT COEFFS.  C
C    EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE OUTPUT COEFFS IS LAM+2.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ ESG  - EQ-COEFFICIENT BATCH.                                      C
C  ▶ LAM  - EFFECTIVE TOTAL ANGULAR MOMENTUM.                          C
C  ▶ MAXM - NUMBER OF EXPONENT/DENSITY PAIRS.                          C
C  ▶ IZ   - CENTRE TO STEP UP.                                         C
C  OUTPUT:                                                             C
C  ▶ ENSG - EQ-COEFFICIENT BATCH AFTER NQN HAS BEEN STEPPED UP.        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/ICRT/IABC(0:ML4,0:ML4,0:ML4),IA(MRC),IB(MRC),IC(MRC),
     &            ILAM(MRC)
      COMMON/MCMD/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     IMPORT GEOMETRIC VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(IZ.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(IZ.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C     SET THE TARGET COEFFICIENTS TO ZERO, TAKING INTO ACCOUNT THE
C     INCREMENT OF LAM BY TWO UNITS IN THE TARGET
      NTUV = (LAM+3)*(LAM+4)*(LAM+5)/6
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ENSG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C                          INDEX MAPPINGS                              C
C -------------------------------------------------------------------- C
C     I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                                C
C     I1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                                C
C     I2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                                C
C     I3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                                C
C     I4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                                C
C     I5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                                C
C     I6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                C
C     I7 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                C
C     I8 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                                C
C     I9 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                                C
C     I10-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                C
C     I11-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                                C
C     I12-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                                C
C     I13-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                                C
C**********************************************************************C
C
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
            I0 = IABC(IT  ,IU  ,IV  )
            I1 = IABC(IT+2,IU  ,IV  )
            I2 = IABC(IT  ,IU+2,IV  )
            I3 = IABC(IT  ,IU  ,IV+2)
            I4 = IABC(IT+1,IU  ,IV  )
            I5 = IABC(IT  ,IU+1,IV  )
            I6 = IABC(IT  ,IU  ,IV+1)
            I7 = IABC(IT  ,IU  ,IV  )
C
            TT = DFLOAT((2*(IT+IU+IV))+3)
            DO M=1,MAXM
              T0 = 1.0D0/P22(M)
              TX = PX(M)/P(M)
              TY = PY(M)/P(M)
              TZ = PZ(M)/P(M)
              TP = PP(M) + TT/P2(M)
              ENSG(M,I1) = ENSG(M,I1) + T0*ESG(M,I0)
              ENSG(M,I2) = ENSG(M,I2) + T0*ESG(M,I0)
              ENSG(M,I3) = ENSG(M,I3) + T0*ESG(M,I0)
              ENSG(M,I4) = ENSG(M,I4) + TX*ESG(M,I0)
              ENSG(M,I5) = ENSG(M,I5) + TY*ESG(M,I0)
              ENSG(M,I6) = ENSG(M,I6) + TZ*ESG(M,I0)
              ENSG(M,I7) = ENSG(M,I7) + TP*ESG(M,I0)
            ENDDO
C
            IF(IT.GE.1) THEN
              RT2 = DFLOAT(2*IT)
              I8  = IABC(IT-1,IU  ,IV  )
              DO M=1,MAXM
                T0 = PX(M)*RT2
                ENSG(M,I8) = ENSG(M,I8) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IU.GE.1) THEN
              RU2 = DFLOAT(2*IU)
              I9  = IABC(IT  ,IU-1,IV  )
              DO M=1,MAXM
                T0 = PY(M)*RU2
                ENSG(M,I9) = ENSG(M,I9) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IV.GE.1) THEN
              RV2 = DFLOAT(2*IV)
              I10 = IABC(IT  ,IU  ,IV-1)
              DO M=1,MAXM
                T0 = PZ(M)*RV2
                ENSG(M,I10) = ENSG(M,I10) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IT.GE.2) THEN
              RT2 = DFLOAT(IT*(IT-1))
              I11 = IABC(IT-2,IU  ,IV  )
              DO M=1,MAXM
                ENSG(M,I11) = ENSG(M,I11) + RT2*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IU.GE.2) THEN
              RU2 = DFLOAT(IU*(IU-1))
              I12 = IABC(IT  ,IU-2,IV  )
              DO M=1,MAXM
                ENSG(M,I12) = ENSG(M,I12) + RU2*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IV.GE.2) THEN
              RV2 = DFLOAT(IV*(IV-1))
              I13 = IABC(IT  ,IU  ,IV-2)
              DO M=1,MAXM
                ENSG(M,I13) = ENSG(M,I13) + RV2*ESG(M,I0)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNLL(RN,EXL,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN LL       LL                        C
C                 RR    RR NNN   NN LL       LL                        C
C                 RR    RR NNNN  NN LL       LL                        C
C                 RR    RR NN NN NN LL       LL                        C
C                 RRRRRRR  NN  NNNN LL       LL                        C
C                 RR    RR NN   NNN LL       LL                        C
C                 RR    RR NN    NN LLLLLLLL LLLLLLLL                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNLL GENERATES THE LARGE-LARGE SGTF NORMALISATION CONSTANTS.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ LQN  - PAIR OF ORBITAL QUANTUM NUMBERS.                           C
C  ▶ NBAS - PAIR OF PARAMETER LIST LENGTHS.                            C
C  OUTPUT:                                                             C
C  ▶ RN   - BATCH OF NORMALISATION CONSTANTS.                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RN(MBS,2),EXL(MBS,2),LQN(2),NBAS(2)
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      DO I=1,2
        T1  = PI12
        F1  = 0.5D0
        GML = DLOG(T1)
        DO N=2,LQN(I)+2
          GML = GML+DLOG(F1)
          F1  = F1 + 1.0D0
        ENDDO
        RLA = DFLOAT(LQN(I))
        GA1 = TWLG-GML
        RA1 = RLA+1.5D0
        DO IBAS=1,NBAS(I)
          ELOG       = DLOG(2.0D0*EXL(IBAS,I))
          RN(IBAS,I) = DEXP(0.5D0*(GA1+RA1*ELOG))
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNSS(RN,EXL,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN  SSSSSS   SSSSSS                   C
C                 RR    RR NNN   NN SS    SS SS    SS                  C
C                 RR    RR NNNN  NN SS       SS                        C
C                 RR    RR NN NN NN  SSSSSS   SSSSSS                   C
C                 RRRRRRR  NN  NNNN       SS       SS                  C
C                 RR    RR NN   NNN SS    SS SS    SS                  C
C                 RR    RR NN    NN  SSSSSS   SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNSS GENERATES THE SMALL-SMALL SGTF NORMALISATION CONSTANTS.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ LQN  - PAIR OF ORBITAL QUANTUM NUMBERS.                           C
C  ▶ NBAS - PAIR OF PARAMETER LIST LENGTHS.                            C
C  OUTPUT:                                                             C
C  ▶ RN - BATCH OF NORMALISATION CONSTANTS.                            C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RN(MBS,2),EXL(MBS,2),LQN(2),NBAS(2)
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      DO I=1,2
        T1  = PI12
        F1  = 0.5D0
        GML = DLOG(T1)
        DO N=2,LQN(I)+3
          GML = GML+DLOG(F1)
          F1  = F1+1.0D0
        ENDDO
        RLA = DFLOAT(LQN(I))
        GA1 = TWLG-GML
        RA1 = RLA+0.5D0
        DO IBAS=1,NBAS(I)
          ELOG       = DLOG(2.0D0*EXL(IBAS,I))
          RN(IBAS,I) = DEXP(0.5D0*(GA1+RA1*ELOG))
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNLS(RN,EXL,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN LL       SSSSSS                    C
C                 RR    RR NNN   NN LL      SS    SS                   C
C                 RR    RR NNNN  NN LL      SS                         C
C                 RR    RR NN NN NN LL       SSSSSS                    C
C                 RRRRRRR  NN  NNNN LL            SS                   C
C                 RR    RR NN   NNN LL      SS    SS                   C
C                 RR    RR NN    NN LLLLLLLL SSSSSS                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNLS GENERATES THE LARGE-SMALL SGTF NORMALISATION CONSTANTS.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ LQN  - PAIR OF ORBITAL QUANTUM NUMBERS.                           C
C  ▶ NBAS - PAIR OF PARAMETER LIST LENGTHS.                            C
C  OUTPUT:                                                             C
C  ▶ RN   - BATCH OF NORMALISATION CONSTANTS.                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RN(MBS,2),EXL(MBS,2),LQN(2),NBAS(2)
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      T1L  = PI12
      F1L  = 0.5D0
      GMLL = DLOG(T1L)
C
      DO N=2,LQN(1)+2
        GMLL = GMLL+DLOG(F1L)
        F1L  = F1L+1.0D0
      ENDDO
C
      RLAL = DFLOAT(LQN(1))
      GA1L = TWLG-GMLL
      RA1L = RLAL+1.5D0
C
      DO IBAS=1,NBAS(1)
        ELOGL      = DLOG(2.0D0*EXL(IBAS,1))
        RN(IBAS,1) = DEXP(0.5D0*(GA1L+RA1L*ELOGL))
      ENDDO
C
      T1S  = PI12
      F1S  = 0.5D0
      GMLS = DLOG(T1S)
C
      DO N=2,LQN(2)+3
        GMLS = GMLS+DLOG(F1S)
        F1S  = F1S+1.0D0
      ENDDO
C
      RLAS = DFLOAT(LQN(2))
      GA1S = TWLG-GMLS
      RA1S = RLAS+0.5D0
C
      DO JBAS=1,NBAS(2)
        ELOGS      = DLOG(2.0D0*EXL(JBAS,2))
        RN(JBAS,2) = DEXP(0.5D0*(GA1S+RA1S*ELOGS))
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNSL(RN,EXL,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN  SSSSSS  LL                        C
C                 RR    RR NNN   NN SS    SS LL                        C
C                 RR    RR NNNN  NN SS       LL                        C
C                 RR    RR NN NN NN  SSSSSS  LL                        C
C                 RRRRRRR  NN  NNNN       SS LL                        C
C                 RR    RR NN   NNN SS    SS LL                        C
C                 RR    RR NN    NN  SSSSSS  LLLLLLLL                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNSL GENERATES THE SMALL-LARGE SGTF NORMALISATION CONSTANTS.        C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ EXL  - PAIR OF BASIS SET PARAMETER LISTS.                         C
C  ▶ LQN  - PAIR OF ORBITAL QUANTUM NUMBERS.                           C
C  ▶ NBAS - PAIR OF PARAMETER LIST LENGTHS.                            C
C  OUTPUT:                                                             C
C  ▶ RN   - BATCH OF NORMALISATION CONSTANTS.                          C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION RN(MBS,2),EXL(MBS,2),LQN(2),NBAS(2)
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      T1S  = PI12
      F1S  = 0.5D0
      GMSL = DLOG(T1S)
C
      DO N=2,LQN(1)+3
        GMSL = GMSL+DLOG(F1S)
        F1S  = F1S+1.0D0
      ENDDO
C
      RLAS = DFLOAT(LQN(1))
      GA1S = TWLG-GMSL
      RA1S = RLAS+0.5D0
C
      DO IBAS=1,NBAS(1)
        ELOGS      = DLOG(2.0D0*EXL(IBAS,1))
        RN(IBAS,1) = DEXP(0.5D0*(GA1S+RA1S*ELOGS))
      ENDDO
C
      T1L  = PI12
      F1L  = 0.5D0
      GMLL = DLOG(T1L)
C
      DO N=2,LQN(2)+2
        GMLL = GMLL+DLOG(F1L)
        F1L  = F1L+1.0D0
      ENDDO
C
      RLAL = DFLOAT(LQN(2))
      GA1L = TWLG-GMLL
      RA1L = RLAL+1.5D0
C
      DO JBAS=1,NBAS(2)
        ELOGL      = DLOG(2.0D0*EXL(JBAS,2))
        RN(JBAS,2) = DEXP(0.5D0*(GA1L+RA1L*ELOGL))
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DNORM(NMAX,ECFF,ICMP,SCL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           DDDDDDD  NN    NN  OOOOOO  RRRRRRR  MM       MM            C
C           DD    DD NNN   NN OO    OO RR    RR MMM     MMM            C
C           DD    DD NNNN  NN OO    OO RR    RR MMMM   MMMM            C
C           DD    DD NN NN NN OO    OO RR    RR MM MM MM MM            C
C           DD    DD NN  NNNN OO    OO RRRRRRR  MM  MMM  MM            C
C           DD    DD NN   NNN OO    OO RR    RR MM   M   MM            C
C           DDDDDDD  NN    NN  OOOOOO  RR    RR MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DNORM CALCULATES A SCALE NORM FOR A REAL OR COMPLEX PART OF A LIST  C
C  ECFF OF LENGTH NMAX, AND STORES THE RESULT IN SCL.                  C
C**********************************************************************C
C
      DIMENSION ECMP(NMAX)
C
      COMPLEX*16 ECFF(NMAX)
C
C     IMPORT EITHER THE REAL OR COMPLEX COMPONENT FROM ECFF
      DO N=1,NMAX
        IF(ICMP.EQ.1) THEN
          ECMP(N) = DREAL(ECFF(N))
        ELSEIF(ICMP.EQ.2) THEN
          ECMP(N) = DIMAG(ECFF(N))
        ELSE
          WRITE(6, *) 'In DNORM: choose component 1 or 2.'
          WRITE(7, *) 'In DNORM: choose component 1 or 2.'
        ENDIF
      ENDDO
C
C     LOOP OVER ELEMENTS OF ECMP
      SSQ = 1.0D0
      SCL = 0.0D0
      DO N=1,NMAX
        IF(ECMP(N).NE.0.0D0) THEN
          ABN = DABS(ECMP(N))
          IF(SCL.LT.ABN) THEN
            SSQ = 1.0D0 + SSQ*(SCL/ABN)**2
          ELSE
            SSQ = SSQ   +     (ABN/SCL)**2
          ENDIF
        ENDIF
      ENDDO
      SCL = SCL*DSQRT(SSQ)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [13] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] SCHWARZ: APPROXIMATES UPPER BOUND OF BLOCK OF COULOMB INTS.    C
C   [B] SELFCLM: GENERATES ARRAY OF COULOMB SELF-OVERLAPS.             C
C   [C] SELFBRT: GENERATES ARRAY OF BREIT SELF-OVERLAPS.               C
C**********************************************************************C
C
C
      SUBROUTINE SCHWARZ(GDIR,SENS,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS   CCCCCC  HH    HH WW         WW    AA    RRRRRRR  ZZZZZZZZ C
C  SS    SS CC    CC HH    HH WW         WW   AAAA   RR    RR      ZZ  C
C  SS       CC       HH    HH WW         WW  AA  AA  RR    RR     ZZ   C
C   SSSSSS  CC       HHHHHHHH WW    W    WW AA    AA RR    RR    ZZ    C
C        SS CC       HH    HH  WW  WWW  WW  AAAAAAAA RRRRRRR    ZZ     C
C  SS    SS CC    CC HH    HH   WWWW WWWW   AA    AA RR    RR  ZZ      C
C   SSSSSS   CCCCCC  HH    HH    WW   WW    AA    AA RR    RR ZZZZZZZZ C
C                                                                      C
C -------------------------------------------------------------------- C
C  SCHWARZ APPROXIMATES THE UPPER BOUND TO A BLOCK OF TWO-ELECTRON     C
C  INTEGRALS AND ITS CONTRIBUTION TO THE GDIR/GXCH MATRIX.             C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C  ▶ GDIR - FULL ARRAY OF PAIR-WISE MATRIX ELEMENTS.                   C
C  ▶ SENS - SENSITIVITY LIMIT FOR MAXIMUM FOCK MATRIX CONTRIBUTION.    C
C  ▶ TADD - TIME TAKEN TO RUN THIS ROUTINE.                            C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      DIMENSION GDIR(MDM,MDM)
      DIMENSION R(8),D(4)
      DIMENSION NBAS(4)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/I2EL/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,MCNT,NADDAB,NADDCD,NBAS,IQL,IQR
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C     RESET SCREENING COUNTERS
      IBCH = 1
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
        DO ISYM=1,11
          IMTX(M,ISYM) = 1
        ENDDO
      ENDDO
      MAXN = NBAS(3)*NBAS(4)
C
C     IF TOGGLE SWITCHED OFF, DO NOT SCREEN
      IF(ITOG.EQ.0) GOTO 99
C
C     FIND LARGEST UPPER BOUND AND DENSITY PRODUCT FOR EACH M
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         DIRECT INTEGRALS
          R(1) = GDIR(NA1+IBAS,NB1+JBAS)
          R(2) = GDIR(NA1+IBAS,NB2+JBAS)
          R(3) = GDIR(NA2+IBAS,NB1+JBAS)
          R(4) = GDIR(NA2+IBAS,NB2+JBAS)
          R(5) = GDIR(NC1+KBAS,ND1+LBAS)
          R(6) = GDIR(NC1+KBAS,ND2+LBAS)
          R(7) = GDIR(NC2+KBAS,ND1+LBAS)
          R(8) = GDIR(NC2+KBAS,ND2+LBAS)
C
C         LARGEST OF THE DIRECT INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 1 AND IFLG = 2
          D(1) = ABS(DENT(NC1+KBAS,ND1+LBAS))
          D(2) = ABS(DENT(NC1+KBAS,ND2+LBAS))
          D(3) = ABS(DENT(NC2+KBAS,ND1+LBAS))
          D(4) = ABS(DENT(NC2+KBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 1) = 0
            IMTX(M, 2) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 3 AND IFLG = 4
          D(1) = ABS(DENT(NA1+IBAS,NB1+JBAS))
          D(2) = ABS(DENT(NA1+IBAS,NB2+JBAS))
          D(3) = ABS(DENT(NA2+IBAS,NB1+JBAS))
          D(4) = ABS(DENT(NA2+IBAS,NB2+JBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 3) = 0
            IMTX(M, 4) = 0
          ENDIF
C
C         EXCHANGE INTEGRALS (FIRST TYPE)
          R(1) = GDIR(NB1+JBAS,NC1+KBAS)
          R(2) = GDIR(NB1+JBAS,NC2+KBAS)
          R(3) = GDIR(NB2+JBAS,NC1+KBAS)
          R(4) = GDIR(NB2+JBAS,NC2+KBAS)
          R(5) = GDIR(NA1+IBAS,ND1+LBAS)
          R(6) = GDIR(NA1+IBAS,ND2+LBAS)
          R(7) = GDIR(NA2+IBAS,ND1+LBAS)
          R(8) = GDIR(NA2+IBAS,ND2+LBAS)
C
C         LARGEST OF THE EXCHANGE INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 8 AND IFLG = 9
          D(1) = ABS(DENT(NA1+IBAS,ND1+LBAS))
          D(2) = ABS(DENT(NA1+IBAS,ND2+LBAS))
          D(3) = ABS(DENT(NA2+IBAS,ND1+LBAS))
          D(4) = ABS(DENT(NA2+IBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 8) = 0
            IMTX(M, 9) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 5
          D(1) = ABS(DENT(NB1+JBAS,NC1+KBAS))
          D(2) = ABS(DENT(NB1+JBAS,NC2+KBAS))
          D(3) = ABS(DENT(NB2+JBAS,NC1+KBAS))
          D(4) = ABS(DENT(NB2+JBAS,NC2+KBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 5) = 0
          ENDIF
C
C         EXCHANGE INTEGRALS (SECOND TYPE)
          R(1) = GDIR(NB1+JBAS,ND1+LBAS)
          R(2) = GDIR(NB1+JBAS,ND2+LBAS)
          R(3) = GDIR(NB2+JBAS,ND1+LBAS)
          R(4) = GDIR(NB2+JBAS,ND2+LBAS)
          R(5) = GDIR(NA1+IBAS,NC1+KBAS)
          R(6) = GDIR(NA1+IBAS,NC2+KBAS)
          R(7) = GDIR(NA2+IBAS,NC1+KBAS)
          R(8) = GDIR(NA2+IBAS,NC2+KBAS)
C
C         LARGEST OF THE EXCHANGE INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 7 AND IFLG = 11
          D(1) = ABS(DENT(NA1+IBAS,NC1+KBAS))
          D(2) = ABS(DENT(NA1+IBAS,NC2+KBAS))
          D(3) = ABS(DENT(NA2+IBAS,NC1+KBAS))
          D(4) = ABS(DENT(NA2+IBAS,NC2+KBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 7) = 0
            IMTX(M,11) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 6 AND IFLG = 10
          D(1) = ABS(DENT(NB1+JBAS,ND1+LBAS))
          D(2) = ABS(DENT(NB1+JBAS,ND2+LBAS))
          D(3) = ABS(DENT(NB2+JBAS,ND1+LBAS))
          D(4) = ABS(DENT(NB2+JBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 6) = 0
            IMTX(M,10) = 0
          ENDIF
C
C         SCREEN THIS BATCH M
          ISCR(M) = 0
          GOTO 1001
C
C         SCREENING FAILED FOR THIS BATCH
1000      CONTINUE
          N = N+1
          IMAP(N) = M
          ISCR(M) = 1
C
1001      CONTINUE
C
        ENDDO
      ENDDO
C
C     NUMBER OF INTEGRALS TO CALCULATE
      MAXN = N
C
C     NONE OF THE ELEMENTS WERE ABOVE SENSITIVITY LIMIT
      IF(N.EQ.0) THEN
        IBCH = 0
      ENDIF
C
C     SKIP POINT WHEN SCREENING COUNTER SWITCHED OFF
99    CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
      SUBROUTINE SELFCLM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  EEEEEEEE LL       FFFFFFFF  CCCCCC  LL       MM       MM  C
C   SS    SS EE       LL       FF       CC    CC LL       MMM     MMM  C
C   SS       EE       LL       FF       CC       LL       MMMM   MMMM  C
C    SSSSSS  EEEEEE   LL       FFFFFF   CC       LL       MM MM MM MM  C
C         SS EE       LL       FF       CC       LL       MM  MMM  MM  C
C   SS    SS EE       LL       FF       CC    CC LL       MM   M   MM  C
C    SSSSSS  EEEEEEEE LLLLLLLL FF        CCCCCC  LLLLLLLL MM       MM  C
C                                                                      C
C -------------------------------------------------------------------- C
C  SELFCLM GENERATES DIAGONAL COULOMB INTERACTION ELEMENTS FOR LATER   C
C  USE IN THE SCHWARZ INEQUALITY IN SCREENING PROCEDURES.              C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*80 TITLE
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/E0LL/E0LLFL(MFL,4),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,4),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      RCFILE = .FALSE.
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDSC(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1100 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE C'
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
        IF(ICNTC.NE.ICNTA) GOTO 1101
C
C     LOOP OVER CENTRE D
      DO 1200 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE D'
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
        IF(ICNTD.NE.ICNTB) GOTO 1201
C
C**********************************************************************C
C     LOOP OVER ALL KQNS (INDEX 2000)                                  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2100 KC=1,NKAP(ICNTC)
C
        IF(KC.NE.KA) GOTO 2101
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2200 KD=1,NKAP(ICNTD)
C
        IF(KD.NE.KB) GOTO 2201
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| VALUES (INDEX 3000)                          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3100 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      IF(MC.NE.MA) GOTO 3101
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3200 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
      IF(MD.NE.MB) GOTO 3201
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND C: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR B AND D: TT = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = MAPTTTT(IT1,IT2)
C
C**********************************************************************C
C     MATRIX ADDRESS ALLOCATION                                        C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDCD
C
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B.                     C
C     INCLUDE A BATCH OF ELECTRON REPULSION INTEGRALS INTO GMAT/QMAT.  C
C     NO EFFORT HAS BEEN MADE TO UTILISE INTEGRAL SYMMETRY BECAUSE     C
C     ROUTINE TAKES ALMOST NO TIME TO RUN AND IS NEEDED ONLY ONCE.     C
C**********************************************************************C
C
C     LOOP OVER ELEMENTS OF FOCK MATRIX BLOCK
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         RESET SCREENING COUNTERS
          DO M=1,NBAS(3)*NBAS(4)
            IMAP(M) = M
            ISCR(M) = 1
          ENDDO
C
C         GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
          CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN)
C
C         MOST OF THIS ERI WORK IS WASTED -- WANT IBAS=KBAS, JBAS=LBAS.
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
C
C             NOTE THAT (--|--) = (++|++) AND (-+|-+) = (+-|+-)
              IF(IBAS.EQ.KBAS.AND.JBAS.EQ.LBAS) THEN
                GDSC(NA1+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M, 1)))
                GDSC(NA1+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M, 6)))
                GDSC(NA2+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M,11)))
                GDSC(NA2+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M,16)))
              ENDIF
C
C           END LOOP OVER KBAS AND LBAS
            ENDDO
          ENDDO
C
C         END LOOP OVER IBAS AND JBAS
        ENDDO
      ENDDO
C
C     END LOOP OVER COMPONENT OVERLAPS
4000  CONTINUE
C     END LOOP OVER |MQN| VALUES
3201  CONTINUE
3200  CONTINUE
3101  CONTINUE
3100  CONTINUE
3000  CONTINUE
C     END LOOP OVER KQNS
2201  CONTINUE
2200  CONTINUE
2101  CONTINUE
2100  CONTINUE
2000  CONTINUE
C     END LOOP OVER CENTRES
1201  CONTINUE
1200  CONTINUE
1101  CONTINUE
1100  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     SELF-COULOMB MATRIX COMPLETE.                                    C
C**********************************************************************C
C
      TITLE = 'GDSC_ARRAY'
C     CALL GNUMTRX(GDSC,TITLE,NDIM)

      RETURN
      END
C
C
      SUBROUTINE SELFBRT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS  EEEEEEEE LL       FFFFFFFF BBBBBBB  RRRRRRR TTTTTTTT    C
C     SS    SS EE       LL       FF       BB    BB RR    RR   TT       C
C     SS       EE       LL       FF       BB    BB RR    RR   TT       C
C      SSSSSS  EEEEEE   LL       FFFFFF   BBBBBBB  RR    RR   TT       C
C           SS EE       LL       FF       BB    BB RRRRRRR    TT       C
C     SS    SS EE       LL       FF       BB    BB RR    RR   TT       C
C      SSSSSS  EEEEEEEE LLLLLLLL FF       BBBBBBB  RR    RR   TT       C
C                                                                      C
C -------------------------------------------------------------------- C
C  SELFBRT GENERATES DIAGONAL BREIT INTERACTION ELEMENTS FOR LATER     C
C  USE IN THE SCHWARZ INEQUALITY IN SCREENING PROCEDURES.              C
C**********************************************************************C
      INCLUDE 'parameters.h'
      INCLUDE 'scfoptions.h'
C
      CHARACTER*80 TITLE
C
      DIMENSION EXL(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION MAPTTTT(4,4)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BSET/BEXL(MBS,0:MEL,MCT),BXYZ(3,MCT),LRGE(MCT,MKP,MKP+1),
     &            KAPA(MKP,MCT),NFNC(0:MEL,MCT),NKAP(MCT),IQNC(MCT),NCNT
      COMMON/EILS/EILSFL(MFL,12),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EISL/EISLFL(MFL,12),IADISL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS,IABSL,ICDSL
      COMMON/IRCM/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/ISCR/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SWRZ/GDSC(MDM,MDM),BDSC(MDM,MDM)
C
C     TWO-ELECTRON COMPONENT OVERLAP ADDRESSES
      DATA MAPTTTT/1,0,0,2,0,5,6,0,0,7,8,0,3,0,0,4/
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      RCFILE = .FALSE.
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.NE.'DHFP'.AND.HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
        RETURN
      ELSE
        ITSTRT = 2
        ITSTOP = 3
        ITSKIP = 1
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDSC(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1100 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE C'
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
        IF(ICNTC.NE.ICNTA) GOTO 1101
C
C     LOOP OVER CENTRE D
      DO 1200 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE D'
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
        IF(ICNTD.NE.ICNTB) GOTO 1201
C
C**********************************************************************C
C     LOOP OVER ALL KQNS (INDEX 2000)                                  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1),ICNTA)
        DO IBAS=1,NBAS(1)
          EXL(IBAS,1) = BEXL(IBAS,LQN(1),ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2),ICNTB)
        DO JBAS=1,NBAS(2)
          EXL(JBAS,2) = BEXL(JBAS,LQN(2),ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2100 KC=1,NKAP(ICNTC)
C
        IF(KC.NE.KA) GOTO 2101
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3),ICNTC)
        DO KBAS=1,NBAS(3)
          EXL(KBAS,3) = BEXL(KBAS,LQN(3),ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2200 KD=1,NKAP(ICNTD)
C
        IF(KD.NE.KB) GOTO 2201
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4),ICNTD)
        DO LBAS=1,NBAS(4)
          EXL(LBAS,4) = BEXL(LBAS,LQN(4),ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| VALUES (INDEX 3000)                          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3100 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      IF(MC.NE.MA) GOTO 3101
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3200 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
      IF(MD.NE.MB) GOTO 3201
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND C: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.2) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR B AND D: TT = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.2) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1

C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = MAPTTTT(IT1,IT2)
C
C**********************************************************************C
C     MATRIX ADDRESS ALLOCATION                                        C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDCD
C
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B.                     C
C     INCLUDE A BATCH OF ELECTRON REPULSION INTEGRALS INTO BDSC.       C
C     NO EFFORT HAS BEEN MADE TO UTILISE INTEGRAL SYMMETRY BECAUSE     C
C     ROUTINE TAKES ALMOST NO TIME TO RUN AND IS NEEDED ONLY ONCE.     C
C**********************************************************************C
C
C     LOOP OVER ELEMENTS OF FOCK MATRIX BLOCK
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         RESET SCREENING COUNTERS
          DO M=1,NBAS(3)*NBAS(4)
            IMAP(M) = M
            ISCR(M) = 1
          ENDDO
C
C         OVERRIDE GAUNT REPLACEMENT TOGGLE
          MGNT = 0
C
C         GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
          CALL BII(RR,XYZ,KQN,MQN,NBAS,EXL,IBAS,JBAS,ITN,MGNT)
C
C         MOST OF THIS ERI WORK IS WASTED -- WANT IBAS=KBAS, JBAS=LBAS.
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
C
C             NOTE THAT (--|++) = (++|--) AND (-+|+-) = (+-|-+)
              IF(IBAS.EQ.KBAS.AND.JBAS.EQ.LBAS) THEN
                BDSC(NA1+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M, 4)))
                BDSC(NA1+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M, 7)))
                BDSC(NA2+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M,10)))
                BDSC(NA2+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M,13)))
              ENDIF
C
C           END LOOP OVER KBAS AND LBAS
            ENDDO
          ENDDO
C
C         END LOOP OVER IBAS AND JBAS
        ENDDO
      ENDDO
C
C     END LOOP OVER COMPONENT OVERLAPS
4000  CONTINUE
C     END LOOP OVER |MQN| VALUES
3201  CONTINUE
3200  CONTINUE
3101  CONTINUE
3100  CONTINUE
3000  CONTINUE
C     END LOOP OVER KQNS
2201  CONTINUE
2200  CONTINUE
2101  CONTINUE
2100  CONTINUE
2000  CONTINUE
C     END LOOP OVER CENTRES
1201  CONTINUE
1200  CONTINUE
1101  CONTINUE
1100  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     SELF-BREIT MATRIX COMPLETE.                                      C
C**********************************************************************C
C
      DO I=1,NDIM-NSKP
        DO J=1,I
          BDSC(J,I) = BDSC(I,J)
        ENDDO
      ENDDO
C
      TITLE = 'BDSC_ARRAY'
C     CALL GNUMTRX(BDSC,TITLE,NDIM)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [14] QED: UEHLING ROUTINE DEVELOPMENT.                              C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] RHOASYM: ASYMPTOTIC FORM FOR UEHLING DENSITY AT LARGE R.       C
C   [B] SELFCLM: GENERATES ARRAY OF COULOMB SELF-OVERLAPS.             C
C   [C] SELFBRT: GENERATES ARRAY OF BREIT SELF-OVERLAPS.               C
C**********************************************************************C
C
C
      SUBROUTINE RHOASYM(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  RRRRRRR  HH    HH  OOOOOO     AA     SSSSSS  YY    YY MM       MM   C
C  RR    RR HH    HH OO    OO   AAAA   SS    SS YY    YY MMM     MMM   C
C  RR    RR HH    HH OO    OO  AA  AA  SS       YY    YY MMMM   MMMM   C
C  RR    RR HHHHHHHH OO    OO AA    AA  SSSSSS   YY  YY  MM MM MM MM   C
C  RRRRRRR  HH    HH OO    OO AAAAAAAA       SS   YYYY   MM  MMM  MM   C
C  RR    RR HH    HH OO    OO AA    AA SS    SS    YY    MM   M   MM   C
C  RR    RR HH    HH  OOOOOO  AA    AA  SSSSSS     YY    MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  RHOASYM CALCULATES THE ASYMPTOTIC FORM FOR THE UEHLING CHARGE       C
C  DENSITY AT A LARGE RADIUS R, GIVEN A SINGLE GAUSSIAN CHARGE MODEL.  C
C  REQUIRES A NUMERICAL INTEGRATION OVER ENERGY DOMAIN T.              C
C  THIS CALCULATES R*RHO(R) BUT THEN PLOTS R*R*RHO(R).                 C
C  ------------------------------------------------------------------- C
C  TODO: FOR NOW, IGNORE FERMI MODEL TREATMENT AND GUESS THE ZETA      C
C        THAT MATCHES BEST WITH NUCLEAR RMS VALUE.                     C
C**********************************************************************C
      INCLUDE 'parameters.h'
      PARAMETER(NGRD=1000,NQDT=500)
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(1)
C
      DIMENSION RAD(0:NGRD),RHO(0:NGRD)
C
      COMMON/BDIM/NDIM,NSKP,NOCC,NVRT
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
C
C     COMPTON WAVELENGTH MODIFIER
      CMPF = CMPW/1.0D0
C
C     WRITE NUCLEAR RADIUS (IN FM)
      RFM = CFM*RNUC(IZ)
      WRITE(6,*) 'Nuclear radius = ',RFM,'fm'
C
C     NUCLEAR WIDTH PARAMETER
      ZETA = 1.5D0/(RNUC(IZ)*RNUC(IZ))
C
C     LOOP OVER ALL RADIUS VALUES
      H = 200.0D0*RFM/(DFLOAT(NGRD)*CFM)
      DO N=0,NGRD
C
C       RADIUS AT THIS POINT
        RAD(N) = H*DFLOAT(N)
        RHO(N) = 0.0D0
C
C       LOOP OVER INTEGRAND POINTS T
        U = (5.0D0-1.0D0)/DFLOAT(NQDT)
        DO J=0,NQDT
C
          T  = 1.0D0 + U*DFLOAT(J)
C
          Y1 = 1.0D0/(T*T*T)
          Y2 = DSQRT(1.0D0 - 1.0D0/(T*T))
          Y3 = 1.0D0 + 0.5D0/(T*T)
          Y4 = DEXP(-2.0D0*T*RAD(N)*CV)
          Y5 = DEXP(EMSS*CV*CV/(ZETA*T*T))

          RHO(N) = RHO(N) + EXTINT11(Y1*Y2*Y3*Y4*Y5,J,NQDT)
          
        ENDDO
C
      ENDDO
C
C     MULTIPLICATIVE FACTOR
      FAC = 5.0D0*U/2.99376D5
      FAC = 8.0D0*FAC*CMPF/(3.0D0*PI*CV*CV)
      DO N=0,NGRD
        RHO(N) = FAC*RHO(N)
      ENDDO
C
C     FILE NAME AND TITLES
      XOUT   = 'Asymptotic'
      TITLE  = 'r*r*rho(r)'
      XAXIS  = 'r/RNUC'
      YAXIS  = 'r*r*rho(r)'
      KEY(1) = 'Gaussian'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO N=0,NGRD
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) RAD(N)*CFM/RFM,RAD(N)*RHO(N)*CFM*1.0D3*4.0D0*PI
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,1,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
C
      RETURN
      END
C
C
      SUBROUTINE CHIGEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            CCCCCC  HH    HH IIII GGGGGG  EEEEEEEE NN    NN           C
C           CC    CC HH    HH  II GG    GG EE       NNN   NN           C
C           CC       HH    HH  II GG       EE       NNNN  NN           C
C           CC       HHHHHHHH  II GG       EEEEEE   NN NN NN           C
C           CC       HH    HH  II GG   GGG EE       NN  NNNN           C
C           CC    CC HH    HH  II GG    GG EE       NN   NNN           C
C            CCCCCC  HH    HH IIII GGGGGG  EEEEEEEE NN    NN           C
C                                                                      C
C -------------------------------------------------------------------- C
C  CHIGEN EXPLICITLY GENERATES THE FUNCTION CHI_2(X) AND SAVES IT TO   C
C  FILE, FOR LATER SPLINE INTERPOLATION IN UEHLING CALCULATIONS.       C
C  IT USES THE EXPONENTIAL INTEGRAL EXPANSION METHOD.                  C
C  THE SPLINE FUNCTION IS ACTUALLY χ_2(X)*EXP(X), LEAVING A POLYNOMIAL.C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      DIMENSION XS(0:NLW),Y2S(0:NLW),D2S(0:NLW),Y1S(0:NLW),D1S(0:NLW),
     &          XB(0:NUP),Y2B(0:NUP),D2B(0:NUP)
C
C     JOINING POINT FOR BOTH SPLINE FUNCTIONS
      XSPL = 0.60D0
C
C**********************************************************************C
C     INTERPOLATING FUNCTIONS IN REGION 0.0D0 < X <~ 0.6D0             C
C**********************************************************************C
C
C     REGION GRID LENGTHS AND ENDPOINTS
      NCOR = 800
      XBEG = 0.00D0
      XCOR = 1.00D-4
      XEND = 1.25D0*XSPL
C
C     VERY SMALL X: UNIFORMLY-SPACED GRID
      DO N=0,NCOR
        XS(N)  = XBEG + (XCOR-XBEG)*DFLOAT(N)/DFLOAT(NCOR)
        Y1S(N) = CHI1SF(XS(N))
        Y2S(N) = CHIFNC(XS(N),2,0)*DEXP(XS(N))
      ENDDO
C
C     LARGER X: EXPONENTIALLY-SPACED GRID
      SPC = DLOG(XEND/XCOR)/DFLOAT(NLW-NCOR)
      DO N=0,NLW-NCOR
        XS(N+NCOR)  = XCOR*DEXP(N*SPC)
        Y1S(N+NCOR) = CHI1SF(XS(N+NCOR))
        Y2S(N+NCOR) = CHIFNC(XS(N+NCOR),2,0)*DEXP(XS(N+NCOR))
      ENDDO
C
C     DERIVATIVES AT SPLINE ENDS
      D10 = 1.0D30
      D1N = CHI1SD(XEND)
      D20 =-1.0D30
      D2N = (CHIDRV(XEND,2,0)+CHIFNC(XEND,2,0))*DEXP(XEND)
C
C     GENERATE SPLINES
      CALL SPLNGEN(XS,Y1S,D1S,D10,D1N,NLW)
      CALL SPLNGEN(XS,Y2S,D2S,D20,D2N,NLW)
C
C     WRITE SPLINE DATA TO FILE
      OPEN(UNIT=50,FILE='chi1x.dat',STATUS='UNKNOWN')
      REWIND(UNIT=50)
        WRITE(50,*) XSPL
        DO N=0,NLW
          WRITE(50,*) XS(N),Y1S(N),D1S(N)
        ENDDO
      CLOSE(UNIT=50)
C
C     WRITE SPLINE DATA TO FILE
      OPEN(UNIT=52,FILE='chi2_small.dat',STATUS='UNKNOWN')
      REWIND(UNIT=52)
        WRITE(52,*) XSPL
        DO N=0,NLW
          WRITE(52,*) XS(N),Y2S(N),D2S(N)
        ENDDO
      CLOSE(UNIT=52)
C
C**********************************************************************C
C     INTERPOLATING FUNCTIONS IN REGION X >~ 0.6D0                     C
C**********************************************************************C
C
C     LARGE X ENDPOINTS
      XBEG =   0.90D0*XSPL
      XEND = 250.00D0
C
C     USE EXPONENTIALLY-SPACED GRID
      SPC = DLOG(XEND/XBEG)/DFLOAT(NUP)
      DO N=0,NUP
        XB(N)  = XBEG*DEXP(N*SPC)
        Y2B(N) = CHIFNC(XB(N),2,1)*DEXP(XB(N))
      ENDDO
C
C     DERIVATIVES AT SPLINE ENDS
      D20 = (CHIDRV(XBEG,2,1)+CHIFNC(XBEG,2,1))*DEXP(XBEG)
      D2N = (CHIDRV(XEND,2,1)+CHIFNC(XEND,2,1))*DEXP(XEND)
C
C     GENERATE SPLINE
      CALL SPLNGEN(XB,Y2B,D2B,D20,D2N,NUP)
C
C     WRITE SPLINE DATA TO FILE
      OPEN(UNIT=53,FILE='chi2_big.dat',STATUS='UNKNOWN')
      REWIND(UNIT=53)
        WRITE(53,*) XSPL
        DO N=0,NUP
          WRITE(53,*) XB(N),Y2B(N),D2B(N)
        ENDDO
      CLOSE(UNIT=53)
C
      RETURN
      END
C
C
      SUBROUTINE POLDENS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C     MAKES A BUNCH OF POLARISED DENSITY PLOTS.                        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(1)
C
      DIMENSION POLC(0:NRAD)
      DIMENSION ETMP(0:NRAD),RK(7)
      DIMENSION C0(7),CNS(7),CND(7)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/VPOL/RAD(0:NRAD),VUEH(0:NRAD),EUEH(0:NRAD),PUEH(0:NRAD)
C
C     MULTIPLIER FOR COMPTON WAVELENGTH (USE FOR MUON OR TAUON FIELD)
      CMPF = 1.0D0*CMPW
      
      iz = 1
C
C     RADIAL PLOTTING INFORMATION
      R0 = 0.0D0/CFM
      RN = 100.0D0/CFM
      HR = (RN-R0)/DFLOAT(NRAD)
C
      S0 = 0.0D0
      SM = 0.0D0
31    SN = SN + 0.001D0/CFM
      PM = SN*rhonuc(IZ,SN)
      IF(DABS(PM).GT.1.0D-10) GOTO 31
c      SM = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
      HS = (SN-S0)/DFLOAT(NSRC)
C
CC     CHARGE SOURCE EXTENT AND UNITLESS PARAMETER
C      SN = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
C      X  = 2.0D0*SM/CMPF
C
C     SKIP THIS STEP
C     GOTO 50
C
C     GENERATE RADIAL GRID AND CHARGE DENSITY
      DO N=0,NRAD
C
C       SET RADIUS
        R = R0 + HR*DFLOAT(N)
        RAD(N) = R
C
C       INITIALISE COUNTER FOR RHOPOL(R)
        RHOPOL = 0.0D0
C
C       MULTIPLICATIVE FACTOR
        RMLT = 8.0D0*R/(3.0D0*CV*CMPF)
C
C       INITIALISE COUNTERS
        RHO1 = 0.0D0
        RHO2 = 0.0D0
C
C       TWO INTEGRALS BUT SEPARATE OUT THE FIRST ONE
        DO M=0,NSRC
C
C         SET SOURCE CHARGE RADIUS
          S = S0 + HS*DFLOAT(M)
C
C         VARIOUS ARGUMENTS
          X1 = 2.0D0*DABS(R-S)/CMPF
          X2 = 2.0D0*DABS(R+S)/CMPF
C
C         ADD TO COUNTERS
          IF(X1.GT.0.0D0) THEN
            QINT = S*RHONUC(IZ,S)*CHIFNCquad(X1,0,1)
            RHO1 = RHO1 + EXTINT11(QINT,M,NSRC)
          ENDIF
          
          IF(X2.GT.0.0D0) THEN
            QINT = S*RHONUC(IZ,S)*CHIFNCquad(X2,0,1)
            RHO2 = RHO2 + EXTINT11(QINT,M,NSRC)
          ENDIF
C
        ENDDO
C
        RHOPOL = RHOPOL + 5.0D0*HS*(RHO1-RHO2)/2.99376D+5
c
        POLC(N) = RMLT*RHOPOL
c       WRITE(6,*) rad(n)/cfm,rmlt,polc(n)
        WRITE(6,*) rad(n)*cfm,rho1,rho2,polc(n)
C        
      ENDDO
C
C     FILE NAME AND TITLES
      XOUT   = 'Pueh_uni_exct'
      TITLE  = 'Weighted Uehling radial charge density rho(r)'
      XAXIS  = 'r [fm]'
      YAXIS  = '4*pi*r^2rho(r) [C/fm]'
      KEY(1) = 'Gaussian'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO N=0,300
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) RAD(N),POLC(N)/CFM
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,1,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
50    CONTINUE
C
C     CHARGE SOURCE EXTENT AND UNITLESS PARAMETER
      SM = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
      X  = 2.0D0*SM/CMPF
C
C     CHI_N(0) VALUES
      C0(2) = 9.0D0*PI/32.0D0
      C0(3) = 0.4D0
      C0(4) = 5.0D0*PI/64.0D0
      C0(5) = 6.0D0/35.0D0
      C0(6) = 21.0D0*PI/512.0D0
      C0(7) = 32.0D0/315.0D0
C
C     CHI_N(X) AND CHI_N(2X) VALUES
      DO N=2,7
        CNS(N) = CHIFNC(      X,N,0)
        CND(N) = CHIFNC(2.0D0*X,N,0)
      ENDDO
C
C     SEARCH FOR START OF POSITIVE CHARGE
      RZR = DSQRT(5.0D0/3.0D0)*RNUC(IZ)*CFM
C
C     TOTAL CHARGE IN EACH REGION (MAGNITUDE)
c     ***
      QP =-C0(4) + CND(4) + 2.0D0*X*CND(3) + X*X*C0(2) + X*X*CND(2)
      QP = QP/(CV*PI*X*X*X)
C
C     CALCULATION OF MOMENTS
C
C     <R^-2> UNDEFINED FOR NOW
      RK(2) = 0.0D0
C
C     <R^-1>
      RK(3) =-C0(3) + CNS(3) + X*CNS(2)
      RK(3) = 4.0D0*RK(3)/(PI*X*X*X*CFM)
C
C     <R^0>
      RK(4) = 0.0D0
C
C     <R^1>
      RK(5) =-C0(5) + CNS(5) + X*CNS(4) + 0.5D0*X*X*C0(3)
      RK(5) = 2.0D0*RK(5)*CMPF*CFM/(CV*PI*X*X*X)
C
C     <R^2>
      RK(6) = 2.0D0*((CMPF*CFM)**2)/(5.0D0*CV*PI)
C
C     <R^3>
c     ***
      RK(7) =-C0(7) + CNS(7) + X*CNS(6) + 0.5D0*X*X*C0(5)
     &      + 0.125D0*X*X*X*X*C0(3)

c      WRITE(6,*) RNUC(IZ)*CFM,-C0(7),CNS(7),X*CNS(6),0.5D0*X*X*C0(5),
c     &           0.125D0*X*X*X*X*C0(3),rk(7)
c      IF(RNUC(IZ)*CFM.EQ.2.0D0) STOP

      RK(7) = 6.0D0*RK(7)/(CV*PI)
      RK(7) = RK(7)*((CMPF*CFM/X)**3)
C
C     VUEH(0) DEFINED AS IDENTICAL TO <R^-1>
      RK(1) = RK(3)
C
      AVAL = (RNUC(IZ)*CFM - 0.570D0)/0.836D0
      AVAL = AVAL**3
      
      WRITE(6,*) RNUC(IZ)*CFM,AVAL,(RK(I),I=1,7),QP,RZR
C
      RETURN
      END
C
C
      FUNCTION CHIFNCQUAD(X,N,MODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           CCCCCC  HH    HH IIII FFFFFFFF NN    NN  CCCCCC            C
C          CC    CC HH    HH  II  FF       NNN   NN CC    CC           C          
C          CC       HH    HH  II  FF       NNNN  NN CC                 C
C          CC       HHHHHHHH  II  FFFFFF   NN NN NN CC                 C
C          CC       HH    HH  II  FF       NN  NNNN CC                 C
C          CC    CC HH    HH  II  FF       NN   NNN CC    CC           C
C           CCCCCC  HH    HH IIII FF       NN    NN  CCCCCC            C
C                                                                      C
C -------------------------------------------------------------------- C      
C     EVALUATE THE FUNCTION CHI_N (X) FOR PARTICULAR VALUE OF X,       C
C     USING A TRUNCATED SERIES WITH NTR TERMS.                         C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     CHECK THAT N IS WITHIN ALLOWED VALUES
      IF(N.LE.1.AND.X.EQ.0.0D0) THEN
        WRITE(6, *) 'In CHIFNC: divergent behaviour when N < 1. N = ',N
        WRITE(7, *) 'In CHIFNC: divergent behaviour when N < 1. N = ',N
        CHIFNC = 1.0D30
      ENDIF
C
C     INTEGRATION PARAMETERS (UNIFORM GRID)
      TBEG = 1.0D0
      TEND = 1.0D4
      HT   = (TEND/TBEG)/DFLOAT(KTR)
C
      CHIFNC = 0.0D0
      DO K=0,KTR
        T = TBEG + HT*DFLOAT(K)
        TR = 1.0D0/T
        Y1 = TR**N
        Y2 = DSQRT(1.0D0 - TR*TR)
        Y3 = 1.0D0 + 0.5D0*TR*TR
        Y4 = DEXP(-X*T)
        Z  = Y1*Y2*Y3*Y4
        CHIFNC = CHIFNC + 5.0D0*HT*EXTINT11(Z,K,KTR)/2.99376D+5
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION CHIFNC(X,N,MODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           CCCCCC  HH    HH IIII FFFFFFFF NN    NN  CCCCCC            C
C          CC    CC HH    HH  II  FF       NNN   NN CC    CC           C          
C          CC       HH    HH  II  FF       NNNN  NN CC                 C
C          CC       HHHHHHHH  II  FFFFFF   NN NN NN CC                 C
C          CC       HH    HH  II  FF       NN  NNNN CC                 C
C          CC    CC HH    HH  II  FF       NN   NNN CC    CC           C
C           CCCCCC  HH    HH IIII FF       NN    NN  CCCCCC            C
C                                                                      C
C -------------------------------------------------------------------- C      
C     EVALUATE THE FUNCTION CHI_N (X) FOR PARTICULAR VALUE OF X,       C
C     USING A TRUNCATED SERIES WITH NTR TERMS.                         C
C                   ∞      _______                                     C
C         χ_N(X) = ∫ t^-N √1-1/t^2 (1 + 1/2t^2) exp(-x t) dt.          C
C                   1                                                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  ▶  MODE = 0: USE EXACT AND APPROX. CHI_N (0.0D0) TO MIN. ERROR      C
C  ▶  MODE = 1: DO NOT USE EXACT VALUE (LARGE X).                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     CHECK THAT N IS WITHIN ALLOWED VALUES
      IF(N.LE.1.AND.X.EQ.0.0D0) THEN
        WRITE(6, *) 'In CHIFNC: divergent behaviour when N < 1. N = ',N
        WRITE(7, *) 'In CHIFNC: divergent behaviour when N < 1. N = ',N
        STOP
      ENDIF
C
C     SPECIAL CASE: X = 0.0D0
      IF(X.EQ.0.0D0) THEN
        CHIFNC = 0.75D0*PI12*GAMHLF(N+3)/(DFLOAT(N-1)*GAMHLF(N+4))
        RETURN
      ENDIF
C
C     χ_N(X) WITH SUM OF EXPONENTIAL FUNCTIONS
C
C     INITIALISE THE CHIFNC COUNTER
      CHIFNC = 0.0D0
C
C     LOOP FROM K=0 TO TRUNCATED INFINITY
      PHS =-1.0D0
      DO K=0,KTR
C
        RK = DFLOAT(K)
        IF(K.EQ.0) THEN
          BNM = 1.0D0
        ELSE
          BNM = (1.5D0-RK)*BNM/RK
        ENDIF
C
        PHS =-PHS
        ENK = EXPINTE(2*K+N,X) + 0.5D0*EXPINTE(2*K+N+2,X)
C
        CHIFNC = CHIFNC + PHS*BNM*ENK
C
      ENDDO
C
C     χ_N(X) NEAR ZERO, TAKING A CLEVER DIFFERENCE FROM χ_N(0)
      IF(MODE.EQ.0.AND.N.GT.1) THEN
C
C       EXACT VALUE AT X = 0.0D0
        TRU = 0.75D0*PI12*GAMHLF(N+3)/(DFLOAT(N-1)*GAMHLF(N+4))
C
C       INITIALISE THE COUNTER FOR RESIDUAL
        RSD = 0.0D0
C
        PHS =-1.0D0
        DO K=0,KTR
C
          RK = DFLOAT(K)
          IF(K.EQ.0) THEN
            BNM = 1.0D0
          ELSE
            BNM = (1.5D0-RK)*BNM/RK
          ENDIF
C
          PHS =-PHS
          RAT = DFLOAT(6*K+3*N+1)/DFLOAT(2*(2*K+N-1)*(2*K+N+1))
C
          RSD = RSD + PHS*BNM*RAT
C
        ENDDO
C
        CHIFNC = CHIFNC+TRU-RSD
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION CHIDRV(X,N,MODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           CCCCCC  HH    HH IIII DDDDDDD  RRRRRRR  VV    VV           C
C          CC    CC HH    HH  II  DD    DD RR    RR VV    VV           C
C          CC       HH    HH  II  DD    DD RR    RR VV    VV           C
C          CC       HHHHHHHH  II  DD    DD RR    RR VV    VV           C
C          CC       HH    HH  II  DD    DD RRRRRRR   VV  VV            C
C          CC    CC HH    HH  II  DD    DD RR    RR   VVVV             C
C           CCCCCC  HH    HH IIII DDDDDDD  RR    RR    VV              C
C                                                                      C
C -------------------------------------------------------------------- C
C  CHI2DERIV EVALUATES THE INSTANTANEOUS DERIVATIVE OF CHI_N(X) USING  C
C  A SERIES OF EXPONENTIAL INTEGRALS, OF LENGTH NTR.                   C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     CHECK THAT N IS WITHIN ALLOWED VALUES
      IF(N.LE.2.AND.X.EQ.0.0D0) THEN
        WRITE(6, *) 'In CHIDRV: divergent behaviour when N < 2. N = ',N
        WRITE(7, *) 'In CHIDRV: divergent behaviour when N < 2. N = ',N
        STOP
      ENDIF
C
C     SPECIAL CASE: X = 0.0D0
      IF(X.EQ.0.0D0) THEN
        CHIDRV =-0.75D0*PI12*GAMHLF(N+2)/(DFLOAT(N-2)*GAMHLF(N+3))
        RETURN
      ENDIF
C
C     χ'_N(X) WITH SUM OF EXPONENTIAL FUNCTIONS
C
C     INITIALISE THE CHIDRV COUNTER
      CHIDRV = 0.0D0
C
C     LOOP FROM K=0 TO TRUNCATED INFINITY
      PHS =-1.0D0
      DO K=0,KTR
C
        RK = DFLOAT(K)
        IF(K.EQ.0) THEN
          BNM = 1.0D0
        ELSE
          BNM = (1.5D0-RK)*BNM/RK
        ENDIF
C
        PHS =-PHS
        ENK = EXPINTE(2*K+N-1,X) + 0.5D0*EXPINTE(2*K+N+1,X)
C
        CHIDRV = CHIDRV - PHS*BNM*ENK
C
      ENDDO
C
C     χ'_N(X) NEAR ZERO, TAKING A CLEVER DIFFERENCE FROM χ'_N(0)
      IF(MODE.EQ.0.AND.N.GT.2) THEN
C
C       EXACT VALUE AT X = 0.0D0
        TRU =-0.75D0*PI12*GAMHLF(N+2)/(DFLOAT(N-2)*GAMHLF(N+3))
C
C       INITIALISE THE COUNTER FOR RESIDUAL
        RSD = 0.0D0
C
        PHS =-1.0D0
        DO K=0,KTR
C
          RK = DFLOAT(K)
          IF(K.EQ.0) THEN
            BNM = 1.0D0
          ELSE
            BNM = (1.5D0-RK)*BNM/RK
          ENDIF
C
          PHS =-PHS
          RAT = DFLOAT(6*K+3*N-2)/DFLOAT(2*(2*K+N-2)*(2*K+N))
C
          RSD = RSD - PHS*BNM*RAT
C
        ENDDO
C
        CHIDRV = CHIDRV+TRU-RSD
C
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION CHI1SF(X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             CCCCCC  HH    HH IIII  11   SSSSSS  FFFFFFFF             C
C            CC    CC HH    HH  II  111  SS    SS FF                   C
C            CC       HH    HH  II   11  SS       FF                   C
C            CC       HHHHHHHH  II   11   SSSSSS  FFFFFF               C
C            CC       HH    HH  II   11        SS FF                   C
C            CC    CC HH    HH  II   11  SS    SS FF                   C
C             CCCCCC  HH    HH IIII 1111  SSSSSS  FF                   C
C                                                                      C
C -------------------------------------------------------------------- C      
C  EVALUATE THE FUNCTION X*CHI_1 (X) FOR PARTICULAR VALUE OF X, USING  C
C  A TRUNCATED SERIES WITH NTR TERMS.                                  C
C                    ∞      _______                                    C
C      X*χ_N(X) = X*∫ t^-N √1-1/t^2 (1 + 1/2t^2) exp(-x t) dt.         C
C                    1                                                 C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     X*χ_1(X) WITH SUM OF EXPONENTIAL FUNCTIONS
C
C     INITIALISE THE CHI1SF COUNTER
      CHI1SF = 0.0D0
C
C     LOOP FROM K=0 TO TRUNCATED INFINITY
      PHS =-1.0D0
      DO K=0,KTR
C
        RK = DFLOAT(K)
        IF(K.EQ.0) THEN
          BNM = 1.0D0
        ELSE
          BNM = (1.5D0-RK)*BNM/RK
        ENDIF
C
        PHS =-PHS
        E10 = 1.5D0*DEXP(-X)
        E11 =-DFLOAT(2*K+1)*EXPINTE(2*K+2,X)
        E12 =-DFLOAT(2*K+3)*EXPINTE(2*K+4,X)*0.5D0
        ENK = E10 + E11 + E12
C
        CHI1SF = CHI1SF + PHS*BNM*ENK
C
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION CHI1SD(X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             CCCCCC  HH    HH IIII  11   SSSSSS  DDDDDDD              C
C            CC    CC HH    HH  II  111  SS    SS DD    DD             C
C            CC       HH    HH  II   11  SS       DD    DD             C
C            CC       HHHHHHHH  II   11   SSSSSS  DD    DD             C
C            CC       HH    HH  II   11        SS DD    DD             C
C            CC    CC HH    HH  II   11  SS    SS DD    DD             C
C             CCCCCC  HH    HH IIII 1111  SSSSSS  DDDDDDD              C
C                                                                      C
C -------------------------------------------------------------------- C      
C  EVALUATE THE DERIVATIVE OF THE FUNCTION X*CHI_1 (X) FOR PARTICULAR  C
C  VALUE OF X, USING A TRUNCATED SERIES WITH NTR TERMS.                C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      COMMON/GAMA/GAMLOG(300),GAMHLF(300)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     CHECK THAT X IS WITHIN ALLOWED VALUES
      IF(X.EQ.0.0D0) THEN
        WRITE(6, *) 'In CHI1SD: divergent behaviour when X = 0.0D0.'
        WRITE(7, *) 'In CHI1SD: divergent behaviour when X = 0.0D0.'
        STOP
      ENDIF
C
C     (X*χ_1(X))' WITH SUM OF EXPONENTIAL FUNCTIONS
C
C     INITIALISE THE CHI1SD COUNTER
      CHI1SD = 0.0D0
C
C     LOOP FROM K=0 TO TRUNCATED INFINITY
      PHS =-1.0D0
      DO K=0,KTR
C
        RK = DFLOAT(K)
        IF(K.EQ.0) THEN
          BNM = 1.0D0
        ELSE
          BNM = (1.5D0-RK)*BNM/RK
        ENDIF
C
        PHS =-PHS
        E10 = 1.5D0*DEXP(-X)
        E11 = DFLOAT(2*K+1)*EXPINTE(2*K+1,X)
        E12 = DFLOAT(2*K+3)*EXPINTE(2*K+3,X)*0.5D0
        ENK = E10 + E11 + E12
C
        CHI1SD = CHI1SD + PHS*BNM*ENK
C
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION EXPINTE(N,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE XX     XX PPPPPPP IIII NN    NN TTTTTTTT EEEEEEEE      C
C      EE        XX   XX  PP    PP II  NNN   NN    TT    EE            C
C      EE         XX XX   PP    PP II  NNNN  NN    TT    EE            C
C      EEEEEE      XXX    PP    PP II  NN NN NN    TT    EEEEEE        C
C      EE         XX XX   PPPPPPP  II  NN  NNNN    TT    EE            C
C      EE        XX   XX  PP       II  NN   NNN    TT    EE            C
C      EEEEEEEE XX     XX PP      IIII NN    NN    TT    EEEEEEEE      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EXPINTE EVALUATES THE GENERALISED EXPONENTIAL INTEGRAL, E_N(X).     C
C**********************************************************************C
C
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
C     CHECK FOR ILLEGAL INPUT
      IF(X.LT.0.0D0) THEN
        WRITE(6, *) 'In EXPINTE: X < 0.0D0. X = ',X 
        WRITE(7, *) 'In EXPINTE: X < 0.0D0. X = ',X 
        RETURN
      ELSEIF(N.LT.2.AND.X.EQ.0.0D0) THEN
        WRITE(6, *) 'In EXPINTE: cannot have X = 0.0D0 and N < 2.'
        WRITE(7, *) 'In EXPINTE: cannot have X = 0.0D0 and N < 2.'
        RETURN
      ENDIF
C
      IF(N.LE.0.AND.X.GT.0.0D0) THEN
C     CASE N < 0, X >= 0.0D0
C
        EXPINTE = DEXP(-X)/X
        DO K=1,N
          EXPINTE = DEXP(-X)/X + DFLOAT(K)*EXPINTE/X
        ENDDO
C
      ELSEIF(N.GE.2.AND.X.EQ.0.0D0) THEN
C     CASE N < 2, X  = 0.0D0
C
        EXPINTE = 1.0D0/DFLOAT(N-1)
C
      ELSEIF(X.GT.0.0D0.AND.X.LE.1.0D0) THEN
C     CASE 0.0D0 <= X <= 1.0D0 (SMALL ARGUMENT, SERIES EVALUATION)
C
C       STARTING VALUE
        IF(N.EQ.1) THEN
          EXPINTE =-DLOG(X)-EULR
        ELSE
          EXPINTE = 1.0D0/DFLOAT(N-1)
        ENDIF
C
C       LOOP UNTIL CORRECTIONS LEVEL OFF
        SER = 1.0D0
C
        DO K=1,100
C
          SER =-SER*X/DFLOAT(K)
C
C         CORRECTION FACTOR
          IF(K.NE.N-1) THEN
            DEL =-SER/DFLOAT(K-N+1)
          ELSE
C         COMPUTE PSI(N)
            PSI =-EULR
            DO KI=1,N-1
              PSI = PSI + 1.0D0/DFLOAT(KI)
            ENDDO
            DEL = SER*(-DLOG(X) + PSI)
          ENDIF
C
          EXPINTE = EXPINTE + DEL
          IF(DABS(DEL).LT.DABS(EXPINTE)*1.0D-9) THEN
            RETURN
          ENDIF
C
        ENDDO
C
C       FAILURE TO EXIT
        WRITE(6, *) 'In EXPINTE: series method failed.'
        WRITE(7, *) 'In EXPINTE: series method failed.'
        RETURN
C
C
      ELSEIF(X.GT.1.0D0) THEN
C     CASE X >= 1.0D0 (LARGE ARGUMENT, LENZ'S ALGORITHM)
C
        B = X+N
        C = 1.0D+30
        D = 1.0D0/B
        H = D
C
        DO K=1,100
          A   =-K*DFLOAT(N+K-1)
          B   = B+2.0D0
          D   = 1.0D0/(A*D+B)
          C   = B + A/C
          DEL = C*D
          H   = H*DEL
C
          EXPINTE = H*DEXP(-X)
          IF(DABS(DEL-1.0D0).LT.1.0D-9) THEN
            RETURN
          ENDIF
C
        ENDDO
C
C       FAILURE TO EXIT
        WRITE(6, *) 'In EXPINTE: continued fraction method failed.'
        WRITE(7, *) 'In EXPINTE: continued fraction method failed.'
        RETURN
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE SPLNGEN(X,Y,D2,D10,D1N,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     SSSSSS  PPPPPPP  LL       NN    NN  GGGGGG  EEEEEEEE NN    NN    C
C    SS    SS PP    PP LL       NNN   NN GG    GG EE       NNN   NN    C
C    SS       PP    PP LL       NNNN  NN GG       EE       NNNN  NN    C
C     SSSSSS  PP    PP LL       NN NN NN GG       EEEEEE   NN NN NN    C
C          SS PPPPPPP  LL       NN  NNNN GG   GGG EE       NN  NNNN    C
C    SS    SS PP       LL       NN   NNN GG    GG EE       NN   NNN    C
C     SSSSSS  PP       LLLLLLLL NN    NN  GGGGGG  EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPLNGEN IS A CUBIC SPLINE GENERATOR, TAKING AN ORDERED LIST OF      C
C  ARGUMENTS X(0:N) AND THE CORRESPONDING FUNCTION VALUES Y(0:N) AS    C
C  WELL AS ITS FIRST DERIVATIVE AT THE SPLINE BOUNDARIES, AND GIVING   C
C  AN ARRAY D2(0:N) OF ITS SECOND DERIVATIVES AT ALL ARGUMENT VALUES.  C
C  THERE ARE SPECIAL CASES WHEN THE BOUNDARY DERIVATIVES AREN'T KNOWN. C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C   ▶   X - ARRAY OF INPUT VALUES, X_I.                                C
C   ▶   Y - ARRAY OF FUNCTION VALUES, Y_I.                             C
C   ▶   N - LENGTH OF ARRAYS FOR X, Y AND D2.                          C
C   ▶ D10 - FIRST DERIVATIVE OF INTERPOLATING FUNCTION AT X_0.         C
C   ▶ D1N - FIRST DERIVATIVE OF INTERPOLATING FUNCTION AT X_N.         C
C OUTPUT:                                                              C
C   ▶  D2 - SECOND DERIVATIVES OF THE INTERPOLATING FUNCTION AT X_I.   C
C**********************************************************************C
C
      DIMENSION X(0:N),Y(0:N),D2(0:N),UT(0:N)
C
C     FORWARD EVALUATION STARTING WITH LOWER BOUNDARY CONDITION D10
C
      IF(DABS(D10).GT.1.0D+29) THEN
C       NATURAL OPTION (D1 LIKELY DIVERGES HERE)
        D2(0) = 0.0D0
        UT(0) = 0.0D0
      ELSE
C       SPECIFIED DERIVATIVE
        D2(0) =-0.5D0
        UT(0) = (3.0D0/(X(1)-X(0)))*((Y(1)-Y(0))/(X(1)-X(0))-D10)
      ENDIF
C
C     DECOMPOSITION LOOP OF THE TRIDIAGONAL ALGORITHM
      DO I=1,N-1
C
        XDP = X(I+1)-X(I  )
        XDM = X(I  )-X(I-1)
        XDB = X(I+1)-X(I-1)
        YDP = Y(I+1)-Y(I  )
        YDM = Y(I  )-Y(I-1)
C
        P     = XDM*D2(I-1)/XDB + 2.0D0
        D2(I) = (XDM/XDB-1.0D0)/P
        UT(I) = 6.0D0*(YDP/XDP-YDM/XDM) - XDM*UT(I-1)
        UT(I) = UT(I)/(P*XDB)
C
      ENDDO
C
C     BACKWARD CORRECTION STARTING WITH UPPER BOUNDARY CONDITION D1N
C
      IF(DABS(D1N).GT.1.0D+29) THEN
C
C       NATURAL OPTION (D1 LIKELY DIVERGES HERE)
        QN = 0.0D0
        UN = 0.0D0
C
      ELSE
C
C       SPECIFIED DERIVATIVE
        QN = 0.5D0
        UN = (3.0D0/(X(N)-X(N-1)))*(D1N-(Y(N)-Y(N-1))/(X(N)-X(N-1)))
C
      ENDIF
C
C     BACK-SUBSTITUTION LOOP USING THE TRIDIAGONAL ALGORITHM
      D2(N) = (UN - QN*UT(N-1))/(QN*D2(N-1)+1.0D0)
      DO I=0,N-1
        K     = N-I
        D2(K) = D2(K)*D2(K+1) + UT(K)
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE SPLNINT(XI,YI,D2I,X,Y,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       SSSSSS  PPPPPPP  LL       NN    NN IIII NN    NN TTTTTTTT      C
C      SS    SS PP    PP LL       NNN   NN  II  NNN   NN    TT         C
C      SS       PP    PP LL       NNNN  NN  II  NNNN  NN    TT         C
C       SSSSSS  PP    PP LL       NN NN NN  II  NN NN NN    TT         C
C            SS PPPPPPP  LL       NN  NNNN  II  NN  NNNN    TT         C
C      SS    SS PP       LL       NN   NNN  II  NN   NNN    TT         C
C       SSSSSS  PP       LLLLLLLL NN    NN IIII NN    NN    TT         C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPLNINT IS AN INTERPOLATOR ROUTINE THAT TAKES AN EXISTING SPLINE    C
C  (WITH ARGUMENTS, FUNCTION VALUES AND SECOND DERIVATIVES IN ARRAYS   C
C  XI, YI AND D2I OF LENGTH N) AND AN ARGUMENT X, THEN RETURNS THE     C
C  CUBIC SPLINE INTERPOLATED FUNCTION VALUE Y.                         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C   ▶  XI - ARRAY OF SPLINE INPUT VALUES X_I.                          C
C   ▶  YI - ARRAY OF SPLINE FUNCTION VALUES Y_I = Y(X_I).              C
C   ▶ D2I - ARRAY OF SPLINE SECOND DERIVATIVE VALUES D2I = Y''(X_I).   C
C   ▶   N - LENGTH OF ARRAYS FOR XI, YI AND D2I.                       C
C   ▶   X - INPUT VALUE OF INTEREST.                                   C
C OUTPUT:                                                              C
C   ▶   Y - CUBIC-SPLINE INTERPOLATED FUNCTION VALUE OF ARGUMENT X.    C
C**********************************************************************C
C
      DIMENSION XI(0:N),YI(0:N),D2I(0:N)
C
C     INITIALISE ENDPOINTS OF CORRECT SPLINE ADDRESS
      M1 = 0
      M2 = N
C
C     USE BISECTION TO SEARCH FOR SPLINE WINDOW.
C     IF SPLNINT ARGUMENTS ARE IN ORDER, STORE M1 AND M2 BETWEEN CALLS.
1     IF(M2-M1.GT.1) THEN
        K = (M2+M1)/2
        IF(XI(K).GT.X) THEN
          M2 = K
        ELSE
          M1 = K
        ENDIF
        GOTO 1
      ENDIF
C
C     SPACING BETWEEN THE NEIGHBOURING XI VALUES
      H = XI(M2)-XI(M1)
C
C     CHECK THAT SPLINE VALUES XI ARE DISTINCT
      IF(H.EQ.0.0D0) THEN
        WRITE(6, *) 'In SPLNINT: bad XI input values.'
        WRITE(7, *) 'In SPLNINT: bad XI input values.'
        STOP
      ENDIF
C
C     EVALUATE CUBIC-SPLINE POLYNOMIAL
      R = (XI(M2)-X     )/H
      S = (X     -XI(M1))/H
      T = R*(R*R-1.0D0)*D2I(M1)
      U = S*(S*S-1.0D0)*D2I(M1)
C
      Y = R*YI(M1) + S*YI(M2) + H*H*(T+U)/6.0D0
C
      RETURN
      END
C
C
      SUBROUTINE VUEHLNG(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV UU    UU EEEEEEEE HH    HH LL       NN    NN  GGGGGG     C
C    VV    VV UU    UU EE       HH    HH LL       NNN   NN GG    GG    C
C    VV    VV UU    UU EE       HH    HH LL       NNNN  NN GG          C
C    VV    VV UU    UU EEEEEE   HHHHHHHH LL       NN NN NN GG          C
C     VV  VV  UU    UU EE       HH    HH LL       NN  NNNN GG   GGG    C
C      VVVV   UU    UU EE       HH    HH LL       NN   NNN GG    GG    C
C       VV     UUUUUU  EEEEEEEE HH    HH LLLLLLLL NN    NN  GGGGGG     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VUEHLNG EVALUATES THE UEHLING POTENTIAL DUE TO A NUCLEAR CHARGE     C
C  SOURCE (GAUSSIAN SHAPE) FOR A SERIES OF RADII.                      C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(1)
C
      DIMENSION XS(0:NLW),Y2S(0:NLW),D2S(0:NLW),Y1S(0:NLW),D1S(0:NLW),
     &          XB(0:NUP),Y2B(0:NUP),D2B(0:NUP)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/VPOL/RAD(0:NRAD),VUEH(0:NRAD),EUEH(0:NRAD),PUEH(0:NRAD)
C
C     MULTIPLIER FOR COMPTON WAVELENGTH (USE FOR MUON OR TAUON FIELD)
      CMPF = 1.0D0*CMPW
C
C     IMPORT SPLINE DATA FOR X*CHI_1(X) GIVEN 0 <= X <= XSPL
      OPEN(UNIT=50,FILE='chi1x.dat',STATUS='UNKNOWN')
      REWIND(UNIT=50)
        READ(50,*) XSPL
        DO N=0,NLW
          READ(50,*) XS(N),Y1S(N),D1S(N)
        ENDDO
      CLOSE(UNIT=50)
C
C     IMPORT SPLINE DATA FOR CHI_2(X) GIVEN 0 <= X <= XSPL
      OPEN(UNIT=52,FILE='chi2_small.dat',STATUS='UNKNOWN')
      REWIND(UNIT=52)
        READ(52,*) XSPL
        DO N=0,NLW
          READ(52,*) XS(N),Y2S(N),D2S(N)
        ENDDO
      CLOSE(UNIT=52)
C
C     IMPORT SPLINE DATA FOR CHI_2(X) GIVEN X >= XSPL
      OPEN(UNIT=53,FILE='chi2_big.dat',STATUS='UNKNOWN')
      REWIND(UNIT=53)
        READ(53,*) XSPL
        DO N=0,NUP
          READ(53,*) XB(N),Y2B(N),D2B(N)
        ENDDO
      CLOSE(UNIT=53)
C
C     RADIAL PLOTTING INFORMATION
      R0 = 0.0D0/CFM
      RN = 2500.0D0/CFM
      HR = (RN-R0)/DFLOAT(NRAD)
C
C     SEARCH FOR CHARGE RADIUS SMAX FOR WHICH RHO(SMAX) < 1.0D-16
      S0 = 0.0D0
      SM = 0.0D0
31    SM = SM + 0.001D0/CFM
      PM = SM*rhonuc(IZ,SM)
      IF(DABS(PM).GT.1.0D-10) GOTO 31
c      SM = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
      HS = (SM-S0)/DFLOAT(NSRC)
C      
      RHOTOT = 0.0D0
      DO M=0,NSRC
        S = S0 + HS*DFLOAT(M)
        Z = S*S*rhonuc(IZ,S)
        RHOTOT = RHOTOT + 5.0D0*HS*EXTINT11(Z,M,NSRC)/2.99376D+5
      ENDDO
C
C     GENERATE RADIAL GRID AND POTENTIALS
      DO N=0,NRAD
C
C       SET RADIUS
        R = R0 + HR*DFLOAT(N)
        RAD(N) = R
C
C       SPECIAL CASE: R = 0.0D0 (UEHLING POTENTIAL AT THE ORIGIN)
        IF(N.EQ.0) THEN
C
C         INITIALISE COUNTER FOR V(R)
          V = 0.0D0
C
C         INTEGRATE OVER CHARGE SOURCE (DON'T INCLUDE S = 0.0D0 CASE)
          DO M=1,NSRC
C
C           SET SOURCE RADIUS
            S  = S0 + HS*DFLOAT(M)
C
C           CHI FUNCTION ARGUMENTS
            X0 = 2.0D0*S/CMPF
C
C           COMPONENTS OF INTEGRAND
            CALL SPLNINT(XS,Y1S,D1S,X0,C0,NLW)
C
C           CONTRIBUTION TO INTEGRAND
            Z = rhonuc(IZ,S)*C0
            V = V + 5.0D0*HS*EXTINT11(Z,M,NSRC)/2.99376D+5
C
          ENDDO
C
C         MULTIPLICATIVE FACTORS FOR VUEH(N)
          VUEH(N) =-4.0D0*CMPF*V/(3.0D0*CV)
C
        ELSE
C       ALL NON-ZERO RADII
C
C         INITIALISE COUNTER FOR V(R)
          V = 0.0D0
C
C         INTEGRATE OVER CHARGE SOURCE
          DO M=0,NSRC
C
C           SET SOURCE RADIUS
            S  = S0 + HS*DFLOAT(M)
C
C           CHI FUNCTION ARGUMENTS
            XM = 2.0D0*DABS(R-S)/CMPF
            XP = 2.0D0*DABS(R+S)/CMPF
C
C           COMPONENTS OF INTEGRAND
            IF(0.5D0*(XM+XP).LT.XSPL) THEN
              CALL SPLNINT(XS,Y2S,D2S,XM,CM,NLW)
              CALL SPLNINT(XS,Y2S,D2S,XP,CP,NLW)    
            ELSE
              CALL SPLNINT(XB,Y2B,D2B,XM,CM,NUP)
              CALL SPLNINT(XB,Y2B,D2B,XP,CP,NUP)
            ENDIF
C
C           PERFORM THE MAPPING CHI(X) = SPLINE(X)*EXP(-X)
            CM = CM*DEXP(-XM)
            CP = CP*DEXP(-XP)
C
C           CONTRIBUTION TO INTEGRAND
            Z = S*rhonuc(IZ,S)*(CM-CP)
            V = V + 5.0D0*HS*EXTINT11(Z,M,NSRC)/2.99376D+5
C          
          ENDDO
C
C         MULTIPLICATIVE FACTORS FOR VUEH(N)
          VUEH(N) =-2.0D0*CMPF*V/(3.0D0*CV*R)
C
        ENDIF
C
      ENDDO
      
      RETURN
C
C     FILE NAME AND TITLES
      XOUT   = 'Vueh'
      TITLE  = 'Uehling potential'
      XAXIS  = 'r [fm]'
      YAXIS  = 'V(r) [C/fm]'
      KEY(1) = 'Gaussian'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO N=0,300
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) RAD(N)*CFM,VUEH(N)/CFM
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,1,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C      
      RETURN
      END
C
C
      SUBROUTINE EUEHLNG(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    EEEEEEEE UU    UU EEEEEEEE HH    HH LL       NN    NN  GGGGGG     C
C    EE       UU    UU EE       HH    HH LL       NNN   NN GG    GG    C
C    EE       UU    UU EE       HH    HH LL       NNNN  NN GG          C
C    EEEEEE   UU    UU EEEEEE   HHHHHHHH LL       NN NN NN GG          C
C    EE       UU    UU EE       HH    HH LL       NN  NNNN GG   GGG    C
C    EE       UU    UU EE       HH    HH LL       NN   NNN GG    GG    C
C    EEEEEEEE  UUUUUU  EEEEEEEE HH    HH LLLLLLLL NN    NN  GGGGGG     C
C                                                                      C
C -------------------------------------------------------------------- C
C  EUEHLNG EVALUATES THE UEHLING ELECTRIC FIELD DUE TO A NUCLEAR       C
C  CHARGE SOURCE (GAUSSIAN SHAPE) FOR A SERIES OF RADII.               C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(1)
C
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/VPOL/RAD(0:NRAD),VUEH(0:NRAD),EUEH(0:NRAD),PUEH(0:NRAD)
      
C     TAKE NUMERICAL DERIVATIVE
      H = RAD(1)-RAD(0)
      DO N=1,NRAD-1
        EUEH(N) =-0.5D0*(VUEH(N+1)-VUEH(N-1))/H
      ENDDO
C
C     SPECIAL CASES (PHYSICALLY-MOTIVATED)
      EUEH(0   ) = 0.0D0
      EUEH(NRAD) = 0.0D0
C
C     THIS FIXES THE INCONSISTENCY BETWEEN V(0) AND V(R) METHODS
      EUEH(1) = 0.5D0*EUEH(2)
C
      RETURN
C
C     FILE NAME AND TITLES
      XOUT   = 'Eueh'
      TITLE  = 'Uehling electric field E_{r}(r)'
      XAXIS  = 'r [fm]'
      YAXIS  = 'E_{r}(r) [C/fm^2]'
      KEY(1) = 'Gaussian'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO N=0,300
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) RAD(N)*CFM,EUEH(N)/(CFM*CFM)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,1,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C      
      RETURN
      END
C
C
      SUBROUTINE PUEHLNG(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    PPPPPPP  UU    UU EEEEEEEE HH    HH LL       NN    NN  GGGGGG     C
C    PP    PP UU    UU EE       HH    HH LL       NNN   NN GG    GG    C
C    PP    PP UU    UU EE       HH    HH LL       NNNN  NN GG          C
C    PPPPPPP  UU    UU EEEEEE   HHHHHHHH LL       NN NN NN GG          C
C    PP       UU    UU EE       HH    HH LL       NN  NNNN GG   GGG    C
C    PP       UU    UU EE       HH    HH LL       NN   NNN GG    GG    C
C    PP        UUUUUU  EEEEEEEE HH    HH LLLLLLLL NN    NN  GGGGGG     C
C                                                                      C
C -------------------------------------------------------------------- C
C  EUEHLNG EVALUATES THE UEHLING CHARGE DISTRIBUTION FIELD DUE TO A    C
C  NUCLEAR CHARGE SOURCE (GAUSSIAN SHAPE) FOR A SERIES OF RADII.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(1)
C
      DIMENSION ETMP(0:NRAD),RK(7)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/VPOL/RAD(0:NRAD),VUEH(0:NRAD),EUEH(0:NRAD),PUEH(0:NRAD)
C
C     PRE-MULTIPLICATION (WEIGH BY R^2)
      DO N=0,NRAD
        ETMP(N) = RAD(N)*RAD(N)*EUEH(N)
      ENDDO
C
C     FINITE DIFFERENCE FIRST DERIVATIVE
      HR = RAD(1)-RAD(0)
      DO N=1,NRAD-1
        PUEH(N) = 0.5D0*(ETMP(N+1)-ETMP(N-1))/HR
      ENDDO
C
C     SPECIAL CASES (PHYSICALLY-MOTIVATED)
      PUEH(0   ) = 0.0D0
      PUEH(NRAD) = 0.0D0
C
C     SEARCH FOR START OF POSITIVE CHARGE
      RZR = 0.0D0
      NPS = 0
      DO N=0,NRAD
        IF(PUEH(N).GT.0.0D0) THEN
          NPS = N
          RZR = (PUEH(N)*RAD(N-1)-PUEH(N-1)*RAD(N))/(PUEH(N)-PUEH(N-1))
          RZR = RZR*CFM
          GOTO 10
        ENDIF
      ENDDO
10    CONTINUE
C      
C     NUMBER OF INTEGRATION STEPS MUST BE DIVISIBLE BY 10
      NCLN = NRAD-NPS-MOD(NRAD-NPS,10)
C
C     INTEGRATE UP OVER POSITIVE PARTS
      QP = 0.0D0
      DO N=NPS,NPS+NCLN
        QP = QP + 5.0D0*HR*EXTINT11(PUEH(N),N-NPS,NCLN)/2.99376D+5
      ENDDO
C
C     CALCULATION OF MOMENTS
C     WRITE(6,*) 'Radial moments...'
      RK(1) = VUEH(0)/CFM
      DO K=-2,3
C
        HR = RAD(1)-RAD(0)
        RK(K+4) = 0.0D0
        DO N=0,NRAD
          IF(N.EQ.0) THEN
            Z = 0.0D0
          ELSE
            Z  = (RAD(N)**K)*PUEH(N)
          ENDIF
          RK(K+4) = RK(K+4) + 5.0D0*HR*EXTINT11(Z,N,NRAD)/2.99376D+5
        ENDDO
C
        RK(K+4) = RK(K+4)*(CFM**K)
C
      ENDDO
C
      AVAL = (RNUC(IZ)*CFM - 0.570)/0.836D0
      AVAL = AVAL**3
      
      WRITE(6,*) RNUC(IZ)*CFM,AVAL,(RK(I),I=1,7),QP,RZR
C
C     FILE NAME AND TITLES
      XOUT   = 'Pueh_frm'
      TITLE  = 'Weighted Uehling radial charge density rho(r)'
      XAXIS  = 'r [fm]'
      YAXIS  = 'r^2rho(r) [C/fm^3]'
      KEY(1) = 'Gaussian'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO N=0,300
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) RAD(N)*CFM,PUEH(N)/CFM
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,1,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE PUEHUNI(IZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      PPPPPPP  UU    UU EEEEEEEE HH    HH UU    UU NN    NN IIII      C
C      PP    PP UU    UU EE       HH    HH UU    UU NNN   NN  II       C
C      PP    PP UU    UU EE       HH    HH UU    UU NNNN  NN  II       C
C      PPPPPPP  UU    UU EEEEEE   HHHHHHHH UU    UU NN NN NN  II       C
C      PP       UU    UU EE       HH    HH UU    UU NN  NNNN  II       C
C      PP       UU    UU EE       HH    HH UU    UU NN   NNN  II       C
C      PP        UUUUUU  EEEEEEEE HH    HH  UUUUUU  NN    NN IIII      C
C                                                                      C
C -------------------------------------------------------------------- C
C  EUEHLNG EVALUATES THE UEHLING CHARGE DISTRIBUTION FIELD DUE TO A    C
C  NUCLEAR CHARGE SOURCE (GAUSSIAN SHAPE) FOR A SERIES OF RADII.       C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5  NMDL
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(1)
C
      DIMENSION ETMP(0:NRAD),RK(7)
      DIMENSION C0(7),CNS(7),CND(7)
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/CONV/CHZ,CFM,CDB
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
      COMMON/PHYS/CV,EMSS,UMSS,TMSS,PMSS,PRAD,CMPW,GFREE,GFRMI,WEIN
      COMMON/VPOL/RAD(0:NRAD),VUEH(0:NRAD),EUEH(0:NRAD),PUEH(0:NRAD)
C
C     MULTIPLIER FOR COMPTON WAVELENGTH (USE FOR MUON OR TAUON FIELD)
      CMPF = 1.0D0*CMPW
C
C     RADIAL PLOTTING INFORMATION
      R0 = 0.0D0/CFM
      RN = 2000.0D0/CFM
      HR = (RN-R0)/DFLOAT(NRAD)
C
C     CHARGE SOURCE EXTENT AND UNITLESS PARAMETER
      SM = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
      X  = 2.0D0*SM/CMPF
C
C     SKIP THIS STEP
      GOTO 50
C
C     GENERATE RADIAL GRID AND CHARGE DENSITY
      DO N=0,NRAD
C
C       SET RADIUS
        R = R0 + HR*DFLOAT(N)
        RAD(N) = R
C
C       INITIALISE COUNTER FOR RHO(R)
        RHO = 0.0D0
C
C       MULTIPLICATIVE FACTOR
        RMLT =-CMPF*R/(2.0D0*PI*CV*SM*SM*SM)
        IF(R.LE.SM) THEN
C
          XM = 2.0D0*(SM-R)/CMPF
          XP = 2.0D0*(SM+R)/CMPF
C
C         CHI_2(X) TERMS
          CHIM = CHIFNC(XM,2,0)
          CHIP = CHIFNC(XP,2,0)
C
          RHO = RHO + CHIM-CHIP
C
C         CHI_1(X) TERMS
          CHIM = CHIFNC(XM,1,0)
          CHIP = CHIFNC(XP,1,0)
C
          RHO = RHO + X*(CHIM-CHIP)
C
        ELSE
C
          XM = 2.0D0*(R-SM)/CMPF
          XP = 2.0D0*(R+SM)/CMPF
C
C         CHI_2(X) TERMS
          CHIM = CHIFNC(XM,2,0)
          CHIP = CHIFNC(XP,2,0)
C
          RHO = RHO + CHIM-CHIP
C
C         CHI_1(X) TERMS
          CHIM = CHIFNC(XM,1,0)
          CHIP = CHIFNC(XP,1,0)
C
          RHO = RHO - X*(CHIM+CHIP)
C
        ENDIF
        
        PUEH(N) = RMLT*RHO
C        
      ENDDO
C
C     FILE NAME AND TITLES
      XOUT   = 'Pueh_uni_exct'
      TITLE  = 'Weighted Uehling radial charge density rho(r)'
      XAXIS  = 'r [fm]'
      YAXIS  = 'r^2rho(r) [C/fm^3]'
      KEY(1) = 'Gaussian'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO N=0,300
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) RAD(N)*CFM,PUEH(N)/CFM
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,1,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
50    CONTINUE
C
C     CHARGE SOURCE EXTENT AND UNITLESS PARAMETER
      SM = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
      X  = 2.0D0*SM/CMPF
C
C     CHI_N(0) VALUES
      C0(2) = 9.0D0*PI/32.0D0
      C0(3) = 0.4D0
      C0(4) = 5.0D0*PI/64.0D0
      C0(5) = 6.0D0/35.0D0
      C0(6) = 21.0D0*PI/512.0D0
      C0(7) = 32.0D0/315.0D0
C
C     CHI_N(X) AND CHI_N(2X) VALUES
      DO N=2,7
        CNS(N) = CHIFNC(      X,N,0)
        CND(N) = CHIFNC(2.0D0*X,N,0)
      ENDDO
C
C     SEARCH FOR START OF POSITIVE CHARGE
      RZR = DSQRT(5.0D0/3.0D0)*RNUC(IZ)*CFM
C
C     TOTAL CHARGE IN EACH REGION (MAGNITUDE)
c     ***
      QP =-C0(4) + CND(4) + 2.0D0*X*CND(3) + X*X*C0(2) + X*X*CND(2)
      QP = QP/(CV*PI*X*X*X)
C
C     CALCULATION OF MOMENTS
C
C     <R^-2> UNDEFINED FOR NOW
      RK(2) = 0.0D0
C
C     <R^-1>
      RK(3) =-C0(3) + CNS(3) + X*CNS(2)
      RK(3) = 4.0D0*RK(3)/(PI*X*X*X*CFM)
C
C     <R^0>
      RK(4) = 0.0D0
C
C     <R^1>
      RK(5) =-C0(5) + CNS(5) + X*CNS(4) + 0.5D0*X*X*C0(3)
      RK(5) = 2.0D0*RK(5)*CMPF*CFM/(CV*PI*X*X*X)
C
C     <R^2>
      RK(6) = 2.0D0*((CMPF*CFM)**2)/(5.0D0*CV*PI)
C
C     <R^3>
c     ***
      RK(7) =-C0(7) + CNS(7) + X*CNS(6) + 0.5D0*X*X*C0(5)
     &      + 0.125D0*X*X*X*X*C0(3)

c      WRITE(6,*) RNUC(IZ)*CFM,-C0(7),CNS(7),X*CNS(6),0.5D0*X*X*C0(5),
c     &           0.125D0*X*X*X*X*C0(3),rk(7)
c      IF(RNUC(IZ)*CFM.EQ.2.0D0) STOP

      RK(7) = 6.0D0*RK(7)/(CV*PI)
      RK(7) = RK(7)*((CMPF*CFM/X)**3)
C
C     VUEH(0) DEFINED AS IDENTICAL TO <R^-1>
      RK(1) = RK(3)
C
      AVAL = (RNUC(IZ)*CFM - 0.570D0)/0.836D0
      AVAL = AVAL**3
      
      WRITE(6,*) RNUC(IZ)*CFM,AVAL,(RK(I),I=1,7),QP,RZR
C
      RETURN
      END
C
C
      FUNCTION VASYMP(IZ,R,CMPF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C     QGAUSS0 IS THE RADIAL CHARGE DENSITY GENERATED BY A PROTON       C
C     WITH POSITIVE UNIT CHARGE, MEAN SQUARE RADIUS RPAU, AND WHOSE    C
C     CHARGE DISTRIBUTION IS A SIMPLE GAUSSIAN.                        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
C
      RP2  = RNUC(IZ)*RNUC(IZ)
      ZETA = 1.5D0/RP2
C
      GSS = 1.0D0/(ZETA*CMPF*CMPF)
      EFC =-2.0D0*R/CMPF
C
C     INTEGRATION PARAMETERS
      NTRM = 200000
      TBEG = 1.0D0
      TEND = 4.0D3
      HT   = (TEND-TBEG)/DFLOAT(NTRM)
C
      Y = 0.0D0
      DO N=0,NTRM
        T  = TBEG + HT*DFLOAT(N)
        X1 = 1.0D0/T
        X2 = DSQRT(1.0D0 - X1*X1)
        X3 = 1.0D0 + 0.5D0*X1*X1
        X4 = DEXP(GSS*X1*X1)
        X5 = DEXP(EFC*T)
        Y  = Y + EXTINT11(X1*X2*X3*X4*X5,N,NTRM)
      ENDDO
      VASYMP = 5.0D0*HT*Y/2.99376D+5
C
      RETURN
      END
C
C
      FUNCTION QUNIFRM(IZ,S)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C     QUNIFRM IS THE RADIAL CHARGE DENSITY GENERATED BY A PROTON       C
C     WITH POSITIVE UNIT CHARGE, MEAN SQUARE RADIUS RPAU, AND WHOSE    C
C     CHARGE DISTRIBUTION IS A UNIFORM BALL.                           C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      B   = DSQRT(5.0D0/3.0D0)*RNUC(IZ)
      IF(S.LE.B) THEN
        B3      = B*B*B
        QUNIFRM = 0.75/(PI*B3)
      ELSE
        QUNIFRM = 0.0D0
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION QGAUSS0(IZ,S)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C     QGAUSS0 IS THE RADIAL CHARGE DENSITY GENERATED BY A PROTON       C
C     WITH POSITIVE UNIT CHARGE, MEAN SQUARE RADIUS RPAU, AND WHOSE    C
C     CHARGE DISTRIBUTION IS A SIMPLE GAUSSIAN.                        C
C**********************************************************************C
      INCLUDE 'parameters.h'
C
      CHARACTER*5 NMDL
C
      COMMON/BNUC/ZNUC(MCT),ANUC(MCT),TFMI(MCT),AFMI(MCT),RNUC(MCT),
     &            FNUC(MCT,MFT),XNUC(MCT,MFT),NNUC(MCT),NMDL(MCT)
      COMMON/MATH/PI,PI12,PI32,PI52,PILG,TWLG,THLG,TW12,EULR
C
      RP2 = RNUC(IZ)*RNUC(IZ)
      AGS = 1.5D0/RP2
      TRM = AGS/PI     
C
      QGAUSS0 = TRM*DSQRT(TRM)*DEXP(-AGS*S*S)
C
      RETURN
      END

