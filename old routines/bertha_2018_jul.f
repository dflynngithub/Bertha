      PROGRAM BERTHA
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         BBBBBBB  EEEEEEEE RRRRRRR TTTTTTTT HH    HH    AA            C
C         BB    BB EE       RR    RR   TT    HH    HH   AAAA           C
C         BB    BB EE       RR    RR   TT    HH    HH  AA  AA          C
C         BBBBBBB  EEEEEE   RR    RR   TT    HHHHHHHH AA    AA         C
C         BB    BB EE       RRRRRRR    TT    HH    HH AAAAAAAA         C
C         BB    BB EE       RR    RR   TT    HH    HH AA    AA         C
C         BBBBBBB  EEEEEEEE RR    RR   TT    HH    HH AA    AA         C
C                                                                      C
C                 (THE PROGRAM FORMERLY KNOWN AS...)                   C
C                                                                      C
C     SSSSSS  WW         WW IIII RRRRRRR  LL      EEEEEEEE SSSSSS      C
C    SS    SS WW         WW  II  RR    RR LL      EE      SS    SS     C
C    SS       WW         WW  II  RR    RR LL      EE      SS           C
C     SSSSSS  WW    W    WW  II  RR    RR LL      EEEEEE   SSSSSS      C
C          SS WW   WWW   WW  II  RRRRRRR  LL      EE            SS     C
C    SS    SS  WW WW WW WW   II  RR    RR LL      EE      SS    SS     C
C     SSSSSS    WW     WW   IIII RR    RR LLLLLLL EEEEEEEE SSSSSS      C
C                                                                      C
C -------------------------------------------------------------------- C
C        A RELATIVISTIC MOLECULAR ELECTRONIC STRUCTURE PROGRAM         C
C            BASED ON THE ANALYTIC FINITE BASIS SET METHOD.            C
C                                                                      C
C        (c)   H.M.QUINEY, H.SKAANE, I.P.GRANT (OXFORD, 1996)          C
C              D. FLYNN (UNIMELB, 2018)                                C
C -------------------------------------------------------------------- C
C                          HAMILTONIANS (HMLT)                         C
C                          -------------------                         C
C   'NORL' NON-RELATIVISTIC HAMILTONIAN (PAULI EQUATION).              C
C   'BARE' BARE NUCLEUS DIRAC HAMILTONIAN (NO ELECTRON INTERACTION).   C
C   'DHFR' DIRAC-COULOMB HAMILTONIAN.                                  C
C   'DHFP' DIRAC-COULOMB HAMILTONIAN (+1ST ORDER BREIT).               C
C   'DHFB' DIRAC-COULOMB-BREIT HAMILTONIAN.                            C
C   'DHFQ' DIRAC-COULOMB-BREIT HAMILTONIAN WITH LEADING-ORDER QED.     C
C -------------------------------------------------------------------- C
C                   CALCULATION TREE OPTIONS (IOPT)                    C
C                   -------------------------------                    C
C    I: HARTREE-FOCK SCF CALCULATION.                                  C
C   II: MANY-BODY DIAGRAMMATIC PERTURBATION THEORY.                    C
C  III: MULTI-CONFIGURATIONAL SCF CALCULATION.                         C
C   IV: DENSITY MATRIX RENORMALISATION GROUP CALCULATION.              C
C    V: CALCULATION OF MOLECULAR EXPECTATION VALUES.                   C
C   VI: VISUALS (ELECTROMAGNETIC FIELDS, POTENTIALS, FORM FACTORS).    C
C -------------------------------------------------------------------- C
C                          TABLE OF CONTENTS                           C
C                          -----------------                           C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C   [4] ATOMIC HARTREE-FOCK: AVERAGE OF CONFIG. ATOMIC SCF.            C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTRE HARTREE-FOCK SCF.          C
C   [6] ONE-CENTRE ROUTINES: ATOMIC INTEGRALS FOR MOLECULAR PURPOSES.  C
C   [7] MULTI-CONFIG: MANY-CENTRE MULTICONFIG. SCF CALCULATIONS.       C
C   [8] DMRG: DENSITY MATRIX RENORMALISATION GROUP CALCULATIONS.       C
C   [9] MBPT: CORRELATION ENERGY CALCULATION ROUTINES.                 C
C  [10] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C  [11] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C  [12] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C  [13] EQ-COEFFS: FINITE BASIS OVERLAP SPIN STRUCTURE FACTORS.        C
C  [14] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C**********************************************************************C
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/TCPU/TTOT,TATM,TSCF,TMPT,TMCF,TDMG,TPRP,TPLT
C
C     START OF BERTHA RUN-TIME
      CALL CPU_TIME(T0)
C
C     READ DATA FROM USER-SPECIFIED INPUT FILE
      CALL CARDIN
C
C     OPEN FILE FOR TERMINAL RECORD
      OPEN(UNIT=7,FILE=TRIM(OUTFL)//'.out',STATUS='UNKNOWN')
C
C     PRINT SUMMARY OF INPUT DATA
      CALL INPUT
C
C     PRINT MEMORY ALLOCATION SUMMARY
      CALL MEMORY
C
C     INTER-ATOMIC ANGLES AND NUCLEAR REPULSION ENERGY
      CALL NUCGEOM
C
C     FOCK MATRIX SYMMETRY TYPE INDICES
      CALL FOCKIND
C
C     CARTESIAN EXPANSION INDICES FOR BASIS FUNCTION OVERLAP PAIRS
      CALL CARTIND
C
C     ATOMIC HARTREE-FOCK SCF ROUTINE
      CALL CPU_TIME(T1)
      IF(INEW.EQ.0) THEN
        CALL ATOMIC
      ENDIF
      CALL CPU_TIME(T2)
      TATM = T2-T1
C
C     MOLECULAR HARTREE-FOCK SCF ROUTINE
      IF(INEW.EQ.0.OR.IOPT.EQ.1) THEN
C        IF(IMOL.NE.0) THEN
          CALL HFSCF
C        ENDIF
      ENDIF
      CALL CPU_TIME(T3)
      TSCF = T3-T2
C
C     MANY-BODY DIAGRAMMATIC PERTURBATION THEORY
      IF(IOPT.EQ.2) THEN
        CALL MBPT
      ENDIF
      CALL CPU_TIME(T4)
      TMPT = T4-T3
C
C     MULTI-CONFIGURATIONAL SELF CONSISTENT FIELD CALCULATION
      IF(IOPT.EQ.3) THEN
        CALL MCSCF
      ENDIF
      CALL CPU_TIME(T5)
      TMCF = T5-T4
C
C     DENSITY MATRIX RENORMALISATION GROUP CALCULATION
      IF(IOPT.EQ.4) THEN
        CALL DMRG
      ENDIF
      CALL CPU_TIME(T6)
      TDMG = T6-T5
C
C     ONE-BODY HAMILTONIAN INTERACTIONS FROM A CONVERGED SOLUTION
      IF(IOPT.EQ.5) THEN
        CALL PT1BODY
      ENDIF
      CALL CPU_TIME(T7)
      TPRP = T7-T6
C
C     ELECTROMAGNETIC FIELDS AND POTENTIALS
      IF(IOPT.EQ.6) THEN
        CALL FIELDS
      ENDIF
      CALL CPU_TIME(T8)
      TPLT = T8-T7
C
C     END OF BERTHA RUN-TIME
      TTOT = T8-T0
C
C     PRINT SUMMARY OF OUTPUT DATA
      CALL OUTPUT
C
C     CLOSE FILE FOR TERMINAL RECORD
      CLOSE(UNIT=7)
C
C     SUCCESSFUL EXIT
      END PROGRAM
C
C
C**********************************************************************C
C ==================================================================== C
C   [1] INPUT/OUTPUT: READ FROM INPUT FILE AND SUMMARISE DATA.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] CARDIN: READ MOLECULAR DATA FROM A USER-SPECIFIED FILE.        C
C   [B] INPUT: WRITE A SUMMARY OF DATA INPUT OPTIONS TO TERMINAL.      C
C   [C] MEMORY: WRITE A SUMMARY OF MEMORY REQUIREMENTS OF BIG ARRAYS.  C
C   [D] OUTPUT: WRITE A SUMMARY OF TOTAL CALCULATION STATS/DATA.       C
C**********************************************************************C
C
C
      SUBROUTINE CARDIN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            CCCCCC     AA    RRRRRRR  DDDDDDD IIII NN    NN           C
C           CC    CC   AAAA   RR    RR DD    DD II  NNN   NN           C
C           CC        AA  AA  RR    RR DD    DD II  NNNN  NN           C
C           CC       AA    AA RR    RR DD    DD II  NN NN NN           C
C           CC       AAAAAAAA RRRRRRR  DD    DD II  NN  NNNN           C
C           CC    CC AA    AA RR    RR DD    DD II  NN   NNN           C
C            CCCCCC  AA    AA RR    RR DDDDDDD IIII NN    NN           C
C                                                                      C
C                          INPUT ROUTINE FOR                           C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  CARDIN READS AND PREPARES DATA FROM A USER-SPECIFIED INPUT FILE.    C
C  THIS IS ALSO WHERE ATOMIC ELEMENT NAMES AND CV ARE SPECIFIED.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*1  DUMLIN
      CHARACTER*2  ELMT(120)
      CHARACTER*4  HMLT
      CHARACTER*7  HMINT(10),PTYPE(10)
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FILL/NCNF(MCT,MKP,MKP+1),NLVL(MCT,MKP),IFILL(MCT)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(3),SHLV
      COMMON/MDLV/ELMT
      COMMON/PLOT/NPTYPE,PTYPE
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/PT1B/NHMINT,HMINT
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
      DATA CV/137.0359898D0/
C     DATA CV/137.0359990D0/ CODATA 2010 MEASUREMENT
      DATA ELMT/'H' ,'He','Li','Be','B' ,'C' ,'N' ,'O' ,'F' ,'Ne',
     &          'Na','Mg','Al','Si','P' ,'S' ,'Cl','Ar','K' ,'Ca',
     &          'Sc','Ti','V' ,'Cr','Mn','Fe','Co','Ni','Cu','Zn',
     &          'Ga','Ge','As','Se','Br','Kr','Rb','Sr','Y' ,'Zr',
     &          'Nb','Mo','Tc','Ru','Rh','Pd','Ag','Cd','In','Sn',
     &          'Sb','Te','I' ,'Xe','Cs','Ba','La','Ce','Pr','Nd',
     &          'Pm','Sm','Eu','Gd','Tb','Dy','Ho','Er','Tm','Yb',
     &          'Lu','Hf','Ta','W' ,'Re','Os','Ir','Pt','Au','Hg',
     &          'Tl','Pb','Bi','Po','At','Rn','Fr','Ra','Ac','Th',
     &          'Pa','U' ,'Np','Pu','Am','Cm','Bk','Cf','Es','Fm',
     &          'Md','No','Lr','Rf','Db','Sg','Bh','Hs','Mt','Ds',
     &          'Rg','Cn','Nh','Fl','Mc','Lv','Ts','Og','Ue','Un'/
C
C     LINK THE OPENMP ROUTINE LIBRARY
      INCLUDE 'omp_lib.h'
C
C**********************************************************************C
C     MOLECULE NAME AND CALCULATION TYPE                               C
C**********************************************************************C
C
C     MOLECULE LABEL
      READ(5, *) DUMLIN
      READ(5, *) MOLCL
C
C     CHOICE OF HAMILTONIAN HMLT: NORL, BARE, DHFR, DHFP, DHFB OR DHFQ
10    FORMAT(A4)
      READ(5, *) DUMLIN
      READ(5,10) HMLT
C
C     ALLOW VALID HAMILTONIANS TO PASS
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR'.OR.
     &   HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') GOTO 20
C
C     UNKNOWN HAMILTONIAN - ABNORMAL EXIT
      WRITE(6, *) 'In CARDIN: unknown HMLT value. HMLT = ',HMLT
      WRITE(7, *) 'In CARDIN: unknown HMLT value. HMLT = ',HMLT
      STOP
C
20    CONTINUE
C
C     WAVE FUNCTION FILE NAME
      WFNFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'.wfn'
C
      READ(5, *) DUMLIN
      READ(5, *) IOPT
C
C     ENSURE USER HAS SELECTED VALID CHOICE OF IOPT
      IF(IOPT.LT.1.OR.IOPT.GT.6) THEN
        WRITE(6, *) 'In CARDIN: invalid calculation tree. ',IOPT
        WRITE(7, *) 'In CARDIN: invalid calculation tree. ',IOPT
        STOP
      ENDIF
C
C     OUTPUT FILE NAME
      IF(IOPT.EQ.1) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_HFSCF'
      ELSEIF(IOPT.EQ.2) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_MBPT'
      ELSEIF(IOPT.EQ.3) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_MCSCF'
      ELSEIF(IOPT.EQ.4) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_DMRG'
      ELSEIF(IOPT.EQ.5) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_EXPVL'
      ELSEIF(IOPT.EQ.6) THEN
        OUTFL = 'output/'//TRIM(MOLCL)//'_'//HMLT//'_PLOTS'
      ENDIF
C
C     NEW START(0), RESUME(1)
      READ(5, *) DUMLIN
      READ(5, *) INEW
C
C     E-COEFFICIENTS BY BATCH (0), TO LARGE EXTERNAL FILE (1)
      READ(5, *) DUMLIN
      READ(5, *) IEQS
C
C     SERIAL CALCULATION (0), OPENMP PARALLEL ENABLED (1)
      READ(5, *) DUMLIN
      READ(5, *) IPAR
C
C     MAX. NUMBER OF THREADS
C     ICOR = OMP_GET_NUM_PROCS()
      ICOR = 1
C
C**********************************************************************C
C     ATOMIC CENTRES AND BASIS FUNCTIONS                               C
C**********************************************************************C
C
C     BASIS SET TYPE: GEOMETRIC (1) OR OPTIMISED (2)
      READ(5, *) DUMLIN
      READ(5, *) INTYPE
C
C     NUMBER OF ATOMIC CENTRES
      READ(5, *) DUMLIN
      READ(5, *) NCNT
C
C     CHECK THAT NCNT CAN BE SUPPORTED BY SYSTEM PARAMETERS
      IF(NCNT.GT.MCT) THEN
        WRITE(6, *) 'In CARDIN: number of centres exceeds MCT.',MCT
        WRITE(7, *) 'In CARDIN: number of centres exceeds MCT.',MCT
        STOP
      ENDIF
C
C     SPECIFY ATOM OR MOLECULE
      IF(NCNT.EQ.1) THEN
        IMOL = 0
      ELSE
        IMOL = 1
      ENDIF
C
C     INITIALISE MAXIMUM LQN AND DIMENSION COUNTERS
      LBIG = 0
      NDIM = 0
C
C     LOOP OVER ATOMIC CENTRES
      DO ICNT=1,NCNT
C
C       CARTESIAN COORDINATES OF THIS CENTRE
        READ(5, *) DUMLIN
        READ(5, *) (BXYZ(J,ICNT),J=1,3)
C
C       ZNUC, ATOMIC MASS, MAXIMUM LQN AND ATOMIC CHARGE
        READ(5, *) DUMLIN
        READ(5, *) IZNC(ICNT),AMSS(ICNT),LMAX(ICNT),IQNC(ICNT)
C
C       CHECK THAT LMAX CAN BE SUPPORTED BY SYSTEM PARAMETERS
        IF(2*LMAX(ICNT)+1.GT.MKP) THEN
          WRITE(6, *) 'In CARDIN: LMAX runs outside MKP storage.'
          WRITE(7, *) 'In CARDIN: LMAX runs outside MKP storage.'
          STOP
        ENDIF
C
C       AUFBAU FILLING FOR THIS CENTRE: AUTOMATIC (0) OR MANUAL (1)
        READ(5, *) DUMLIN
        READ(5, *) IFILL(ICNT)
C
C       IF FILLING IS MANUAL, IMPORT ATOMIC ELECTRON CONFIGURATION
        IF(IFILL(ICNT).NE.0) THEN
          READ(5, *) DUMLIN
          DO L=1,LMAX(ICNT)+1
            READ(5, *) NLVL(ICNT,L),(NCNF(ICNT,L,N),N=1,NLVL(ICNT,L))
          ENDDO
        ENDIF
C
C       NUMBER OF KAPPA VALUES FOR THIS ATOM
        NKAP(ICNT) = 2*LMAX(ICNT)+1
C
C       NUCLEAR CHARGE AS A REAL VALUE
        ZNUC(ICNT) = DFLOAT(IZNC(ICNT))
C
C       GAUSSIAN WIDTH PARAMETER FOR NUCLEAR CHARGE
        IF(IZNC(ICNT).EQ.1) THEN
          CNUC(ICNT) = 2.1248239171D+09
        ELSEIF(IZNC(ICNT).EQ.8) THEN
          CNUC(ICNT) = 5.8631436655D+08
        ELSE
          CDEN = AMSS(ICNT)**(1.0D0/3.0D0)
          CDEN = 0.836D+00*CDEN + 0.57D+00
          CDEN = 0.529177249D+00/CDEN
          CNUC(ICNT) = 1.50D+10*CDEN*CDEN
        ENDIF
C
C       UPDATE OVERALL MAXIMUM OCCURRING LQN
        IF(LMAX(ICNT).GT.LBIG) LBIG = LMAX(ICNT)
C
C       INITIATE IF STATEMENT FOR TYPE OF BASIS FUNCTION
        READ(5, *) DUMLIN
C
C       GEOMETRIC BASIS FUNCTIONS
        IF(INTYPE.EQ.1) THEN
C
C         GENERATE THE EVEN TEMPERED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX(ICNT)
C
C           READ GENERATING PARAMETERS A, B AND NFUNCT
            READ(5, *) APARAM,BPARAM,NFNC(LQN+1,ICNT)
C
C           GENERATE NFUNCT BASIS EXPONENTS USING VARIABLE ZETA
            ZETA = APARAM
            DO IBAS=1,NFNC(LQN+1,ICNT)
              BSET(IBAS,LQN+1,ICNT) = ZETA
              ZETA = ZETA*BPARAM
            ENDDO
C
C           CHECK THAT NFUNCT CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN+1,ICNT).GT.MBS) THEN
              NOOPS = NFNC(LQN+1,ICNT)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
          ENDDO
C
C       OPTIMISED EXPONENTS FROM A RECORDED LIST
        ELSEIF(INTYPE.EQ.2) THEN
C
C         READ IN THE OPTIMISED ORBITAL EXPONENTS FOR EACH LQN
          DO LQN=0,LMAX(ICNT)
C
C           READ NUMBER OF BASIS FUNCTIONS
            READ(5, *) NFNC(LQN+1,ICNT)
C
C           CHECK THAT THIS CAN BE SUPPORTED BY SYSTEM PARAMETERS
            IF(NFNC(LQN+1,ICNT).GT.MBS) THEN
              NOOPS = NFNC(LQN+1,ICNT)
              WRITE(6, *) 'In CARDIN: too many basis functions.',NOOPS
              WRITE(7, *) 'In CARDIN: too many basis functions.',NOOPS
              STOP
            ENDIF
C
C           READ BASIS EXPONENTS FROM A LIST
            DO IBAS=1,NFNC(LQN+1,ICNT)
              READ(5, *) BSET(IBAS,LQN+1,ICNT)
            ENDDO
C
          ENDDO
C
C       END IF STATEMENT FOR TYPE OF BASIS FUNCTION
        ENDIF
C
C       LOOP OVER ALL LQNS IN THIS CENTRE AND ADD TO FOCK DIMENSION
        DO LQN=0,LMAX(ICNT)
C
C         EXTEND DIMENSION OF FOCK MATRIX
          NDIM = NDIM + 4*(2*LQN+1)*NFNC(LQN+1,ICNT)
C
C         ASSIGN KQN VALUES
          IF(LQN.NE.0) THEN
            KAPA(2*LQN  ,ICNT) = LQN
          ENDIF
          KAPA(2*LQN+1,ICNT) =-LQN-1
C
        ENDDO
C
C     END LOOP OVER ATOMIC CENTRES
      ENDDO
C
C     TOTAL DIMENSION DEPENDING ON CHOICE OF HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
        NDIM = NDIM/2
        NSKP = 0
      ELSE
        NSKP = NDIM/2
      ENDIF
C
C     CHECK THAT SYSTEM PARAMETERS CAN SUPPORT NDIM
      IF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        WRITE(7, *) 'In CARDIN: matrix dimension exceeds maximum.',NDIM
        STOP
      ENDIF
C
C**********************************************************************C
C     CLOSED/OPEN SHELL DETAILS                                        C
C**********************************************************************C
C
C     NUMBER OF CLOSED- AND OPEN-SHELL ELECTRONS AND TOTAL ELECTRONS
      READ(5, *) DUMLIN
      READ(5, *) NCLS,NOPN,NOELEC
C
C     TOTAL NUMBER OF ELECTRONS IN SYSTEM
C     DFNOTE: THIS IS A HACK FOR NOW
      NOCC = NCLS + NOPN
      NVRT = NDIM - NSKP - NOCC
C
C     NOCC = 0
C     DO IZ=1,NCNT
C       NOCC = NOCC + IZNC(IZ) - IQNC(IZ)
C     ENDDO
C
C     INITIATE IF STATEMENT DEPENDING ON CLOSED/OPEN SHELLS

C     OPEN-SHELL MOLECULE
      goto 555
C     DFNOTE: ENABLE THIS OPTION
      IF(NOPN.NE.0) THEN
C
C       FRACTIONAL OCCUPANCY OF THE OPEN SHELL
        FOPN = DFLOAT(NOELEC)/DFLOAT(NOPN)
C
C       LABELS FOR THE OPEN SHELL
        READ(5, *) DUMLIN
        READ(5, *) ACFF,BCFF,(IOPN(M),M=1,NOPN)
C
C       PRINT THE LABELS FOR THE CLOSED-SHELL SPINORS USING KNOWN
C       IDENTITY OF THE OPEN-SHELL SPINORS
        JCL = 1
        JOP = 1
        DO JCOUNT=1,NOCC
C
C         APPLY LABEL TO EACH ORBITAL
          IF(JCOUNT.NE.IOPN(JOP)) THEN
            ICLS(JCL) = JCOUNT
            JCL = JCL + 1
          ELSE
            JOP = JOP + 1
          ENDIF
C
        ENDDO
C
C     CLOSED-SHELL MOLECULE
      ELSE
C
C       LABEL THE CLOSED-SHELL ELECTRONS
        DO JCL=1,NCLS
          ICLS(JCL) = JCL
        ENDDO
C
C     END IF STATEMENT FOR CLOSED/OPEN SHELLS
      ENDIF
C
555   continue
C
C     ALL SPINORS ARE CLOSED
      DO JCL=1,NCLS
        ICLS(JCL) = JCL
      ENDDO
C
C**********************************************************************C
C     LEVEL SHIFTING AND INTEGRAL INCLUSION                            C
C**********************************************************************C
C
C     LEVEL SHIFT PARAMETER FOR EACH INTEGRAL STAGE (SKAANE 4.4.3)
      READ(5, *) DUMLIN
      READ(5, *) (SHLEV(N),N=1,3)
C
C     STARTING STAGE OF INTEGRAL INCLUSION LEVEL (1-3)
      READ(5, *) DUMLIN
      READ(5, *) ILEV
C
C     REASONS TO CHANGE THE INTEGRAL INCLUSION LEVEL
      IF(HMLT.EQ.'NORL') THEN
        ILEV = 1
      ENDIF
C
      IF(NCNT.EQ.1.OR.INEW.EQ.1) THEN
        ILEV = 3
      ENDIF
C
C     IMPLEMENT THE STARTING SHIFT FACTOR
      IF(ILEV.GE.1.AND.ILEV.LE.3) THEN
        SHLV = SHLEV(ILEV)
      ELSE
        WRITE(6, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        WRITE(7, *) 'In CARDIN: invalid starting stage. ILEV = ',ILEV
        STOP
      ENDIF
C
C**********************************************************************C
C     NON-HF CALCULATION DETAILS                                       C
C**********************************************************************C
C
C     EXPECTATION VALUE CALCULATIONS: ORTHGNL,MAGDIPL ETC
      IF(IOPT.EQ.5) THEN
C
C       READ NUMBER OF EXPECTATION VALUES
        READ(5, *) DUMLIN
        READ(5, *) NHMINT
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NHMINT.LT.1.OR.NHMINT.GT.10) THEN
          WRITE(6, *) 'In CARDIN: invalid number of expectation values.'
          WRITE(7, *) 'In CARDIN: invalid number of expectation values.'
          STOP
        ENDIF
C
C       READ IN EACH INTERACTION HAMILTONIAN
        DO N=1,NHMINT
          READ(5, *) HMINT(N)
        ENDDO
C
      ENDIF
C
C     DATA PLOTTING: AMPLITUDES, EM FIELDS AND POTENTIALS
      IF(IOPT.EQ.6) THEN
C
C       READ NUMBER OF PLOT TYPES
        READ(5, *) DUMLIN
        READ(5, *) NPTYPE
C
C       PLACE LIMIT ON POSSIBLE NUMBER OF THEM
        IF(NPTYPE.LT.1.OR.NPTYPE.GT.10) THEN
          WRITE(6, *) 'In CARDIN: invalid number of plot types.'
          WRITE(7, *) 'In CARDIN: invalid number of plot types.'
          STOP
        ENDIF
C
C       READ IN EACH PLOT TYPE
        DO N=1,NPTYPE
          READ(5, *) PTYPE(N)
        ENDDO
C
      ENDIF
C
C**********************************************************************C
C     READ IN ANY EXTERNAL DATA FILES                                  C
C**********************************************************************C
C
C     READ IN A WAVE FUNCTION FILE IF PROMPTED
      IF(INEW.EQ.1) THEN
        OPEN(UNIT=8,FILE=WFNFL,STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          READ(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE INPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               IIII NN    NN PPPPPPP  UU    UU TTTTTTTT               C
C                II  NNN   NN PP    PP UU    UU    TT                  C
C                II  NNNN  NN PP    PP UU    UU    TT                  C
C                II  NN NN NN PP    PP UU    UU    TT                  C
C                II  NN  NNNN PPPPPPP  UU    UU    TT                  C
C                II  NN   NNN PP       UU    UU    TT                  C
C               IIII NN    NN PP        UUUUUU     TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  INPUT PRINTS MOLECULAR DATA INPUT OPTIONS TO THE TERMINAL.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MCT=4,MBS=26,MKP=9)
C
      CHARACTER*4  HMLT
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TSCF/TSCFS(33)
      COMMON/TMMD/TMMDS(8)
C
C     INITIALISE TIME COUNTERS
      DO NT=1,32
        TSCFS(NT) = 0.0D0
      ENDDO
C
      DO NT=1,8
        TMMDS(NT) = 0.0D0
      ENDDO
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',30),'INPUT SUMMARY'
      WRITE(7, *) REPEAT(' ',30),'INPUT SUMMARY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     TITLE FOR INPUT OPTIONS
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',21),'Calculation tree and data files'
      WRITE(7, *) REPEAT(' ',21),'Calculation tree and data files'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     CALCULATION TREE
      IF(IOPT.EQ.1) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',43),'Hartree-Fock'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',43),'Hartree-Fock'
      ELSEIF(IOPT.EQ.2) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',51),'MBPT'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',51),'MBPT'
      ELSEIF(IOPT.EQ.3) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',50),'MCSCF'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',50),'MCSCF'
      ELSEIF(IOPT.EQ.4) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',51),'DMRG'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',51),'DMRG'
      ELSEIF(IOPT.EQ.5) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',44),'Expct. vals'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',44),'Expct. vals'
      ELSEIF(IOPT.EQ.6) THEN
        WRITE(6, *) 'Calculation tree:',REPEAT(' ',47),'Plotting'
        WRITE(7, *) 'Calculation tree:',REPEAT(' ',47),'Plotting'
      ENDIF
C
C     PRINT THE HAMILTONIAN OPTION
      WRITE(6, *) 'Hamiltonian type:',REPEAT(' ',51),HMLT
      WRITE(7, *) 'Hamiltonian type:',REPEAT(' ',51),HMLT
C
C     CONFIRM SOLUTION SPACE DIMENSION OR EXIT
      IF(NDIM.LE.MDM) THEN
        WRITE(6, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
        WRITE(7, *) 'Fock matrix dimension: ',REPEAT(' ',37),NDIM
      ELSEIF(NDIM.GT.MDM) THEN
        WRITE(6, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        WRITE(7, *) 'In INPUT: matrix dimension too big. NDIM = ',NDIM
        STOP
      ENDIF
C
C     NEW START OR READ IN HFSCF EXPANSION COEFFICIENTS
      IF(INEW.EQ.0) THEN
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',44),'New start'
      ELSE
        WRITE(6, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
        WRITE(7, *) 'SCF density matrix:',REPEAT(' ',46),'Read in'
      ENDIF
C
C     E-COEFFICIENT CALCULATION
      IF(IEQS.EQ.0) THEN
        WRITE(6, *) 'E-coefficients:',REPEAT(' ',49),'By batch'
        WRITE(7, *) 'E-coefficients:',REPEAT(' ',49),'By batch'
      ELSE
        WRITE(6, *) 'E-coefficients:',REPEAT(' ',45),'Save to file'
        WRITE(7, *) 'E-coefficients:',REPEAT(' ',45),'Save to file'
      ENDIF
C
C     OPENMP PARALLEL OPTION
      IF(IPAR.EQ.0) THEN
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',41),'Disabled'
      ELSE
        WRITE(6, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(7, *) 'OpenMP parallel option:',REPEAT(' ',42),'Enabled'
        WRITE(6, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),ICOR
        WRITE(7, *) 'OpenMP thread limit:'   ,REPEAT(' ',40),ICOR
      ENDIF
C
C     SECTION FOR FILE NAMES
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     PRINT INPUT FILE NAME
      LF = LEN(TRIM(MOLCL))
      WRITE(6, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
      WRITE(7, *) 'Molecule name:',REPEAT(' ',58-LF),TRIM(MOLCL)
C
C     PRINT FILE OUTPUT NAMES
      LN = LEN(TRIM(OUTFL))
      WRITE(6, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
      WRITE(7, *) 'Output file name: ',REPEAT(' ',54-LN),TRIM(OUTFL)
C
C     RECORD TIME AT BEGINNING OF CALCULATION
      CALL CPU_TIME(TBEG)
      CALL TIMENOW(STAMP)
      WRITE(6, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
      WRITE(7, *) 'Time at BERTHA initiation:',REPEAT(' ',26),STAMP
C
C     END OF INPUT SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE MEMORY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RRRRRRR  YY    YY      C
C     MMM     MMM EE       MMM     MMM OO    OO RR    RR YY    YY      C
C     MMMM   MMMM EE       MMMM   MMMM OO    OO RR    RR  YY  YY       C
C     MM MM MM MM EEEEEE   MM MM MM MM OO    OO RR    RR   YYYY        C
C     MM  MMM  MM EE       MM  MMM  MM OO    OO RRRRRRR     YY         C
C     MM   M   MM EE       MM   M   MM OO    OO RR    RR    YY         C
C     MM       MM EEEEEEEE MM       MM  OOOOOO  RR    RR    YY         C
C                                                                      C
C -------------------------------------------------------------------- C
C  MEMORY SUMMARISES THE SIZE AND MEMORY REQUIREMENTS OF BIG ARRAYS.   C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MFL=15000000,MKP=9,
     &                                            MNU=MKP+1,MAB=2*MNU+6)
C
      INTEGER*8  NCMEM,NDMEM,NEMEM,NMMEM,NRMEM,NTMEM
      INTEGER*16 NHMEM
C
      CHARACTER*4 HMLT
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
C
C     TITLE FOR MEMORY SUMMARY
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Approx. system memory allocation'
      WRITE(7, *) REPEAT(' ',20),'Approx. system memory allocation'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     APPROXIMATE THE MEMORY STORAGE ALLOCATION
      NCMEM = 2*SIZE(COEF)
      NDMEM = 2*SIZE(DENC) + 2*SIZE(DENO) + 2*SIZE(DENT)
      NEMEM = SIZE(E0LLFL) + SIZE(E0SSFL) + SIZE(EILSFL)
      NHMEM = 20*MFL
      NMMEM = 2*SIZE(OVAP) + 2*SIZE(HNUC) + 2*SIZE(HKIN)
     &      + 2*SIZE(VUEH) + 2*SIZE(GDIR) + 2*SIZE(GXCH)
     &      + 2*SIZE(QDIR) + 2*SIZE(QXCH) + 2*SIZE(BDIR)
     &      + 2*SIZE(BXCH) + 2*SIZE(FOCK)
      NTMEM = NCMEM + NDMEM + NEMEM + NHMEM + NMMEM
C
C     SIZES (IN GIGABYTES)
      SCMEM = NCMEM*8.0D-9
      SDMEM = NDMEM*8.0D-9
      SEMEM = NEMEM*8.0D-9
      SHMEM = NHMEM*8.0D-9
      SMMEM = NMMEM*8.0D-9
      STMEM = NTMEM*8.0D-9
C
20    FORMAT(1X,A,4X,A,19X,A,9X,A)
21    FORMAT(1X,A,6X,A,5X,I12,9X,F9.5)
      WRITE(6,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(7,20) 'COMMON','Description','Words (double)','Size (GB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(7,21) 'COEF','Expansion coeffs.          ',NCMEM,SCMEM
      WRITE(6,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(7,21) 'DENS','Density matrices           ',NDMEM,SDMEM
      WRITE(6,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(7,21) 'MTRX','Molecular Fock matrices    ',NMMEM,SMMEM
      WRITE(6,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(7,21) 'EQTT','Eq-coefficient file        ',NEMEM,SEMEM
      WRITE(6,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(7,21) 'RCTT','R-integral class file      ',NHMEM,SHMEM
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,21) '    ','Total                      ',NTMEM,STMEM
      WRITE(7,21) '    ','Total                      ',NTMEM,STMEM
C
C     END OF MEMORY SUMMARY
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE OUTPUT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  UU    UU TTTTTTTT PPPPPPP  UU    UU TTTTTTTT        C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PP    PP UU    UU    TT           C
C         OO    OO UU    UU    TT    PPPPPPP  UU    UU    TT           C
C         OO    OO UU    UU    TT    PP       UU    UU    TT           C
C          OOOOOO   UUUUUU     TT    PP        UUUUUU     TT           C
C                                                                      C
C                      EXIT SUMMARY ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  OUTPUT PRINTS A SUMMARY OF TOTAL CALCULATION DATA TO TERMINAL.      C
C**********************************************************************C
      PARAMETER(MCT=4,MBS=26,MKP=9)
C
      CHARACTER*4  HMLT
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
C
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TCPU/TTOT,TATM,TSCF,TMPT,TMCF,TDMG,TPRP,TPLT
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',30),'OUTPUT SUMMARY'
      WRITE(7, *) REPEAT(' ',30),'OUTPUT SUMMARY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME AT BERTHA EXIT
      CALL TIMENOW(STAMP)
C
C     PRINT TABLE OF DATA
20    FORMAT(1X,A,26X,A)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',28),'CPU time summary'
      WRITE(7, *) REPEAT(' ',28),'CPU time summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(INEW.EQ.0) THEN
        WRITE(6,20) 'Atomic Hartree-Fock SCF:      ',HMS(TATM)
        WRITE(7,20) 'Atomic Hartree-Fock SCF:      ',HMS(TATM)
      ENDIF
      IF(IOPT.EQ.1.OR.INEW.EQ.0) THEN
        WRITE(6,20) 'Molecular Hartree-Fock SCF:   ',HMS(TSCF)
        WRITE(7,20) 'Molecular Hartree-Fock SCF:   ',HMS(TSCF)
      ELSEIF(IOPT.EQ.2) THEN
        WRITE(6,20) 'Many-body perturbation theory:',HMS(TMPT)
        WRITE(7,20) 'Many-body perturbation theory:',HMS(TMPT)
      ELSEIF(IOPT.EQ.3) THEN
        WRITE(6,20) 'Multi-configurational SCF:    ',HMS(TMCF)
        WRITE(7,20) 'Multi-configurational SCF:    ',HMS(TMCF)
      ELSEIF(IOPT.EQ.4) THEN
        WRITE(6,20) 'Density matrix renorm. group: ',HMS(TDMG)
        WRITE(7,20) 'Density matrix renorm. group: ',HMS(TDMG)
      ELSEIF(IOPT.EQ.5) THEN
        WRITE(6,20) 'Property calculation:         ',HMS(TPRP)
        WRITE(7,20) 'Property calculation:         ',HMS(TPRP)
      ELSEIF(IOPT.EQ.6) THEN
        WRITE(6,20) 'Plotting:                     ',HMS(TPLT)
        WRITE(7,20) 'Plotting:                     ',HMS(TPLT)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(7,20) 'Total CPU time:               ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     SUCCESSFUL EXIT MESSAGE
      WRITE(6, *)
      WRITE(7, *)
      WRITE(6, *) 'Successful BERTHA exit at:',REPEAT(' ',26),STAMP
      WRITE(7, *) 'Successful BERTHA exit at:',REPEAT(' ',26),STAMP
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [2] LABELS: MOLECULAR GEOMETRY AND FOCK MATRIX BLOCK ADDRESSES.    C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] NUCGEOM: BOND DISTANCES AND NUCLEAR REPULSION ENERGY.          C
C   [B] FOCKIND: CALCULATE ADDRESSES OF FOCK MATRIX FOR BASIS QN'S.    C
C   [C] CARTIND: GENERATES INDICES FOR EQ-COEFFS AND R-INTEGRALS.      C
C   [D] AUFBAU: DETERMINES GROUND STATE ATOMIC ELECTRON CONFIG.        C
C   [E] SPECTRM0: ATOMIC SPECTRUM W/ EIGENVALUES AND RADIAL MOMENTS.   C
C   [E] SPECTRM: MOLECULAR SPECTRUM W/ EIGENVALUES AND TERM SYMBOLS.   C
C   [F] ELLTERM: GIVES THE CHARACTER CORRESPONDING TO LQN VALUE L.     C
C   [G] ROTATE: PERFORM TWO EULER ROTATIONS ON ALL ATOMIC CENTRES.     C
C   [H] MMPROD: PRODUCT OF TWO SQUARE ARRAYS OF DOUBLES.               C
C   [I] MVPROD: PRODUCT OF A SQUARE MATRIX AND VECTOR OF DOUBLES.      C
C   [K] HMS: RETURNS A QUOTED TIME IN SECONDS AS 'MIN-SEC'.            C
C   [J] MS: RETURNS A QUOTED TIME IN SECONDS AS 'HR-MIN-SEC'.          C
C   [L] TIMENOW: RETURNS A DATE STRING FOR THE CPU TIME.               C
C**********************************************************************C
C
C
      SUBROUTINE NUCGEOM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  NN    NN UU    UU  CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C  NNN   NN UU    UU CC    CC GG    GG EE       OO    OO MMM     MMM   C
C  NNNN  NN UU    UU CC       GG       EE       OO    OO MMMM   MMMM   C
C  NN NN NN UU    UU CC       GG       EEEEEE   OO    OO MM MM MM MM   C
C  NN  NNNN UU    UU CC       GG   GGG EE       OO    OO MM  MMM  MM   C
C  NN   NNN UU    UU CC    CC GG    GG EE       OO    OO MM   M   MM   C
C  NN    NN  UUUUUU   CCCCCC   GGGGGG  EEEEEEEE  OOOOOO  MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCGEOM TRANSLATES AND ROTATES A MOLECULE IN A WAY THAT IS BEST     C
C  SUITED TO EFFICIENT COMPUTATION, IDENTIFIES MOLECULAR SHAPE AND     C
C  BOND DISTANCES, AND CALCULATES NUCLEAR REPULSION ENERGY.            C
C -------------------------------------------------------------------- C
C  DFNOTE: THE TSYM PACKAGE (WERNER 1996) CAN BE DIRECTLY IMPLEMENTED  C
C          AT THIS POINT AND PERFORMS POINT GROUP SYMMETRY ANALYSIS.   C
C          THIS RESULTS IN A HAMILTONIAN MATRIX OF BLOCK STRUCTURE     C
C          ACCORDING TO IRREPS, AND SPEEDS UP SCF CALCULATIONS.        C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=4,MKP=9)
C
      CHARACTER*2 ELMT(120),ELA,ELB,ELC
      CHARACTER*8 SHAPE,SPCES
C
      DIMENSION XYZ(3,MCT),DIST(MCT),CENT(3),IZAD(MCT,3)
C
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/GEOM/SHAPE
      COMMON/MDLV/ELMT
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
      DATA PI/3.1415926535897932D0/
C
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',25),'MOLECULAR COORDINATES'
      WRITE(7, *) REPEAT(' ',25),'MOLECULAR COORDINATES'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     UNCOMMENT THIS FLAG TO DISABLE ROTATION/TRANSLATION
      GOTO 500
C
C**********************************************************************C
C     IDENTIFY LARGEST ATOMIC CENTRES                                  C
C**********************************************************************C
C
C     IDENTIFY THE THREE LARGEST NUCLEAR CHARGES
      LZ1 = 0
      LZ2 = 0
      LZ3 = 0
      DO N=1,NCNT
        IZ = IZNC(N)
        IF(IZ.GT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = LZ1
          LZ1 = IZ
        ELSEIF(IZ.GT.LZ2.AND.IZ.LT.LZ1) THEN
          LZ3 = LZ2
          LZ2 = IZ
        ELSEIF(IZ.GT.LZ3.AND.IZ.LT.LZ2) THEN
          LZ3 = IZ
        ENDIF
      ENDDO
C
C     COUNT CENTRES WITH TOP THREE NUCLEAR CHARGES
      NZ1 = 0
      NZ2 = 0
      NZ3 = 0
      DO N=1,NCNT
        IZ = IZNC(N)
        IF(IZ.EQ.LZ1) THEN
          NZ1 = NZ1 + 1
          IZAD(NZ1,1) = N
        ELSEIF(IZ.EQ.LZ2) THEN
          NZ2 = NZ2 + 1
          IZAD(NZ2,2) = N
        ELSEIF(IZ.EQ.LZ3) THEN
          NZ3 = NZ3 + 1
          IZAD(NZ3,3) = N
        ENDIF
      ENDDO
C
C     DESIGNATE SPECIES OF MOLECULE
      IF(NZ2.EQ.0) THEN
        SPCES = 'HOMONUC.'
      ELSE
        SPCES = 'HTRONUC.'
      ENDIF
C
C**********************************************************************C
C     TRANSLATION: ORIGIN COINCIDES WITH CENTRE OF ALL HEAVY ATOMS     C
C**********************************************************************C
C
C     CALCULATE CENTRE OF ALL CHARGES LZ1
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ1
          CENT(I) = CENT(I) + BXYZ(I,IZAD(N,1))
        ENDDO
        CENT(I) = CENT(I)/NZ1
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     TRANSLATE MOLECULE BY CENT(I) AND CALCULATE DISTANCE TO ORIGIN
      DO N=1,NCNT
        DO I=1,3
          XYZ(I,N) = BXYZ(I,N) - CENT(I)
        ENDDO
        DIST(N) = DSQRT(XYZ(1,N)**2 + XYZ(2,N)**2 + XYZ(3,N)**2)
      ENDDO
C
C     ALERT THE USER IF TRANSLATION WAS SUBSTANTIAL
      IF(DCNT.GT.1.0D-4) THEN
        WRITE(6, *) 'In NUCGEOM: molecule has been translated.'
        WRITE(7, *) 'In NUCGEOM: molecule has been translated.'
      ENDIF
C
C     ONE-CENTRE (MUST BE ATOMIC)
      IF(NCNT.EQ.1) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'ATOMIC'
C
C       NO ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     FIRST ROTATION: FIX ON A ROTATION CENTRE AND ROTATE TO Z-AXIS.   C
C**********************************************************************C
C
C     IF AN LZ1 CENTRE IS ON Z-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(3,N))
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 200
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTRE THAT DOES NOT LIE ON ORIGIN
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        IF(DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 35
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTRE ALREADY ON
C     THE Z-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ2.
C
C     VECTOR CENTRE OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ2 IS ON Z-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DABS(CENT(3))
      IF(DABS(X).LT.1.0D-4.AND.DCNT.GT.1.0D-4) THEN
        GOTO 200
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON ORIGIN, FIX ON AN LZ2 NOT ON THE ORIGIN
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          IF(DIST(N).GT.1.0D-4) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 35
          ENDIF
        ENDDO
      ENDIF
C
C     LZ1 AND LZ2 ALWAYS SUFFICIENT TO DEFINE A Z ORIENTATION
C
C     SKIP POINT (ROTATION CENTRE HAS BEEN IDENTIFIED)
35    CONTINUE
C
C     CALCULATE FIRST ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
C     BETA  IS ROTATION ANGLE FROM (X,Z) TO (0,Z')
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      BETA  = DACOS(CENT(3)/DCNT)
      CALL ROTATE(XYZ,NCNT,ALPHA,BETA)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Z-AXIS ROTATION NECESSARY
200   CONTINUE
C
C     TWO-CENTRE (MUST BE DIATOMIC)
      IF(NCNT.EQ.2) THEN
C
C       DESIGNATE SHAPE
        SHAPE = 'DIATOMIC'
C
C       NO FURTHER ROTATIONS NECESSARY
        GOTO 300
C
      ENDIF
C
C**********************************************************************C
C     SECOND ROTATION: FIX ON A ROTATION CENTRE AND ROTATE TO Y-AXIS.  C
C**********************************************************************C
C
C     CHECK WHETHER MOLECULE IS LINEAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2 + XYZ(2,N)**2
        IF(TEST.GT.1.0D-6) GOTO 40
      ENDDO
      SHAPE = 'LINEAR'
      GOTO 300
40    CONTINUE
C
C     IF AN LZ1 CENTRE IS ON YZ-AXIS BUT NOT THE ORIGIN, SKIP ROTATION
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DSQRT(XYZ(2,N)**2 + XYZ(3,N)**2)
        IF(DABS(X).LT.1.0D-6.AND.DIST(N).GT.1.0D-4) THEN
          GOTO 300
        ENDIF
      ENDDO
C
C     FIX ON AN LZ1 CENTRE THAT DOES NOT LIE ON ORIGIN OR Z-AXIS
      DO NZ=1,NZ1
        N = IZAD(NZ,1)
        X = DIST(N) - DABS(XYZ(2,N))
        IF(DABS(X).GT.1.0D-4.AND.DIST(N).GT.1.0D-4) THEN
          DO I=1,3
            CENT(I) = XYZ(I,N)
          ENDDO
          DCNT = DIST(N)
          GOTO 50
        ENDIF
      ENDDO
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ1 CENTRE ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ2.
C
C     IF THERE ARE NO LZ2 CENTRES, SKIP ROTATION
      IF(NZ2.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTRE OF ALL LZ2
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ2
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ2
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ2 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTRE OF LZ2 IS NOT ON Y-AXIS, MAKE IT THE CENTRE
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTRE OF LZ2 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ2
          N = IZAD(NZ,2)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF WE HAVE MADE IT THIS FAR, THERE IS NO LZ2 CENTRE ALREADY ON
C     THE YZ-AXIS AND NO LZ1 CENTRE OFF THE ORIGIN --> MOVE TO LZ3.
C
C     IF THERE ARE NO LZ3 CENTRES, SKIP ROTATION
      IF(NZ3.EQ.0) THEN
        GOTO 300
      ENDIF
C
C     VECTOR CENTRE OF ALL LZ3
      DCNT = 0.0D0
      DO I=1,3
        CENT(I) = 0.0D0
        DO N=1,NZ3
          CENT(I) = CENT(I) + XYZ(I,IZAD(N,2))
        ENDDO
        CENT(I) = CENT(I)/NZ3
        DCNT    = DCNT + CENT(I)**2
      ENDDO
      DCNT = DSQRT(DCNT)
C
C     IF CENTRE OF LZ3 IS ON YZ-AXIS BUT NOT ORIGIN, SKIP ROTATION
      X = DCNT - DSQRT(CENT(2)**2 + CENT(3)**2)
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 300
      ENDIF
C
C     IF CENTRE OF LZ3 IS NOT ON Y-AXIS, MAKE IT THE CENTRE
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).GT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        GOTO 50
      ENDIF
C
C     IF CENTRE OF LZ3 IS ON Y-AXIS, FIX ON ONE OF THEM
      X = DCNT - DABS(CENT(2))
      IF(DABS(X).LT.1.0D-3.AND.DCNT.GT.1.0D-3) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(XYZ(2,N))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     IF CENTRE OF LZ3 IS ON ORIGIN, FIX ON ONE THAT IS OFF THE Z AXIS
      IF(DCNT.LT.1.0D-4) THEN
        DO NZ=1,NZ3
          N = IZAD(NZ,3)
          X = DIST(N) - DABS(CENT(3))
          IF(DABS(X).GT.1.0D-3.AND.DIST(N).GT.1.0D-3) THEN
            DO I=1,3
              CENT(I) = XYZ(I,N)
            ENDDO
            DCNT = DIST(N)
            GOTO 50
          ENDIF
        ENDDO
      ENDIF
C
C     SKIP POINT (ROTATION CENTRE HAS BEEN IDENTIFIED)
50    CONTINUE

C     CALCULATE ROTATION ANGLE
C     ALPHA IS ROTATION ANGLE AROUND XY TO BRING CENT TO Y=0
      RLT = DSQRT(CENT(1)**2 + CENT(2)**2)
      ALPHA = DACOS(CENT(1)/RLT)
      CALL ROTATE(XYZ,NCNT,ALPHA,0.0D0)
      WRITE(6, *) 'In NUCGEOM: molecule has been rotated.'
      WRITE(7, *) 'In NUCGEOM: molecule has been rotated.'
C
C     NO Y-AXIS ROTATION NECESSARY
300   CONTINUE
C
C     IF MOLECULE ALREADY HAS LABEL, SKIP
      IF(SHAPE.EQ.'ATOMIC'.OR.SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR')
     & GOTO 400
C
C     CHECK WHETHER MOLECULE IS PLANAR
      DO N=1,NCNT
        TEST = XYZ(1,N)**2
        IF(TEST.GT.1.0D-6) GOTO 60
      ENDDO
      SHAPE = 'PLANAR'
60    CONTINUE
C
C     NO MOLECULAR SYMMETRY
      SHAPE = 'NOSYMM'
C
400   CONTINUE
C
C     TRANSFER ALL TEMPORARY COORDINATES TO THE COMMON ARRAY
      DO N=1,NCNT
        DO I=1,3
          BXYZ(I,N) = XYZ(I,N)
        ENDDO
      ENDDO
C
C     ROTATION/TRANSLATION SKIP
500   CONTINUE
C
C**********************************************************************C
C     MOLECULAR GEOMETRY, BOND DISTANCES AND NUCLEAR REPULSION ENERGY  C
C**********************************************************************C
C
C     ATOMIC COORDINATES
20    FORMAT(13X,A)
21    FORMAT(1X,A,12X,A,14X,A,14X,A)
22    FORMAT(1X,I2,' (',A,') ',6X,F16.10,5X,F16.10,5X,F16.10)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) '  Molecular geometry A: Cartesian coordinates'
      WRITE(7,20) '  Molecular geometry A: Cartesian coordinates'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,21) 'Centre','x-coord','y-coord','z-coord'
      WRITE(7,21) 'Centre','x-coord','y-coord','z-coord'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO ICNT=1,NCNT
        ELA = ELMT(IZNC(ICNT))
        WRITE(6,22) ICNT,ELA,BXYZ(1,ICNT),BXYZ(2,ICNT),BXYZ(3,ICNT)
        WRITE(7,22) ICNT,ELA,BXYZ(1,ICNT),BXYZ(2,ICNT),BXYZ(3,ICNT)
      ENDDO
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     BOND ANGLES AND DISTANCES
30    FORMAT(21X,A)
31    FORMAT(1X,A,8X,A,12X,A,12X,A)
32    FORMAT(1X,A,2X,A,7X,F14.6)
33    FORMAT(40X,A,2X,A,2X,A,9X,F14.6)
      IF(NCNT.EQ.1) THEN
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
      ELSEIF(NCNT.GT.1) THEN
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'Molecular geometry B: R-matrix'
        WRITE(7,30) 'Molecular geometry B: R-matrix'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,31) 'C1  C2','Bond distance','C1  C2  C3','Angle (deg)'
        WRITE(7,31) 'C1  C2','Bond distance','C1  C2  C3','Angle'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
C
        ICNT = 1
        DO JCNT=2,NCNT
          ELA = ELMT(IZNC(ICNT))
          ELB = ELMT(IZNC(JCNT))
          R1X = BXYZ(1,JCNT) - BXYZ(1,ICNT)
          R1Y = BXYZ(2,JCNT) - BXYZ(2,ICNT)
          R1Z = BXYZ(3,JCNT) - BXYZ(3,ICNT)
          D1  = DSQRT(R1X*R1X + R1Y*R1Y + R1Z*R1Z)
          WRITE(6,32) ELA,ELB,D1
          WRITE(7,32) ELA,ELB,D1
C
          DO KCNT=2,JCNT-1
            ELA = ELMT(IZNC(ICNT))
            ELB = ELMT(IZNC(JCNT))
            ELC = ELMT(IZNC(KCNT))
            R2X = BXYZ(1,KCNT) - BXYZ(1,ICNT)
            R2Y = BXYZ(2,KCNT) - BXYZ(2,ICNT)
            R2Z = BXYZ(3,KCNT) - BXYZ(3,ICNT)
            D2  = DSQRT(R2X*R2X + R2Y*R2Y + R2Z*R2Z)
            SP  = (R1X*R2X + R1Y*R2Y + R1Z*R2Z)
            D12 = D1*D2
            DEG = 180.0D0/PI
            ANG = DEG*DACOS(SP/D12)
            WRITE(6,33) ELB,ELA,ELC,ANG
            WRITE(7,33) ELB,ELA,ELC,ANG
          ENDDO
          IF(JCNT.NE.NCNT) THEN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
          ENDIF
        ENDDO
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       NUCLEAR REPULSION ENERGY
        ENUC = 0.0D0
        DO ICNT=1,NCNT
          DO JCNT=1,ICNT-1
            SEP  = DSQRT((BXYZ(1,ICNT) - BXYZ(1,JCNT))**2
     #                  +(BXYZ(2,ICNT) - BXYZ(2,JCNT))**2
     #                  +(BXYZ(3,ICNT) - BXYZ(3,JCNT))**2)
            EPNT = ZNUC(ICNT)*ZNUC(JCNT)/SEP
C
CC          THIS CODE INCLUDES GAUSSIAN CHARGE STRUCTURE EFFECTS,
CC          BUT CORRECTIONS EXCEED DOUBLE FLOAT ACCURACY LIMITS...
C           EPRD = CNUC(ICNT)*CNUC(JCNT)
C           ESUM = CNUC(ICNT)+CNUC(JCNT)
C           EGAU = DSQRT(EPRD/ESUM)*SEP
C           EERF = DERF(EGAU)
C           ESEP = EPNT*EERF
C
            ESEP = EPNT
            ENUC = ENUC + ESEP

          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FOCKIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       FFFFFFFF OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C       FF      OO    OO CC    CC KK   KK   II  NNN   NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NNNN  NN DD    DD      C
C       FFFFFF  OO    OO CC       KKKKK     II  NN NN NN DD    DD      C
C       FF      OO    OO CC       KK  KK    II  NN  NNNN DD    DD      C
C       FF      OO    OO CC    CC KK   KK   II  NN   NNN DD    DD      C
C       FF       OOOOOO   CCCCCC  KK    KK IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  FOCKIND ASSIGNS INDICES FOR FOCK MATRIX BLOCKS DEPENDING ON         C
C  ICNT, KQN AND MQN QUANTUM NUMBERS OF EACH BASIS FUNCTION.           C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     QUANTUM NUMBER LABELS
      ILST = 0
      DO ICNT=1,NCNT
        DO IMV=1,(MKP+1)/2
          MQN = 2*IMV-1
C
C         LABEL MQN<0 BLOCKS
          DO KA=1,NKAP(ICNT)
            KQN = KAPA(KA,ICNT)
            IF(KQN.GT.0) THEN
              LQN = KQN
            ELSE
              LQN =-KQN-1
            ENDIF
            NBAS  = NFNC(LQN+1,ICNT)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LRGE(ICNT,KA,MQN) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = ICNT
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) =-MQN
              ENDDO
              ILST = ILST+NBAS
            ENDIF
          ENDDO
C
C         LABEL MQN>0 BLOCKS
          DO KA=1,NKAP(ICNT)
            KQN = KAPA(KA,ICNT)
            IF(KQN.GT.0) THEN
              LQN = KQN
            ELSE
              LQN =-KQN-1
            ENDIF
            NBAS  = NFNC(LQN+1,ICNT)
            MQMAX = 2*IABS(KQN)-1
            IF(MQMAX.GE.MQN) THEN
              LRGE(ICNT,KA,MQN+1) = ILST
              DO IBAS=1,NBAS
                LABICN(ILST+IBAS) = ICNT
                LABKQN(ILST+IBAS) = KQN
                LABMQN(ILST+IBAS) = MQN
              ENDDO
              ILST = ILST + NBAS
            ENDIF
          ENDDO

        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE CARTIND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        CCCCCC     AA    RRRRRRR TTTTTTTT IIII NN    NN DDDDDDD       C
C       CC    CC   AAAA   RR    RR   TT     II  NNN   NN DD    DD      C
C       CC        AA  AA  RR    RR   TT     II  NNNN  NN DD    DD      C
C       CC       AA    AA RR    RR   TT     II  NN NN NN DD    DD      C
C       CC       AAAAAAAA RRRRRRR    TT     II  NN  NNNN DD    DD      C
C       CC    CC AA    AA RR    RR   TT     II  NN   NNN DD    DD      C
C        CCCCCC  AA    AA RR    RR   TT    IIII NN    NN DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  CARTIND GENERATES INDICES FOR EQ-COEFFICIENTS AND R-INTEGRALS.      C
C**********************************************************************C
      PARAMETER(MKP=9,ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C     LOOP OVER ALL (A,B,C) SO THAT A+B+C=LAM AND APPLY ORDERED ADDRESS
      N = 0
      DO LAM=0,ML4
        DO IA=0,LAM
          DO IB=0,LAM
            DO IC=0,LAM
C
C             TEST WHETER A+B+C=LAM
              IF(IA+IB+IC.NE.LAM) GOTO 10
C
C             UPDATE ADDRESS
              N = N+1
C
C             CARTESIAN INDICES (A,B,C) AND LAM VALUE FOR THIS ADDRESS
              IVEC(N)   = IA
              JVEC(N)   = IB
              KVEC(N)   = IC
              LAMVEC(N) = LAM
C
C             GLOBAL ADDRESS FOR THIS (A,B,C) INDEX
              INABCD(IA,IB,IC) = N
C
C             SKIP POINT FOR (A,B,C) THAT DO NOT ADD TO LAM
10            CONTINUE
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE AUFBAU(IZNC,IQNC,NORB,NOCC,LQNMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            AA    UU    UU FFFFFFF BBBBBBB     AA    UU    UU         C
C           AAAA   UU    UU FF      BB    BB   AAAA   UU    UU         C
C          AA  AA  UU    UU FF      BB    BB  AA  AA  UU    UU         C
C         AA    AA UU    UU FFFFF   BBBBBBB  AA    AA UU    UU         C
C         AAAAAAAA UU    UU FF      BB    BB AAAAAAAA UU    UU         C
C         AA    AA UU    UU FF      BB    BB AA    AA UU    UU         C
C         AA    AA  UUUUUU  FF      BBBBBBB  AA    AA  UUUUUU          C
C                                                                      C
C -------------------------------------------------------------------- C
C  AUFBAU DETERMINES THE GROUND STATE ELECTRONIC CONFIGURATION OF A    C
C  NEUTRAL ATOM OF CHARGE IZNC, UP TO COMPLETE OCCUPATION WITH THE     C
C  LIMIT LQNMAX = 4 (g-ORBITALS). 220 AVAILABLE ORBITALS.              C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    LQNMAX IS THE HIGHEST LQN REQUIRED TO DESCRIBE THE GROUND STATE   C
C    NOCC SAVES THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS      C
C    NORB SAVES THE NUMBER OF ELECTRONS IN OF TYPE LQN IN SHELL N      C
C  PARAMETERS:                                                         C
C    IAUF STORES THE LQN OF ORBITALS IN ORDER OF HYDROGENIC ENERGY     C
C**********************************************************************C
      PARAMETER(MKP=9)
C
      DIMENSION NORB(MKP,MKP+1),NOCC((MKP+1)/2),IAUF((MKP+1)*(MKP+3)/4)
C
C     INITIALISE THE OCCUPIED NQN SHELL COUNTER FOR EACH LQN
      DO LQN=0,(MKP-1)/2
        NOCC(LQN+1) = 0
      ENDDO
C
C     RECORD LQNS AS THEY APPEAR IN A FULL AUFBAU COUNT UP TO LMAX
      ICT = 0
C
C     EACH LQN AS THE HIGHEST
      DO LHIGH=0,(MKP-1)/2
C
C       GET TWO DIAGONAL STRIKES FOR THIS LHIGH
        DO MDIAG=1,2
C
C         GO BACKWARDS FROM THIS LQN DOWN TO ZERO AND RECORD LQN
          DO LQN=LHIGH,0,-1
            ICT = ICT + 1
            IAUF(ICT) = LQN
          ENDDO
C
        ENDDO
C
      ENDDO
C
C     INITIALISE THE MAX LQN COUNTER
      LQNMAX = 0
C
C     INITIALISE THE NUMBER OF ELECTRONS LEFT TO FILL ORBITALS WITH
      ILEFT = IZNC-IQNC
C
C     INITIALISE LOOP OVER ORBITALS
      DO M=1,(MKP+1)*(MKP+3)/4
C
C       EXIT IF THERE ARE NO ELECTRONS LEFT TO COUNT
        IF(ILEFT.EQ.0) GOTO 20
C
C       THE LQN OF THIS ORBITAL IS STORED IN IAUF
        LQN = IAUF(M)
C
C       UPDATE THE MAX LQN COUNTER IF NECESSARY
        IF(LQN.GT.LQNMAX) THEN
          LQNMAX = LQN
        ENDIF
C
C       ADD TO THE NUMBER OF OCCUPIED NSHELLS FOR THIS LQN CLASS
        NOCC(LQN+1) = NOCC(LQN+1)+1
C
C       DETERMINE NO. OF ELECTRONS REQ'D TO FULLY OCCUPY THIS SUBSHELL
        IFULL = 4*LQN + 2
C
C       BEGIN IF STATEMENT TO DETERMINE THE SUBSHELL OCCUPATION
        IF(ILEFT.GT.IFULL) THEN
C
C         IF THERE ARE MORE ELECTRONS LEFT THAN IFULL, FILL THE SUBSHELL
          NORB(LQN+1,NOCC(LQN+1)) = IFULL
          ILEFT = ILEFT-IFULL
C
        ELSE
C
C         OTHERWISE, LEAVE ALL REMAINING ELECTRONS IN THIS NSHELL
          NORB(LQN+1,NOCC(LQN+1)) = ILEFT
          GOTO 20
C
C       END THE NSHELL IF STATEMENT
        ENDIF
C
C     END LOOP OVER ATOMIC ORBITALS
      ENDDO
20    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE SPECTRM0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  PPPPPPP   CCCCCC TTTTTTTT RRRRRRR  MM       MM  000000    C
C   SS    SS PP    PP CC    CC   TT    RR    RR MMM     MMM 00   000   C
C   SS       PP    PP CC         TT    RR    RR MMMM   MMMM 00  0000   C
C    SSSSSS  PP    PP CC         TT    RR    RR MM MM MM MM 00 00 00   C
C         SS PPPPPPP  CC         TT    RRRRRRR  MM  MMM  MM 0000  00   C
C   SS    SS PP       CC    CC   TT    RR    RR MM   M   MM 000   00   C
C    SSSSSS  PP        CCCCCC    TT    RR    RR MM       MM  000000    C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPECTRM0 SUMMARISES RESULTS OF THE AVERAGE-OVER-CONFIGURATION       C
C  ATOMIC HARTREE-FOCK SOLUTIONS IN THE USUAL DIRAC BASIS, WITH SOME   C
C  RADIAL EXPECTATION VALUES FOR EACH DEGENERATE ENERGY LEVEL.         C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MBD=2*MBS,MCT=4,MKP=9)
C
      CHARACTER*1 ELLTERM,CHS
      CHARACTER*2 ELMT(120),ELNM
      CHARACTER*4 HMLT
C
      COMPLEX*16 COEF(MDM,MDM)
C
      DIMENSION QA(MKP),NUMOCC((MKP+1)/2),NORB(MKP,MKP+1)
      DIMENSION PLTN(MCT,MKP+1,MKP),IGLB(MCT,MKP+1,MKP)
      DIMENSION RRA(MBD,MBD),RRB(MBD,MBD),RRC(MBD,MBD)
      
      DIMENSION EXL(MBS)
      DIMENSION RGLB(MCT,MKP+1,MKP,3)
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FILL/NCNF(MCT,MKP,MKP+1),NLVL(MCT,MKP),IFILL(MCT)
      COMMON/MDLV/ELMT
      COMMON/OCPD/IOCPN(MDM),IOCCM0
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C**********************************************************************C
C     SORTING SECTION: FIND ADDRESSES FOR USUAL ATOMIC ORDER           C
C**********************************************************************C
C
C     COUNTER FOR OCCUPIED ORBITALS
      IOCCML = 0
C
C     LOOP OVER NUCLEAR CENTRES IN THE MOLECULE
      DO ICNT=1,NCNT
C
C       IMPORT ATOMIC CHARGE DETAILS
        IZNV = IZNC(ICNT)
        ELNM = ELMT(IZNV)
        ICRG = IQNC(ICNT)
C
C       INITIALISE THE ORBITAL FILLING ARRAY
        DO LQN=0,MKP-1
          DO NQN=1,MKP+1
            NORB(LQN+1,NQN) = 0
          ENDDO
        ENDDO
C
C       READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
        IF(IFILL(ICNT).EQ.0) THEN
          CALL AUFBAU(IZNV,ICRG,NORB,NUMOCC,LMXCONF)
        ELSE
          LMXCONF = LMAX(ICNT)
          DO LQN=0,LMXCONF
            NUMOCC(LQN+1) = NLVL(ICNT,LQN+1)
            DO NQN=1,NLVL(ICNT,LQN+1)
              NORB(LQN+1,NQN) = NCNF(ICNT,LQN+1,NQN)
            ENDDO
          ENDDO
        ENDIF
C
C       LOOP OVER LQNS
        DO LQN=0,LMXCONF
C
C         RECORD LQNA VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
          NBAS = NFNC(LQN+1,ICNT)
          DO IBAS=1,NBAS
            EXL(IBAS) = BSET(IBAS,LQN+1,ICNT)
          ENDDO
C
C         FRACTIONAL SUBSHELL OCCUPANCY
          DO NQN=1,NUMOCC(LQN+1)
            QA(NQN) = DFLOAT(NORB(LQN+1,NQN))/DFLOAT(4*LQN+2)
          ENDDO
C
C         POSITIVE KQN CHOICE (APPLIES ONLY FOR LQN>0)
C
          IF(LQN.EQ.0.OR.HMLT.EQ.'NORL') GOTO 110
C
C         CALCULATE BATCH OF <1/R>, <R> AND INTEGRALS
          CALL RRK(RRA,EXL, LQN  ,NBAS,-1)
          CALL RRK(RRB,EXL, LQN  ,NBAS, 1)
          CALL RRK(RRC,EXL, LQN  ,NBAS, 2)
C
C         LOOP OVER |MQN| CHOICES FOR THIS KQN
          DO MQN=1,LQN
C
C           LOOP OVER LISTED NQNS
            DO NQN=1,NUMOCC(LQN+1)
C
C             SKIP THIS STEP IF ORBITAL IS UNOCCUPIED
              IF(NORB(LQN+1,NQN).EQ.0) GOTO 101
C
C             SPHERICAL SYMMETRY: FOCUS ON FIRST MQN ONLY
              IF(MQN.EQ.1) THEN
C
C               ADDRESS AND AVERAGE OCCUPATION
                IGLB(ICNT,NQN+LQN,2*LQN  ) = IOCCML+1
                PLTN(ICNT,NQN+LQN,2*LQN  ) = QA(NQN)
C
C               FOCK MATRIX ADDRESSES
                IL = LRGE(ICNT,2*LQN  ,MQN)
                IS = LRGE(ICNT,2*LQN  ,MQN)+NSKP
C
C               COEFFICIENT MATRIX OFFSET
                MOCC = IOCCML+1+NSKP
C
C               RADIAL MOMENTS
                RA = 0.0D0
                RB = 0.0D0
                RC = 0.0D0
                DO IBAS=1,NBAS
                  DO JBAS=1,NBAS
C
C                   LARGE-COMPONENT OFFSETS
                    IA = IL+IBAS
                    JA = IL+JBAS
C
C                   SMALL-COMPONENT OFFSETS
                    IB = IS+IBAS
                    JB = IS+JBAS
C
                    KBAS = IBAS+NBAS
                    LBAS = JBAS+NBAS
C
                    RA = RA + COEF(IA,MOCC)*COEF(JA,MOCC)*RRA(IBAS,JBAS)
     &                      + COEF(IB,MOCC)*COEF(JB,MOCC)*RRA(KBAS,LBAS)
                    RB = RB + COEF(IA,MOCC)*COEF(JA,MOCC)*RRB(IBAS,JBAS)
     &                      + COEF(IB,MOCC)*COEF(JB,MOCC)*RRB(KBAS,LBAS)
                    RC = RC + COEF(IA,MOCC)*COEF(JA,MOCC)*RRC(IBAS,JBAS)
     &                      + COEF(IB,MOCC)*COEF(JB,MOCC)*RRC(KBAS,LBAS)
C
                  ENDDO
                ENDDO
                RGLB(ICNT,NQN+LQN,2*LQN  ,1) = RA/QA(NQN)
                RGLB(ICNT,NQN+LQN,2*LQN  ,2) = RB/QA(NQN)
                RGLB(ICNT,NQN+LQN,2*LQN  ,3) = RC/QA(NQN)
C
              ENDIF
C
C             UPDATE NUMBER OF OCCUPIED PAIRS
              IOCCML = IOCCML+2
C
C             SKIP STEP FOR UNOCCUPIED ORBITALS
101           CONTINUE
C
C           END LOOP OVER LISTED NQNS
            ENDDO
C
          ENDDO
C
110       CONTINUE
C
C         NEGATIVE KQN CHOICE
C
C         CALCULATE BATCH OF <1/R>, <R> AND INTEGRALS
          CALL RRK(RRA,EXL,-LQN-1,NBAS,-1)
          CALL RRK(RRB,EXL,-LQN-1,NBAS, 1)
          CALL RRK(RRC,EXL,-LQN-1,NBAS, 2)
C
C         LOOP OVER |MQN| CHOICES
          DO MQN=1,LQN+1
C
C           LOOP OVER LISTED NQNS
            DO NQN=1,NUMOCC(LQN+1)
C
C             SKIP THIS STEP IF ORBITAL IS UNOCCUPIED
              IF(NORB(LQN+1,NQN).EQ.0) GOTO 102
C
C             SPHERICAL SYMMETRY: FOCUS ON FIRST MQN ONLY
              IF(MQN.EQ.1) THEN
C
C               ADDRESS AND AVERAGE OCCUPATION
                IGLB(ICNT,NQN+LQN,2*LQN+1) = IOCCML+1
                PLTN(ICNT,NQN+LQN,2*LQN+1) = QA(NQN)
C
C               FOCK MATRIX ADDRESSES
                IL = LRGE(ICNT,2*LQN+1,MQN)
                IS = LRGE(ICNT,2*LQN+1,MQN)+NSKP
C
C               COEFFICIENT MATRIX OFFSET
                MOCC = IOCCML+1+NSKP
C
C               RADIAL MOMENTS
                RA = 0.0D0
                RB = 0.0D0
                RC = 0.0D0
                DO IBAS=1,NBAS
                  DO JBAS=1,NBAS
C
C                   LARGE-COMPONENT OFFSETS
                    IA = IL+IBAS
                    JA = IL+JBAS
C
C                   SMALL-COMPONENT OFFSETS
                    IB = IS+IBAS
                    JB = IS+JBAS
C
                    KBAS = IBAS+NBAS
                    LBAS = JBAS+NBAS
C
                    RA = RA + COEF(IA,MOCC)*COEF(JA,MOCC)*RRA(IBAS,JBAS)
                    RB = RB + COEF(IA,MOCC)*COEF(JA,MOCC)*RRB(IBAS,JBAS)
                    RC = RC + COEF(IA,MOCC)*COEF(JA,MOCC)*RRC(IBAS,JBAS)
C
                    IF(HMLT.EQ.'NORL') GOTO 115
C
                    RA = RA + COEF(IB,MOCC)*COEF(JB,MOCC)*RRA(KBAS,LBAS)
                    RB = RB + COEF(IB,MOCC)*COEF(JB,MOCC)*RRB(KBAS,LBAS)
                    RC = RC + COEF(IB,MOCC)*COEF(JB,MOCC)*RRC(KBAS,LBAS)
C
115                 CONTINUE
C
                  ENDDO
                ENDDO
                RGLB(ICNT,NQN+LQN,2*LQN+1,1) = RA/QA(NQN)
                RGLB(ICNT,NQN+LQN,2*LQN+1,2) = RB/QA(NQN)
                RGLB(ICNT,NQN+LQN,2*LQN+1,3) = RC/QA(NQN)
C
              ENDIF
C
C             UPDATE NUMBER OF OCCUPIED PAIRS
              IOCCML = IOCCML+2
C
C             SKIP STEP FOR UNOCCUPIED ORBITALS
102           CONTINUE
C
C           END LOOP OVER LISTED NQNS
            ENDDO
C
          ENDDO
C
C         NON-RELATIVISTIC SPECIAL CASE: ALSO FILL IN THE +KQN BLOCK
          IF(HMLT.EQ.'NORL'.AND.LQN.GE.1) THEN
C
C           LOOP OVER |MQN| CHOICES
            DO MQN=1,LQN
C
C             LOOP OVER LISTED NQNS
              DO NQN=1,NUMOCC(LQN+1)
C
C               SKIP THIS STEP IF ORBITAL IS UNOCCUPIED
                IF(NORB(LQN+1,NQN).GT.0) THEN
                  IOCCML = IOCCML+2
                ENDIF
C
              ENDDO
C
            ENDDO
C
          ENDIF
C
C       END LOOP OVER LQNS
        ENDDO
C
C     END LOOP OVER NUCLEAR CENTRES
      ENDDO
C
C**********************************************************************C
C     PRINT SPECTRUM                                                   C
C**********************************************************************C
C
C     PRINT TITLE TO TERMINAL/FILE
20    FORMAT(1X,'Z  | nl',8X,'Energy (au)',2X,'Degcy',4X,
     &                          'Frac |',4X,'<1/r>',7X,'<r>',5X,'<r^2>')
21    FORMAT(1X,A,1X,'|',I2,A,A,1X,F17.10,5X,I2,3X,F5.3,' |',
     &                                                    F9.5,2(F10.5))
C
      WRITE(6,20)
      WRITE(7,20)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     LOOP OVER NUCLEAR CENTRES IN THE MOLECULE
      DO ICNT=1,NCNT
C
C       IMPORT ATOMIC CHARGE DETAILS
        IZNV = IZNC(ICNT)
        ELNM = ELMT(IZNV)
        ICRG = IQNC(ICNT)
C
C       INITIALISE THE ORBITAL FILLING ARRAY
        DO LQN=0,MKP-1
          DO NQN=1,MKP+1
            NORB(LQN+1,NQN) = 0
          ENDDO
        ENDDO
C
C       READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
        IF(IFILL(ICNT).EQ.0) THEN
          CALL AUFBAU(IZNV,ICRG,NORB,NUMOCC,LMXCONF)
        ELSE
          LMXCONF = LMAX(ICNT)
          DO L=1,LMXCONF+1
            NUMOCC(L) = NLVL(ICNT,L)
            DO N=1,NLVL(ICNT,L)
              NORB(L,N) = NCNF(ICNT,L,N)
            ENDDO
          ENDDO
        ENDIF
C
C       LOOP OVER ORBITALS IN THE USUAL AUFBAU ORDER
        DO NQN=1,MKP
          DO LQN=0,NQN-1
C
            IF(NORB(LQN+1,NQN-LQN).EQ.0) GOTO 150
C
C           POSITIVE KQN CHOICE (APPLIES ONLY FOR LQN>0)
            IF(LQN.EQ.0.OR.HMLT.EQ.'NORL') GOTO 120
C
C           SYMMETRY LABEL
            CHS = '+'
C
C           DEGENERACY
            IDGN = 2*LQN
C
C           IDENTIFY THE RIGHT INDEX AND PROPERTIES
            MOCC = IGLB(ICNT,NQN,2*LQN  )+NSKP
            FRAC = PLTN(ICNT,NQN,2*LQN  )
            RAVA = RGLB(ICNT,NQN,2*LQN  ,1)
            RAVB = RGLB(ICNT,NQN,2*LQN  ,2)
            RAVC = RGLB(ICNT,NQN,2*LQN  ,3)
C
C           OUTPUT TO TERMINAL
            WRITE(6,21) ELNM,NQN,ELLTERM(LQN),CHS,EIGN(MOCC),IDGN,FRAC,
     &                                                  RAVA,RAVB,RAVC
            WRITE(7,21) ELNM,NQN,ELLTERM(LQN),CHS,EIGN(MOCC),IDGN,FRAC,
     &                                                  RAVA,RAVB,RAVC
C
120         CONTINUE
C
C           NEGATIVE KQN CHOICE (APPLIES ONLY FOR LQN>0)
C
C           SYMMETRY LABEL IF NEEDED
            IF(LQN.EQ.0.OR.HMLT.EQ.'NORL') THEN
              CHS = ' '
            ELSE
              CHS = '-'
            ENDIF
C
C           DEGENERACY
            IF(HMLT.EQ.'NORL') THEN
              IDGN = 4*LQN+2
            ELSE
              IDGN = 2*LQN+2
            ENDIF
C
C           IDENTIFY THE RIGHT INDEX AND PROPERTIES
            MOCC = IGLB(ICNT,NQN,2*LQN+1)+NSKP
            FRAC = PLTN(ICNT,NQN,2*LQN+1)
            RAVA = RGLB(ICNT,NQN,2*LQN+1,1)
            RAVB = RGLB(ICNT,NQN,2*LQN+1,2)
            RAVC = RGLB(ICNT,NQN,2*LQN+1,3)
C
C           OUTPUT TO TERMINAL
            WRITE(6,21) ELNM,NQN,ELLTERM(LQN),CHS,EIGN(MOCC),IDGN,FRAC,
     &                                                  RAVA,RAVB,RAVC
            WRITE(7,21) ELNM,NQN,ELLTERM(LQN),CHS,EIGN(MOCC),IDGN,FRAC,
     &                                                  RAVA,RAVB,RAVC
C
150         CONTINUE
C
          ENDDO
C
        ENDDO
C
C       DELIMETER BETWEEN NUCLEAR CENTRES
        IF(ICNT.NE.NCNT) THEN
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF

C     END LOOP OVER NUCLEAR CENTRES
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE SPECTRM(IBND,IVIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  PPPPPPP  EEEEEEEE  CCCCCC TTTTTTTT RRRRRRR  MM       MM   C
C   SS    SS PP    PP EE       CC    CC   TT    RR    RR MMM     MMM   C
C   SS       PP    PP EE       CC         TT    RR    RR MMMM   MMMM   C
C    SSSSSS  PP    PP EEEEEE   CC         TT    RR    RR MM MM MM MM   C
C         SS PPPPPPP  EE       CC         TT    RRRRRRR  MM  MMM  MM   C
C   SS    SS PP       EE       CC    CC   TT    RR    RR MM   M   MM   C
C    SSSSSS  PP       EEEEEEEE  CCCCCC    TT    RR    RR MM       MM   C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPECTRM SUMMARISES THE ENERGY LEVELS OF AN SCF ITERATION, USING     C
C  ATOMIC TERM SYMBOLS, ATOMIC CENTRES AND FRACTIONAL POPULATIONS.     C
C  IT ALSO APPLIES SYMMETRY LABELS TO EACH STATE AND SORTS MQN M'FOLDS.C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    IBND - NUMBER OF BOUND ORBITALS TO INCLUDE.                       C
C    IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE.                     C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*1 CHL,ELLTERM
      CHARACTER*2 ELMT(120),ELA
      CHARACTER*4 HMLT
C
      DIMENSION FRAC(MDM,MCT,MKP,MKP+1),NPR(MCT,MKP,MKP+1)
      DIMENSION ICNLST(MDM),KQNLST(MDM),MQNLST(MDM),NQNLST(MDM),
     &          POPLST(MDM)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
      COMPLEX*16 CTEMP,ROT1,ROT2
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/MDLV/ELMT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
      DATA PI/3.1415926535897932D0/
C
C     SENSITIVITY TOLERANCE PARAMETER
      EPS = 1.0D-14
C
C     INITIALISE COUNTER ARRAYS
      DO ICNT=1,NCNT
        DO IKAP=1,NKAP(ICNT)
          IKQN = KAPA(IKAP,ICNT)
          IF(IKQN.LT.0) THEN
            ILQN =-IKQN-1
          ELSE
            ILQN = IKQN
          ENDIF
          NMV = 2*IABS(IKQN)
          DO IMV=1,NMV
            DO IOCC=1,IBND+IVIR
              FRAC(IOCC,ICNT,IKAP,IMV) = 0.0D0
            ENDDO
            NPR(ICNT,IKAP,IMV) = ILQN
          ENDDO
        ENDDO
      ENDDO
C
C     INTERNAL ROTATION BETWEEN PAIRS OF STATES
      DO IPAIR=1,NDIM-NSKP,2
C
C       SKIP NEGATIVE ENERGY SPECTRUM
        MPAIR = IPAIR+NSKP
C
C       TEMPORARY LARGE VALUE
        RLRG = 10.0D10
C
C       INITIAL INCRIMENTAL RADIAN (SWEEP OVER ALL POSSIBLE ANGLES)
        RINC = PI/180.0D0
C
C       SEARCH FOR STARTING POINT BY SWEEPING ANGLES 0 <= PHI < PI
        DO NPHI=0,179
C
C         CALCULATE ROTATION ANGLE AND COS/SIN TRANSFORMATIONS
          PHI  = RINC*DFLOAT(NPHI)
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
            ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
            OLAP = OLAP + CDABS(ROT1)*CDABS(ROT2)
          ENDDO
C
C         FIND PHI WHICH RESULTS IN SMALLEST SUM OF PRODUCTS
          IF(OLAP.LT.RLRG) THEN
            PHI0 = PHI
            RLRG = OLAP
          ENDIF
        ENDDO
C
C       NEW STARTING ROTATION ANGLE BASED ON THE ABOVE SEARCH
        PHI  = PHI0 - RINC
        SOLD = 1.0D11
C
C       SWEEP THROUGH INCREMENTAL ANGLES AND SEARCH AGAIN
        DO NPHI=1,4000
          PHI  = PHI + RINC
          CPHI = DCOS(PHI)
          SPHI = DSIN(PHI)
          OLAP = 0.0D0
C
C         ROTATE ALL THE EXPANSION COEFFICIENT MQN PAIRS BY ANGLE PHI
          DO I=1,NDIM
            ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
            ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
            OLAP = OLAP + CDABS(ROT1)*CDABS(ROT2)
          ENDDO
C
C         IF THE NEW VALUE IS BELOW A TOLERANCE, FINISH.
          IF(DABS(OLAP-SOLD).LT.EPS) GOTO 1
C
C         IF SUM OF COEFFICIENT PRODUCTS IS BIGGER THAN COUNTER, REFINE.
          IF(OLAP.GT.SOLD) THEN
            RINC =-RINC/10.0D0
          ENDIF
C
C         DECREASE COUNTER VALUE
          SOLD = OLAP
C
        ENDDO
1       CONTINUE
C
C       PERFORM THE ACTUAL ROTATION USING THE BEST SOLUTION PHI
        CPHI = DCOS(PHI)
        SPHI = DSIN(PHI)
        DO I=1,NDIM
          ROT1 = CPHI*COEF(I,MPAIR  ) + SPHI*COEF(I,MPAIR+1)
          ROT2 =-SPHI*COEF(I,MPAIR  ) + CPHI*COEF(I,MPAIR+1)
C
          COEF(I,MPAIR  ) = ROT1
          COEF(I,MPAIR+1) = ROT2
        ENDDO
C
      ENDDO
C
C     CALCULATE FRACTIONAL OCCUPATION FOR EACH SOLUTION VECTOR
C
C     LOOP OVER OCCUPIED ORBITALS
      DO IOCC=1,IBND+IVIR
C
C       IGNORE NEGATIVE SPECTRUM
        MOCC = IOCC+NSKP
C
C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
        DO I=1,NDIM-NSKP
          IS = I+NSKP
          ICNT = LABICN(I)
          IKQN = LABKQN(I)
          IMQN = LABMQN(I)
          IF(IKQN.LT.0) THEN
            IKAP =-2*IKQN-1
          ELSE
            IKAP = 2*IKQN
          ENDIF
          IF(IMQN.LT.0) THEN
            IMV = IABS(IMQN)
          ELSE
            IMV = IMQN+1
          ENDIF
C
          DO J=1,NDIM-NSKP
            JS = J+NSKP
            JCNT = LABICN(J)
            JKQN = LABKQN(J)
            JMQN = LABMQN(J)
C
C           LARGE AND SMALL CONTRIBUTIONS
            TMP = DREAL(DCONJG(COEF(I ,MOCC))*COEF(J ,MOCC)*OVAP(I ,J ))
     &          + DREAL(DCONJG(COEF(IS,MOCC))*COEF(JS,MOCC)*OVAP(IS,JS))
C
C           DECIDE WHERE TO PUT CONTRIBUTION
            IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
              FRAC(IOCC,ICNT,IKAP,IMV) = FRAC(IOCC,ICNT,IKAP,IMV) + TMP
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     IDENTIFY CONVENTIONAL DIRAC QUANTUM NUMBERS BASED ON FRAC.
C
C     LOOP OVER POSITIVE ENERGY SPECTRUM IN PAIRS
      DO IOCC=1,NDIM-NSKP
C
C       SEARCH FOR HIGHEST POPULATED ATOMIC STATE
        PLTN = 0.0D0
        DO ICNT=1,NCNT
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            NMV  = 2*IABS(IKQN)
            DO IMV=1,NMV
              IF(FRAC(IOCC,ICNT,IKAP,IMV).GT.PLTN) THEN
                PLTN = FRAC(IOCC,ICNT,IKAP,IMV)
                KCNT = ICNT
                KKQN = IKQN
                KKAP = IKAP
                KMV  = IMV
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        NPR(KCNT,KKAP,KMV) = NPR(KCNT,KKAP,KMV)+1
C
C       APPLY DIRAC LABELS ACCORDING TO HIGHEST POPULATED STATE
        NQNLST(IOCC) = NPR(KCNT,KKAP,KMV)
        ICNLST(IOCC) = KCNT
        KQNLST(IOCC) = KKQN
        POPLST(IOCC) = FRAC(IOCC,KCNT,KKAP,KMV)
        IF(MOD(KMV,2).EQ.1) THEN
          MQNLST(IOCC) =-KMV
        ELSE
          MQNLST(IOCC) = KMV-1
        ENDIF
C
C     END LOOP OVER ORBITALS
      ENDDO
C
C     SORTING: ORGANISE POSITIVE-ENERGY SOLUTIONS IN MQN PAIRS
C
      IF(NCNT.EQ.1) THEN
C
C       LOOP OVER ALL STATES
        DO IOCC=1,NDIM-NSKP
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MOCC = IOCC+NSKP
C
C         IDENTIFY KQN OF STATE
          IKQN = KQNLST(IOCC)
C
C         FOR THIS KQN VALUE, SEARCH NEXT 2*|KQN| ENTRIES AND ORDER
C
        ENDDO
C
      ELSEIF(NCNT.GT.1) THEN
C
C       LOOP OVER PAIRS OF STATES
        DO IPAIR=1,NDIM-NSKP,2
C
C         SKIP NEGATIVE ENERGY SPECTRUM
          MPAIR = IPAIR+NSKP
C
C         NO NEED TO SWAP IF MQN OF THE FIRST STATE IS NEGATIVE
          IF(MQNLST(IPAIR).LT.0) GOTO 100
C
C         SWAP EIGENVALUES, EXPANSION COEFFICIENTS AND MQN VALUES
          ETEMP         = EIGN(MPAIR+1)
          EIGN(MPAIR+1) = EIGN(MPAIR  )
          EIGN(MPAIR  ) = ETEMP
C
          DO I=1,NDIM
            CTEMP           = COEF(I,MPAIR+1)
            COEF(I,MPAIR+1) = COEF(I,MPAIR  )
            COEF(I,MPAIR  ) = CTEMP
          ENDDO
C
          MTEMP           = MQNLST(IPAIR+1)
          MQNLST(IPAIR+1) = MQNLST(IPAIR  )
          MQNLST(IPAIR  ) = MTEMP
C
          PTEMP           = POPLST(IPAIR+1)
          POPLST(IPAIR+1) = POPLST(IPAIR  )
          POPLST(IPAIR  ) = PTEMP
C
C         SKIP POINT FOR ALREADY-SORTED PAIRS
100       CONTINUE
C
        ENDDO
C
      ENDIF
C
C     PRINT TITLE TO TERMINAL/FILE
20    FORMAT(1X,'Orb.',2X,'Centre',4X,'Term sym.',3X,'m_j',14X,
     &                                    'Energy (au)',6X,'Population')
21    FORMAT(1X,I3,2X,I2,' (',A,')',4X,I2,A,'_',I1,'/2',4X,I2,'/2',7X,
     &                                                  F18.12,6X,F10.8)
C
      WRITE(6,20)
      WRITE(7,20)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     SUMMARISE RESULTS
      DO IOCC=1,IBND+IVIR
C
        MOCC = IOCC+NSKP
C
        ICNT = ICNLST(IOCC)
        INQN = NQNLST(IOCC)
        IKQN = KQNLST(IOCC)
        IMQN = MQNLST(IOCC)
        ELA  = ELMT(IZNC(ICNT))
        IF(IKQN.LT.0) THEN
          ILQN =-IKQN-1
        ELSE
          ILQN = IKQN
        ENDIF
        CHL  = ELLTERM(ILQN)
        IJQN = 2*IABS(IKQN)-1

        IF(IOCC.LE.IBND) THEN
          PLTN = POPLST(IOCC)
        ELSE
          PLTN = 0.0D0
        ENDIF
C
        IF(HMLT.EQ.'NORL') THEN
          PLTN = 0.5D0*PLTN
        ENDIF
C
C       OUTPUT TO TERMINAL
        WRITE(6,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGN(MOCC),PLTN
        WRITE(7,21) IOCC,ICNT,ELA,INQN,CHL,IJQN,IMQN,EIGN(MOCC),PLTN
        IF(IOCC.EQ.IBND.AND.IVIR.NE.0) THEN
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF
C
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      FUNCTION ELLTERM(L)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE LL       LL     TTTTTTTT EEEEEEEE RRRRRRR  MM       MM    C
C   EE       LL       LL        TT    EE       RR    RR MMM     MMM    C
C   EE       LL       LL        TT    EE       RR    RR MMMM   MMMM    C
C   EEEEEE   LL       LL        TT    EEEEEE   RR    RR MM MM MM MM    C
C   EE       LL       LL        TT    EE       RRRRRRR  MM  MMM  MM    C
C   EE       LL       LL        TT    EE       RR    RR MM   M   MM    C
C   EEEEEEEE LLLLLLLL LLLLLLLL  TT    EEEEEEEE RR    RR MM       MM    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELLTERM(L) EVALUATES A CHARACTER CORRESPONDING TO TERM SYMBOL L.    C
C**********************************************************************C
C
      CHARACTER*1 ELLTERM
C
      IF(L.EQ.0) THEN
        ELLTERM = 's'
      ELSEIF(L.EQ.1) THEN
        ELLTERM = 'p'
      ELSEIF(L.EQ.2) THEN
        ELLTERM = 'd'
      ELSEIF(L.EQ.3) THEN
        ELLTERM = 'f'
      ELSEIF(L.EQ.4) THEN
        ELLTERM = 'g'
      ELSEIF(L.EQ.5) THEN
        ELLTERM = 'h'
      ELSEIF(L.EQ.6) THEN
        ELLTERM = 'i'
      ELSEIF(L.EQ.7) THEN
        ELLTERM = 'j'
      ELSEIF(L.EQ.8) THEN
        ELLTERM = 'k'
      ELSEIF(L.EQ.9) THEN
        ELLTERM = 'l'
      ELSEIF(L.EQ.10) THEN
        ELLTERM = 'm'
      ELSEIF(L.EQ.11) THEN
        ELLTERM = 'n'
      ELSEIF(L.EQ.12) THEN
        ELLTERM = 'o'
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ROTATE(XYZ,NCNT,ALPHA,BETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          RRRRRRR   OOOOOO TTTTTTTT   AA   TTTTTTTT EEEEEEEE          C
C          RR    RR OO    OO   TT     AAAA     TT    EE                C
C          RR    RR OO    OO   TT    AA  AA    TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EEEEEE            C
C          RRRRRRR  OO    OO   TT   AAAAAAAA   TT    EE                C
C          RR    RR OO    OO   TT   AA    AA   TT    EE                C
C          RR    RR  OOOOOO    TT   AA    AA   TT    EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ROTATE PERFORMS TWO ROTATIONS ON ALL ATOMIC CENTRES, FIRST SO THAT  C
C  Y DOES NOT CHANGE, AND THEN SO THAT Z DOES NOT CHANGE.              C
C**********************************************************************C
C
      DIMENSION XYZ(3,NCNT),V(3),W(3)
      DIMENSION AR(3,3),BR(3,3),RR(3,3)
C
C     INITIALISE MATRICES
      DO I=1,3
        DO J=1,3
          AR(I,J) = 0.0D0
          BR(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     FIX ALL VALUES OF Z AND ROTATE BY ALPHA
      AR(3,3) = 1.0D0
      AR(1,1) = DCOS(ALPHA)
      AR(2,2) = DCOS(ALPHA)
      AR(1,2) = DSIN(ALPHA)
      AR(2,1) =-DSIN(ALPHA)
C
C     FIX ALL VALUES OF Y AND ROTATE BY BETA
      BR(2,2) = 1.0D0
      BR(1,1) = DCOS(BETA)
      BR(3,3) = DCOS(BETA)
      BR(3,1) = DSIN(BETA)
      BR(1,3) =-DSIN(BETA)
C
C     EVALUATE OVERALL ROTATION MATRIX
      CALL MMPROD(BR,AR,RR,3)
C
C     ROTATE ALL VECTORS IN XYZ
      DO N=1,NCNT
        DO I=1,3
          V(I) = XYZ(I,N)
        ENDDO
        CALL MVPROD(RR,V,W,3)
        DO I=1,3
          XYZ(I,N) = W(I)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MMPROD(A,B,X,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM MM       MM PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD       C
C     MMM     MMM MMM     MMM PP    PP RR    RR OO    OO DD    DD      C
C     MMMM   MMMM MMMM   MMMM PP    PP RR    RR OO    OO DD    DD      C
C     MM MM MM MM MM MM MM MM PP    PP RR    RR OO    OO DD    DD      C
C     MM  MMM  MM MM  MMM  MM PPPPPPP  RRRRRRR  OO    OO DD    DD      C
C     MM   M   MM MM   M   MM PP       RR    RR OO    OO DD    DD      C
C     MM       MM MM       MM PP       RR    RR  OOOOOO  DDDDDDD       C
C                                                                      C
C -------------------------------------------------------------------- C
C  MMPROD CALCULATES THE PRODUCT OF TWO SQUARE, DOUBLE-PRECISION       C
C  MATRIX ARRAYS OF DIMENSION N, AND OUTPUTS THE RESULT INTO X.        C
C**********************************************************************C
C
      DIMENSION A(N,N),B(N,N),X(N,N)
C
C     INITIALISE X MATRIX
      DO I=1,N
        DO J=1,N
          X(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          DO K=1,N
            X(I,J) = X(I,J) + A(I,K)*B(K,J)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE MVPROD(A,V,W,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       MM       MM VV    VV PPPPPPP  RRRRRRR   OOOOOO  DDDDDDD        C
C       MMM     MMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MMMM   MMMM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM MM MM MM VV    VV PP    PP RR    RR OO    OO DD    DD       C
C       MM  MMM  MM  VV  VV  PPPPPPP  RRRRRRR  OO    OO DD    DD       C
C       MM   M   MM   VVVV   PP       RR    RR OO    OO DD    DD       C
C       MM       MM    VV    PP       RR    RR  OOOOOO  DDDDDDD        C
C                                                                      C
C -------------------------------------------------------------------- C
C  MVPROD CALCULATES THE PRODUCT OF A SQUARE MATRIX OF DIMENSION N     C
C  AND A VECTOR OF DIMENSION N, AND OUTPUTS THE RESULT INTO W.         C
C**********************************************************************C
C
      DIMENSION A(N,N),V(N),W(N)
C
C     INITIALISE W MATRIX
      DO I=1,N
        W(I) = 0.0D0
      ENDDO
C
C     MATRIX PRODUCT
      DO I=1,N
        DO J=1,N
          W(I) = W(I) + A(I,J)*V(J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION MS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          MM       MM  SSSSSS                         C
C                          MMM     MMM SS    SS                        C
C                          MMMM   MMMM SS                              C
C                          MM MM MM MM  SSSSSS                         C
C                          MM  MMM  MM       SS                        C
C                          MM   M   MM SS    SS                        C
C                          MM       MM  SSSSSS                         C
C                                                                      C
C -------------------------------------------------------------------- C
C   MS RETURNS A QUOTED TIME IN SECONDS USING 'MIN-SEC' FORMAT.        C
C**********************************************************************C
C
      CHARACTER*4 MINUTES
      CHARACTER*7 SECONDS
      CHARACTER*11 MS
C
C     INITIALISE COUNTERS
      NMIN = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PRINT THE MINUTE
      IF(NMIN.EQ.0) THEN
        WRITE(MINUTES,'(A)') '    '
      ELSE
        WRITE(MINUTES,'(I3,A)') NMIN,'m'
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F4.2,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F4.2,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F5.2,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(MS,'(A,A)') MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      FUNCTION HMS(TSEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                     HH    HH MM       MM  SSSSSS                     C
C                     HH    HH MMM     MMM SS    SS                    C
C                     HH    HH MMMM   MMMM SS                          C
C                     HHHHHHHH MM MM MM MM  SSSSSS                     C
C                     HH    HH MM  MMM  MM       SS                    C
C                     HH    HH MM   M   MM SS    SS                    C
C                     HH    HH MM       MM  SSSSSS                     C
C                                                                      C
C -------------------------------------------------------------------- C
C   HMS RETURNS A QUOTED TIME IN SECONDS USING 'HR-MIN-SEC' FORMAT.    C
C**********************************************************************C
C
      CHARACTER*4 HOURS,MINUTES
      CHARACTER*8 SECONDS
      CHARACTER*16 HMS
C
C     INITIALISE COUNTERS
      NMIN = 0
      NHRS = 0
C
C     BACKUP TSEC
      TEMP = TSEC
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0.0D0 <= TSEC < 60.0D0
      DO WHILE (TSEC.GE.6.0D1)
        TSEC = TSEC - 60.0D0
        NMIN = NMIN + 1
      ENDDO
C
C     PERFORM MODULAR ARITHMETIC UNTIL 0 <= NMIN < 60
      DO WHILE (NMIN.GE.60)
        NMIN = NMIN - 60
        NHRS = NHRS + 1
      ENDDO
C
C     PRINT THE HOUR
      IF(NHRS.EQ.0) THEN
        WRITE(HOURS,'(A)') '    '
      ELSE
        WRITE(HOURS,'(I3,A)') NHRS,'h'
      ENDIF
C
C     PRINT THE MINUTE
      IF(NHRS.EQ.0) THEN
        IF(NMIN.EQ.0) THEN
          WRITE(MINUTES,'(1X,A)') '   '
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ELSEIF(NHRS.NE.0) THEN
        IF(NMIN.LT.10) THEN
          WRITE(MINUTES,'(1X,I1,I1,A)') 0,NMIN,'m'
        ELSE
          WRITE(MINUTES,'(1X,I2,A)') NMIN,'m'
        ENDIF
      ENDIF
C
C     PRINT THE SECOND
      IF(NMIN.EQ.0) THEN
        IF(TSEC.LT.1.0D0) THEN
          WRITE(SECONDS,'(2X,F5.3,A)') TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ELSEIF(NMIN.GT.0) THEN
        IF(TSEC.LT.10.0D0) THEN
          WRITE(SECONDS,'(1X,I1,F5.3,A)') 0,TSEC,'s'
        ELSE
          WRITE(SECONDS,'(1X,F6.3,A)') TSEC,'s'
        ENDIF
      ENDIF
C
      WRITE(HMS,'(A,A,A)') HOURS//MINUTES//SECONDS
C
C     RESTORE TSEC
      TSEC = TEMP
C
      RETURN
      END
C
C
      SUBROUTINE TIMENOW(STAMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  TTTTTTTT IIII MM       MM EEEEEEEE NN    NN  OOOOOO  WW         WW  C
C     TT     II  MMM     MMM EE       NNN   NN OO    OO WW         WW  C
C     TT     II  MMMM   MMMM EE       NNNN  NN OO    OO WW         WW  C
C     TT     II  MM MM MM MM EEEEEE   NN NN NN OO    OO WW    W    WW  C
C     TT     II  MM  MMM  MM EE       NN  NNNN OO    OO WW   WWW   WW  C
C     TT     II  MM   M   MM EE       NN   NNN OO    OO  WW WW WW WW   C
C     TT    IIII MM       MM EEEEEEEE NN    NN  OOOOOO    WW     WW    C
C                                                                      C
C -------------------------------------------------------------------- C
C  TIMENOW CREATES A DATE STRING SPECIFYING CPU TIME WHEN CALLED.      C
C**********************************************************************C
C
      CHARACTER*5  ZONE
      CHARACTER*8  DATE
      CHARACTER*10 TIME
      CHARACTER*20 STAMP
C
      DIMENSION IVL(8)
C
C     CALL TIME AND DATE ROUTINE
      CALL DATE_AND_TIME(DATE,TIME,ZONE,IVL)
C
C     PRINT THE DAY
      IF(IVL(3).LT.10) THEN
        WRITE(STAMP,'(1X,I1,I1,A)') 0,IVL(3),'/'
      ELSE
        WRITE(STAMP,'(1X,I2,A)') IVL(3),'/'
      ENDIF
C
C     PRINT THE MONTH
      IF(IVL(2).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(2),'/'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(2),'/'
      ENDIF
C
C     PRINT THE YEAR
      WRITE(STAMP,'(A,I4)') TRIM(STAMP),IVL(1)
C
C     PRINT THE HOUR
      IF(IVL(5).LT.10) THEN
        WRITE(STAMP,'(A,A,I1,I1,A)') TRIM(STAMP),' ',0,IVL(5),':'
      ELSE
        WRITE(STAMP,'(A,A,I2,A)') TRIM(STAMP),' ',IVL(5),':'
      ENDIF
C
C     PRINT THE MINUTE
      IF(IVL(6).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1,A)') TRIM(STAMP),0,IVL(6),':'
      ELSE
        WRITE(STAMP,'(A,I2,A)') TRIM(STAMP),IVL(6),':'
      ENDIF
C
C     PRINT THE SECOND
      IF(IVL(7).LT.10) THEN
        WRITE(STAMP,'(A,I1,I1)') TRIM(STAMP),0,IVL(7)
      ELSE
        WRITE(STAMP,'(A,I2)') TRIM(STAMP),IVL(7)
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [3] DENSITIES: MOLECULAR DENSITIES, ENERGIES AND LEVEL SHIFTING.   C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] DENSTY0: GENERATES CLOSED- AND OPEN-SHELL MOLECULAR DENSITY.   C
C   [B] DENSTY: GENERATES CLOSED- AND OPEN-SHELL MOLECULAR DENSITY.    C
C   [C] LEVSHFT: APPLIES A LEVEL SHIFT TO OCCUPIED ORBITALS IN FOCK.   C
C   [D] ENERGIES: USE DENSITY MATRIX TO CALCULATE ENERGY TERMS.        C
C**********************************************************************C
C
C
      SUBROUTINE DENSTY0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    DDDDDDD  EEEEEEEE NN    NN  SSSSSS TTTTTTTT YY    YY  000000      C
C    DD    DD EE       NNN   NN SS    SS   TT    YY    YY 00   000     C
C    DD    DD EE       NNNN  NN SS         TT     YY  YY  00  0000     C
C    DD    DD EEEEEE   NN NN NN  SSSSSS    TT      YYYY   00 00 00     C
C    DD    DD EE       NN  NNNN       SS   TT       YY    0000  00     C
C    DD    DD EE       NN   NNN SS    SS   TT       YY    000   00     C
C    DDDDDDD  EEEEEEEE NN    NN  SSSSSS    TT       YY     000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSTY0 IS A STARTING DENSITY ROUTINE FOR USE ONLY WHEN INEW = 0.   C
C  THIS IS BECAUSE 'ATOMIC' CALCULATES AVERAGE OVER SHELL OCCUPANCIES. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      COMPLEX*16 SUM
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/OCPD/IOCPN(MDM),IOCCM0
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     CONSTRUCT THE CLOSED-SHELL AND TOTAL DENSITY ARRAYS
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,IOCCM0
            IOCAD = IOCPN(IOCC)
            SUM = SUM + DCONJG(COEF(I,IOCAD+NSKP))*COEF(J,IOCAD+NSKP)
          ENDDO
          DENC(I,J) = SUM
          DENO(I,J) = 0.0D0
          DENT(I,J) = DENC(I,J) + DENO(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DENSTY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS TTTTTTTT YY    YY         C
C         DD    DD EE       NNN   NN SS    SS   TT    YY    YY         C
C         DD    DD EE       NNNN  NN SS         TT     YY  YY          C
C         DD    DD EEEEEE   NN NN NN  SSSSSS    TT      YYYY           C
C         DD    DD EE       NN  NNNN       SS   TT       YY            C
C         DD    DD EE       NN   NNN SS    SS   TT       YY            C
C         DDDDDDD  EEEEEEEE NN    NN  SSSSSS    TT       YY            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSTY GENERATES DENSITY MATRICES FROM THE EXPANSION COEFFS COEF.   C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      COMPLEX*16 SUM
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     MAKE CLOSED-SHELL DENSITY AND EMPTY OPEN-SHELL DENSITY (RSCF 81)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NCLS
            ICL = ICLS(IOCC)
            SUM = SUM +      DCONJG(COEF(I,ICL+NSKP))*COEF(J,ICL+NSKP)
          ENDDO
          DENC(I,J) = SUM
          DENT(I,J) = DENC(I,J)
          DENO(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
      IF(NOPN.EQ.0) GOTO 100
C
C     MAKE THE OPEN-SHELL DENSITY (RSCF 82)
      DO I=1,NDIM
        DO J=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO IOCC=1,NOPN
            IOP = IOPN(IOCC)
            SUM = SUM + FOPN*DCONJG(COEF(I,IOP+NSKP))*COEF(J,IOP+NSKP)
          ENDDO
          DENO(I,J) = SUM
          DENT(I,J) = DENT(I,J) + DENO(I,J)
        ENDDO
      ENDDO
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE LEVSHFT(SHLV)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   LL       EEEEEEEE VV      VV  SSSSSS  HH    HH FFFFFFFF TTTTTTTT   C
C   LL       EE       VV      VV SS    SS HH    HH FF          TT      C
C   LL       EE       VV      VV SS       HH    HH FF          TT      C
C   LL       EEEEEE    VV    VV   SSSSSS  HHHHHHHH FFFFFF      TT      C
C   LL       EE         VV  VV         SS HH    HH FF          TT      C
C   LL       EE          VVVV    SS    SS HH    HH FF          TT      C
C   LLLLLLLL EEEEEEEE     VV      SSSSSS  HH    HH FF          TT      C
C                                                                      C
C -------------------------------------------------------------------- C
C  LEVSHFT APPLIES A LEVEL SHIFT OF SHLV TO UNOCCUPIED ORBITALS IN THE C
C  FOCK MATRIX.                                                        C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
      COMPLEX*16 A(MDM),SUM
C
      COMMON/EIGC/COEF
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     LOOP OVER ALL NON-OCCUPIED POSITIVE-ENERGY (I.E., VIRTUAL) OCCS
      DO IVIR=NSKP+NOCC+1,NDIM
C
C       LIST OF FOCK ADDRESSES WITH 'I' WITH AN AMOUNT FROM EACH IVIR
        DO I=1,NDIM
          SUM = DCMPLX(0.0D0,0.0D0)
          DO J=1,NDIM
            SUM = SUM + OVAP(I,J)*COEF(J,IVIR)
          ENDDO
          A(I) = SUM
        ENDDO
C
C       ADD A LEVEL SHIFT'S WORTH OF INTERACTION ENERGY TO ALL FOCK(I,J)
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = FOCK(I,J) + SHLV*A(I)*DCONJG(A(J))
          ENDDO
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ENERGIES
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE NN    NN EEEEEEEE RRRRRRR   GGGGGG IIII EEEEEEEE SSSSSS   C
C   EE       NNN   NN EE       RR    RR GG    GG II  EE      SS    SS  C
C   EE       NNNN  NN EE       RR    RR GG       II  EE      SS        C
C   EEEEEE   NN NN NN EEEEEE   RR    RR GG       II  EEEEEE   SSSSSS   C
C   EE       NN  NNNN EE       RRRRRRR  GG   GGG II  EE            SS  C
C   EE       NN   NNN EE       RR    RR GG    GG II  EE      SS    SS  C
C   EEEEEEEE NN    NN EEEEEEEE RR    RR  GGGGGG IIII EEEEEEEE SSSSSS   C
C                                                                      C
C -------------------------------------------------------------------- C
C  ENERGIES CALCULATES INTERACTION ENERGIES OF THE CURRENT DENSITY     C
C  MATRIX OVER OCCUPIED SPINORS WITH THE MATRIX REP OF OPERATORS.      C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      COMPLEX*16 ETMP(12)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE MOLECULAR ENERGY COUNTERS
      DO N=1,12
        ETMP(N) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     CALCULATE MOLECULAR ENERGY COUNTERS OVER THE MOST RECENT DENSITY
      DO I=1,NDIM
        DO J=1,NDIM
          ETMP( 1) = ETMP( 1) +       DENT(I,J)*HNUC(I,J)
          ETMP( 2) = ETMP( 2) +       DENT(I,J)*HKIN(I,J)
          ETMP( 3) = ETMP( 3) +       DENT(I,J)*VUEH(I,J)
          ETMP( 4) = ETMP( 4) + 0.5D0*DENT(I,J)*GDIR(I,J)
          ETMP( 5) = ETMP( 5) + 0.5D0*DENT(I,J)*GXCH(I,J)
          ETMP( 6) = ETMP( 6) + 0.5D0*DENT(I,J)*BDIR(I,J)
          ETMP( 7) = ETMP( 7) + 0.5D0*DENT(I,J)*BXCH(I,J)
          ETMP( 8) = ETMP( 8) - 0.5D0*DENO(I,J)*QDIR(I,J)
     &                        + 0.5D0*DENT(I,J)*QDIR(I,J)*(FOPN-1.0D0)
          ETMP( 9) = ETMP( 9) - 0.5D0*DENO(I,J)*QXCH(I,J)
     &                        + 0.5D0*DENT(I,J)*QXCH(I,J)*(FOPN-1.0D0)
          ETMP(12) = ETMP(12) +       DENT(I,J)*FOCK(I,J)
        ENDDO
      ENDDO
C
C     REAL COMPONENTS ARE ACTUAL ENERGIES
      EHNC = DREAL(ETMP( 1))
      EHKN = DREAL(ETMP( 2))
      EUEH = DREAL(ETMP( 3))
      EGDR = DREAL(ETMP( 4))
      EGXC = DREAL(ETMP( 5))
      EBDR = DREAL(ETMP( 6))
      EBXC = DREAL(ETMP( 7))
      EQDR = DREAL(ETMP( 8))
      EQXC = DREAL(ETMP( 9))
      EMDR = DREAL(ETMP(10))
      EMXC = DREAL(ETMP(11))
C
C     ADD ALL CONTRIBUTIONS TO THE TOTAL ENERGY
      EONE = EHNC+EHKN
      ECLG = EGDR-EGXC
      ECLQ = EQDR-EQXC
      EBRG = EBDR-EBXC
      EBRQ = EMDR-EMXC
      ETOT = ENUC+EONE+EUEH+ECLG+ECLQ+EBRG
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [4] ATOMIC HARTREE-FOCK: SINGLE-CENTRE SCF CALCULATIONS.           C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] ATOMIC: MAIN ROUTNE FOR ATOMIC SCF CALCULATIONS.               C
C   [B] ATOM1E: HYDROGENIC ATOMIC SOLVER (ONE-BODY ONLY, SO NO SCF.)   C
C   [C] HFSCF0: ATOMIC SCF ROUTINE (AVERAGE OF CONFIGURATION MODEL.)   C
C   [D] OVRLP0: GENERATES ATOMIC OVERLAP MATRIX FOR A GIVEN KQN.       C
C   [E] KINTC0: GENERATES ATOMIC KINETIC MATRIX FOR A GIVEN KQN.       C
C   [F] PNTNC0: GENERATES ATOMIC POINT-NUCLEAR MATRIX FOR A GIVEN KQN. C
C   [G] GSSNC0: GENERATES ATOMIC OVERLAP MATRIX FOR A GIVEN KQN.       C
C   [H] ONEEL0: GENERATES ATOMIC ONE-ELECTRON MATRIX (ALL HAMILS).     C
C   [I] RRK: GENERATES ATOMIC RADIAL INTEGRALS FOR A GIVEN KQN.        C
C   [J] ERFINT0: INTEGRAL OVER A GAUSSIAN AND ERROR FUNCTION.          C
C   [K] UEHLING0: GENERATES ATOMIC UEHLING INTERACTION MATRIX.         C
C   [L] UEHINT0: CALCULATES AN ATOMIC UEHLING INTEGRAL.                C
C   [M] COULOMB0: ATOMIC MEAN-FIELD COULOMB MATRIX (BETA INTEGRALS).   C
C   [N] RKCLM0: BATCH OF ATOMIC COULOMB INTERACTION INTEGRALS.         C
C   [O] ANGCLM0: ATOMIC ANGULAR COULOMB COEFFICIENTS.                  C
C   [P] ABC000: SQUARE OF A WIGNER-3J SYMBOL (LS COUPLING).            C
C   [Q] SYM3JSQ: SQUARE OF A WIGNER-3J SYMBOL (JJ COUPLING).           C
C   [R] BREIT0: CONSTRUCTION OF ATOMIC BREIT INTERACTION MATRIX.       C
C   [S] RKBRT0: BATCH OF ATOMIC BREIT INTERACTION INTEGRALS.           C
C   [T] ANGBRT0: ATOMIC ANGULAR BREIT COEFFICIENTS.                    C
C   [U] BRCOEF0: EXCHANGE MAGNETIC COEFFICIENTS FOR CLOSED-SHELL BREIT.C
C   [V] IJSET0: BASIS SET INTERMEDIATES FOR IJ-PAIRS IN RKCLM0/RKBRT0. C
C   [W] KLSET0: BASIS SET INTERMEDIATES FOR KL-PAIRS IN RKCLM0/RKBRT0. C
C   [X] RNORM0: GENERATE BATCHES OF ALL TT' NORMALISATION FACTORS.     C
C   [Y] GAMGEN: LIST OF GAMMA FUNCTIONS FOR INT AND HALF-INT ARGS.     C
C   [Z] FACTRLS: LIST OF FACTORIALS AND DOUBLE FACTORIALS.             C
C**********************************************************************C
C
C
      SUBROUTINE ATOMIC
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             AA   TTTTTTTT OOOOOO  MM       MM IIII CCCCCC            C
C            AAAA     TT   OO    OO MMM     MMM  II CC    CC           C
C           AA  AA    TT   OO    OO MMMM   MMMM  II CC                 C
C          AA    AA   TT   OO    OO MM MM MM MM  II CC                 C
C          AAAAAAAA   TT   OO    OO MM  MMM  MM  II CC                 C
C          AA    AA   TT   OO    OO MM   M   MM  II CC    CC           C
C          AA    AA   TT    OOOOOO  MM       MM IIII CCCCCC            C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  ATOMIC PERFORMS A SINGLE-CENTRE SCF PROCEDURE FOR EACH ATOM IN THE  C
C  MOLECULE AND ASSEMBLES AN INITIAL COEFFICIENT MATRIX.               C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4  HMLT
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/OCPD/IOCPN(MDM),IOCCM0
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TATM/TTOT
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',26),'ATOMIC HARTREE-FOCK SCF'
      WRITE(7, *) REPEAT(' ',26),'ATOMIC HARTREE-FOCK SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME AT START OF ATOMIC CALCULATION
      CALL CPU_TIME(TDUM)
C
C     INITIALISE MOLECULAR MATRICES AND RADIAL EXPECTATION VALUES
      DO I=1,NDIM
        DO J=1,NDIM
          COEF(I,J) = DCMPLX(0.0D0,0.0D0)
          OVAP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
C
C     INITIALISE OCCUPATION COUNTER
      IOCCM0 = 0
C
C     SPECIAL EXIT FOR ZERO- AND ONE-ELECTRON PROBLEMS
      IF(NOELEC.EQ.0) THEN
        WRITE(6, *) 'There are no electrons! Skip ATOMIC.'
        WRITE(7, *) 'There are no electrons! Skip ATOMIC.'
        RETURN
      ELSEIF(NOELEC.EQ.1.AND.NCNT.EQ.1) THEN
        ICNT = 1
        CALL ATOM1E(ICNT)
        CALL DENSTY0
        WRITE(6, *) REPEAT(' ',22),'Atomic one-electron summary'
        WRITE(7, *) REPEAT(' ',22),'Atomic one-electron summary'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        CALL SPECTRM0
        RETURN
      ENDIF
C
C     HARTREE-FOCK SCF PROCEDURE FOR EACH ISOLATED ATOM
      DO ICNT=1,NCNT
        CALL HFSCF0(ICNT)
      ENDDO
C
C     GENERATE DENSITY MATRIX
      CALL DENSTY0
C
C     ATOMIC SCF SUMMARY HEADER
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT(' ',27),'Atomic SCF summary'
      WRITE(7, *) REPEAT(' ',27),'Atomic SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     PRODUCE SPECTRUM SUMMARY
      CALL SPECTRM0
C
C     MOLECULAR ENERGIES
20    FORMAT(1X,A,31X,F21.12)
      WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) 'Source',REPEAT(' ',60),'Energy'
      WRITE(7, *) 'Source',REPEAT(' ',60),'Energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Nucleus-nucleus  (N)',ENUC
      WRITE(7,20) 'Nucleus-nucleus  (N)',ENUC
      WRITE(6,20) 'One-electron     (H)',EONE
      WRITE(7,20) 'One-electron     (H)',EONE
      IF(HMLT.EQ.'BARE') GOTO 202
      WRITE(6,20) 'Coulomb (closed) (G)',ECLG
      WRITE(7,20) 'Coulomb (closed) (G)',ECLG
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 202
      WRITE(6,20) 'Breit (closed)   (B)',EBRG
      WRITE(7,20) 'Breit (closed)   (B)',EBRG
202   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) 'Molecule total   (F)',ETOT
      WRITE(7,20) 'Molecule total   (F)',ETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     SAVE EIGENVECTORS TO OUTPUT FILE
      OPEN(UNIT=8,FILE=TRIM(WFNFL),STATUS='UNKNOWN')
      REWIND(UNIT=10)
      DO I=1,NDIM
        WRITE(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
C     TIME TAKEN FOR ATOMIC CALCULATION
      CALL CPU_TIME(TTOT)
      TTOT = TTOT - TDUM
C
C     DATE AND TIME AT END OF ITERATION
      CALL TIMENOW(STAMP)
C
C     CALCULATION TIME
30    FORMAT(1X,A,26X,A)
      WRITE(6,30) 'Total atomic SCF time         ',HMS(TTOT)
      WRITE(7,30) 'Total atomic SCF time         ',HMS(TTOT)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Time at end of calculation',STAMP
      WRITE(7,30) 'Time at end of calculation',STAMP
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE ATOM1E(ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             AA   TTTTTTTT OOOOOO  MM       MM  11  EEEEEEEE          C
C            AAAA     TT   OO    OO MMM     MMM 111  EE                C
C           AA  AA    TT   OO    OO MMMM   MMMM  11  EE                C
C          AA    AA   TT   OO    OO MM MM MM MM  11  EEEEEE            C
C          AAAAAAAA   TT   OO    OO MM  MMM  MM  11  EE                C
C          AA    AA   TT   OO    OO MM   M   MM  11  EE                C
C          AA    AA   TT    OOOOOO  MM       MM 1111 EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ATOM1E CALCUATES THE SOLUTION TO A ONE-ELECTRON ATOMIC PROBLEM.     C
C  THERE IS NO NEED FOR AVERAGE-OVER CONFIGUTION TREATMENT HERE, SO    C
C  RESULTS ARE STORED IN THE MASTER LIST OF A SINGLE ORBITAL.          C
C  ALL SOLUTIONS OF THE EIGENVALUE PROBLEM ARE EXPORTED TO COEF.       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT - ATOMIC CENTRE INDEX                                        C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MBD=2*MBS,MB2=MBS*MBS,MCT=4,MKP=9,
     &                                    MNU=MKP+1,LWK=128*MBS,MIT=100)
C
      CHARACTER*1 ELLTERM,QSGN
      CHARACTER*2 ELMT(120),ELNM
      CHARACTER*4 HMLT
      CHARACTER*8 ZWRT,QWRT,EWRT
C
      DIMENSION O2(MBD,MBD),H2(MBD,MBD),U2(MBD,MBD)
      DIMENSION W2(MBD),T(LWK),EXL(MBS)
      DIMENSION NORB(MKP,MKP+1),NUMOCC((MKP+1)/2)
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FILL/NCNF(MCT,MKP,MKP+1),NLVL(MCT,MKP),IFILL(MCT)
      COMMON/MDLV/ELMT
      COMMON/OCPD/IOCPN(MDM),IOCCM0
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     IMPORT ATOMIC CHARGE DETAILS
      IZNV = IZNC(ICNT)
      ZCRG = ZNUC(ICNT)
      ELNM = ELMT(IZNV)
      ICRG = IQNC(ICNT)
      MLQN = LMAX(ICNT)
C
C     CONVERT IZNV AND ICRG TO STRINGS AND WRITE TITLE
      IF(IZNV.LT.10) THEN
        WRITE(ZWRT,'(A,I1)') 'Z = ',IZNV
      ELSEIF(IZNV.LT.100) THEN
        WRITE(ZWRT,'(A,I2)') 'Z = ',IZNV
      ELSE
        WRITE(ZWRT,'(A,I3)') 'Z = ',IZNV
      ENDIF
C
      IF(ICRG.LT.10) THEN
        WRITE(QWRT,'(A,I2)') 'Q = ',ICRG
      ELSEIF(IZNV.LT.100) THEN
        WRITE(QWRT,'(A,I3)') 'Q = ',ICRG
      ELSE
        WRITE(QWRT,'(A,I4)') 'Q = ',ICRG
      ENDIF
C
      IF(ICRG.GT.0) THEN
        QSGN = '+'
      ELSEIF(ICRG.LT.0) THEN
        QSGN = '-'
      ENDIF
C
      ICMD = IABS(ICRG)
      IF(ICRG.EQ.0) THEN
        WRITE(EWRT,'(A,A,A)') '(',TRIM(ELNM),')'
      ELSEIF(ICMD.EQ.1) THEN
        WRITE(EWRT,'(A,A,A,A,A)') '(',TRIM(ELNM),'^',QSGN,')'
      ELSEIF(ICMD.LT.10) THEN
        WRITE(EWRT,'(A,A,A,I1,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSEIF(ICMD.LT.100) THEN
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSE
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ENDIF
C
C     PRINT TITLE SUMMARY FOR THIS ATOM
20    FORMAT(17X,'Centre',I3,':',3X,A,3X,A,3X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) ICNT,ZWRT,QWRT,EWRT
      WRITE(7,20) ICNT,ZWRT,QWRT,EWRT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
      IF(IFILL(ICNT).EQ.0) THEN
        CALL AUFBAU(IZNV,ICRG,NORB,NUMOCC,LMXCONF)
      ELSE
        LMXCONF = LMAX(ICNT)
        DO L=0,LMXCONF
          NUMOCC(L+1) = NLVL(ICNT,L+1)
          DO N=1,NLVL(ICNT,L+1)
            NORB(L+1,N) = NCNF(ICNT,L+1,N)
          ENDDO
        ENDDO
      ENDIF
C
C     CHECK WHETHER THERE ARE SUFFICIENT BASIS FUNCTION TYPES
      IF(MLQN.LT.LMXCONF) THEN
        WRITE(6, *) 'In ATOM1E: insufficient angular types in basis.'
        WRITE(7, *) 'In ATOM1E: insufficient angular types in basis.'
        WRITE(6, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        WRITE(7, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        STOP
      ENDIF
C
C     PRINT ATOMIC CONFIGURATION
30    FORMAT(1X,A,2X,A,1X,'|',2X'NSHELL ',12(2X,I2))
31    FORMAT(1X,'LQN = ',I1,3X,I2,2X,'|'1X,' OCC(',A,'):',A,12(2X,I2))
C
      IF(IFILL(ICNT).EQ.0) THEN
        WRITE(6,30) 'Aufbau:','#fns',(N,N=1,12)
        WRITE(7,30) 'Aufbau:','#fns',(N,N=1,12)
      ELSE
        WRITE(6,30) 'Manual:','#fns',(N,N=1,12)
        WRITE(7,30) 'Manual:','#fns',(N,N=1,12)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO L=0,LMAX(ICNT)
        WRITE(6,31) L,NFNC(L+1,ICNT),ELLTERM(L),
     &               REPEAT(' ',L*4),(NORB(L+1,J),J=1,NUMOCC(L+1))
        WRITE(7,31) L,NFNC(L+1,ICNT),ELLTERM(L),
     &               REPEAT(' ',L*4),(NORB(L+1,J),J=1,NUMOCC(L+1))
      ENDDO
C
C     RESULTS FOR EACH ITERATION
40    FORMAT(1X,A,10X,A,10X,A,13X,A,11X,A)
41    FORMAT(I3,2X,F15.6,2X,F15.6,2X,F18.6,4X,ES12.5)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(7,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     IMPORT NUCLEAR RADIUS FOR THIS CENTRE
      PNUC = CNUC(ICNT)
C
C**********************************************************************C
C     ONE-BODY PROBLEM: IZNV-ICRG = 1. (NO COULOMB ENERGY.)            C
C**********************************************************************C
C
C     IDENTIFY LQN AND NQN FOR OCCUPIED ELECTRON
      DO L=0,LMXCONF
        DO N=1,NUMOCC(L+1)
          IF(NORB(L+1,N).EQ.1) THEN
            LQN = L
            NQN = N
          ENDIF
        ENDDO
      ENDDO
C
C     RELATIVISTIC QUANTUM NUMBER
      KQN =-LQN-1
C     KQN = LQN
C
C     MAGNETIC NUMBER (DOUBLE THE ACTUAL VALUE)
      MQNA =-1
C
C     CORRESPONDING FOCK ADDRESS FOR THIS KQN
      IF(KQN.LT.0) THEN
        KADD =-2*KQN-1
      ELSE
        KADD = 2*KQN
      ENDIF
C
C     CORRESPONDING FOCK ADDRESS FOR THIS MQN
      IF(MQNA.LT.0) THEN
        MADD =-MQNA
      ELSE
        MADD = MQNA+1
      ENDIF
C
C     EFFECTIVE AND AVERAGE OCCUPATION NUMBERS FOR THIS KQN ORBITAL
C     A CLOSED SUBSHELL (NQN,LQN) CONTAINS NCLS ELECTRONS
      IF(HMLT.EQ.'NORL') THEN
        NCLS = 4*LQN+2
      ELSE
        NCLS = 2*IABS(KQN)
      ENDIF
C
C     CORRESPONDING FOCK ADDRESS FOR THIS KQN
      IF(KQN.LT.0) THEN
        KADD =-2*KQN-1
      ELSE
        KADD = 2*KQN
      ENDIF
C
C     IMPORT BASIS FUNCTION EXPONENTS
      NBAS = NFNC(LQN+1,ICNT)
      DO IBAS=1,NBAS
        EXL(IBAS) = BSET(IBAS,LQN+1,ICNT)
      ENDDO
C
C     MATRIX DIMENSIONS FOR THIS LQN BLOCK
      IF(HMLT.EQ.'NORL') THEN
        NBLC = 0
      ELSE
        NBLC = NBAS
      ENDIF
      NMAT = NBAS+NBLC
C
C     GENERATE OVERLAP AND BARE DIRAC MATRICES
      CALL OVRLP0(O2,EXL,     KQN,NBAS)
      CALL ONEEL0(H2,EXL,ZCRG,KQN,NBAS)
C     CALL KINTC0(H2,EXL,     KQN,NBAS)
C     CALL PNTNC0(H2,EXL,ZCRG,KQN,NBAS)
C     CALL GSSNC0(H2,EXL,ZCRG,KQN,NBAS)
C
C     ATOMIC UEHLING INTERACTION
      IF(HMLT.EQ.'DHFQ') THEN
C
C       GENERATE UEHLING MATRIX ELEMENTS
        CALL UEHLING0(U2,EXL,ZCRG,KQN,NBAS)
C
C       ADD UEHLING MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
        DO IBAS=1,NMAT
          DO JBAS=1,NMAT
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + U2(IBAS,JBAS)
          ENDDO
        ENDDO
C
      ENDIF
C
C     DIAGONALISE MATRIX (THIS NEEDS LAPACK LIBRARY)
      CALL DSYGV(1,'V','U',NMAT,H2,MBD,O2,MBD,W2,T,LWK,INFO)
      IF(INFO.NE.0) THEN
        WRITE(6, *) 'In ATOM1E: eigenvalue solver DSYGV failed.',INFO
        WRITE(7, *) 'In ATOM1E: eigenvalue solver DSYGV failed.',INFO
        STOP
      ENDIF
C
C     NON-RELATIVISTIC CASE
      IF(HMLT.EQ.'NORL') THEN
C
C       FOCK MATRIX ADDRESSES
        IL = LRGE(ICNT,KADD,MADD)
C
C       INCREASE NUMBER OF ELECTRONS IN SYSTEM
        IOCCM0 = IOCCM0+1
        IOCPN(IOCCM0) = NQN
C
C       LOOP OVER SOLUTIONS OF EIGENVALUE EQUATION
        DO IBAS=1,NBAS
C
C         COPY ENERGY EIGENVALUES TO MASTER LIST
          EIGN(NSKP+IBAS) = W2(NBLC+IBAS)
C
C         LOOP OVER BASIS FUNCTIONS
          DO JBAS=1,NBAS
C
C           SPINOR COEFFICIENT FOR THIS BASIS FUNCTION
            CLP = H2(JBAS     ,NBLC+IBAS)
C
C           COPY INTO MASTER COEFFICIENT LIST
            COEF(IL+JBAS,NSKP+IBAS) = DCMPLX(CLP,0.0D0)
C
          ENDDO
C
        ENDDO
C
C     RELATIVISTIC CASE
      ELSE
C
C       FOCK MATRIX ADDRESSES
        IL = LRGE(ICNT,KADD,MADD)
        IS = LRGE(ICNT,KADD,MADD)+NSKP
        WRITE(*,*) IL
C
C       INCREASE NUMBER OF ELECTRONS IN SYSTEM
        IOCCM0 = IOCCM0+1
        IOCPN(IOCCM0) = NQN
        WRITE(*,*) NQN,IOCPN(IOCCM0)
C
C       LOOP OVER SOLUTIONS OF EIGENVALUE EQUATION
        DO IBAS=1,NBAS
C
C         COPY ENERGY EIGENVALUES TO MASTER LIST
          EIGN(NSKP+IBAS) = W2(NBLC+IBAS)
          EIGN(     IBAS) = W2(     IBAS)
C
C         LOOP OVER BASIS FUNCTIONS
          DO JBAS=1,NBAS
C
C           SPINOR COEFFICIENT FOR THIS BASIS FUNCTION
            CLP = H2(JBAS     ,NBLC+IBAS)
            CLN = H2(JBAS     ,     IBAS)
            CSP = H2(JBAS+NBLC,NBLC+IBAS)
            CSN = H2(JBAS+NBLC,     IBAS)
C
C           COPY INTO MASTER COEFFICIENT LIST
            COEF(IL+JBAS,NSKP+IBAS) = DCMPLX(CLP,0.0D0)
            COEF(IL+JBAS,     IBAS) = DCMPLX(CLN,0.0D0)
            COEF(IS+JBAS,NSKP+IBAS) = DCMPLX(CSP,0.0D0)
            COEF(IS+JBAS,     IBAS) = DCMPLX(CSN,0.0D0)
C
          ENDDO
C
        ENDDO
C        
      ENDIF
C
C     ONE- AND TWO-BODY ENERGIES
      EH = W2(NBLC+NQN)
C
C     UEHLING INTERACTION ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          M = M+1
C
C         MATRIX ELEMENT (LL) CONTRIBUTION
          VIJ = H2(IBAS,NBLC+NQN)*H2(JBAS,NBLC+NQN)
          EU  = EU + U2(IBAS,JBAS)*VIJ
C
          IF(HMLT.NE.'NORL') THEN
C
C           SMALL-COMPONENT ADDRESSES
            KBAS = IBAS+NBLC
            LBAS = JBAS+NBLC
C
C           MATRIX ELEMENT (SS) CONTRIBUTION
            VIJ = H2(KBAS,NBLC+NQN)*H2(LBAS,NBLC+NQN)
            EU  = EU + U2(KBAS,LBAS)*VIJ
C
          ENDIF
C
        ENDDO
      ENDDO
C
      EG = 0.0D0
      EB = 0.0D0
      ENEW = EH
C
C     WRITE RESULT
      WRITE(6,41) 1,EH,0.0D0,ENEW,1.0D0
      WRITE(7,41) 1,EH,0.0D0,ENEW,1.0D0
C
C**********************************************************************C
C     WRITTEN SUMMARY                                                  C
C**********************************************************************C
C
C     SUMMARY OF ENERGY CONTRIBUTIONS
50    FORMAT(1X,A,24X,F19.12)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,50) 'One-electron energy          ',EH
      WRITE(7,50) 'One-electron energy          ',EH
      WRITE(6,50) 'Two-electron energy (Coulomb)',EG
      WRITE(7,50) 'Two-electron energy (Coulomb)',EG
      IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 500
      WRITE(6,50) 'Two-electron energy (Breit)  ',EB
      WRITE(7,50) 'Two-electron energy (Breit)  ',EB
500   CONTINUE
      WRITE(6,50) 'Total energy                 ',ENEW
      WRITE(7,50) 'Total energy                 ',ENEW
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
C
      RETURN
      END
C
C
      SUBROUTINE HFSCF0(ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          HH    HH FFFFFFFF SSSSSS   CCCCCC  FFFFFFFF 000000          C
C          HH    HH FF      SS    SS CC    CC FF      00   000         C
C          HH    HH FF      SS       CC       FF      00  0000         C
C          HHHHHHHH FFFFFF   SSSSSS  CC       FFFFFF  00 00 00         C
C          HH    HH FF            SS CC       FF      0000  00         C
C          HH    HH FF      SS    SS CC    CC FF      000   00         C
C          HH    HH FF       SSSSSS   CCCCCC  FF       000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  HFSCF PERFORMS AN ATOMIC SINGLE-DETERMINANT ITERATIVE SELF-         C
C  CONSISTENT FIELD PROCEDURE OVER THE USER-SPECIFIED HAMILTONIAN.     C
C  USES THE CLOSED-SHELL AVERAGE OF CONFIGURATION MODEL, WITH SUBSHELL C
C  OCCUPATIONS DETERMINED EITHER MANUALLY OR BY THE AUFBAU ROUTINE.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT - ATOMIC CENTRE INDEX                                        C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MBD=2*MBS,MB2=MBS*MBS,MCT=4,MKP=9,
     &                                    MNU=MKP+1,LWK=128*MBS,MIT=100)
C
      CHARACTER*1 ELLTERM,QSGN
      CHARACTER*2 ELMT(120),ELNM
      CHARACTER*4 HMLT
      CHARACTER*8 ZWRT,QWRT,EWRT
      CHARACTER*80 TITLE
C
      DIMENSION QE(MKP),QA(MKP),NORB(MKP,MKP+1),NUMOCC((MKP+1)/2)
      DIMENSION W1(MBD),W2(MBD),T(LWK)
      DIMENSION O1(MBD,MBD),H1(MBD,MBD),U1(MBD,MBD),
     &          O2(MBD,MBD),H2(MBD,MBD),U2(MBD,MBD)
      DIMENSION DENLL(MB2,MKP),DFNLL(MB2,MKP),
     &          DENSL(MB2,MKP),DFNSL(MB2,MKP),
     &          DENSS(MB2,MKP),DFNSS(MB2,MKP),
     &          DENLS(MB2,MKP),DFNLS(MB2,MKP)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/ATMB/B11(MBD,MBD),B21(MBD,MBD),B12(MBD,MBD),B22(MBD,MBD)
      COMMON/ATMC/G11(MBD,MBD),G21(MBD,MBD),G12(MBD,MBD),G22(MBD,MBD)
      COMMON/ATMD/DLL1(MB2),DSL1(MB2),DSS1(MB2),DLS1(MB2),
     &            DLL2(MB2),DSL2(MB2),DSS2(MB2),DLS2(MB2)
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/FILL/NCNF(MCT,MKP,MKP+1),NLVL(MCT,MKP),IFILL(MCT)
      COMMON/MDLV/ELMT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/OCPD/IOCPN(MDM),IOCCM0
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     GENERATE LIST OF FACTORIALS
      CALL FACTRLS
C
C     CONVERGENCE TOLERANCE VALUE
      IF(HMLT.EQ.'NORL') THEN
        ENRGTOL = 5.0D-12
      ELSE
        ENRGTOL = 5.0D-13
      ENDIF
C
C     IMPORT ATOMIC CHARGE DETAILS
      IZNV = IZNC(ICNT)
      ZCRG = ZNUC(ICNT)
      ELNM = ELMT(IZNV)
      ICRG = IQNC(ICNT)
      MLQN = LMAX(ICNT)
C
C     CONVERT IZNV AND ICRG TO STRINGS AND WRITE TITLE
      IF(IZNV.LT.10) THEN
        WRITE(ZWRT,'(A,I1)') 'Z = ',IZNV
      ELSEIF(IZNV.LT.100) THEN
        WRITE(ZWRT,'(A,I2)') 'Z = ',IZNV
      ELSE
        WRITE(ZWRT,'(A,I3)') 'Z = ',IZNV
      ENDIF
C
      IF(ICRG.LT.10) THEN
        WRITE(QWRT,'(A,I2)') 'Q = ',ICRG
      ELSEIF(IZNV.LT.100) THEN
        WRITE(QWRT,'(A,I3)') 'Q = ',ICRG
      ELSE
        WRITE(QWRT,'(A,I4)') 'Q = ',ICRG
      ENDIF
C
      IF(ICRG.GT.0) THEN
        QSGN = '+'
      ELSEIF(ICRG.LT.0) THEN
        QSGN = '-'
      ENDIF
C
      ICMD = IABS(ICRG)
      IF(ICRG.EQ.0) THEN
        WRITE(EWRT,'(A,A,A)') '(',TRIM(ELNM),')'
      ELSEIF(ICMD.EQ.1) THEN
        WRITE(EWRT,'(A,A,A,A,A)') '(',TRIM(ELNM),'^',QSGN,')'
      ELSEIF(ICMD.LT.10) THEN
        WRITE(EWRT,'(A,A,A,I1,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSEIF(ICMD.LT.100) THEN
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ELSE
        WRITE(EWRT,'(A,A,A,I2,A,A)') '(',TRIM(ELNM),'^',ICMD,QSGN,')'
      ENDIF
C
C     PRINT TITLE SUMMARY FOR THIS ATOM
20    FORMAT(17X,'Centre',I3,':',3X,A,3X,A,3X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) ICNT,ZWRT,QWRT,EWRT
      WRITE(7,20) ICNT,ZWRT,QWRT,EWRT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     READ OR GENERATE AUFBAU OCCUPANCY FOR THIS ATOM
      IF(IFILL(ICNT).EQ.0) THEN
        CALL AUFBAU(IZNV,ICRG,NORB,NUMOCC,LMXCONF)
      ELSE
        LMXCONF = LMAX(ICNT)
        DO LQN=0,LMXCONF
          NUMOCC(LQN+1) = NLVL(ICNT,LQN+1)
          DO NQN=1,NLVL(ICNT,LQN+1)
            NORB(LQN+1,NQN) = NCNF(ICNT,LQN+1,NQN)
          ENDDO
        ENDDO
      ENDIF
C
C     IDENTIFY THE HIGHEST OCCUPIED SHELL
      NMAX = 1
      DO LQN=1,LMXCONF+1
        IF(NUMOCC(LQN).GT.NMAX) THEN
          NMAX = NUMOCC(LQN)
        ENDIF
      ENDDO
C
C     CHECK WHETHER THERE ARE SUFFICIENT BASIS FUNCTION TYPES
      IF(MLQN.LT.LMXCONF) THEN
        WRITE(6, *) 'In HFSCF0: insufficient angular types in basis.'
        WRITE(7, *) 'In HFSCF0: insufficient angular types in basis.'
        WRITE(6, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        WRITE(7, *) 'MLQN = ',MLQN,' and LMXCONF = ',LMXCONF
        STOP
      ENDIF
C
C     PRINT ATOMIC CONFIGURATION
30    FORMAT(1X,A,2X,A,1X,'|',2X'NSHELL ',12(2X,I2))
31    FORMAT(1X,'LQN = ',I1,3X,I2,2X,'|'1X,' OCC(',A,'):',A,12(2X,I2))
C
      IF(IFILL(ICNT).EQ.0) THEN
        WRITE(6,30) 'Aufbau:','#fns',(N,N=1,12)
        WRITE(7,30) 'Aufbau:','#fns',(N,N=1,12)
      ELSE
        WRITE(6,30) 'Manual:','#fns',(N,N=1,12)
        WRITE(7,30) 'Manual:','#fns',(N,N=1,12)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO LQN=0,LMAX(ICNT)
        WRITE(6,31) LQN,NFNC(LQN+1,ICNT),ELLTERM(LQN),
     &               REPEAT(' ',LQN*4),(NORB(LQN+1,J),J=1,NUMOCC(LQN+1))
        WRITE(7,31) LQN,NFNC(LQN+1,ICNT),ELLTERM(LQN),
     &               REPEAT(' ',LQN*4),(NORB(LQN+1,J),J=1,NUMOCC(LQN+1))
      ENDDO
C
C     RESULTS FOR EACH ITERATION
40    FORMAT(1X,A,10X,A,10X,A,13X,A,11X,A)
41    FORMAT(I3,2X,F15.6,2X,F15.6,2X,F18.6,4X,ES12.5)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(7,40) 'It','E1 (au)','E2 (au)','ET (au)','Ratio'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     IMPORT NUCLEAR RADIUS FOR THIS CENTRE
      PNUC = CNUC(ICNT)
C
C     INITIALISE A STORAGE BIN FOR PREVIOUS ATOMIC ENERGY
      EPRV = 0.0D0
C
C**********************************************************************C
C     ZERO-BODY PROBLEM: IZNV-ICRG = 0. (NO ELECTRONS AROUND CENTRE.)  C
C**********************************************************************C
C
      IF(IZNV.EQ.ICRG) THEN
C
C       NO OCCUPYING ELECTRON -> NO EIGENVALUE NEEDED
C
        EH = 0.0D0
        EG = 0.0D0
        EB = 0.0D0
        ENEW = EH-EG-EB

        WRITE(6,41) 1,EH,EG,ENEW,1.0D0
        WRITE(7,41) 1,EH,EG,ENEW,1.0D0
C
        GOTO 1001
C
C**********************************************************************C
C     ONE-BODY PROBLEM: IZNV-ICRG = 1. (NO COULOMB ENERGY.)            C
C**********************************************************************C
C
      ELSEIF(IZNV-ICRG.EQ.1) THEN
C
C       IMPORT ORDERED ELECTRON OCCUPATION NUMBER
        IOCCML = IOCCM0
C
C       IDENTIFY LQNA AND NSHELL FOR OCCUPIED ELECTRON
        DO LQN=0,LMXCONF
          DO NQN=1,NUMOCC(LQN+1)
            IF(NORB(LQN+1,NQN).EQ.1) THEN
              LQNA   = LQN
              NSHELL = NQN
            ENDIF
          ENDDO
        ENDDO
C
C       CORRESPONDING RELATIVISTIC QUANTUM NUMBER
        KAPA2 =-LQNA-1
C       KAPA2 = LQNA
C
C       EFFECTIVE AND AVERAGE OCCUPATION NUMBERS FOR THIS KQNA ORBITAL
C       A CLOSED SUBSHELL (NSHELL,LQNA) CONTAINS NCLS ELECTRONS
        IF(HMLT.EQ.'NORL') THEN
          NCLS = 4*LQNA+2
        ELSE
          NCLS = 2*IABS(KAPA2)
        ENDIF
        RK2A2 = DFLOAT(NCLS)
C
C       CORRESPONDING FOCK ADDRESS FOR THIS KQN
        IF(KAPA2.LT.0) THEN
          KADD =-2*KAPA2-1
        ELSE
          KADD = 2*KAPA2
        ENDIF
C
C       IMPORT BASIS FUNCTION EXPONENTS
        NBASA = NFNC(LQNA+1,ICNT)
        DO IBAS=1,NBASA
          EXLA(IBAS) = BSET(IBAS,LQNA+1,ICNT)
        ENDDO
C
C       MATRIX DIMENSIONS FOR THIS LQNA BLOCK
        IF(HMLT.EQ.'NORL') THEN
          NBLC = 0
        ELSE
          NBLC = NBASA
        ENDIF
        NMAT = NBASA+NBLC
C
C       GENERATE OVERLAP AND BARE DIRAC MATRICES
        CALL OVRLP0(O2,EXLA,     KAPA2,NBASA)
        CALL ONEEL0(H2,EXLA,ZCRG,KAPA2,NBASA)
C       CALL KINTC0(H2,EXLA,     KAPA2,NBASA)
C       CALL PNTNC0(H2,EXLA,ZCRG,KAPA2,NBASA)
C       CALL GSSNC0(H2,EXLA,ZCRG,KAPA2,NBASA)
C
C       ATOMIC UEHLING INTERACTION
        IF(HMLT.EQ.'DHFQ') THEN
C
C         GENERATE UEHLING MATRIX ELEMENTS
          CALL UEHLING0(U2,EXLA,ZCRG,KAPA2,NBASA)
C
C         ADD UEHLING MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
          DO IBAS=1,NMAT
            DO JBAS=1,NMAT
              H2(IBAS,JBAS) = H2(IBAS,JBAS) + U2(IBAS,JBAS)
            ENDDO
          ENDDO
C
        ENDIF
C
C       DIAGONALISE MATRIX (THIS NEEDS LAPACK LIBRARY)
        CALL DSYGV(1,'V','U',NMAT,H2,MBD,O2,MBD,W2,T,LWK,INFO)
        IF(INFO.NE.0) THEN
          WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
          WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
          STOP
        ENDIF
C
C       EFFECTIVE OCCUPANCY
        QF = DSQRT(1.0D0/DFLOAT(NCLS))
C
C       LOOP OVER ALL STATES IN THIS SUBSHELL
        DO ISUB=1,NCLS
C
C         NON-RELATIVISTIC CASE
          IF(HMLT.EQ.'NORL') THEN
C
C           FOCK MATRIX ADDRESSES
            IF(ISUB.LE.(2*LQNA)) THEN
              IL = LRGE(ICNT,2*LQNA  ,ISUB       )
            ELSE
              IL = LRGE(ICNT,2*LQNA+1,ISUB-2*LQNA)
            ENDIF
C
C           COPY ENERGY EIGENVALUES TO MASTER LIST
            EIGN(NSKP+IOCCML+ISUB) = W2(NBLC+NSHELL)
C
C           LOOP OVER BASIS FUNCTIONS
            DO IBAS=1,NBASA
C
C             SPINOR COEFFICIENT FOR THIS BASIS FUNCTION
              CLP = QF*H2(IBAS     ,NSHELL+NBLC)
C
C             COPY INTO MASTER COEFFICIENT LIST
              COEF(IL+IBAS,NSKP+IOCCML+ISUB) = DCMPLX(CLP,0.0D0)
C
            ENDDO
C
C         RELATIVISTIC CASE
          ELSE
C
C           COPY ENERGY EIGENVALUES TO MASTER LIST
            EIGN(     IOCCML+ISUB) = W2(     NSHELL)
            EIGN(NSKP+IOCCML+ISUB) = W2(NBLC+NSHELL)
C
C           FOCK MATRIX ADDRESSES
            IL = LRGE(ICNT,KADD,ISUB)
            IS = LRGE(ICNT,KADD,ISUB)+NSKP
C
C           LOOP OVER BASIS FUNCTIONS
            DO IBAS=1,NBASA
C
C             SPINOR COEFFICIENT FOR THIS BASIS FUNCTION
              CLN = QF*H2(IBAS     ,NSHELL     )
              CLP = QF*H2(IBAS     ,NSHELL+NBLC)
              CSN = QF*H2(IBAS+NBLC,NSHELL     )
              CSP = QF*H2(IBAS+NBLC,NSHELL+NBLC)
C
C             COPY INTO MASTER COEFFICIENT LIST
              COEF(IL+IBAS,     IOCCML+ISUB) = DCMPLX(CLN,0.0D0)
              COEF(IL+IBAS,NSKP+IOCCML+ISUB) = DCMPLX(CLP,0.0D0)
              COEF(IS+IBAS,     IOCCML+ISUB) = DCMPLX(CSN,0.0D0)
              COEF(IS+IBAS,NSKP+IOCCML+ISUB) = DCMPLX(CSP,0.0D0)
C
            ENDDO
C        
          ENDIF
C
        ENDDO
C
C       INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (NCLS AT A TIME)
        IOCCML = IOCCML+NCLS
C
C       ONE- AND TWO-BODY ENERGIES
        EH = W2(NBLC+NSHELL)
C
C       UEHLING INTERACTION ENERGIES FOR OCCUPIED ELECTRONS
        M = 0
        DO IBAS=1,NBASA
          DO JBAS=1,NBASA
            M = M+1
C
C           MATRIX ELEMENT (LL) CONTRIBUTION
            VIJ = H2(IBAS,NBLC+NSHELL)*H2(JBAS,NBLC+NSHELL)
            EU  = EU + U2(IBAS,JBAS)*VIJ
C
            IF(HMLT.NE.'NORL') THEN
C
C             SMALL-COMPONENT ADDRESSES
              KBAS = IBAS+NBLC
              LBAS = JBAS+NBLC
C
C             MATRIX ELEMENT (SS) CONTRIBUTION
              VIJ = H2(KBAS,NBLC+NSHELL)*H2(LBAS,NBLC+NSHELL)
              EU  = EU + U2(KBAS,LBAS)*VIJ
C
            ENDIF
C
          ENDDO
        ENDDO
C
        EG = 0.0D0
        EB = 0.0D0
        ENEW = EH
C
C       WRITE RESULT
        WRITE(6,41) 1,EH,0.0D0,ENEW,1.0D0
        WRITE(7,41) 1,EH,0.0D0,ENEW,1.0D0
C
C       UPDATE FOCK LABEL FOR OCCUPATION COUNTER
        IOCCM0 = IOCCML
C
C       EXIT TO CONVERGENCE
        GOTO 1001
C
      ENDIF
C
C**********************************************************************C
C     TWO-BODY PROBLEM: INTERACTING ELECTRONS. (TREAT WITH SCF.)       C
C -------------------------------------------------------------------- C
C     ENTER ITERATIVE SELF-CONSISTENT FIELD PROCEDURE (USE INDEX 1000) C
C**********************************************************************C
C
      DO 1000 ITER=1,MIT
C
C       INITIALISE ONE-BODY AND TWO-BODY ENERGY COUNTERS
        EH = 0.0D0
        EU = 0.0D0
        EG = 0.0D0
        EB = 0.0D0
C
C       INITIALISE ELECTRON OCCUPATION COUNTER
        IOCCML = IOCCM0
C
C**********************************************************************C
C     ONE-ELECTRON PART: LOOP OVER BASIS FUNCTIONS I,J (USE INDEX 100) C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO 100 LQNA=0,LMXCONF
C
C     RECORD LQNA VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
      NBASA = NFNC(LQNA+1,ICNT)
      DO IBAS=1,NBASA
        EXLA(IBAS) = BSET(IBAS,LQNA+1,ICNT)
      ENDDO
C
C     MATRIX DIMENSIONS FOR THIS LQNA BLOCK
      IF(HMLT.EQ.'NORL') THEN
        NBLC = 0
      ELSE
        NBLC = NBASA
      ENDIF
      NMAT = NBASA+NBLC
C
C     EFFECTIVE AND AVERAGE OCCUPATION NUMBERS FOR THIS LQNA ORBITAL
C     A CLOSED SUBSHELL (NSHELL,LQNA) CONTAINS NCLS ELECTRONS
      NCLS = 4*LQNA+2
C
C     FOR EACH LISTED SUBSHELLS OF LQN TYPE
      DO IOCC=1,NUMOCC(LQNA+1)
C
C       NUMBER OF CHARGES IN THIS SUBSHELL (NSHELL=IOCC+LQNA)
        NQ = NORB(LQNA+1,IOCC)
C
        IF(NQ.EQ.NCLS) THEN
C         IF SUBSHELL IS CLOSED THERE IS NO FRACTIONAL OCCUPANCY
          QE(IOCC) = 1.0D0
        ELSE
C         IF SUBSHELL IS OPEN, CONSTRUCT FRACTION (GRANT 6.6.24)
          QE(IOCC) = DFLOAT(NQ-1)/DFLOAT(NCLS-1)
        ENDIF
C
C       ACTUAL FRACTIONAL SUBSHELL OCCUPANCY
        IF(NQ.GT.0) THEN
          QA(IOCC) = DFLOAT(NQ)/DFLOAT(NCLS)
        ELSE
          QA(IOCC) = 0.0D0
        ENDIF
C
      ENDDO
C
C     POSITIVE KAPPA(A) CHOICE (APPLIES ONLY FOR LQNA > 0)
      IF(LQNA.EQ.0.OR.HMLT.EQ.'NORL') GOTO 130

      KAPA1 = LQNA
      RK2A1 = DFLOAT(2*IABS(KAPA1))
C
C     GENERATE OVERLAP AND BARE DIRAC MATRICES
      CALL OVRLP0(O1,EXLA,     KAPA1,NBASA)
      CALL ONEEL0(H1,EXLA,ZCRG,KAPA1,NBASA)
C     CALL KINTC0(H1,EXLA,     KAPA1,NBASA)
C     CALL PNTNC0(H1,EXLA,ZCRG,KAPA1,NBASA)
C     CALL GSSNC0(H1,EXLA,ZCRG,KAPA1,NBASA)
C
C     ATOMIC UEHLING INTERACTION
      IF(HMLT.EQ.'DHFQ') THEN
C
C       GENERATE UEHLING MATRIX ELEMENTS
        CALL UEHLING0(U1,EXLA,ZCRG,KAPA1,NBASA)
C
C       ADD UEHLING MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
        DO IBAS=1,NMAT
          DO JBAS=1,NMAT
            H1(IBAS,JBAS) = H1(IBAS,JBAS) + U1(IBAS,JBAS)
          ENDDO
        ENDDO
C
      ENDIF
C
130   CONTINUE
C
C     NEGATIVE KAPPA(A) CHOICE (APPLIES TO ALL LQNA VALUES)
      KAPA2 =-LQNA-1
      IF(HMLT.EQ.'NORL') THEN
        RK2A2 = DFLOAT(NCLS)
      ELSE
        RK2A2 = DFLOAT(2*IABS(KAPA2))
      ENDIF
C
C     GENERATE OVERLAP AND BARE DIRAC MATRICES
      CALL OVRLP0(O2,EXLA,     KAPA2,NBASA)
      CALL ONEEL0(H2,EXLA,ZCRG,KAPA2,NBASA)
C     CALL KINTC0(H2,EXLA,     KAPA2,NBASA)
C     CALL PNTNC0(H2,EXLA,ZCRG,KAPA2,NBASA)
C     CALL GSSNC0(H2,EXLA,ZCRG,KAPA2,NBASA)
C
C     ATOMIC UEHLING INTERACTION
      IF(HMLT.EQ.'DHFQ') THEN
C
C       GENERATE UEHLING MATRIX ELEMENTS
        CALL UEHLING0(U2,EXLA,ZCRG,KAPA2,NBASA)
C
C       ADD UEHLING MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
        DO IBAS=1,NMAT
          DO JBAS=1,NMAT
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + U2(IBAS,JBAS)
          ENDDO
        ENDDO
C
      ENDIF
C
C     SKIP SCF INTERACTIONS IN FIRST ITERATION
      IF(ITER.EQ.1) GOTO 150
C
C     INITIALISE RELEVANT COUNTERS AND ARRAYS
      RK2B1 = 0.0D0
      RK2B2 = 0.0D0
C
C**********************************************************************C
C     TWO-ELECTRON PART: LOOP OVER BASIS FUNCTIONS K,L (USE INDEX 200) C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO 200 LQNB=0,LMXCONF
C
C     RECORD LQNB VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
      NBASB = NFNC(LQNB+1,ICNT)
      DO JBAS=1,NBASB
        EXLB(JBAS) = BSET(JBAS,LQNB+1,ICNT)
      ENDDO
C
C     NUMBER OF BASIS FUNCTION OVERLAPS IN THIS BLOCK
      MAXM = NBASB*NBASB
C
C     POSITIVE KAPPA(B) CHOICE (APPLIES ONLY FOR LQNB > 0)
      IF(LQNB.EQ.0.OR.HMLT.EQ.'NORL') GOTO 230
C
C     ANGULAR QUANTUM NUMBER AND DEGENERACY
      KAPB1 = LQNB
      RK2B1 = DFLOAT(2*IABS(KAPB1))
C
C     RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
      IF(LQNA.EQ.LQNB) THEN
        DO M=1,MAXM
          DLL1(M) = DENLL(M,2*LQNB  )
          DSL1(M) = DENSL(M,2*LQNB  )
          DSS1(M) = DENSS(M,2*LQNB  )
          DLS1(M) = DENLS(M,2*LQNB  )
        ENDDO
      ELSEIF(LQNA.NE.LQNB) THEN
        DO M=1,MAXM
          DLL1(M) = DFNLL(M,2*LQNB  )
          DSL1(M) = DFNSL(M,2*LQNB  )
          DSS1(M) = DFNSS(M,2*LQNB  )
          DLS1(M) = DFNLS(M,2*LQNB  )
        ENDDO
      ENDIF
C
230   CONTINUE
C
C     NEGATIVE KAPPA(B) CHOICE (APPLIES TO ALL LQNB VALUES)
C
C     ANGULAR QUANTUM NUMBER AND DEGENERACY
      KAPB2 =-LQNB-1
      IF(HMLT.EQ.'NORL') THEN
        RK2B2 = DFLOAT(4*LQNB+2)
      ELSE
        RK2B2 = DFLOAT(2*IABS(KAPB2))
      ENDIF
C
C     RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
      IF(LQNA.EQ.LQNB) THEN
        DO M=1,MAXM
          DLL2(M) = DENLL(M,2*LQNB+1)
          IF(HMLT.NE.'NORL') THEN
            DSL2(M) = DENSL(M,2*LQNB+1)
            DSS2(M) = DENSS(M,2*LQNB+1)
            DLS2(M) = DENLS(M,2*LQNB+1)
          ENDIF
        ENDDO
      ELSEIF(LQNA.NE.LQNB) THEN
        DO M=1,MAXM
          DLL2(M) = DFNLL(M,2*LQNB+1)
          IF(HMLT.NE.'NORL') THEN
            DSL2(M) = DFNSL(M,2*LQNB+1)
            DSS2(M) = DFNSS(M,2*LQNB+1)
            DLS2(M) = DFNLS(M,2*LQNB+1)
          ENDIF
        ENDDO
      ENDIF
C
C**********************************************************************C
C     GENERATE ATOMIC MEAN-FIELD COULOMB MATRIX                        C
C**********************************************************************C
C
C     GENERATE THE MEAN-FIELD ATOMIC COULOMB MATRIX OVER DENSITIES
      CALL COULOMB0
C
C     ADD COULOMB MATRIX ELEMENTS CONTRIBUTIONS TO FOCK MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC COULOMB MATRIX
C
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B2*G22(IBAS,JBAS)
C
          ELSE
C         RELATIVISTIC COULOMB MATRIX
C
            H1(IBAS,JBAS) = H1(IBAS,JBAS) + RK2B1*G11(IBAS,JBAS)
     &                                    + RK2B2*G12(IBAS,JBAS)
            H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B1*G21(IBAS,JBAS)
     &                                    + RK2B2*G22(IBAS,JBAS)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C     TWO-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC COULOMB ENERGY
C
            EG = EG + RK2A2*RK2B2*G22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
          ELSE
C         RELATIVISTIC  COULOMB ENERGY
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBASA
            LBAS = JBAS+NBASA
C
C           LL BLOCK
            EG = EG
     &         +       RK2A1*RK2B1*G11(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &         +       RK2A1*RK2B2*G12(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &         +       RK2A2*RK2B1*G21(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
     &         +       RK2A2*RK2B2*G22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C           SL BLOCK
            EG = EG
     &         + 2.0D0*RK2A1*RK2B1*G11(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &         + 2.0D0*RK2A1*RK2B2*G12(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &         + 2.0D0*RK2A2*RK2B1*G21(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
     &         + 2.0D0*RK2A2*RK2B2*G22(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
C
C           SS BLOCK
            EG = EG
     &         +       RK2A1*RK2B1*G11(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &         +       RK2A1*RK2B2*G12(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &         +       RK2A2*RK2B1*G21(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
     &         +       RK2A2*RK2B2*G22(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE ATOMIC MEAN-FIELD BREIT MATRIX                          C
C**********************************************************************C
C
C     GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX
      IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 250
C
C     GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX OVER DENSITIES
      CALL BREIT0
C
C     ADD TWO-PARTICLE CONTRIBUTIONS TO FOCK MATRIX
      DO IBAS=1,NMAT
        DO JBAS=1,NMAT
C
          H1(IBAS,JBAS) = H1(IBAS,JBAS) + RK2B1*B11(IBAS,JBAS)
     &                                  + RK2B2*B12(IBAS,JBAS)
          H2(IBAS,JBAS) = H2(IBAS,JBAS) + RK2B1*B21(IBAS,JBAS)
     &                                  + RK2B2*B22(IBAS,JBAS)
C
        ENDDO
      ENDDO
C
C     TWO-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBASA
          LBAS = JBAS+NBASA
C
C         LL BLOCK
          EB = EB
     &       +       RK2A1*RK2B1*B11(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &       +       RK2A1*RK2B2*B12(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &       +       RK2A2*RK2B1*B21(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
     &       +       RK2A2*RK2B2*B22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C         SL BLOCK
          EB = EB
     &       + 2.0D0*RK2A1*RK2B1*B11(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &       + 2.0D0*RK2A1*RK2B2*B12(KBAS,JBAS)*DFNSL(M,2*LQNA  )
     &       + 2.0D0*RK2A2*RK2B1*B21(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
     &       + 2.0D0*RK2A2*RK2B2*B22(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
C
C         SS BLOCK
          EB = EB
     &       +       RK2A1*RK2B1*B11(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &       +       RK2A1*RK2B2*B12(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &       +       RK2A2*RK2B1*B21(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
     &       +       RK2A2*RK2B2*B22(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
        ENDDO
      ENDDO
C
250   CONTINUE
C
C**********************************************************************C
C     FINISHED GENERATING TWO-ELECTRON INTEGRALS                       C
C**********************************************************************C
C
C     END LOOP OVER LQNS FOR ORBITAL B
200   CONTINUE
C
C       UEHLING INTERACTION ENERGIES FOR OCCUPIED ELECTRONS
        IF(HMLT.EQ.'DHFQ') THEN
C
          M = 0
          DO IBAS=1,NBASA
            DO JBAS=1,NBASA
              M = M+1
C
C             SMALL COMPONENT BLOCK ADDRESSES
              KBAS = IBAS+NBASA
              LBAS = JBAS+NBASA
C
C             LL BLOCK
              EU = EU + RK2A1*U1(IBAS,JBAS)*DFNLL(M,2*LQNA  )
     &                + RK2A2*U2(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
C
C             SS BLOCK
              EU = EU + RK2A1*U1(KBAS,LBAS)*DFNSS(M,2*LQNA  )
     &                + RK2A2*U2(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
            ENDDO
          ENDDO
C
        ENDIF
C
C     FINISH GENERATING SCF CONTRIBUTIONS
150   CONTINUE
C
C     FINISHED CALCULATING OVERLAP COMBINATIONS BETWEEN THIS LQNA
C     VALUE AND ALL POSSIBLE LQNB VALUES
C
C**********************************************************************C
C     MATRIX DIAGONALISATION AND COEFFICIENT MATRIX UPDATES            C
C**********************************************************************C
C
C     POSITIVE KAPPA(A) CHOICE (APPLIES ONLY FOR LQNA > 0)
      IF(LQNA.EQ.0.OR.HMLT.EQ.'NORL') GOTO 140
C
C     DIAGONALISE FOCK MATRIX (THIS NEEDS LAPACK LIBRARY)
      CALL DSYGV(1,'V','U',NMAT,H1,MBD,O1,MBD,W1,T,LWK,INFO)
      IF(INFO.NE.0) THEN
        WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        STOP
      ENDIF
C
C     ATOMIC SELECTION RULE: ORTHOGONALITY IN BLOCKS OF KQN -> KA = KB
C
C     BEGIN LOOP OVER MQNA VALUES
      DO IMVAL=1,IABS(KAPA1)
C
C       COEFFICIENT MATRIX ADDRESSES
        IL1 = LRGE(ICNT,2*LQNA  ,IMVAL*2-1)
        IL2 = LRGE(ICNT,2*LQNA  ,IMVAL*2  )
        IS1 = IL1+NSKP
        IS2 = IL2+NSKP
C
C       LOOP OVER ALL LISTED SUBSHELLS OF THIS KQN TYPE
        DO IOCC=1,NUMOCC(LQNA+1)
C
C         SKIP IF THIS SUBSHELL IS UNOCCUPIED
          IF(NORB(LQNA+1,IOCC).EQ.0) GOTO 132
C
C         EFFECTIVE OCCUPATION NUMBER
          QF = DSQRT(QA(IOCC))
C
C         COPY INTO MASTER COEFFICIENT LIST
          DO IBAS=1,NBASA
C
C           LARGE COMPONENT OF KRAMERS PAIR
            CLN = QF*H1(IBAS      ,IOCC     )
            CLP = QF*H1(IBAS      ,IOCC+NBLC)
C
            COEF(IL1+IBAS,     IOCCML+1) = DCMPLX(CLN,0.0D0)
            COEF(IL2+IBAS,     IOCCML+2) = DCMPLX(CLN,0.0D0)
            COEF(IL1+IBAS,NSKP+IOCCML+1) = DCMPLX(CLP,0.0D0)
            COEF(IL2+IBAS,NSKP+IOCCML+2) = DCMPLX(CLP,0.0D0)
C
C           SMALL COMPONENT OF KRAMERS PAIR
            CSP = QF*H1(IBAS+NBLC,IOCC+NBLC)
            CSN = QF*H1(IBAS+NBLC,IOCC     )
C
            COEF(IS1+IBAS,     IOCCML+1) = DCMPLX(CSN,0.0D0)
            COEF(IS2+IBAS,     IOCCML+2) = DCMPLX(CSN,0.0D0)
            COEF(IS1+IBAS,NSKP+IOCCML+1) = DCMPLX(CSP,0.0D0)
            COEF(IS2+IBAS,NSKP+IOCCML+2) = DCMPLX(CSP,0.0D0)
C
          ENDDO
C
C         STORE LOWEST ENERGY EIGENVALUES TO MASTER LIST
          EIGN(     IOCCML+1) = W1(     IOCC)
          EIGN(NSKP+IOCCML+1) = W1(NBLC+IOCC)
          EIGN(     IOCCML+2) = W1(     IOCC)
          EIGN(NSKP+IOCCML+2) = W1(NBLC+IOCC)
C
C         INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
          IOCCML = IOCCML+2
C
C         SKIP POINT FOR UNOCCUPIED ORBITALS
132       CONTINUE
C
        ENDDO
      ENDDO
C
C     BUILD ATOMIC CHARGE DENSITY MATRIX FOR THIS KQNA BLOCK
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         INITIALISE ATOMIC DENSITY LISTS FOR THIS BLOCK
          DENLL(M,2*LQNA  ) = 0.0D0
          DENSL(M,2*LQNA  ) = 0.0D0
          DENSS(M,2*LQNA  ) = 0.0D0
          DENLS(M,2*LQNA  ) = 0.0D0
C
          DFNLL(M,2*LQNA  ) = 0.0D0
          DFNSL(M,2*LQNA  ) = 0.0D0
          DFNSS(M,2*LQNA  ) = 0.0D0
          DFNLS(M,2*LQNA  ) = 0.0D0
C
C         LOOP OVER ALL LISTED SUBSHELLS OF THIS KQN TYPE
          DO IOCC=1,NUMOCC(LQNA+1)
C
C           SKIP THIS STEP SUBSHELL IS UNOCCUPIED
            IF(NORB(LQNA+1,IOCC).GT.0) THEN
            
C             DENSITY OVERLAPS FROM EIGENVECTOR PRODUCTS
              DLL = H1(IBAS     ,NBLC+IOCC)*H1(JBAS     ,NBLC+IOCC)
              DSL = H1(IBAS+NBLC,NBLC+IOCC)*H1(JBAS     ,NBLC+IOCC)
              DSS = H1(IBAS+NBLC,NBLC+IOCC)*H1(JBAS+NBLC,NBLC+IOCC)
              DLS = H1(IBAS     ,NBLC+IOCC)*H1(JBAS+NBLC,NBLC+IOCC)
C
C             ADD DENSITY CONTRIBUTIONS TO ATOMIC LIST
              DENLL(M,2*LQNA  ) = DENLL(M,2*LQNA  ) + QE(IOCC)*DLL
              DENSL(M,2*LQNA  ) = DENSL(M,2*LQNA  ) + QE(IOCC)*DSL
              DENSS(M,2*LQNA  ) = DENSS(M,2*LQNA  ) + QE(IOCC)*DSS
              DENLS(M,2*LQNA  ) = DENLS(M,2*LQNA  ) + QE(IOCC)*DLS
C
              DFNLL(M,2*LQNA  ) = DFNLL(M,2*LQNA  ) + QA(IOCC)*DLL
              DFNSL(M,2*LQNA  ) = DFNSL(M,2*LQNA  ) + QA(IOCC)*DSL
              DFNSS(M,2*LQNA  ) = DFNSS(M,2*LQNA  ) + QA(IOCC)*DSS
              DFNLS(M,2*LQNA  ) = DFNLS(M,2*LQNA  ) + QA(IOCC)*DLS
C
             ENDIF
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     ONE-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      DO IOCC=1,NUMOCC(LQNA+1)
        IF(NORB(LQNA+1,IOCC).GT.0) THEN
          EH = EH + QA(IOCC)*RK2A1*W1(NBLC+IOCC)
        ENDIF
      ENDDO
C
140   CONTINUE
C
C     NEGATIVE KAPPA(A) CHOICE (APPLIES TO ALL LQNA VALUES)
C
C     DIAGONALISE FOCK MATRIX (THIS NEEDS LAPACK LIBRARY)
      CALL DSYGV(1,'V','U',NMAT,H2,MBD,O2,MBD,W2,T,LWK,INFO)
      IF(INFO.NE.0) THEN
        WRITE(6, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        WRITE(7, *) 'In HFSCF0: eigenvalue solver DSYGV failed.',INFO
        STOP
      ENDIF
C
C     ATOMIC SELECTION RULE: ORTHOGONALITY IN BLOCKS OF KQN -> KA = KB
C
C     BEGIN LOOP OVER MQNA VALUES
      DO IMVAL=1,IABS(KAPA2)
C
C       COEFFICIENT MATRIX ADDRESSES
        IL1 = LRGE(ICNT,2*LQNA+1,IMVAL*2-1)
        IL2 = LRGE(ICNT,2*LQNA+1,IMVAL*2  )
        IS1 = IL1+NSKP
        IS2 = IL2+NSKP
C
C       LOOP OVER ALL LISTED SUBSHELLS OF THIS KQN TYPE
        DO IOCC=1,NUMOCC(LQNA+1)
C
C         SKIP IF THIS SUBSHELL IS UNOCCUPIED
          IF(NORB(LQNA+1,IOCC).EQ.0) GOTO 133
C
C         EFFECTIVE OCCUPATION NUMBER
          QF = DSQRT(QA(IOCC))
C
C         COPY INTO MASTER COEFFICIENT LIST
          DO IBAS=1,NBASA
C
C           LARGE COMPONENT OF KRAMERS PAIR
            CLP = QF*H2(IBAS     ,IOCC+NBLC)
C
            COEF(IL1+IBAS,NSKP+IOCCML+1) = DCMPLX(CLP,0.0D0)
            COEF(IL2+IBAS,NSKP+IOCCML+2) = DCMPLX(CLP,0.0D0)
C
C           SMALL COMPONENT OF KRAMERS PAIR
            IF(HMLT.NE.'NORL') THEN
C
              CLN = QF*H2(IBAS     ,IOCC     )
              CSN = QF*H2(IBAS+NBLC,IOCC     )
              CSP = QF*H2(IBAS+NBLC,IOCC+NBLC)
C
              COEF(IL1+IBAS,     IOCCML+1) = DCMPLX(CLN,0.0D0)
              COEF(IL2+IBAS,     IOCCML+2) = DCMPLX(CLN,0.0D0)
              COEF(IS1+IBAS,     IOCCML+1) = DCMPLX(CSN,0.0D0)
              COEF(IS2+IBAS,     IOCCML+2) = DCMPLX(CSN,0.0D0)
              COEF(IS1+IBAS,NSKP+IOCCML+1) = DCMPLX(CSP,0.0D0)
              COEF(IS2+IBAS,NSKP+IOCCML+2) = DCMPLX(CSP,0.0D0)
C
            ENDIF
C
          ENDDO
C
C         STORE LOWEST ENERGY EIGENVALUES TO MASTER LIST
          IF(HMLT.NE.'NORL') THEN
            EIGN(     IOCCML+1) = W2(     IOCC)
            EIGN(     IOCCML+2) = W2(     IOCC)
          ENDIF
C
          EIGN(NSKP+IOCCML+1) = W2(NBLC+IOCC)
          EIGN(NSKP+IOCCML+2) = W2(NBLC+IOCC)
C
C         INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
          IOCCML = IOCCML+2
C
C         SKIP POINT FOR UNOCCUPIED ORBITALS
133       CONTINUE
C
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC SPECIAL CASE: ALSO FILL IN THE +KQNA BLOCK
      IF(HMLT.EQ.'NORL'.AND.LQNA.GE.1) THEN
C
C       BEGIN LOOP OVER MQNA VALUES IN +KQNA BLOCK
        DO IMVAL=1,IABS(KAPA(2*LQNA  ,ICNT))
C
C         COEFFICIENT MATRIX ADDRESSES
          IL1 = LRGE(ICNT,2*LQNA  ,IMVAL*2-1)
          IL2 = LRGE(ICNT,2*LQNA  ,IMVAL*2  )
C
C         LOOP OVER ALL LISTED SUBSHELLS OF THIS KQN TYPE
          DO IOCC=1,NUMOCC(LQNA+1)
C
C           SKIP IF THIS SUBSHELL IS UNOCCUPIED
            IF(NORB(LQNA+1,IOCC).EQ.0) GOTO 134
C
C           EFFECTIVE OCCUPATION NUMBER
            QF = DSQRT(QA(IOCC))
C
C           COPY INTO MASTER COEFFICIENT LIST
            DO IBAS=1,NBASA
C
C             LARGE COMPONENT OF KRAMERS PAIR
              CL = QF*H2(IBAS     ,NBLC+IOCC)
              COEF(IL1+IBAS,NSKP+IOCCML+1) = DCMPLX(CL,0.0D0)
              COEF(IL2+IBAS,NSKP+IOCCML+2) = DCMPLX(CL,0.0D0)
C
            ENDDO
C
C           STORE LOWEST ENERGY EIGENVALUES TO MASTER LIST
            EIGN(NSKP+IOCCML+1) = W2(NBLC+IOCC)
            EIGN(NSKP+IOCCML+2) = W2(NBLC+IOCC)
C
C           INCREASE FOCK ADDRESS OF OCCUPIED ORBITALS (PAIR AT A TIME)
            IOCCML = IOCCML+2
C
C         SKIP POINT FOR UNOCCUPIED ORBITALS
134       CONTINUE
C
          ENDDO
C
        ENDDO
      ENDIF
C
C     BUILD ATOMIC CHARGE DENSITY MATRIX FOR THIS KQNA BLOCK
      M = 0
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
          M = M+1
C
C         INITIALISE ATOMIC DENSITY LISTS FOR THIS BLOCK
          DENLL(M,2*LQNA+1) = 0.0D0
          DFNLL(M,2*LQNA+1) = 0.0D0
C
          IF(HMLT.NE.'NORL') THEN
            DENSL(M,2*LQNA+1) = 0.0D0
            DFNSL(M,2*LQNA+1) = 0.0D0
C
            DENSS(M,2*LQNA+1) = 0.0D0
            DFNSS(M,2*LQNA+1) = 0.0D0
C
            DENLS(M,2*LQNA+1) = 0.0D0
            DFNLS(M,2*LQNA+1) = 0.0D0
          ENDIF
C
C         LOOP OVER ALL LISTED SUBSHELLS OF THIS KQN TYPE
          DO IOCC=1,NUMOCC(LQNA+1)
C
C           SKIP THIS STEP IF SUBSHELL IS UNOCCUPIED
            IF(NORB(LQNA+1,IOCC).GT.0) THEN
C
C             LL DENSITY CONTRIBUTIONS
              DLL = H2(IBAS     ,NBLC+IOCC)*H2(JBAS     ,NBLC+IOCC)
              DENLL(M,2*LQNA+1) = DENLL(M,2*LQNA+1) + QE(IOCC)*DLL
              DFNLL(M,2*LQNA+1) = DFNLL(M,2*LQNA+1) + QA(IOCC)*DLL
C
              IF(HMLT.NE.'NORL') THEN
C
C               SL DENSITY CONTRIBUTIONS
                DSL = H2(IBAS+NBLC,NBLC+IOCC)*H2(JBAS     ,NBLC+IOCC)
                DENSL(M,2*LQNA+1) = DENSL(M,2*LQNA+1) + QE(IOCC)*DSL
                DFNSL(M,2*LQNA+1) = DFNSL(M,2*LQNA+1) + QA(IOCC)*DSL
C
C               SS DENSITY CONTRIBUTIONS
                DSS = H2(IBAS+NBLC,NBLC+IOCC)*H2(JBAS+NBLC,NBLC+IOCC)
                DENSS(M,2*LQNA+1) = DENSS(M,2*LQNA+1) + QE(IOCC)*DSS
                DFNSS(M,2*LQNA+1) = DFNSS(M,2*LQNA+1) + QA(IOCC)*DSS
C
C               LS DENSITY CONTRIBUTIONS
                DLS = H2(IBAS     ,NBLC+IOCC)*H2(JBAS+NBLC,NBLC+IOCC)
                DENLS(M,2*LQNA+1) = DENLS(M,2*LQNA+1) + QE(IOCC)*DLS
                DFNLS(M,2*LQNA+1) = DFNLS(M,2*LQNA+1) + QA(IOCC)*DLS
C
              ENDIF
C
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     ONE-BODY EIGENVALUE ENERGIES FOR OCCUPIED ELECTRONS
      DO IOCC=1,NUMOCC(LQNA+1)
        IF(NORB(LQNA+1,IOCC).GT.0) THEN
          EH = EH + QA(IOCC)*RK2A2*W2(NBLC+IOCC)
        ENDIF
      ENDDO
C
C     END LOOP OVER LQNA VALUES
100   CONTINUE
C
C     COULOMB AND BREIT ENERGIES HAVE BEEN DOUBLE-COUNTED
      EG = EG/2.0D0
      EB = EB/2.0D0
C
      E2 = EG+EB
C
C     TOTAL ATOMIC ENERGY IN THIS ITERATION
      ENEW = EH-EG-EB
C
C     RELATIVE CHANGE IN ENERGY
      ETEST = DABS((EPRV-ENEW)/ENEW)
C
C     WRITE THE ITERATION NUMBER AND THE TOTAL ENERGY
      WRITE(6,41) ITER,EH,E2,ENEW,ETEST
      WRITE(7,41) ITER,EH,E2,ENEW,ETEST
C
C     SUCCESSFUL CONVERGENCE
      IF(ETEST.LE.ENRGTOL) THEN
        GOTO 1001
      ELSE
        EPRV = ENEW
      ENDIF
C
C     BARE NUCLEUS APPROXIMATION
      IF(HMLT.EQ.'BARE') GOTO 1001
C
C     END LOOP OVER ITERATIONS
1000  CONTINUE
C
C     WARN USER THAT ATOMIC SCF DID NOT CONVERGE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6, *) 'In HFSCF0: no convergence in ',ITER,' iterations.'
      WRITE(7, *) 'In HFSCF0: no convergence in ',ITER,' iterations.'
C
C     COVERGENCE SUCCESSFUL
1001  CONTINUE
C
C**********************************************************************C
C     CONSTRUCT MOLECULAR OVERLAP MATRIX                               C
C**********************************************************************C
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO 101 LQNA=0,LMXCONF
C
C     IMPORT BASIS FUNCTION EXPONENTS
      NBASA = NFNC(LQNA+1,ICNT)
      DO IBAS=1,NBASA
        EXLA(IBAS) = BSET(IBAS,LQNA+1,ICNT)
      ENDDO
C
C     ONLY NEED 'KQN =+LQN' IN SOME CASES
      IF(LQNA.EQ.0) GOTO 131
C
C     FIRST RELATIVISTIC QUANTUM NUMBER
      KAPA1 = LQNA
C
C     GENERATE OVERLAP MATRIX
      CALL OVRLP0(O1,EXLA,KAPA1,NBASA)
C
131   CONTINUE
C
C     NEED 'KQN =-LQN-1' ALWAYS
C
C     SECOND RELATIVISTIC QUANTUM NUMBER
      KAPA2 =-LQNA-1
C
C     GENERATE OVERLAP MATRIX
      CALL OVRLP0(O2,EXLA,KAPA2,NBASA)
C
C     NOW FILL IN THESE OVERLAP MATRICES...
C
C     ONLY NEED 'KQN =+LQN' IN SOME CASES
      IF(LQNA.EQ.0) GOTO 141
C
C     BEGIN LOOP OVER MQNA VALUES
      DO IMVAL=1,IABS(KAPA1)
C
C       COEFFICIENT MATRIX ADDRESSES FOR 'KQN =+LQN' CHOICE
        IL1 = LRGE(ICNT,2*LQNA  ,IMVAL*2-1)
        IL2 = LRGE(ICNT,2*LQNA  ,IMVAL*2  )
        IS1 = IL1+NSKP
        IS2 = IL2+NSKP
C
C       TRANSFER OVERLAP MATRIX TO COMMON ARRAY
        DO IBAS=1,NBASA
          DO JBAS=1,NBASA
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBASA
            LBAS = JBAS+NBASA
C
C           MATRIX ELEMENTS
            OVAP(IL1+IBAS,IL1+JBAS) = DCMPLX(O1(IBAS,JBAS),0.0D0)
            OVAP(IL2+IBAS,IL2+JBAS) = DCMPLX(O1(IBAS,JBAS),0.0D0)

            IF(HMLT.NE.'NORL') THEN
              OVAP(IS1+IBAS,IS1+JBAS) = DCMPLX(O1(KBAS,LBAS),0.0D0)
              OVAP(IS2+IBAS,IS2+JBAS) = DCMPLX(O1(KBAS,LBAS),0.0D0)
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
141   CONTINUE
C
C     NEED 'KQN =-LQN-1' ALWAYS
C
C     BEGIN LOOP OVER MQNA VALUES
      DO IMVAL=1,IABS(KAPA2)
C
C       COEFFICIENT MATRIX ADDRESSES FOR 'KQN =+LQN' CHOICE
        IL1 = LRGE(ICNT,2*LQNA+1,IMVAL*2-1)
        IL2 = LRGE(ICNT,2*LQNA+1,IMVAL*2  )
        IS1 = IL1+NSKP
        IS2 = IL2+NSKP
C
C       TRANSFER OVERLAP MATRIX TO COMMON ARRAY
        DO IBAS=1,NBASA
          DO JBAS=1,NBASA
C
C           SMALL COMPONENT BLOCK ADDRESSES
            KBAS = IBAS+NBASA
            LBAS = JBAS+NBASA
C
C           MATRIX ELEMENTS
            OVAP(IL1+IBAS,IL1+JBAS) = DCMPLX(O2(IBAS,JBAS),0.0D0)
            OVAP(IL2+IBAS,IL2+JBAS) = DCMPLX(O2(IBAS,JBAS),0.0D0)
C
            IF(HMLT.NE.'NORL') THEN
              OVAP(IS1+IBAS,IS1+JBAS) = DCMPLX(O2(KBAS,LBAS),0.0D0)
              OVAP(IS2+IBAS,IS2+JBAS) = DCMPLX(O2(KBAS,LBAS),0.0D0)
            ENDIF
C
          ENDDO
        ENDDO
      ENDDO
C
C     END LOOP OVER LQN VALUES
101   CONTINUE
C
C**********************************************************************C
C     WRITTEN SUMMARY                                                  C
C**********************************************************************C
C
C     SUMMARY OF ENERGY CONTRIBUTIONS
50    FORMAT(1X,A,24X,F19.12)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',20),'Atomic energies (Hartree units)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,50) 'One-electron energy          ',EH
      WRITE(7,50) 'One-electron energy          ',EH
      WRITE(6,50) 'Two-electron energy (Coulomb)',EG
      WRITE(7,50) 'Two-electron energy (Coulomb)',EG
      IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 500
      WRITE(6,50) 'Two-electron energy (Breit)  ',EB
      WRITE(7,50) 'Two-electron energy (Breit)  ',EB
500   CONTINUE
      WRITE(6,50) 'Total energy                 ',ENEW
      WRITE(7,50) 'Total energy                 ',ENEW
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
C
C**********************************************************************C
C     BREIT ENERGY BY FIRST ORDER PERTURBATION THEORY                  C
C**********************************************************************C
C
      IF(HMLT.NE.'DHFP') GOTO 600
C
      WRITE(6,*) REPEAT('=',72)
      WRITE(7,*) REPEAT('=',72)
      WRITE(6,*) REPEAT(' ',24),'First order Breit energy'
      WRITE(7,*) REPEAT(' ',24),'First order Breit energy'
      WRITE(6,*) REPEAT('=',72)
      WRITE(7,*) REPEAT('=',72)
601   FORMAT(1X,'(KA,KB)',9X,
     &              'E(LL|SS)',8X,'E(SS|LL)',8X,'E(SL|LS)',10X,'E(TOT)')
602   FORMAT(1X,'(',I2,',',I2,')',3X,
     &                             F14.10,2X,F14.10,2X,F14.10,2X,F14.10)
603   FORMAT(1X,'Atomic',4X,F14.10,2X,F14.10,2X,F14.10,2X,F14.10)
C
C     PRINT HEADER TO TERMINAL
      WRITE(6,601)
      WRITE(7,601)
      WRITE(6,*) REPEAT('-',72)
      WRITE(7,*) REPEAT('-',72)
C
C     INITIALISE TOTAL BREIT COUNTERS
      EBLLTOT = 0.0D0
      EBSSTOT = 0.0D0
      EBSLTOT = 0.0D0
      EBTTTOT = 0.0D0
C
C     LOOP OVER ALL OCCUPIED LQN VALUES
      DO LQNA=0,LMXCONF
C
C       RECORD LQNA VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
        NBASA = NFNC(LQNA+1,ICNT)
        DO IBAS=1,NBASA
          EXLA(IBAS) = BSET(IBAS,LQNA+1,ICNT)
        ENDDO
C
C       POSITIVE KAPPA(A) CHOICE (APPLIES ONLY FOR LQNA > 0)
        KAPA1 = LQNA
        RK2A1 = DFLOAT(2*IABS(KAPA1))
C
C       NEGATIVE KAPPA(A) CHOICE (APPLIES TO ALL LQNA VALUES)
        KAPA2 =-LQNA-1
        RK2A2 = DFLOAT(2*IABS(KAPA2))
C
C       INITIALISE RELEVANT COUNTERS AND ARRAYS
        RK2B1 = 0.0D0
        RK2B2 = 0.0D0
C
C       LOOP OVER ALL OCCUPIED LQN VALUES
        DO LQNB=0,LMXCONF
C
C         RECORD LQNB VALUE AND READ BASIS FUNCTIONS FOR THIS LQN
          NBASB = NFNC(LQNB+1,ICNT)
          DO JBAS=1,NBASB
            EXLB(JBAS) = BSET(JBAS,LQNB+1,ICNT)
          ENDDO
C
C         NUMBER OF BASIS FUNCTION OVERLAPS IN THIS BLOCK
          MAXM = NBASB*NBASB
C
C         POSITIVE KAPPA(B) CHOICE (APPLIES ONLY FOR LQNB > 0)
          IF(LQNB.EQ.0) GOTO 630
C
C         ANGULAR QUANTUM NUMBER AND DEGENERACY
          KAPB1 = LQNB
          RK2B1 = DFLOAT(2*IABS(KAPB1))
C
C         RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
          IF(LQNA.EQ.LQNB) THEN
            DO M=1,MAXM
              DLL1(M) = DENLL(M,2*LQNB  )
              DSL1(M) = DENSL(M,2*LQNB  )
              DSS1(M) = DENSS(M,2*LQNB  )
              DLS1(M) = DENLS(M,2*LQNB  )
            ENDDO
          ELSEIF(LQNA.NE.LQNB) THEN
            DO M=1,MAXM
              DLL1(M) = DFNLL(M,2*LQNB  )
              DSL1(M) = DFNSL(M,2*LQNB  )
              DSS1(M) = DFNSS(M,2*LQNB  )
              DLS1(M) = DFNLS(M,2*LQNB  )
            ENDDO
          ENDIF
C
630       CONTINUE
C
C         NEGATIVE KAPPA(B) CHOICE (APPLIES TO ALL LQNB VALUES)
C
C         ANGULAR QUANTUM NUMBER AND DEGENERACY
          KAPB2 =-LQNB-1
          RK2B2 = DFLOAT(2*IABS(KAPB2))
C
C         RELEVANT DENSITY MATRIX DEPENDS ON LQNA AND LQNB
          IF(LQNA.EQ.LQNB) THEN
            DO M=1,MAXM
              DLL2(M) = DENLL(M,2*LQNB+1)
              DSL2(M) = DENSL(M,2*LQNB+1)
              DSS2(M) = DENSS(M,2*LQNB+1)
              DLS2(M) = DENLS(M,2*LQNB+1)
            ENDDO
          ELSEIF(LQNA.NE.LQNB) THEN
            DO M=1,MAXM
              DLL2(M) = DFNLL(M,2*LQNB+1)
              DSL2(M) = DFNSL(M,2*LQNB+1)
              DSS2(M) = DFNSS(M,2*LQNB+1)
              DLS2(M) = DFNLS(M,2*LQNB+1)
            ENDDO
          ENDIF
C
C         GENERATE THE MEAN-FIELD ATOMIC BREIT MATRIX OVER DENSITIES
          CALL BREIT0
C
C         ENERGY COUNTERS BY KAPPA TYPE THE SAME (LQNA,LQNB) BLOCK
          EBLL22 = 0.0D0
          EBSL22 = 0.0D0
          EBSS22 = 0.0D0
          EBLL21 = 0.0D0
          EBSL21 = 0.0D0
          EBSS21 = 0.0D0
          EBLL12 = 0.0D0
          EBSL12 = 0.0D0
          EBSS12 = 0.0D0
          EBLL11 = 0.0D0
          EBSL11 = 0.0D0
          EBSS11 = 0.0D0
C
C         SUM OVER THIS BREIT MATRIX AND MULTIPLY BY DENSITY
          M = 0
          DO IBAS=1,NBASA
            DO JBAS=1,NBASA
              M = M+1
C
C             SMALL COMPONENT BLOCK ADDRESSES
              KBAS = IBAS+NBASA
              LBAS = JBAS+NBASA
C
C             KQNA < 0 AND KQNB < 0
              EBLL22 = EBLL22 + B22(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
              EBSL22 = EBSL22 + B22(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
              EBSS22 = EBSS22 + B22(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
C
C             KQNA < 0 AND KQNB > 0
              IF(LQNB.NE.0) THEN
                EBLL21 = EBLL21 + B21(IBAS,JBAS)*DFNLL(M,2*LQNA+1)
                EBSL21 = EBSL21 + B21(KBAS,JBAS)*DFNSL(M,2*LQNA+1)
                EBSS21 = EBSS21 + B21(KBAS,LBAS)*DFNSS(M,2*LQNA+1)
              ENDIF
C
C             KQNA > 0 AND KQNB < 0
              IF(LQNA.NE.0) THEN
                EBLL12 = EBLL12 + B12(IBAS,JBAS)*DFNLL(M,2*LQNA  )
                EBSL12 = EBSL12 + B12(KBAS,JBAS)*DFNSL(M,2*LQNA  )
                EBSS12 = EBSS12 + B12(KBAS,LBAS)*DFNSS(M,2*LQNA  )
              ENDIF
C
C             KQNA > 0 AND KQNB > 0
              IF(LQNA.NE.0.AND.LQNB.NE.0) THEN
                EBLL11 = EBLL11 + B11(IBAS,JBAS)*DFNLL(M,2*LQNA  )
                EBSL11 = EBSL11 + B11(KBAS,JBAS)*DFNSL(M,2*LQNA  )
                EBSS11 = EBSS11 + B11(KBAS,LBAS)*DFNSS(M,2*LQNA  )
              ENDIF
C
            ENDDO
          ENDDO
C
C         ATOMIC CONTRIBUTIONS BY COMPONENT OVERLAP
          EBLL22 = RK2A2*RK2B2*EBLL22/2.0D0
          EBSS22 = RK2A2*RK2B2*EBSS22/2.0D0
          EBSL22 = RK2A2*RK2B2*EBSL22/2.0D0
          EBLL21 = RK2A2*RK2B1*EBLL21/2.0D0
          EBSS21 = RK2A2*RK2B1*EBSS21/2.0D0
          EBSL21 = RK2A2*RK2B1*EBSL21/2.0D0
          EBLL12 = RK2A1*RK2B2*EBLL12/2.0D0
          EBSS12 = RK2A1*RK2B2*EBSS12/2.0D0
          EBSL12 = RK2A1*RK2B2*EBSL12/2.0D0
          EBLL11 = RK2A1*RK2B1*EBLL11/2.0D0
          EBSS11 = RK2A1*RK2B1*EBSS11/2.0D0
          EBSL11 = RK2A1*RK2B1*EBSL11/2.0D0
C
C         TOTAL FOR THESE (KQNA,KQNB) MANIFOLDS
          EBTT22 = EBLL22+EBSS22+EBSL22+EBSL22
          EBTT21 = EBLL21+EBSS21+EBSL21+EBSL21
          EBTT12 = EBLL12+EBSS12+EBSL12+EBSL12
          EBTT11 = EBLL11+EBSS11+EBSL11+EBSL11
C
C         PRINT TO TERMINAL
          WRITE(6,602) KAPA2,KAPB2,EBLL22,EBSS22,EBSL22,EBTT22
          WRITE(7,602) KAPA2,KAPB2,EBLL22,EBSS22,EBSL22,EBTT22
          IF(LQNB.NE.0) THEN
            WRITE(6,602) KAPA2,KAPB1,EBLL21,EBSS21,EBSL21,EBTT21
            WRITE(7,602) KAPA2,KAPB1,EBLL21,EBSS21,EBSL21,EBTT21
          ENDIF
          IF(LQNA.NE.0) THEN
            WRITE(6,602) KAPA1,KAPB2,EBLL12,EBSS12,EBSL12,EBTT12
            WRITE(7,602) KAPA1,KAPB2,EBLL12,EBSS12,EBSL12,EBTT12
          ENDIF
          IF(LQNA.NE.0.AND.LQNB.NE.0) THEN
            WRITE(6,602) KAPA1,KAPB1,EBLL11,EBSS11,EBSL11,EBTT11
            WRITE(7,602) KAPA1,KAPB1,EBLL11,EBSS11,EBSL11,EBTT11
          ENDIF
C
C         ADD TO ATOMIC TOTAL
          EBLLTOT = EBLLTOT + EBLL22 + EBLL21 + EBLL12 + EBLL11
          EBSSTOT = EBSSTOT + EBSS22 + EBSS21 + EBSS12 + EBSS11
          EBSLTOT = EBSLTOT + EBSL22 + EBSL21 + EBSL12 + EBSL11
          EBTTTOT = EBTTTOT + EBTT22 + EBTT21 + EBTT12 + EBTT11
C
C       END LOOP OVER LQNS FOR ORBITAL B
        ENDDO
C
C     END LOOP OVER LQNS FOR ORBITAL A
      ENDDO
C
C     SUMMARY OF TOTALS
      WRITE(6,*) REPEAT('-',72)
      WRITE(7,*) REPEAT('-',72)
      WRITE(6,603) EBLLTOT,EBSSTOT,EBSLTOT,EBTTTOT
      WRITE(7,603) EBLLTOT,EBSSTOT,EBSLTOT,EBTTTOT
      WRITE(6,*) REPEAT('=',72)
      WRITE(7,*) REPEAT('=',72)
      
      EB = EBTTTOT
C
600   CONTINUE
C
C**********************************************************************C
C     ORBITAL AND ENERGY COUNTERS FOR WHOLE MOLECULE                   C
C**********************************************************************C
C
C     UPDATE COUNTER FOR HIGHEST OCCUPIED ATOMIC ORBITAL
      IOCCM0 = IOCCML
C
C     ADD RESULTS FROM THIS ATOM TO MOLECULAR ENERGY
      ETOT = ETOT + ENEW
      EONE = EONE + EH
      ECLG = ECLG + EG
      EBRG = EBRG + EB
C
      RETURN
      END
C
C
      SUBROUTINE OVRLP0(OVAP,EXL,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  VV    VV RRRRRRR  LL      PPPPPPP   000000          C
C         OO    OO VV    VV RR    RR LL      PP    PP 00   000         C
C         OO    OO VV    VV RR    RR LL      PP    PP 00  0000         C
C         OO    OO VV    VV RR    RR LL      PP    PP 00 00 00         C
C         OO    OO  VV  VV  RRRRRRR  LL      PPPPPPP  0000  00         C
C         OO    OO   VVVV   RR    RR LL      PP       000   00         C
C          OOOOOO     VV    RR    RR LLLLLLL PP        000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  OVRLP0 CALCULATES THE ATOMIC OVERLAP MATRIX FOR SYMMETRY TYPE KQN.  C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      DIMENSION RN(MBS*MBS,4),OVAP(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T32 = RL+1.5D0
          T52 = RL+2.5D0
          E32 = EIJ**T32
          E52 = EIJ**T52
          SLL = 0.5D0*RN(M,1)*GAMHLF(2*LQN+3)/E32
          SSS = 2.0D0*RN(M,3)*GAMHLF(2*LQN+5)*EPR/E52
C
C         OVERLAP MATRIX ELEMENTS
          OVAP(IBAS     ,JBAS     ) = SLL
          IF(HMLT.EQ.'NORL') GOTO 50
          OVAP(IBAS+NBAS,JBAS     ) = 0.0D0
          OVAP(JBAS     ,IBAS+NBAS) = 0.0D0
          OVAP(IBAS+NBAS,JBAS+NBAS) = SSS
50        CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE KINTC0(HMAT,EXL,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           KK    KK IIII NN    NN TTTTTTTT CCCCCC   000000            C
C           KK   KK   II  NNN   NN    TT   CC    CC 00   000           C
C           KK  KK    II  NNNN  NN    TT   CC       00  0000           C
C           KKKKK     II  NN NN NN    TT   CC       00 00 00           C
C           KK  KK    II  NN  NNNN    TT   CC       0000  00           C
C           KK   KK   II  NN   NNN    TT   CC    CC 000   00           C
C           KK    KK IIII NN    NN    TT    CCCCCC   000000            C
C                                                                      C
C -------------------------------------------------------------------- C
C  KINTC0 CALCULATES THE ATOM-CENTERED KINETIC MATRIX ELEMENTS.        C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      DIMENSION RN(MBS*MBS,4),HMAT(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M    = M+1
          EJ   = EXL(JBAS)
          EIJ  = EI+EJ
          EPR  = EI*EJ
          T52  = RL+2.5D0
          E52  = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            PLL = RN(M,1)*GAMHLF(2*LQN+5)*EPR/E52
            HMAT(IBAS,JBAS) = PLL
C
          ELSE
C
C           OVERLAPS, KINETIC ELEMENTS AND SS POTENTIAL INTEGRALS
            PSL = 2.0D0*RN(M,2)*GAMHLF(2*LQN+5)*EPR/E52
C
C           TRANSFER INTO ARRAY
            HMAT(IBAS+NBAS,JBAS     ) = CV*PSL
            HMAT(JBAS     ,IBAS+NBAS) = HMAT(IBAS+NBAS,JBAS     )
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE PNTNC0(HMAT,EXL,ZCRG,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        PPPPPPP  NN    NN TTTTTTTT NN    NN  CCCCCC   000000          C
C        PP    PP NNN   NN    TT    NNN   NN CC    CC 00   000         C
C        PP    PP NNNN  NN    TT    NNNN  NN CC       00  0000         C
C        PP    PP NN NN NN    TT    NN NN NN CC       00 00 00         C
C        PPPPPPP  NN  NNNN    TT    NN  NNNN CC       0000  00         C
C        PP       NN   NNN    TT    NN   NNN CC    CC 000   00         C
C        PP       NN    NN    TT    NN    NN  CCCCCC   000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  PNTNC0 CALCULATES ATOM-CENTRED NUCLEAR ATTRACTION MATRIX ELEMENTS   C
C  FOR A POINT-NUCLEAR CHARGE MODEL.                                   C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      DIMENSION RN(MBS*MBS,4),HMAT(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      G  = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          EL1 = EIJ**(LQN+1)
          T52 = RL+2.5D0
          E52 = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            ULL = 0.5D0*GAMHLF(2*LQN+2)/EL1
C
C           TRANSFER INTO DIRAC MATRIX
            HMAT(IBAS,JBAS) = HMAT(IBAS,JBAS)-ZCRG*RN(M,1)*ULL
C
          ELSE
C
C           RELATIVISTIC CASE
            SSS = 2.0D0*GAMHLF(2*LQN+5)*EPR/E52
            ULL = 0.5D0*GAMHLF(2*LQN+2)/EL1
C
            VSA = 2.0D0*GAMHLF(2*LQN+4)*EPR/(EL1*EIJ)
            IF(KQN.LT.0) THEN
              VSN = 0.0D0
            ELSE
              VSN = 0.5D0*GAMHLF(2*LQN  )*G*EIJ/EL1
            ENDIF
            USS = VSA+VSN
C
C           TRANSFER INTO ARRAY
            HMAT(IBAS     ,JBAS     ) =-ZCRG*RN(M,1)*ULL
            HMAT(IBAS+NBAS,JBAS+NBAS) =-ZCRG*RN(M,3)*USS
     &                                 -2.0D0*CV*CV*RN(M,3)*SSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GSSNC0(HMAT,EXL,ZCRG,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         GGGGGG   SSSSSS   SSSSSS  NN    NN  CCCCCC   000000          C
C        GG    GG SS    SS SS    SS NNN   NN CC    CC 00   000         C
C        GG       SS       SS       NNNN  NN CC       00  0000         C
C        GG        SSSSSS   SSSSSS  NN NN NN CC       00 00 00         C
C        GG   GGG       SS       SS NN  NNNN CC       0000  00         C
C        GG    GG SS    SS SS    SS NN   NNN CC    CC 000   00         C
C         GGGGGG   SSSSSS   SSSSSS  NN    NN  CCCCCC   000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  GSSNC0 CALCULATES ATOM-CENTRED NUCLEAR ATTRACTION MATRIX ELEMENTS   C
C  FOR A GAUSSIAN NUCLEAR CHARGE MODEL.                                C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      DIMENSION RN(MBS*MBS,4),HMAT(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      G  = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T52 = RL+2.5D0
          E52 = EIJ**T52
C
C         MATRIX ELEMENT DEPENDS ON HAMILTONIAN
          IF(HMLT.EQ.'NORL') THEN
C
C           NON-RELATIVISTIC CASE
            ULL = ERFINT0(2*LQN+1,EIJ)
C
C           TRANSFER INTO DIRAC MATRIX
            HMAT(IBAS,JBAS) = HMAT(IBAS,JBAS)-ZCRG*RN(M,1)*ULL
C
          ELSE
C
C           RELATIVISTIC CASE
            SSS = 2.0D0*GAMHLF(2*LQN+5)*EPR/E52
            ULL = ERFINT0(2*LQN+1,EIJ)
            VSA = 4.0D0*EPR*ERFINT0(2*LQN+3,EIJ)
            IF(KQN.LT.0) THEN
              VSN = 0.0D0
            ELSE
              VSN =-2.0D0*EIJ*G*ERFINT0(2*LQN+1,EIJ)
     &                     +G*G*ERFINT0(2*LQN-1,EIJ)
            ENDIF
            USS = VSA+VSN
C
C           TRANSFER INTO DIRAC MATRIX
            HMAT(IBAS     ,JBAS     ) =-ZCRG*RN(M,1)*ULL
            HMAT(IBAS+NBAS,JBAS+NBAS) =-ZCRG*RN(M,3)*USS
     &                                 -2.0D0*CV*CV*RN(M,3)*SSS
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ONEEL0(HMAT,EXL,ZCRG,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          OOOOOO  NN    NN EEEEEEEE EEEEEEEE LL      000000           C
C         OO    OO NNN   NN EE       EE       LL     00   000          C
C         OO    OO NNNN  NN EE       EE       LL     00  0000          C
C         OO    OO NN NN NN EEEEEE   EEEEEE   LL     00 00 00          C
C         OO    OO NN  NNNN EE       EE       LL     0000  00          C
C         OO    OO NN   NNN EE       EE       LL     000   00          C
C          OOOOOO  NN    NN EEEEEEEE EEEEEEEE LLLLLLL 000000           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ONEEL0 CALCULATES THE ATOMIC DIRAC AND OVERLAP MATRICES FOR         C
C  SYMMETRY TYPE KQN, USING EVEN-TEMPERED SGTFS.                       C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      DIMENSION RN(MBS*MBS,4),HMAT(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      G  = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M    = M+1
          EJ   = EXL(JBAS)
          EIJ  = EI+EJ
          EPR  = EI*EJ
          T52  = RL+2.5D0
          E52  = EIJ**T52
C
C         LL OVERLAP
          ULL =-ZCRG*RN(M,1)*ERFINT0(2*LQN+1,EIJ)
          IF(HMLT.EQ.'NORL') THEN
            PLL = RN(M,1)*GAMHLF(2*LQN+5)*EPR/E52
          ELSE
            PLL = 0.0D0
          ENDIF
C
C         TRANSFER INTO ARRAY
          HMAT(IBAS,JBAS) = ULL + PLL
C
C         LS,SL AND SS OVERLAPS
          IF(HMLT.EQ.'NORL') GOTO 50
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBAS
          LBAS = JBAS+NBAS
C
C         OVERLAPS, KINETIC ELEMENTS AND SS POTENTIAL INTEGRALS
          SSS = 2.0D0*RN(M,3)*GAMHLF(2*LQN+5)*EPR/E52
          PSL = 2.0D0*RN(M,2)*GAMHLF(2*LQN+5)*EPR/E52
C
          VSA  = 4.0D0*EPR*ERFINT0(2*LQN+3,EIJ)
          IF(KQN.GT.0) THEN
            VSN =-2.0D0*EIJ*G*ERFINT0(2*LQN+1,EIJ)
     &                   +G*G*ERFINT0(2*LQN-1,EIJ)
          ELSE
            VSN = 0.0D0
          ENDIF
          USS =-ZCRG*RN(M,3)*(VSA+VSN)
C
C         TRANSFER INTO ARRAY
          HMAT(KBAS,JBAS) = CV*PSL
          HMAT(JBAS,KBAS) = HMAT(KBAS,JBAS)
          HMAT(KBAS,LBAS) = USS-2.0D0*CV*CV*SSS
C
50        CONTINUE
C
        ENDDO
      ENDDO     
C
      RETURN
      END
C
C
      SUBROUTINE RRK(RR,EXL,KQN,NBAS,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                      RRRRRRR  RRRRRRR  KK    KK                      C
C                      RR    RR RR    RR KK   KK                       C
C                      RR    RR RR    RR KK  KK                        C
C                      RR    RR RR    RR KKKKK                         C
C                      RRRRRRR  RRRRRRR  KK  KK                        C
C                      RR    RR RR    RR KK   KK                       C
C                      RR    RR RR    RR KK    KK                      C
C                                                                      C
C -------------------------------------------------------------------- C
C  RRK CALCULATES RADIAL MATRIX ELEMENTS <r^K>^{TT} FOR INTEGER K.     C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      DIMENSION RN(MBS*MBS,4),RR(MBD,MBD),EXL(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      RK = DFLOAT(K)
      G  = DFLOAT(2*LQN+1)
C
C     INITIALISE ARRAYS
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          RR(IBAS     ,JBAS     ) = 0.0D0
          RR(IBAS+NBAS,JBAS+NBAS) = 0.0D0
          RR(IBAS+NBAS,JBAS     ) = 0.0D0
          RR(IBAS     ,JBAS+NBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     CONDITIONAL FOR K THAT PRODUCES DIVERGING INTEGRAL
      IF(2*LQN+K.LE.-3) THEN
        RETURN
      ENDIF
C
C     NORMALISATION FACTORS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXL(IBAS)
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
C
C         POWERS AND FACTORS
          TK3 = RL+0.5D0*RK+1.5D0
          TK5 = RL+0.5D0*RK+2.5D0
          EK3 = EIJ**TK3
          EK5 = EIJ**TK5
C
          IF(KQN.LT.0) THEN
            TM1 = 0.0D0
          ELSE
            TM1 =-RK*G*EIJ*EIJ + 4.0D0*EPR*(RL+0.5D0+0.5D0*RK)*TK3         
          ENDIF
C
C         PRODUCT OF EACH PART
          RLL = 0.5D0*RN(M,1)*GAMHLF(2*LQN+K+3)/EK3
          IF(KQN.LT.0) THEN
            RSS = 2.0D0*RN(M,3)*GAMHLF(2*LQN+K+5)*EPR/EK5
          ELSE
            RSS = 0.5D0*RN(M,3)*GAMHLF(2*LQN+K+1)*TM1/EK5
          ENDIF
C
C         MATRIX ELEMENTS
          RR(IBAS     ,JBAS     ) = RLL
          RR(IBAS+NBAS,JBAS+NBAS) = RSS
          RR(IBAS+NBAS,JBAS     ) = 0.0D0
          RR(IBAS     ,JBAS+NBAS) = 0.0D0
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION ERFINT0(N,ZETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      EEEEEEEE RRRRRRR  FFFFFFFF IIII NN    NN TTTTTTTT 000000        C
C      EE       RR    RR FF        II  NNN   NN    TT   00   000       C
C      EE       RR    RR FF        II  NNNN  NN    TT   00  0000       C
C      EEEEEE   RR    RR FFFFFF    II  NN NN NN    TT   00 00 00       C
C      EE       RRRRRRR  FF        II  NN  NNNN    TT   0000  00       C
C      EE       RR    RR FF        II  NN   NNN    TT   000   00       C
C      EEEEEEEE RR    RR FF       IIII NN    NN    TT    000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERFINT0 CALCULATES THE VALUE OF AN INTEGRAL OVER A GAUSSIAN WITH    C
C  BASIS PAIR EXPONENT, AN ERROR FUNCTION WITH NUCLEAR WIDTH PARAMETER C
C  AND AN ODD POLYNOMIAL ORDER, N=1 TO N=21 I.E., LQNMAX=9 (i-TYPE):   C
C  ERFINT0(N,ZETA) = INT{R^N*EXP(-ZETA*R^2)*ERF(SQRT(PNUC)*R)}.        C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=4,MKP=9)
C
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     ROUTINE ONLY ALLOWS ODD PARAMETERS N
      IF(MOD(N,2).NE.1) THEN
        WRITE(6, *) 'In ERFINT0: order N must be odd. N = ',N
        WRITE(7, *) 'In ERFINT0: order N must be odd. N = ',N
      ENDIF
C
C     FACTORS NEEDED FOR ALL PARAMETERS N
      X   = ZETA/PNUC
      X5  = X*X*X*X*X
      T0  = PNUC+ZETA
      RAT = PNUC/T0
      TRM = 0.5D0*DSQRT(PNUC)/ZETA/DSQRT(T0)
      DO I=1,(N-1)/2
        TRM = 0.5D0*TRM*RAT/ZETA
      ENDDO
C
      IF(N.EQ.1) THEN
        TRM = TRM
      ELSEIF(N.EQ.3) THEN
        VA  = 2.0D0 + 3.0D0*X
        TRM = TRM*VA
      ELSEIF(N.EQ.5) THEN
        VA  = 8.0D0 + 20.0D0*X + 15.0D0*X*X
        TRM = TRM*VA
      ELSEIF(N.EQ.7) THEN
        VA  = 16.0D0 + 56.0D0*X + 70.0D0*X*X + 35.0D0*X*X*X
        TRM = 3.0D0*TRM*VA
      ELSEIF(N.EQ.9) THEN
        VA  = 128.0D0 + 576.0D0*X + 1008.0D0*X*X + 840.0D0*X*X*X
        VB  = 315.0D0*X*X*X*X
        TRM = 3.0D0*TRM*(VA+VB)
      ELSEIF(N.EQ.11) THEN
        VA  = 256.0D0 + 1408.0D0*X + 3168.0D0*X*X + 3696.0D0*X*X*X
        VB  = 2310.0D0*X*X*X*X + 693.0D0*X*X*X*X*X
        TRM = 15.0D0*TRM*(VA+VB)
      ELSEIF(N.EQ.13) THEN
        VA  = 1024.0D0 + 6656.0D0*X + 18304.0D0*X*X
        VB  = 27456.0D0*X*X*X + 24024.0D0*X*X*X*X
        VC  = 12012.0D0*X5 + 3003.0D0*X5*X
        TRM = 45.0D0*TRM*(VA+VB+VC)
      ELSEIF(N.EQ.15) THEN
        VA  = 2048.0D0 + 15360.0D0*X + 49920.0D0*X*X
        VB  = 91520.0D0*X*X*X+ 102960.0D0*X*X*X*X + 72072.0D0*X5
        VC  = 30030.0D0*X5*X + 6435.0D0*X5*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC)
      ELSEIF(N.EQ.17) THEN
        VA  = 32768.0D0 + 278528.0D0*X + 1044480.0D0*X*X
        VB  = 2263040.0D0*X*X*X + 3111680.0D0*X*X*X*X
        VC  = 2800512.0D0*X5 + 1633632.0D0*X5*X + 583440.0D0*X5*X*X
        VD  = 109395.0D0*X5*X*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(N.EQ.19) THEN
        VA  = 65536.0D0 + 6222592.0D0*X + 2646016.0D0*X*X
        VB  = 6615040.0D0*X*X*X + 10749440.0D0*X*X*X*X
        VC  = 11824384.0D0*X5 + 8868288.0D0*X5*X + 4434144.0D0*X5*X*X
        VD  = 1385670.0D0*X5*X*X*X + 230945.0D0*X5*X*X*X*X
        TRM = 2835.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(N.EQ.21) THEN
        VA  = 262144.0D0 + 2752512.0D0*X + 13074432.0D0*X*X
        VB  = 37044224.0D0*X*X*X + 69457920.0D0*X*X*X*X
        VC  = 90295296.0D0*X5 + 82770688.0D0*X5*X
        VD  = 53209728.0D0*X5*X*X + 23279256.0D0*X5*X*X*X
        VE  = 6466460.0D0*X5*X*X*X*X + 969969.0D0*X5*X5
        TRM = 14175.0D0*TRM*(VA+VB+VC+VD+VE)
      ELSE
        WRITE(6, *) 'In ERFINT0: order N too large. N = ',N
        WRITE(7, *) 'In ERFINT0: order N too large. N = ',N
      ENDIF
C
C     TRANSFER DATA TO ERFINT0
      ERFINT0 = TRM
C
      RETURN
      END
C
C
      SUBROUTINE UEHLING0(UMAT,EXL,ZCRG,KQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  UU    UU EEEEEEEE HH    HH LL      IIII NN    NN  GGGGGG   000000   C
C  UU    UU EE       HH    HH LL       II  NNN   NN GG    GG 00   000  C
C  UU    UU EE       HH    HH LL       II  NNNN  NN GG       00  0000  C
C  UU    UU EEEEEE   HHHHHHHH LL       II  NN NN NN GG       00 00 00  C
C  UU    UU EE       HH    HH LL       II  NN  NNNN GG   GGG 0000  00  C
C  UU    UU EE       HH    HH LL       II  NN   NNN GG    GG 000   00  C
C   UUUUUU  EEEEEEEE HH    HH LLLLLLL IIII NN    NN  GGGGGG   000000   C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHLING0 GENERATES ATOMIC UEHLING INTERACTION MATRIX FOR KQNA.      C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      DIMENSION RN(MBS*MBS,4),UMAT(MBD,MBD),EXL(MBS)
C
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
      DATA PI/3.1415926535897932D0/
C
C     DETERMINE THE LQN
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
      RL = DFLOAT(LQN)
      G  = DFLOAT(2*LQN+1)
C
C     GENERATE NORMALISATION FACTORS FOR THESE EXPONENTS
      CALL RNORM0(RN,EXL,NBAS,LQN)
C
C     COMPTON WAVELENGTH FOR COUPLING TO THE ELECTRON FIELD
      CMP = 1.0D0/CV
C
C     PRE-FACTOR COMMON TO ALL MATRIX ELEMENTS
      VCF = 6.0D0*CV*PI
      VCF =-ZCRG/VCF
C
C     CHARGE MOMENT FACTOR
      FCT = 1.0D0/(PNUC*CMP*CMP)
C
C     LOOP OVER PAIRS OF BASIS FUNCTIONS WITHIN THIS KQN BLOCK
      M = 0
      DO IBAS=1,NBAS
        EI = EXL(IBAS)
        DO JBAS=1,NBAS
          M   = M+1
          EJ  = EXL(JBAS)
          EIJ = EI+EJ
          EPR = EI*EJ
          T52 = RL+2.5D0
          E52 = EIJ**T52
C
C         LL OVERLAP
          UMAT(IBAS,JBAS) = VCF*RN(M,1)*UEHINT0(LQN+1,EIJ)/EIJ
C
C         SS OVERLAP
          IF(HMLT.EQ.'NORL') GOTO 50
C
C         SMALL COMPONENT BLOCK ADDRESSES
          KBAS = IBAS+NBAS
          LBAS = JBAS+NBAS
C
          VSA = 4.0D0*EPR*UEHINT0(LQN+2,EIJ)
          IF(KQN.GT.0) THEN
            VSN =-2.0D0*EIJ*G*UEHINT0(LQN+1,EIJ)
     &                  + G*G*UEHINT0(LQN  ,EIJ)
          ELSE
            VSN = 0.0D0
          ENDIF
C
          UMAT(KBAS,LBAS) = VCF*RN(M,3)*(VSA+VSN)
C
50        CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION UEHINT0(N,ZETA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       UU    UU EEEEEEEE HH    HH IIII NN    NN TTTTTTTT 000000       C
C       UU    UU EE       HH    HH  II  NNN   NN    TT   00   000      C
C       UU    UU EE       HH    HH  II  NNNN  NN    TT   00  0000      C
C       UU    UU EEEEEE   HHHHHHHH  II  NN NN NN    TT   00 00 00      C
C       UU    UU EE       HH    HH  II  NN  NNNN    TT   0000  00      C
C       UU    UU EE       HH    HH  II  NN   NNN    TT   000   00      C
C        UUUUUU  EEEEEEEE HH    HH IIII NN    NN    TT    000000       C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHINT0 CALCULATES AN ATOMIC UEHLING POTENTIAL OVERLAP INTEGRAL     C
C  FOR A LOCAL GAUSSIAN NUCLEAR CHARGE DISTRIBUTION.                   C
C -------------------------------------------------------------------- C
C  DFNOTE: AT THE MOMENT THIS IS JUST A COPY OF ERFINT0.               C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=4,MKP=9)
C
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     ROUTINE ONLY ALLOWS ODD PARAMETERS N
      IF(MOD(N,2).NE.1) THEN
        WRITE(6, *) 'In UEHINT0: order N must be odd. N = ',N
        WRITE(7, *) 'In UEHINT0: order N must be odd. N = ',N
      ENDIF
C
C     FACTORS NEEDED FOR ALL PARAMETERS N
      X   = ZETA/PNUC
      X5  = X*X*X*X*X
      T0  = PNUC+ZETA
      RAT = PNUC/T0
      TRM = 0.5D0*DSQRT(PNUC)/ZETA/DSQRT(T0)
      DO I=1,(N-1)/2
        TRM = 0.5D0*TRM*RAT/ZETA
      ENDDO
C
      IF(N.EQ.1) THEN
        TRM = TRM
      ELSEIF(N.EQ.3) THEN
        VA  = 2.0D0 + 3.0D0*X
        TRM = TRM*VA
      ELSEIF(N.EQ.5) THEN
        VA  = 8.0D0 + 20.0D0*X + 15.0D0*X*X
        TRM = TRM*VA
      ELSEIF(N.EQ.7) THEN
        VA  = 16.0D0 + 56.0D0*X + 70.0D0*X*X + 35.0D0*X*X*X
        TRM = 3.0D0*TRM*VA
      ELSEIF(N.EQ.9) THEN
        VA  = 128.0D0 + 576.0D0*X + 1008.0D0*X*X + 840.0D0*X*X*X
        VB  = 315.0D0*X*X*X*X
        TRM = 3.0D0*TRM*(VA+VB)
      ELSEIF(N.EQ.11) THEN
        VA  = 256.0D0 + 1408.0D0*X + 3168.0D0*X*X + 3696.0D0*X*X*X
        VB  = 2310.0D0*X*X*X*X + 693.0D0*X*X*X*X*X
        TRM = 15.0D0*TRM*(VA+VB)
      ELSEIF(N.EQ.13) THEN
        VA  = 1024.0D0 + 6656.0D0*X + 18304.0D0*X*X
        VB  = 27456.0D0*X*X*X + 24024.0D0*X*X*X*X
        VC  = 12012.0D0*X5 + 3003.0D0*X5*X
        TRM = 45.0D0*TRM*(VA+VB+VC)
      ELSEIF(N.EQ.15) THEN
        VA  = 2048.0D0 + 15360.0D0*X + 49920.0D0*X*X
        VB  = 91520.0D0*X*X*X+ 102960.0D0*X*X*X*X + 72072.0D0*X5
        VC  = 30030.0D0*X5*X + 6435.0D0*X5*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC)
      ELSEIF(N.EQ.17) THEN
        VA  = 32768.0D0 + 278528.0D0*X + 1044480.0D0*X*X
        VB  = 2263040.0D0*X*X*X + 3111680.0D0*X*X*X*X
        VC  = 2800512.0D0*X5 + 1633632.0D0*X5*X + 583440.0D0*X5*X*X
        VD  = 109395.0D0*X5*X*X*X
        TRM = 315.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(N.EQ.19) THEN
        VA  = 65536.0D0 + 6222592.0D0*X + 2646016.0D0*X*X
        VB  = 6615040.0D0*X*X*X + 10749440.0D0*X*X*X*X
        VC  = 11824384.0D0*X5 + 8868288.0D0*X5*X + 4434144.0D0*X5*X*X
        VD  = 1385670.0D0*X5*X*X*X + 230945.0D0*X5*X*X*X*X
        TRM = 2835.0D0*TRM*(VA+VB+VC+VD)
      ELSEIF(N.EQ.21) THEN
        VA  = 262144.0D0 + 2752512.0D0*X + 13074432.0D0*X*X
        VB  = 37044224.0D0*X*X*X + 69457920.0D0*X*X*X*X
        VC  = 90295296.0D0*X5 + 82770688.0D0*X5*X
        VD  = 53209728.0D0*X5*X*X + 23279256.0D0*X5*X*X*X
        VE  = 6466460.0D0*X5*X*X*X*X + 969969.0D0*X5*X5
        TRM = 14175.0D0*TRM*(VA+VB+VC+VD+VE)
      ELSE
        WRITE(6, *) 'In UEHINT0: order N too large. N = ',N
        WRITE(7, *) 'In UEHINT0: order N too large. N = ',N
      ENDIF
C
C     TRANSFER DATA TO UEHINT0
      UEHINT0 = TRM
C
      RETURN
      END
C
C
      SUBROUTINE COULOMB0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    CCCCCC   OOOOOO  UU    UU LL      MM       MM BBBBBBB   000000    C
C   CC    CC OO    OO UU    UU LL      MMM     MMM BB    BB 00   000   C
C   CC       OO    OO UU    UU LL      MMMM   MMMM BB    BB 00  0000   C
C   CC       OO    OO UU    UU LL      MM MM MM MM BBBBBBB  00 00 00   C
C   CC       OO    OO UU    UU LL      MM  MMM  MM BB    BB 0000  00   C
C   CC    CC OO    OO UU    UU LL      MM   M   MM BB    BB 000   00   C
C    CCCCCC   OOOOOO   UUUUUU  LLLLLLL MM       MM BBBBBBB   000000    C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB0 CONSTRUCTS THE ATOMIC COULOMB MATRIX FROM RADIAL DIRECT    C
C  AND EXCHANGE INTEGRALS AND A MEAN-FIELD CHARGE DENSITY.             C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MB2=MBS*MBS,MKP=9,MNU=MKP+1,
     &                                                      MAB=2*MNU+6)
C
      CHARACTER*4 HMLT
C
      DIMENSION RJLLLL(MB2,4),RJSSSS(MB2,4),RJLLSS(MB2,4),RJSSLL(MB2,4),
     &          RKLLLL(MB2,4),RKSSSS(MB2,4),RKSLSL(MB2,4)
C
      COMMON/ATMC/G11(MBD,MBD),G21(MBD,MBD),G12(MBD,MBD),G22(MBD,MBD)
      COMMON/ATMD/DLL1(MB2),DSL1(MB2),DSS1(MB2),DLS1(MB2),
     &            DLL2(MB2),DSL2(MB2),DSS2(MB2),DLS2(MB2)
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
C
C     INITIALISE COULOMB MATRIX
      DO IBAS=1,MBD
        DO JBAS=1,MBD
          G11(IBAS,JBAS) = 0.0D0
          G21(IBAS,JBAS) = 0.0D0
          G12(IBAS,JBAS) = 0.0D0
          G22(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C1 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+1)
      C3 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+3)
      C5 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+5)
      C7 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+7)
      C9 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+9)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
      V8 = 8.0D0
      VS = 1.6D1
C
      TI = DFLOAT(2*LQNA+1)
      TJ = DFLOAT(2*LQNA+1)
      TK = DFLOAT(2*LQNB+1)
      TL = DFLOAT(2*LQNB+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
C
C     EVALUATE CLOSED-SHELL ELECTRON REPULSION ANGULAR INTEGRALS
      CALL ANGCLM0
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL KLSET0
C
C     ITERATE OVER ALL MATRIX ELEMENTS
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
C
C         GAUSSIAN EXPONENTS FOR THIS PAIR
          EI = EXLA(IBAS)
          EJ = EXLA(JBAS)
C
C         BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
          CALL IJSET0
C
C         GENERATE BATCH OF RADIAL INTEGRALS (J AND K MATRICES)
          CALL RKCLM0(RJLLLL,RJSSSS,RJLLSS,RJSSLL,RKLLLL,RKSSSS,RKSLSL)
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
C           INITIALISE COUNTER
            GLL = 0.0D0
C
C           BUILD THE FOCK MATRIX
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,1)*DLL2(M) - RKLLLL(M,1)*DLL2(M)
            ENDDO
C
C           TRANSFER COUNTER VALUE TO COULOMB MATRIX
            G22(IBAS,JBAS) = GLL
C
          ELSE
C         RELATIVISTIC HAMILTONIAN
C
C           SMALL-COMPONENT MATRIX ADDRESSES
            KBAS = IBAS + NBASA
            LBAS = JBAS + NBASA
C
C    (22)   KQNA < 0 AND KQNB < 0  CONTRIBUTIONS (CANNOT SKIP)
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,1)*DLL2(M) - RKLLLL(M,1)*DLL2(M)
     &                  + RJLLSS(M,1)*DSS2(M)
              GSL = GSL                       - RKSLSL(M,1)*DSL2(M)
              GSS = GSS + RJSSSS(M,1)*DSS2(M) - RKSSSS(M,1)*DSS2(M)
     &                  + RJSSLL(M,1)*DLL2(M)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G22(IBAS,JBAS) = GLL
            G22(KBAS,JBAS) = GSL
            G22(JBAS,KBAS) = GSL
            G22(KBAS,LBAS) = GSS
C
C    (21)   KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNB.EQ.0) GOTO 200
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,2)*DLL1(M) - RKLLLL(M,2)*DLL1(M)
     &                  + RJLLSS(M,2)*DSS1(M)
              GSL = GSL                       - RKSLSL(M,2)*DSL1(M)
              GSS = GSS + RJSSSS(M,2)*DSS1(M) - RKSSSS(M,2)*DSS1(M)
     &                  + RJSSLL(M,2)*DLL1(M)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G21(IBAS,JBAS) = GLL
            G21(KBAS,JBAS) = GSL
            G21(JBAS,KBAS) = GSL
            G21(KBAS,LBAS) = GSS
C
200         CONTINUE
C
C    (12)   KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0) GOTO 300
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,3)*DLL2(M) - RKLLLL(M,3)*DLL2(M)
     &                  + RJLLSS(M,3)*DSS2(M)
              GSL = GSL                       - RKSLSL(M,3)*DSL2(M)
              GSS = GSS + RJSSSS(M,3)*DSS2(M) - RKSSSS(M,3)*DSS2(M)
     &                  + RJSSLL(M,3)*DLL2(M)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G12(IBAS,JBAS) = GLL
            G12(KBAS,JBAS) = GSL
            G12(JBAS,KBAS) = GSL
            G12(KBAS,LBAS) = GSS
C
300         CONTINUE
C
C    (11)   KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 400
C
C           INITIALISE COUNTERS
            GLL = 0.0D0
            GSL = 0.0D0
            GSS = 0.0D0
C
C           SUM OVER MEAN FIELD CONTRIBUTIONS FOR THIS BASIS PAIR
            DO M=1,MAXM
              GLL = GLL + RJLLLL(M,4)*DLL1(M) - RKLLLL(M,4)*DLL1(M)
     &                  + RJLLSS(M,4)*DSS1(M)
              GSL = GSL                       - RKSLSL(M,4)*DSL1(M)
              GSS = GSS + RJSSSS(M,4)*DSS1(M) - RKSSSS(M,4)*DSS1(M)
     &                  + RJSSLL(M,4)*DLL1(M)
            ENDDO
C
C           TRANSFER COUNTER VALUES TO COULOMB MATRIX
            G11(IBAS,JBAS) = GLL
            G11(KBAS,JBAS) = GSL
            G11(JBAS,KBAS) = GSL
            G11(KBAS,LBAS) = GSS
C
400         CONTINUE
C
          ENDIF
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RKCLM0(RJLLLL,RJSSSS,RJLLSS,RJSSLL,
     &                                       RKLLLL,RKSSSS,RKSLSL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       RRRRRRR  KK    KK CCCCCC  LL       MM       MM  000000         C
C       RR    RR KK   KK CC    CC LL       MMM     MMM 00   000        C
C       RR    RR KK  KK  CC       LL       MMMM   MMMM 00  0000        C
C       RR    RR KKKKK   CC       LL       MM MM MM MM 00 00 00        C
C       RRRRRRR  KK  KK  CC       LL       MM  MMM  MM 0000  00        C
C       RR    RR KK   KK CC    CC LL       MM   M   MM 000   00        C
C       RR    RR KK    KK CCCCCC  LLLLLLLL MM       MM  000000         C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKCLM0 EVALUATES A DIRECT AND EXCHANGE BATCH OF ELECTRON REPULSION  C
C  INTEGRALS OF ALL COMPONENT LABEL COMBINATIONS L AND S IN THE ATOMIC C
C  SCF PROCEDURE FOR A USER-SPECIFIED HAMILTONIAN.                     C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    RJLLLL(M,N) - DIRECT ERI OVERLAP {LL,LL}                          C
C    RJSSSS(M,N) - DIRECT ERI OVERLAP {SS,SS}                          C
C    RJLLSS(M,N) - DIRECT ERI OVERLAP {LL,SS}                          C
C    RJSSLL(M,N) - DIRECT ERI OVERLAP {SS,LL}                          C
C    RKLLLL(M,N) - EXCHANGE ERI OVERLAP {LL,LL}                        C
C    RKSSSS(M,N) - EXCHANGE ERI OVERLAP {SS,SS}                        C
C    RKSLSL(M,N) - EXCHANGE ERI OVERLAP {SL,SL}                        C
C -------------------------------------------------------------------- C
C    N=1 - KQN(A)<0, KQN(B)<0 (TYPICAL LABEL 22)                       C
C    N=2 - KQN(A)<0, KQN(B)>0 (TYPICAL LABEL 12)                       C
C    N=3 - KQN(A)>0, KQN(B)<0 (TYPICAL LABEL 21)                       C
C    N=4 - KQN(A)>0, KQN(B)>0 (TYPICAL LABEL 11)                       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+6)
C
      CHARACTER*4 HMLT
C
      DIMENSION XJ(MB2,2),XK(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
      DIMENSION BDU(MB2,-MAB:MAB,-MAB:MAB),BDL(MB2,-MAB:MAB,-MAB:MAB)
      DIMENSION BXU(MB2,-MAB:MAB,-MAB:MAB),BXL(MB2,-MAB:MAB,-MAB:MAB)
C
      DIMENSION RTIK0(MBS),RTJL0(MBS),PTIK0(MBS),PTJL0(MBS)
      DIMENSION RJLLLL(MB2,4),RJSSSS(MB2,4),RJLLSS(MB2,4),RJSSLL(MB2,4),
     &          RKLLLL(MB2,4),RKSSSS(MB2,4),RKSLSL(MB2,4)
C
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BIKS/EIK(MB2,-MAB:MAB),IKIND(MB2)
      COMMON/BJLS/EJL(MB2,-MAB:MAB),JLIND(MB2)
      COMMON/BKLS/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/TANG/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C     LOWEST EXPONENT POWER
      IPOWER = LQNA+LQNB-NUF
C
C     A BLOCK OF BASIS EXPONENT PRODUCTS
      DO KBAS=1,NBASB
        RTIK0(KBAS) = DSQRT(EI+EXLB(KBAS))
        RTJL0(KBAS) = DSQRT(EJ+EXLB(KBAS))
        PTIK0(KBAS) = RTIK0(KBAS)**(-IPOWER)
        PTJL0(KBAS) = RTJL0(KBAS)**(-IPOWER)
      ENDDO
C
C     CALCULATE A FULL SET OF EXPONENT OVERLAPS FOR EXCHANGE
      DO M=1,MAXM
        RTIK  = RTIK0(IKIND(M))
        RTJL  = RTJL0(JLIND(M))
        EIK(M,-NUF) = PTIK0(IKIND(M))
        EJL(M,-NUF) = PTJL0(JLIND(M))
        DO IPOW=-NUF+1,NUF+5
          EIK(M,IPOW) = EIK(M,IPOW-1)/RTIK
          EJL(M,IPOW) = EJL(M,IPOW-1)/RTJL
        ENDDO
      ENDDO
C
C     CALCULATE LIST OF BETA FUNCTION ARGUMENTS, XK(MB2,2) (Z AND Z')
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = EI+EJ+TKL0
        XK(M,1) = (EI+EK(M))/TIJKL
        XK(M,2) = (EJ+EL(M))/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL DIRECT INTEGRALS
      NVALS = 3
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
C
C       TWICE THE ACTUAL FAMILY VALUE
        IAA(1) = 2*LQNA+2*NX-1
        IAA(2) = 2*LQNB+2*NX-1
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = 2*LQNB+2*NY-2
          IBB(2) = 2*LQNA+2*NY-2
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO J=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      =  1.0D0-XROOT(M)
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
            ENDIF
C
C           SORT THE BETA INTEGRAL INTO THE CORRECT ARRAY
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BDU(M,2*NX-1,2*NY-2) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BDL(M,2*NX-1,2*NY-2) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR EXCHANGE TERMS                     C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL EXCHANGE INTEGRALS
      NVALS = (NUF-NUI)/2+3
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
        IAA(1) = LQNA+LQNB+NUI+2*NX-1
        IAA(2) = LQNA+LQNB+NUI+2*NX-1
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = LQNA+LQNB-NUF+2*NY-2
          IBB(2) = LQNA+LQNB-NUF+2*NY-2
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA = (IAA(IBETA)-1)/2
            IB =  IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
              RA = X
              RB = DFLOAT(1-IB)
              RC = 1.0D0+X
              RD = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XK(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO J=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XK(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XK(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XK(M,IBETA)
              ENDDO
C
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XK(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
            ENDIF
C
C           SORT THE BETA INTEGRAL INTO THE UPPER/LOWER ARRAYS
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BXU(M, NUI+2*NX-1,-NUF+2*NY-2) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BXL(M, NUI+2*NX-1,-NUF+2*NY-2) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXM
        DO N=1,4
          RJLLLL(M,N) = 0.0D0
          RJLLSS(M,N) = 0.0D0
          RJSSLL(M,N) = 0.0D0
          RJSSSS(M,N) = 0.0D0
          RKLLLL(M,N) = 0.0D0
          RKSLSL(M,N) = 0.0D0
          RKSSSS(M,N) = 0.0D0
        ENDDO
      ENDDO
C
C     VALUE PREPARATION
      E0000 = 1.0D0
      E1000 = EI
      E0100 = EJ
      E1100 = EI*EJ
C
C     INITIATE LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1010 = EI*EK(M)
        E1001 = EI*EL(M)
        E0110 = EJ*EK(M)
        E0101 = EJ*EL(M)
        E0011 = EK(M)*EL(M)
        E1110 = EI*EJ*EK(M)
        E1101 = EI*EJ*EL(M)
        E1011 = EI*EK(M)*EL(M)
        E0111 = EJ*EK(M)*EL(M)
        E1111 = EI*EJ*EK(M)*EL(M)
C
C**********************************************************************C
C       DIRECT INTEGRAL MATRICES: RJSSSS, RJLLSS, RJSSLL, RJLLLL       C
C**********************************************************************C
C
        IF(HMLT.EQ.'NORL') THEN
C       NON-RELATIVISTIC HAMILTONIAN
C
          B32 = EIJ(2)*EKL(M,3)*BDL(M,3,2) + EIJ(3)*EKL(M,2)*BDU(M,3,2)
C
          RJLLLL(M,1) = V1*T0000*E0000*C5*B32
C
        ELSE
C       RELATIVISTIC HAMILTONIAN
C
C         TEMPORARY STORAGE OF RAW RJ(1,M) (LTEN=1 BECAUSE NU=0 ONLY)
          B10 = EIJ(0)*EKL(M,1)*BDL(M,1,0) + EIJ(1)*EKL(M,0)*BDU(M,1,0)
          B12 = EIJ(2)*EKL(M,1)*BDL(M,1,2) + EIJ(3)*EKL(M,0)*BDU(M,3,0)
          B14 = EIJ(4)*EKL(M,1)*BDL(M,1,4) + EIJ(5)*EKL(M,0)*BDU(M,5,0)
          B30 = EIJ(0)*EKL(M,3)*BDL(M,3,0) + EIJ(1)*EKL(M,2)*BDU(M,1,2)
          B32 = EIJ(2)*EKL(M,3)*BDL(M,3,2) + EIJ(3)*EKL(M,2)*BDU(M,3,2)
          B34 = EIJ(4)*EKL(M,3)*BDL(M,3,4) + EIJ(5)*EKL(M,2)*BDU(M,5,2)
          B50 = EIJ(0)*EKL(M,5)*BDL(M,5,0) + EIJ(1)*EKL(M,4)*BDU(M,1,4)
          B52 = EIJ(2)*EKL(M,5)*BDL(M,5,2) + EIJ(3)*EKL(M,4)*BDU(M,3,4)
          B54 = EIJ(4)*EKL(M,5)*BDL(M,5,4) + EIJ(5)*EKL(M,4)*BDU(M,5,4)
C
C         FILL RJ ARRAYS FOR THIS LQNA,LQNB BLOCK
C
C         KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
          RJLLLL(M,1) = V1*T0000*E0000*C5*B32
          RJLLSS(M,1) = V4*T0000*E0011*C7*B52
          RJSSLL(M,1) = V4*T0000*E1100*C7*B34
          RJSSSS(M,1) = VS*T0000*E1111*C9*B54
C
C         KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 102
          RJLLLL(M,2) = V1*T0000*E0000*C5*B32
          RJLLSS(M,2) = V4*T0000*E0011*C7*B52
     &                - V2*T0001*E0010*C5*B32 - V2*T0010*E0001*C5*B32
     &                + V1*T0011*E0000*C3*B12
          RJSSLL(M,2) = V4*T0000*E1100*C7*B34
          RJSSSS(M,2) = VS*T0000*E1111*C9*B54
     &                - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B34
     &                + V4*T0011*E1100*C5*B14
102       CONTINUE
C
C         KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 103
          RJLLLL(M,3) = V1*T0000*E0000*C5*B32
          RJLLSS(M,3) = V4*T0000*E0011*C7*B52
          RJSSLL(M,3) = V4*T0000*E1100*C7*B34
     &                - V2*T0100*E1000*C5*B32 - V2*T1000*E0100*C5*B32
     &                + V1*T1100*E0000*C3*B30
          RJSSSS(M,3) = VS*T0000*E1111*C9*B54
     &                - V8*T0100*E1011*C7*B52 - V8*T1000*E0111*C7*B52
     &                + V4*T1100*E0011*C5*B50
103       CONTINUE
C
C         KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 104
          RJLLLL(M,4) = V1*T0000*E0000*C5*B32
          RJLLSS(M,4) = V4*T0000*E0011*C7*B52
     &                - V2*T0001*E0010*C5*B32 - V2*T0010*E0001*C5*B32
     &                + V1*T0011*E0000*C3*B12
          RJSSLL(M,4) = V4*T0000*E1100*C7*B34
     &                - V2*T0100*E1000*C5*B32 - V2*T1000*E0100*C5*B32
     &                + V1*T1100*E0000*C3*B30
          RJSSSS(M,4) = VS*T0000*E1111*C9*B54
     &                - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B34
     &                - V8*T0100*E1011*C7*B52 - V8*T1000*E0111*C7*B52
     &                + V4*T1100*E0011*C5*B50 + V4*T0011*E1100*C5*B14
     &                + V4*T0110*E1001*C5*B32 + V4*T1001*E0110*C5*B32
     &                + V4*T1010*E0101*C5*B32 + V4*T0101*E1010*C5*B32
     &                - V2*T0111*E1000*C3*B12 - V2*T1011*E0100*C3*B12
     &                - V2*T1101*E0010*C3*B30 - V2*T1110*E0001*C3*B30
     &                + V1*T1111*E0000*C1*B10
104       CONTINUE
C
        ENDIF
C
C**********************************************************************C
C       EXCHANGE INTEGRAL MATRICES: RKSSSS, RKSLSL, RKLLLL             C
C**********************************************************************C
C
C       LOOP OVER THE TENSOR ORDERS OF THE COULOMB INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
            B32 = EIK(M,-NU+2)*EJL(M, NU+3)*BXL(M, NU+3,-NU+2)
     &          + EIK(M, NU+3)*EJL(M,-NU+2)*BXU(M, NU+3,-NU+2)
C
            RKLL = V1*T0000*E0000*C5*B32
C
            RKLLLL(M,1) = RKLLLL(M,1) + BK(LTEN,1)*RKLL
C
          ELSE
C         RELATIVISTIC HAMILTONIAN
C
C           TEMPORARY STORAGE OF RAW RK(LTEN,M)
            B10 = EIK(M,-NU  )*EJL(M, NU+1)*BXL(M, NU+1,-NU  )
     &          + EIK(M, NU+1)*EJL(M,-NU  )*BXU(M, NU+1,-NU  )
            B12 = EIK(M,-NU+2)*EJL(M, NU+1)*BXL(M, NU+1,-NU+2)
     &          + EIK(M, NU+3)*EJL(M,-NU  )*BXU(M, NU+3,-NU  )
            B14 = EIK(M,-NU+4)*EJL(M, NU+1)*BXL(M, NU+1,-NU+4)
     &          + EIK(M, NU+5)*EJL(M,-NU  )*BXU(M, NU+5,-NU  )
            B30 = EIK(M,-NU  )*EJL(M, NU+3)*BXL(M, NU+3,-NU  )
     &          + EIK(M, NU+1)*EJL(M,-NU+2)*BXU(M, NU+1,-NU+2)
            B32 = EIK(M,-NU+2)*EJL(M, NU+3)*BXL(M, NU+3,-NU+2)
     &          + EIK(M, NU+3)*EJL(M,-NU+2)*BXU(M, NU+3,-NU+2)
            B34 = EIK(M,-NU+4)*EJL(M, NU+3)*BXL(M, NU+3,-NU+4)
     &          + EIK(M, NU+5)*EJL(M,-NU+2)*BXU(M, NU+5,-NU+2)
            B50 = EIK(M,-NU  )*EJL(M, NU+5)*BXL(M, NU+5,-NU  )
     &          + EIK(M, NU+1)*EJL(M,-NU+4)*BXU(M, NU+1,-NU+4)
            B52 = EIK(M,-NU+2)*EJL(M, NU+5)*BXL(M, NU+5,-NU+2)
     &          + EIK(M, NU+3)*EJL(M,-NU+4)*BXU(M, NU+3,-NU+4)
            B54 = EIK(M,-NU+4)*EJL(M, NU+5)*BXL(M, NU+5,-NU+4)
     &          + EIK(M, NU+5)*EJL(M,-NU+4)*BXU(M, NU+5,-NU+4)
C
C           KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
            RKLL = V1*T0000*E0000*C5*B32
            RKSL = V4*T0000*E1010*C7*B34
            RKSS = VS*T0000*E1111*C9*B54
C
            RKLLLL(M,1) = RKLLLL(M,1) + BK(LTEN,1)*RKLL
            RKSLSL(M,1) = RKSLSL(M,1) + BK(LTEN,1)*RKSL
            RKSSSS(M,1) = RKSSSS(M,1) + BK(LTEN,1)*RKSS
C
C           KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNB.EQ.0) GOTO 202
            RKLL = V1*T0000*E0000*C5*B32
            RKSL = V4*T0000*E1010*C7*B34 - V2*T0010*E1000*C5*B32
            RKSS = VS*T0000*E1111*C9*B54 - V8*T0001*E1110*C7*B34
     &           - V8*T0010*E1101*C7*B52 + V4*T0011*E1100*C5*B32
C
            RKLLLL(M,2) = RKLLLL(M,2) + BK(LTEN,2)*RKLL
            RKSLSL(M,2) = RKSLSL(M,2) + BK(LTEN,2)*RKSL
            RKSSSS(M,2) = RKSSSS(M,2) + BK(LTEN,2)*RKSS
202         CONTINUE
C
C           KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0) GOTO 203
            RKLL = V1*T0000*E0000*C5*B32
            RKSL = V4*T0000*E1010*C7*B34 - V2*T0100*E0010*C5*B32
            RKSS = VS*T0000*E1111*C9*B54 - V8*T0100*E1011*C7*B34
     &           - V8*T1000*E0111*C7*B52 + V4*T1100*E0011*C5*B32
C
            RKLLLL(M,3) = RKLLLL(M,3) + BK(LTEN,3)*RKLL
            RKSLSL(M,3) = RKSLSL(M,3) + BK(LTEN,3)*RKSL
            RKSSSS(M,3) = RKSSSS(M,3) + BK(LTEN,3)*RKSS
203         CONTINUE
C
C           KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
            IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 204
            RKLL = V1*T0000*E0000*C5*B32
            RKSL = V4*T0000*E1010*C7*B34 - V2*T1000*E0010*C5*B32
     &           - V2*T0010*E1000*C5*B32 + V1*T1010*E0000*C3*B30
            RKSS = VS*T0000*E1111*C9*B54
     &           - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B52
     &           - V8*T0100*E1011*C7*B34 - V8*T1000*E0111*C7*B52
     &           + V4*T1100*E0011*C5*B32 + V4*T0011*E1100*C5*B32
     &           + V4*T1001*E0110*C5*B32 + V4*T0110*E1001*C5*B32
     &           + V4*T0101*E1010*C5*B14 + V4*T1010*E0101*C5*B50
     &           - V2*T1101*E0010*C3*B12 - V2*T0111*E1000*C3*B12
     &           - V2*T1110*E0001*C3*B30 - V2*T1011*E0100*C3*B30
     &           + V1*T1111*E0000*C1*B10
C
            RKLLLL(M,4) = RKLLLL(M,4) + BK(LTEN,4)*RKLL
            RKSLSL(M,4) = RKSLSL(M,4) + BK(LTEN,4)*RKSL
            RKSSSS(M,4) = RKSSSS(M,4) + BK(LTEN,4)*RKSS
204         CONTINUE
C
          ENDIF
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      IF(HMLT.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          RNLLLL = RNIJ(1)*RNKL(M,1)
          RJLLLL(M,1) = RJLLLL(M,1)*RNLLLL
          RKLLLL(M,1) = RKLLLL(M,1)*RNLLLL
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          RNLLLL = RNIJ(1)*RNKL(M,1)
          RNLLSS = RNIJ(1)*RNKL(M,3)
          RNSLSL = RNIJ(2)*RNKL(M,2)
          RNSSLL = RNIJ(3)*RNKL(M,1)
          RNSSSS = RNIJ(3)*RNKL(M,3)
          DO N=1,4
            RJLLLL(M,N) = RJLLLL(M,N)*RNLLLL
            RJLLSS(M,N) = RJLLSS(M,N)*RNLLSS
            RJSSLL(M,N) = RJSSLL(M,N)*RNSSLL
            RJSSSS(M,N) = RJSSSS(M,N)*RNSSSS
            RKLLLL(M,N) = RKLLLL(M,N)*RNLLLL
            RKSLSL(M,N) = RKSLSL(M,N)*RNSLSL
            RKSSSS(M,N) = RKSSSS(M,N)*RNSSSS
          ENDDO
        ENDDO
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ANGCLM0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     AA    NN    NN  GGGGGG   CCCCCC  LL       MM       MM  000000    C
C    AAAA   NNN   NN GG    GG CC    CC LL       MMM     MMM 00   000   C
C   AA  AA  NNNN  NN GG       CC       LL       MMMM   MMMM 00  0000   C
C  AA    AA NN NN NN GG       CC       LL       MM MM MM MM 00 00 00   C
C  AAAAAAAA NN  NNNN GG   GGG CC       LL       MM  MMM  MM 0000  00   C
C  AA    AA NN   NNN GG    GG CC    CC LL       MM   M   MM 000   00   C
C  AA    AA NN    NN  GGGGGG   CCCCCC  LLLLLLLL MM       MM  000000    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGCLM0 EVALUATES THE ANGULAR COEFFICIENTS OF THE COULOMB           C
C  INTERACTIONS FOR CLOSED SHELLS IN THE (L1,L2) MANIFOLD.             C
C**********************************************************************C
      PARAMETER(MBS=26,MKP=9,MNU=MKP+1)
C
      CHARACTER*4 HMLT
C
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/TANG/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     CALCULATE KQNA AND 2*JQNA VALUES FROM LQNA
      KLA =-LQNA-1
      KRA = LQNA
      JLA = 2*IABS(KLA)-1
      JRA = 2*IABS(KRA)-1
C
C     CALCULATE KQNB AND 2*JQNB VALUES FROM LQNB
      KLB =-LQNB-1
      KRB = LQNB
      JLB = 2*IABS(KLB)-1
      JRB = 2*IABS(KRB)-1
C
C     START AND END PARAMETERS FROM TRIANGLE RULE
      NUI = IABS(LQNA-LQNB)
      NUF = LQNA+LQNB+1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 0
      DO NU=NUI,NUF
C
C       TEST WHETHER 'LQNA+LQNB+NU' ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.1) THEN
C       ONLY ANGULAR COEFFICIENTS OF EVEN PARITY ARE NON-ZERO
C
C         SAVE THIS TENSOR ORDER
          LTEN      = LTEN+1
          NUS(LTEN) = NU
C
          IF(HMLT.EQ.'NORL') THEN
            BK(LTEN,1) = 0.5D0*ABC000(LQNA,LQNB,NU)
          ELSE
            BK(LTEN,1) = SYM3JSQ(JLA,JLB,NU)
            BK(LTEN,2) = SYM3JSQ(JLA,JRB,NU)
            BK(LTEN,3) = SYM3JSQ(JRA,JLB,NU)
            BK(LTEN,4) = SYM3JSQ(JRA,JRB,NU)
          ENDIF
        ENDIF
C
      ENDDO
C
C     NUMBER OF SURVIVING TENSOR ORDERS
      NUNUM = LTEN
C
      RETURN
      END
C
C
      FUNCTION ABC000(L1,L2,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           AA    BBBBBBB   CCCCCC   000000   000000   000000          C
C          AAAA   BB    BB CC    CC 00   000 00   000 00   000         C
C         AA  AA  BB    BB CC       00  0000 00  0000 00  0000         C
C        AA    AA BBBBBBB  CC       00 00 00 00 00 00 00 00 00         C
C        AAAAAAAA BB    BB CC       0000  00 0000  00 0000  00         C
C        AA    AA BB    BB CC    CC 000   00 000   00 000   00         C
C        AA    AA BBBBBBB   CCCCCC   000000   000000   000000          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ABC000 EVALUATES THE NON-RELATIVISTIC 3-J SYMBOL FOR ATOMIC COULOMB C
C  ANGULAR COEFFICIENT ROUTINES, TAKEN FROM BRINK AND SATCHLER.        C
C  L1,L2, AND K MUST BE EQUAL TO THE ACTUAL (INTEGER) ANGULAR MOMENTA  C
C  OF THE ELECTRON AND PHOTON.                                         C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:20),SFACT(0:20)
C
C     TRIANGLE INEQUALITY RESTRICTIONS
      IF(K.LT.IABS(L1-L2).OR.K.GT.(L1+L2)) THEN
        ABC000 = 0.0D0
        RETURN
      ENDIF
      LLK = L1+L2+K
C
C     PARITY SELECTION RULE
      IF((LLK/2)*2.NE.LLK) THEN
        ABC000 = 0.0D0
        RETURN
      ENDIF
C
      RF1 = RFACT(  L1+L2-K   )
      RF2 = RFACT(- L1+L2+K   )
      RF3 = RFACT(  L1-L2+K   )
      RF4 = RFACT(  L1+L2+K +1)
      RF5 = RFACT(( L1+L2+K)/2)
      RF6 = RFACT(( L1+L2-K)/2)
      RF7 = RFACT(( L1-L2+K)/2)
      RF8 = RFACT((-L1+L2+K)/2)
C
      T1 = RF1*RF2*RF3
      T2 = T1/RF4
      T3 = RF6*RF7*RF8
      T4 = RF5/T3
C
      ABC000 = T2*T4*T4
C
      RETURN
      END
C
C
      FUNCTION SYM3JSQ(J1,J2,K)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS  YY    YY MM       MM  333333       JJJJ SSSSSS   QQQQQQ    C
C  SS    SS YY    YY MMM     MMM 33    33       JJ SS    SS QQ    QQ   C
C  SS       YY    YY MMMM   MMMM       33       JJ SS       QQ    QQ   C
C   SSSSSS   YY  YY  MM MM MM MM    3333        JJ  SSSSSS  QQ    QQ   C
C        SS   YYYY   MM  MMM  MM       33       JJ       SS QQ   QQQ   C
C  SS    SS    YY    MM   M   MM 33    33 JJ    JJ SS    SS QQ    QQ   C
C   SSSSSS     YY    MM       MM  333333   JJJJJJ   SSSSSS   QQQQQQ Q  C
C                                                                      C
C -------------------------------------------------------------------- C
C  SYM3JSQ EVALUATES THE SQUARE OF A 3-J SYMBOL,   /  j   K   j' \^2   C
C  WHERE j = J1/2 AND j' = J2/2, FOR THE           \-1/2  0  1/2 /     C
C  COULOMB/BREIT ANGULAR COEFFICIENT ROUTINES.                         C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:20),SFACT(0:20)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(K.LT.IABS((J1-J2)/2).OR.K.GT.(J1+J2)/2) THEN
        SYM3JSQ = 0.0D0
        RETURN
      ELSEIF(J1.LE.0.OR.J2.LE.0) THEN
        SYM3JSQ = 0.0D0
        RETURN
      ENDIF
C
C     VARIABLE WHICH DEPENDS ON PARITY OF ARGUMENTS
      JJK = (J1+J2)/2 + K
      IF((JJK/2)*2.EQ.JJK) THEN
        M = K
      ELSE
        M = K+1
      ENDIF
C
      RN1 = RFACT(( J1+J2)/2 - K)
      RN2 = RFACT((-J1+J2)/2 + K)
      RN3 = RFACT(( J1-J2)/2 + K)
      RN4 = SFACT(( J1+J2)/2 + M)
      RD1 = DFLOAT(J1+1)
      RD2 = DFLOAT(J2+1)
      RD3 = RFACT(( J1+J2)/2 + K + 1)
      RD4 = SFACT(( J1+J2)/2 - M    )
      RD5 = SFACT(( J1-J2)/2 + M - 1)
      RD6 = SFACT((-J1+J2)/2 + M - 1)
      PHS = (-1.0D0)**((J2-(3*J1))/2+M)
C
      RNUM  = RN1*RN2*RN3*(RN4)**2
      RDEN  = RD1*RD2*RD3*(RD4*RD5*RD6)**2
C
      SYM3JSQ = PHS*RNUM/RDEN
C
      RETURN
      END
C
C
      SUBROUTINE BREIT0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT 000000            C
C           BB    BB RR    RR EE        II     TT   00   000           C
C           BB    BB RR    RR EE        II     TT   00  0000           C
C           BBBBBBB  RR    RR EEEEEE    II     TT   00 00 00           C
C           BB    BB RRRRRRR  EE        II     TT   0000  00           C
C           BB    BB RR    RR EE        II     TT   000   00           C
C           BBBBBBB  RR    RR EEEEEEEE IIII    TT    000000            C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT0 CONSTRUCTS THE ATOMIC BREIT MATRIX FROM RADIAL DIRECT AND    C
C  EXCHANGE INTEGRALS AND A MEAN-FIELD CHARGE DENSITY.                 C
C**********************************************************************C
      PARAMETER(MBS=26,MBD=2*MBS,MB2=MBS*MBS,MKP=9,MNU=MKP+1,
     &                                                      MAB=2*MNU+6)
C
      DIMENSION RKLLSS(MB2,4),RKSLLS(MB2,4),RKSSLL(MB2,4),RMSLLS(MB2,4)
C
      COMMON/ATMB/B11(MBD,MBD),B21(MBD,MBD),B12(MBD,MBD),B22(MBD,MBD)
      COMMON/ATMD/DLL1(MB2),DSL1(MB2),DSS1(MB2),DLS1(MB2),
     &            DLL2(MB2),DSL2(MB2),DSS2(MB2),DLS2(MB2)
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
C
C     INITIALISE BREIT MATRIX
      DO IBAS=1,MBD
        DO JBAS=1,MBD
          B11(IBAS,JBAS) = 0.0D0
          B21(IBAS,JBAS) = 0.0D0
          B12(IBAS,JBAS) = 0.0D0
          B22(IBAS,JBAS) = 0.0D0
        ENDDO
      ENDDO
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C3 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+3)
      C5 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+5)
      C7 = 0.25D0*GAMHLF(2*LQNA+2*LQNB+7)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
C
      TI = DFLOAT(2*LQNA+1)
      TJ = DFLOAT(2*LQNA+1)
      TK = DFLOAT(2*LQNB+1)
      TL = DFLOAT(2*LQNB+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1001 = TI*TL
      T0011 = TK*TL
C
C     EVALUATE CLOSED-SHELL BREIT INTERACTION ANGULAR INTEGRALS
      CALL ANGBRT0
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL KLSET0
C
C     ITERATE OVER ALL MATRIX ELEMENTS
      DO IBAS=1,NBASA
        DO JBAS=1,NBASA
C
C         GAUSSIAN EXPONENTS FOR THIS PAIR
          EI = EXLA(IBAS)
          EJ = EXLA(JBAS)
C
C         BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
          CALL IJSET0
C
C         GENERATE BATCH OF RADIAL INTEGRALS (J AND K MATRICES)
          CALL RKBRT0(RKLLSS,RKSLLS,RKSSLL,RMSLLS)
C
C         SMALL-COMPONENT MATRIX ADDRESSES
          KBAS = IBAS + NBASA
          LBAS = JBAS + NBASA
C
C    (22) KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,1)*DSS2(M)
            BSL = BSL + RKSLLS(M,1)*DLS2(M) + RMSLLS(M,1)*DLS2(M)
            BSS = BSS + RKSSLL(M,1)*DLL2(M)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B22(IBAS,JBAS) = BLL
          B22(KBAS,JBAS) = BSL
          B22(JBAS,KBAS) = BSL
          B22(KBAS,LBAS) = BSS
C
C    (21) KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 200
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,2)*DSS1(M)
            BSL = BSL + RKSLLS(M,2)*DLS1(M) + RMSLLS(M,2)*DLS1(M)
            BSS = BSS + RKSSLL(M,2)*DLL1(M)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B21(IBAS,JBAS) = BLL
          B21(KBAS,JBAS) = BSL
          B21(JBAS,KBAS) = BSL
          B21(KBAS,LBAS) = BSS
C
200       CONTINUE
C
C    (12) KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 300
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
C
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,3)*DSS2(M)
            BSL = BSL + RKSLLS(M,3)*DLS2(M) + RMSLLS(M,3)*DLS2(M)
            BSS = BSS + RKSSLL(M,3)*DLL2(M)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B12(IBAS,JBAS) = BLL
          B12(KBAS,JBAS) = BSL
          B12(JBAS,KBAS) = BSL
          B12(KBAS,LBAS) = BSS
C
300       CONTINUE
C
C    (11) KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 400
C
C         INITIALISE COUNTERS
          BLL = 0.0D0
          BSL = 0.0D0
          BSS = 0.0D0
C
C         SUM OVER MEAN FIELD CONTRIBUTIONS FOR THIS BASIS PAIR
          DO M=1,MAXM
            BLL = BLL + RKLLSS(M,4)*DSS1(M)
            BSL = BSL + RKSLLS(M,4)*DLS1(M) + RMSLLS(M,4)*DLS1(M)
            BSS = BSS + RKSSLL(M,4)*DLL1(M)
          ENDDO
C
C         TRANSFER COUNTER VALUES TO BREIT MATRIX
          B11(IBAS,JBAS) = BLL
          B11(KBAS,JBAS) = BSL
          B11(JBAS,KBAS) = BSL
          B11(KBAS,LBAS) = BSS
C
400       CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RKBRT0(RKLLSS,RKSLLS,RKSSLL,RMSLLS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         RRRRRRR  KK    KK BBBBBBB  RRRRRRR TTTTTTTT 000000           C
C         RR    RR KK   KK  BB    BB RR    RR   TT   00   000          C
C         RR    RR KK  KK   BB    BB RR    RR   TT   00  0000          C
C         RR    RR KKKKK    BBBBBBB  RR    RR   TT   00 00 00          C
C         RRRRRRR  KK  KK   BB    BB RRRRRRR    TT   0000  00          C
C         RR    RR KK   KK  BB    BB RR    RR   TT   000   00          C
C         RR    RR KK    KK BBBBBBB  RR    RR   TT    000000           C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKBRT0 EVALUATES A DIRECT AND EXCHANGE BATCH OF BREIT INTERACTION   C
C  INTEGRALS OF ALL COMPONENT LABEL COMBINATIONS L AND S IN THE ATOMIC C
C  (RELATIVISTIC) SCF PROCEDURE.                                       C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    RKLLSS(M,N) - EXCHANGE BII OVERLAP {LL,SS}                        C
C    RKSLLS(M,N) - EXCHANGE BII OVERLAP {SL,SL}                        C
C    RKSSLL(M,N) - EXCHANGE BII OVERLAP {SS,LL}                        C
C    RMSLLS(M,N) - SEMI-RANGE BII OVERLAP {SL,SL}                      C
C -------------------------------------------------------------------- C
C    N=1 - KQN(A)<0, KQN(B)<0 (TYPICAL LABEL 22)                       C
C    N=2 - KQN(A)<0, KQN(B)>0 (TYPICAL LABEL 12)                       C
C    N=3 - KQN(A)>0, KQN(B)<0 (TYPICAL LABEL 21)                       C
C    N=4 - KQN(A)>0, KQN(B)>0 (TYPICAL LABEL 11)                       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+6)
C
      DIMENSION XK(MB2,2),IAA(2),IBB(2)
      DIMENSION RTIK0(MBS),RTJL0(MBS),PTIK0(MBS),PTJL0(MBS)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
      DIMENSION BXU(MB2,-MAB:MAB,-MAB:MAB),BXL(MB2,-MAB:MAB,-MAB:MAB)
      DIMENSION RKLLSS(MB2,4),RKSLLS(MB2,4),RKSSLL(MB2,4),RMSLLS(MB2,4)
C
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BIKS/EIK(MB2,-MAB:MAB),IKIND(MB2)
      COMMON/BJLS/EJL(MB2,-MAB:MAB),JLIND(MB2)
      COMMON/BKLS/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/TANG/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XK(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TKL0  = EK(M)+EL(M)
        TIJKL = TIJ0+TKL0
        XK(M,1) = (EI+EK(M))/TIJKL
        XK(M,2) = (EJ+EL(M))/TIJKL
      ENDDO
C
C     LOWEST EXPONENT POWER
      IPOWER = LQNA+LQNB-NUF
C
C     A BLOCK OF BASIS EXPONENT PRODUCTS
      DO KBAS=1,NBASB
        RTIK0(KBAS) = DSQRT(EI+EXLB(KBAS))
        RTJL0(KBAS) = DSQRT(EJ+EXLB(KBAS))
        PTIK0(KBAS) = RTIK0(KBAS)**(-IPOWER)
        PTJL0(KBAS) = RTJL0(KBAS)**(-IPOWER)
      ENDDO
C
C     CALCULATE A FULL SET OF EXPONENT OVERLAPS FOR EXCHANGE
      DO M=1,MAXM
        RTIK = RTIK0(IKIND(M))
        RTJL = RTJL0(JLIND(M))
        EIK(M,-NUF) = PTIK0(IKIND(M))
        EJL(M,-NUF) = PTJL0(JLIND(M))
        DO IPOW=-NUF+1,NUF+4
          EIK(M,IPOW) = EIK(M,IPOW-1)/RTIK
          EJL(M,IPOW) = EJL(M,IPOW-1)/RTJL
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR EXCHANGE TERMS                     C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL EXCHANGE INTEGRALS
      NVALS = (NUF-NUI)/2+2
C
C     LOOP OVER ORDER FOR FIRST INDEX
      DO NX=1,NVALS
        IAA(1) = LQNA+LQNB+NUI+2*NX
        IAA(2) = LQNA+LQNB+NUI+2*NX
C
C       LOOP OVER ORDER FOR SECOND INDEX
        DO NY=1,NVALS
          IBB(1) = LQNA+LQNB-NUF+2*NY-1
          IBB(2) = LQNA+LQNB-NUF+2*NY-1
C
C         LOOP OVER BETA INTEGRAL TYPE
          DO IBETA=1,2
            IA = (IAA(IBETA)-1)/2
            IB =  IBB(IBETA)   /2
C
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
              RA = X
              RB = DFLOAT(1-IB)
              RC = 1.0D0+X
              RD = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XK(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO J=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XK(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XK(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XK(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XK(M,IBETA)
              ENDDO
C
C             CASE A: IA > 1
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XK(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
C             CASE B: IA = 1
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
C             CASE C: IA = 0
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
            ENDIF
C
C           SORT THE BETA INTEGRAL INTO THE UPPER/LOWER ARRAYS
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BXU(M, NUI+2*NX  ,-NUF+2*NY-1) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BXL(M, NUI+2*NX  ,-NUF+2*NY-1) = BETA(M)
              ENDDO
            ENDIF
C
C         END LOOPS OVER IBETA AND INDICES NX, NY
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXM
        DO N=1,4
          RKLLSS(M,N) = 0.0D0
          RKSLLS(M,N) = 0.0D0
          RKSSLL(M,N) = 0.0D0
          RMSLLS(M,N) = 0.0D0
        ENDDO
      ENDDO
C
      E0000 = 1.0D0
      E1000 = EI
      E0100 = EJ
      E1100 = EI*EJ
C
C     INITIATE LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1001 = EI*EL(M)
        E0011 = EK(M)*EL(M)
C
C**********************************************************************C
C       EXCHANGE INTEGRAL MATRICES: RKLLSS, RKSLLS, RKSSLL             C
C**********************************************************************C
C
C       LOOP OVER THE TENSOR ORDERS OF THE BREIT INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         TEMPORARY STORAGE OF RAW RK(LTEN,M)
          B21 = EIK(M,-NU+1)*EJL(M, NU+2)*BXL(M, NU+2,-NU+1)
     &        + EIK(M, NU+2)*EJL(M,-NU+1)*BXU(M, NU+2,-NU+1)
          B23 = EIK(M,-NU+3)*EJL(M, NU+2)*BXL(M, NU+2,-NU+3)
     &        + EIK(M, NU+4)*EJL(M,-NU+1)*BXU(M, NU+4,-NU+1)
          B41 = EIK(M,-NU+1)*EJL(M, NU+4)*BXL(M, NU+4,-NU+1)
     &        + EIK(M, NU+2)*EJL(M,-NU+3)*BXU(M, NU+2,-NU+3)
          B43 = EIK(M,-NU+3)*EJL(M, NU+4)*BXL(M, NU+4,-NU+3)
     &        + EIK(M, NU+4)*EJL(M,-NU+3)*BXU(M, NU+4,-NU+3)
C
C         FILL RK ARRAYS FOR THIS LQNA,LQNB BLOCK
C
C         KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
          RKLL = V4*T0000*E0011*C7*B43
          RKSL = V4*T0000*E1001*C7*B43
          RKSS = V4*T0000*E1100*C7*B43
C
          RKLLSS(M,1) = RKLLSS(M,1) + ELL(LTEN,1)*RKLL
          RKSLLS(M,1) = RKSLLS(M,1) + ESL(LTEN,1)*RKSL
          RKSSLL(M,1) = RKSSLL(M,1) + ESS(LTEN,1)*RKSS
C
C         KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 202
          RKLL = V4*T0000*E0011*C7*B43 - V2*T0001*E0010*C5*B23
     &         - V2*T0010*E0001*C5*B41 + V1*T0011*E0000*C3*B21
          RKSL = V4*T0000*E1001*C7*B43 - V2*T0001*E1000*C5*B23
          RKSS = V4*T0000*E1100*C7*B43
C
          RKLLSS(M,2) = RKLLSS(M,2) + ELL(LTEN,2)*RKLL
          RKSLLS(M,2) = RKSLLS(M,2) + ESL(LTEN,2)*RKSL
          RKSSLL(M,2) = RKSSLL(M,2) + ESS(LTEN,2)*RKSS
202       CONTINUE
C
C         KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 203
          RKLL = V4*T0000*E0011*C7*B43
          RKSL = V4*T0000*E1001*C7*B43 - V2*T1000*E0001*C5*B41
          RKSS = V4*T0000*E1100*C7*B43 - V2*T0100*E1000*C5*B23
     &         - V2*T1000*E0100*C5*B41 + V1*T1100*E0000*C3*B21
C
          RKLLSS(M,3) = RKLLSS(M,3) + ELL(LTEN,3)*RKLL
          RKSLLS(M,3) = RKSLLS(M,3) + ESL(LTEN,3)*RKSL
          RKSSLL(M,3) = RKSSLL(M,3) + ESS(LTEN,3)*RKSS
203       CONTINUE
C
C         KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 204
          RKLL = V4*T0000*E0011*C7*B43 - V2*T0001*E0010*C5*B23
     &         - V2*T0010*E0001*C5*B41 + V1*T0011*E0000*C3*B21
          RKSL = V4*T0000*E1001*C7*B43 - V2*T1000*E0001*C5*B41
     &         - V2*T0001*E1000*C5*B23 + V1*T1001*E0000*C3*B21
          RKSS = V4*T0000*E1100*C7*B43 - V2*T0100*E1000*C5*B23
     &         - V2*T1000*E0100*C5*B41 + V1*T1100*E0000*C3*B21
C
          RKLLSS(M,4) = RKLLSS(M,4) + ELL(LTEN,4)*RKLL
          RKSLLS(M,4) = RKSLLS(M,4) + ESL(LTEN,4)*RKSL
          RKSSLL(M,4) = RKSSLL(M,4) + ESS(LTEN,4)*RKSS
204       CONTINUE
C
        ENDDO
C
C**********************************************************************C
C       HALF-RANGE EXCHANGE INTEGRAL MATRICES: RMSLLS                  C
C**********************************************************************C
C
C       LOOP OVER THE TENSOR ORDERS OF THE COULOMB INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         TEMPORARY STORAGE OF RAW RM(LTEN,M) FOR RMSLLS
          B21 = EIK(M,-NU+1)*EJL(M, NU+2)*BXL(M, NU+2,-NU+1)
     &        - EIK(M, NU+2)*EJL(M,-NU+1)*BXU(M, NU+2,-NU+1)
          B23 = EIK(M,-NU+3)*EJL(M, NU+2)*BXL(M, NU+2,-NU+3)
     &        - EIK(M, NU+4)*EJL(M,-NU+1)*BXU(M, NU+4,-NU+1)
          B41 = EIK(M,-NU+1)*EJL(M, NU+4)*BXL(M, NU+4,-NU+1)
     &        - EIK(M, NU+2)*EJL(M,-NU+3)*BXU(M, NU+2,-NU+3)
          B43 = EIK(M,-NU+3)*EJL(M, NU+4)*BXL(M, NU+4,-NU+3)
     &        - EIK(M, NU+4)*EJL(M,-NU+3)*BXU(M, NU+4,-NU+3)
C
C         FILL RM ARRAYS FOR THIS LQNA,LQNB BLOCK
C
C         KQNA < 0 AND KQNB < 0 CONTRIBUTIONS (CANNOT SKIP)
          RMSL = V4*T0000*E1001*C7*B43

          RMSLLS(M,1) = RMSLLS(M,1) + GSL(LTEN,1)*RMSL
C
C         KQNA < 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNB.EQ.0) GOTO 302
          RMSL = V4*T0000*E1001*C7*B43 - V2*T0001*E1000*C5*B23
C
          RMSLLS(M,2) = RMSLLS(M,2) + GSL(LTEN,2)*RMSL
302       CONTINUE
C
C         KQNA > 0 AND KQNB < 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0) GOTO 303
          RMSL = V4*T0000*E1001*C7*B43 - V2*T1000*E0001*C5*B41
C
          RMSLLS(M,3) = RMSLLS(M,3) + GSL(LTEN,3)*RMSL
303       CONTINUE
C
C         KQNA > 0 AND KQNB > 0 CONTRIBUTIONS (SKIP IF POSSIBLE)
          IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 304
          RMSL = V4*T0000*E1001*C7*B43 - V2*T1000*E0001*C5*B41
     &         - V2*T0001*E1000*C5*B23 + V1*T1001*E0000*C3*B21
C
          RMSLLS(M,4) = RMSLLS(M,4) + GSL(LTEN,4)*RMSL
304       CONTINUE
C
        ENDDO
C
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      DO M=1,MAXM
        RNLLSS = RNIJ(1)*RNKL(M,3)
        RNSSLL = RNIJ(3)*RNKL(M,1)
        T0SLLS = RNIJ(2)*RNKL(M,4)
        DO N=1,4
          RKLLSS(M,N) = RNLLSS*RKLLSS(M,N)
          RKSSLL(M,N) = RNSSLL*RKSSLL(M,N)
          RKSLLS(M,N) = T0SLLS*RKSLLS(M,N)
          RMSLLS(M,N) = T0SLLS*RMSLLS(M,N)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ANGBRT0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        AA    NN    NN  GGGGGG  BBBBBBB  RRRRRRR TTTTTTTT 000000      C
C       AAAA   NNN   NN GG    GG BB    BB RR    RR   TT   00   000     C
C      AA  AA  NNNN  NN GG       BB    BB RR    RR   TT   00  0000     C
C     AA    AA NN NN NN GG       BBBBBBB  RR    RR   TT   00 00 00     C
C     AAAAAAAA NN  NNNN GG   GGG BB    BB RRRRRRR    TT   0000  00     C
C     AA    AA NN   NNN GG    GG BB    BB RR    RR   TT   000   00     C
C     AA    AA NN    NN  GGGGGG  BBBBBBB  RR    RR   TT    000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGBRT0 EVALUATES ANGULAR COEFFICIENTS OF THE ATOMIC CLOSED SHELL   C
C  BREIT INTERACTION FOR ALL (K1,K2) VALUES IN THE MANIFOLD (L1,L2).   C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    NUNUM - NUMBER OF NU VALUES THAT SATISFY PARITY RESTRICTION RULE. C
C    NUI - MINIMUM NU VALUE IN THIS MANIFOLD.                          C
C    NUF - MAXIMUM NU VALUE IN THIS MANIFOLD.                          C
C    ELL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;LL) TERMS    C
C    ESS(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SS) TERMS    C
C    ESL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SL) TERMS    C
C    GSL(MNU,4) - ANGULAR TERMS FOR CLOSED BREIT EK(JA,JB;SL) TERMS    C
C**********************************************************************C
      PARAMETER(MBS=26,MKP=9,MNU=MKP+1)
C
      DIMENSION SCOEF(4,2)
C
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/TANG/BK(MNU,4),ELL(MNU,4),ESS(MNU,4),ESL(MNU,4),GSL(MNU,4)
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     INITIALISE COEFFICIENT ARRAYS
      DO LTEN=1,MNU
        DO N=1,4
          ELL(LTEN,N) = 0.0D0
          ESS(LTEN,N) = 0.0D0
          ESL(LTEN,N) = 0.0D0
          GSL(LTEN,N) = 0.0D0
        ENDDO
        NUS(LTEN) = 0
      ENDDO
      NUNUM = 0
C
      NUI = IABS(LQNA-LQNB  )
      NUF = IABS(LQNA+LQNB+1)
C
C     SPECIFY ALLOWED NU VALUES
      NUNUM = 0
      DO NU=NUI-1,NUF
        IF(NU.GE.0.AND.MOD(LQNA+LQNB+NU,2).EQ.1) THEN
          NUNUM = NUNUM+1
          NUS(NUNUM) = NU
        ENDIF
      ENDDO
C
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C**********************************************************************C
C     (1) KQNA < 0 AND KQNB < 0   (CANNOT SKIP)                        C
C**********************************************************************C
C
C     KQNA AND KQNB
      KQNA =-LQNA-1
      KQNB =-LQNB-1
C
C     JQNA AND JQNB
      JQNA = 2*IABS(KQNA)-1
      JQNB = 2*IABS(KQNB)-1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       SKIP IF THIS VALUE OF NU EXCEEDS TRIANGLE RULE FOR KQN BLOCK
        IF(NU.GT.(JQNA+JQNB)/2) GOTO 101
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JQNA,JQNB,NU)
C
C       DETERMINE PARITY OF COMBINATION LQNA,LQNB,NU
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPAR = 1
        ELSE
          IPAR = 0
        ENDIF
C
        IF(IPAR.EQ.0.AND.NU.NE.0) THEN
C       CASE 1: ANGULAR COEFFICIENTS OF ODD PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          RNU  = DFLOAT(NU*(NU+1))
          COEF = DFLOAT((KQNA+KQNB)*(KQNA+KQNB))/RNU
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,1) = ELL(LTEN,1) + COEF*RAW
          ESS(LTEN,1) = ESS(LTEN,1) + COEF*RAW
          ESL(LTEN,1) = ESL(LTEN,1) + COEF*RAW
C
        ELSEIF(IPAR.EQ.1) THEN
C       CASE 2: ANGULAR COEFFICIENTS OF EVEN-PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEF,KQNA,KQNB,NU)
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,1) = ELL(LTEN,1) + SCOEF(1,1)*RAW
          ESL(LTEN,1) = ESL(LTEN,1) + SCOEF(2,1)*RAW
          ESS(LTEN,1) = ESS(LTEN,1) + SCOEF(3,1)*RAW
          GSL(LTEN,1) = GSL(LTEN,1) + SCOEF(4,1)*RAW
C
C         STEP PARAMETER FOR ADDITIONS TO COEFFICIENTS
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,1) = ELL(LTEN,1) + SCOEF(1,2)*RAW
          ESL(LTEN,1) = ESL(LTEN,1) + SCOEF(2,2)*RAW
          ESS(LTEN,1) = ESS(LTEN,1) + SCOEF(3,2)*RAW
          GSL(LTEN,1) = GSL(LTEN,1) + SCOEF(4,2)*RAW
C
        ENDIF
C
101     CONTINUE
C
      ENDDO
C
C     ADJUST NUNUM IF NECESSARY
      NUI   = MIN(NUI,NUS(1))
      NUF   = MAX(NUF,NUS(LTEN))
      NUNUM = MAX(LTEN,NUNUM)
C
C     APPROPRIATE NUI GIVEN ODD SELECTION RULE
      NUI = MOD(LQNA+LQNB+1,2)
C
C**********************************************************************C
C     (2) KQNA < 0 AND KQNB > 0   (SKIP IF POSSIBLE)                   C
C**********************************************************************C
C
      IF(LQNB.EQ.0) GOTO 200
C
C     KQNA AND KQNB
      KQNA =-LQNA-1
      KQNB = LQNB
C
C     JQNA AND JQNB
      JQNA = 2*IABS(KQNA)-1
      JQNB = 2*IABS(KQNB)-1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       SKIP IF THIS VALUE OF NU EXCEEDS TRIANGLE RULE FOR KQN BLOCK
        IF(NU.GT.(JQNA+JQNB)/2) GOTO 201
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JQNA,JQNB,NU)
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPAR = 1
        ELSE
          IPAR = 0
        ENDIF
C
        IF(IPAR.EQ.0.AND.NU.NE.0) THEN
C       CASE 1: ANGULAR COEFFICIENTS OF ODD PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          RNU  = DFLOAT(NU*(NU+1))
          COEF = DFLOAT((KQNA+KQNB)*(KQNA+KQNB))/RNU
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,2) = ELL(LTEN,2) + COEF*RAW
          ESS(LTEN,2) = ESS(LTEN,2) + COEF*RAW
          ESL(LTEN,2) = ESL(LTEN,2) + COEF*RAW
C
        ELSEIF(IPAR.EQ.1) THEN
C       CASE 2: ANGULAR COEFFICIENTS OF EVEN-PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEF,KQNA,KQNB,NU)
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,2) = ELL(LTEN,2) + SCOEF(1,1)*RAW
          ESL(LTEN,2) = ESL(LTEN,2) + SCOEF(2,1)*RAW
          ESS(LTEN,2) = ESS(LTEN,2) + SCOEF(3,1)*RAW
          GSL(LTEN,2) = GSL(LTEN,2) + SCOEF(4,1)*RAW
C
C         STEP PARAMETER FOR ADDITIONS TO COEFFICIENTS
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,2) = ELL(LTEN,2) + SCOEF(1,2)*RAW
          ESL(LTEN,2) = ESL(LTEN,2) + SCOEF(2,2)*RAW
          ESS(LTEN,2) = ESS(LTEN,2) + SCOEF(3,2)*RAW
          GSL(LTEN,2) = GSL(LTEN,2) + SCOEF(4,2)*RAW
C
        ENDIF
C
201     CONTINUE
C
      ENDDO
C
C     ADJUST NUNUM IF NECESSARY
      NUI   = MIN(NUI,NUS(1))
      NUF   = MAX(NUF,NUS(LTEN))
      NUNUM = MAX(LTEN,NUNUM)
C
200   CONTINUE
C
C**********************************************************************C
C     (3) KQNA > 0 AND KQNB < 0   (SKIP IF POSSIBLE)                   C
C**********************************************************************C
C
      IF(LQNA.EQ.0) GOTO 300
C
C     KQNA AND KQNB
      KQNA = LQNA
      KQNB =-LQNB-1
C
C     JQNA AND JQNB
      JQNA = 2*IABS(KQNA)-1
      JQNB = 2*IABS(KQNB)-1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       SKIP IF THIS VALUE OF NU EXCEEDS TRIANGLE RULE FOR KQN BLOCK
        IF(NU.GT.(JQNA+JQNB)/2) GOTO 301
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JQNA,JQNB,NU)
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPAR = 1
        ELSE
          IPAR = 0
        ENDIF
C
        IF(IPAR.EQ.0.AND.NU.NE.0) THEN
C       CASE 1: ANGULAR COEFFICIENTS OF ODD PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          RNU  = DFLOAT(NU*(NU+1))
          COEF = DFLOAT((KQNA+KQNB)*(KQNA+KQNB))/RNU
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,3) = ELL(LTEN,3) + COEF*RAW
          ESS(LTEN,3) = ESS(LTEN,3) + COEF*RAW
          ESL(LTEN,3) = ESL(LTEN,3) + COEF*RAW
C
        ELSEIF(IPAR.EQ.1) THEN
C       CASE 2: ANGULAR COEFFICIENTS OF EVEN-PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEF,KQNA,KQNB,NU)
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,3) = ELL(LTEN,3) + SCOEF(1,1)*RAW
          ESL(LTEN,3) = ESL(LTEN,3) + SCOEF(2,1)*RAW
          ESS(LTEN,3) = ESS(LTEN,3) + SCOEF(3,1)*RAW
          GSL(LTEN,3) = GSL(LTEN,3) + SCOEF(4,1)*RAW
C
C         STEP PARAMETER FOR ADDITIONS TO COEFFICIENTS
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,3) = ELL(LTEN,3) + SCOEF(1,2)*RAW
          ESL(LTEN,3) = ESL(LTEN,3) + SCOEF(2,2)*RAW
          ESS(LTEN,3) = ESS(LTEN,3) + SCOEF(3,2)*RAW
          GSL(LTEN,3) = GSL(LTEN,3) + SCOEF(4,2)*RAW
C
        ENDIF
C
301     CONTINUE
C
      ENDDO
C
C     ADJUST NUNUM IF NECESSARY
      NUI   = MIN(NUI,NUS(1))
      NUF   = MAX(NUF,NUS(LTEN))
      NUNUM = MAX(LTEN,NUNUM)
C
300   CONTINUE
C
C**********************************************************************C
C     (4) KQNA > 0 AND KQNB > 0   (SKIP IF POSSIBLE)                   C
C**********************************************************************C
C
      IF(LQNA.EQ.0.OR.LQNB.EQ.0) GOTO 400
C
C     KQNA AND KQNB
      KQNA = LQNA
      KQNB = LQNB
C
C     JQNA AND JQNB
      JQNA = 2*IABS(KQNA)-1
      JQNB = 2*IABS(KQNB)-1
C
C     LOOP OVER ALL NU VALUES WITHIN TRIANGLE RULE
      LTEN = 1
      DO NU=NUI,NUF
C
C       SKIP IF THIS VALUE OF NU EXCEEDS TRIANGLE RULE FOR KQN BLOCK
        IF(NU.GT.(JQNA+JQNB)/2) GOTO 401
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JQNA,JQNB,NU)
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQNA+LQNB+NU,2).EQ.0) THEN
          IPAR = 1
        ELSE
          IPAR = 0
        ENDIF
C
        IF(IPAR.EQ.0.AND.NU.NE.0) THEN
C       CASE 1: ANGULAR COEFFICIENTS OF ODD PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          RNU  = DFLOAT(NU*(NU+1))
          COEF = DFLOAT((KQNA+KQNB)*(KQNA+KQNB))/RNU
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,4) = ELL(LTEN,4) + COEF*RAW
          ESS(LTEN,4) = ESS(LTEN,4) + COEF*RAW
          ESL(LTEN,4) = ESL(LTEN,4) + COEF*RAW
C
        ELSEIF(IPAR.EQ.1) THEN
C       CASE 2: ANGULAR COEFFICIENTS OF EVEN-PARITY
C
C         CALCULATE INTERMEDIATE COEFFICIENTS
          CALL BRCOEF0(SCOEF,KQNA,KQNB,NU)
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,4) = ELL(LTEN,4) + SCOEF(1,1)*RAW
          ESL(LTEN,4) = ESL(LTEN,4) + SCOEF(2,1)*RAW
          ESS(LTEN,4) = ESS(LTEN,4) + SCOEF(3,1)*RAW
          GSL(LTEN,4) = GSL(LTEN,4) + SCOEF(4,1)*RAW
C
C         STEP PARAMETER FOR ADDITIONS TO COEFFICIENTS
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU+1
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN,4) = ELL(LTEN,4) + SCOEF(1,2)*RAW
          ESL(LTEN,4) = ESL(LTEN,4) + SCOEF(2,2)*RAW
          ESS(LTEN,4) = ESS(LTEN,4) + SCOEF(3,2)*RAW
          GSL(LTEN,4) = GSL(LTEN,4) + SCOEF(4,2)*RAW
C
        ENDIF
C
401     CONTINUE
C
      ENDDO
C
C     ADJUST NUNUM IF NECESSARY
      NUI   = MIN(NUI,NUS(1))
      NUF   = MAX(NUF,NUS(LTEN))
      NUNUM = MAX(LTEN,NUNUM)
C
400   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE BRCOEF0(SCOEFF,KQNA,KQNB,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB  RRRRRRR   CCCCCC   OOOOOO  EEEEEEEE FFFFFFFF 000000      C
C    BB    BB RR    RR CC    CC OO    OO EE       FF      00   000     C
C    BB    BB RR    RR CC       OO    OO EE       FF      00  0000     C
C    BBBBBBB  RR    RR CC       OO    OO EEEEEE   FFFFFF  00 00 00     C
C    BB    BB RRRRRRR  CC       OO    OO EE       FF      0000  00     C
C    BB    BB RR    RR CC    CC OO    OO EE       FF      000   00     C
C    BBBBBBB  RR    RR  CCCCCC   OOOOOO  EEEEEEEE FF       000000      C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRCOEF0 EVALUATES THE INTERMEDIATE COEFFICIENTS OF THE BREIT        C
C  INTERACTION FOR CLOSED SHELLS (TABLE 3 OF GRANT AND PYPER 1976).    C
C**********************************************************************C
      DIMENSION SCOEFF(4,2)
C
      RU  = DFLOAT(NU)
      RK  = DFLOAT(KQNB-KQNA)
C
      IF(NU.GT.0) THEN
        RM = RU-1.0D0
        B1 = (RM+2.0D0)/(2.0D0*   (2.0D0*RM+1.0D0))
        C1 =-(RM-1.0D0)/(2.0D0*RU*(2.0D0*RM+1.0D0))
        SCOEFF(1,1) = (RK+RU)*(C1*RK+B1)
        SCOEFF(2,1) = -B1*RU + C1*RK*RK
        SCOEFF(3,1) = (RK-RU)*(C1*RK-B1)
        SCOEFF(4,1) =  RK    *(C1*RU-B1)
      ELSE
        SCOEFF(1,1) = 0.0D0
        SCOEFF(2,1) = 0.0D0
        SCOEFF(3,1) = 0.0D0
        SCOEFF(4,1) = 0.0D0
      ENDIF
      IF(NU+1.GT.1) THEN
        RP = RU+1.0D0
        B2 = (RP-1.0D0)/(2.0D0*   (2.0D0*RP+1.0D0))
        C2 = (RP+2.0D0)/(2.0D0*RP*(2.0D0*RP+1.0D0))
        SCOEFF(1,2) = (RK-RP)*(C2*RK+B2)
        SCOEFF(2,2) =  B2*RP + C2*RK*RK 
        SCOEFF(3,2) = (RK+RP)*(C2*RK-B2)
        SCOEFF(4,2) =  RK    *(C2*RP+B2)
      ELSE
        SCOEFF(1,2) = 0.0D0
        SCOEFF(2,2) = 0.0D0
        SCOEFF(3,2) = 0.0D0
        SCOEFF(4,2) = 0.0D0
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE IJSET0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           IIII     JJJJ SSSSSS  EEEEEEEE TTTTTTTT 000000             C
C            II       JJ SS    SS EE          TT   00   000            C
C            II       JJ SS       EE          TT   00  0000            C
C            II       JJ  SSSSSS  EEEEEE      TT   00 00 00            C
C            II       JJ       SS EE          TT   0000  00            C
C            II JJ    JJ SS    SS EE          TT   000   00            C
C           IIII JJJJJJ   SSSSSS  EEEEEEEE    TT    000000             C
C                                                                      C
C -------------------------------------------------------------------- C
C  IJSET0 GENERATES BASIS SET INTERMEDIATES FOR IJ-PAIRS TO BE USED    C
C  IN THE CONSTRUCTION OF ATOMIC TWO-ELECTRON INTEGRALS.               C
C**********************************************************************C
      PARAMETER(MBS=26,MKP=9,MNU=MKP+1,MAB=2*MNU+6)
C
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
C
      DATA TWOLOG/6.93147180559945309D-1/
C
C     NORMALISATION CONSTANTS FOR EXPONENTS EI AND EJ
      RL = DFLOAT(LQNA)
      G1 = TWOLOG-GAMLOG(2*LQNA+3)
      G2 = TWOLOG-GAMLOG(2*LQNA+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
C
      ELOG = DLOG(2.0D0*EI)
      RNLI = DEXP(0.5D0*(G1+R1*ELOG))
      RNSI = DEXP(0.5D0*(G2+R2*ELOG))
C
      ELOG = DLOG(2.0D0*EJ)
      RNLJ = DEXP(0.5D0*(G1+R1*ELOG))
      RNSJ = DEXP(0.5D0*(G2+R2*ELOG))
C
C     NORMALISATION PAIRS
      RNIJ(1) = RNLI*RNLJ
      RNIJ(2) = RNSI*RNLJ
      RNIJ(3) = RNSI*RNSJ
      RNIJ(4) = RNLI*RNSJ
C
C     POWERS OF THE EXPONENT SUM
      EIJ0 = EI+EJ
      EIJR = DSQRT(EIJ0)
      EIJA = EIJ0**(-LQNA)
      DO N=0,5
        EIJ(N) = EIJA
        EIJA   = EIJA/EIJR
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE KLSET0
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         KK    KK LL       SSSSSS  EEEEEEEE TTTTTTTT 000000           C
C         KK   KK  LL      SS    SS EE          TT   00   000          C
C         KK  KK   LL      SS       EE          TT   00  0000          C
C         KKKKK    LL       SSSSSS  EEEEEE      TT   00 00 00          C
C         KK  KK   LL            SS EE          TT   0000  00          C
C         KK   KK  LL      SS    SS EE          TT   000   00          C
C         KK    KK LLLLLLLL SSSSSS  EEEEEEEE    TT    000000           C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLSET0 GENERATES BASIS SET INTERMEDIATES FOR KL-PAIRS TO BE USED    C
C  IN THE CONSTRUCTION OF ATOMIC TWO-ELECTRON INTEGRALS.               C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+6)
C
      COMMON/BIKS/EIK(MB2,-MAB:MAB),IKIND(MB2)
      COMMON/BJLS/EJL(MB2,-MAB:MAB),JLIND(MB2)
      COMMON/BKLS/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/BQNA/EXLA(MBS),EXLB(MBS),NBASA,NBASB,LQNA,LQNB,MAXM
C
C     GENERATE INDICES AND EXPONENT COMBINATIONS
      M = 0
      DO KBAS=1,NBASB
        EK0 = EXLB(KBAS)
        DO LBAS=1, NBASB
          M   = M+1
          EL0 = EXLB(LBAS)
          IKIND(M) = KBAS
          JLIND(M) = LBAS
          EK(M)    = EK0
          EL(M)    = EL0
          EKL0     = EK0+EL0
          EKLR     = DSQRT(EKL0)
          EKPW     = EKL0**LQNB
          EKLA     = 1.0D0/EKPW
          DO N=0,5
            EKL(M,N) = EKLA
            EKLA     = EKLA/EKLR
          ENDDO
        ENDDO
      ENDDO
C
C     NORMALISATION CONSTANTS
      CALL RNORM0(RNKL,EXLB,NBASB,LQNB)
C
      RETURN
      END
C
C
      SUBROUTINE RNORM0(RN,EXL,NBAS,LQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       RRRRRRR  NN    NN  OOOOOO  RRRRRRR  MM       MM  000000        C
C       RR    RR NNN   NN OO    OO RR    RR MMM     MMM 00   000       C
C       RR    RR NNNN  NN OO    OO RR    RR MMMM   MMMM 00  0000       C
C       RR    RR NN NN NN OO    OO RR    RR MM MM MM MM 00 00 00       C
C       RRRRRRR  NN  NNNN OO    OO RRRRRRR  MM  MMM  MM 0000  00       C
C       RR    RR NN   NNN OO    OO RR    RR MM   M   MM 000   00       C
C       RR    RR NN    NN  OOOOOO  RR    RR MM       MM  000000        C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNORM0 EVALUATES NORMALISATION CONSTANTS OF ALL VARIETIES.          C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS)
C
      DIMENSION RN(MB2,4),EXL(MBS),RNL(MBS),RNS(MBS)
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
C
      DATA TWOLOG/6.93147180559945309D-1/
C
      RL = DFLOAT(LQN)
      G1 = TWOLOG-GAMLOG(2*LQN+3)
      G2 = TWOLOG-GAMLOG(2*LQN+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO IBAS=1,NBAS
        ELOG      = DLOG(2.0D0*EXL(IBAS))
        RNL(IBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNS(IBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     RN(M,1) ARE THE LL NORMALISATION CONSTANTS
C     RN(M,2) ARE THE SL NORMALISATION CONSTANTS
C     RN(M,3) ARE THE SS NORMALISATION CONSTANTS
C     RN(M,4) ARE THE LS NORMALISATION CONSTANTS
C
      M = 0
      DO IBAS=1,NBAS
        DO JBAS=1,NBAS
          M = M+1
          RN(M,1) = RNL(IBAS)*RNL(JBAS)
          RN(M,2) = RNS(IBAS)*RNL(JBAS)
          RN(M,3) = RNS(IBAS)*RNS(JBAS)
          RN(M,4) = RNL(IBAS)*RNS(JBAS)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE GAMGEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        GGGGGG     AA    MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C       GG    GG   AAAA   MMM     MMM GG    GG EE       NNN   NN       C
C       GG        AA  AA  MMMM   MMMM GG       EE       NNNN  NN       C
C       GG       AA    AA MM MM MM MM GG       EEEEEE   NN NN NN       C
C       GG   GGG AAAAAAAA MM  MMM  MM GG   GGG EE       NN  NNNN       C
C       GG    GG AA    AA MM   M   MM GG    GG EE       NN   NNN       C
C        GGGGGG  AA    AA MM       MM  GGGGGG  EEEEEEEE NN    NN       C
C                                                                      C
C -------------------------------------------------------------------- C
C  GAMGEN EVALUATES INTEGER/HALF-INTEGER GAMMA VALUES AND THEIR LOGS.  C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    GAMLOG(N) = DLOG(GAMMA(N/2))                                      C
C    GAMHLF(N) = GAMMA(N/2)                                            C
C**********************************************************************C
C
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
C
      DATA ROOTPI,RTPILG/1.7724538509055160D0,5.7236494292470009D-1/
C
C     STARTING VALUES
      GAMLOG(1) = RTPILG
      GAMLOG(2) = 0.0D0
      GAMHLF(1) = ROOTPI
      GAMHLF(2) = 1.0D0
C
C     SEED VALUES FOR INCREMENT
      F1 = 0.5D0
      F2 = 1.0D0
C
C     FILL TABLE VALUES
      DO N=4,50,2
        GAMLOG(N-1) = GAMLOG(N-3)+DLOG(F1)
        GAMLOG(N  ) = GAMLOG(N-2)+DLOG(F2)
        GAMHLF(N-1) = GAMHLF(N-3)*F1
        GAMHLF(N  ) = GAMHLF(N-2)*F2
        F1 = F1+1.0D0
        F2 = F2+1.0D0
      ENDDO
C
      RETURN
      END
C
C
       SUBROUTINE FACTRLS
       IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     FFFFFFFF   AA     CCCCCC TTTTTTTT RRRRRRR  LL       SSSSSS       C
C     FF        AAAA   CC    CC   TT    RR    RR LL      SS    SS      C
C     FF       AA  AA  CC         TT    RR    RR LL      SS            C
C     FFFFFF  AA    AA CC         TT    RR    RR LL       SSSSSS       C
C     FF      AAAAAAAA CC         TT    RRRRRRR  LL            SS      C
C     FF      AA    AA CC    CC   TT    RR    RR LL      SS    SS      C
C     FF      AA    AA  CCCCCC    TT    RR    RR LLLLLLLL SSSSSS       C
C                                                                      C
C -------------------------------------------------------------------- C
C  FACTRLS GENERATES A SET OF N! AND N!! AS REAL NUMBERS.              C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    RFACT - REGULAR FACTORIALS, RFACT(N) = N!                         C
C    SFACT - SEMI-FACTORIALS,    SFACT(N) = N!!                        C
C**********************************************************************C
C
      COMMON/FCTS/RFACT(0:20),SFACT(0:20)
C
      RFACT(0) = 1.0D0
      RFACT(1) = 1.0D0
      SFACT(0) = 1.0D0
      SFACT(1) = 1.0D0
      DO I=2,20
        RNUMBER  = DFLOAT(I)
        RFACT(I) = RNUMBER*RFACT(I-1)
        SFACT(I) = RNUMBER*SFACT(I-2)
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [5] MOLECULAR HARTREE-FOCK: MANY-CENTRE SCF CALCULATIONS.          C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] HFSCF: MAIN ROUTINE FOR MOLECULAR HARTREE-FOCK SCF PROCEDURE.  C
C   [B] OVRLP: CONSTRUCTS THE ONE-ELECTRON OVERLAP MATRIX.             C
C   [C] ONEEL: ONE-ELECTRON MULTI-CENTRE MATRIX OF INTEGRALS.          C
C   [D] UEHLING: CONSTRUCTS MULTI-CENTRE UEHLING MATRIX ELEMENTS.      C
C   [E] COULOMB: CONSTRUCTS ALL MULTI-CENTRE COULOMB SCF ELEMENTS.     C
C   [F] ERI: GENERATES A BLOCK OF ELECTRON REPULSION INTEGRALS.        C
C   [G] CLMMAT: MULTIPLIES BATCH FROM RR BY DENSITIES, ADDS TO GMAT.   C
C   [H] BREIT: MATRIX REP OF MEAN-FIELD BREIT INTERACTION.             C
C   [I] BII: GENERATES A BLOCK OF BREIT INTERACTION INTEGRALS.         C
C   [J] BRTMAT: MULTIPLIES BATCH FROM RR BY DENSITIES, ADDS TO BMAT.   C
C   [K] COUPLE: ESTABLISH OPEN/CLOSED SHELL COUPLING BETWEEN ARRAYS.   C
C   [L] SPARSITY: SEARCHES FOR VANISHING MATRIX ELEMTNS IN A MATRIX.   C
C   [M] NCART: RETURNS THE CARTESIAN INDEX FROM A LOOP INDEX.          C
C   [N] NCNTRS: RETURNS NUMBER OF UNIQUE NUCLEAR CENTRES FROM INPUT.   C
C   [O] ZPROJ: RETURNS A METRIC FOR Z-AXIS DEVIATION OF SOME BXYZS.   C
C**********************************************************************CC
C
C
      SUBROUTINE HFSCF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              HH    HH FFFFFFFF SSSSSS   CCCCCC  FFFFFFFF             C
C              HH    HH FF      SS    SS CC    CC FF                   C
C              HH    HH FF      SS       CC       FF                   C
C              HHHHHHHH FFFFFF   SSSSSS  CC       FFFFFF               C
C              HH    HH FF            SS CC       FF                   C
C              HH    HH FF      SS    SS CC    CC FF                   C
C              HH    HH FF       SSSSSS   CCCCCC  FF                   C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  HFSCF PERFORMS A SINGLE-DETERMINANT ITERATIVE SELF-CONSISTENT FIELD C
C  PROCEDURE OVER THE USER-SPECIFIED HAMILTONIAN.                      C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9,LWK=64*MDM,MIT=200)
C
      CHARACTER*4  HMLT
      CHARACTER*11 MS
      CHARACTER*16 HMS
      CHARACTER*20 STAMP
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 TESTER,title
C
      DIMENSION RWORK(3*MDM),ESAV(0:MIT),DNRM(MIT),WEDN(MIT)
      DIMENSION NMLEV(4),TMLEV(4)
      DIMENSION ARRAY(MDM,MDM)
      DIMENSION BMAT(MDM,MDM)
C
      COMPLEX*16 WORK(LWK)
      COMPLEX*16 DTMP(MDM,MDM),OTMP(MDM,MDM),COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/ENRG/ETOT,ENUC,EONE,ECLG,ECLQ,EBRG,EBRQ,EHNC,EHKN,EGDR,
     &            EGXC,EQDR,EQXC,EBDR,EBXC,EMDR,EMXC,EUEH
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/LSHF/SHLEV(3),SHLV
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',23),'MOLECULAR HARTREE-FOCK SCF'
      WRITE(7, *) REPEAT(' ',23),'MOLECULAR HARTREE-FOCK SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME AT START OF MOLECULAR SCF CALCULATION
      CALL CPU_TIME(TSCF1)
C
C     PARAMETERS FOR COMPLETING STAGES
      ENRGLV1 = 1.0D-08
      ENRGLV2 = 5.0D-11
      ENRGTOL = 1.0D-12
      DSTYTOL = 1.0D-10
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
      CALL FACTRLS
C
C     INITIALISE ENERGY NORM STORAGE
      IF(INEW.EQ.0) THEN
        ESAV(0) = ETOT
      ELSE
        ESAV(0) = 1.0D0
      ENDIF
C
C     INITIALISE INTEGRAL INCLUSION LEVEL VALUES
      DO N=1,4
        NMLEV(N) = 0
        TMLEV(N) = 0.0D0
      ENDDO
C
C     INITIALISE ARRAYS AND TEMPORARY DENSITY MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          OVAP(I,J) = DCMPLX(0.0D0,0.0D0)
          HNUC(I,J) = DCMPLX(0.0D0,0.0D0)
          HKIN(I,J) = DCMPLX(0.0D0,0.0D0)
          VUEH(I,J) = DCMPLX(0.0D0,0.0D0)
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          FOCK(I,J) = DCMPLX(0.0D0,0.0D0)
          DTMP(I,J) = DENT(I,J)
        ENDDO
      ENDDO
C
C     IF READING IN PREVIOUS SOLUTION, CALCULATE MOLECULAR DENSITY
      IF(INEW.EQ.1) THEN
        CALL DENSTY
      ENDIF
C
C     SWITCH OFF SINGLE-CENTRE BREIT INTEGRALS
      ISWITCH = 0
C
C     CALCULATE THE FULL SET OF EQ-COEFFICIENTS
c     dfnote: breit1fix so comment out
      CALL CPU_TIME(T1)
      IF(IEQS.EQ.1) THEN
        CALL EQFILE
      ENDIF
      CALL CPU_TIME(T2)
      TEPP = T2-T1
C
C     MASTER SCREENING TOGGLE
      ISWZ = 0
C
C     GENERATE DIAGONAL TWO-ELECTRON INTEGRALS FOR SCREENING LATER
      CALL CPU_TIME(T1)
      IF(NOELEC.GT.1.AND.ISWZ.NE.0) THEN
        IF(HMLT.NE.'BARE') THEN
          CALL SELFCLM
          IF(HMLT.NE.'NORL'.AND.HMLT.NE.'DHFR') THEN
            CALL SELFBRT
          ENDIF
        ENDIF
      ENDIF
      CALL CPU_TIME(T2)
      TSCR = TSCR+T2-T1
C
C     DFNOTE: BREIT1 FIX - SKIP OPTION FOR ATOMS UNDER DHFP HAMILTONIAN
      IF(IMOL.EQ.0.AND.HMLT.EQ.'DHFP') GOTO 998
C
C     PRINT THE FIRST INTEGRAL INCLUSION LEVEL
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      IF(ILEV.EQ.1) THEN
        WRITE(6,40)
        WRITE(7,40)
      ELSEIF(ILEV.EQ.2) THEN
        IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
          WRITE(6,41)
          WRITE(7,41)
        ELSE
          WRITE(6,42)
          WRITE(7,42)
        ENDIF
      ELSEIF(ILEV.EQ.3) THEN
        WRITE(6,43)
        WRITE(7,43)
      ENDIF
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C**********************************************************************C
C     START OF SELF-CONSISTENT FIELD CALCULATIONS                      C
C**********************************************************************C
C
C     LOOP OVER SCF ITERATIONS
      DO ITER=1,MIT
C
C       TIME AT START OF ITERATION
        CALL CPU_TIME(TMIT)
C
C       CALCULATE OVERLAP, KINETIC AND NUCLEAR POTENTIAL ELEMENTS
        CALL CPU_TIME(T1)
        IF(ITER.EQ.1) THEN
          CALL OVRLP
          CALL ONEEL
        ENDIF
        CALL CPU_TIME(T2)
        T1EL = T2-T1
        THMX = THMX+T1EL
C
C       CALCULATE UEHLING POTENTIAL ELEMENTS
        CALL CPU_TIME(T1)
        IF(HMLT.EQ.'DHFQ') THEN
          IF(ITER.EQ.1) THEN
            CALL UEHLING
          ENDIF
        ENDIF
        CALL CPU_TIME(T2)
        T1EL = T1EL+T2-T1
        TQMX = TQMX+T2-T1
C
C       ADDITIONAL INTERACTIONS IN THE VARIATIONAL PROBLEM
C       DFNOTE: BUILD THIS OPTION INTO INPUT FILES MAYBE?
        IF(HMLT.EQ.'XTRA') THEN
          IF(ITER.EQ.1) THEN
C
C           EITHER MAKE A ROUTINE THAT GENERATES THE MATRIX OR
C           DO IT BY COMPONENT TYPES.
C
          ENDIF
        ENDIF
C
C       RESET TWO-ELECTRON INTEGRAL SCREENING COUNTERS
        DO MCNT=1,5
          DO ITT=1,6
            N2EB(MCNT,ITT) = 0
            N2EI(MCNT,ITT) = 0
            N2ES(MCNT,ITT) = 0
            T2ES(MCNT,ITT) = 0.0D0
          ENDDO
        ENDDO
C
C       GENERATE MEAN-FIELD CLOSED- AND OPEN-SHELL COULOMB MATRIX
        IF(HMLT.NE.'BARE'.AND.NOELEC.GT.1) THEN
C
C         BUILD HERMITIAN MATRIX FOR MANY-CENTRE COULOMB CONTRIBUTIONS
          CALL CPU_TIME(T1)
          CALL COULOMB
          CALL CPU_TIME(T2)
          TCL2 = T2-T1
          TC2T = TC2T+TCL2
C
C         ADD ALL ONE-CENTRE COULOMB CONTRIBUTIONS (RACAH ALGEBRA)
          CALL CPU_TIME (T1)
          DO ICNT=1,NCNT
            CALL COULOMB1(ICNT)
          ENDDO
          CALL CPU_TIME(T2)
          TCL1 = T2-T1
          TC1T = TC1T+TCL1
C
        ENDIF
C
C       GENERATE MEAN-FIELD BREIT MATRIX
        IF((HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ').AND.NOELEC.GT.1) THEN
C
C         BUILD HERMITIAN MATRIX FOR MANY-CENTRE BREIT INTEGRALS
          CALL CPU_TIME(T1)
          CALL BREIT(ISWITCH)
          CALL CPU_TIME(T2)
          TBR2 = T2-T1
          TB2T = TB2T+TBR2
C
C         ADD ALL ONE-CENTRE BREIT CONTRIBUTIONS (RACAH ALGEBRA)
          CALL CPU_TIME (T1)
          IF(ISWITCH.EQ.1) THEN
            DO ICNT=1,NCNT
              CALL BREIT1(ICNT)
            ENDDO
          ENDIF
          CALL CPU_TIME(T2)
          TBR1 = T2-T1
          TB1T = TB1T+TBR1
C
        ENDIF
C
C       ADD TWO- AND MANY-CENTRE BINS TO (TT|TT) TOTALS
        DO MCNT=1,4
          DO ITT=1,5
            N2EB(5,ITT) = N2EB(5,ITT) + N2EB(MCNT,ITT)
            N2EI(5,ITT) = N2EI(5,ITT) + N2EI(MCNT,ITT)
            N2ES(5,ITT) = N2ES(5,ITT) + N2ES(MCNT,ITT)
            T2ES(5,ITT) = T2ES(5,ITT) + T2ES(MCNT,ITT)
          ENDDO
        ENDDO
C
C       ADD ALL (TT|TT) RESULTS TO TOTALS
        DO MCNT=1,5
          DO ITT=1,5
            N2EB(MCNT,6) = N2EB(MCNT,6) + N2EB(MCNT,ITT)
            N2EI(MCNT,6) = N2EI(MCNT,6) + N2EI(MCNT,ITT)
            N2ES(MCNT,6) = N2ES(MCNT,6) + N2ES(MCNT,ITT)
            T2ES(MCNT,6) = T2ES(MCNT,6) + T2ES(MCNT,ITT)
          ENDDO
        ENDDO
C
C       FRACTION OF BLOCKS SCREENED
        DO MCNT=1,5
          DO ITT=1,6
            IF(N2EI(MCNT,ITT).NE.0) THEN
              RATIO = DFLOAT(N2ES(MCNT,ITT))/DFLOAT(N2EI(MCNT,ITT))
              F2ES(MCNT,ITT) = 100.0D0*RATIO
            ELSE
              F2ES(MCNT,ITT) = 0.0D0
            ENDIF
          ENDDO
        ENDDO
C
C       ESTABLISH COUPLING BETWEEN CLOSED- AND OPEN-SHELL MATRIX REPS
        IF(HMLT.NE.'BARE') THEN
          IF(NOELEC.GT.1.AND.NOPN.NE.0) THEN
            CALL COUPLE
          ENDIF
        ENDIF
C
C       CONSTRUCT FOCK MATRIX FROM ONE- AND TWO-BODY INTERACTIONS
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = HNUC(I,J) + HKIN(I,J) + GDIR(I,J) - GXCH(I,J)
     &                - QDIR(I,J) + QXCH(I,J) + BDIR(I,J) - BXCH(I,J)
     &                + VUEH(I,J)
          ENDDO
        ENDDO
C
C       UPDATE MOLECULAR ENERGIES (BASED ON *PREVIOUS* DENSITY D^{N-1})
        CALL ENERGIES
C
C       START TIMER ON MATRIX DIAGONALISATION PROCEDURE
        CALL CPU_TIME(T1)
C
C       IMPLEMENT SPARSITY CHECK ON FOCK MATRIX
        CALL SPARSITY(FOCK,NDIM,1.0D-10)
C
C       LEVEL-SHIFT THE VIRTUAL SPACE TO MAKE ORBITALS LESS ACCESSIBLE
        IF(INEW.NE.0.OR.ITER.NE.1) THEN
          CALL LEVSHFT(SHLV)
        ENDIF
        NMLEV(ILEV) = NMLEV(ILEV)+1
C
C       SAVE OVERLAP MATRIX IN TEMPORARY MATRIX (ZHEGV OVERWRITES IT)
        DO I=1,NDIM
          DO J=1,NDIM
            OTMP(I,J) = OVAP(I,J)
          ENDDO
        ENDDO
C
C       DIAGONALISE FOCK MATRIX (REQUIRES LAPACK LIBRARY)
        CALL ZHEGV(1,'V','L',NDIM,FOCK,MDM,OVAP,MDM,
     &                                        EIGN,WORK,LWK,RWORK,INFO)
        IF(INFO.NE.0) THEN
          WRITE(6, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INFO
          WRITE(7, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INFO
        ENDIF
C
C       TRANSFER EIGENVECTORS TO THE C ARRAY AND RESTORE OVAP ARRAY
        DO J=1,NDIM
          DO I=1,NDIM
            COEF(I,J) = FOCK(I,J)
            OVAP(I,J) = OTMP(I,J)
          ENDDO
        ENDDO
C
C       DEDUCT LEVEL SHIFT VALUE FROM VIRTUAL ORBITAL EIGENVALUES
        IF(ITER.NE.1) THEN
          DO IVIR=NSKP+NOCC+1,NDIM
            EIGN(IVIR) = EIGN(IVIR)-SHLV
          ENDDO
        ENDIF
C
C       WRITE EIGENVECTORS TO OUTPUT FILE
        OPEN(UNIT=8,FILE=TRIM(WFNFL),STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          WRITE(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)
C
C       MATRIX DIAGONALISATION COMPLEX
        CALL CPU_TIME(T2)
        TDGN = T2-T1
        TEIG = TEIG+TDGN
C
C       UPDATE THE DENSITY MATRIX
        CALL DENSTY
C
C       DENSITY DIFFERENCE NORM CALCULATION
        DNRM(ITER) = 0.0D0
        DO J=1,NDIM
          DO I=1,NDIM
            TMP        = ABS(DENT(I,J)-DTMP(I,J))
            DNRM(ITER) = DNRM(ITER)+TMP*TMP
            DTMP(I,J)  = DENT(I,J)
          ENDDO
        ENDDO
        RDM2 = DFLOAT(NDIM*NDIM)
        DNRM(ITER) = DSQRT(DNRM(ITER))/RDM2
C
C       IF DNRM IS SMALL ENOUGH, REDUCE REQUIREMENTS TO ENTER STAGE 3
        IF(DNRM(ITER).LE.1.0D-09) THEN
          ENRGLV2 = 1.0D+02*DNRM(ITER)
        ENDIF
C
C       WEIGHTED ENERGY DIFFERENCE NORM, WEDN
        DOFF = DABS(ETOT)+1.0D0
        WEDN(ITER) = DABS(ESAV(ITER-1)-ETOT)/DOFF
        ESAV(ITER) = ETOT
C
C       UPDATE TIME COUNTERS AT END OF ITERATION
        CALL CPU_TIME(TDON)
        TSTP = TDON-TMIT
        TMLEV(ILEV) = TMLEV(ILEV)+TSTP
C
C       DATE AND TIME AT END OF ITERATION
        CALL TIMENOW(STAMP)
C
C       HEADER FOR ITERATION SUMMARY
20      FORMAT(27X,A,1X,I3)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6,20) 'Iteration number',ITER
        WRITE(7,20) 'Iteration number',ITER
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       PRODUCE SPECTRUM SUMMARY AND INCLUDE FIRST 6 VIRTUAL STATES
        LF = LEN(TRIM(MOLCL))+LEN(TRIM(HMLT))
        LF = 23-LF/2
21      FORMAT(1X,A,'Molecular spectrum for ',A,' (',A,')')
        WRITE(6,21) REPEAT(' ',LF),TRIM(MOLCL),TRIM(HMLT)
        WRITE(7,21) REPEAT(' ',LF),TRIM(MOLCL),TRIM(HMLT)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        CALL SPECTRM(NOCC,6)
C
C       MOLECULAR ENERGIES
22      FORMAT(1X,A,22X,F21.12)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
        WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) 'Source',REPEAT(' ',60),'Energy'
        WRITE(7, *) 'Source',REPEAT(' ',60),'Energy'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,22) 'Nucleus-nucleus           (N)',ENUC
        WRITE(7,22) 'Nucleus-nucleus           (N)',ENUC
        WRITE(6,22) 'Electron-nucleus          (V)',EHNC
        WRITE(7,22) 'Electron-nucleus          (V)',EHNC
        WRITE(6,22) 'Electron kinetic          (T)',EHKN
        WRITE(7,22) 'Electron kinetic          (T)',EHKN
        IF(HMLT.EQ.'DHFQ') THEN
          WRITE(6,22) 'Uehling interaction       (U)',EUEH
          WRITE(7,22) 'Uehling interaction       (U)',EUEH
        ENDIF
        IF(HMLT.NE.'BARE'.AND.NOELEC.GT.1) THEN
          WRITE(6,22) 'Coulomb direct (closed)   (J)',EGDR
          WRITE(7,22) 'Coulomb direct (closed)   (J)',EGDR
          WRITE(6,22) 'Coulomb exchange (closed) (K)',EGXC
          WRITE(7,22) 'Coulomb exchange (closed) (K)',EGXC
          IF(NOPN.NE.0) THEN
            WRITE(6,22) 'Coulomb direct (open)     (Q)',EQDR
            WRITE(7,22) 'Coulomb direct (open)     (Q)',EQDR
            WRITE(6,22) 'Coulomb exchange (open)   (S)',EQXC
            WRITE(7,22) 'Coulomb exchange (open)   (S)',EQXC
          ENDIF
          IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
            WRITE(6,22) 'Breit direct (closed)     (B)',EBDR
            WRITE(7,22) 'Breit direct (closed)     (B)',EBDR
            WRITE(6,22) 'Breit exchange (closed)   (W)',EBXC
            WRITE(7,22) 'Breit exchange (closed)   (W)',EBXC
            IF(NOPN.NE.0) THEN
              WRITE(6,22) 'Breit direct (open)       (Y)',EMDR
              WRITE(7,22) 'Breit direct (open)       (Y)',EMDR
              WRITE(6,22) 'Breit exchange (open)     (Z)',EMXC
              WRITE(7,22) 'Breit exchange (open)     (Z)',EMXC
            ENDIF
          ENDIF
        ENDIF
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,22) 'Molecule total               ',ETOT
        WRITE(7,22) 'Molecule total               ',ETOT
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       TWO-ELECTRON INTEGRAL SUMMARY
23      FORMAT(1X,A,4X,'1-centre',4X,'2-centre',4X,'3-centre',
     &                                     4X,'4-centre',7X,'Total')
24      FORMAT(1X,A,3X,I9,3X,I9,3X,I9,3X,I9,3X,I9)
25      FORMAT(1X,A,3X,F9.2,3X,F9.2,3X,F9.2,3X,F9.2,3X,F9.2)
26      FORMAT(1X,A,1X,A,1X,A,1X,A,1X,A,1X,A)
C
        IF(HMLT.EQ.'BARE'.OR.NOELEC.LE.1) THEN
          GOTO 207
        ENDIF
C
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(7, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        IF(HMLT.EQ.'NORL') THEN
          WRITE(6,23) '(LL|LL)     '
          WRITE(7,23) '(LL|LL)     '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Blocks  (#) ',(N2EB(MCNT,1),MCNT=1,5)
          WRITE(7,24) 'Blocks  (#) ',(N2EB(MCNT,1),MCNT=1,5)
          IF(ISWZ.EQ.0) GOTO 240
          WRITE(6,24) 'Integrals(#)',(N2EI(MCNT,1),MCNT=1,5)
          WRITE(7,24) 'Integrals(#)',(N2EI(MCNT,1),MCNT=1,5)
          WRITE(6,24) 'Screened (#)',(N2ES(MCNT,1),MCNT=1,5)
          WRITE(7,24) 'Screened (#)',(N2ES(MCNT,1),MCNT=1,5)
          WRITE(6,25) 'Screened (%)',(F2ES(MCNT,1),MCNT=1,5)
          WRITE(7,25) 'Screened (%)',(F2ES(MCNT,1),MCNT=1,5)
240       CONTINUE
          WRITE(6,26) 'Time        ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(7,26) 'Time        ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
        ELSE
          WRITE(6,23) 'Blocks  (#) '
          WRITE(7,23) 'Blocks  (#) '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) '(LL|LL)     ',(N2EB(MCNT,1),MCNT=1,5)
          WRITE(7,24) '(LL|LL)     ',(N2EB(MCNT,1),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 211
          WRITE(6,24) '(LL|SS)     ',(N2EB(MCNT,2),MCNT=1,5)
          WRITE(7,24) '(LL|SS)     ',(N2EB(MCNT,2),MCNT=1,5)
          WRITE(6,24) '(SS|LL)     ',(N2EB(MCNT,3),MCNT=1,5)
          WRITE(7,24) '(SS|LL)     ',(N2EB(MCNT,3),MCNT=1,5)
          WRITE(6,24) '(SS|SS)     ',(N2EB(MCNT,4),MCNT=1,5)
          WRITE(7,24) '(SS|SS)     ',(N2EB(MCNT,4),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 211
          WRITE(6,24) '(SL|LS)     ',(N2EB(MCNT,5),MCNT=1,5)
          WRITE(7,24) '(SL|LS)     ',(N2EB(MCNT,5),MCNT=1,5)
211       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Total       ',(N2EB(MCNT,6),MCNT=1,5)
          WRITE(7,24) 'Total       ',(N2EB(MCNT,6),MCNT=1,5)
          IF(ISWZ.EQ.0) GOTO 250
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Integrals(#)'
          WRITE(7,23) 'Integrals(#)'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) '(LL|LL)     ',(N2EI(MCNT,1),MCNT=1,5)
          WRITE(7,24) '(LL|LL)     ',(N2EI(MCNT,1),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 212
          WRITE(6,24) '(LL|SS)     ',(N2EI(MCNT,2),MCNT=1,5)
          WRITE(7,24) '(LL|SS)     ',(N2EI(MCNT,2),MCNT=1,5)
          WRITE(6,24) '(SS|LL)     ',(N2EI(MCNT,3),MCNT=1,5)
          WRITE(7,24) '(SS|LL)     ',(N2EI(MCNT,3),MCNT=1,5)
          WRITE(6,24) '(SS|SS)     ',(N2EI(MCNT,4),MCNT=1,5)
          WRITE(7,24) '(SS|SS)     ',(N2EI(MCNT,4),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 212
          WRITE(6,24) '(SL|LS)     ',(N2EI(MCNT,5),MCNT=1,5)
          WRITE(7,24) '(SL|LS)     ',(N2EI(MCNT,5),MCNT=1,5)
212       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Total       ',(N2EI(MCNT,6),MCNT=1,5)
          WRITE(7,24) 'Total       ',(N2EI(MCNT,6),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Screened (#)'
          WRITE(7,23) 'Screened (#)'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) '(LL|LL)     ',(N2ES(MCNT,1),MCNT=1,5)
          WRITE(7,24) '(LL|LL)     ',(N2ES(MCNT,1),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 214
          WRITE(6,24) '(LL|SS)     ',(N2ES(MCNT,2),MCNT=1,5)
          WRITE(7,24) '(LL|SS)     ',(N2ES(MCNT,2),MCNT=1,5)
          WRITE(6,24) '(SS|LL)     ',(N2ES(MCNT,3),MCNT=1,5)
          WRITE(7,24) '(SS|LL)     ',(N2ES(MCNT,3),MCNT=1,5)
          WRITE(6,24) '(SS|SS)     ',(N2ES(MCNT,4),MCNT=1,5)
          WRITE(7,24) '(SS|SS)     ',(N2ES(MCNT,4),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 214
          WRITE(6,24) '(SL|LS)     ',(N2ES(MCNT,5),MCNT=1,5)
          WRITE(7,24) '(SL|LS)     ',(N2ES(MCNT,5),MCNT=1,5)
214       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,24) 'Total       ',(N2ES(MCNT,6),MCNT=1,5)
          WRITE(7,24) 'Total       ',(N2ES(MCNT,6),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Screened (%)'
          WRITE(7,23) 'Screened (%)'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,25) '(LL|LL)     ',(F2ES(MCNT,1),MCNT=1,5)
          WRITE(7,25) '(LL|LL)     ',(F2ES(MCNT,1),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 216
          WRITE(6,25) '(LL|SS)     ',(F2ES(MCNT,2),MCNT=1,5)
          WRITE(7,25) '(LL|SS)     ',(F2ES(MCNT,2),MCNT=1,5)
          WRITE(6,25) '(SS|LL)     ',(F2ES(MCNT,3),MCNT=1,5)
          WRITE(7,25) '(SS|LL)     ',(F2ES(MCNT,3),MCNT=1,5)
          WRITE(6,25) '(SS|SS)     ',(F2ES(MCNT,4),MCNT=1,5)
          WRITE(7,25) '(SS|SS)     ',(F2ES(MCNT,4),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 216
          WRITE(6,25) '(SL|LS)     ',(F2ES(MCNT,5),MCNT=1,5)
          WRITE(7,25) '(SL|LS)     ',(F2ES(MCNT,5),MCNT=1,5)
216       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,25) 'Total       ',(F2ES(MCNT,6),MCNT=1,5)
          WRITE(7,25) 'Total       ',(F2ES(MCNT,6),MCNT=1,5)
250       CONTINUE
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
          WRITE(6,23) 'Time        '
          WRITE(7,23) 'Time        '
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,26) '(LL|LL)     ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          WRITE(7,26) '(LL|LL)     ',(MS(T2ES(MCNT,1)),MCNT=1,5)
          IF(HMLT.EQ.'NORL') GOTO 219
          WRITE(6,26) '(LL|SS)     ',(MS(T2ES(MCNT,2)),MCNT=1,5)
          WRITE(7,26) '(LL|SS)     ',(MS(T2ES(MCNT,2)),MCNT=1,5)
          WRITE(6,26) '(SS|LL)     ',(MS(T2ES(MCNT,3)),MCNT=1,5)
          WRITE(7,26) '(SS|LL)     ',(MS(T2ES(MCNT,3)),MCNT=1,5)
          WRITE(6,26) '(SS|SS)     ',(MS(T2ES(MCNT,4)),MCNT=1,5)
          WRITE(7,26) '(SS|SS)     ',(MS(T2ES(MCNT,4)),MCNT=1,5)
          IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') GOTO 219
          WRITE(6,26) '(SL|LS)     ',(MS(T2ES(MCNT,5)),MCNT=1,5)
          WRITE(7,26) '(SL|LS)     ',(MS(T2ES(MCNT,5)),MCNT=1,5)
219       CONTINUE
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
          WRITE(6,26) 'Total       ',(MS(T2ES(MCNT,6)),MCNT=1,5)
          WRITE(7,26) 'Total       ',(MS(T2ES(MCNT,6)),MCNT=1,5)
          WRITE(6, *) REPEAT('=',72)
          WRITE(7, *) REPEAT('=',72)
        ENDIF
207     CONTINUE
C
C       MATRIX CONSTRUCTION STOPWATCH
        TMOR = TSTP-T1EL-TCL1-TCL2-TBR1-TBR2-TDGN
30      FORMAT(1X,A,24X,A)
31      FORMAT(1X,A,1X,I3,16X,A)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',20),'Fock construction labour analysis'
        WRITE(7, *) REPEAT(' ',20),'Fock construction labour analysis'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'One-electron matrices           ',HMS(T1EL)
        WRITE(7,30) 'One-electron matrices           ',HMS(T1EL)
        IF(HMLT.NE.'BARE') THEN
          WRITE(6,30) 'Coulomb (atomic)                ',HMS(TCL1)
          WRITE(7,30) 'Coulomb (atomic)                ',HMS(TCL1)
          WRITE(6,30) 'Coulomb (many-centre)           ',HMS(TCL2)
          WRITE(7,30) 'Coulomb (many-centre)           ',HMS(TCL2)
          IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
            WRITE(6,30) 'Breit (atomic)                  ',HMS(TBR1)
            WRITE(7,30) 'Breit (atomic)                  ',HMS(TBR1)
            WRITE(6,30) 'Breit (many-centre)             ',HMS(TBR2)
            WRITE(7,30) 'Breit (many-centre)             ',HMS(TBR2)
          ENDIF
        ENDIF
        WRITE(6,30) 'Matrix diagonalisation          ',HMS(TDGN)
        WRITE(7,30) 'Matrix diagonalisation          ',HMS(TDGN)
        WRITE(6,30) 'Other sources                   ',HMS(TMOR)
        WRITE(7,30) 'Other sources                   ',HMS(TMOR)
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,30) 'Total iteration time            ',HMS(TSTP)
        WRITE(7,30) 'Total iteration time            ',HMS(TSTP)
        WRITE(6,31) 'Time at end of iteration        ',ITER,STAMP
        WRITE(7,31) 'Time at end of iteration        ',ITER,STAMP
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       CONVERGENCE STATUS
32      FORMAT(1X,A,42X,I3)
33      FORMAT(1X,A,37X,F8.5)
34      FORMAT(1X,A,29X,1P,D16.9)
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',26),'Convergence analysis'
        WRITE(7, *) REPEAT(' ',26),'Convergence analysis'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,32) 'Iteration number           ',ITER
        WRITE(7,32) 'Iteration number           ',ITER
        WRITE(6,32) 'Integral inclusion level   ',ILEV
        WRITE(7,32) 'Integral inclusion level   ',ILEV
        WRITE(6,33) 'Level shift parameter      ',SHLV
        WRITE(7,33) 'Level shift parameter      ',SHLV
        WRITE(6,34) 'Density difference norm    ',DNRM(ITER)
        WRITE(7,34) 'Density difference norm    ',DNRM(ITER)
        WRITE(6,34) 'Weighted energy difference ',WEDN(ITER)
        WRITE(7,34) 'Weighted energy difference ',WEDN(ITER)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       TEST FOR CONVERGENCE OR INTEGRAL CLASS UPDATE
40      FORMAT(29X,'Stage 1: (LL|LL)')
41      FORMAT(23X,'Stage 2: (LL|SS) and (SS|LL)')
42      FORMAT(19X,'Stage 2: (LL|SS), (SS|LL) and (SL|LS)')
43      FORMAT(29X,'Stage 3: (SS|SS)')
44      FORMAT(29X,'Stage 4: (SL|LS)')
C
C       THREE-STRIKE RULE: IF ENERGY DIFFERENCE KEEPS INCREASING, EXIT
        IF(ITER.GT.3) THEN
C
C         STORE LAST FEW ENERGY DIFFERENCE VALUES
          WE1 = WEDN(ITER-3)
          WE2 = WEDN(ITER-2)
          WE3 = WEDN(ITER-1)
          WE4 = WEDN(ITER  )
C
C         IF EACH IS SEQUENTIALLY BIGGER THAN THE LAST, EXIT
          IF(WE4.GT.WE3.AND.WE3.GT.WE2.AND.WE2.GT.WE1) THEN
            WRITE(6, *) ' '
            WRITE(7, *) ' '
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6, *) 'In HFSCF: energy not converging. Exit BERTHA.'
            WRITE(7, *) 'In HFSCF: energy not converging. Exit BERTHA.'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            STOP
          ENDIF
C
        ENDIF
C
C       BARE NUCLEUS APPROXIMATION: NO COULOMB INTEGRALS AND NO SCF.
        IF(HMLT.EQ.'BARE'.OR.NOELEC.LE.1) GOTO 300
C
C       CURRENTLY AT STAGE 1: (LL|LL)
        IF(ILEV.EQ.1) THEN
C
C         NON-RELATIVISTIC HAMILTONIAN ONLY INVOLVES (LL|LL)
          IF(HMLT.EQ.'NORL') THEN
C
C           SATISFIES ALL CRITERIA - SUCCESSFUL CONVERGENCE
            IF(WEDN(ITER).LT.ENRGTOL.AND.DNRM(ITER).LT.DSTYTOL) THEN
              GOTO 300
            ENDIF
C
C         ALL OTHER HAMILTONIANS REQUIRE FURTHER INTEGRAL INCLUSIONS
          ELSE
C
C           IF STAGE 1 HAS NOT CONVERGED, ITERATE AGAIN
            IF(WEDN(ITER).GE.ENRGLV1) THEN
              SHLV = SHLEV(ILEV)
C           IF STAGE 1 HAS CONVERGED, PROCEED TO STAGE 2
            ELSEIF(WEDN(ITER).LT.ENRGLV1) THEN
              ILEV = 2
              SHLV = SHLEV(ILEV)
              WRITE(6, *) ' '
              WRITE(7, *) ' '
              WRITE(6, *) REPEAT('*',72)
              WRITE(7, *) REPEAT('*',72)
              IF(HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
                WRITE(6,41)
                WRITE(7,41)
              ELSE
                WRITE(6,42)
                WRITE(7,42)
              ENDIF
              WRITE(6, *) REPEAT('*',72)
              WRITE(7, *) REPEAT('*',72)
              WRITE(6, *) ' '
              WRITE(7, *) ' '
            ENDIF
C
          ENDIF
C
C       CURRENTLY AT STAGE 2: (LL|SS), (SS|LL), (SL|LS)
        ELSEIF(ILEV.EQ.2) THEN

C         IF STAGE 2 HAS CONVERGED, PROCEED TO STAGE 3
          IF(WEDN(ITER).LT.ENRGLV2) THEN
            ILEV = 3
            SHLV = SHLEV(ILEV)
            WRITE(6, *) ' '
            WRITE(7, *) ' '
            WRITE(6, *) REPEAT('*',72)
            WRITE(7, *) REPEAT('*',72)
            WRITE(6,43)
            WRITE(7,43)
            WRITE(6, *) REPEAT('*',72)
            WRITE(7, *) REPEAT('*',72)
            WRITE(6, *) ' '
            WRITE(7, *) ' '
          ENDIF
C
C       CURRENTLY AT STAGE 3: (SS|SS)
        ELSEIF(ILEV.EQ.3) THEN
C
C         SATISFIES ALL CRITERIA - SUCCESSFUL CONVERGENCE
          IF(WEDN(ITER).LT.ENRGTOL.AND.DNRM(ITER).LT.DSTYTOL) THEN
            GOTO 300
          ENDIF
C
        ENDIF
C
C     END LOOP OVER ITERATIONS
      ENDDO
C
C     FORCED EXIT: UNSUCCESSFUL CONVERGENCE
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6, *) 'In HFSCF: convergence not attained. ITER = ',ITER
      WRITE(7, *) 'In HFSCF: convergence not attained. ITER = ',ITER
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      STOP
C
C     EARLY EXIT: SUCCESSFUL CONVERGENCE
300   CONTINUE
C
C**********************************************************************C
C     END OF SELF-CONSISTENT FIELD CALCULATIONS                        C
C**********************************************************************C
C
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) REPEAT('\/',36)
      WRITE(7, *) REPEAT('\/',36)
      WRITE(6, *) REPEAT(':',72)
      WRITE(7, *) REPEAT(':',72)
      WRITE(6, *) REPEAT(' ',25),'Successful convergence!'
      WRITE(7, *) REPEAT(' ',25),'Successful convergence!'
      WRITE(6, *) REPEAT(':',72)
      WRITE(7, *) REPEAT(':',72)
      WRITE(6, *) REPEAT('/\',36)
      WRITE(7, *) REPEAT('/\',36)
      WRITE(6, *) REPEAT('*',72)
      WRITE(7, *) REPEAT('*',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C**********************************************************************C
C     ADDITIONAL OPTIONS AFTER CONVERGENCE (1ST ORDER P.T.)            C
C**********************************************************************C
C
998   CONTINUE
C
C     CALCULATE THE PERTUBATIVE VALUE OF THE BREIT ENERGY
      IF(HMLT.EQ.'DHFP') THEN
        CALL CPU_TIME(TPRTI)
C
C       PRINT CALL TO NEW STAGE OF R-INTEGRALS
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('*',72)
        WRITE(7, *) REPEAT('*',72)
        WRITE(6,44)
        WRITE(7,44)
        WRITE(6, *) REPEAT('*',72)
        WRITE(7, *) REPEAT('*',72)
        WRITE(6, *) ' '
        WRITE(7, *) ' '
C
C       TITLE FOR CALL TO BREIT ROUTINE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',24),'First order Breit energy'
        WRITE(7, *) REPEAT(' ',24),'First order Breit energy'
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
C
C
        ISWITCH=1
C
C       GENERATE MATRIX REP OF BREIT INTERACTION
        TSCR = 0.0D0

        CALL CPU_TIME(T1)
        CALL BREIT(ISWITCH)
        IF(ISWITCH.EQ.1) THEN
          DO ICNT=1,NCNT
            CALL BREIT1(ICNT)
          ENDDO
        ENDIF
        CALL CPU_TIME(T2)
        
        TBR2 = T2-T1
        TB2T = TB2T+TBR2
c
        TITLE = 'BXCH1-FOR-Ne'
        DO I=1,NDIM
          DO J=1,NDIM
            BMAT(I,J) = -DREAL(BXCH(I,J))
          ENDDO
        ENDDO
Cc
C     PRINT TO EXTERNAL DATA FILE
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//".dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (bmat(I,J),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
C       CALCULATE FRACTION OF SCREENED INTEGRALS
        TSCR = TSCR + TSCR
        DO MCNT=1,5
          DO ITT=5,6
            IF(N2EI(MCNT,ITT).NE.0) THEN
              RATIO = DFLOAT(N2ES(MCNT,ITT))/DFLOAT(N2EI(MCNT,ITT))
              F2ES(MCNT,ITT) = 100.0D0*RATIO
            ELSE
              F2ES(MCNT,ITT) = 0.0D0
            ENDIF
          ENDDO
        ENDDO
        
        GOTO 222
C
C       ADD BREIT MATRIX TO MOST RECENT FOCK MATRIX
        DO I=1,NDIM
          DO J=1,NDIM
            FOCK(I,J) = FOCK(I,J)+BDIR(I,J)-BXCH(I,J)
          ENDDO
        ENDDO
C
C       DIAGONALISE FOCK MATRIX (REQUIRES LAPACK LIBRARY)
        CALL ZHEGV(1,'V','L',NDIM,FOCK,MDM,OVAP,MDM,
     &                                        EIGN,WORK,LWK,RWORK,INFO)
        IF(INFO.NE.0) THEN
          WRITE(6, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INFO
          WRITE(7, *) 'In HFSCF: eigenvalue solver ZHEGV failed.',INFO
        ENDIF
C
C       TRANSFER EIGENVECTORS TO THE C ARRAY
        DO J=1,NDIM
          DO I=1,NDIM
            COEF(I,J) = FOCK(I,J)
          ENDDO
        ENDDO
C
C       DEDUCT LEVEL SHIFT VALUE FROM VIRTUAL ORBITAL EIGENVALUES
        IF(ITER.EQ.1) THEN
          DO IVIR=NSKP+NOCC+1,NDIM
            EIGN(IVIR) = EIGN(IVIR) - SHLV
          ENDDO
        ENDIF
C
C       UPDATE EIGENVALUES AND COEFFICIENTS
        OPEN(UNIT=8,FILE=TRIM(WFNFL)//'(+B).wfn',STATUS='UNKNOWN')
        REWIND(UNIT=8)
        DO I=1,NDIM
          WRITE(8, *) EIGN(I),(COEF(J,I),J=1,NDIM)
        ENDDO
        CLOSE(UNIT=8)

222     CONTINUE
C
C       RECALCULATE TOTAL ENERGY
        CALL ENERGIES
C
C       UPDATE TOTAL BREIT CALCULATION TIME
        CALL CPU_TIME(TPRTF)
        TBMX = TPRTF-TPRTI
C
C       SUMMARISE DIRECT AND EXCHANGE ENERGIES
        WRITE(6,22) 'Breit direct (closed)     (B)',EBDR
        WRITE(7,22) 'Breit direct (closed)     (B)',EBDR
        WRITE(6,22) 'Breit exchange (closed)   (W)',EBXC
        WRITE(7,22) 'Breit exchange (closed)   (W)',EBXC
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,30) 'Total BREIT time                ',HMS(TBMX)
        WRITE(7,30) 'Total BREIT time                ',HMS(TBMX)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        
C       DFNOTE: BREIT1 FIXING STOPPER
        STOP
C
C       TWO-ELECTRON CALCULATION BREAKDOWN
        WRITE(6, *) REPEAT(' ',72)
        WRITE(7, *) REPEAT(' ',72)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(7, *) REPEAT(' ',19),'Two-electron calculation breakdown'
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
        WRITE(6,23) '(SL|LS)     '
        WRITE(7,23) '(SL|LS)     '
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,24) 'Integrals(#)',(N2EI(MCNT,5),MCNT=1,5)
        WRITE(7,24) 'Integrals(#)',(N2EI(MCNT,5),MCNT=1,5)
        IF(ISWZ.EQ.0) GOTO 260
        WRITE(6,24) 'Screened (#)',(N2ES(MCNT,5),MCNT=1,5)
        WRITE(7,24) 'Screened (#)',(N2ES(MCNT,5),MCNT=1,5)
        WRITE(6,25) 'Screened (%)',(F2ES(MCNT,5),MCNT=1,5)
        WRITE(7,25) 'Screened (%)',(F2ES(MCNT,5),MCNT=1,5)
260     CONTINUE
        WRITE(6,26) 'Time        ',(MS(T2ES(MCNT,5)),MCNT=1,5)
        WRITE(7,26) 'Time        ',(MS(T2ES(MCNT,5)),MCNT=1,5)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       LEVEL ITERATIONS AND TIME
        NMLEV(4) = 1
        TMLEV(4) = TBMX
        ITER     = ITER+1
C
      ENDIF
C
C**********************************************************************C
C     SUMMARY OF CALCULATION DETAILS                                   C
C**********************************************************************C
C
C     TIME AT END OF MOLECULAR CALCULATION
      CALL CPU_TIME(TSCF2)
      TTOT = TSCF2 - TSCF1
C
C     DATE AND TIME AT END OF CALCULATION
      CALL TIMENOW(STAMP)
C
C     PRINT OUT FINAL SCF RESULTS
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'Molecular SCF summary'
      WRITE(7, *) REPEAT(' ',25),'Molecular SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     MOLECULAR ENERGIES
      EDIR = EGDR+EQDR+EBDR+EMDR
      EXCH = EGXC+EQXC+EBXC+EMXC
50    FORMAT(1X,A,22X,A,11X,A,14X,A)
51    FORMAT(1X,A,39X,F17.9)
52    FORMAT(1X,A,1X,F17.9,2X,F17.9,2X,F17.9)
      WRITE(6, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(7, *) REPEAT(' ',19),'Molecular energies (Hartree units)'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,50) 'Source','Direct','Exchange','Total'
      WRITE(7,50) 'Source','Direct','Exchange','Total'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,51) 'Nucleus-nucleus ',ENUC
      WRITE(7,51) 'Nucleus-nucleus ',ENUC
      WRITE(6,51) 'Electron-nucleus',EHNC
      WRITE(7,51) 'Electron-nucleus',EHNC
      WRITE(6,51) 'Electron kinetic',EHKN
      WRITE(7,51) 'Electron kinetic',EHKN
      IF(HMLT.NE.'DHFQ') GOTO 405
      WRITE(6,51) 'Uehling effects ',EUEH
      WRITE(6,51) 'Uehling effects ',EUEH
405   CONTINUE
      IF(HMLT.EQ.'BARE') GOTO 400
      WRITE(6,52) 'Coulomb (closed)',EGDR,EGXC,ECLG
      WRITE(7,52) 'Coulomb (closed)',EGDR,EGXC,ECLG
      IF(NOPN.EQ.0) GOTO 410
      WRITE(6,52) 'Coulomb (open)  ',EQDR,EQXC,ECLQ
      WRITE(7,52) 'Coulomb (open)  ',EQDR,EQXC,ECLQ
410   CONTINUE
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 400
      WRITE(6,52) 'Breit (closed)  ',EBDR,EBXC,EBRG
      WRITE(7,52) 'Breit (closed)  ',EBDR,EBXC,EBRG
      IF(NOPN.EQ.0) GOTO 400
      WRITE(6,52) 'Breit (open)    ',EMDR,EMXC,EBRQ
      WRITE(7,52) 'Breit (open)    ',EMDR,EMXC,EBRQ
400   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,52) 'Molecule        ',EDIR,EXCH,ETOT
      WRITE(7,52) 'Molecule        ',EDIR,EXCH,ETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     E-COEFFICIENT AND R-INTEGRAL ANALYSIS
53    FORMAT(1X,A,5X,A,14X,A,20X,A)
54    FORMAT(1X,A,3X,A,14X,A,A)
64    FORMAT(1X,A,3X,A)
55    FORMAT(38X,A,A)
56    FORMAT(1X,A,2X,A,33X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',21),'E-coefficients and R-integrals'
      WRITE(7, *) REPEAT(' ',21),'E-coefficients and R-integrals'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,53) 'E-coefficients','Time','R-integrals','Time'
      WRITE(7,53) 'E-coefficients','Time','R-integrals','Time'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,54) 'E0LL',HMS(TELL),'(LL|LL)            ',HMS(TRLL)
      WRITE(7,54) 'E0LL',HMS(TELL),'(LL|LL)            ',HMS(TRLL)
      IF(HMLT.EQ.'NORL') GOTO 420
      WRITE(6,54) 'E0SS',HMS(TESS),'(LL|SS) and (SS|LL)',HMS(TRLS)
      WRITE(7,54) 'E0SS',HMS(TESS),'(LL|SS) and (SS|LL)',HMS(TRLS)
      WRITE(6,55)                  '(SS|SS)            ',HMS(TRSS)
      WRITE(7,55)                  '(SS|SS)            ',HMS(TRSS)
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 420
      WRITE(6,54) 'EILS',HMS(TELS),'(SL|LS)            ',HMS(TRBR)
      WRITE(7,54) 'EILS',HMS(TELS),'(SL|LS)            ',HMS(TRBR)
      WRITE(6,64) 'EISL',HMS(TESL)
      WRITE(7,64) 'EISL',HMS(TESL)
420   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,56) 'Total',HMS(TELL+TESS+TELS+TESL),
     &                    HMS(TRLL+TRLS+TRSS+TRBR)
      WRITE(7,56) 'Total',HMS(TELL+TESS+TELS+TESL),
     &                    HMS(TRLL+TRLS+TRSS+TRBR)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     CONVERGENCE ANALYSIS
      T1 = TMLEV(1)
      T2 = TMLEV(2)
      T3 = TMLEV(3)
      T4 = TMLEV(4)
59    FORMAT(1X,A,3X,A,16X,A,6X,A,14X,A)
60    FORMAT(1X,I1,7X,A,2X,F8.5,13X,I3,2X,A)
61    FORMAT(1X,I1,7X,A)
62    FORMAT(9X,A,2X,F8.5,13X,I3,2X,A)
63    FORMAT(1X,A,46X,I3,2X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',25),'Convergence analysis'
      WRITE(7, *) REPEAT(' ',25),'Convergence analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,59) 'Stage','Inclusion','Shift','Iterations','Time'
      WRITE(7,59) 'Stage','Inclusion','Shift','Iterations','Time'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,60) 1,'(LL|LL)             ',SHLEV(1),NMLEV(1),HMS(T1)
      WRITE(7,60) 1,'(LL|LL)             ',SHLEV(1),NMLEV(1),HMS(T1)
      IF(HMLT.EQ.'NORL') GOTO 440
      IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFQ') THEN
        WRITE(6,61) 2,'(LL|SS) and (SS|LL),'
        WRITE(7,61) 2,'(LL|SS) and (SS|LL),'
        WRITE(6,62)   '(SL|LS)             ',SHLEV(2),NMLEV(2),HMS(T2)
        WRITE(7,62)   '(SL|LS)             ',SHLEV(2),NMLEV(2),HMS(T2)
      ELSE
        WRITE(6,60) 2,'(LL|SS) and (SS|LL) ',SHLEV(2),NMLEV(2),HMS(T2)
        WRITE(7,60) 2,'(LL|SS) and (SS|LL) ',SHLEV(2),NMLEV(2),HMS(T2)
      ENDIF
      WRITE(6,60) 3,'(SS|SS)             ',SHLEV(3),NMLEV(3),HMS(T3)
      WRITE(7,60) 3,'(SS|SS)             ',SHLEV(3),NMLEV(3),HMS(T3)
      IF(HMLT.EQ.'DHFP') THEN
        WRITE(6,60) 4,'(SL|LS)             ',SHLEV(3),NMLEV(4),HMS(T4)
        WRITE(7,60) 4,'(SL|LS)             ',SHLEV(3),NMLEV(4),HMS(T4)
      ENDIF
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,63) 'Total',ITER,HMS(T1+T2+T3+T4)
      WRITE(7,63) 'Total',ITER,HMS(T1+T2+T3+T4)
440   CONTINUE
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     HFSCF LABOUR ANALYIS
57    FORMAT(1X,A,24X,A)
58    FORMAT(1X,A,1X,25X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT(' ',26),'HFSCF labour analysis'
      WRITE(7, *) REPEAT(' ',26),'HFSCF labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(HMLT.EQ.'BARE') GOTO 530
      TC1O = TC1T-TC1S-TC1B-TC1R-TC1F-TC1M
      WRITE(6, *) REPEAT(' ',24),'Coulomb (atomic) details'
      WRITE(7, *) REPEAT(' ',24),'Coulomb (atomic) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TC1S)
      WRITE(7,57) 'Screening                       ',HMS(TC1S)
      WRITE(6,57) 'Basis intermediates             ',HMS(TC1B)
      WRITE(7,57) 'Basis intermediates             ',HMS(TC1B)
      WRITE(6,57) 'R(AB|CD) integrals              ',HMS(TC1R)
      WRITE(7,57) 'R(AB|CD) integrals              ',HMS(TC1R)
      WRITE(6,57) 'Full integrals                  ',HMS(TC1F)
      WRITE(7,57) 'Full integrals                  ',HMS(TC1F)
      WRITE(6,57) 'Matrix construction             ',HMS(TC1M)
      WRITE(7,57) 'Matrix construction             ',HMS(TC1M)
      WRITE(6,57) 'Other                           ',HMS(TC1O)
      WRITE(7,57) 'Other                           ',HMS(TC1O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TC1T)
      WRITE(7,57) 'Total                           ',HMS(TC1T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      TC2O = TC2T-TC2S-TCEC-TCRM-TCRR-TCC1-TCC2-TCMC
      WRITE(6, *) REPEAT(' ',21),'Coulomb (many-centre) details'
      WRITE(7, *) REPEAT(' ',21),'Coulomb (many-centre) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TC2S)
      WRITE(7,57) 'Screening                       ',HMS(TC2S)
      WRITE(6,57) 'Eq-coefficients                 ',HMS(TCEC)
      WRITE(7,57) 'Eq-coefficients                 ',HMS(TCEC)
      WRITE(6,57) 'R-integral make                 ',HMS(TCRM)
      WRITE(7,57) 'R-integral make                 ',HMS(TCRM)
      WRITE(6,57) 'R-integral read                 ',HMS(TCRR)
      WRITE(7,57) 'R-integral read                 ',HMS(TCRR)
      WRITE(6,57) '1st contraction                 ',HMS(TCC1)
      WRITE(7,57) '1st contraction                 ',HMS(TCC1)
      WRITE(6,57) '2nd contraction                 ',HMS(TCC2)
      WRITE(7,57) '2nd contraction                 ',HMS(TCC2)
      WRITE(6,57) 'Matrix construction             ',HMS(TCMC)
      WRITE(7,57) 'Matrix construction             ',HMS(TCMC)
      WRITE(6,57) 'Other                           ',HMS(TC2O)
      WRITE(7,57) 'Other                           ',HMS(TC2O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TC2T)
      WRITE(7,57) 'Total                           ',HMS(TC2T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 530
      TB1O = TB1T-TB1S-TB1B-TB1R-TB1F-TB1M
      WRITE(6, *) REPEAT(' ',25),'Breit (atomic) details'
      WRITE(7, *) REPEAT(' ',25),'Breit (atomic) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TB1S)
      WRITE(7,57) 'Screening                       ',HMS(TB1S)
      WRITE(6,57) 'Basis intermediates             ',HMS(TB1B)
      WRITE(7,57) 'Basis intermediates             ',HMS(TB1B)
      WRITE(6,57) 'R(AB|CD) integrals              ',HMS(TB1R)
      WRITE(7,57) 'R(AB|CD) integrals              ',HMS(TB1R)
      WRITE(6,57) 'Full integrals                  ',HMS(TB1F)
      WRITE(7,57) 'Full integrals                  ',HMS(TB1F)
      WRITE(6,57) 'Matrix construction             ',HMS(TB1M)
      WRITE(7,57) 'Matrix construction             ',HMS(TB1M)
      WRITE(6,57) 'Other                           ',HMS(TB1O)
      WRITE(7,57) 'Other                           ',HMS(TB1O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TB1T)
      WRITE(7,57) 'Total                           ',HMS(TB1T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
555   CONTINUE
      TB2O = TB2T-TB2S-TBEC-TBRM-TBRR-TBC1-TBC2-TBMC
      WRITE(6, *) REPEAT(' ',22),'Breit (many-centre) details'
      WRITE(7, *) REPEAT(' ',22),'Breit (many-centre) details'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'Screening                       ',HMS(TB2S)
      WRITE(7,57) 'Screening                       ',HMS(TB2S)
      WRITE(6,57) 'Eq-coefficients                 ',HMS(TBEC)
      WRITE(7,57) 'Eq-coefficients                 ',HMS(TBEC)
      WRITE(6,57) 'R-integral make                 ',HMS(TBRM)
      WRITE(7,57) 'R-integral make                 ',HMS(TBRM)
      WRITE(6,57) 'R-integral read                 ',HMS(TBRR)
      WRITE(7,57) 'R-integral read                 ',HMS(TBRR)
      WRITE(6,57) '1st contraction                 ',HMS(TBC1)
      WRITE(7,57) '1st contraction                 ',HMS(TBC1)
      WRITE(6,57) '2nd contraction                 ',HMS(TBC2)
      WRITE(7,57) '2nd contraction                 ',HMS(TBC2)
      WRITE(6,57) 'Matrix construction             ',HMS(TBMC)
      WRITE(7,57) 'Matrix construction             ',HMS(TBMC)
      WRITE(6,57) 'Other                           ',HMS(TB2O)
      WRITE(7,57) 'Other                           ',HMS(TB2O)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TB2T)
      WRITE(7,57) 'Total                           ',HMS(TB2T)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
530   CONTINUE
      TOTH = TTOT-TEPP-THMX-TQMX-TC1T-TC2T-TB1T-TB2T-TEIG
      WRITE(6, *) REPEAT(' ',27),'Overall SCF summary'
      WRITE(7, *) REPEAT(' ',27),'Overall SCF summary'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,57) 'E-coefficient data file prep.   ',HMS(TEPP)
      WRITE(7,57) 'E-coefficient data file prep.   ',HMS(TEPP)
      WRITE(6,57) 'Nuclear, kinetic and overlap    ',HMS(THMX)
      WRITE(7,57) 'Nuclear, kinetic and overlap    ',HMS(THMX)
      IF(HMLT.EQ.'DHFQ') THEN
        WRITE(6,57) 'Uehling matrix elements         ',HMS(TQMX)
        WRITE(7,57) 'Uehling matrix elements         ',HMS(TQMX)
      ENDIF
      IF(HMLT.EQ.'BARE') GOTO 430
      WRITE(6,57) 'Coulomb (atomic)                ',HMS(TC1T)
      WRITE(7,57) 'Coulomb (atomic)                ',HMS(TC1T)
      WRITE(6,57) 'Coulomb (many-centre)           ',HMS(TC2T)
      WRITE(7,57) 'Coulomb (many-centre)           ',HMS(TC2T)
      IF(HMLT.EQ.'NORL'.OR.HMLT.EQ.'DHFR') GOTO 430
      WRITE(6,57) 'Breit (atomic)                  ',HMS(TB1T)
      WRITE(7,57) 'Breit (atomic)                  ',HMS(TB1T)
      WRITE(6,57) 'Breit (many-centre)             ',HMS(TB2T)
      WRITE(7,57) 'Breit (many-centre)             ',HMS(TB2T)
430   CONTINUE
      WRITE(6,57) 'Matrix diagonalisation          ',HMS(TEIG)
      WRITE(7,57) 'Matrix diagonalisation          ',HMS(TEIG)
      WRITE(6,57) 'Other sources                   ',HMS(TOTH)
      WRITE(7,57) 'Other sources                   ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,57) 'Total                           ',HMS(TTOT)
      WRITE(7,57) 'Total                           ',HMS(TTOT)
      WRITE(6,58) 'Time at end of calculation',STAMP
      WRITE(7,58) 'Time at end of calculation',STAMP
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE OVRLP
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              OOOOOO  VV    VV RRRRRRR  LL      PPPPPPP               C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO VV    VV RR    RR LL      PP    PP              C
C             OO    OO  VV  VV  RRRRRRR  LL      PPPPPPP               C
C             OO    OO   VVVV   RR    RR LL      PP                    C
C              OOOOOO     VV    RR    RR LLLLLLL PP                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  OVRLP CONSTRUCTS A MOLECULAR BASIS FUNCTION OVERLAP MATRIX.         C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLT
C
      DIMENSION RC(MB2,MRC),EXPT(MBS,4),XYZ(3,4),APH(MB2),CP(MB2,3),
     &          PNC(MB2),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      DATA PI/3.1415926535897932D0/
C
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM
        DO J=1,NDIM
          OVAP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS=+1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-PHS*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = PHS*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC OVERLAP CALCULATIONS COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 500
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS=+1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-PHS*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = PHS*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF THE OVERLAP MATRIX FOR THIS BLOCK OF   C
C     BASIS FUNCTIONS -- NOW OVERLAY THE RESULTS INTO OVAP.            C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVAP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVAP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVAP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVAP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVAP(JL1+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL2+JBAS))
            OVAP(JL1+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVAP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVAP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVAP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVAP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
            OVAP(JL1+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL2+JBAS))
            OVAP(JL1+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC OVERLAP MATRIX COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 600
C
C     SS BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVAP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVAP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVAP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVAP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVAP(JS1+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS2+JBAS))
            OVAP(JS1+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVAP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVAP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVAP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVAP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
            OVAP(JS1+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS2+JBAS))
            OVAP(JS1+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ONEEL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               OOOOOO  NN    NN EEEEEEE EEEEEEE LL                    C
C              OO    OO NNN   NN EE      EE      LL                    C
C              OO    OO NNNN  NN EE      EE      LL                    C
C              OO    OO NN NN NN EEEEEE  EEEEEE  LL                    C
C              OO    OO NN  NNNN EE      EE      LL                    C
C              OO    OO NN   NNN EE      EE      LL                    C
C               OOOOOO  NN    NN EEEEEEE EEEEEEE LLLLLLL               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ONEEL CONSTRUCTS A FULL SET OF MULTI-CENTRE OVERLAP, KINETIC AND    C
C  NUCLEAR ATTRACTION BASIS FUNCTION MATRIX ELEMENTS.                  C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLT
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CTMP1,CTMP2,CTMP3,CTMP4
      COMPLEX*16 E11A,E11B,E11C,TRM11,E21A,E21B,E21C,TRM21
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 SLL(MBS,MBS,4),SSS(MBS,MBS,4),
     &           VLL(MBS,MBS,4),VSS(MBS,MBS,4),
     &           TLL(MBS,MBS,4),TLS(MBS,MBS,4),TSL(MBS,MBS,4)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          HNUC(I,J) = DCMPLX(0.0D0,0.0D0)
          HKIN(I,J) = DCMPLX(0.0D0,0.0D0)
          OVAP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXM = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IB=1,4
            SLL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            SSS(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            TLL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            TLS(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            TSL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            VLL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMLL  = LQN(1)+LQN(2)
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
          DO M=1,MAXM
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SLL(IBAS,JBAS,1) = EROOT*E11(M,1)
          SLL(IBAS,JBAS,3) = EROOT*E21(M,1)
          SLL(IBAS,JBAS,2) =-PHS*DCONJG(SLL(IBAS,JBAS,3))
          SLL(IBAS,JBAS,4) = PHS*DCONJG(SLL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
C
C           FINITE-NUCLEUS OPTIONS
            ESM    = CNUC(IZ)+EIJ
            APH(M) = EIJ*CNUC(IZ)/ESM
            PNC(M) = 2.0D0*PI*DSQRT(CNUC(IZ)/ESM)*ZNUC(IZ)/EIJ
C
C           POINT-NUCLEUS OPTIONS
C           APH(M) = EIJ
C           PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXM,LAMLL)
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUME OF ELL0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVLL
              VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                         - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                         - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
            VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
            VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
      ENDDO
C
C     CONSTRUCT NON-RELATIVISTIC KINETIC ENERGY INTEGRALS (IOS 91)
      IF(HMLT.EQ.'NORL') THEN
        RL2 = DFLOAT(2*LQN(2)+3)
        M   = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
C
C           GAUSSIAN PRODUCT THEOREM DETAILS
            EJ  = EXPT(JBAS,2)
            EIJ = EXPT(IBAS,1) + EXPT(JBAS,2)
            ERT = DSQRT(PI/EIJ)**3
            PX = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
C
C           COORDINATES RELATIVE TO NUCLEAR CENTRE
            PBX = PX-XYZ(1,2)
            PBY = PY-XYZ(2,2)
            PBZ = PZ-XYZ(3,2)
            PB2 = PBX*PBX + PBY*PBY + PBZ*PBZ
C
            E0FC = EJ*RL2 - 2.0D0*EJ*EJ*PB2 - 3.0D0*EJ*EJ/EIJ
            E1FC = 4.0D0*EJ*EJ
C
C           TRUNCATE EXPRESSION DEPENDING ON LAMLL VALUE
C           ALL COMBINATIONS ALLOW FOR THE LAMLL = 0 MANIFOLD
            TRM11 = E0FC*E11(M,INABCD(0,0,0))
            TRM21 = E0FC*E21(M,INABCD(0,0,0))
C           IF LAMLL > 0 PROVIDE SECOND BUNCH OF TERMS
            IF(LAMLL.GE.1) THEN
              E11A = E11(M,INABCD(1,0,0))
              E21A = E21(M,INABCD(1,0,0))
              E11B = E11(M,INABCD(0,1,0))
              E21B = E21(M,INABCD(0,1,0))
              E11C = E11(M,INABCD(0,0,1))
              E21C = E21(M,INABCD(0,0,1))
              TRM11 = TRM11 - E1FC*(PBX*E11A + PBY*E11B + PBZ*E11C)
              TRM21 = TRM21 - E1FC*(PBX*E21A + PBY*E21B + PBZ*E21C)
            ENDIF
C           IF LAMLL > 1 PROVIDE FINAL BUNCH OF TERMS
            IF(LAMLL.GE.2) THEN
              E11A = E11(M,INABCD(2,0,0))
              E21A = E21(M,INABCD(2,0,0))
              E11B = E11(M,INABCD(0,2,0))
              E21B = E21(M,INABCD(0,2,0))
              E11C = E11(M,INABCD(0,0,2))
              E21C = E21(M,INABCD(0,0,2))
              TRM11 = TRM11 - E1FC*(E11A + E11B + E11C)
              TRM21 = TRM21 - E1FC*(E21A + E21B + E21C)
            ENDIF
            TLL(IBAS,JBAS,1) = ERT*TRM11
            TLL(IBAS,JBAS,3) = ERT*TRM21
            TLL(IBAS,JBAS,2) =-PHS*DCONJG(TLL(IBAS,JBAS,3))
            TLL(IBAS,JBAS,4) = PHS*DCONJG(TLL(IBAS,JBAS,1))
C            
          ENDDO
        ENDDO
C       NON-RELATIVISTIC HAMILTONIAN MATRICES COMPLETE
        GOTO 500
      ENDIF
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
          DO M=1,MAXM
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ   = EXPT(IBAS,1)+EXPT(JBAS,2)
          EROOT = DSQRT(PI/EIJ)**3
          SSS(IBAS,JBAS,1) = EROOT*E11(M,1)
          SSS(IBAS,JBAS,3) = EROOT*E21(M,1)
          SSS(IBAS,JBAS,2) =-PHS*DCONJG(SSS(IBAS,JBAS,3))
          SSS(IBAS,JBAS,4) = PHS*DCONJG(SSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
C
C           FINITE-NUCLEUS OPTIONS
            ESM    = CNUC(IZ)+EIJ
            APH(M) = EIJ*CNUC(IZ)/ESM
            PNC(M) = 2.0D0*PI*DSQRT(CNUC(IZ)/ESM)*ZNUC(IZ)/EIJ
C
C           POINT-NUCLEUS OPTIONS
C           APH(M) = EIJ
C           PNC(M) = 2.0D0*ZNUC(IZ)*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXM,LAMSS)
        CALL CPU_TIME(TDM2)
        TRSS = TRSS + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUME OF ESS0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVSS
              VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                           + PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                           + PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SUBTRACT THE SS OVERLAP MATRIX AND FINISH CONSTRUCTION
      CV2 = 2.0D0*CV*CV
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          VSS(IBAS,JBAS,1) =-VSS(IBAS,JBAS,1) - CV2*SSS(IBAS,JBAS,1)
          VSS(IBAS,JBAS,3) =-VSS(IBAS,JBAS,3) - CV2*SSS(IBAS,JBAS,3)
          VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
          VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 3: THE SL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     KINETIC MATRIX ELEMENTS
      FACT = CV*DSQRT(DFLOAT(2*LQN(2)+3))
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          EIJ    = EXPT(IBAS,1) + EXPT(JBAS,2)
          EJRT   = FACT*DSQRT(EXPT(JBAS,2))
          EROOT  = DSQRT(PI/EIJ)**3
          TSL(IBAS,JBAS,1) = EJRT*EROOT*E11(M,1)
          TSL(IBAS,JBAS,3) = EJRT*EROOT*E21(M,1)
          TSL(IBAS,JBAS,2) =-PHS*DCONJG(TSL(IBAS,JBAS,3))
          TSL(IBAS,JBAS,4) = PHS*DCONJG(TSL(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C
C**********************************************************************C
C     PART 4: THE LS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMSS  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
C
      CALL CPU_TIME(TDM1)
C
C     DFNOTE: THE INDEX SWAP '2 1' MAKES FILE IMPORT ANNOYING. I'M LAZY.
C             JUST GENERATE THESE EQ'S AS A BATCH (DOESN'T TAKE LONG).
C
C     IF(IEQS.EQ.0) THEN
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,2,1,0)
C     ELSEIF(IEQS.EQ.1) THEN
C       DO ITUV=1,NTUVSS
C         IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXM
C         M = 0
C         DO IBAS=1,NBAS(1)
C           DO JBAS=1,NBAS(2)
C             M = M+1
C             N = (JBAS-1)*NBAS(2) + IBAS
C             PI^{SL}_{IJ} = PI^{LS}_{JI}* (THE NEXT LINES ARE WRONG)
C             E11(M,ITUV) = DCMPLX(E0SSFL(IAD+N,1),-E0SSFL(IAD+N,2))
C             E21(M,ITUV) = DCMPLX(E0SSFL(IAD+N,3),-E0SSFL(IAD+N,4))
C           ENDDO
C         ENDDO
C       ENDDO
C     ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     KINETIC MATRIX ELEMENTS
      FACT = CV*DSQRT(DFLOAT(2*LQN(1)+3))
      M = 0
      DO JBAS=1,NBAS(2)
        DO IBAS=1,NBAS(1)
          M = M+1
          EIJ    = EXPT(JBAS,2) + EXPT(IBAS,1)
          EIRT   = FACT*DSQRT(EXPT(IBAS,1))
          EROOT  = DSQRT(PI/EIJ)**3
          TLS(IBAS,JBAS,1) = EIRT*EROOT*E11(M,1)
          TLS(IBAS,JBAS,3) = EIRT*EROOT*E21(M,1)
          TLS(IBAS,JBAS,2) =-PHS*DCONJG(TLS(IBAS,JBAS,3))
          TLS(IBAS,JBAS,4) = PHS*DCONJG(TLS(IBAS,JBAS,1))
        ENDDO
      ENDDO
C
C     GENERATE LS MATRICES FROM THE ABOVE SL MATRICES
      M = 0
      DO JBAS=1,NBAS(2)
        DO IBAS=1,NBAS(1)
          M = M + 1
          CTMP1 = DCONJG(TLS(IBAS,JBAS,1))
          CTMP2 = DCONJG(TLS(IBAS,JBAS,2))
          CTMP3 = DCONJG(TLS(IBAS,JBAS,3))
          CTMP4 = DCONJG(TLS(IBAS,JBAS,4))
C
          TLS(IBAS,JBAS,1) = CTMP1
          TLS(IBAS,JBAS,2) = CTMP3
          TLS(IBAS,JBAS,3) = CTMP2
          TLS(IBAS,JBAS,4) = CTMP4
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF HNUC AND HKIN FOR THIS BLOCK.          C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL OVERLAP BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVAP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVAP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVAP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVAP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
C
            OVAP(JL1+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL2+JBAS))
            OVAP(JL1+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVAP(IL1+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,1)
            OVAP(IL1+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,2)
            OVAP(IL2+IBAS,JL1+JBAS) = SLL(IBAS,JBAS,3)
            OVAP(IL2+IBAS,JL2+JBAS) = SLL(IBAS,JBAS,4)
C
            OVAP(JL1+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL1+IBAS) = DCONJG(OVAP(IL1+IBAS,JL2+JBAS))
            OVAP(JL1+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL1+JBAS))
            OVAP(JL2+JBAS,IL2+IBAS) = DCONJG(OVAP(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     LL NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HNUC(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            HNUC(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            HNUC(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            HNUC(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            HNUC(JL1+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL2+JBAS))
            HNUC(JL1+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            HNUC(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            HNUC(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            HNUC(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            HNUC(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            HNUC(JL1+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL1+IBAS) = DCONJG(HNUC(IL1+IBAS,JL2+JBAS))
            HNUC(JL1+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL1+JBAS))
            HNUC(JL2+JBAS,IL2+IBAS) = DCONJG(HNUC(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC HAMILTONIAN HAS A KINETIC MATRIX IN THE LL BLOCK
      IF(HMLT.EQ.'NORL') THEN
C
C       LL KINETIC BLOCKS
        IF(IL1.GT.JL1) THEN
          DO JBAS=1,NBAS(2)
            DO IBAS=1,NBAS(1)
              HKIN(IL1+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,1)
              HKIN(IL1+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,2)
              HKIN(IL2+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,3)
              HKIN(IL2+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,4)
C
              HKIN(JL1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL2+JBAS))
              HKIN(JL1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL2+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
        IF(IL1.EQ.JL1) THEN
          DO JBAS=1,NBAS(2)
            DO IBAS=JBAS,NBAS(1)
              HKIN(IL1+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,1)
              HKIN(IL1+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,2)
              HKIN(IL2+IBAS,JL1+JBAS) = TLL(IBAS,JBAS,3)
              HKIN(IL2+IBAS,JL2+JBAS) = TLL(IBAS,JBAS,4)
C
              HKIN(JL1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JL2+JBAS))
              HKIN(JL1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL1+JBAS))
              HKIN(JL2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JL2+JBAS))
            ENDDO
          ENDDO
        ENDIF
C
C       NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
        GOTO 600
C
      ENDIF
C
C     SS OVERLAP BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            OVAP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVAP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVAP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVAP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
C
            OVAP(JS1+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS2+JBAS))
            OVAP(JS1+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            OVAP(IS1+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,1)
            OVAP(IS1+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,2)
            OVAP(IS2+IBAS,JS1+JBAS) = SSS(IBAS,JBAS,3)
            OVAP(IS2+IBAS,JS2+JBAS) = SSS(IBAS,JBAS,4)
C
            OVAP(JS1+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS1+IBAS) = DCONJG(OVAP(IS1+IBAS,JS2+JBAS))
            OVAP(JS1+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS1+JBAS))
            OVAP(JS2+JBAS,IS2+IBAS) = DCONJG(OVAP(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SS NUCLEAR POTENTIAL BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HNUC(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            HNUC(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            HNUC(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            HNUC(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            HNUC(JS1+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS2+JBAS))
            HNUC(JS1+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            HNUC(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            HNUC(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            HNUC(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            HNUC(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            HNUC(JS1+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS1+IBAS) = DCONJG(HNUC(IS1+IBAS,JS2+JBAS))
            HNUC(JS1+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS1+JBAS))
            HNUC(JS2+JBAS,IS2+IBAS) = DCONJG(HNUC(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     LS BLOCKS
      IF(IL1.GE.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HKIN(IL1+IBAS,JS1+JBAS) = TLS(IBAS,JBAS,1)
            HKIN(IL1+IBAS,JS2+JBAS) = TLS(IBAS,JBAS,2)
            HKIN(IL2+IBAS,JS1+JBAS) = TLS(IBAS,JBAS,3)
            HKIN(IL2+IBAS,JS2+JBAS) = TLS(IBAS,JBAS,4)
C
            HKIN(JS1+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JS1+JBAS))
            HKIN(JS2+JBAS,IL1+IBAS) = DCONJG(HKIN(IL1+IBAS,JS2+JBAS))
            HKIN(JS1+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JS1+JBAS))
            HKIN(JS2+JBAS,IL2+IBAS) = DCONJG(HKIN(IL2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     SL BLOCKS
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            HKIN(IS1+IBAS,JL1+JBAS) = TSL(IBAS,JBAS,1)
            HKIN(IS1+IBAS,JL2+JBAS) = TSL(IBAS,JBAS,2)
            HKIN(IS2+IBAS,JL1+JBAS) = TSL(IBAS,JBAS,3)
            HKIN(IS2+IBAS,JL2+JBAS) = TSL(IBAS,JBAS,4)
C
            HKIN(JL1+JBAS,IS1+IBAS) = DCONJG(HKIN(IS1+IBAS,JL1+JBAS))
            HKIN(JL2+JBAS,IS1+IBAS) = DCONJG(HKIN(IS1+IBAS,JL2+JBAS))
            HKIN(JL1+JBAS,IS2+IBAS) = DCONJG(HKIN(IS2+IBAS,JL1+JBAS))
            HKIN(JL2+JBAS,IS2+IBAS) = DCONJG(HKIN(IS2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
C     END LOOPS OVER BASIS PAIRS A,B
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE UEHLING
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       UU    UU EEEEEEEE HH    HH LL      IIII NN    NN  GGGGGG       C
C       UU    UU EE       HH    HH LL       II  NNN   NN GG    GG      C
C       UU    UU EE       HH    HH LL       II  NNNN  NN GG            C
C       UU    UU EEEEEE   HHHHHHHH LL       II  NN NN NN GG            C
C       UU    UU EE       HH    HH LL       II  NN  NNNN GG   GGG      C
C       UU    UU EE       HH    HH LL       II  NN   NNN GG    GG      C
C        UUUUUU  EEEEEEEE HH    HH LLLLLLL IIII NN    NN  GGGGGG       C
C                                                                      C
C -------------------------------------------------------------------- C
C  UEHLING CONSTRUCTS A FULL SET OF MULTI-CENTRE UEHLING INTERACTION   C
C  MATRIX ELEMENTS.                                                    C
C -------------------------------------------------------------------- C
C  DFNOTE: AT THE MOMENT THIS IS JUST A COPY OF THE ONEEL NUCLEAR      C
C          ATTRACTION MATRIX MAKER.                                    C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLT
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CTMP1,CTMP2,CTMP3,CTMP4
      COMPLEX*16 E11A,E11B,E11C,TRM11,E21A,E21B,E21C,TRM21
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VLL(MBS,MBS,4),VSS(MBS,MBS,4)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/DENS/DENC,DENO,DENT
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     INITIALISE STORAGE MATRIX
      DO I=1,NDIM
        DO J=1,NDIM
          VUEH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON MATRICES BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     INITIALISE STORAGE ARRAYS
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          DO IB=1,4
            VLL(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
            VSS(IBAS,JBAS,IB) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     PART 1: THE LL MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)
      NTUVLL = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ELL0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVLL
          IAD = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            ESM = CNUC(IZ)+EIJ
            PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
            APH(M) = EIJ*CNUC(IZ)/ESM
            PNC(M) = 2.0D0*PI*DSQRT(CNUC(IZ)/ESM)*ZNUC(IZ)/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXAB,LAM)
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUME OF ELL0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVLL
              VLL(IBAS,JBAS,1) = VLL(IBAS,JBAS,1)
     &                         - PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VLL(IBAS,JBAS,3) = VLL(IBAS,JBAS,3)
     &                         - PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
            VLL(IBAS,JBAS,2) =-PHS*DCONJG(VLL(IBAS,JBAS,3))
            VLL(IBAS,JBAS,4) = PHS*DCONJG(VLL(IBAS,JBAS,1))
          ENDDO
        ENDDO
      ENDDO
C
C     NON-RELATIVISTIC CALCULATIONS ARE COMPLETE
      IF(HMLT.EQ.'NORL') GOTO 500
C
C**********************************************************************C
C     PART 2: THE SS MATRICES                                          C
C**********************************************************************C
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAM    = LQN(1)+LQN(2)+2
      NTUVSS = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GENERATE ESS0 COEFFICIENTS (IPHS = +1)
      CALL CPU_TIME(TDM1)
      IF(IEQS.EQ.0) THEN
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVSS
          IAD = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            E11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
            E21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
          ENDDO
        ENDDO
      ENDIF
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
C     NUCLEAR ATTRACTION MATRIX ELEMENTS
      DO IZ=1,NCNT
C
C       NUCLEAR COORDINATES
        CX = BXYZ(1,IZ)
        CY = BXYZ(2,IZ)
        CZ = BXYZ(3,IZ)
C
C       GAUSSIAN PRODUCT THEOREM OVER BASIS FUNCTIONS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M   = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            ESM = CNUC(IZ) + EIJ
            PX  = (XYZ(1,1)*EXPT(IBAS,1) + XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1) + XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1) + XYZ(3,2)*EXPT(JBAS,2))/EIJ
            APH(M) = (EIJ*CNUC(IZ))/ESM
            PNC(M) = 2.0D0*PI*DSQRT(CNUC(IZ)/ESM)*ZNUC(IZ)/EIJ
            CP(M,1) = CX-PX
            CP(M,2) = CY-PY
            CP(M,3) = CZ-PZ
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,MAXAB,LAM)
        CALL CPU_TIME(TDM2)
        TRSS = TRSS + TDM2 - TDM1
C
C       NUCLEAR ATTRACTION INTEGRALS AS A FINITE SUME OF ELL0 AND RC
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            DO ITUV=1,NTUVSS
              VSS(IBAS,JBAS,1) = VSS(IBAS,JBAS,1)
     &                           + PNC(M)*E11(M,ITUV)*RC(M,ITUV)
              VSS(IBAS,JBAS,3) = VSS(IBAS,JBAS,3)
     &                           + PNC(M)*E21(M,ITUV)*RC(M,ITUV)
            ENDDO
            VSS(IBAS,JBAS,2) =-PHS*DCONJG(VSS(IBAS,JBAS,3))
            VSS(IBAS,JBAS,4) = PHS*DCONJG(VSS(IBAS,JBAS,1))
          ENDDO
        ENDDO
      ENDDO
C
500   CONTINUE
C
C**********************************************************************C
C     WE NOW HAVE ALL PIECES OF VUEH FOR THIS BLOCK.                   C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      IL1 = LRGE(ICNTA,KA,MJA  )
      IL2 = LRGE(ICNTA,KA,MJA+1)
      JL1 = LRGE(ICNTB,KB,MJB  )
      JL2 = LRGE(ICNTB,KB,MJB+1)
C
      IS1 = IL1+NSKP
      IS2 = IL2+NSKP
      JS1 = JL1+NSKP
      JS2 = JL2+NSKP
C
C     LL UEHLING INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VUEH(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VUEH(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VUEH(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VUEH(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VUEH(JL1+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL2+JBAS))
            VUEH(JL1+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VUEH(IL1+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,1)
            VUEH(IL1+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,2)
            VUEH(IL2+IBAS,JL1+JBAS) = VLL(IBAS,JBAS,3)
            VUEH(IL2+IBAS,JL2+JBAS) = VLL(IBAS,JBAS,4)
C
            VUEH(JL1+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL1+IBAS) = DCONJG(VUEH(IL1+IBAS,JL2+JBAS))
            VUEH(JL1+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL1+JBAS))
            VUEH(JL2+JBAS,IL2+IBAS) = DCONJG(VUEH(IL2+IBAS,JL2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
C     NON-RELATIVISTIC MATRIX CONSTRUCTION COMPLETE
      GOTO 600
C
C     SS UEHLING INTERACTION BLOCK
      IF(IL1.GT.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=1,NBAS(1)
            VUEH(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VUEH(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VUEH(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VUEH(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VUEH(JS1+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS2+JBAS))
            VUEH(JS1+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
      IF(IL1.EQ.JL1) THEN
        DO JBAS=1,NBAS(2)
          DO IBAS=JBAS,NBAS(1)
            VUEH(IS1+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,1)
            VUEH(IS1+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,2)
            VUEH(IS2+IBAS,JS1+JBAS) = VSS(IBAS,JBAS,3)
            VUEH(IS2+IBAS,JS2+JBAS) = VSS(IBAS,JBAS,4)
C
            VUEH(JS1+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS1+IBAS) = DCONJG(VUEH(IS1+IBAS,JS2+JBAS))
            VUEH(JS1+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS1+JBAS))
            VUEH(JS2+JBAS,IS2+IBAS) = DCONJG(VUEH(IS2+IBAS,JS2+JBAS))
          ENDDO
        ENDDO
      ENDIF
C
600   CONTINUE
C
C     END LOOPS OVER BASIS PAIRS A,B
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE COULOMB
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    CCCCCC   OOOOOO  UU    UU LL      OOOOOO  MM       MM BBBBBBB     C
C   CC    CC OO    OO UU    UU LL     OO    OO MMM     MMM BB    BB    C
C   CC       OO    OO UU    UU LL     OO    OO MMMM   MMMM BB    BB    C
C   CC       OO    OO UU    UU LL     OO    OO MM MM MM MM BBBBBBB     C
C   CC       OO    OO UU    UU LL     OO    OO MM  MMM  MM BB    BB    C
C   CC    CC OO    OO UU    UU LL     OO    OO MM   M   MM BB    BB    C
C    CCCCCC   OOOOOO   UUUUUU  LLLLLLL OOOOOO  MM       MM BBBBBBB     C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB GENERATES ALL MANY-CENTRE ELECTRON REPULSION INTEGRALS IN   C
C  BATCHES AND ADDS THEM TO THE SCF CLOSED/OPEN-SHELL COULOMB MATRIX.  C
C  CALCULATIONS ARE MADE WITH A RELATIVISTIC MCMURCHIE-DAVIDSON SCHEME.C
C -------------------------------------------------------------------- C
C  DFNOTE: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.  C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4 HMLT
      CHARACTER*8 SHAPE
C
      DIMENSION GDSC(MDM,MDM),BDSC(MDM,MDM)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-MKP:MKP,2*(MKP+1)*MKP),ICNT(4)
C
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
      COMPLEX*16 RR(MB2,16)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GEOM/SHAPE
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVIR
      COMMON/SWRZ/GDSC,BDSC
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     LINK THE OPENMP ROUTINE LIBRARY
      INCLUDE 'omp_lib.h'
C
C     SCREENING SENSITIVITY TOLERANCE
      SENS = 1.0D-12
C
C     SAVED BATCHES OF R(AB|CD) INTEGRALS IN ERI
      IF(IEQS.EQ.0) THEN
        IERC = 0
      ELSE
        IERC = 1
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     LINEAR MOLECULE SHORTCUT OPTION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          GXCH(I,J) = DCMPLX(0.0D0,0.0D0)
          QDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          QXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL ATOMIC CENTRES (USE INDEX 1000)                    C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
        ICNT(1) = ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,ICNTA
        ICNT(2) = ICNTB
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1000 ICNTC=1,NCNT
        ICNT(3) = ICNTC
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 1000 ICNTD=1,NCNT
        ICNT(4) = ICNTD
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTRE CONTRIBUTIONS
      IF(MCNT.EQ.1) THEN
        GOTO 1001
      ENDIF
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES (USE INDEX 2000)                C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = BSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = BSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| PROJECTIONS (INDEX 3000)                     C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ILIN.EQ.1) THEN
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) GOTO 3003
        GOTO 3001
      ENDIF
3003  CONTINUE
C
C**********************************************************************C
C     IDENTIFICATION OF ERI SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     CALCULATE BLOCK INDICES FOR {ABCD} COMBINATIONS
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ1.LT.IQ2) GOTO 3001
      IF(IQ3.LT.IQ4) GOTO 3001
      IF(IQL.LT.IQR) GOTO 3001
C
      IF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 1
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.GT.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 > IQ2, IQ3 > IQ4, IQL = IQR
        ITSCF = 2
      ELSEIF(IQ1.GT.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 > IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 3
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.GT.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 > IQ4, IQL > IQR
        ITSCF = 4
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.GT.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL > IQR
        ITSCF = 5
      ELSEIF(IQ1.EQ.IQ2.AND.IQ3.EQ.IQ4.AND.IQL.EQ.IQR) THEN
C       IQ1 = IQ2, IQ3 = IQ4, IQL = IQR
        ITSCF = 6
      ELSE
C       ALL OTHER CASES GENERATED BY THE ABOVE, SO SKIP
        GOTO 3001
      ENDIF
C
C     READ IN FLAG VALUES FROM ISCF DATA BLOCK
      DO ISYM=1,11
        IFLG(ISYM) = ISCF(ISYM,ITSCF)
      ENDDO
C
C     INCLUDE SPECIAL CASES FOR MATCHING BLOCKS
      IF(IQ2.EQ.IQ3) THEN
C       IQ2 = IQ3
        IF(ITSCF.EQ.1.OR.ITSCF.EQ.3.OR.ITSCF.EQ.4) THEN
          IFLG( 9) = 1
        ENDIF
      ENDIF
C
      IF(ITSCF.EQ.1) THEN
        IF(IQ1.EQ.IQ3) THEN
C         IQ1 = IQ3
          IFLG(10) = 1
        ELSEIF(IQ2.EQ.IQ4) THEN
C         IQ2 = IQ4
          IFLG(11) = 1
        ENDIF
      ENDIF
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND B: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
        NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
        NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDAB
        NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDAB
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR C AND D: T'T' = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
        NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDCD
        NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDCD
        ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDCD
        ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDCD
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = (2*IT1+IT2)/3
C
C     STAGE 1: INCLUDE ONLY (LL|LL) REPULSION INTEGRALS
      IF(ILEV.EQ.1.AND.ITT.GT.1) THEN
        GOTO 4001
      ENDIF
C
C     STAGE 2: INCLUDE ONLY (LL|SS) AND (SS|LL) REPULSION INTEGRALS
      IF(ILEV.EQ.2.AND.ITT.GT.3) THEN
        GOTO 4001
      ENDIF
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      N2EB(MCNT,ITT) = N2EB(MCNT,ITT)+1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) TO CONSTRUCT GMAT/QMAT     C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL CPU_TIME(TI)
C
C     START OF PARALLEL REGION
C!$OMP PARALLEL DO COLLAPSE(2)
C!$OMP&  PRIVATE(RR,IBCH,IFLG)
C!$OMP&  SHARED(XYZ,KQN,MQN,EXPT,NBAS,ITN)
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
          IF(ITT.GT.1.AND.ISWZ.NE.0) THEN
            ITOG = 1
          ELSE
            ITOG = 0
          ENDIF
          itog = 0
C
          CALL SCHWARZ(GDSC,SENS,TC2S)
C
C         UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
          N2EI(MCNT,ITT) = N2EI(MCNT,ITT)+NBAS(3)*NBAS(4)
          N2ES(MCNT,ITT) = N2ES(MCNT,ITT)+NBAS(3)*NBAS(4)-MAXN
C
C         CONDITIONAL TO SKIP THIS BATCH
          IF(IBCH.EQ.1) THEN
C
C           GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
            CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
C
C           MULTIPLY BY DENSITY ELEMENTS AND ADD TO GMAT/QMAT
            CALL CLMMAT(RR,IFLG,TCMC)
C
          ENDIF
C
        ENDDO
      ENDDO
C     END OF PARALLEL REGION
C!$OMP END PARALLEL DO
C
C     RECORD TIME AT END OF BATCH
      CALL CPU_TIME(TF)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + TF - TI
C
4001  CONTINUE
4000  CONTINUE
3001  CONTINUE
3000  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL MATRICES BY CONJUGATION.            C
C**********************************************************************C
C
C     LOOP OVER LOWER TRIANGLE OF EACH TT' BLOCK
      DO J=1,NDIM-NSKP
        DO I=1,J
C
C         SMALL-COMPONENT ADDRESSES
          K = I+NSKP
          L = J+NSKP
C
C         SKIP DIAGONAL PARTS OF EACH SUB-BLOCK
          IF(LABICN(I).NE.LABICN(J)) GOTO 400
          IF(LABKQN(I).NE.LABKQN(J)) GOTO 400
          IF(IABS(LABMQN(I)).NE.IABS(LABMQN(J))) GOTO 400
          GOTO 401
400       CONTINUE
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LL BLOCK
          GDIR(I,J) = GDIR(I,J) + DCONJG(GDIR(J,I))
          GDIR(J,I) =             DCONJG(GDIR(I,J))
          GXCH(I,J) = GXCH(I,J) + DCONJG(GXCH(J,I))
          GXCH(J,I) =             DCONJG(GXCH(I,J))
          QDIR(I,J) = QDIR(I,J) + DCONJG(QDIR(J,I))
          QDIR(J,I) =             DCONJG(QDIR(I,J))
          QXCH(I,J) = QXCH(I,J) + DCONJG(QXCH(J,I))
          QXCH(J,I) =             DCONJG(QXCH(I,J))
C
C         IF HMLT = 'NORL' SKIP THE NEXT FEW CALCULATIONS
          IF(HMLT.EQ.'NORL') GOTO 401
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SS BLOCK
          GDIR(K,L) = GDIR(K,L) + DCONJG(GDIR(L,K))
          GDIR(L,K) =             DCONJG(GDIR(K,L))
          GXCH(K,L) = GXCH(K,L) + DCONJG(GXCH(L,K))
          GXCH(L,K) =             DCONJG(GXCH(K,L))
          QDIR(K,L) = QDIR(K,L) + DCONJG(QDIR(L,K))
          QDIR(L,K) =             DCONJG(QDIR(K,L))
          QXCH(K,L) = QXCH(K,L) + DCONJG(QXCH(L,K))
          QXCH(L,K) =             DCONJG(QXCH(K,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF LS BLOCK
          GXCH(I,L) = GXCH(I,L) + DCONJG(GXCH(L,I))
          GXCH(L,I) =             DCONJG(GXCH(I,L))
          QXCH(I,L) = QXCH(I,L) + DCONJG(QXCH(L,I))
          QXCH(L,I) =             DCONJG(QXCH(I,L))
C
C         COMPLETE LOWER AND THEN UPPER TRIANGLE OF SL BLOCK
          GXCH(K,J) = GXCH(K,J) + DCONJG(GXCH(J,K))
          GXCH(J,K) =             DCONJG(GXCH(K,J))
          QXCH(K,J) = QXCH(K,J) + DCONJG(QXCH(J,K))
          QXCH(J,K) =             DCONJG(QXCH(K,J))
C
401       CONTINUE
        ENDDO
      ENDDO
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS
      DO J=1,NDIM
        DO I=1,NDIM
          QDIR(I,J) = ACFF*QDIR(I,J)
          QXCH(I,J) = BCFF*QXCH(I,J)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                        EEEEEEEE RRRRRRR  IIII                        C
C                        EE       RR    RR  II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEE   RR    RR  II                         C
C                        EE       RRRRRRR   II                         C
C                        EE       RR    RR  II                         C
C                        EEEEEEEE RR    RR IIII                        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    XYZ(3,4)    - COORDINATES OF THE NUCLEAR CENTRES IN THIS BLOCK.   C
C    KQN(4)      - KQN RELATIVISTIC LABELS OF THE CENTRES.             C
C    MQN(4)      - |MQN| QUANTUM NUMBERS OF THE CENTRES.               C
C    NBAS(4)     - NUMBER OF FUNCTIONS IN THE BLOCK.                   C
C    EXPT(MBS,4) - LIST OF EXPONENTS IN THE BLOCK.                     C
C    IBAS,JBAS   - COMPONENT LABEL INDEX FOR AB BASIS FUNCTIONS.       C
C    ITN(2)      - COMPONENT OVERLAP (T,T') FOR EACH PAIR AB AND CD.   C
C                  ITN(I) = {LL,LS,SL,SS}.                             C
C  OUTPUT:                                                             C
C    RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLT
      CHARACTER*8 SHAPE
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MEQ),IABR21(MEQ),IABI11(MEQ),IABI21(MEQ)
      DIMENSION ICDR11(MEQ),ICDR21(MEQ),ICDI11(MEQ),ICDI21(MEQ)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ),ECD11(MB2,MEQ),
     &           EAB21(MB2,MEQ),ECD21(MB2,MEQ)
C
      SAVE EAB11,EAB21,IABR11,IABI11,IABR21,IABI21
      SAVE ECD11,ECD21,ICDR11,ICDI11,ICDR21,ICDI21
      SAVE RCTTFL,IRCTTFL
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GEOM/SHAPE
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      DATA ROOTPI5,SENS/17.4934183276248628D0,1.0D-10/
C
C     LINEAR MOLECULE SKIP CONDITION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C     ILLEGAL COMPONENT OVERLAP CHECKER
      DO IT=1,2
        IF(ITN(IT).NE.1.AND.ITN(IT).NE.4) THEN
          WRITE(6, *) 'In ERI: illegal component overlaps in ITN.'
          WRITE(7, *) 'In ERI: illegal component overlaps in ITN.'
          STOP
        ENDIF
      ENDDO
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS A, B, C, D
      DO N=1,4
        IF(KQN(N).LT.0) THEN
          LQN(N) =-KQN(N)-1
        ELSE
          LQN(N) = KQN(N)
        ENDIF
      ENDDO
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTORS FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ(AB)-COEFFICIENTS
      IF(ITN(1).EQ.1) THEN
        LAMAB = LQN(1)+LQN(2)
      ELSEIF(ITN(1).EQ.4) THEN
        LAMAB = LQN(1)+LQN(2)+2
      ENDIF
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ(CD)-COEFFICIENTS
      IF(ITN(2).EQ.1) THEN
        LAMCD = LQN(3)+LQN(4)
      ELSEIF(ITN(2).EQ.4) THEN
        LAMCD = LQN(3)+LQN(4)+2
      ENDIF
C
C     VRS MAXIMUM LAMBDA LEVEL FOR CONTRACTED R-INTEGRAL BATCH
      LAMABCD = LAMAB+LAMCD
C
C     VRS MAXIMUM LAMBDA LEVEL FOR RCTTFL SAVED LIST (ONLY IF MCNT.GT.2)
      IF(IERC.EQ.0.OR.HMLT.EQ.'NORL') THEN
        LAMABCDFL = LAMABCD
      ELSEIF(IERC.EQ.1.AND.HMLT.NE.'NORL') THEN
        IF(ILEV.EQ.1) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)
        ELSEIF(ILEV.EQ.2) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+2
        ELSEIF(ILEV.EQ.3) THEN
          LAMABCDFL = LQN(1)+LQN(2)+LQN(3)+LQN(4)+4
        ENDIF
      ENDIF
C
C     VRS TOTAL LENGTH OF EQ-COEFFICIENT LISTS AND R-INTEGRAL BATCH
      NTUVAB     = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD     = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD   = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
      NTUVABCDFL = (LAMABCDFL+1)*(LAMABCDFL+2)*(LAMABCDFL+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ  = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
C
C     INITIALISE RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(IEQS.EQ.1) THEN
        IF(ITN(1).EQ.1) THEN
          DO ITUV=1,NTUVAB
            IAD = IABLL + (ITUV-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,1),E0LLFL(IAD+M,2))
              EAB21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,3),E0LLFL(IAD+M,4))
            ENDDO
          ENDDO
        ELSEIF(ITN(1).EQ.4) THEN
          DO ITUV=1,NTUVAB
            IAD = IABSS + (ITUV-1)*MAXAB
            DO M=1,MAXAB
              EAB11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,1),E0SSFL(IAD+M,2))
              EAB21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,3),E0SSFL(IAD+M,4))
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      IF(IEQS.EQ.0) THEN
        IF(ITN(1).EQ.1) THEN
          CALL EMAKELL(EAB11,EAB21,EXPT,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ELSEIF(ITN(1).EQ.4) THEN
          CALL EMAKESS(EAB11,EAB21,EXPT,XYZ,KQN,MQN,NBAS,IPHSAB,1,2,0)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.1) THEN
        TELL = TELL+TDM2-TDM1
      ELSEIF(ITN(1).EQ.4) THEN
        TESS = TESS+TDM2-TDM1
      ENDIF
C
C     SCREENING: TEST E(AB| -) COLUMNS OF CARTESIAN INDEX (T ,U ,V )
      DO IAB=1,NTUVAB
C
C       Re{E(AB|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          ERAB11 = DREAL(EAB11(M,IAB))
          SUM = SUM + DABS(ERAB11)
          IF(SUM.GT.SENS) THEN
            IABR11(IAB) = 1
            GOTO 101
          ENDIF
        ENDDO
        IABR11(IAB) = 0
101     CONTINUE
C
C       Im{E(AB|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          EIAB11 = DIMAG(EAB11(M,IAB))
          SUM = SUM + DABS(EIAB11)
          IF(SUM.GT.SENS) THEN
            IABI11(IAB) = 1
            GOTO 102
          ENDIF
        ENDDO
        IABI11(IAB) = 0
102     CONTINUE
C
C       Re{E(AB|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          ERAB21 = DREAL(EAB21(M,IAB))
          SUM = SUM + DABS(ERAB21)
          IF(SUM.GT.SENS) THEN
            IABR21(IAB) = 1
            GOTO 103
          ENDIF
        ENDDO
        IABR21(IAB) = 0
103     CONTINUE
C
C       Im{E(AB|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXAB
          EIAB21 = DIMAG(EAB21(M,IAB))
          SUM = SUM + DABS(EIAB21)
          IF(SUM.GT.SENS) THEN
            IABI21(IAB) = 1
            GOTO 104
          ENDIF
        ENDDO
        IABI21(IAB) = 0
104     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     OPTION 1: READ FROM LOCAL EQ-COEFFICIENT FILE
      IF(IEQS.EQ.1) THEN
        IF(ITN(2).EQ.1) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDLL + (ITUV-1)*MAXCD
            DO M=1,MAXCD
              ECD11(M,ITUV) = DCMPLX(E0LLFL(IAD+M,5),E0LLFL(IAD+M,6))
              ECD21(M,ITUV) = DCMPLX(E0LLFL(IAD+M,7),E0LLFL(IAD+M,8))
            ENDDO
          ENDDO
        ELSEIF(ITN(2).EQ.4) THEN
          DO ITUV=1,NTUVCD
            IAD = ICDSS + (ITUV-1)*MAXCD
            DO M=1,MAXCD
              ECD11(M,ITUV) = DCMPLX(E0SSFL(IAD+M,5),E0SSFL(IAD+M,6))
              ECD21(M,ITUV) = DCMPLX(E0SSFL(IAD+M,7),E0SSFL(IAD+M,8))
            ENDDO
          ENDDO
        ENDIF
      ENDIF
C
C     OPTION 2: CALCULATE FROM SCRATCH
      IF(IEQS.EQ.0) THEN
        IF(ITN(2).EQ.1) THEN
          CALL EMAKELL(ECD11,ECD21,EXPT,XYZ,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ELSEIF(ITN(2).EQ.4) THEN
          CALL EMAKESS(ECD11,ECD21,EXPT,XYZ,KQN,MQN,NBAS,IPHSCD,3,4,0)
        ENDIF
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      IF(ITN(2).EQ.1) THEN
        TELL = TELL+TDM2-TDM1
      ELSEIF(ITN(2).EQ.4) THEN
        TESS = TESS+TDM2-TDM1
      ENDIF
C
C     SCREENING: TEST E(CD| -) COLUMNS OF CARTESIAN INDEX (T',U',V')
      DO ICD=1,NTUVCD
C
C       Re{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          ERCD11 = DREAL(ECD11(M,ICD))
          SUM = SUM + DABS(ERCD11)
          IF(SUM.GT.SENS) THEN
            ICDR11(ICD) = 1
            GOTO 201
          ENDIF
        ENDDO
        ICDR11(ICD) = 0
201     CONTINUE
C
C       Im{E(CD|--)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          EICD11 = DIMAG(ECD11(M,ICD))
          SUM = SUM + DABS(EICD11)
          IF(SUM.GT.SENS) THEN
            ICDI11(ICD) = 1
            GOTO 202
          ENDIF
        ENDDO
        ICDI11(ICD) = 0
202     CONTINUE
C
C       Re{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          ERCD21 = DREAL(ECD21(M,ICD))
          SUM = SUM + DABS(ERCD21)
          IF(SUM.GT.SENS) THEN
            ICDR21(ICD) = 1
            GOTO 203
          ENDIF
        ENDDO
        ICDR21(ICD) = 0
203     CONTINUE
C
C       Im{E(CD|+-)} COEFFICIENTS
        SUM = 0.0D0
        DO M=1,MAXCD
          EICD21 = DIMAG(ECD21(M,ICD))
          SUM = SUM + DABS(EICD21)
          IF(SUM.GT.SENS) THEN
            ICDI21(ICD) = 1
            GOTO 204
          ENDIF
        ENDDO
        ICDI21(ICD) = 0
204     CONTINUE
C
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL CPU_TIME(T2)
      TCEC = TCEC + T2 - T1
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) FROM SCRATCH OR READ-IN          C
C**********************************************************************C
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     READ FROM LOCAL RC(AB|CD) FILE
      IF(IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.0) THEN
C
        CALL CPU_TIME(T1)
C
C       STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
        IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCDFL
C
C       READ RC(AB|CD) INTEGRALS FROM THIS STARTING POINT
        DO N=1,MAXN
          DO IABCD=1,NTUVABCD
            IAD = IADRTT + (IMAP(N)-1)*NTUVABCDFL + IABCD
            RC(N,IABCD) = RCTTFL(IAD)
          ENDDO
        ENDDO
C
C       STARTING ADDRESS FOR SCREENING FLAGS
        IADSCR = (IJ-1)*NTUVABCDFL
C
C       READ SCREENING FLAGS FROM THIS STARTING POINT
        DO IABCD=1,NTUVABCD
          IAD = IADSCR + IABCD
          IRC(IABCD) = IRCTTFL(IAD)
        ENDDO
C
C       RECORD TIME SPENT READING R-INTEGRALS
        CALL CPU_TIME(T2)
        TCRR = TCRR+T2-T1
C
C       NORMALISATION FACTORS FOR THIS BATCH
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.1) THEN
              N   = N+1
              EKL = EXPT(KBAS,3)+EXPT(LBAS,4)
              EMX = DSQRT(EIJ+EKL)*EIJ*EKL
              PRE(N) = 2.0D0*ROOTPI5/EMX
            ENDIF
          ENDDO
        ENDDO
C
      ENDIF
C
C     CALCULATE FROM SCRATCH
      IF(IERC.EQ.0.OR.IRIJ(IBAS,JBAS).EQ.1) THEN
C
        CALL CPU_TIME(T1)
C
C       GAUSSIAN OVERLAP CENTRE
        PX = (XYZ(1,1)*EXPT(IBAS,1)+XYZ(1,2)*EXPT(JBAS,2))/EIJ
        PY = (XYZ(2,1)*EXPT(IBAS,1)+XYZ(2,2)*EXPT(JBAS,2))/EIJ
        PZ = (XYZ(3,1)*EXPT(IBAS,1)+XYZ(3,2)*EXPT(JBAS,2))/EIJ
C
C       AUXILLIARY DATA FOR RMAKE ROUTINE
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF((IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.1)
     &                           .OR.(IERC.EQ.0.AND.ISCR(M).EQ.1)) THEN
              N   = N+1
              EKL = EXPT(KBAS,3)+EXPT(LBAS,4)
              EMX = DSQRT(EIJ+EKL)*EIJ*EKL
              APH(N) = EIJ*EKL/(EIJ+EKL)
              PRE(N) = 2.0D0*ROOTPI5/EMX
              QX = (XYZ(1,3)*EXPT(KBAS,3)+XYZ(1,4)*EXPT(LBAS,4))/EKL
              QY = (XYZ(2,3)*EXPT(KBAS,3)+XYZ(2,4)*EXPT(LBAS,4))/EKL
              QZ = (XYZ(3,3)*EXPT(KBAS,3)+XYZ(3,4)*EXPT(LBAS,4))/EKL
              PQ(N,1) = QX-PX
              PQ(N,2) = QY-PY
              PQ(N,3) = QZ-PZ
            ENDIF
          ENDDO
        ENDDO
C
C       EXTEND MAXN IF GENERATING A FULL SET OF INTEGRALS
        MAXN = MAXCD
C
C       GENERATE R-INTEGRALS
        CALL RMAKE(RC,PQ,APH,MAXN,LAMABCDFL)
C
C       SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
        DO IABCDFL=1,NTUVABCDFL
C
C         SUM OF RC(AB|CD) MAGNITUDES
          SUM = 0.0D0
          DO N=1,MAXN
            SUM = SUM + DABS(RC(N,IABCDFL))
            IF(SUM.GT.SENS) THEN
              IRC(IABCDFL) = 1
              GOTO 301
            ENDIF
          ENDDO
          IRC(IABCDFL) = 0
301       CONTINUE
C
        ENDDO
C
C       SAVE THIS SET TO APPROPRIATE CLASS ADDRESS
        IF(IERC.EQ.1) THEN
C
C         TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
          ILIM = IJ*NBAS(3)*NBAS(4)*NTUVABCDFL
C
          IF(ILIM.GT.20*MFL) THEN
C           OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
            WRITE(6, *) 'In ERI: RCTT words exceed allocated limit.'
            WRITE(7, *) 'In ERI: RCTT words exceed allocated limit.'
            GOTO 300
          ELSE
C           DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
            IRIJ(IBAS,JBAS) = 0
          ENDIF
C
C         STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
          IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCDFL

C         COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
          DO N=1,MAXN
            DO IABCDFL=1,NTUVABCDFL
              IAD = IADRTT + (N-1)*NTUVABCDFL + IABCDFL
              RCTTFL(IAD)  = RC(N,IABCDFL)
            ENDDO
          ENDDO
C
C         STARTING ADDRESS FOR SCREENING FLAGS
          IADSCR = (IJ-1)*NTUVABCDFL
C
C         COPY SCREENING MARKERS TO A SAVED LIST
          DO IABCDFL=1,NTUVABCDFL
            IAD = IADSCR + IABCDFL
            IRCTTFL(IAD) = IRC(IABCDFL)
          ENDDO
C
C         SHORTEN THE CURRENT RC LIST WITH IMAP FROM SCREENING
          M = 0
          N = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              IF(ISCR(M).EQ.1) THEN
                N      = N+1
                PRE(N) = PRE(M)
                DO IABCD=1,NTUVABCD
                  RC(N,IABCD) = RC(M,IABCD)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
C
        ENDIF
300     CONTINUE
C
        CALL CPU_TIME(T2)
        TCRM = TCRM+T2-T1
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL CPU_TIME(TDM2)
      IF(ITN(1).EQ.1.AND.ITN(2).EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITN(1).EQ.4.AND.ITN(2).EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ELSE
        TRLS = TRLS+TDM2-TDM1
      ENDIF
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     TIME AT START OF FIRST CONTRACTION
      CALL CPU_TIME(T1)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) PASSES SCREENING CONDITION
        IF(IABR11(IAB)+IABI11(IAB)+IABR21(IAB)+IABI21(IAB).EQ.0) THEN
          GOTO 401
        ENDIF
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO ICD=1,NTUVCD
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = INABCD(IVEC(IAB)+IVEC(ICD),JVEC(IAB)+JVEC(ICD),
     &                                             KVEC(IAB)+KVEC(ICD))
C
C         SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
          IF(IRC(IRABCD).EQ.0) GOTO 402
C
C         SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
          IF(ICDR11(ICD)+ICDI11(ICD)+ICDR21(ICD)+ICDI21(ICD).EQ.0) THEN
            GOTO 402
          ENDIF
C
C         CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
          IF(ILIN.EQ.1.AND.IABR11(IAB).EQ.0) GOTO 411
          IF(ICDR11(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                         + DREAL(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
411       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
          IF(ILIN.EQ.1.AND.IABI11(IAB).EQ.0) GOTO 412
          IF(ICDI11(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                         + DIMAG(ECD11(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
412       CONTINUE
C
C         CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
          IF(ILIN.EQ.1.AND.IABR21(IAB).EQ.0) GOTO 413
          IF(ICDR21(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                         + DREAL(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
413       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
          IF(ILIN.EQ.1.AND.IABI21(IAB).EQ.0) GOTO 414
          IF(ICDI21(ICD).EQ.1) THEN
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                         + DIMAG(ECD21(IMAP(N),ICD))*RC(N,IRABCD)
            ENDDO
          ENDIF
414       CONTINUE
C
C         SKIP POINT FOR RC(AB|CD) SCREENING
402       CONTINUE
C
C       END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
        ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION
      CALL CPU_TIME(T2)
      TCC1 = TCC1+T2-T1
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB = ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD = ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 1) =     PRE(N)*DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 4) = PCD*PRE(N)*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,16) = PABCD*DCONJG(RR(N, 1))
        RR(N,13) = PABCD*DCONJG(RR(N, 4))
      ENDDO
C
      IF(ILIN.EQ.1) GOTO 501
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 3) =     PRE(N)*DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N, 2) =-PCD*PRE(N)*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N,14) =-PABCD*DCONJG(RR(N, 3))
        RR(N,15) =-PABCD*DCONJG(RR(N, 2))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N, 9) =     PRE(N)*DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = PCD*PRE(N)*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 8) =-PABCD*DCONJG(RR(N, 9))
        RR(N, 5) =-PABCD*DCONJG(RR(N,12))
      ENDDO
C
501   CONTINUE
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB).EQ.1) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     APPLY PHASE RELATIONS AND NORMALISATION FACTORS TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) =     PRE(N)*DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) =-PCD*PRE(N)*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
        RR(N, 6) = PABCD*DCONJG(RR(N,11))
        RR(N, 7) = PABCD*DCONJG(RR(N,10))
      ENDDO
C
C     TIME AT END OF SECOND CONTRACTION
      CALL CPU_TIME(T3)
      TCC2 = TCC2+T3-T2
C
C**********************************************************************C
C     COULOMB INTEGRAL BATCH NOW FULLY CONSTRUCTED                     C
C**********************************************************************C
C
      RETURN
      END
C
C
      SUBROUTINE CLMMAT(RR,IFLG,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       CCCCCC  LL       MM       MM MM       MM    AA   TTTTTTTT      C
C      CC    CC LL       MMM     MMM MMM     MMM   AAAA     TT         C
C      CC       LL       MMMM   MMMM MMMM   MMMM  AA  AA    TT         C
C      CC       LL       MM MM MM MM MM MM MM MM AA    AA   TT         C
C      CC       LL       MM  MMM  MM MM  MMM  MM AAAAAAAA   TT         C
C      CC    CC LL       MM   M   MM MM   M   MM AA    AA   TT         C
C       CCCCCC  LLLLLLLL MM       MM MM       MM AA    AA   TT         C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLMMAT MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF COULOMB MATRICES.     C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO ERI):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C    NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C    IFLG(11)   - INTEGRAL SYMMETRY FLAGS.                             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9)
C
      DIMENSION IFLG(11),NBAS(4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS...                                    C
C**********************************************************************C
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 101
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 101
C
            GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENC(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENC(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENC(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENC(NC2+KBAS,ND2+LBAS)
C
101         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 102
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 102
C
              GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENC(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENC(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENC(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENC(ND2+LBAS,NC2+KBAS)
C
102         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 103
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 103
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENC(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENC(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENC(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENC(NA2+IBAS,NB2+JBAS)
C
103         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 104
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 104
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENC(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENC(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NB2+JBAS,NA2+IBAS)
C
104         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 105
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 105
C
            GXCH(NA1+IBAS,ND1+LBAS) = GXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENC(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND2+LBAS) = GXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENC(NC2+KBAS,NB2+JBAS)
C
105         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 106
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 106
C
            GXCH(NA1+IBAS,NC1+KBAS) = GXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENC(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC2+KBAS) = GXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENC(ND2+LBAS,NB2+JBAS)
C
106         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 107
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 107
C
            GXCH(NB1+JBAS,ND1+LBAS) = GXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND2+LBAS) = GXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NC2+KBAS,NA2+IBAS)
C
107         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 108
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 108
C
            GXCH(NB1+JBAS,NC1+KBAS) = GXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENC(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC2+KBAS) = GXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENC(ND2+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENC(ND1+LBAS,NA1+IBAS)
C
108         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 109
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 109
C
            GXCH(NC1+KBAS,NB1+JBAS) = GXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENC(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB2+JBAS) = GXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENC(NA2+IBAS,ND2+LBAS)
C
109         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 110
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 110
C
            GXCH(NC1+KBAS,NA1+IBAS) = GXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENC(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA2+IBAS) = GXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NB2+JBAS,ND2+LBAS)
C
110         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 111
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 111
C
            GXCH(ND1+LBAS,NB1+JBAS) = GXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB2+JBAS) = GXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENC(NA2+IBAS,NC2+KBAS)
111         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ILIN.EQ.1) GOTO 5002
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 201
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 201
C
            GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENC(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENC(NC2+KBAS,ND1+LBAS)
C
            GDIR(NA1+IBAS,NB2+JBAS) = GDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENC(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENC(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENC(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENC(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB1+JBAS) = GDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENC(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENC(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENC(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENC(NC2+KBAS,ND2+LBAS)
C
            GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,14)*DENC(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENC(NC2+KBAS,ND1+LBAS)
C
201         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 202
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 202
C
              GDIR(NA1+IBAS,NB1+JBAS) = GDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENC(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENC(ND2+LBAS,NC1+KBAS)
C
              GDIR(NA1+IBAS,NB2+JBAS) = GDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENC(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENC(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENC(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENC(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB1+JBAS) = GDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENC(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENC(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENC(ND2+LBAS,NC2+KBAS)
C
              GDIR(NA2+IBAS,NB2+JBAS) = GDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,14)*DENC(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENC(ND2+LBAS,NC1+KBAS)
C
202         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 203
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 203
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENC(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENC(NA2+IBAS,NB1+JBAS)
C
            GDIR(NC1+KBAS,ND2+LBAS) = GDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENC(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENC(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENC(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENC(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND1+LBAS) = GDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENC(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENC(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENC(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENC(NA2+IBAS,NB2+JBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 8)*DENC(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENC(NA2+IBAS,NB1+JBAS)
C
203         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 204
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 204
C
            GDIR(NC1+KBAS,ND1+LBAS) = GDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NB2+JBAS,NA1+IBAS)
C
            GDIR(NC1+KBAS,ND2+LBAS) = GDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENC(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENC(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND1+LBAS) = GDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENC(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENC(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NB2+JBAS,NA2+IBAS)
C
            GDIR(NC2+KBAS,ND2+LBAS) = GDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENC(NB2+JBAS,NA1+IBAS)
C
204         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 205
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 205
C
            GXCH(NA1+IBAS,ND1+LBAS) = GXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENC(NC2+KBAS,NB1+JBAS)
C
            GXCH(NA1+IBAS,ND2+LBAS) = GXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENC(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENC(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND1+LBAS) = GXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENC(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENC(NC2+KBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,ND2+LBAS) = GXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENC(NC2+KBAS,NB1+JBAS)
C
205         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 206
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 206
C
            GXCH(NA1+IBAS,NC1+KBAS) = GXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENC(ND2+LBAS,NB1+JBAS)
C
            GXCH(NA1+IBAS,NC2+KBAS) = GXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENC(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENC(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC1+KBAS) = GXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENC(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENC(ND2+LBAS,NB2+JBAS)
C
            GXCH(NA2+IBAS,NC2+KBAS) = GXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENC(ND2+LBAS,NB1+JBAS)
C
206         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 207
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 207
C
            GXCH(NB1+JBAS,ND1+LBAS) = GXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENC(NC2+KBAS,NA1+IBAS)
C
            GXCH(NB1+JBAS,ND2+LBAS) = GXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENC(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND1+LBAS) = GXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENC(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NC2+KBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,ND2+LBAS) = GXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENC(NC2+KBAS,NA1+IBAS)
C
207         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 208
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 208
C
            GXCH(NB1+JBAS,NC1+KBAS) = GXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENC(ND2+LBAS,NA1+IBAS)
C
            GXCH(NB1+JBAS,NC2+KBAS) = GXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENC(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENC(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC1+KBAS) = GXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENC(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENC(ND2+LBAS,NA2+IBAS)
C
            GXCH(NB2+JBAS,NC2+KBAS) = GXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENC(ND2+LBAS,NA1+IBAS)
C
208         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 209
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 209
C
            GXCH(NC1+KBAS,NB1+JBAS) = GXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENC(NA2+IBAS,ND1+LBAS)
C
            GXCH(NC1+KBAS,NB2+JBAS) = GXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENC(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENC(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB1+JBAS) = GXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENC(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENC(NA2+IBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NB2+JBAS) = GXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENC(NA2+IBAS,ND1+LBAS)
C
209         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 210
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 210
C
            GXCH(NC1+KBAS,NA1+IBAS) = GXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NB2+JBAS,ND1+LBAS)
C
            GXCH(NC1+KBAS,NA2+IBAS) = GXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA1+IBAS) = GXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENC(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENC(NB2+JBAS,ND2+LBAS)
C
            GXCH(NC2+KBAS,NA2+IBAS) = GXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NB2+JBAS,ND1+LBAS)
C
210         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 211
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 211
C
            GXCH(ND1+LBAS,NB1+JBAS) = GXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENC(NA2+IBAS,NC1+KBAS)
C
            GXCH(ND1+LBAS,NB2+JBAS) = GXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENC(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENC(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB1+JBAS) = GXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENC(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENC(NA2+IBAS,NC2+KBAS)
C
            GXCH(ND2+LBAS,NB2+JBAS) = GXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENC(NA2+IBAS,NC1+KBAS)
C
211         CONTINUE
          ENDDO
        ENDDO
      ENDIF

C
5002  CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS...                                      C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5100
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 301
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 301
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,ND2+LBAS)
C
301         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 302
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 302
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NC2+KBAS)
C
302         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 303
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 303
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,NB2+JBAS)
C
303         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 304
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 304
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,NA2+IBAS)
C
304         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 305
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 305
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,NB2+JBAS)
C
305         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 306
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 306
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NB2+JBAS)
C
306         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 307
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 307
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NC2+KBAS,NA2+IBAS)
C
307         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 308
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 308
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENO(ND2+LBAS,NA2+IBAS)
C
308         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 309
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 309
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,ND2+LBAS)
C
309         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 310
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 310
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,ND2+LBAS)
C
310         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 311
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 311
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(NA2+IBAS,NC2+KBAS)
C
311         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ILIN.EQ.1) GOTO 5003
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 401
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 401
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,ND1+LBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,ND1+LBAS)
C
401        CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 402
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 402
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NC1+KBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NC1+KBAS)
C
402         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 403
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 403
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,NB1+JBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,NB1+JBAS)
C
403         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 404
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 404
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,NA1+IBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,NA1+IBAS)
C
404         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 405
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 405
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,ND2+LBAS) = QXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND1+LBAS) = QXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,NB1+JBAS)
C
405         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 406
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 406
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,NC2+KBAS) = QXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC1+KBAS) = QXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NB1+JBAS)
C
406         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 407
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 407
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NC2+KBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,ND2+LBAS) = QXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND1+LBAS) = QXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NC2+KBAS,NA1+IBAS)
C
407         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 408
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 408
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENO(ND2+LBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,NC2+KBAS) = QXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC1+KBAS) = QXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENO(ND2+LBAS,NA1+IBAS)
C
408         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 409
            N = N+1
            IF(IMTX(M,9).EQ.0) GOTO 409
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NB2+JBAS) = QXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB1+JBAS) = QXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,ND1+LBAS)
C
409         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 410
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 410
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NA2+IBAS) = QXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA1+IBAS) = QXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,ND1+LBAS)
C
410         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 411
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 411
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(NA2+IBAS,NC1+KBAS)
C
            QXCH(ND1+LBAS,NB2+JBAS) = QXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB1+JBAS) = QXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(NA2+IBAS,NC1+KBAS)
C
411         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     SKIP POINT FOR LINEAR BATCH
5003  CONTINUE
C     SKIPPING POINT FOR CLOSED SYSTEMS
5100  CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
      SUBROUTINE BREIT(ISWITCH)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C               BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT               C
C               BB    BB RR    RR EE        II     TT                  C
C               BB    BB RR    RR EE        II     TT                  C
C               BBBBBBB  RR    RR EEEEEE    II     TT                  C
C               BB    BB RRRRRRR  EE        II     TT                  C
C               BB    BB RR    RR EE        II     TT                  C
C               BBBBBBB  RR    RR EEEEEEEE IIII    TT                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT GENERATES ELECTRON INTERACTION INTEGRALS IN BATCHES AND       C
C  CALCULATES THE SCF BREIT MATRIX (B). INTEGRAL SYMMETRY IS PARTIALLY C
C  PARTIALLY EXPLOITED, BUT WITH ROOM FOR IMPROVEMENT.                 C
C  (GEOMETRIC SYMM, R-INT SYMM, E-COEFF SYMM).                         C
C -------------------------------------------------------------------- C
C  DFNOTE: THIS ROUTINE COULD BENEFIT FROM PARALLELISATION -- OPENMP.  C
C          LOOK INTO OPEN SHELL EXTENSIONS AND CASES WITH ZERO DIRECT. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4 HMLT
      CHARACTER*8 SHAPE
      CHARACTER*80 TITLE
C
      DIMENSION GDSC(MDM,MDM),BDSC(MDM,MDM)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-MKP:MKP,2*(MKP+1)*MKP),ICNT(4)
      DIMENSION BMAT(MDM,MDM)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GEOM/SHAPE
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/SWRZ/GDSC,BDSC
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     SCREENING SENSITIVITY TOLERANCE
      SENS = 1.0D-12
C
C     OVERRIDE ISCF UNTIL INTEGRAL SYMMETRIES HAVE BEEN IDENTIFIED
      DO ITSCF=1,2
        DO ISYM=1,11
          ISCF(ISYM,ITSCF) = 1
        ENDDO
      ENDDO
C
C     SKIP CASES WHEN IQL=IQR
      ISCF( 3,2) = 0
      ISCF( 4,2) = 0
      ISCF( 9,2) = 0
      ISCF(10,2) = 0
      ISCF(11,2) = 0
C
C     SAVED BATCHES OF R(AB|CD) INTEGRALS IN ERI
      IF(IEQS.EQ.0) THEN
        IERC = 0
      ELSE
        IERC = 1
      ENDIF
C
C     LINEAR MOLECULE SHORTCUT OPTION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDIR(I,J) = DCMPLX(0.0D0,0.0D0)
          BXCH(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TWO-ELECTRON COMPONENT OVERLAP INDEX
      ITT = 5
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL NUCLEAR CENTRES (USE INDEX 1000)                   C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 1000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     NUMBER OF NUCLEAR CENTRES INVOLVED IN THIS OVERLAP
      MCNT = NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
C
C     SKIP ONE-CENTRE CONTRIBUTIONS
      IF(MCNT.EQ.1.AND.ISWITCH.EQ.1) THEN
        GOTO 1001
      ENDIF
C
C     SKIP MULTI-CENTRE CONTRIBUTIONS IN STAGE 1
      IF(MCNT.NE.1.AND.ILEV.EQ.1) GOTO 1001
C
C**********************************************************************C
C     LOOP OVER ALL KQN SYMMETRY TYPES (USE INDEX 2000)                C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = BSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = BSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C     THIS UNIQUELY DEFINES A FULL SET OF RC(AB|CD) INTEGRALS -- RESET
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          IRIJ(IBAS,JBAS) = 1
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| PROJECTIONS (INDEX 3000)                     C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IEAB  = 1
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      IECD  = 1
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     MOLECULAR SELECTION RULES BASED ON MQN                           C
C**********************************************************************C
C
C     SPIN PROJECTION CONSERVED ALONG Z-AXIS FOR LINEAR MOLECULES
      IF(ILIN.EQ.1) THEN
        IF(MQN(1).EQ.MQN(2).AND.MQN(3).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(3).AND.MQN(2).EQ.MQN(4)) GOTO 3003
        IF(MQN(1).EQ.MQN(4).AND.MQN(2).EQ.MQN(3)) GOTO 3003
        GOTO 3001
      ENDIF
3003  CONTINUE
C
C**********************************************************************C
C     IDENTIFICATION OF ERI SYMMETRIES AVAILABLE TO THIS BLOCK         C
C**********************************************************************C
C
C     STARTING INDEX VALUES
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     COMBINED BLOCK INDEX IN A TWO-FUNCTION LIST
      IQL = (IQ1*(IQ1-1))/2 + IQ2
      IQR = (IQ3*(IQ3-1))/2 + IQ4
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
C     IF(IQ1.LT.IQ2) GOTO 3001
C     IF(IQ3.LT.IQ4) GOTO 3001
C
      IF(IQL.GT.IQR) THEN
C       IQL > IQR
        ITSCF = 1
      ELSEIF(IQL.EQ.IQR) THEN
C       IQL = IQR
        ITSCF = 2
      ELSEIF(IQL.LT.IQR) THEN
C       IQL < IQR
        GOTO 3001
      ENDIF
C
C     READ IN FLAG VALUES FROM ISCF DATA BLOCK
      DO ISYM=1,11
        IFLG(ISYM) = ISCF(ISYM,ITSCF)
      ENDDO
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
C     NB! OPPOSITE PHASE AS IN THE LL/SS CASE SEEN IN SCF
      PAB1 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 =-ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
      PCD1 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 =-ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C     FURTHER DEFINE STARTING ADDRESSES FOR {ABCD} BASIS OVERLAPS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)+NSKP
      NB2 = LRGE(ICNTB,KB,2*MB  )+NSKP
      NC1 = LRGE(ICNTC,KC,2*MC-1)
      NC2 = LRGE(ICNTC,KC,2*MC  )
      ND1 = LRGE(ICNTD,KD,2*MD-1)+NSKP
      ND2 = LRGE(ICNTD,KD,2*MD  )+NSKP
C
C     UPDATE COUNTER FOR NUMBER OF BLOCKS
      N2EB(MCNT,ITT) = N2EB(MCNT,ITT) + 1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) TO CONSTRUCT BMAT/WMAT     C
C**********************************************************************C
C
C     RECORD TIME AT START OF BATCH
      CALL CPU_TIME(TI)
C
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         SCHWARZ SCREENING (ECONOMIC ONLY WHEN SCREENING FRACTION BIG)
          IF(ISWZ.EQ.0) THEN
            ITOG = 0
          ENDIF
C
C         CALL THE SCREENING ROUTINE
          CALL SCHWARZ(BDSC,SENS,TB2S)
C
C         UPDATE COUNTER FOR NUMBER OF INTEGRALS AND SCREENED INTEGRALS
          N2EI(MCNT,ITT) = N2EI(MCNT,ITT)+NBAS(3)*NBAS(4)
          N2ES(MCNT,ITT) = N2ES(MCNT,ITT)+NBAS(3)*NBAS(4)-MAXN
C
C         CONDITIONAL TO SKIP THIS BATCH
          IF(IBCH.EQ.1) THEN
C
C           GENERATE A BATCH OF BREIT INTERACTION INTEGRALS
            CALL BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
C
C           MULTIPLY BY DENSITY ELEMENTS AND ADD TO BMAT/WMAT
            CALL BRTMAT(RR,IFLG,TBMC)
C
          ENDIF
C
        ENDDO
      ENDDO
C
C     RECORD TIME AT END OF BATCH
      CALL CPU_TIME(TF)
      T2ES(MCNT,ITT) = T2ES(MCNT,ITT) + TF - TI
C
3001  CONTINUE
3000  CONTINUE
2000  CONTINUE
1001  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF BREIT MATRIX BY MATRIX CONJUGATION.     C
C**********************************************************************C
C
      DO I=1,NSKP
        DO J=NSKP+1,NDIM
          BDIR(J,I) = DCONJG(BDIR(I,J))
          BXCH(J,I) = DCONJG(BXCH(I,J))
        ENDDO
      ENDDO
C
C     CALCULATION OF BREIT ENERGY
      ELLSS = 0.0D0
      ESSLL = 0.0D0
      ESLLS = 0.0D0
      ELSSL = 0.0D0
      DO IL=1,NSKP
        DO JL=1,NSKP
C
C         SMALL-COMPONENT LABELS
          IS = IL+NSKP
          JS = JL+NSKP
C
          ELLSS = ELLSS - 0.5D0*BXCH(IL,JL)*DENC(IL,JL)
          ESSLL = ESSLL - 0.5D0*BXCH(IS,JS)*DENC(IS,JS)
          ESLLS = ESLLS - 0.5D0*BXCH(IS,JL)*DENC(IS,JL)
          ELSSL = ELSSL - 0.5D0*BXCH(IL,JS)*DENC(IL,JS)
C
        ENDDO
      ENDDO
C
c      WRITE(*,*) 'E(LL|SS) = ',ELLSS
c      WRITE(*,*) 'E(SS|LL) = ',ESSLL
c      WRITE(*,*) 'E(SL|LS) = ',ESLLS
c      WRITE(*,*) 'E(LS|SL) = ',ELSSL
c      WRITE(*,*) REPEAT('-',72)
C
C
C     MULTIPLY OPEN MATRIX BY ANGULAR COEFFICIENTS (LIFTED FROM COULOMB)
C      DO J=1,NDIM
C        DO I=1,NDIM
C          WDIR(I,J) = ACFF*WDIR(I,J)
C          WXCH(I,J) = BCFF*WXCH(I,J)
C        ENDDO
C      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          BBBBBBB IIII IIII                           C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB  II   II                            C
C                          BB    BB II   II                            C
C                          BB    BB II   II                            C
C                          BBBBBBB IIII IIII                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ERI GENERATES A BATCH OF MOLECULAR ELECTRON REPULSION INTEGRALS BY  C
C  MEANS OF THE MCMURCHIE-DAVIDSION ALGORITHM (DOUBLE FINITE SUM OVER  C
C  EQ-COEFFICIENTS AND INTEGRALS OVER A PAIR OF HGTFS.)                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    XYZ(3,4)    - COORDINATES OF THE NUCLEAR CENTRES IN THIS BLOCK.   C
C    KQN(4)      - KQN RELATIVISTIC LABELS OF THE CENTRES.             C
C    MQN(4)      - |MQN| QUANTUM NUMBERS OF THE CENTRES.               C
C    NBAS(4)     - NUMBER OF FUNCTIONS IN BLOCK.                       C
C    EXPT(MBS,4) - LIST OF EXPONENTS IN THE BLOCK.                     C
C    IBAS,JBAS   - COMPONENT LABEL INDEX FOR AB BASIS FUNCTIONS.       C
C  OUTPUT:                                                             C
C    RR(MB2,16) - BII'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4 HMLT
      CHARACTER*8 SHAPE
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION PQ(MB2,3),APH(MB2),PRE(MB2),RC(MB2,MRC)
      DIMENSION IABR11(MEQ,3),IABI11(MEQ,3),IABR21(MEQ,3),IABI21(MEQ,3)
      DIMENSION ICDR11(MEQ,3),ICDI11(MEQ,3),ICDR21(MEQ,3),ICDI21(MEQ,3)
      DIMENSION IRC(MRC)
      DIMENSION RCTTFL(20*MFL),IRCTTFL(MFL)
      DIMENSION GABR11(MB2,MEQ),GABI11(MB2,MEQ),
     &          GABR21(MB2,MEQ),GABI21(MB2,MEQ)
      DIMENSION QR1(MB2),QI1(MB2),QR2(MB2),QI2(MB2)
      DIMENSION T(MB2),IDX(3),JDX(3)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 EAB11(MB2,MEQ,3),EAB21(MB2,MEQ,3),
     &           ECD11(MB2,MEQ,3),ECD21(MB2,MEQ,3)
C
      SAVE EAB11,EAB21,IABR11,IABI11,IABR21,IABI21
      SAVE ECD11,ECD21,ICDR11,ICDI11,ICD221,ICDI21
      SAVE RCTTFL,IRCTTFL
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/GEOM/SHAPE
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      DATA ROOTPI5,SENS/17.4934183276248628D0,1.0D-10/
C
C     LINEAR MOLECULE SKIP CONDITION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C     EVALUATE LQNS FOR BASIS FUNCTIONS (A,B,C,D)
      DO N=1,4
        IF(KQN(N).LT.0) THEN
         LQN(N) =-KQN(N)-1
        ELSE
         LQN(N) = KQN(N)
        ENDIF
      ENDDO
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
      MAXCD = NBAS(3)*NBAS(4)
C
C     PHASE FACTOR FOR AB AND CD PAIR OVERLAPS
      IPHSAB = 1
      IPHSCD =-1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR EQ-COEFFICIENT ADDRESSES
      LAMAB = LQN(1)+LQN(2)+1
      LAMCD = LQN(3)+LQN(4)+1
C
C     VRS MAXIMUM LAMBDA LEVEL FOR CONTRACTED R-INTEGRAL BATCH
      LAMABCD = LAMAB+LAMCD+2
C
C     VRS TOTAL LENGTH OF EQ-COEFFICIENT LISTS AND R-INTEGRAL BATCH
      NTUVAB   = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
      NTUVCD   = (LAMCD+1)*(LAMCD+2)*(LAMCD+3)/6
      NTUVABCD = (LAMABCD+1)*(LAMABCD+2)*(LAMABCD+3)/6
C
C     LIST ADDRESS FOR (AB|  ) AND GAUSSIAN EXPONENT FOR AB OVERLAP
      IJ = (IBAS-1)*NBAS(2)+JBAS
      EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
C
C     INITIALISE AND RR ARRAY
      DO M=1,MAXCD
        DO ITG=1,16
          RR(M,ITG) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(AB|  ) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
      IF(IEAB.EQ.0) GOTO 100
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
      IF(IEQS.EQ.0) THEN
       CALL EMAKEB3(EAB11,EAB21,EXPT,XYZ,KQN,MQN,NBAS,IPHSAB,1,2)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVAB
          IAD = IABLS + (ITUV-1)*MAXAB
          DO M=1,MAXAB
            EAB11(M,ITUV,1) = DCMPLX(EILSFL(IAD+M, 1),EILSFL(IAD+M, 2))
            EAB21(M,ITUV,1) = DCMPLX(EILSFL(IAD+M, 3),EILSFL(IAD+M, 4))
            EAB11(M,ITUV,2) = DCMPLX(EILSFL(IAD+M, 5),EILSFL(IAD+M, 6))
            EAB21(M,ITUV,2) = DCMPLX(EILSFL(IAD+M, 7),EILSFL(IAD+M, 8))
            EAB11(M,ITUV,3) = DCMPLX(EILSFL(IAD+M, 9),EILSFL(IAD+M,10))
            EAB21(M,ITUV,3) = DCMPLX(EILSFL(IAD+M,11),EILSFL(IAD+M,12))
          ENDDO
        ENDDO
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(AB|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     SCREENING PROCEDURE: NORM SUM OF E-COEFFICIENT LIST FOR EACH IAB
      DO ICMP=1,3
        DO IAB=1,NTUVAB
C
C         Re{E(AB|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            ER = DREAL(EAB11(M,IAB,ICMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              IABR11(IAB,ICMP) = 1
              GOTO 101
            ENDIF
          ENDDO
          IABR11(IAB,ICMP) = 0
101       CONTINUE
C
C         Im{E(AB|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            EI = DIMAG(EAB11(M,IAB,ICMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              IABI11(IAB,ICMP) = 1
              GOTO 102
            ENDIF
          ENDDO
          IABI11(IAB,ICMP) = 0
102       CONTINUE
C
C         Re{E(AB|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            ER = DREAL(EAB21(M,IAB,ICMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              IABR21(IAB,ICMP) = 1
              GOTO 103
            ENDIF
          ENDDO
          IABR21(IAB,ICMP) = 0
103       CONTINUE
C
C         Im{E(AB|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXAB
            EI = DIMAG(EAB21(M,IAB,ICMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              IABI21(IAB,ICMP) = 1
              GOTO 104
            ENDIF
          ENDDO
          IABI21(IAB,ICMP) = 0
104       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
      IEAB = 0
C
100   CONTINUE
C
C**********************************************************************C
C     GENERATE NEW BATCH OF E(CD| -) COEFFICIENTS IF PROMPTED          C
C**********************************************************************C
C
      IF(IECD.EQ.0) GOTO 200
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     GENERATE ELS(CD) COEFFICIENTS
      IF(IEQS.EQ.0) THEN
        CALL EMAKEB3(ECD11,ECD21,EXPT,XYZ,KQN,MQN,NBAS,IPHSCD,3,4)
      ELSEIF(IEQS.EQ.1) THEN
        DO ITUV=1,NTUVCD
          IAD = ICDLS + (ITUV-1)*MAXCD
          DO M=1,MAXCD
            ECD11(M,ITUV,1) = DCMPLX(EILSFL(IAD+M,13),EILSFL(IAD+M,14))
            ECD21(M,ITUV,1) = DCMPLX(EILSFL(IAD+M,15),EILSFL(IAD+M,16))
            ECD11(M,ITUV,2) = DCMPLX(EILSFL(IAD+M,17),EILSFL(IAD+M,18))
            ECD21(M,ITUV,2) = DCMPLX(EILSFL(IAD+M,19),EILSFL(IAD+M,20))
            ECD11(M,ITUV,3) = DCMPLX(EILSFL(IAD+M,21),EILSFL(IAD+M,22))
            ECD21(M,ITUV,3) = DCMPLX(EILSFL(IAD+M,23),EILSFL(IAD+M,24))
          ENDDO
        ENDDO
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE/READ THE E(CD|  ) COEFFICIENTS
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     SCREENING PROCEDURE: NORM SUM OF E-COEFFICIENT LIST FOR EACH ICD
      DO JCMP=1,3
        DO ICD=1,NTUVCD
C
C         Re{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            ER = DREAL(ECD11(M,ICD,JCMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              ICDR11(ICD,JCMP) = 1
              GOTO 201
            ENDIF
          ENDDO
          ICDR11(ICD,JCMP) = 0
201       CONTINUE
C
C         Im{E(CD|--)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            EI = DIMAG(ECD11(M,ICD,JCMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              ICDI11(ICD,JCMP) = 1
              GOTO 202
            ENDIF
          ENDDO
          ICDI11(ICD,JCMP) = 0
202       CONTINUE
C
C         Re{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            ER = DREAL(ECD21(M,ICD,JCMP))
            SUM = SUM + DABS(ER)
            IF(SUM.GT.SENS) THEN
              ICDR21(ICD,JCMP) = 1
              GOTO 203
            ENDIF
          ENDDO
          ICDR21(ICD,JCMP) = 0
203       CONTINUE
C
C         Im{E(CD|+-)} COEFFICIENTS
          SUM = 0.0D0
          DO M=1,MAXCD
            EI = DIMAG(ECD21(M,ICD,JCMP))
            SUM = SUM + DABS(EI)
            IF(SUM.GT.SENS) THEN
              ICDI21(ICD,JCMP) = 1
              GOTO 204
            ENDIF
          ENDDO
          ICDI21(ICD,JCMP) = 0
204       CONTINUE
C
        ENDDO
      ENDDO
C
C     DO NOT CALCULATE AGAIN UNTIL ASKED EXTERNALLY
      IECD = 0
C
200   CONTINUE
      CALL CPU_TIME(T2)
      TBEC = TBEC + T2 - T1
C
C**********************************************************************C
C     GENERATE NEW BATCH OF RC(AB|CD) FROM SCRATCH OR READ-IN          C
C**********************************************************************C
C
C     FACTORS NEEDED IN BOTH CASES
C
C     GAUSSIAN OVERLAP CENTRE
      PX = (XYZ(1,1)*EXPT(IBAS,1)+XYZ(1,2)*EXPT(JBAS,2))/EIJ
      PY = (XYZ(2,1)*EXPT(IBAS,1)+XYZ(2,2)*EXPT(JBAS,2))/EIJ
      PZ = (XYZ(3,1)*EXPT(IBAS,1)+XYZ(3,2)*EXPT(JBAS,2))/EIJ
C
C     AUXILLIARY DATA FOR RMAKE ROUTINE
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          IF((IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.0.AND.ISCR(M).EQ.1)
     &                    .OR.(IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.1)
     &                            .OR.(IERC.EQ.0.AND.ISCR(M).EQ.1)) THEN
            N   = N+1
            EKL = EXPT(KBAS,3)+EXPT(LBAS,4)
            QX  = (XYZ(1,3)*EXPT(KBAS,3)+XYZ(1,4)*EXPT(LBAS,4))/EKL
            QY  = (XYZ(2,3)*EXPT(KBAS,3)+XYZ(2,4)*EXPT(LBAS,4))/EKL
            QZ  = (XYZ(3,3)*EXPT(KBAS,3)+XYZ(3,4)*EXPT(LBAS,4))/EKL
            APH(N)  = EIJ*EKL/(EIJ+EKL)
            PQ(N,1) = QX-PX
            PQ(N,2) = QY-PY
            PQ(N,3) = QZ-PZ
            EMX     = DSQRT(EIJ+EKL)*EIJ*EKL
            PRE(N)  = 2.0D0*ROOTPI5/EMX
          ENDIF
        ENDDO
      ENDDO
C
C     START TIME
      CALL CPU_TIME(TDM1)
C
C     READ FROM LOCAL RC(AB|CD) FILE
      IF(IERC.EQ.1.AND.IRIJ(IBAS,JBAS).EQ.0) THEN
C
        CALL CPU_TIME(T1)
C
C       STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
        IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCD
C
C       READ RC(AB|CD) INTEGRALS FROM THIS STARTING POINT
        N = 0
        DO N=1,MAXN
          DO IABCD=1,NTUVABCD
            IAD = IADRTT + (IMAP(N)-1)*NTUVABCD + IABCD
            RC(N,IABCD) = RCTTFL(IAD)
          ENDDO
        ENDDO
C
C       STARTING ADDRESS FOR SCREENING FLAGS
        IADSCR = (IJ-1)*NTUVABCD
C
C       READ SCREENING FLAGS FROM THIS STARTING POINT
        DO IABCD=1,NTUVABCD
          IAD = IADSCR + IABCD
          IRC(IABCD) = IRCTTFL(IAD)
        ENDDO
C
C       RECORD TIME SPENT READING R-INTEGRALS
        CALL CPU_TIME(T2)
        TBRR = TBRR+T2-T1
C
      ENDIF
C
C     CALCULATE FROM SCRATCH
      IF(IERC.EQ.0.OR.IRIJ(IBAS,JBAS).EQ.1) THEN
C
        CALL CPU_TIME(T1)
C
C       GENERATE R-INTEGRALS
        CALL RMAKE(RC,PQ,APH,MAXN,LAMABCD)
C
C       SCREENING: TEST RC(AB|CD) COLUMNS WITH INDEX (T+T',U+U',V+V')
        DO IABCD=1,NTUVABCD
C
C         SUM OF RC(AB|CD) MAGNITUDES
          SUM = 0.0D0
          DO N=1,MAXN
            SUM = SUM + DABS(RC(N,IABCD))
            IF(SUM.GT.SENS) THEN
              IRC(IABCD) = 1
              GOTO 301
            ENDIF
          ENDDO
          IRC(IABCD) = 0
301       CONTINUE
C
        ENDDO
C
C       SAVE THIS SET TO APPROPRIATE CLASS ADDRESS
        IF(IERC.EQ.1) THEN
C
C         TEST WHETHER FINAL ADDRESS IS STILL INSIDE ARRAY BOUNDS
          ILIM = IJ*NBAS(3)*NBAS(4)*NTUVABCD
C
          IF(ILIM.GT.20*MFL) THEN
C           OUT OF BOUNDS: PRINT WARNING BUT KEEP GOING
            WRITE(6, *) 'In BII: RCTT words exceed allocated limit.'
            WRITE(7, *) 'In BII: RCTT words exceed allocated limit.'
            GOTO 300
          ELSE
C           DO NOT CALCULATE AGAIN UNTIL PROMPTED EXTERNALLY
            IRIJ(IBAS,JBAS) = 0
          ENDIF
C
C         STARTING ADDRESS FOR SAVED R(AB|CD) INTEGRALS
          IADRTT = (IJ-1)*NBAS(3)*NBAS(4)*NTUVABCD

C         COPY THIS BATCH OF INTEGRALS TO A SAVED LIST
          DO N=1,MAXN
            DO IABCD=1,NTUVABCD
              IAD = IADRTT + (N-1)*NTUVABCD + IABCD
              RCTTFL(IAD) = RC(N,IABCD)
            ENDDO
          ENDDO
C
C         STARTING ADDRESS FOR SCREENING FLAGS
          IADSCR = (IJ-1)*NTUVABCD
C
C         COPY SCREENING MARKERS TO A SAVED LIST
          DO IABCD=1,NTUVABCD
            IAD = IADSCR + IABCD
            IRCTTFL(IAD) = IRC(IABCD)
          ENDDO
C
C         SHORTEN THE CURRENT RC LIST WITH IMAP FROM SCREENING
          M = 0
          N = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
              IF(ISCR(M).EQ.1) THEN
                N       = N+1
                APH(N)  = APH(M)
                PQ(N,1) = PQ(M,1)
                PQ(N,2) = PQ(M,2)
                PQ(N,3) = PQ(M,3)
                PRE(N)  = PRE(M)
                DO IABCD=1,NTUVABCD
                  RC(N,IABCD) = RC(M,IABCD)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
C
C         SHORTEN MAXN
          MAXN = N
C
        ENDIF
300     CONTINUE
C
        CALL CPU_TIME(T2)
        TBRM = TBRM+T2-T1
C
      ENDIF
C
C     RECORD THE TIME TAKEN TO GENERATE THE RC(AB|CD) BATCH
      CALL CPU_TIME(TDM2)
      TRBR = TRBR+TDM2-TDM1
C
C**********************************************************************C
C     PERFORM FIRST CONTRACTION: G(AB| -) = E(CD| -)*RC(AB|CD).        C
C     THIS YIELDS ALL MQN SIGN POSSIBILITIES FOR C AND D.              C
C**********************************************************************C
C
C     LOOP OVER CARTESIAN INDEX ICMP FOR CENTRE AB (USE INDEX 6000)
      DO 6000 ICMP=1,3
C
C     TIME AT START OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T1I)
C
C     CARTESIAN INDEX ICMP AS A VECTOR, IDX
      CALL NCART(IDX,ICMP)
C
C     LOOP OVER ALL ADDRESSES FOR E(AB| -) FINITE EXPANSION
      DO IAB=1,NTUVAB
C
C       RESET CONTRACTION STORAGE ARRAYS G(AB| -)
        DO N=1,MAXN
          GABR11(N,IAB) = 0.0D0
          GABI11(N,IAB) = 0.0D0
          GABR21(N,IAB) = 0.0D0
          GABI21(N,IAB) = 0.0D0
        ENDDO
C
C       SKIP ENTIRE PROCESS IF E(AB| -) PASSES SCREENING CONDITION
        IF(IABR11(IAB,ICMP)+IABI11(IAB,ICMP)
     &                   +IABR21(IAB,ICMP)+IABI21(IAB,ICMP).EQ.0) THEN
          GOTO 401
        ENDIF
C
C       LOOP OVER ALL FINITE EXPANSION ADDRESSES FOR E(CD| -)
        DO ICD=1,NTUVCD
C
C         SPECIAL CASE: CARTESIAN INDICES ARE EQUAL {-BXX, -BYY, -BZZ}
C
C         CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
          IRABCD = INABCD(IVEC(IAB)+IVEC(ICD),JVEC(IAB)+JVEC(ICD),
     &                                             KVEC(IAB)+KVEC(ICD))
C
C         SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
          IF(IRC(IRABCD).EQ.0) GOTO 402
C
C         SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
          IF(ICDR11(ICD,ICMP)+ICDI11(ICD,ICMP)
     &                   +ICDR21(ICD,ICMP)+ICDI21(ICD,ICMP).EQ.0) THEN
            GOTO 402
          ENDIF
C
C         CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
          IF(ILIN.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 411
          IF(ICDR11(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABR11(N,IAB) = GABR11(N,IAB)
     &                    - DREAL(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
411       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
          IF(ILIN.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 412
          IF(ICDI11(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABI11(N,IAB) = GABI11(N,IAB)
     &                    - DIMAG(ECD11(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
412       CONTINUE
C
C         CONTRIBUTIONS TO Re{G(AB|+-)} FROM EACH Re{E(CD|+-)} ADDRESS
          IF(ILIN.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 413
          IF(ICDR21(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABR21(N,IAB) = GABR21(N,IAB)
     &                    - DREAL(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
413       CONTINUE
C
C         CONTRIBUTIONS TO Im{G(AB|+-)} FROM EACH Im{E(CD|+-)} ADDRESS
          IF(ILIN.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 414
          IF(ICDI21(ICD,ICMP).EQ.1) THEN
            DO N=1,MAXN
              GABI21(N,IAB) = GABI21(N,IAB)
     &                    - DIMAG(ECD21(IMAP(N),ICD,ICMP))*RC(N,IRABCD)
            ENDDO
          ENDIF
414       CONTINUE
C
C         SKIP POINT FOR RC(AB|CD) AND E(CD) SCREENING
402       CONTINUE
C
C         LOOP OVER CARTESIAN INDEX JCMP FOR CENTRE CD
          DO JCMP=1,3
C
C           SKIP THIS STEP IF THE E(CD) PASSES SCREENING CONDITION
            IF(ICDR11(ICD,JCMP)+ICDI11(ICD,JCMP)
     &                     +ICDR21(ICD,JCMP)+ICDI21(ICD,JCMP).EQ.0) THEN
              GOTO 403
            ENDIF
C
C           CARTESIAN INDEX JCMP AS A VECTOR, JDX
            CALL NCART(JDX,JCMP)
C
C           NEW ADDRESS DEPENDING ON JCMP CARTESIAN INDEX
            IF(JCMP.EQ.1) THEN
              RTP = DFLOAT(IVEC(IAB)+IVEC(ICD))
            ELSEIF(JCMP.EQ.2) THEN
              RTP = DFLOAT(JVEC(IAB)+JVEC(ICD))
            ELSEIF(JCMP.EQ.3) THEN
              RTP = DFLOAT(KVEC(IAB)+KVEC(ICD))
            ENDIF
C
C           FIRST CONTRIBUTION ADDRESS
            I1 = IVEC(IAB)+IVEC(ICD)+IDX(1)+JDX(1)
            J1 = JVEC(IAB)+JVEC(ICD)+IDX(2)+JDX(2)
            K1 = KVEC(IAB)+KVEC(ICD)+IDX(3)+JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR1 = INABCD(I1,J1,K1)
C
C           SECOND CONTRIBUTION ADDRESS
            I2 = IVEC(IAB)+IVEC(ICD)+IDX(1)
            J2 = JVEC(IAB)+JVEC(ICD)+IDX(2)
            K2 = KVEC(IAB)+KVEC(ICD)+IDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IADR2 = INABCD(I2,J2,K2)
C
C           THIRD CONTRIBUTION ADDRESS
            I3 = IVEC(IAB)+IVEC(ICD)+IDX(1)-JDX(1)
            J3 = JVEC(IAB)+JVEC(ICD)+IDX(2)-JDX(2)
            K3 = KVEC(IAB)+KVEC(ICD)+IDX(3)-JDX(3)
C
C           CALCULATE RC ADDRESS FOR THIS PARTICULAR AB/CD OVERLAP
            IF(I3.GE.0.AND.J3.GE.0.AND.K3.GE.0) THEN
              IADR3 = INABCD(I3,J3,K3)
            ELSE
              IADR3 = 0
            ENDIF
C
C           SKIP THIS STEP IF THE RC(AB|CD) PASSES SCREENING CONDITION
            IF(IADR3.NE.0) THEN
              IF(IRC(IADR1)+IRC(IADR2)+IRC(IADR3).EQ.0) GOTO 403
            ELSE
              IF(IRC(IADR1)+IRC(IADR2).EQ.0) GOTO 403
            ENDIF
C
C           PRE-FACTORS FOR THE UPCOMING CONTRACTION
            IF(IADR3.NE.0) THEN
              DO N=1,MAXN
                T1 = RC(N,IADR1)*0.5D0/APH(N)
                T2 = RC(N,IADR2)*PQ(N,JCMP)
                T3 = RC(N,IADR3)*RTP
                T(N) = T1-T2+T3
              ENDDO
            ELSEIF(ITHRD.EQ.0) THEN
              DO N=1,MAXN
                T1 = RC(N,IADR1)*0.5D0/APH(N)
                T2 = RC(N,IADR2)*PQ(N,JCMP)
                T(N) = T1-T2
              ENDDO           
            ENDIF
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ILIN.EQ.1.AND.IABR11(IAB,ICMP).EQ.0) GOTO 415
            IF(ICDR11(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABR11(N,IAB) = GABR11(N,IAB)
     &                            + DREAL(ECD11(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
415         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ILIN.EQ.1.AND.IABI11(IAB,ICMP).EQ.0) GOTO 416
            IF(ICDI11(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABI11(N,IAB) = GABI11(N,IAB)
     &                            + DIMAG(ECD11(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
416         CONTINUE
C
C           CONTRIBUTIONS TO Re{G(AB|--)} FROM EACH Re{E(CD|--)} ADDRESS
            IF(ILIN.EQ.1.AND.IABR21(IAB,ICMP).EQ.0) GOTO 417
            IF(ICDR21(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABR21(N,IAB) = GABR21(N,IAB)
     &                            + DREAL(ECD21(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
417         CONTINUE
C
C           CONTRIBUTIONS TO Im{G(AB|--)} FROM EACH Im{E(CD|--)} ADDRESS
            IF(ILIN.EQ.1.AND.IABI21(IAB,ICMP).EQ.0) GOTO 418
            IF(ICDI21(ICD,JCMP).EQ.1) THEN
              DO N=1,MAXN
                GABI21(N,IAB) = GABI21(N,IAB)
     &                            + DIMAG(ECD21(IMAP(N),ICD,JCMP))*T(N)
              ENDDO
            ENDIF
418         CONTINUE
C
C         SKIP POINT FOR E(CD) SCREENING
403       CONTINUE
C
C         END LOOP OVER CARTESIAN INDEX JCMP FOR CENTRE CD
          ENDDO
C
C       END LOOP OVER E(CD|  ) FINITE EXPANSION ADDRESSES
        ENDDO
C
C       SKIP POINT FOR E(AB|  ) SCREENING
401     CONTINUE
C
C     END LOOP OVER E(AB|  ) FINITE EXPANSION ADDRESSES
      ENDDO
C
C     TIME AT END OF FIRST CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T1F)
      TBC1 = TBC1+T1F-T1I
C
C**********************************************************************C
C     PERFORM SECOND CONTRACTION: ( -| -) = E(AB| -)*G(AB| -).         C
C     THIS YIELDS A FULL BATCH OF TWO-ELECTRON INTEGRALS (16 PERM'NS). C
C**********************************************************************C
C
C     CALCULATE PHASES FOR BASIS FUNCTION OVERLAP COMBINATIONS
      PAB =-ISIGN(1,KQN(1)*KQN(2))*(-1)**((MQN(1)-MQN(2))/2)
      PCD =-ISIGN(1,KQN(3)*KQN(4))*(-1)**((MQN(3)-MQN(4))/2)
C
      PABCD = PAB*PCD
C
C     1ST SET: ( 1) = (--|--)   ( 4) = (--|++)
C              (16) = (++|++)   (13) = (++|--)        (16 AND 13 LATER)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|--) = E(AB|--)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,1 ) = RR(N,1 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,4 ) = RR(N,4 ) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
      IF(ILIN.EQ.1) GOTO 501
C
C     2ND SET: ( 3) = (--|+-)   ( 2) = (--|-+)
C              (14) = (++|-+)   (15) = (++|+-)        (14 AND 15 LATER)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (--|+-) = E(AB|--)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI11(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB11(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB11(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,3 ) = RR(N,3 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,2 ) = RR(N,2 ) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     3RD SET: ( 9) = (+-|--)   (12) = (+-|++)
C              ( 8) = (-+|++)   ( 5) = (-+|--)        ( 8 AND  5 LATER)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|--) = E(AB|+-)*(Re{G(AB|--)} + i*Im{G(AB|--)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR11(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI11(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,9 ) = RR(N,9 ) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,12) = RR(N,12) + PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
501   CONTINUE
C
C     4TH SET: (11) = (+-|+-)   (10) = (+-|-+)
C              ( 6) = (-+|-+)   ( 7) = (-+|+-)        ( 6 AND  7 LATER)
C
C     RESET CONTRACTION STORAGE LISTS
      DO N=1,MAXN
        QR1(N) = 0.0D0
        QI1(N) = 0.0D0
        QR2(N) = 0.0D0
        QI2(N) = 0.0D0
      ENDDO
C
C     RAW CONTRACTION (+-|+-) = E(AB|+-)*(Re{G(AB|+-)} + i*Im{G(AB|+-)})
      DO IAB=1,NTUVAB
        IF(IABR21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QR1(N) = QR1(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QI2(N) = QI2(N) + DREAL(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
        IF(IABI21(IAB,ICMP).NE.0) THEN
          DO N=1,MAXN
            QI1(N) = QI1(N) + DIMAG(EAB21(IJ,IAB,ICMP))*GABR21(N,IAB)
            QR2(N) = QR2(N) - DIMAG(EAB21(IJ,IAB,ICMP))*GABI21(N,IAB)
          ENDDO
        ENDIF
      ENDDO
C
C     ADD THIS ICMP TERM TO RAW CONTRACTION
      DO N=1,MAXN
        RR(N,11) = RR(N,11) +     DCMPLX(QR1(N)+QR2(N),QI1(N)+QI2(N))
        RR(N,10) = RR(N,10) - PCD*DCMPLX(QR1(N)-QR2(N),QI1(N)-QI2(N))
      ENDDO
C
C     TIME AT END OF SECOND CONTRACTION FOR THIS ICMP INDEX
      CALL CPU_TIME(T2F)
      TBC2 = TBC2+T2F-T1F
C
C     END LOOP OVER CARTESIAN INDICES {IX,IY,IZ}
6000  CONTINUE
C
C     HALF OF THE RR ARRAY CAN BE GENERATED WITH PHASE RELATIONS
      DO N=1,MAXN
        RR(N,16) = PABCD*DCONJG(RR(N,1 ))
        RR(N,13) = PABCD*DCONJG(RR(N,4 ))
        RR(N,14) =-PABCD*DCONJG(RR(N,3 ))
        RR(N,15) =-PABCD*DCONJG(RR(N,2 ))
        RR(N,8 ) =-PABCD*DCONJG(RR(N,9 ))
        RR(N,5 ) =-PABCD*DCONJG(RR(N,12))
        RR(N,6 ) = PABCD*DCONJG(RR(N,11))
        RR(N,7 ) = PABCD*DCONJG(RR(N,10))
      ENDDO     
C
C**********************************************************************C
C     BREIT INTEGRAL BATCH NOW FULLY CONSTRUCTED                       C
C**********************************************************************C
C
C     INCLUDE THE OUTSIDE FACTOR OF (1/2) AND MOVE TO FULL ARRAY
      DO N=1,MAXN
        DO ITG=1,16
          RR(N,ITG) = 0.5D0*PRE(N)*RR(N,ITG)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BRTMAT(RR,IFLG,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        BBBBBBB  RRRRRRR TTTTTTTT MM       MM    AA   TTTTTTTT        C
C        BB    BB RR    RR   TT    MMM     MMM   AAAA     TT           C
C        BB    BB RR    RR   TT    MMMM   MMMM  AA  AA    TT           C
C        BBBBBBB  RR    RR   TT    MM MM MM MM AA    AA   TT           C
C        BB    BB RRRRRRR    TT    MM  MMM  MM AAAAAAAA   TT           C
C        BB    BB RR    RR   TT    MM   M   MM AA    AA   TT           C
C        BBBBBBB  RR    RR   TT    MM       MM AA    AA   TT           C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRTMAT MULTIPLIES A MOLECULAR ERI BATCH BY DENSITY ELEMENTS AND     C
C  ADDS THE CONTRIBUTIONS TO THE OPEN/CLOSED SCF BREIT MATRICES.       C
C  DEPENDING ON THE COMBINATION OF MQN VALUES, CAN TAKE ADVANTAGE OF   C
C  INTEGRAL PERMUTATION SYMMETRIES (MINIMISING CALLS TO ERI):          C
C              ( MA, MB|-MD,-MC) =     PCD*( MA, MB| MC, MD)           C
C              (-MB,-MA| MC, MD) = PAB*    ( MA, MB| MC, MD)           C
C              ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    RR(MB2,16) - ERI'S FOR BLOCK AB, ALL 16 MQN SIGN COMBINATIONS.    C
C    NBAS(4)    - NUMBER OF BASIS FUNCTIONS IN BLOCK (ABCD).           C
C    IFLG(11)   - INTEGRAL SYMMETRY FLAGS.                             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9)
C
      DIMENSION IFLG(11),NBAS(4)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SHLL/ALPHA,BETA,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C**********************************************************************C
C     CLOSED-SHELL CONTRIBUTIONS... (NO DIRECT TERMS)                  C
C**********************************************************************C
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 105
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 105
C
            BXCH(NA1+IBAS,ND1+LBAS) = BXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENC(NC2+KBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,ND2+LBAS) = BXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENC(NC2+KBAS,NB2+JBAS)
C
105         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 106
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 106
C
            BXCH(NA1+IBAS,NC1+KBAS) = BXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENC(ND2+LBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,NC2+KBAS) = BXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENC(ND2+LBAS,NB2+JBAS)
C
106         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 107
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 107
C
            BXCH(NB1+JBAS,ND1+LBAS) = BXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NC2+KBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,ND2+LBAS) = BXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NC2+KBAS,NA2+IBAS)
C
107         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 108
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 108
C
            BXCH(NB1+JBAS,NC1+KBAS) = BXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENC(ND2+LBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,NC2+KBAS) = BXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENC(ND2+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENC(ND1+LBAS,NA1+IBAS)
C
108         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 109
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 109
C
            BXCH(NC1+KBAS,NB1+JBAS) = BXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENC(NA2+IBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NB2+JBAS) = BXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENC(NA2+IBAS,ND2+LBAS)
C
109         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 110
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 110
C
            BXCH(NC1+KBAS,NA1+IBAS) = BXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENC(NB2+JBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NA2+IBAS) = BXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENC(NB2+JBAS,ND2+LBAS)
C
110         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 111
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 111
C
            BXCH(ND1+LBAS,NB1+JBAS) = BXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENC(NA2+IBAS,NC2+KBAS)
C
            BXCH(ND2+LBAS,NB2+JBAS) = BXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENC(NA2+IBAS,NC2+KBAS)
C
111         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ILIN.EQ.1) GOTO 5002
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 205
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 205
C
            BXCH(NA1+IBAS,ND1+LBAS) = BXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENC(NC2+KBAS,NB1+JBAS)
C
            BXCH(NA1+IBAS,ND2+LBAS) = BXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENC(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENC(NC2+KBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,ND1+LBAS) = BXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENC(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENC(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENC(NC2+KBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,ND2+LBAS) = BXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENC(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENC(NC2+KBAS,NB1+JBAS)
C
205         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 206
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 206
C
            BXCH(NA1+IBAS,NC1+KBAS) = BXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENC(ND2+LBAS,NB1+JBAS)
C
            BXCH(NA1+IBAS,NC2+KBAS) = BXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENC(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENC(ND2+LBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,NC1+KBAS) = BXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENC(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENC(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENC(ND2+LBAS,NB2+JBAS)
C
            BXCH(NA2+IBAS,NC2+KBAS) = BXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENC(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENC(ND2+LBAS,NB1+JBAS)
C
206         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 207
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 207
C
            BXCH(NB1+JBAS,ND1+LBAS) = BXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENC(NC2+KBAS,NA1+IBAS)
C
            BXCH(NB1+JBAS,ND2+LBAS) = BXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENC(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NC2+KBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,ND1+LBAS) = BXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENC(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NC2+KBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,ND2+LBAS) = BXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENC(NC2+KBAS,NA1+IBAS)
C
207         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 208
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 208
C
            BXCH(NB1+JBAS,NC1+KBAS) = BXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENC(ND2+LBAS,NA1+IBAS)
C
            BXCH(NB1+JBAS,NC2+KBAS) = BXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENC(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENC(ND2+LBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,NC1+KBAS) = BXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENC(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENC(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENC(ND2+LBAS,NA2+IBAS)
C
            BXCH(NB2+JBAS,NC2+KBAS) = BXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENC(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENC(ND2+LBAS,NA1+IBAS)
C
208         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 209
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 209
C
            BXCH(NC1+KBAS,NB1+JBAS) = BXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENC(NA2+IBAS,ND1+LBAS)
C
            BXCH(NC1+KBAS,NB2+JBAS) = BXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENC(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENC(NA2+IBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NB1+JBAS) = BXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENC(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENC(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENC(NA2+IBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NB2+JBAS) = BXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENC(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENC(NA2+IBAS,ND1+LBAS)
C
209         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 210
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 210
C
            BXCH(NC1+KBAS,NA1+IBAS) = BXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENC(NB2+JBAS,ND1+LBAS)
C
            BXCH(NC1+KBAS,NA2+IBAS) = BXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENC(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENC(NB2+JBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NA1+IBAS) = BXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENC(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENC(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENC(NB2+JBAS,ND2+LBAS)
C
            BXCH(NC2+KBAS,NA2+IBAS) = BXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENC(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENC(NB2+JBAS,ND1+LBAS)
C
210         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 211
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 211
C
            BXCH(ND1+LBAS,NB1+JBAS) = BXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENC(NA2+IBAS,NC1+KBAS)
C
            BXCH(ND1+LBAS,NB2+JBAS) = BXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENC(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENC(NA2+IBAS,NC2+KBAS)
C
            BXCH(ND2+LBAS,NB1+JBAS) = BXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENC(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENC(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENC(NA2+IBAS,NC2+KBAS)
C
            BXCH(ND2+LBAS,NB2+JBAS) = BXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENC(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENC(NA2+IBAS,NC1+KBAS)
C
211         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     SKIP POINT FOR LINEAR BATCH
5002  CONTINUE
C
C**********************************************************************C
C     OPEN-SHELL CONTRIBUTIONS... (NOTE: WILL NEED WDIR/WXCH INSTEAD)  C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5100
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 301
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 301
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,ND2+LBAS)
C
301         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 302
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 302
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NC2+KBAS)
C
302         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 303
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 303
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,NB2+JBAS)
C
303         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 304
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 304
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,NA2+IBAS)
C
304         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 305
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 305
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 1)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,16)*DENO(NC2+KBAS,NB2+JBAS)
C
305         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 306
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 306
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 4)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,13)*DENO(ND2+LBAS,NB2+JBAS)
C
306         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 307
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 307
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,13)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NC2+KBAS,NA2+IBAS)
C
307         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 308
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 308
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB1*PCD1*RR(N,16)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 7)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD1*RR(N, 1)*DENO(ND2+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,10)*DENO(ND1+LBAS,NA1+IBAS)
C
308         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 309
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 309
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 1)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N,16)*DENO(NA2+IBAS,ND2+LBAS)
C
309         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 310
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 310
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,13)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 4)*DENO(NB2+JBAS,ND2+LBAS)
C
310         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 311
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 311
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 4)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 7)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,13)*DENO(NA2+IBAS,NC2+KBAS)
C
311         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     ADD MORE CONTRIBUTIONS FOR GENERAL MOLECULAR BATCH
      IF(ILIN.EQ.1) GOTO 5003
C
C     1ST CASE (DIRECT):  ( MA, MB| MC, MD)
      IF(IFLG(1).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 401
            N = N+1
            IF(IMTX(M, 1).EQ.0) GOTO 401
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,ND1+LBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 7)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N,10)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,ND2+LBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,ND1+LBAS)
C
401         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     2ND CASE (DIRECT):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(2).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 402
            N = N+1
            IF(IMTX(M, 2).EQ.0) GOTO 402
C
            QDIR(NA1+IBAS,NB1+JBAS) = QDIR(NA1+IBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NC1+KBAS)
C
            QDIR(NA1+IBAS,NB2+JBAS) = QDIR(NA1+IBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 7)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB1+JBAS) = QDIR(NA2+IBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,10)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NC2+KBAS)
C
            QDIR(NA2+IBAS,NB2+JBAS) = QDIR(NA2+IBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NC1+KBAS)
C
402         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     3RD CASE (DIRECT):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(3).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 403
            N = N+1
            IF(IMTX(M, 3).EQ.0) GOTO 403
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,NB1+JBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,10)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,NB1+JBAS)
     &                     +           RR(N, 7)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,NB2+JBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,NB1+JBAS)
C
403         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     4TH CASE (DIRECT):  ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(4).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 404
            N = N+1
            IF(IMTX(M, 4).EQ.0) GOTO 404
C
            QDIR(NC1+KBAS,ND1+LBAS) = QDIR(NC1+KBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,NA1+IBAS)
C
            QDIR(NC1+KBAS,ND2+LBAS) = QDIR(NC1+KBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,10)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND1+LBAS) = QDIR(NC2+KBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 7)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,NA2+IBAS)
C
            QDIR(NC2+KBAS,ND2+LBAS) = QDIR(NC2+KBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,NA1+IBAS)
C
404         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     5TH CASE (EXCHNG):  ( MA, MB| MC, MD)
      IF(IFLG(5).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 405
            N = N+1
            IF(IMTX(M, 5).EQ.0) GOTO 405
C
            QXCH(NA1+IBAS,ND1+LBAS) = QXCH(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 5)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 3)*DENO(NC2+KBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,ND2+LBAS) = QXCH(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 2)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 6)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 4)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 8)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND1+LBAS) = QXCH(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N, 9)*DENO(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N,13)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,11)*DENO(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N,15)*DENO(NC2+KBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,ND2+LBAS) = QXCH(NA2+IBAS,ND2+LBAS)
     &                     +           RR(N,14)*DENO(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N,12)*DENO(NC2+KBAS,NB1+JBAS)
C
405         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     6TH CASE (EXCHNG):  ( MA, MB| MD, MC) =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(6).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 406
            N = N+1
            IF(IMTX(M, 6).EQ.0) GOTO 406
C
            QXCH(NA1+IBAS,NC1+KBAS) = QXCH(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 8)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(ND2+LBAS,NB1+JBAS)
C
            QXCH(NA1+IBAS,NC2+KBAS) = QXCH(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N, 2)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 6)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 1)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC1+KBAS) = QXCH(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(ND1+LBAS,NB1+JBAS)
     &                     +      PCD1*RR(N,16)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD2*RR(N,11)*DENO(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N,15)*DENO(ND2+LBAS,NB2+JBAS)
C
            QXCH(NA2+IBAS,NC2+KBAS) = QXCH(NA2+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 9)*DENO(ND2+LBAS,NB1+JBAS)
C
406         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     7TH CASE (EXCHNG):  ( MB, MA| MC, MD) = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(7).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 407
            N = N+1
            IF(IMTX(M, 7).EQ.0) GOTO 407
C
            QXCH(NB1+JBAS,ND1+LBAS) = QXCH(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NC2+KBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,ND2+LBAS) = QXCH(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N,14)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB1*     RR(N,16)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND1+LBAS) = QXCH(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,11)*DENO(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NC2+KBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,ND2+LBAS) = QXCH(NB2+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N,12)*DENO(NC2+KBAS,NA1+IBAS)
C
407         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     8TH CASE (EXCHNG):  ( MB, MA| MD, MC) = PAB*    (-MA,-MB| MC, MD)
C                                           = PAB*PCD*(-MA,-MB|-MC,-MD)
      IF(IFLG(8).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 408
            N = N+1
            IF(IMTX(M, 8).EQ.0) GOTO 408
C
            QXCH(NB1+JBAS,NC1+KBAS) = QXCH(NB1+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N, 8)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD2*RR(N,15)*DENO(ND2+LBAS,NA1+IBAS)
C
            QXCH(NB1+JBAS,NC2+KBAS) = QXCH(NB1+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N,14)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB2*PCD2*RR(N, 6)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB1*PCD1*RR(N,13)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB2*PCD1*RR(N, 5)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC1+KBAS) = QXCH(NB2+JBAS,NC1+KBAS)
     &                     + PAB2*PCD1*RR(N,12)*DENO(ND1+LBAS,NA1+IBAS)
     &                     + PAB1*PCD1*RR(N, 4)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD2*RR(N,11)*DENO(ND2+LBAS,NA1+IBAS)
     &                     + PAB1*PCD2*RR(N, 3)*DENO(ND2+LBAS,NA2+IBAS)
C
            QXCH(NB2+JBAS,NC2+KBAS) = QXCH(NB2+JBAS,NC2+KBAS)
     &                     + PAB1*PCD2*RR(N, 2)*DENO(ND1+LBAS,NA2+IBAS)
     &                     + PAB2*PCD1*RR(N, 9)*DENO(ND2+LBAS,NA1+IBAS)
C
408         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     9TH CASE (EXCHNG):  ( MC, MD| MA, MB) =         ( MA, MB| MC, MD)
      IF(IFLG(9).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 409
            N = N+1
            IF(IMTX(M, 9).EQ.0) GOTO 409
C
            QXCH(NC1+KBAS,NB1+JBAS) = QXCH(NC1+KBAS,NB1+JBAS)
     &                     +           RR(N, 2)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N, 9)*DENO(NA2+IBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NB2+JBAS) = QXCH(NC1+KBAS,NB2+JBAS)
     &                     +           RR(N, 5)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 6)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,13)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,14)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB1+JBAS) = QXCH(NC2+KBAS,NB1+JBAS)
     &                     +           RR(N, 3)*DENO(NA1+IBAS,ND1+LBAS)
     &                     +           RR(N, 4)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,11)*DENO(NA2+IBAS,ND1+LBAS)
     &                     +           RR(N,12)*DENO(NA2+IBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NB2+JBAS) = QXCH(NC2+KBAS,NB2+JBAS)
     &                     +           RR(N, 8)*DENO(NA1+IBAS,ND2+LBAS)
     &                     +           RR(N,15)*DENO(NA2+IBAS,ND1+LBAS)
C
409         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     10TH CASE (EXCHNG): ( MC, MD| MB, MA) =         ( MB, MA| MC, MD)
C                                           = PAB*    (-MA,-MB| MC, MD)
      IF(IFLG(10).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 410
            N = N+1
            IF(IMTX(M,10).EQ.0) GOTO 410
C
            QXCH(NC1+KBAS,NA1+IBAS) = QXCH(NC1+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,14)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N, 9)*DENO(NB2+JBAS,ND1+LBAS)
C
            QXCH(NC1+KBAS,NA2+IBAS) = QXCH(NC1+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 5)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N, 6)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 1)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N, 2)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA1+IBAS) = QXCH(NC2+KBAS,NA1+IBAS)
     &                     + PAB1*     RR(N,15)*DENO(NB1+JBAS,ND1+LBAS)
     &                     + PAB1*     RR(N,16)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB2*     RR(N,11)*DENO(NB2+JBAS,ND1+LBAS)
     &                     + PAB2*     RR(N,12)*DENO(NB2+JBAS,ND2+LBAS)
C
            QXCH(NC2+KBAS,NA2+IBAS) = QXCH(NC2+KBAS,NA2+IBAS)
     &                     + PAB2*     RR(N, 8)*DENO(NB1+JBAS,ND2+LBAS)
     &                     + PAB1*     RR(N, 3)*DENO(NB2+JBAS,ND1+LBAS)
C
410         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     11TH CASE (EXCHNG): ( MD, MC| MA, MB) =         ( MA, MB| MD, MC)
C                                           =     PCD*( MA, MB|-MC,-MD)
      IF(IFLG(11).EQ.1) THEN
        M = 0
        N = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
            IF(ISCR(M).EQ.0) GOTO 411
            N = N+1
            IF(IMTX(M,11).EQ.0) GOTO 411
C
            QXCH(ND1+LBAS,NB1+JBAS) = QXCH(ND1+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 2)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,12)*DENO(NA2+IBAS,NC1+KBAS)
C
            QXCH(ND1+LBAS,NB2+JBAS) = QXCH(ND1+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 8)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N, 6)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD1*RR(N,16)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD2*RR(N,14)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB1+JBAS) = QXCH(ND2+LBAS,NB1+JBAS)
     &                     +      PCD2*RR(N, 3)*DENO(NA1+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 1)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,11)*DENO(NA2+IBAS,NC1+KBAS)
     &                     +      PCD1*RR(N, 9)*DENO(NA2+IBAS,NC2+KBAS)
C
            QXCH(ND2+LBAS,NB2+JBAS) = QXCH(ND2+LBAS,NB2+JBAS)
     &                     +      PCD1*RR(N, 5)*DENO(NA1+IBAS,NC2+KBAS)
     &                     +      PCD2*RR(N,15)*DENO(NA2+IBAS,NC1+KBAS)
C
411         CONTINUE
          ENDDO
        ENDDO
      ENDIF
C
C     SKIP POINT FOR LINEAR BATCH
5003  CONTINUE
C     SKIPPING POINT FOR CLOSED SYSTEMS
5100  CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
      SUBROUTINE COUPLE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         CCCCCC   OOOOOO  UU    UU PPPPPPP  LL       EEEEEEEE         C
C        CC    CC OO    OO UU    UU PP    PP LL       EE               C
C        CC       OO    OO UU    UU PP    PP LL       EE               C
C        CC       OO    OO UU    UU PP    PP LL       EEEEEE           C
C        CC       OO    OO UU    UU PPPPPPP  LL       EE               C
C        CC    CC OO    OO UU    UU PP       LL       EE               C
C         CCCCCC   OOOOOO   UUUUUU  PP       LLLLLLLL EEEEEEEE         C
C                                                                      C
C -------------------------------------------------------------------- C
C  COUPLE SPECIFIES THE OPEN-SHELL COUPLING MATRIX R:                  C
C               R = {S.D(O).Q + Q.D(O).S}  (RSCF 89)                   C
C  AND ADDS TO THE EXISTING DIRECT- AND EXCHANGE COULOMB/BREIT ARRAYS. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      COMPLEX*16 T1(MDM),T2(MDM),T3(MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     LOOP OVER ARRAY COLUMNS J
      DO J=1,NDIM
C
C       RESET INTERMEDIATE COUNTERS T1 AND T2
        DO K=1,NDIM
          T1(K) = DCMPLX(0.0D0,0.0D0)
          T2(K) = DCMPLX(0.0D0,0.0D0)
C
C         PERFORM FIRST MATRIX CONTRACTION
          DO L=1,NDIM
            T1(K) = T1(K) + DENT(K,L)*QDIR(L,J) - DENT(K,L)*QDIR(L,J)
            T2(K) = T2(K) + DENT(K,L)*OVAP(L,J)
          ENDDO
C
C       AT THIS POINT, T1 AND T2 ARE COMPLETE FOR COLUMN J
        ENDDO
C
C       MULTIPLY THESE CONTRACTIONS APPROPRIATELY
        DO I=1,NDIM
          T3(I) = DCMPLX(0.0D0,0.0D0)
          DO K=1,NDIM
            T3(I) = T3(I) + T1(K)*OVAP(I,K)
     &                    + T2(K)*QDIR(I,K) - T2(K)*QXCH(I,K)
          ENDDO
        ENDDO
C
C       ADD THE PROJECTOR AND Q-MATRIX TO THE COULOMB MATRIX  (RSCF 91)
C       DO I=1,NDIM
C         FOCK(I,J) = FOCK(I,J) - QMAT(I,J) + T3(I)
C       ENDDO
C       DFNOTE: OKAY... SO I HAVE TO FIX ENERGY TERM
C
C       APPLY COUPLING TO ALL ROWS I OF THE JTH COLUMN OF QDIR/QXCH
        DO I=1,NDIM
          QDIR(I,J) = QDIR(I,J) - T3(I)
          QXCH(I,J) = QXCH(I,J) + T3(I)
        ENDDO
C
C     END LOOP OVER ARRAY COLUMNS J
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE SPARSITY(A,N,EPS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS  PPPPPPP     AA    RRRRRRR   SSSSSS IIII TTTTTTTT YY    YY  C
C  SS    SS PP    PP   AAAA   RR    RR SS    SS II     TT    YY    YY  C
C  SS       PP    PP  AA  AA  RR    RR SS       II     TT    YY    YY  C
C   SSSSSS  PP    PP AA    AA RR    RR  SSSSSS  II     TT     YY  YY   C
C        SS PPPPPPP  AAAAAAAA RRRRRRR        SS II     TT      YYYY    C
C  SS    SS PP       AA    AA RR    RR SS    SS II     TT       YY     C
C   SSSSSS  PP       AA    AA RR    RR  SSSSSS IIII    TT       YY     C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPARSITY APPLIES MATRIX SPARSITY CONDITIONS ON A COMPLEX-VALUED     C
C  ARRAY A OF DIMENSION N.                                             C
C**********************************************************************C
C
      COMPLEX*16 A(N,N)
C
C     LOOP OVER ALL MATRIX ELEMENTS
      DO I=1,NDIM
        DO J=1,NDIM
C
          X = DREAL(A(I,J))
          Y = DIMAG(A(I,J))
C
C         ELIMINATE ANY VANISHINGLY SMALL MATRIX ELEMENTS
          IF(DABS(X).LT.EPS) THEN
            X = 0.0D0
          ENDIF
          IF(DABS(Y).LT.EPS) THEN
            Y = 0.0D0
          ENDIF
C
C         ALSO ELMINATE ALL DIAGONAL IMAGINARY MATRIX ELEMENTS
          IF(I.EQ.J) THEN
            Y = 0.0D0
          ENDIF
C
C         TRANSFER ELEMENT BACK TO A MATRIX
          A(I,J) = DCMPLX(X,Y)
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE NCART(IVECT,IND)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             NN    NN  CCCCCC     AA    RRRRRRR TTTTTTTT              C
C             NNN   NN CC    CC   AAAA   RR    RR   TT                 C
C             NNNN  NN CC        AA  AA  RR    RR   TT                 C
C             NN NN NN CC       AA    AA RR    RR   TT                 C
C             NN  NNNN CC       AAAAAAAA RRRRRRR    TT                 C
C             NN   NNN CC    CC AA    AA RR    RR   TT                 C
C             NN    NN  CCCCCC  AA    AA RR    RR   TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCART RETURNS THE CARTESIAN INDEX FROM THE INDEX VALUE IND.         C
C**********************************************************************C
C
      DIMENSION IVECT(3)
C
      IF(IND.EQ.1) THEN
        IVECT(1) = 1
        IVECT(2) = 0
        IVECT(3) = 0
      ELSEIF(IND.EQ.2) THEN
        IVECT(1) = 0
        IVECT(2) = 1
        IVECT(3) = 0
      ELSEIF(IND.EQ.3) THEN
        IVECT(1) = 0
        IVECT(2) = 0
        IVECT(3) = 1
      ELSE
        WRITE(6, *) 'In NCART: supplied index not valid',IND
        WRITE(7, *) 'In NCART: supplied index not valid',IND
        RETURN
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION NCNTRS(ICNTA,ICNTB,ICNTC,ICNTD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        NN    NN  CCCCCC  NN    NN TTTTTTTT RRRRRRR   SSSSSS          C
C        NNN   NN CC    CC NNN   NN    TT    RR    RR SS    SS         C
C        NNNN  NN CC       NNNN  NN    TT    RR    RR SS               C
C        NN NN NN CC       NN NN NN    TT    RR    RR  SSSSSS          C
C        NN  NNNN CC       NN  NNNN    TT    RRRRRRR        SS         C
C        NN   NNN CC    CC NN   NNN    TT    RR    RR SS    SS         C
C        NN    NN  CCCCCC  NN    NN    TT    RR    RR  SSSSSS          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NCNTRS RETURNS NUMBER OF UNIQUE NUCLEAR CENTRES FROM INPUT VALUES.  C
C**********************************************************************C
C
C     STORE ICNTA IN FIRST PLACE
      NCNTRS = 1
C
C     CHECK ICNTB AGAINST STORED VALUES
      IF(ICNTB.NE.ICNTA) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTC AGAINST STORED VALUES
      IF(ICNTC.NE.ICNTA.AND.ICNTC.NE.ICNTB) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
C     CHECK ICNTD AGAINST STORED VALUES
      IF(ICNTD.NE.ICNTA.AND.ICNTD.NE.ICNTB.AND.ICNTD.NE.ICNTC) THEN
        NCNTRS = NCNTRS + 1
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION ZPROJ(XYZ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            ZZZZZZZZ PPPPPPP  RRRRRRR   OOOOOO     JJJJJJ             C
C                 ZZ  PP    PP RR    RR OO    OO       JJ              C
C                ZZ   PP    PP RR    RR OO    OO       JJ              C
C               ZZ    PP    PP RR    RR OO    OO       JJ              C
C              ZZ     PPPPPPP  RRRRRRR  OO    OO       JJ              C
C             ZZ      PP       RR    RR OO    OO JJ    JJ              C
C            ZZZZZZZZ PP       RR    RR  OOOOOO   JJJJJJ               C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZPROJ RETURNS THE SUM OF ABSOLUTE DIFFERENCES BETWEEN X AND Y       C
C  LOCATIONS OF FOUR SUPPLIED COORDINATES.                             C
C**********************************************************************C
C
       DIMENSION XYZ(3,4)
C
       ZPROJ = 0.0D0
C
       DO IX=1,2
         DO M=1,3
           DO N=M+1,4
             ZPROJ = ZPROJ + DABS(XYZ(IX,M)-XYZ(IX,N))
           ENDDO
         ENDDO
       ENDDO
C
       RETURN
       END
C
C
C**********************************************************************C
C ==================================================================== C
C   [6] ONE-CENTRE ROUTINES: ATOMIC INTEGRALS FOR MOLECULAR PURPOSES.  C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] COULOMB1: ONE-CENTRE CONTRIBUTION TO MOLECULAR COULOMB MATRIX. C
C   [B] RKCLM1: MAKES A BATCH OF RADIAL COULOMB INTEGRALS RK(ABCD).    C
C   [C] ANGCLM1: CONSTRUCTS ANGULAR COEFFICIENTS FOR COULOMB1.         C
C   [D] DK: ANGULAR AND CG-COEFFICIENT PRE-FACTORS FOR ANGCLM1.        C
C   [E] SYM3J: EVALUATES A WIGNER 3J-SYMBOL.                           C
C   [F] BREIT1: ONE-CENTRE CONTRIBUTION TO MOLECULAR BREIT MATRIX.     C
C   [G] RKBRT1: MAKES A BATCH OF RADIAL COULOMB INTEGRALS RK(ABCD).    C
C   [H] ANGBRT1: ANGULAR TERMS FOR ONE-CENTRE BREIT INTEGRALS.         C
C   [I] BRCOEF1: INTERMEDIATE COUPLING TERMS FOR ABOVE BREIT INTEGRALS.C
C   [J] IJSET1: BASIS SET INTERMEDIATES FOR IJ-PAIRS IN RKCLM1/RKBRT1. C
C   [K] KLSET1: BASIS SET INTERMEDIATES FOR KL-PAIRS IN RKCLM1/RKBRT1. C
C   [L] TESTANG: TESTS A FULL BATCH OF COMMON ANGULAR COEFFICIENTS.    C
C**********************************************************************C
C
C
      SUBROUTINE COULOMB1(ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  CCCCCC   OOOOOO  UU    UU LL      OOOOOO  MM       MM BBBBBBB   11  C
C CC    CC OO    OO UU    UU LL     OO    OO MMM     MMM BB    BB 111  C
C CC       OO    OO UU    UU LL     OO    OO MMMM   MMMM BB    BB  11  C
C CC       OO    OO UU    UU LL     OO    OO MM MM MM MM BBBBBBB   11  C
C CC       OO    OO UU    UU LL     OO    OO MM  MMM  MM BB    BB  11  C
C CC    CC OO    OO UU    UU LL     OO    OO MM   M   MM BB    BB  11  C
C  CCCCCC   OOOOOO   UUUUUU  LLLLLLL OOOOOO  MM       MM BBBBBBB  1111 C
C                                                                      C
C -------------------------------------------------------------------- C
C  COULOMB1 CONSTRUCT A ONE-CENTRE CONTRIBUTION TO THE MOLECULAR       C
C  MEAN-FIELD COULOMB MATRIX WITH RACAH ALGEBRA AND BETA INTEGRALS.    C
C  THIS ROUTINE IS SIMILAR TO THE IN-LINE CONSTRUCTION OF MEAN-FIELD   C
C  ATOMIC COULOMB MATRIX IN HFSCF0, BUT WITH MQN STRUCTURE AS WELL.    C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MNU=MKP+1,
     &                                                      MAB=2*MNU+6)
C
      CHARACTER*4 HMLT
      CHARACTER*8 SHAPE
C
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
      DIMENSION RJLLLL(MB2,MNU),RJLLSS(MB2,MNU),
     &          RJSSLL(MB2,MNU),RJSSSS(MB2,MNU)
      DIMENSION XLLLL(MB2),XSSLL(MB2),XLLSS(MB2),XSSSS(MB2)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BQNM/EXPT(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/DENS/DENC,DENO,DENT
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/GEOM/SHAPE
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      DATA SENS/1.0D-10/
C
      CALL CPU_TIME(TBCH1)
C
C     LINEAR MOLECULE SHORTCUT OPTION
      IF(SHAPE.EQ.'DIATOMIC'.OR.SHAPE.EQ.'LINEAR') THEN
        ILIN = 1
      ELSE
        ILIN = 0
      ENDIF
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPE FOR A,B,C,D BLOCKS (USE INDEX 1000)  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 1000 KA=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNT)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNT)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 1000 KB=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNT)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNT)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 1000 KC=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNT)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3)+1,ICNT)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = BSET(KBAS,LQN(3)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 1000 KD=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNT)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4)+1,ICNT)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = BSET(LBAS,LQN(4)+1,ICNT)
        ENDDO
C
C     NUMBER OF BASIS FUNCTION COMBINATIONS IN (CD) BLOCK
      MAXM = NBAS(3)*NBAS(4)
C
C**********************************************************************C
C     PREPARE INTERMEDIATE DATA FOR USE IN RKCLM1                      C
C**********************************************************************C
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C1 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+1)
      C3 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+3)
      C5 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+5)
      C7 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+7)
      C9 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+9)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
      V8 = 8.0D0
      VS = 1.6D1
C
      TI = DFLOAT(LQN(1)+KQN(1)+1)
      TJ = DFLOAT(LQN(2)+KQN(2)+1)
      TK = DFLOAT(LQN(3)+KQN(3)+1)
      TL = DFLOAT(LQN(4)+KQN(4)+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
C
C     ANGULAR COEFFICIENTS
      CALL CPU_TIME(T1)
      CALL ANGCLM1(DKAB,DKCD,KQN,LQN,ISEL)
      CALL CPU_TIME(T2)
      TC1B = TC1B+T2-T1
C
C     EXIT THIS COMBINATION IF IT VIOLATES A SELECTION RULE
      IF(ISEL.EQ.0) GOTO 1001
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL CPU_TIME(T1)
      CALL KLSET1(ICNT)
      CALL CPU_TIME(T2)
      TC1B = TC1B+T2-T1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 2000)         C
C**********************************************************************C
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      IF(HMLT.EQ.'NORL') THEN
        N2EB(1,1) = N2EB(1,1) + 1
      ELSE
        N2EB(1,1) = N2EB(1,1) + 1
        N2EB(1,2) = N2EB(1,2) + 1
        N2EB(1,3) = N2EB(1,3) + 1
        N2EB(1,4) = N2EB(1,4) + 1
      ENDIF
C
      DO 2000 IBAS=1,NBAS(1)
      DO 2000 JBAS=1,NBAS(2)
C
C       UPDATE COUNTER FOR NUMBER OF INTEGRALS
        IF(HMLT.EQ.'NORL') THEN
          N2EI(1,1) = N2EI(1,1) + NBAS(3)*NBAS(4)
        ELSE
          N2EI(1,1) = N2EI(1,1) + NBAS(3)*NBAS(4)
          N2EI(1,2) = N2EI(1,2) + NBAS(3)*NBAS(4)
          N2EI(1,3) = N2EI(1,3) + NBAS(3)*NBAS(4)
          N2EI(1,4) = N2EI(1,4) + NBAS(3)*NBAS(4)
        ENDIF
C
C       BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
        CALL CPU_TIME(T1)
        CALL IJSET1
        CALL CPU_TIME(T2)
        TC1B = TC1B+T2-T1
C
C       BATCH OF RADIAL INTEGRALS (EFFECTIVE INTERACTION STRENGTHS)
        CALL CPU_TIME(T1)
        CALL RKCLM1(RJLLLL,RJLLSS,RJSSLL,RJSSSS)
        CALL CPU_TIME(T2)
        TC1R = TC1R+T2-T1
C
C       CAN NOW CONTRACT THESE RADIAL INTEGRALS OVER ANGULAR COMPONENTS
C       OF G-SPINOR BASIS FUNCTIONS USING A TENSOR EXPANSION IN {L,Q}
C
C**********************************************************************C
C     LOOP OVER |MQN| MAGNITUDES FOR A,B,C,D BLOCKS (USE INDEX 3000)   C
C**********************************************************************C
C
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C**********************************************************************C
C     LOOP OVER THE SIGNS OF |MQN| FOR A,B,C,D BLOCKS (USE INDEX 4000) C
C**********************************************************************C
C
      DO 4000 ISGN1=1,2
        MMJA = MQN(1)*((-1)**ISGN1)
        IMJA = MQN(1)+ISGN1-1
C
      DO 4000 ISGN2=1,2
        MMJB = MQN(2)*((-1)**ISGN2)
        IMJB = MQN(2)+ISGN2-1
C
      DO 4000 ISGN3=1,2
        MMJC = MQN(3)*((-1)**ISGN3)
        IMJC = MQN(3)+ISGN3-1
C
      DO 4000 ISGN4=1,2
        MMJD = MQN(4)*((-1)**ISGN4)
        IMJD = MQN(4)+ISGN4-1
C
C     STARTING FOCK ADDRESS FOR EACH BASIS LIST
      NAL = LRGE(ICNT,KA,IMJA)
      NBL = LRGE(ICNT,KB,IMJB)
      NCL = LRGE(ICNT,KC,IMJC)
      NDL = LRGE(ICNT,KD,IMJD)
C
      NAS = LRGE(ICNT,KA,IMJA)+NSKP
      NBS = LRGE(ICNT,KB,IMJB)+NSKP
      NCS = LRGE(ICNT,KC,IMJC)+NSKP
      NDS = LRGE(ICNT,KD,IMJD)+NSKP
C
C     APPLY ANGULAR MQN SELECTION RULE
      IF(MMJA-MMJB.NE.MMJD-MMJC) GOTO 4001
      IF(ILIN.EQ.1) THEN
        IF(ISGN1.EQ.ISGN2.AND.ISGN3.EQ.ISGN4) GOTO 4002
        IF(ISGN1.EQ.ISGN4.AND.ISGN3.EQ.ISGN2) GOTO 4002     
        GOTO 4001
      ENDIF
4002  CONTINUE
C
C     INITIALISE EFFECTIVE INTERACTION STRENGTH VALUES
      CALL CPU_TIME(T1)
      DO M=1,NBAS(3)*NBAS(4)
        XLLLL(M) = 0.0D0
        XLLSS(M) = 0.0D0
        XSSLL(M) = 0.0D0
        XSSSS(M) = 0.0D0
      ENDDO
C
C     ASSEMBLE INTEGRAL BY SUMMING OVER EXPANSION POWER L
      DO LTEN=1,NUNUM
C
C       ANGULAR COEFFICIENT
C       DFNOTE: ANGFAC CAN BE EXPRESSED AS THE SQUARE ROOT OF A 
C               RATIONAL NUMBER -- SMALL ERRORS AT PRESENT.
        ANGFAC = DKAB(LTEN,IMJA,IMJB)*DKCD(LTEN,IMJC,IMJD)
C
C       SCREENING OF INTEGRAL BASED ON ANGULAR COEFFICIENT
        IF(DABS(ANGFAC).LE.SENS) GOTO 4003
C
        IF(HMLT.EQ.'NORL') THEN
C       NON-RELATIVISTIC HAMILTONIAN
C
          DO M=1,NBAS(3)*NBAS(4)
            XLLLL(M) = XLLLL(M) + ANGFAC*RJLLLL(M,LTEN)
          ENDDO
C
        ELSE
C       RELATIVISTIC HAMILTONIAN
C
          DO M=1,NBAS(3)*NBAS(4)
            XLLLL(M) = XLLLL(M) + ANGFAC*RJLLLL(M,LTEN)
            XLLSS(M) = XLLSS(M) + ANGFAC*RJLLSS(M,LTEN)
            XSSLL(M) = XSSLL(M) + ANGFAC*RJSSLL(M,LTEN)
            XSSSS(M) = XSSSS(M) + ANGFAC*RJSSSS(M,LTEN)
          ENDDO
C
        ENDIF
C
C       SKIP POINT FOR ANGULAR SCREENING
4003    CONTINUE
C
      ENDDO
C
C     FULL-INTEGRAL CONSTRUCTION COMPLETE
      CALL CPU_TIME(T2)
      TC1F = TC1F+T2-T1
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO CLOSED-SHELL COULOMB MATRIX     C
C -------------------------------------------------------------------- C
C     DFNOTE: BE AWARE THAT THERE ARE ISSUES WITH NUMERICAL ACCURACY   C
C             IN THIS METHOD, STEMMING FROM ACCUMULATING ERRORS IN THE C
C             FLOATING-POINT REPRESENTATION OF INTEGERS AND RATIONALS. C
C             (EG. ANGFAC^2 IS A RATIONAL NUMBER).                     C
C**********************************************************************C
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       DIRECT CONTRIBUTIONS
        IF(ILIN.EQ.1) THEN
          IF(ISGN1.NE.ISGN2.OR.ISGN3.NE.ISGN4) GOTO 5001
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                          +      XLLLL(M)*DENC(NCL+KBAS,NDL+LBAS)
C
          ENDDO
        ENDDO
5001    CONTINUE
C
C       EXCHANGE CONTRIBUTIONS
        IF(ILIN.EQ.1) THEN
          IF(ISGN1.NE.ISGN4.OR.ISGN3.NE.ISGN2) GOTO 5002
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS) 
     &                          +      XLLLL(M)*DENC(NCL+KBAS,NBL+JBAS)
C
          ENDDO
        ENDDO
5002    CONTINUE
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C       DIRECT CONTRIBUTIONS
        IF(ILIN.EQ.1) THEN
          IF(ISGN1.NE.ISGN2.OR.ISGN3.NE.ISGN4) GOTO 5003
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            GDIR(NAL+IBAS,NBL+JBAS) = GDIR(NAL+IBAS,NBL+JBAS)
     &                          +      XLLLL(M)*DENC(NCL+KBAS,NDL+LBAS)
     &                          +      XLLSS(M)*DENC(NCS+KBAS,NDS+LBAS)
C
            GDIR(NAS+IBAS,NBS+JBAS) = GDIR(NAS+IBAS,NBS+JBAS)
     &                          +      XSSLL(M)*DENC(NCL+KBAS,NDL+LBAS)
     &                          +      XSSSS(M)*DENC(NCS+KBAS,NDS+LBAS)
C
          ENDDO
        ENDDO
5003    CONTINUE
C
C       EXCHANGE CONTRIBUTIONS
        IF(ILIN.EQ.1) THEN
          IF(ISGN1.NE.ISGN4.OR.ISGN3.NE.ISGN2) GOTO 5004
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            GXCH(NAL+IBAS,NDL+LBAS) = GXCH(NAL+IBAS,NDL+LBAS)
     &                          +      XLLLL(M)*DENC(NCL+KBAS,NBL+JBAS)
C
            GXCH(NAL+IBAS,NDS+LBAS) = GXCH(NAL+IBAS,NDS+LBAS)
     &                          +      XLLSS(M)*DENC(NCS+KBAS,NBL+JBAS)
C
            GXCH(NAS+IBAS,NDL+LBAS) = GXCH(NAS+IBAS,NDL+LBAS)
     &                          +      XSSLL(M)*DENC(NCL+KBAS,NBS+JBAS)
C
            GXCH(NAS+IBAS,NDS+LBAS) = GXCH(NAS+IBAS,NDS+LBAS)
     &                          +      XSSSS(M)*DENC(NCS+KBAS,NBS+JBAS)
C
          ENDDO
        ENDDO
5004    CONTINUE
C
      ENDIF
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL COULOMB MATRIX       C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5100
C
C     NON-RELATIVISTIC HAMILTONIAN
      IF(HMLT.EQ.'NORL') THEN
C
C       DIRECT CONTRIBUTIONS
        IF(ILIN.EQ.1) THEN
          IF(ISGN1.NE.ISGN2.OR.ISGN3.NE.ISGN4) GOTO 5005
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS)
     &                          + ACFF*XLLLL(M)*DENO(NCL+KBAS,NDL+LBAS)
C
          ENDDO
        ENDDO
5005    CONTINUE
C
C       EXCHANGE CONTRIBUTIONS
        IF(ILIN.EQ.1) THEN
          IF(ISGN1.NE.ISGN4.OR.ISGN3.NE.ISGN2) GOTO 5006
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C           
            QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                          + BCFF*XLLLL(M)*DENO(NCL+KBAS,NBL+JBAS)
C
          ENDDO
        ENDDO
5006    CONTINUE
C
C     RELATIVISTIC HAMILTONIAN
      ELSE
C
C       DIRECT CONTRIBUTIONS
        IF(ILIN.EQ.1) THEN
          IF(ISGN1.NE.ISGN2.OR.ISGN3.NE.ISGN4) GOTO 5007
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            QDIR(NAL+IBAS,NBL+JBAS) = QDIR(NAL+IBAS,NBL+JBAS)
     &                          + ACFF*XLLLL(M)*DENO(NCL+KBAS,NDL+LBAS)
     &                          + ACFF*XLLSS(M)*DENO(NCS+KBAS,NDS+LBAS)
C
            QDIR(NAS+IBAS,NBS+JBAS) = QDIR(NAS+IBAS,NBS+JBAS)
     &                          + ACFF*XSSLL(M)*DENO(NCL+KBAS,NDL+LBAS)
     &                          + ACFF*XSSSS(M)*DENO(NCS+KBAS,NDS+LBAS)
C
          ENDDO
        ENDDO
5007    CONTINUE
C
C       EXCHANGE CONTRIBUTIONS
        IF(ILIN.EQ.1) THEN
          IF(ISGN1.NE.ISGN4.OR.ISGN3.NE.ISGN2) GOTO 5008
        ENDIF
        M = 0
        DO KBAS=1,NBAS(3)
          DO LBAS=1,NBAS(4)
            M = M+1
C
            QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                          + BCFF*XLLLL(M)*DENO(NCL+KBAS,NBL+JBAS)
C
            QXCH(NAL+IBAS,NDS+LBAS) = QXCH(NAL+IBAS,NDS+LBAS)
     &                          + BCFF*XLLSS(M)*DENO(NCS+KBAS,NBL+JBAS)
C
            QXCH(NAS+IBAS,NDL+LBAS) = QXCH(NAS+IBAS,NDL+LBAS)
     &                          + BCFF*XSSLL(M)*DENO(NCL+KBAS,NBS+JBAS)
            
            QXCH(NAS+IBAS,NDS+LBAS) = QXCH(NAS+IBAS,NDS+LBAS)
     &                          + BCFF*XSSSS(M)*DENO(NCS+KBAS,NBS+JBAS)
C
          ENDDO
        ENDDO
5008    CONTINUE
C
      ENDIF
C
5100  CONTINUE
C
C     MATRIX MULTIPLICATION STEP COMPLETE
      CALL CPU_TIME(T3)
      TC1M = TC1M+T3-T2
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL ONE-CENTRE CONTRIBUTIONS.           C
C**********************************************************************C
C
C     EARLY EXIT FOR MQN SELECTION RULES
4001  CONTINUE
C     END LOOP OVER ALL |MQN| SIGNS
4000  CONTINUE
C     END LOOP OVER ALL |MQN| MAGNITUDES
3000  CONTINUE
C     END LOOP OVER IBAS AND JBAS
2000  CONTINUE
C     EARLY EXIT FOR KQN SELECTION RULES
1001  CONTINUE
C     END LOOP OVER ALL KQNS
1000  CONTINUE
C
C     RECORD CPU TIME AT END OF BATCH AND ADD TO APPROPRIATE COUNTER
      CALL CPU_TIME(TBCH2)
      IF(HMLT.EQ.'NORL') THEN
        T2ES(1,1) = T2ES(1,1) + TBCH2 - TBCH1
      ELSE
        T2ES(1,1) = T2ES(1,1) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,2) = T2ES(1,2) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,3) = T2ES(1,3) + 0.25D0*(TBCH2-TBCH1)
        T2ES(1,4) = T2ES(1,4) + 0.25D0*(TBCH2-TBCH1)
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE RKCLM1(RJLLLL,RJLLSS,RJSSLL,RJSSSS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         RRRRRRR  KK    KK CCCCCC  LL       MM       MM  11           C
C         RR    RR KK   KK CC    CC LL       MMM     MMM 111           C
C         RR    RR KK  KK  CC       LL       MMMM   MMMM  11           C
C         RR    RR KKKKK   CC       LL       MM MM MM MM  11           C
C         RRRRRRR  KK  KK  CC       LL       MM  MMM  MM  11           C
C         RR    RR KK   KK CC    CC LL       MM   M   MM  11           C
C         RR    RR KK    KK CCCCCC  LLLLLLLL MM       MM 1111          C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKCLM1 EVALUATES A BATCH OF GENERAL (OPEN-SHELL) ONE-CENTRE RADIAL  C
C  INTEGRALS OVER THE COULOMB INTERACTION, SEPARATING RESULTS BY THE   C
C  ALLOWED TENSOR ORDERS RK(ABCD).                                     C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+6)
C
      CHARACTER*4 HMLT
C
      DIMENSION XJ(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
      DIMENSION BDU(MB2,-MAB:MAB,-MAB:MAB),BDL(MB2,-MAB:MAB,-MAB:MAB)
C
      DIMENSION RJLLLL(MB2,MNU),RJLLSS(MB2,MNU),
     &          RJSSLL(MB2,MNU),RJSSSS(MB2,MNU)
C
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BKLS/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/BQNM/EXPT(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL EXCHANGE INTEGRALS
      NVALS = (NUF-NUI)/2+3
C
C     LOOP OVER EXPANSION TERMINALS FOR FIRST PAIR
      DO NX=1,NVALS
        IAA(1) = LQN(1)+LQN(2)+NUI+2*NX-1
        IAA(2) = LQN(3)+LQN(4)+NUI+2*NX-1
C
C       LOOP OVER EXPANSION TERMINALS FOR SECOND PAIR
        DO NY=1,NVALS
          IBB(1) = LQN(3)+LQN(4)-NUF+2*NY-2
          IBB(2) = LQN(1)+LQN(2)-NUF+2*NY-2
C
C         LOOP OVER BETA INTEGRAL COMBINATIONS
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BDU(M, NUI+2*NX-1,-NUF+2*NY-2) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BDL(M, NUI+2*NX-1,-NUF+2*NY-2) = BETA(M)
              ENDDO
            ENDIF

          ENDDO

        ENDDO
      ENDDO
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR INTEGRALS
      DO M=1,MAXM
        DO LTEN=1,NUNUM
          RJLLLL(M,LTEN) = 0.0D0
          RJLLSS(M,LTEN) = 0.0D0
          RJSSLL(M,LTEN) = 0.0D0
          RJSSSS(M,LTEN) = 0.0D0
        ENDDO
      ENDDO
C
C     VALUE PREPARATION
      E0000 = 1.0D0
      E1000 = EI
      E0100 = EJ
      E1100 = EI*EJ
C
C     INITIATE LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1010 = EI*EK(M)
        E1001 = EI*EL(M)
        E0110 = EJ*EK(M)
        E0101 = EJ*EL(M)
        E0011 = EK(M)*EL(M)
        E1110 = EI*EJ*EK(M)
        E1101 = EI*EJ*EL(M)
        E1011 = EI*EK(M)*EL(M)
        E0111 = EJ*EK(M)*EL(M)
        E1111 = EI*EJ*EK(M)*EL(M)
C
C       LOOP OVER THE TENSOR ORDERS OF THE COULOMB INTERACTION
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C**********************************************************************C
C     SPECIAL CASE: NON-RELATIVISTIC HAMILTONIAN                       C
C**********************************************************************C
C
          IF(HMLT.EQ.'NORL') THEN
C         NON-RELATIVISTIC HAMILTONIAN
C
C           BETA INTEGRALS WITH POWERS OF EXPONENTIALS
            B32 = EIJ(-NU+2)*EKL(M, NU+3)*BDL(M, NU+3,-NU+2)
     &          + EIJ( NU+3)*EKL(M,-NU+2)*BDU(M, NU+3,-NU+2)
C
C           EFFECTIVE INTERACTION STRENGTH FOR THIS TENSOR ORDER
            RJLLLL(M,LTEN) = C5*B32
C
C           SKIP PAST THE RELATIVISTIC STAGES
            GOTO 999
C
          ENDIF
C
C**********************************************************************C
C     LARGER CASE: RELATIVISTIC HAMILTONIAN (T TERMS GIVE ZEROES)      C
C**********************************************************************C
C
C         TEMPORARY STORAGE OF RAW RJ(LTEN,M)
          B10 = EIJ(-NU  )*EKL(M, NU+1)*BDL(M, NU+1,-NU  )
     &        + EIJ( NU+1)*EKL(M,-NU  )*BDU(M, NU+1,-NU  )
          B12 = EIJ(-NU+2)*EKL(M, NU+1)*BDL(M, NU+1,-NU+2)
     &        + EIJ( NU+3)*EKL(M,-NU  )*BDU(M, NU+3,-NU  )
          B14 = EIJ(-NU+4)*EKL(M, NU+1)*BDL(M, NU+1,-NU+4)
     &        + EIJ( NU+5)*EKL(M,-NU  )*BDU(M, NU+5,-NU  )
          B30 = EIJ(-NU  )*EKL(M, NU+3)*BDL(M, NU+3,-NU  )
     &        + EIJ( NU+1)*EKL(M,-NU+2)*BDU(M, NU+1,-NU+2)
          B32 = EIJ(-NU+2)*EKL(M, NU+3)*BDL(M, NU+3,-NU+2)
     &        + EIJ( NU+3)*EKL(M,-NU+2)*BDU(M, NU+3,-NU+2)
          B34 = EIJ(-NU+4)*EKL(M, NU+3)*BDL(M, NU+3,-NU+4)
     &        + EIJ( NU+5)*EKL(M,-NU+2)*BDU(M, NU+5,-NU+2)
          B50 = EIJ(-NU  )*EKL(M, NU+5)*BDL(M, NU+5,-NU  )
     &        + EIJ( NU+1)*EKL(M,-NU+4)*BDU(M, NU+1,-NU+4)
          B52 = EIJ(-NU+2)*EKL(M, NU+5)*BDL(M, NU+5,-NU+2)
     &        + EIJ( NU+3)*EKL(M,-NU+4)*BDU(M, NU+3,-NU+4)
          B54 = EIJ(-NU+4)*EKL(M, NU+5)*BDL(M, NU+5,-NU+4)
     &        + EIJ( NU+5)*EKL(M,-NU+4)*BDU(M, NU+5,-NU+4)
C
C         EFFECTIVE INTERACTION STRENGTH RJLLLL(M,LTEN)
          RJLLLL(M,LTEN) = V1*T0000*E0000*C5*B32
C
C         EFFECTIVE INTERACTION STRENGTH RJLLSS(M,LTEN)
          RJLLSS(M,LTEN) = V4*T0000*E0011*C7*B52 - V2*T0001*E0010*C5*B32
     &                   - V2*T0010*E0001*C5*B32 + V1*T0011*E0000*C3*B12
C
C         EFFECTIVE INTERACTION STRENGTH RJSSLL(M,LTEN)
          RJSSLL(M,LTEN) = V4*T0000*E1100*C7*B34 - V2*T0100*E1000*C5*B32
     &                   - V2*T1000*E0100*C5*B32 + V1*T1100*E0000*C3*B30
C
C         EFFECTIVE INTERACTION STRENGTH RJSSSS(M,LTEN)
          RJSSSS(M,LTEN) = VS*T0000*E1111*C9*B54
     &                   - V8*T0001*E1110*C7*B34 - V8*T0010*E1101*C7*B34
     &                   - V8*T0100*E1011*C7*B52 - V8*T1000*E0111*C7*B52
     &                   + V4*T1100*E0011*C5*B50 + V4*T0011*E1100*C5*B14
     &                   + V4*T1001*E0110*C5*B32 + V4*T0110*E1001*C5*B32
     &                   + V4*T0101*E1010*C5*B32 + V4*T1010*E0101*C5*B32
     &                   - V2*T1101*E0010*C3*B30 - V2*T0111*E1000*C3*B12
     &                   - V2*T1110*E0001*C3*B30 - V2*T1011*E0100*C3*B12
     &                   + V1*T1111*E0000*C1*B10
C
C         SKIP POINT FOR NON-RELATIVISTIC HAMILTONIANS
999       CONTINUE
C
C       END LOOP OVER TENSOR ORDERS
        ENDDO
C
C     END LOOP OVER K,L BASIS FUNCTIONS
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      IF(HMLT.EQ.'NORL') THEN
C     NON-RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          RNLLLL = RNIJ(1)*RNKL(M,1)
          DO LTEN=1,NUNUM
            RJLLLL(M,LTEN) = RNLLLL*RJLLLL(M,LTEN)
          ENDDO
        ENDDO
C
      ELSE
C     RELATIVISTIC HAMILTONIAN
C
        DO M=1,MAXM
          RNLLLL = RNIJ(1)*RNKL(M,1)
          RNLLSS = RNIJ(1)*RNKL(M,3)
          RNSSLL = RNIJ(3)*RNKL(M,1)
          RNSSSS = RNIJ(3)*RNKL(M,3)
          DO LTEN=1,NUNUM
            RJLLLL(M,LTEN) = RNLLLL*RJLLLL(M,LTEN)
            RJLLSS(M,LTEN) = RNLLSS*RJLLSS(M,LTEN)
            RJSSLL(M,LTEN) = RNSSLL*RJSSLL(M,LTEN)
            RJSSSS(M,LTEN) = RNSSSS*RJSSSS(M,LTEN)
          ENDDO
        ENDDO
C
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE ANGCLM1(DKAB,DKCD,KQN,LQN,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       AA    NN    NN  GGGGGG   CCCCCC  LL       MM       MM  11      C
C      AAAA   NNN   NN GG    GG CC    CC LL       MMM     MMM 111      C
C     AA  AA  NNNN  NN GG       CC       LL       MMMM   MMMM  11      C
C    AA    AA NN NN NN GG       CC       LL       MM MM MM MM  11      C
C    AAAAAAAA NN  NNNN GG   GGG CC       LL       MM  MMM  MM  11      C
C    AA    AA NN   NNN GG    GG CC    CC LL       MM   M   MM  11      C
C    AA    AA NN    NN  GGGGGG   CCCCCC  LLLLLLLL MM       MM 1111     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGCLM1 PERFORMS THE ANGULAR ANALYSIS FOR THE EVALUATION OF TWO     C
C  ELECTRON INTEGRALS USING RACAH ALGEBRA TECHNIQUES. (OPEN-SHELL.)    C
C**********************************************************************C
      PARAMETER(MKP=9,MNU=MKP+1)
C
      DIMENSION KQN(4),LQN(4),JQN(4)
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
C
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
C**********************************************************************C
C     PARITY ANALYSIS: CHECK UNDERLYING LQN COMBINATIONS AND EXIT      C
C     IF THERE IS NO MULTIPOLE EXPANSION OF THE INTERACTION.           C
C**********************************************************************C
C
C     A AND B: LQN(1)+LQN(2) EVEN OR ODD
      IF(MOD(LQN(1)+LQN(2),2).EQ.0) THEN
        IPARAB = 1
      ELSE
        IPARAB = 0
      ENDIF
C
C     C AND D: LQN(3)+LQN(4) EVEN OR ODD
      IF(MOD(LQN(3)+LQN(4),2).EQ.0) THEN
        IPARCD = 1
      ELSE
        IPARCD = 0
      ENDIF
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.EQ.IPARCD) THEN
        ISEL = 1
      ELSE
        ISEL = 0
        RETURN
      ENDIF
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
      NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
      NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
C
C     JQN SELECTION RULE: TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUI.GT.NUF) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     FURTHER PARITY ANALYSIS: RUN OVER ALLOWED TENSOR ORDERS NU AND   C
C     SCREEN THOSE WHICH ARE NOT ALLOWED ON PARITY GROUNDS.            C
C**********************************************************************C
C
      NUNUM = 0
      DO NU=NUI,NUF
C
C       A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD
        IF(MOD(LQN(1)+LQN(2)+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
C       C AND D: LQN(3)+LQN(4)+NU EVEN OR ODD
        IF(MOD(LQN(3)+LQN(4)+NU,2).EQ.0) THEN
          IPARCD = 1
        ELSE
          IPARCD = 0
        ENDIF
C
C       LQN SELECTION RULE: WHEN SUM OF A AND B, C AND D EVEN
        IF(IPARAB.EQ.1.AND.IPARCD.EQ.1) THEN
C
C         INCREASE TOTAL NUMBER OF NU VALUES TO BE FACILITATED
          NUNUM = NUNUM+1
C
C         SAVE THIS PARTICULAR NU VALUE TO A LIST
          NUS(NUNUM) = NU
C
        ENDIF
C
      ENDDO
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, EXIT PROCEDURE
      IF(NUNUM.EQ.0) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C     RE-SET THE LOWER AND UPPER LIMITS OF THE EXPANSION
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C**********************************************************************C
C     ANGULAR FACTORS: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|      C
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.   C
C**********************************************************************C
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(1),-MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(1), MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(1),-MJA,JQN(2), MJB,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(1), MJA,JQN(2), MJB,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     THE ARGUMENTS OF DK COEFFICIENTS ARE REVERSED IN THE CASE OF THE
C     CD PAIRS IN ORDER TO ACCOMMODATE THE RELATION:
C               DK(J,M,J',M',L) = ((-1)^Q)*DK(J'M',J,M,L).
C
C     LOOP OVER MQN(C) AND MQN(D) VALUES
      DO MC=1,IABS(KQN(3))
        MJC = 2*MC-1
        DO MD=1,IABS(KQN(4))
          MJD = 2*MD-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKCD(LTEN,MJC  ,MJD  ) = DK(JQN(4),-MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD  ) = DK(JQN(4),-MJD,JQN(3), MJC,NU)
            DKCD(LTEN,MJC  ,MJD+1) = DK(JQN(4), MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD+1) = DK(JQN(4), MJD,JQN(3), MJC,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION DK(JA,MA,JB,MB,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                          DDDDDDD  KK    KK                           C
C                          DD    DD KK   KK                            C
C                          DD    DD KK  KK                             C
C                          DD    DD KKKKK                              C
C                          DD    DD KK  KK                             C
C                          DD    DD KK   KK                            C
C                          DDDDDDD  KK    KK                           C
C                                                                      C
C -------------------------------------------------------------------- C
C  DK EVALUATES THE ANGULAR COEFFICIENTS OF THE COULOMB INTERACTION,   C
C  ABSORBING THE ANGULAR DIAGRAM AND ANGULAR PARTS OF THE EFFECTIVE    C
C  INTERACTION STRENGTH TOGETHER. IT EVALUATES ALL PARTS THAT DEPEND   C
C  ON THE ANGULAR FACTOR AT THE INTERACTION VERTEX, ASSUMING THAT THE  C
C  PRIMITIVE RK-RADIAL INTEGRAL (AND NOT XK) IS THE REMAINDER.         C
C -------------------------------------------------------------------- C
C  INPUT CONVENTION: THE ANGULAR MOMENTA (JA,JB,MA,MB) SHOULD BE       C
C  SUPPLIED AS TWICE THEIR ACTUAL VALUES (THESE ARE ODD-HALF-INTEGER   C
C  ELECTRONIC VALUES) WHILE NU AND IQ ARE THE **ACTUAL** VALUES OF THE C
C  PHOTON PARAMETERS. THE SELECTION RULE IS THAT (MA+MB)/2+IQ=0.       C
C**********************************************************************C
C
C      CHOOSE IQ IN ACCORDANCE WITH PHOTON SELECTION RULE
       IQ = (MA-MB)/2
C
C      MQN PHASE TERM
       PHS = DFLOAT((-1)**((MA+1)/2))
C
C      CONVENTIONAL JQN SQUARE ROOT TERMS
       RTJ = DSQRT(DFLOAT((JA+1)*(JB+1)))
C
C      3J SYMBOL ASSOCIATED WITH ANGULAR MOMENTUM CONSERVATION
       SEL = SYM3J(JA,NU,JB,+1,0,-1)
C
C      3J SYMBOL CONTAINING SPIN TERMS
       QMM = SYM3J(JA,NU,JB,-MA,IQ,MB)
C
C      FINAL ANGULAR FACTOR
       DK = PHS*RTJ*SEL*QMM
C
       RETURN
       END
C
C
      FUNCTION SYM3J(JA,L,JB,MA,M,MB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            SSSSSS  YY    YY MM       MM  333333      JJJJJ           C
C           SS    SS YY    YY MMM     MMM 33    33       JJ            C
C           SS       YY    YY MMMM   MMMM       33       JJ            C
C            SSSSSS   YY  YY  MM MM MM MM    3333        JJ            C
C                 SS   YYYY   MM  MMM  MM       33       JJ            C
C           SS    SS    YY    MM   M   MM  33   33 JJ    JJ            C
C            SSSSSS     YY    MM       MM   33333   JJJJJJ             C
C                                                                      C
C -------------------------------------------------------------------- C
C  SYM3J EVALUATES A WIGNER 3-J SYMBOL,               / j  L  j'\      C
C  WHERE j=JA/2, j'=JB/2, m=MA/2 AND m'=MB/2,         \ m  M  m'/      C
C  BUT L AND M ARE THE ACTUAL VALUES. (BRINK AND SATCHLER {2.34}.)     C
C**********************************************************************C
      COMMON/FCTS/RFACT(0:20),SFACT(0:20)
C
C     TRIANGLE RULE RESTRICTIONS
      IF(IABS(M).GT.L) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(2*M+MA+MB.NE.0) THEN
        SYM3J = 0.0D0
        RETURN
      ELSEIF(IABS(MA).GT.JA.OR.IABS(MB).GT.JB) THEN
        SYM3J = 0.0D0
        RETURN
      ENDIF
C
C     OVERALL PHASE FACTOR (CONVERSION FROM CG-COEFF TO 3J-SYMBOL)
      IPS = (JA-MB)/2 - L
      PHS = DFLOAT((-1)**(IPS))
C
C     SYMMETRIC FACTOR INVOLVING VERTICAL PAIRS (j,m), (L,M), (j',m')
      SM1 = RFACT((JA+MA)/2)
      SM2 = RFACT((JA-MA)/2)
      SM3 = RFACT((JB-MB)/2)
      SM4 = RFACT((JB+MB)/2)
      SM5 = RFACT(  L +M   )
      SM6 = RFACT(  L -M   )
      SYM = DSQRT(SM1*SM2*SM3*SM4*SM5*SM6)
C
C     TRIANGULAR FACTOR, DELTA (j, L, j')
      TR1 = RFACT((JA-JB)/2+L  )
      TR2 = RFACT((JA+JB)/2-L  )
      TR3 = RFACT((JB-JA)/2+L  )
      TR4 = RFACT((JA+JB)/2+L+1)
      TRP = DSQRT(TR1*TR2*TR3/TR4)
C
C     LIMITS IN THE SUM OVER TENSOR ORDERS NU
      NUI = MAX0(L-(JB+MA)/2,M+(JA-JB)/2,  0)
      NUF = MIN0(  (JA-MA)/2,L+(JA-JB)/2,L+M)
C
C     SUM OVER ALLOWED TENSOR ORDERS NU
      XNU = 0.0D0
      DO NU=NUI,NUF
C
C       PHASE TERM FROM TENSOR ORDER
        PTN = DFLOAT((-1)**NU)
C
C       FACTORS INVOLVING TENSOR ORDER
        RD1 = RFACT((JA-MA)/2    -NU)
        RD2 = RFACT((JB+MA)/2-L  +NU)
        RD3 = RFACT((JB-JA)/2  -M+NU)
        RD4 = RFACT((JA-JB)/2+L  -NU)
        RD5 = RFACT(          L+M-NU)
        RD6 = RFACT(              NU)
        RDP = RD1*RD2*RD3*RD4*RD5*RD6
C
C       ADD THIS CONTRIBUTION TO THE 3J-SYMBOL
        XNU = XNU + PTN/RDP
C
      ENDDO
C
C     3-J SYMBOL IS A PRODUCT OF PHASE, SYMMETRIC FACTOR, TRIANGULAR
C     FACTOR AND THE SUM OVER ALLOWED NU TERMS
      SYM3J = PHS*TRP*SYM*XNU
C
      RETURN
      END
C
C
      SUBROUTINE BREIT1(ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C             BBBBBBB  RRRRRRR  EEEEEEEE IIII TTTTTTTT 11              C
C             BB    BB RR    RR EE        II     TT   111              C
C             BB    BB RR    RR EE        II     TT    11              C
C             BBBBBBB  RR    RR EEEEEE    II     TT    11              C
C             BB    BB RRRRRRR  EE        II     TT    11              C
C             BB    BB RR    RR EE        II     TT    11              C
C             BBBBBBB  RR    RR EEEEEEEE IIII    TT   1111             C
C                                                                      C
C -------------------------------------------------------------------- C
C  BREIT1 CONSTRUCTS A ONE-CENTRE CONTRIBUTION TO THE MOLECULAR        C
C  MEAN-FIELD BREIT MATRIX WITH RACAH ALGEBRA AND BETA INTEGRALS.      C
C  THIS ROUTINE IS SIMILAR TO THE IN-LINE CONSTRUCTION OF MEAN-FIELD   C
C  ATOMIC BREIT MATRIX IN HFSCF0, BUT WITH MQN STRUCTURE AS WELL.      C
C -------------------------------------------------------------------- C
C  DFNOTE: NOT WORKING YET...                                          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MNU=MKP+1,
     &                                                      MAB=2*MNU+6)
C
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
      DIMENSION EMAT(MNU,8),ANGFAC(8)
      DIMENSION RJLSSL(MB2,MNU,2),RJSLLS(MB2,MNU,2),
     &          RJSLSL(MB2,MNU,2),RJLSLS(MB2,MNU,2)
      DIMENSION XLSSL(MB2),XSLLS(MB2),XSLSL(MB2),XLSLS(MB2)
      
      dimension jqn(4)
      dimension zssll(10,10),zllss(10,10),
     &          zlssl(10,10),zslls(10,10),ztotal(10,10)
C
      complex*16 sum
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
      
      complex*16 bsav(mdm,mdm,10)
C
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BQNM/EXPT(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/SHLL/ACFF,BCFF,FOPN,ICLS(500),IOPN(6),NCLS,NOPN,NOELEC
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/T2EL/F2ES(5,6),T2ES(5,6),N2EB(5,6),N2EI(5,6),N2ES(5,6)
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
      COMMON/TSCF/TC1B,TC1R,TC1F,TC1M,TCEC,TCRM,TCRR,TCC1,TCC2,TCMC,
     &            TB1B,TB1R,TB1F,TB1M,TBEC,TBRM,TBRR,TBC1,TBC2,TBMC,
     &            TQMX,THMX,TC1T,TC2T,TB1T,TB2T,TEIG,TSCR,TTOT,
     &            TC1S,TC2S,TB1S,TB2S
C
      DATA SENS/1.0D-12/
C
      CALL CPU_TIME(TBCH1)
      
c     empty bsav
      do i=1,ndim
        do j=1,ndim
          do iocc=1,10
            bsav(i,j,iocc) = dcmplx(0.0d0,0.0d0)
          enddo
        enddo
      enddo      
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPE FOR A,B,C,D BLOCKS (USE INDEX 1000)  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 1000 KA=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNT)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNT)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 1000 KB=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNT)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNT)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 1000 KC=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNT)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3)+1,ICNT)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = BSET(KBAS,LQN(3)+1,ICNT)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 1000 KD=1,NKAP(ICNT)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNT)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4)+1,ICNT)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = BSET(LBAS,LQN(4)+1,ICNT)
        ENDDO
C
C       NUMBER OF BASIS FUNCTIONS IN (CD) BLOCK
        MAXM = NBAS(3)*NBAS(4)
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
C**********************************************************************C
C     PREPARE INTERMEDIATE DATA FOR USE IN RKBRT1                      C
C**********************************************************************C
C
C     COEFFICIENTS FOR INTEGRAL ASSEMBLY
      C3 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+3)
      C5 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+5)
      C7 = 0.25D0*GAMHLF(LQN(1)+LQN(2)+LQN(3)+LQN(4)+7)
C
      V1 = 1.0D0
      V2 = 2.0D0
      V4 = 4.0D0
C
      TI = DFLOAT(LQN(1)+KQN(1)+1)
      TJ = DFLOAT(LQN(2)+KQN(2)+1)
      TK = DFLOAT(LQN(3)+KQN(3)+1)
      TL = DFLOAT(LQN(4)+KQN(4)+1)
C
      T0000 = 1.0D0
      T1000 = TI
      T0100 = TJ
      T0010 = TK
      T0001 = TL
      T1100 = TI*TJ
      T1010 = TI*TK
      T1001 = TI*TL
      T0110 = TJ*TK
      T0101 = TJ*TL
      T0011 = TK*TL
      T1110 = TI*TJ*TK
      T1101 = TI*TJ*TL
      T1011 = TI*TK*TL
      T0111 = TJ*TK*TL
      T1111 = TI*TJ*TK*TL
      
      if(kqn(1).ne.kqn(4)) goto 1001
      if(kqn(2).ne.kqn(3)) goto 1001
C
C     ANGULAR COEFFICIENTS
      CALL CPU_TIME(T1)
      CALL ANGBRT1(DKAB,DKCD,EMAT,KQN,LQN,ISEL)
      if(isel.ne.0) then
        write(*,*) kqn(1),kqn(2),kqn(3),kqn(4),'|',nunum,'|',
     &                                        (nus(lten),lten=1,nunum)
        do lten=1,nunum
          write(*,*) nus(lten),emat(lten,1),emat(lten,3),
     &                         emat(lten,5),emat(lten,7)
          write(*,*) '           ',emat(lten,2),emat(lten,4),
     &                             emat(lten,5),emat(lten,8)
        enddo
      endif
      if(kqn(1).eq.-1.and.kqn(2).eq.1.and.kqn(3).eq.1.and.kqn(4).eq.-1)
     & then
       nunum=2
       nui=0
       nuf=2
       nus(1)=0
       nus(2)=2
      endif
      CALL CPU_TIME(T2)
      TB1B = TB1B+T2-T1
C
C     EXIT THIS COMBINATION IF IT VIOLATES A SELECTION RULE
      IF(ISEL.EQ.0) GOTO 1001
C
C     BASIS SET INTERMEDIATES FOR THE KL-PAIRS
      CALL CPU_TIME(T1)
      CALL KLSET1(ICNT)
      CALL CPU_TIME(T2)
      TB1B = TB1B+T2-T1
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 2000)         C
C**********************************************************************C
C
C     UPDATE COUNTER FOR NUMBER OF CLASSES
      N2EB(1,5) = N2EB(1,5)+1
C
      DO 2000 IBAS=1,NBAS(1)
      DO 2000 JBAS=1,NBAS(2)
C
C       UPDATE COUNTER FOR NUMBER OF INTEGRALS
        N2EI(1,5) = N2EI(1,5)+NBAS(3)*NBAS(4)
C
C       BASIS SET INTERMEDIATES FOR THE IJ-PAIRS
        CALL CPU_TIME(T1)
        CALL IJSET1
        CALL CPU_TIME(T2)
        TB1B = TB1B+T2-T1
C
C       BATCH OF RADIAL INTEGRALS (EFFECTIVE INTERACTION STRENGTHS)
        CALL CPU_TIME(T1)
        CALL RKBRT1(RJLSSL,RJSLLS,RJSLSL,RJLSLS)
        CALL CPU_TIME(T2)
        TB1R = TB1R+T2-T1
C
C**********************************************************************C
C     LOOP OVER |KQN| MAGNITUDES FOR A,B,C,D BLOCKS (USE INDEX 3000)   C
C**********************************************************************C
C
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
      DO 3000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      DO 3000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     TRANSFORM THE X(L) INTO G-SPINOR MATRIX ELEMENTS USING
C     THE TENSOR EXPANSION IN {L,Q}
C
C     LOOP OVER THE SIGNS OF |MQN| AND DETERMINE FOCK ADDRESSES
      DO 4000 ISGN1=1,2
        MMJA = MQN(1)*((-1)**ISGN1)
        IMJA = MQN(1)+ISGN1-1
C
      DO 4000 ISGN2=1,2
        MMJB = MQN(2)*((-1)**ISGN2)
        IMJB = MQN(2)+ISGN2-1
C
      DO 4000 ISGN3=1,2
        MMJC = MQN(3)*((-1)**ISGN3)
        IMJC = MQN(3)+ISGN3-1
C
      DO 4000 ISGN4=1,2
        MMJD = MQN(4)*((-1)**ISGN4)
        IMJD = MQN(4)+ISGN4-1
C
C     STARTING FOCK ADDRESS FOR EACH BASIS LIST
      NAL = LRGE(ICNT,KA,IMJA)
      NBL = LRGE(ICNT,KB,IMJB)
      NCL = LRGE(ICNT,KC,IMJC)
      NDL = LRGE(ICNT,KD,IMJD)
C
      NAS = LRGE(ICNT,KA,IMJA)+NSKP
      NBS = LRGE(ICNT,KB,IMJB)+NSKP
      NCS = LRGE(ICNT,KC,IMJC)+NSKP
      NDS = LRGE(ICNT,KD,IMJD)+NSKP
C
C     APPLY ANGULAR MQN SELECTION RULE
      IF(MMJA-MMJB.NE.MMJD-MMJC) THEN
        GOTO 4001
      ENDIF
C
C     RESET CONTRACTED RADIAL ARRAYS
      CALL CPU_TIME(T1)
      DO M=1,NBAS(3)*NBAS(4)
        XLSSL(M) = 0.0D0
        XSLLS(M) = 0.0D0
        XSLSL(M) = 0.0D0
        XLSLS(M) = 0.0D0
      ENDDO
C
C     ASSEMBLE INTEGRAL BY SUMMING OVER EXPANSION POWER L
      DO LTEN=1,NUNUM
C
C       ANGULAR COEFFICIENTS
        DKABCD = DKAB(LTEN,IMJA,IMJB)*DKCD(LTEN,IMJC,IMJD)
        DO IMU=1,8
          ANGFAC(IMU) = DKABCD*EMAT(LTEN,IMU)
        ENDDO
C
C       SCREENING OF INTEGRAL BASED ON ANGULAR COEFFICIENT
        ANGSUM = 0.0D0
        DO IMU=1,8
          ANGSUM = ANGSUM + ANGFAC(IMU)
        ENDDO
        IF(DABS(ANGSUM).LE.SENS) GOTO 4003
C
        DO M=1,NBAS(3)*NBAS(4)
C
C         FACTORS LEADING TO BXCH(LL)
          XLSSL(M) = XLSSL(M) + ANGFAC(8)*RJLSSL(M,LTEN,1)
     &                        + ANGFAC(7)*RJLSSL(M,LTEN,2)
C
C         FACTORS LEADING TO BXCH(SS)
          XSLLS(M) = XSLLS(M) + ANGFAC(6)*RJSLLS(M,LTEN,1)
     &                        + ANGFAC(5)*RJSLLS(M,LTEN,2)
C
C         FACTORS LEADING TO BXCH(SL)
          XSLSL(M) = XSLSL(M) + ANGFAC(4)*RJSLSL(M,LTEN,1)
     &                        + ANGFAC(3)*RJSLSL(M,LTEN,2)
C
C         FACTORS LEADING TO BXCH(LS)
          XLSLS(M) = XLSLS(M) + ANGFAC(2)*RJLSLS(M,LTEN,1)
     &                        + ANGFAC(1)*RJLSLS(M,LTEN,2)
C
        ENDDO
C
C       SKIP POINT FOR ANGULAR SCREENING
4003    CONTINUE
C
      ENDDO
C
C     FULL-INTEGRAL CONSTRUCTION COMPLETE
      CALL CPU_TIME(T2)
      TB1F = TB1F+T2-T1
C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO CLOSED-SHELL BREIT MATRIX       C
C -------------------------------------------------------------------- C
C          (NO BDIR CONTRIBUTIONS FOR CLOSED-SHELL SYSTEMS.)           C
C**********************************************************************C
C
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         DIRECT CONTRIBUTIONS
          BDIR(NAL+IBAS,NBS+JBAS) = BDIR(NAL+IBAS,NBS+JBAS)
     &                          +      XLSLS(M)*DENC(NCL+KBAS,NDS+LBAS)
     &                          +      XLSSL(M)*DENC(NCS+KBAS,NDL+LBAS)
C
          BDIR(NAS+IBAS,NBL+JBAS) = BDIR(NAS+IBAS,NBL+JBAS)
     &                          +      XSLLS(M)*DENC(NCL+KBAS,NDS+LBAS)
     &                          +      XSLSL(M)*DENC(NCS+KBAS,NDL+LBAS)
C
C
C         EXCHANGE CONTRIBUTIONS
          BXCH(NAL+IBAS,NDL+LBAS) = BXCH(NAL+IBAS,NDL+LBAS)
     &                          +      XLSSL(M)*DENC(NBS+JBAS,NCS+KBAS)
C
          BXCH(NAL+IBAS,NDS+LBAS) = BXCH(NAL+IBAS,NDS+LBAS)
     &                          +      XLSLS(M)*DENC(NBS+JBAS,NCL+KBAS)
C
          BXCH(NAS+IBAS,NDL+LBAS) = BXCH(NAS+IBAS,NDL+LBAS)
     &                          +      XSLSL(M)*DENC(NBL+JBAS,NCS+KBAS)

          BXCH(NAS+IBAS,NDS+LBAS) = BXCH(NAS+IBAS,NDS+LBAS)
     &                          +      XSLLS(M)*DENC(NBL+JBAS,NCL+KBAS)
C
        ENDDO
      ENDDO

C
C     FOR SYMMETRY TYPE REDUCTION
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          do iocc=1,10
          
          iad = iocc+NSKP
           
          bsav(NAL+IBAS,NDL+LBAS,iocc) = bsav(NAL+IBAS,NDL+LBAS,iocc)
     &     + XLSSL(M)*DCONJG(COEF(NBS+JBAS,iad))*COEF(NCs+KBAS,iad)
C
          bsav(NAL+IBAS,NDS+LBAS,iocc) = bsav(NAL+IBAS,NDS+LBAS,iocc)
     &     + XLSLS(M)*DCONJG(COEF(NBS+JBAS,iad))*COEF(NCL+KBAS,iad)
C
          bsav(NAS+IBAS,NDL+LBAS,iocc) = bsav(NAS+IBAS,NDL+LBAS,iocc)
     &     + XSLSL(M)*DCONJG(COEF(NBL+JBAS,iad))*COEF(NCs+KBAS,iad)

          bsav(NAS+IBAS,NDS+LBAS,iocc) = bsav(NAS+IBAS,NDS+LBAS,iocc)
     &     + XSLLS(M)*DCONJG(COEF(NBL+JBAS,iad))*COEF(NCL+KBAS,iad)

          enddo
        ENDDO
      ENDDO

C
C**********************************************************************C
C     ADD THIS BATCH OF R-INTEGRALS TO OPEN-SHELL BREIT MATRIX         C
C**********************************************************************C
C
      IF(NOPN.EQ.0) GOTO 5100
C
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         DIRECT CONTRIBUTIONS
          QDIR(NAL+IBAS,NBS+JBAS) = QDIR(NAL+IBAS,NBS+JBAS)
     &                          + ACFF*XLSLS(M)*DENO(NCL+KBAS,NDS+LBAS)
     &                          + ACFF*XLSSL(M)*DENO(NCS+KBAS,NDL+LBAS)
C
          QDIR(NAS+IBAS,NBL+JBAS) = QDIR(NAS+IBAS,NBL+JBAS)
     &                          + ACFF*XSLLS(M)*DENO(NCL+KBAS,NDS+LBAS)
     &                          + ACFF*XSLSL(M)*DENO(NCS+KBAS,NDL+LBAS)
C
C         EXCHANGE CONTRIBUTIONS
          QXCH(NAL+IBAS,NDL+LBAS) = QXCH(NAL+IBAS,NDL+LBAS)
     &                          + BCFF*XLSSL(M)*DENO(NBS+JBAS,NCS+KBAS)
C
          QXCH(NAL+IBAS,NDS+LBAS) = QXCH(NAL+IBAS,NDS+LBAS)
     &                          + BCFF*XLSLS(M)*DENO(NBS+JBAS,NCL+KBAS)
C
          QXCH(NAS+IBAS,NDL+LBAS) = QXCH(NAS+IBAS,NDL+LBAS)
     &                          + BCFF*XSLSL(M)*DENO(NBL+JBAS,NCS+KBAS)

          QXCH(NAS+IBAS,NDS+LBAS) = QXCH(NAS+IBAS,NDS+LBAS)
     &                          + BCFF*XSLLS(M)*DENO(NBL+JBAS,NCL+KBAS)
C
        ENDDO
      ENDDO
C
5100  CONTINUE
C
C     MATRIX MULTIPLICATION STEP COMPLETE
      CALL CPU_TIME(T3)
      TB1M = TB1M+T3-T2
C
C**********************************************************************C
C     COMPLETE CONSTRUCTION OF ALL ONE-CENTRE CONTRIBUTIONS.           C
C**********************************************************************C
C
C     EARLY EXIT FOR MQN SELECTION RULES
4001  CONTINUE
C     END LOOP OVER ALL |MQN| SIGNS
4000  CONTINUE
C     END LOOP OVER ALL |MQN| MAGNITUDES
3000  CONTINUE
C     END LOOP OVER IBAS AND JBAS
2000  CONTINUE
C     EARLY EXIT FOR KQN SELECTION RULES
1001  CONTINUE
C     END LOOP OVER ALL KQNS
1000  CONTINUE
C
C     CALCULATION OF BREIT ENERGY
      ELLSS = 0.0D0
      ESSLL = 0.0D0
      ESLLS = 0.0D0
      ELSSL = 0.0D0
      DO IL=1,NSKP
        DO JL=1,NSKP
C
C         SMALL-COMPONENT LABELS
          IS = IL+NSKP
          JS = JL+NSKP
C
          ELLSS = ELLSS - 0.5D0*BXCH(IL,JL)*DENC(IL,JL)
          ESSLL = ESSLL - 0.5D0*BXCH(IS,JS)*DENC(IS,JS)
          ESLLS = ESLLS - 0.5D0*BXCH(IS,JL)*DENC(IS,JL)
          ELSSL = ELSSL - 0.5D0*BXCH(IL,JS)*DENC(IL,JS)
C
        ENDDO
      ENDDO
C
      do iocc=1,10
        do jocc=1,10
          jad = jocc+NSKP
          zllss(iocc,jocc) = 0.0d0
          zssll(iocc,jocc) = 0.0d0
          zslls(iocc,jocc) = 0.0d0
          zlssl(iocc,jocc) = 0.0d0
          do il=1,NSKP
            do jl=1,NSKP
              is = il+NSKP
              js = jl+NSKP
              zllss(iocc,jocc) = zllss(iocc,jocc) 
     &            - 0.5D0*bsav(il,jl,iocc)*COEF(il,jad)*COEF(jl,jad)
              zssll(iocc,jocc) = zssll(iocc,jocc) 
     &            - 0.5D0*bsav(is,js,iocc)*COEF(is,jad)*COEF(js,jad)
              zslls(iocc,jocc) = zslls(iocc,jocc) 
     &            - 0.5D0*bsav(is,jl,iocc)*COEF(is,jad)*COEF(jl,jad)
              zlssl(iocc,jocc) = zlssl(iocc,jocc) 
     &            - 0.5D0*bsav(il,js,iocc)*COEF(il,jad)*COEF(js,jad)
            enddo
          enddo
          ztotal(iocc,jocc) = zllss(iocc,jocc) + zssll(iocc,jocc)
     &                      + zslls(iocc,jocc) + zlssl(iocc,jocc)
c          write(*,*) iocc,jocc,zllss(iocc,jocc),zssll(iocc,jocc),
c     &               zslls(iocc,jocc),zlssl(iocc,jocc),ztotal(iocc,jocc)
        enddo
      enddo
c
601   FORMAT(1X,'(KA,KB)',9X,
     &              'E(LL|SS)',8X,'E(SS|LL)',8X,'E(SL|LS)',8X,
     &              'E(LS|SL)',10X,'E(TOT)')
602   FORMAT(1X,'(',I2,',',I2,')',3X,F14.10,2X,F14.10,2X,F14.10,2X,
     &                               F14.10,2X,F14.10,2X,F14.10,2X)
603   FORMAT(1X,'total',5X,F14.10,2X,F14.10,2X,F14.10,2X,F14.10,2X,
     &                                         F14.10,2X,F14.10,2X)

C
C     PRINT A HEADER
      WRITE(*,*) REPEAT('=',88)
      WRITE(*,601)
      WRITE(*,*) REPEAT('-',88)

      ellssnet  = 0.0d0
      essllnet  = 0.0d0
      esllsnet  = 0.0d0
      elsslnet  = 0.0d0
      etotalnet = 0.0d0


c     (s_1/2|s_1/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=1,4
        do jocc=1,4
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) -1,-1,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal
C
c     (s_1/2|p_1/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=1,4
        do jocc=5,6
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) -1,+1,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal
C
c     (s_1/2|p_3/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=1,4
        do jocc=7,10
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) -1,-2,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal
C
c     (p_1/2|s_1/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=5,6
        do jocc=1,4
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) +1,-1,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal
C
c     (p_1/2|p_1/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=5,6
        do jocc=5,6
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) +1,+1,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal
C
c     (p_1/2|p_3/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=5,6
        do jocc=7,10
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) +1,-2,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal
C
c     (p_3/2|s_1/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=7,10
        do jocc=1,4
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) -2,-1,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal
C
c     (p_3/2|p_1/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=7,10
        do jocc=5,6
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) -2,+1,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal
C
c     (p_3/2|p_3/2)
      ellss  = 0.0d0
      essll  = 0.0d0
      eslls  = 0.0d0
      elssl  = 0.0d0
      etotal = 0.0d0     
      do iocc=7,10
        do jocc=7,10
          ellss  = ellss  + zllss(iocc,jocc)
          essll  = essll  + zssll(iocc,jocc)
          eslls  = eslls  + zslls(iocc,jocc)
          elssl  = elssl  + zlssl(iocc,jocc)
          etotal = etotal + ztotal(iocc,jocc)
        enddo
      enddo
      write(*,602) -2,-2,ellss,essll,eslls,elssl,etotal
c
      ellssnet  = ellssnet + ellss
      essllnet  = essllnet + essll
      esllsnet  = esllsnet + eslls
      elsslnet  = elsslnet + elssl
      etotalnet = etotalnet + etotal

      WRITE(*,*) REPEAT('-',88)
      write(*,603) ellssnet,essllnet,esllsnet,elsslnet,etotalnet
      WRITE(*,*) REPEAT('=',88)
C
C     RECORD CPU TIME AT END OF BATCH AND ADD TO APPROPRIATE COUNTER
      CALL CPU_TIME(TBCH2)
      T2ES(1,5) = T2ES(1,5)+TBCH2-TBCH1
C
      RETURN
      END
C
C
      SUBROUTINE RKBRT1(RJLSSL,RJSLLS,RJSLSL,RJLSLS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            RRRRRRR  KK    KK BBBBBBB  RRRRRRR TTTTTTTT 11            C
C            RR    RR KK   KK  BB    BB RR    RR   TT   111            C
C            RR    RR KK  KK   BB    BB RR    RR   TT    11            C
C            RR    RR KKKKK    BBBBBBB  RR    RR   TT    11            C
C            RRRRRRR  KK  KK   BB    BB RRRRRRR    TT    11            C
C            RR    RR KK   KK  BB    BB RR    RR   TT    11            C
C            RR    RR KK    KK BBBBBBB  RR    RR   TT   1111           C
C                                                                      C
C -------------------------------------------------------------------- C
C  RKBRT1 EVALUATES A BATCH OF GENERAL (OPEN-SHELL) ONE-CENTRE RADIAL  C
C  INTEGRALS OVER THE BREIT INTERACTION, SEPARATING RESULTS BY THE     C
C  ALLOWED TENSOR ORDERS RK(ABCD).                                     C
C -------------------------------------------------------------------- C
C  DFNOTE: NOT WORKING YET...                                          C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+6)
C
      DIMENSION XJ(MB2,2),IAA(2),IBB(2)
      DIMENSION BETA(MB2),BTA1(MB2),XROOT(MB2),BIN(MB2),TRM(MB2)
      DIMENSION BDU(MB2,-MAB:MAB,-MAB:MAB),BDL(MB2,-MAB:MAB,-MAB:MAB)
C
      DIMENSION RJLSSL(MB2,MNU,2),RJSLLS(MB2,MNU,2),
     &          RJSLSL(MB2,MNU,2),RJLSLS(MB2,MNU,2)
C
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BKLS/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/BQNM/EXPT(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/RCFF/T0000,T1000,T0100,T0010,T0001,T1100,T1010,T1001,
     &            T0110,T0101,T0011,T1110,T1101,T1011,T0111,T1111,
     &            C1,C3,C5,C7,C9,V1,V2,V4,V8,VS
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
C**********************************************************************C
C     PREPARATION OF EXPONENT POWERS AND BETA FUNCTION ARGUMENTS.      C
C**********************************************************************C
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     GAUSSIAN EXPONENT FOR (IBAS,JBAS) OVERLAP
      TIJ0 = EI+EJ
C
C     INITIALISE THE ARRAY XJ(M,2) FOR INCOMPLETE BETA FUNCTION ARGS.
      DO M=1,MAXM
        TKL0    = EK(M)+EL(M)
        TIJKL   = TIJ0+TKL0
        XJ(M,1) = TIJ0/TIJKL
        XJ(M,2) = TKL0/TIJKL
      ENDDO
C
C**********************************************************************C
C     INLINE BETA FUNCTION CODE FOR DIRECT TERMS                       C
C**********************************************************************C
C
C     NUMBER OF LEVELS NEEDED TO ACCOUNT FOR ALL BETA INTEGRALS
      NVALS = (NUF-NUI)/2+2
C
C     LOOP OVER EXPANSION TERMINALS FOR FIRST PAIR
      DO NX=1,NVALS
        IAA(1) = LQN(1)+LQN(2)+NUI+2*NX
        IAA(2) = LQN(3)+LQN(4)+NUI+2*NX
C
C       LOOP OVER EXPANSION TERMINALS FOR SECOND PAIR
        DO NY=1,NVALS
          IBB(1) = LQN(3)+LQN(4)-NUF+2*NY-1
          IBB(2) = LQN(1)+LQN(2)-NUF+2*NY-1
C
C         LOOP OVER BETA INTEGRAL COMBINATIONS
          DO IBETA=1,2
            IA =(IAA(IBETA)-1)/2
            IB = IBB(IBETA)   /2
C
C           BEGIN CONDITIONAL STATEMENT OVER IB VALUES
C           CASE 1: IB > 1
            IF(IB.GT.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BTA1(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
              RA  = X
              RB  = DFLOAT(1-IB)
              RC  = X+1.0D0
              RD  = 1.0D0
              RCD = RC*RD
              FCT = RA*RB/RCD
              DO M=1,MAXM
                TRM(M) = FCT*XJ(M,IBETA)
                BIN(M) = 1.0D0+TRM(M)
              ENDDO
              RA = RA+1.0D0
              RB = RB+1.0D0
              RC = RC+1.0D0
              RD = RD+1.0D0
              DO IT=2,IB-1
                RCD = RC*RD
                FCT = RA*RB/RCD
                DO M=1,MAXM
                  TRM(M) = FCT*TRM(M)*XJ(M,IBETA)
                  BIN(M) = BIN(M)+TRM(M)
                ENDDO
                RA = RA+1.0D0
                RB = RB+1.0D0
                RC = RC+1.0D0
                RD = RD+1.0D0
              ENDDO
              DO M=1,MAXM
                BETA(M) = BTA1(M)*BIN(M)
              ENDDO
C
C           CASE 2: IB = 1
            ELSEIF(IB.EQ.1) THEN
              X  = DFLOAT(IA)+0.5D0
              IX = 2*IA+1
              DO M=1,MAXM
                BETA(M) = (DSQRT(XJ(M,IBETA))**IX)/X
              ENDDO
C
C           CASE 3: IB = 0
            ELSEIF(IB.EQ.0) THEN
              DO M=1,MAXM
                XROOT(M) = DSQRT(XJ(M,IBETA))
                DEN      = (1.0D0-XROOT(M))
                RAT      = (1.0D0+XROOT(M))/DEN
                BTA1(M)  = DLOG(RAT)
                BIN(M)   = 1.0D0
                TRM(M)   = XJ(M,IBETA)
              ENDDO
              IF(IA.GT.1) THEN
                DO K=2,IA
                  KK = 2*K-1
                  RK = DFLOAT(KK)
                  X  = 1.0D0/RK
                  DO M=1,MAXM
                    BIN(M) = BIN(M)+X*TRM(M)
                    TRM(M) = TRM(M)*XJ(M,IBETA)
                  ENDDO
                ENDDO
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)*BIN(M)
                ENDDO
              ELSEIF(IA.EQ.1) THEN
                DO M=1,MAXM
                  BETA(M) = BTA1(M)-2.0D0*XROOT(M)
                ENDDO
              ELSE
                DO M=1,MAXM
                  BETA(M) = BTA1(M)
                ENDDO
              ENDIF
C
C           END CONDITIONAL STATEMENT OVER IB VALUES
            ENDIF
C
            IF(IBETA.EQ.1) THEN
              DO M=1,MAXM
                BDU(M, NUI+2*NX  ,-NUF+2*NY-1) = BETA(M)
              ENDDO
            ELSE
              DO M=1,MAXM
                BDL(M, NUI+2*NX  ,-NUF+2*NY-1) = BETA(M)
              ENDDO
            ENDIF

          ENDDO

        ENDDO
      ENDDO
C
C**********************************************************************C
C     RADIAL INTEGRALS OVER SPINORS (SEPARATED BY TENSOR ORDER)        C
C**********************************************************************C
C
C     EMPTY COUNTER ARRAYS FOR DIRECT AND EXCHANGE INTEGRALS
      DO M=1,MAXM
        DO LTEN=1,NUNUM
          DO ILU=1,2
            RJLSLS(M,LTEN,ILU) = 0.0D0
            RJSLSL(M,LTEN,ILU) = 0.0D0
            RJSLLS(M,LTEN,ILU) = 0.0D0
            RJLSSL(M,LTEN,ILU) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     VALUE PREPARATION
      E0000 = 1.0D0
      E1000 = EI
      E0100 = EJ
      E1100 = EI*EJ
C
C     INITIATE LOOP OVER K,L BASIS FUNCTIONS
      DO M=1,MAXM
C
C       MORE VALUE PREPARATION
        E0010 = EK(M)
        E0001 = EL(M)
        E1010 = EI*EK(M)
        E1001 = EI*EL(M)
        E0110 = EJ*EK(M)
        E0101 = EJ*EL(M)
        E0011 = EK(M)*EL(M)
C
C       LOOP OVER THE TENSOR ORDERS OF THE BREIT INTERACTION
C       (U -> Z, L -> Z')
        DO LTEN=1,NUNUM
C
C         IMPORT NU VALUE FROM ARRAY
          NU = NUS(LTEN)
C
C         TEMPORARY STORAGE OF RAW RJ(LTEN,M)
          B21L = EIJ(-NU+1)*EKL(M, NU+2)*BDL(M, NU+2,-NU+1)
          B21U = EIJ( NU+2)*EKL(M,-NU+1)*BDU(M, NU+2,-NU+1)
          B23L = EIJ(-NU+3)*EKL(M, NU+2)*BDL(M, NU+2,-NU+3)
          B41U = EIJ( NU+4)*EKL(M,-NU+1)*BDU(M, NU+4,-NU+1)
          B41L = EIJ(-NU+1)*EKL(M, NU+4)*BDL(M, NU+4,-NU+1)
          B23U = EIJ( NU+2)*EKL(M,-NU+3)*BDU(M, NU+2,-NU+3)
          B43L = EIJ(-NU+3)*EKL(M, NU+4)*BDL(M, NU+4,-NU+3)
          B43U = EIJ( NU+4)*EKL(M,-NU+3)*BDU(M, NU+4,-NU+3)
C
C         EFFECTIVE INTERACTION STRENGTH RJLSSL(M,LTEN)
          RJLSSL(M,LTEN,1)
     &         = V4*T0000*E0110*C7*B43L - V2*T0010*E0100*C5*B23L
     &         - V2*T0100*E0010*C5*B41L + V1*T0110*E0000*C3*B21L
C
          RJLSSL(M,LTEN,2) 
     &         = V4*T0000*E0110*C7*B43U - V2*T0010*E0100*C5*B41U
     &         - V2*T0100*E0010*C5*B23U + V1*T0110*E0000*C3*B21U
C
C         EFFECTIVE INTERACTION STRENGTH RJSLLS(M,LTEN)
          RJSLLS(M,LTEN,1) 
     &         = V4*T0000*E1001*C7*B43L - V2*T0001*E1000*C5*B23L
     &         - V2*T1000*E0001*C5*B41L + V1*T1001*E0000*C3*B21L
C
          RJSLLS(M,LTEN,2) 
     &         = V4*T0000*E1001*C7*B43U - V2*T0001*E1000*C5*B41U
     &         - V2*T1000*E0001*C5*B23U + V1*T1001*E0000*C3*B21U
C
C         EFFECTIVE INTERACTION STRENGTH RJSLSL(M,LTEN)
          RJSLSL(M,LTEN,1)
     &         = V4*T0000*E1010*C7*B43L - V2*T0010*E1000*C5*B23L
     &         - V2*T1000*E0010*C5*B41L + V1*T1010*E0000*C3*B21L
C
          RJSLSL(M,LTEN,2)
     &         = V4*T0000*E1010*C7*B43U - V2*T0010*E1000*C5*B41U
     &         - V2*T1000*E0010*C5*B23U + V1*T1010*E0000*C3*B21U
C
C         EFFECTIVE INTERACTION STRENGTH RJLSLS(M,LTEN)
          RJLSLS(M,LTEN,1) 
     &         = V4*T0000*E0101*C7*B43L - V2*T0001*E0100*C5*B23L
     &         - V2*T0100*E0001*C5*B41L + V1*T0101*E0000*C3*B21L
C
          RJLSLS(M,LTEN,2) 
     &         = V4*T0000*E0101*C7*B43U - V2*T0001*E0100*C5*B41U
     &         - V2*T0100*E0001*C5*B23U + V1*T0101*E0000*C3*B21U
C
C         SKIP POINT FOR NON-RELATIVISTIC HAMILTONIANS
999       CONTINUE
C
C       END LOOP OVER TENSOR ORDERS
        ENDDO
C
C     END LOOP OVER K,L BASIS FUNCTIONS
      ENDDO
C
C**********************************************************************C
C     APPLY NORMALISATION FACTORS                                      C
C**********************************************************************C
C
      DO M=1,MAXM
        RNLSLS = RNIJ(4)*RNKL(M,4)
        RNSLSL = RNIJ(2)*RNKL(M,2)
        RNSLLS = RNIJ(2)*RNKL(M,4)
        RNLSSL = RNIJ(4)*RNKL(M,2)
        DO LTEN=1,NUNUM
          DO ILU=1,2
            RJLSLS(M,LTEN,ILU) = RNLSLS*RJLSLS(M,LTEN,ILU)
            RJSLSL(M,LTEN,ILU) = RNSLSL*RJSLSL(M,LTEN,ILU)
            RJSLLS(M,LTEN,ILU) = RNSLLS*RJSLLS(M,LTEN,ILU)
            RJLSSL(M,LTEN,ILU) = RNLSSL*RJLSSL(M,LTEN,ILU)
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE ANGBRT1(DKAB,DKCD,EMAT,KQN,LQN,ISEL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          AA    NN    NN  GGGGGG  BBBBBBB  RRRRRRR TTTTTTTT 11        C
C         AAAA   NNN   NN GG    GG BB    BB RR    RR   TT   111        C
C        AA  AA  NNNN  NN GG       BB    BB RR    RR   TT    11        C
C       AA    AA NN NN NN GG       BBBBBBB  RR    RR   TT    11        C
C       AAAAAAAA NN  NNNN GG   GGG BB    BB RRRRRRR    TT    11        C
C       AA    AA NN   NNN GG    GG BB    BB RR    RR   TT    11        C
C       AA    AA NN    NN  GGGGGG  BBBBBBB  RR    RR   TT   1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  ANGBRT1 PERFORMS THE ANGULAR ANALYSIS FOR THE EVALUATION OF TWO     C
C  ELECTRON INTEGRALS USING RACAH ALGEBRA TECHNIQUES. (OPEN-SHELL.)    C
C -------------------------------------------------------------------- C
C  DFNOTE: NOT WORKING YET...                                          C
C**********************************************************************C
      PARAMETER(MKP=9,MNU=MKP+1)
C
      DIMENSION KQN(4),LQN(4),JQN(4)
      DIMENSION EMAT(MNU,8),SCOEFF(8,2)
      DIMENSION DKAB(MNU,MKP+1,MKP+1),DKCD(MNU,MKP+1,MKP+1)
C
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
C     INITIALISE BREIT COEFFICIENTS
      DO INU=1,MNU
        DO IMU=1,8
          EMAT(INU,IMU) = 0.0D0
        ENDDO
        NUS(INU) = 0
      ENDDO
C
C     ASSIGN JQN VALUES
      DO N=1,4
        JQN(N) = 2*IABS(KQN(N))-1
      ENDDO
C
C**********************************************************************C
C     PARITY ANALYSIS: CHECK UNDERLYING LQN COMBINATIONS AND EXIT      C
C     IF THERE IS NO MULTIPOLE EXPANSION OF THE INTERACTION.           C
C**********************************************************************C
C
C     A AND B: LQN(1)+LQN(2) EVEN OR ODD
      IF(MOD(LQN(1)+LQN(2),2).EQ.0) THEN
        IPARAB = 1
      ELSE
        IPARAB = 0
      ENDIF
C
C     C AND D: LQN(3)+LQN(4) EVEN OR ODD
      IF(MOD(LQN(3)+LQN(4),2).EQ.0) THEN
        IPARCD = 1
      ELSE
        IPARCD = 0
      ENDIF
C
C     LQN SELECTION RULE: BOTH LQN PAIRS MUST BE OF SAME SYMMETRY
      IF(IPARAB.EQ.IPARCD) THEN
        ISEL = 1
      ELSE
        ISEL = 0
        RETURN
      ENDIF
C
C**********************************************************************C
C     MULTIPOLE EXPANSION UPPER/LOWER LIMITS SATISFY TRIANGLE RULE.    C
C**********************************************************************C
C
      NUI = MAX0(IABS(JQN(1)-JQN(2))/2,IABS(JQN(3)-JQN(4))/2)
      NUF = MIN0(    (JQN(1)+JQN(2))/2,    (JQN(3)+JQN(4))/2)
C
C     JQN SELECTION RULE: TRIANGLE RULE MUST PROVIDE VALID NU RANGE
      IF(NUI.GT.NUF) THEN
        ISEL = 0
        RETURN
      ELSE
        ISEL = 1
      ENDIF
C
C**********************************************************************C
C     LQN SELECTION RULE PARITY ANALYSIS: PAIRS BOTH EVEN OR BOTH ODD. C
C     ALSO CALCULATE BREIT FACTORS IN THIS SECTION.                    C
C**********************************************************************C
C
      ISEL = 0
      LTEN = 1
      DO NU=NUI,NUF
C
C       A AND B: LQN(1)+LQN(2)+NU EVEN OR ODD
        IF(MOD(LQN(1)+LQN(2)+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
C       C AND D: LQN(3)+LQN(4)+NU EVEN OR ODD
        IF(MOD(LQN(3)+LQN(4)+NU,2).EQ.0) THEN
          IPARCD = 1
        ELSE
          IPARCD = 0
        ENDIF
C
C       CASE 1: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH ODD (UNLESS NU=0)
        IF(IPARAB.EQ.0.AND.IPARCD.EQ.0.AND.NU.NE.0) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         BREIT COEFFICIENT IS SIMPLE ENOUGH TO CALCULATE HERE
          RNU  = DFLOAT(NU*(NU+1))
          COEF =-DFLOAT((KQN(1)+KQN(2))*(KQN(3)+KQN(4)))/RNU
C
C         SAVE THIS PARTICULAR NU VALUE TO A LIST
          NUS(LTEN) = NU
C
C         COPY ACROSS TO ARRAY
          DO IMU=1,8
            EMAT(LTEN,IMU) = EMAT(LTEN,IMU) + COEF
          ENDDO
C
        ENDIF
C
C       CASE 2: LQNA+LQNB+NU AND LQNC+LQND+NU ARE BOTH EVEN
        IF(IPARAB.EQ.1.AND.IPARCD.EQ.1) THEN
C
C         THERE IS A NON-TRIVIAL TENSOR EXPANSION
          ISEL = 1
C
C         CALCULATE BREIT COEFFICIENTS WITH CALL TO BRCOEF1
          CALL BRCOEF1(SCOEFF,KQN,NU)
C
C         SAVE THIS PARTICULAR NU VALUE TO A LIST
          NUS(LTEN) = NU-1
C
C         COPY ACROSS TO ARRAY
          DO IMU=1,8
            EMAT(LTEN,IMU) = EMAT(LTEN,IMU) + SCOEFF(IMU,1)
          ENDDO
C
C         INCREASE TENSOR ORDER ONLY IF NU NONZERO
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         SAVE THIS PARTICULAR NU VALUE TO A LIST
          NUS(LTEN) = NU+1
C          
C         COPY ACROSS TO ARRAY
          DO IMU=1,8
            EMAT(LTEN,IMU) = EMAT(LTEN,IMU) + SCOEFF(IMU,2)
          ENDDO
C
        ENDIF
C
      ENDDO
C
C     RE-SET THE LOWER AND UPPER LIMITS OF THE EXPANSION
      NUI = NUS(1)
      NUF = NUS(LTEN)
      NUNUM = LTEN
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, EXIT PROCEDURE
      IF(ISEL.EQ.0) THEN
        RETURN
      ENDIF
C
C**********************************************************************C
C     ANGULAR FACTORS: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|      C
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.   C
C**********************************************************************C
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(1),-MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(1),+MJA,JQN(2),-MJB,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(1),-MJA,JQN(2),+MJB,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(1),+MJA,JQN(2),+MJB,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
C     THE ARGUMENTS OF DK COEFFICIENTS ARE REVERSED IN THE CASE OF THE
C     CD PAIRS IN ORDER TO ACCOMMODATE THE RELATION:
C               DK(J,M,J',M',L) = ((-1)^Q)*DK(J'M',J,M,L).
C
C     LOOP OVER MQN(C) AND MQN(D) VALUES
      DO MC=1,IABS(KQN(3))
        MJC = 2*MC-1
        DO MD=1,IABS(KQN(4))
          MJD = 2*MD-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKCD(LTEN,MJC  ,MJD  ) = DK(JQN(4),-MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD  ) = DK(JQN(4),-MJD,JQN(3),+MJC,NU)
            DKCD(LTEN,MJC  ,MJD+1) = DK(JQN(4),+MJD,JQN(3),-MJC,NU)
            DKCD(LTEN,MJC+1,MJD+1) = DK(JQN(4),+MJD,JQN(3),+MJC,NU)
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE BRCOEF1(SCOEFF,KQN,NU)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      BBBBBBB  RRRRRRR   CCCCCC   OOOOOO  EEEEEEEE FFFFFFFF 11        C
C      BB    BB RR    RR CC    CC OO    OO EE       FF      111        C
C      BB    BB RR    RR CC       OO    OO EE       FF       11        C
C      BBBBBBB  RR    RR CC       OO    OO EEEEEE   FFFFFF   11        C
C      BB    BB RRRRRRR  CC       OO    OO EE       FF       11        C
C      BB    BB RR    RR CC    CC OO    OO EE       FF       11        C
C      BBBBBBB  RR    RR  CCCCCC   OOOOOO  EEEEEEEE FF      1111       C
C                                                                      C
C -------------------------------------------------------------------- C
C  BRCOEF1 EVALUATES THE INTERMEDIATE COEFFICIENTS OF THE BREIT        C
C  INTERACTION IN THE GENERAL CASE (TABLE 2 OF GRANT AND PYPER 1976).  C
C**********************************************************************C
      DIMENSION SCOEFF(8,2),KQN(4)
C
      RNU = DFLOAT(NU)
      RK1 = DFLOAT(KQN(2)-KQN(1))
      RK2 = DFLOAT(KQN(4)-KQN(3))
C
      IF(NU-1.GE.0) THEN
        B1 = DFLOAT(NU+1)/DFLOAT(2   *(2*NU+1))
        C1 =-DFLOAT(NU-2)/DFLOAT(2*NU*(2*NU+1))
        SCOEFF(1,1) = (RNU+RK1)*(B1+C1*RK2)
        SCOEFF(2,1) = (RNU+RK2)*(B1+C1*RK1)
        SCOEFF(3,1) = (RNU-RK1)*(B1-C1*RK2)
        SCOEFF(4,1) = (RNU-RK2)*(B1-C1*RK1)
        SCOEFF(5,1) =-(RNU+RK1)*(B1-C1*RK2)
        SCOEFF(6,1) =-(RNU-RK2)*(B1+C1*RK1)
        SCOEFF(7,1) =-(RNU-RK1)*(B1+C1*RK2)
        SCOEFF(8,1) =-(RNU+RK2)*(B1-C1*RK1)
      ELSE
        SCOEFF(1,1) = 0.0D0
        SCOEFF(2,1) = 0.0D0
        SCOEFF(3,1) = 0.0D0
        SCOEFF(4,1) = 0.0D0
        SCOEFF(5,1) = 0.0D0
        SCOEFF(6,1) = 0.0D0
        SCOEFF(7,1) = 0.0D0
        SCOEFF(8,1) = 0.0D0
      ENDIF
C
      IF(NU+1.GE.1) THEN
        B2 = DFLOAT(NU  )/DFLOAT(2       *(2*NU+3))
        C2 = DFLOAT(NU+3)/DFLOAT(2*(NU+1)*(2*NU+3))
        SCOEFF(1,2) = ( RK2-RNU-1.0D0)*(B2+C2*RK1)
        SCOEFF(2,2) = ( RK1-RNU-1.0D0)*(B2+C2*RK2)
        SCOEFF(3,2) = (-RK2-RNU-1.0D0)*(B2-C2*RK1)
        SCOEFF(4,2) = (-RK1-RNU-1.0D0)*(B2-C2*RK2)
        SCOEFF(5,2) =-(-RK2-RNU-1.0D0)*(B2+C2*RK1)
        SCOEFF(6,2) =-( RK1-RNU-1.0D0)*(B2-C2*RK2)
        SCOEFF(7,2) =-( RK2-RNU-1.0D0)*(B2-C2*RK1)
        SCOEFF(8,2) =-(-RK1-RNU-1.0D0)*(B2+C2*RK2)
      ELSE
        SCOEFF(1,2) = 0.0D0
        SCOEFF(2,2) = 0.0D0
        SCOEFF(3,2) = 0.0D0
        SCOEFF(4,2) = 0.0D0
        SCOEFF(5,2) = 0.0D0
        SCOEFF(6,2) = 0.0D0
        SCOEFF(7,2) = 0.0D0
        SCOEFF(8,2) = 0.0D0
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE IJSET1
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              IIII     JJJJ SSSSSS  EEEEEEEE TTTTTTTT 11              C
C               II       JJ SS    SS EE          TT   111              C
C               II       JJ SS       EE          TT    11              C
C               II       JJ  SSSSSS  EEEEEE      TT    11              C
C               II       JJ       SS EE          TT    11              C
C               II JJ    JJ SS    SS EE          TT    11              C
C              IIII JJJJJJ   SSSSSS  EEEEEEEE    TT   1111             C
C                                                                      C
C -------------------------------------------------------------------- C
C  IJSET1 PREPARES BASIS SET INTERMEDIATES FOR ALL IJ-PAIRS OF BASIS   C
C  FUNCTIONS, FOR USE IN ROUTINES RKCLM1/RKBRT1.                       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,MNU=MKP+1,MAB=2*MNU+6)
C
      COMMON/BIJS/EIJ(-MAB:MAB),RNIJ(4),EI,EJ,IBAS,JBAS
      COMMON/BQNM/EXPT(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
      DATA TWOLOG/6.93147180559945309D-1/
C
C     GAUSSIAN EXPONENTS FOR THIS PAIR
      EI = EXPT(IBAS,1)
      EJ = EXPT(JBAS,2)
C
C     NORMALISATION CONSTANTS FOR EXPONENT EI
      RL = DFLOAT(LQN(1))
      G1 = TWOLOG-GAMLOG(2*LQN(1)+3)
      G2 = TWOLOG-GAMLOG(2*LQN(1)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
C
      ELOG = DLOG(2.0D0*EI)
      RNLI = DEXP(0.5D0*(G1+R1*ELOG))
      RNSI = DEXP(0.5D0*(G2+R2*ELOG))
C
C     NORMALISATION CONSTANTS FOR EXPONENT EJ
      RL = DFLOAT(LQN(2))
      G1 = TWOLOG-GAMLOG(2*LQN(2)+3)
      G2 = TWOLOG-GAMLOG(2*LQN(2)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
C
      ELOG = DLOG(2.0D0*EJ)
      RNLJ = DEXP(0.5D0*(G1+R1*ELOG))
      RNSJ = DEXP(0.5D0*(G2+R2*ELOG))
C
C     COMPOSITE NORMALISATION CONSTANTS
      RNIJ(1) = RNLI*RNLJ
      RNIJ(2) = RNSI*RNLJ
      RNIJ(3) = RNSI*RNSJ
      RNIJ(4) = RNLI*RNSJ
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     LOWEST EXPONENT POWER
      IPOWER = LQN(1)+LQN(2)-NUF
C
C     SEED GAUSSIAN EXPONENT VALUE
      EIJ0 = EI+EJ
      EIJR = DSQRT(EIJ0)
      EIJ(-NUF) = EIJR**(-IPOWER)
C
C     LOOP OVER ALL TENSOR ORDERS AND DIVIDE
      DO IPOW=-NUF+1,NUF+5
        EIJ(IPOW) = EIJ(IPOW-1)/EIJR
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE KLSET1(ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            KK    KK LL       SSSSSS  EEEEEEEE TTTTTTTT 11            C
C            KK   KK  LL      SS    SS EE          TT   111            C
C            KK  KK   LL      SS       EE          TT    11            C
C            KKKKK    LL       SSSSSS  EEEEEE      TT    11            C
C            KK  KK   LL            SS EE          TT    11            C
C            KK   KK  LL      SS    SS EE          TT    11            C
C            KK    KK LLLLLLLL SSSSSS  EEEEEEEE    TT   1111           C
C                                                                      C
C -------------------------------------------------------------------- C
C  KLSET1 PREPARES BASIS SET INTERMEDIATES FOR ALL IJ-PAIRS OF BASIS   C
C  FUNCTIONS, FOR USE IN ROUTINES RKCLM1/RKBRT1.                       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MNU=MKP+1,MAB=2*MNU+6)
C
      DIMENSION RNLC(MBS),RNSC(MBS),RNLD(MBS),RNSD(MBS)
      DIMENSION EKL0(MB2)
C
      COMMON/BKLS/EKL(MB2,-MAB:MAB),RNKL(MB2,4),EK(MB2),EL(MB2)
      COMMON/BQNM/EXPT(MBS,4),MQN(4),KQN(4),LQN(4),NBAS(4),MAXM
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TNUS/NUS(MNU),NUI,NUF,NUNUM
C
      DATA TWOLOG/6.93147180559945309D-1/
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST C
      RL = DFLOAT(LQN(3))
      G1 = TWOLOG-GAMLOG(2*LQN(3)+3)
      G2 = TWOLOG-GAMLOG(2*LQN(3)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO KBAS=1,NBAS(3)
        EKV        = BSET(KBAS,LQN(3)+1,ICNT)
        ELOG       = DLOG(2.0D0*EKV)
        RNLC(KBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNSC(KBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     NORMALISATION CONSTANTS FOR EXPONENTS IN LIST D
      RL = DFLOAT(LQN(4))
      G1 = TWOLOG-GAMLOG(2*LQN(4)+3)
      G2 = TWOLOG-GAMLOG(2*LQN(4)+5)
      R1 = RL+1.5D0
      R2 = RL+0.5D0
      DO LBAS=1,NBAS(4)
        ELV        = BSET(LBAS,LQN(4)+1,ICNT)
        ELOG       = DLOG(2.0D0*ELV)
        RNLD(LBAS) = DEXP(0.5D0*(G1+R1*ELOG))
        RNSD(LBAS) = DEXP(0.5D0*(G2+R2*ELOG))
      ENDDO
C
C     LIST OF EXPONENTS AND NORMALISATION COEFFICIENTS IN THE BLOCK
      M = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
          EK(M)     = BSET(KBAS,LQN(3)+1,ICNT)
          EL(M)     = BSET(LBAS,LQN(4)+1,ICNT)
          EKL0(M)   = EK(M)+EL(M)
          RNKL(M,1) = RNLC(KBAS)*RNLD(LBAS)
          RNKL(M,2) = RNSC(KBAS)*RNLD(LBAS)
          RNKL(M,3) = RNSC(KBAS)*RNSD(LBAS)
          RNKL(M,4) = RNLC(KBAS)*RNSD(LBAS)
        ENDDO
      ENDDO
C
C     TENSOR ORDER LIMITS
      NUI = NUS(1)
      NUF = NUS(NUNUM)
C
C     LOWEST EXPONENT POWER
      IPOWER = LQN(3)+LQN(4)-NUF
C
C     GAUSSIAN OVERLAPS TO ALL REQUIRED POWERS
      DO M=1,MAXM
C
C       SEED GAUSSIAN EXPONENT VALUE
        EKLR = DSQRT(EKL0(M))
        EKL(M,-NUF) = EKLR**(-IPOWER)
C
C       LOOP OVER ALL TENSOR ORDERS AND DIVIDE
        DO IPOW=-NUF+1,NUF+5
          EKL(M,IPOW) = EKL(M,IPOW-1)/EKLR
        ENDDO
C
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE TESTANG(KQN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     TTTTTTTT EEEEEEEE SSSSSS TTTTTTTT   AA    NN    NN  GGGGGG       C
C        TT    EE      SS    SS   TT     AAAA   NNN   NN GG    GG      C
C        TT    EE      SS         TT    AA  AA  NNNN  NN GG            C
C        TT    EEEEEE   SSSSSS    TT   AA    AA NN NN NN GG            C
C        TT    EE            SS   TT   AAAAAAAA NN  NNNN GG   GGG      C
C        TT    EE      SS    SS   TT   AA    AA NN   NNN GG    GG      C
C        TT    EEEEEEEE SSSSSS    TT   AA    AA NN    NN  GGGGGG       C
C                                                                      C
C -------------------------------------------------------------------- C
C  TESTANG IS A ROUTINE THAT PRINTS A TABLE OF ANGULAR COEFFICIENTS,   C
C  DK(J M ,J'M') FOR AN ALLOWED NUMBER OF TENSOR POWERS K, AND ALL     C
C  COMBINATIONS OF JA, JB, MA, MB FOR GIVEN SYMMETRY TYPES KA, KB.     C
C -------------------------------------------------------------------- C
C  NOTE: MUST CALL 'FACTRLS' ROUTINE AT SOME POINT BEFORE THIS.        C
C        FACTORS ARE PRESENTED AS THEIR SQUARES (SIGNS RETAINED), WITH C
C        AN EXTRA OPTION TO MULTIPLY THEM AGAIN BY A FACTOR F(NU).     C
C**********************************************************************C
      PARAMETER(MKP=9,MNU=MKP+1)
C
      CHARACTER*4  HMLT
C
      DIMENSION KQN(2),JQN(2),LQN(2)
      DIMENSION NUS(MNU),FMLT(MNU)
      DIMENSION BK(MNU)
      DIMENSION ELL(MNU),ESL(MNU),ESS(MNU),GSL(MNU)
      DIMENSION DKAB(MNU,MKP+1,MKP+1)
C
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
C
C     CALL FACTORIAL ROUTINE FOR USE IN SYM3J
      CALL FACTRLS
C
C     OVER-RIDE INPUT KQN VALUES
      KQN(1) =-1
      KQN(2) =-1
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE LQN VALUES
      DO I=1,2
        IF(KQN(I).LT.0) THEN
          LQN(I) =-KQN(I)-1
        ELSE
          LQN(I) = KQN(I)
        ENDIF
      ENDDO
C
C     ALLOWED TENSOR POWERS
      NUI = IABS(JQN(1)-JQN(2))/2
      NUF =     (JQN(1)+JQN(2))/2
      NUNUM = NUF-NUI+1
C
C     IF NO NU VALUES WERE ALLOWED DURING THIS RUN, QUIT PROCEDURE
      IF(NUNUM.EQ.0) RETURN
C
C**********************************************************************C
C     CLOSED-SHELL COULOMB EXCHANGE TERMS, BK(JJ').                    C
C**********************************************************************C
C
C     LOOP OVER ALL TENSOR ORDERS ALLOWED BY TRIANGLE CONDITION
      LTEN = 0
      DO NU=NUI,NUF
C
C       TEST WHETHER 'LQNA+LQNB+NU' ODD OR EVEN
        IF(MOD(LQN(1)+LQN(2)+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.1) THEN
C       ONLY ANGULAR COEFFICIENTS OF EVEN PARITY ARE NON-ZERO
C
C         SAVE THIS TENSOR ORDER
          LTEN = LTEN+1
          NUS(LTEN) = NU
C
          IF(HMLT.EQ.'NORL') THEN
            BK(LTEN) = 0.5D0*ABC000(LQN(1),LQN(2),NU)
          ELSE
            BK(LTEN) =      SYM3JSQ(JQN(1),JQN(2),NU)
          ENDIF
        ENDIF
C
      ENDDO
C
C     NUMBER OF SURVIVING TENSOR ORDERS
      NUNUM = LTEN
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' CLOSED COULOMB EXCHANGE COEFFICIENTS:'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
301   FORMAT(1X,A, 1(1X,F13.9))
302   FORMAT(1X,A, 2(1X,F13.9))
303   FORMAT(1X,A, 3(1X,F13.9))
304   FORMAT(1X,A, 4(1X,F13.9))
305   FORMAT(1X,A, 5(1X,F13.9))
306   FORMAT(1X,A, 6(1X,F13.9))
307   FORMAT(1X,A, 7(1X,F13.9))
308   FORMAT(1X,A, 8(1X,F13.9))
309   FORMAT(1X,A, 9(1X,F13.9))
310   FORMAT(1X,A,10(1X,F13.9))
311   FORMAT(1X,A,11(1X,F13.9))
312   FORMAT(1X,A,12(1X,F13.9))
313   FORMAT(1X,A,13(1X,F13.9))
314   FORMAT(1X,A,14(1X,F13.9))
C
      IF(NUNUM.EQ.1) THEN
        WRITE(*,301) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,302) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,303) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,304) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,305) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,306) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,307) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,308) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,309) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,310) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,311) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,312) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,313) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,314) 'BK(JA,JB)         ',(BK(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
C**********************************************************************C
C     CLOSED-SHELL BREIT EXCHANGE TERMS, EK(JJ') AND GK(JJ').          C
C**********************************************************************C
C
C     INITIALISE COEFFICIENT ARRAYS
      DO LTEN=1,NUF-NUI+1
        ELL(LTEN) = 0.0D0
        ESL(LTEN) = 0.0D0
        ESS(LTEN) = 0.0D0
        GSL(LTEN) = 0.0D0
      ENDDO
C
C     LOOP OVER ALL TENSOR ORDERS ALLOWED BY TRIANGLE CONDITION
      LTEN = 1
      DO NU=NUI,NUF
C
C       RAW SQUARED 3J-SYMBOL
        RAW = SYM3JSQ(JQN(1),JQN(2),NU)
C
C       FLOATING-POINT VERSIONS OF TENSOR ORDER AND KQN DIFFERENCE
        RU  = DFLOAT(NU)
        RK  = DFLOAT(KQN(2)-KQN(1))
        RP  = DFLOAT(KQN(1)+KQN(2))
C
C       TEST WHETHER PARITY OF 'LQNA+LQNB+NU' IS ODD OR EVEN
        IF(MOD(LQN(1)+LQN(2)+NU,2).EQ.0) THEN
          IPARAB = 1
        ELSE
          IPARAB = 0
        ENDIF
C
        IF(IPARAB.EQ.0.AND.NU.NE.0) THEN
C       ANGULAR COEFFICIENTS OF ODD PARITY
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU
C
C         CONTRIBUTIONS TO ANGULAR TERMS
          ELL(LTEN) = ELL(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
          ESS(LTEN) = ESS(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
          ESL(LTEN) = ESL(LTEN) + RAW*RP*RP/DFLOAT(NU*(NU+1))
C
        ELSEIF(IPARAB.EQ.1) THEN
C       ANGULAR COEFFICIENTS OF EVEN PARITY
C
C         DOWN-LADDER ENTRIES...
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          NUS(LTEN) = NU-1
C
C         ADD TO ARRAY ELEMENTS ONLY IF EFFECTIVE TENSOR ORDER >= 0
          IF(NU-1.GE.0) THEN
            B1 = DFLOAT(NU+1)/DFLOAT(2*(2*NU-1))
            C1 =-DFLOAT(NU-2)/DFLOAT(2*(2*NU-1)*NU)
            ELL(LTEN) = ELL(LTEN) + RAW*((RU+RK)*(B1+C1*RK))
            ESL(LTEN) = ESL(LTEN) - RAW*((B1*RU)-(C1*RK*RK))
            ESS(LTEN) = ESS(LTEN) + RAW*((RU-RK)*(B1-C1*RK))
            GSL(LTEN) = GSL(LTEN) - RAW*(    RK *(B1-C1*RU))
          ENDIF
C
C         SAVE THIS TENSOR ORDER NU TO THE LTEN ELEMENT OF 'NUS'
          IF(NU.GT.0) THEN
            LTEN = LTEN+1
          ENDIF
C
C         UP-LADDER ENTRIES...
          NUS(LTEN) = NU+1
C
C         ADD TO ARRAY ELEMENTS ONLY IF EFFECTIVE TENSOR ORDER >= 1
          IF(NU+1.GE.1) THEN
            B2 = DFLOAT(NU  )/DFLOAT(2*(2*NU+3))
            C2 = DFLOAT(NU+3)/DFLOAT(2*(NU+1)*(2*NU+3))
            ELL(LTEN) = ELL(LTEN) + RAW*((RK-RU-1.0D0)*( B2+C2*RK))
            ESL(LTEN) = ESL(LTEN) + RAW*((B2*(RU+1.0D0))+C2*RK*RK)
            ESS(LTEN) = ESS(LTEN) - RAW*((RK+RU+1.0D0)*( B2-C2*RK))
            GSL(LTEN) = GSL(LTEN) + RAW*(C2*RK*(RU+1.0D0)+B2*RK)
          ENDIF
C
        ENDIF
C
      ENDDO
      
      NUNUM = LTEN
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' CLOSED BREIT EXCHANGE COEFFICIENTS:'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
      IF(NUNUM.EQ.1) THEN
        WRITE(*,301) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,301) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,302) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,302) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,303) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,303) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,304) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,304) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,305) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,305) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,306) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,306) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,307) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,307) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,308) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,308) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,309) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,309) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,310) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,310) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,311) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,311) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,312) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,312) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,313) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,313) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,314) 'EK(JA,JB;LL)      ',(ELL(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'EK(JA,JB;SS)      ',(ESS(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'EK(JA,JB;SL)      ',(ESL(LTEN),LTEN=1,NUNUM)
        WRITE(*,314) 'GK(JA,JB;SL)      ',(GSL(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
C**********************************************************************C
C     GENERAL COULOMB TERMS, DK(J M ;J'M').                            C
C**********************************************************************C
C
C     RESTORE ORIGINAL TENSOR ORDER RANGE
      NUNUM = NUF-NUI+1
C
C     ASSIGN THE TENSOR POWERS TO A LIST
      LTEN = 0
      DO NU=NUI,NUF
        LTEN      = LTEN+1
        NUS(LTEN) = NU
      ENDDO
C
C     ANGULAR FACTORS: EVALUATE AN ANGULAR FACTOR FOR EVERY |MQN|
C     COMBINATION IN THE MULTIPOLE EXPANSION OVER ALLOWED NU VALUES.
C     REVERSE (JA,MA) WITH (JB,MB) INPUTS TO ACCOMMODATE THE RELATION:
C                DK(J,M,J',M',L) = ((-1)^Q)*DK(J'M',J,M,L).
C
C     ASSIGN PRE-FACTORS TO TENSOR POWERS
      DO LTEN=1,NUNUM
        FMLT(LTEN) = 1.0D0
      ENDDO
C
C     LOOP OVER MQN(A) AND MQN(B) VALUES
      DO MA=1,IABS(KQN(1))
        MJA = 2*MA-1
        DO MB=1,IABS(KQN(2))
          MJB = 2*MB-1
C
C         LOOP OVER ALL SURVIVING TENSOR ORDERS
          DO LTEN=1,NUNUM
C
C           READ THE ACTUAL ORDER NU
            NU = NUS(LTEN)
C
C           GENERATE AN ANGULAR FACTOR FOR ALL |MQN| SIGNS
            DKAB(LTEN,MJA  ,MJB  ) = DK(JQN(2),-MJB,JQN(1),-MJA,NU)
            DKAB(LTEN,MJA+1,MJB  ) = DK(JQN(2),-MJB,JQN(1),+MJA,NU)
            DKAB(LTEN,MJA  ,MJB+1) = DK(JQN(2),+MJB,JQN(1),-MJA,NU)
            DKAB(LTEN,MJA+1,MJB+1) = DK(JQN(2),+MJB,JQN(1),+MJA,NU)
C
C            G1 = FMLT(LTEN)*DKAB(LTEN,MJA  ,MJB  )
C            G2 = FMLT(LTEN)*DKAB(LTEN,MJA+1,MJB  )
C            G3 = FMLT(LTEN)*DKAB(LTEN,MJA  ,MJB+1)
C            G4 = FMLT(LTEN)*DKAB(LTEN,MJA+1,MJB+1)
CC
CC           SQUARE THE RESULT BUT KEEP THE SIGN
C            F1 = DSIGN(1.0D0,G1)
C            F2 = DSIGN(1.0D0,G2)
C            F3 = DSIGN(1.0D0,G3)
C            F4 = DSIGN(1.0D0,G4)
CC
C            DKAB(LTEN,MJA  ,MJB  ) = F1*G1*G1
C            DKAB(LTEN,MJA+1,MJB  ) = F2*G2*G2
C            DKAB(LTEN,MJA  ,MJB+1) = F3*G3*G3
C            DKAB(LTEN,MJA+1,MJB+1) = F4*G4*G4
C
          ENDDO
C
C       END THE LOOP OVER MQN(A)
        ENDDO
C     END THE LOOP OVER MQN(B)
      ENDDO
C
C     GENERATE A TABLE OF RESULTS AND PRINT TO TERMINAL
C
C     PRINT A HEADER
      NLNES = 18+14*NUNUM
      WRITE(*,*)
      WRITE(*,*) ' GENERAL COULOMB COEFFICIENTS D^K(JA,MA;JB,MB):'
      WRITE(*,*) REPEAT('=',NLNES)
      IF(NUNUM.EQ.1) THEN
        WRITE(*,101) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.2) THEN
        WRITE(*,102) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.3) THEN
        WRITE(*,103) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.4) THEN
        WRITE(*,104) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.5) THEN
        WRITE(*,105) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.6) THEN
        WRITE(*,106) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.7) THEN
        WRITE(*,107) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.8) THEN
        WRITE(*,108) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.9) THEN
        WRITE(*,109) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.10) THEN
        WRITE(*,110) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.11) THEN
        WRITE(*,111) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.12) THEN
        WRITE(*,112) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.13) THEN
        WRITE(*,113) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ELSEIF(NUNUM.EQ.14) THEN
        WRITE(*,114) JQN(1),JQN(2),(NUS(LTEN),LTEN=1,NUNUM)
      ENDIF
      WRITE(*,*) REPEAT('=',NLNES)
C
101   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 1(9X,'K =',I2))
102   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 2(9X,'K =',I2))
103   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 3(9X,'K =',I2))
104   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 4(9X,'K =',I2))
105   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 5(9X,'K =',I2))
106   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 6(9X,'K =',I2))
107   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 7(9X,'K =',I2))
108   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 8(9X,'K =',I2))
109   FORMAT(' JA=',I3,'/2  JB=',I3,'/2', 9(9X,'K =',I2))
110   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',10(9X,'K =',I2))
111   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',11(9X,'K =',I2))
112   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',12(9X,'K =',I2))
113   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',13(9X,'K =',I2))
114   FORMAT(' JA=',I3,'/2  JB=',I3,'/2',14(9X,'K =',I2))
C
C     LOOP OVER POSITIVE MQN(B) VALUES -- DESCENDING ORDER OF MAGNITUDE
      DO MB=IABS(KQN(2)),1,-1
        MJB = 2*MB-1
C       LOOP OVER POSITIVE MQN(A) -- DESCENDING ORDER OF MAGNITUDE
        DO MA=IABS(KQN(1)),1,-1
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214) MJA, MJB,(DKAB(LTEN,MJA+1,MJB+1),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
C       LOOP OVER POSITIVE MQN(A) -- ASCENDING ORDER OF MAGNITUDE
        DO MA=1,IABS(KQN(1))
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214)-MJA, MJB,(DKAB(LTEN,MJA  ,MJB+1),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
        IF(MB.NE.1) WRITE(*,*) REPEAT('-',NLNES)
C     END THE LOOP OVER MQN(B)
      ENDDO
      WRITE(*,*) REPEAT('-',NLNES)
C     LOOP OVER NEGATIVE MQN(B) VALUES -- ASCENDING ORDER OF MAGNITUDE
      DO MB=1,IABS(KQN(2))
        MJB = 2*MB-1
C       LOOP OVER POSITIVE MQN(A) -- DESCENDING ORDER OF MAGNITUDE
        DO MA=IABS(KQN(1)),1,-1
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214) MJA,-MJB,(DKAB(LTEN,MJA+1,MJB  ),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
C       LOOP OVER POSITIVE MQN(A) -- ASCENDING ORDER OF MAGNITUDE
        DO MA=1,IABS(KQN(1))
          MJA = 2*MA-1
C         WRITE ANGULAR COEFFICIENTS FOR THIS MQN COMBINATIONS
          IF(NUNUM.EQ.1) THEN
            WRITE(*,201)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.2) THEN
            WRITE(*,202)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.3) THEN
            WRITE(*,203)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.4) THEN
            WRITE(*,204)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.5) THEN
            WRITE(*,205)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.6) THEN
            WRITE(*,206)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.7) THEN
            WRITE(*,207)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.8) THEN
            WRITE(*,208)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.9) THEN
            WRITE(*,209)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.10) THEN
            WRITE(*,210)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.11) THEN
            WRITE(*,211)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.12) THEN
            WRITE(*,212)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.13) THEN
            WRITE(*,213)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ELSEIF(NUNUM.EQ.14) THEN
            WRITE(*,214)-MJA,-MJB,(DKAB(LTEN,MJA  ,MJB  ),LTEN=1,NUNUM)
          ENDIF
C       END THE LOOP OVER MQN(A)
        ENDDO
        IF(MB.NE.IABS(KQN(2))) WRITE(*,*) REPEAT('-',NLNES)
C     END THE LOOP OVER MQN(B)
      ENDDO
      WRITE(*,*) REPEAT('=',NLNES)
C
201   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 1(1X,F13.9))
202   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 2(1X,F13.9))
203   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 3(1X,F13.9))
204   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 4(1X,F13.9))
205   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 5(1X,F13.9))
206   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 6(1X,F13.9))
207   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 7(1X,F13.9))
208   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 8(1X,F13.9))
209   FORMAT(' MA=',I3,'/2  MB=',I3,'/2', 9(1X,F13.9))
210   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',10(1X,F13.9))
211   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',11(1X,F13.9))
212   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',12(1X,F13.9))
213   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',13(1X,F13.9))
214   FORMAT(' MA=',I3,'/2  MB=',I3,'/2',14(1X,F13.9))
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [7] MULTI-CONFIG: MANY-CENTRE MULTICONFIG. SCF CALCULATIONS.       C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] MCSCF: MAIN ROUTINE FOR MULTI-CONFIGURATIONAL SCF CALCULATION. C
C**********************************************************************C
C
C
      SUBROUTINE MCSCF
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           MM       MM  CCCCCC   SSSSSS   CCCCCC  FFFFFFFF            C
C           MMM     MMM CC    CC SS    SS CC    CC FF                  C
C           MMMM   MMMM CC       SS       CC       FF                  C
C           MM MM MM MM CC        SSSSSS  CC       FFFFFF              C
C           MM  MMM  MM CC             SS CC       FF                  C
C           MM   M   MM CC    CC SS    SS CC    CC FF                  C
C           MM       MM  CCCCCC   SSSSSS   CCCCCC  FF                  C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  MCSCF PERFORMS A MULTI-CONFIGURATIONAL SCF CALCULATION USING THE    C
C  APPROACH OF KNOWLES AND WERNER (1985,1988).                         C
C**********************************************************************C
C
      CHARACTER*4  HMLT
C
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/TMCF/EMTY
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
      CALL FACTRLS
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',20),'MULTI-CONFIGURATIONAL MOLECULAR SCF'
      WRITE(7, *) REPEAT(' ',20),'MULTI-CONFIGURATIONAL MOLECULAR SCF'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     EQ-COEFFICIENTS IN COMMON ARRAYS
      IF(IEQS.EQ.1.AND.INEW.NE.0) THEN
        CALL EQFILE
      ENDIF
C
C     WARN USER THAT ROUTINE HASN'T BEEN WRITTEN YET
      WRITE(6, *) 'In BERTHA: MCSCF option not yet available.'
      WRITE(7, *) 'In BERTHA: MCSCF option not yet available.'
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [8] DMRG: DENSITY MATRIX RENORMALISATION GROUP CALCULATIONS.       C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] DMRG: DENSITY MATRIX RENORMALISATION GROUP CALCULATION.        C
C**********************************************************************C
C
C
      SUBROUTINE DMRG
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                DDDDDDD  MM       MM RRRRRRR   GGGGGG                 C
C                DD    DD MMM     MMM RR    RR GG    GG                C
C                DD    DD MMMM   MMMM RR    RR GG                      C
C                DD    DD MM MM MM MM RR    RR GG                      C
C                DD    DD MM  MMM  MM RRRRRRR  GG   GGG                C
C                DD    DD MM   M   MM RR    RR GG    GG                C
C                DDDDDDD  MM       MM RR    RR  GGGGGG                 C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  DMRG PERFORMS A CALCULATION BASED ON THE FORMALISM OF THE DENSITY   C
C  MATRIX RENORMALISATION GROUP.                                       C
C**********************************************************************C
C
      CHARACTER*4 HMLT
C
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/TDMG/EMTY
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
      CALL FACTRLS
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',20),'DENSITY MATRIX RENORMALISATION GROUP'
      WRITE(7, *) REPEAT(' ',20),'DENSITY MATRIX RENORMALISATION GROUP'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     EQ-COEFFICIENTS IN COMMON ARRAYS
      IF(IEQS.EQ.1.AND.INEW.NE.0) THEN
        CALL EQFILE
      ENDIF
C
C     WARN USER THAT ROUTINE HASN'T BEEN WRITTEN YET
      WRITE(6, *) 'In BERTHA: DMRG option not yet available.'
      WRITE(7, *) 'In BERTHA: DMRG option not yet available.'
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C   [9] MBPT: CORRELATION ENERGY CALCULATION ROUTINES.                 C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] MBPT: MAIN ROUTINE FOR MANY-BODY DIAGRAMMATIC P.T.             C
C   [B] MBPT1: ZERO- AND FIRST-ORDER ENERGY ANALYSIS.                  C
C   [C] MBPT2: SECOND-ORDER CORRELATION ENERGY ANALYSIS.               C
C**********************************************************************C
C
C
      SUBROUTINE MBPT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                MM       MM BBBBBBB  PPPPPPP  TTTTTTTT                C
C                MMM     MMM BB    BB PP    PP    TT                   C
C                MMMM   MMMM BB    BB PP    PP    TT                   C
C                MM MM MM MM BBBBBBB  PP    PP    TT                   C
C                MM  MMM  MM BB    BB PPPPPPP     TT                   C
C                MM   M   MM BB    BB PP          TT                   C
C                MM       MM BBBBBBB  PP          TT                   C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  MBPT PERFORMS MANY-BODY DIAGRAMMATIC EVALUATION ON A CONVERGED      C
C  MOLECULAR HARTREE-FOCK SOLUTION SPACE.                              C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*5 G2INT
C
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMPT/EMTY
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
      CALL FACTRLS
C
C     PRINT A BIG SECTION HEADER
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) REPEAT(' ',21),'MANY-BODY PERTURBATION THEORY'
      WRITE(7, *) REPEAT(' ',21),'MANY-BODY PERTURBATION THEORY'
      WRITE(6, *) REPEAT('#',72)
      WRITE(7, *) REPEAT('#',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     EQ-COEFFICIENTS IN COMMON ARRAYS
      IF(IEQS.EQ.1.AND.INEW.NE.0) THEN
        CALL EQFILE
      ENDIF
C
C     GENERATE DENSITY MATRIX
      IF(INEW.EQ.1) THEN
        CALL DENSTY
      ENDIF
C
C     RESTRICT SET OF OCCUPIED AND VIRTUAL STATES
      MINO = 1
      NUMO = NOCC
      MINV = NOCC+1
      NUMV = NVRT
C
C     LABEL THE TWO-BODY INTERACTION ('COULM' OR 'BREIT')
      G2INT = 'COULM'
C
C     SUMMARY OF INPUT CHOICES
      WRITE(6, *) 'First occupied orbital:     ',MINO
      WRITE(7, *) 'First occupied orbital:     ',MINO
      WRITE(6, *) 'Number of occupied orbitals:',NUMO
      WRITE(7, *) 'Number of occupied orbitals:',NUMO
      WRITE(6, *) 'First virtual orbital:      ',MINV
      WRITE(7, *) 'First virtual orbital:      ',MINV
      WRITE(6, *) 'Number of virtual orbitals: ',NUMV
      WRITE(7, *) 'Number of virtual orbitals: ',NUMV
      IF(G2INT.EQ.'COULM') THEN
        WRITE(6, *) '2-body interaction: Coulomb.'
        WRITE(7, *) '2-body interaction: Coulomb.'
      ELSEIF(G2INT.EQ.'BREIT') THEN
        WRITE(6, *) '2-body interaction: Breit.'
        WRITE(7, *) '2-body interaction: Breit.'
      ENDIF
C
C     CALL FIRST-ORDER MBPT ROUTINE
      CALL MBPT1(MINO,NUMO,G2INT)
C
C     CALL SECOND-ORDER MBPT ROUTINE
      CALL MBPT2(MINO,NUMO,MINV,NUMV,G2INT)
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TMPT)
      TTOT = TTOT-TDUM
C
      RETURN
      END
C
C
      SUBROUTINE MBPT1(MINO,NUMO,G2INT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              MM       MM BBBBBBB  PPPPPPP TTTTTTTT 11                C
C              MMM     MMM BB    BB PP    PP   TT   111                C
C              MMMM   MMMM BB    BB PP    PP   TT    11                C
C              MM MM MM MM BBBBBBB  PP    PP   TT    11                C
C              MM  MMM  MM BB    BB PPPPPPP    TT    11                C
C              MM   M   MM BB    BB PP         TT    11                C
C              MM       MM BBBBBBB  PP         TT   1111               C
C                                                                      C
C -------------------------------------------------------------------- C
C  MBPT1 EVALUATES ZERO- AND FIRST-ORDER ENERGIES FOR ALL OCCUPIED     C
C  SOLUTIONS TO A CONVERGED HARTREE-FOCK PROBLEM.                      C
C -------------------------------------------------------------------- C
C INPUT:                                                               C
C  MINO  - LOWEST OCCUPIED STATE TO ACCOUNT FOR. (FULL: 1)             C
C  NUMO  - NUMBER OF OCCUPIED STATES TO ACCOUNT FOR. (FULL: NOCC)      C
C  G2INT - NAME OF TWO-BODY OPERATOR ('COULM' OR 'BREIT').             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000)
C
      CHARACTER*4 HMLT
      CHARACTER*5 G2INT
      CHARACTER*16 HMS
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-(MKP+1)/2:(MKP+1)/2,MKP)
      DIMENSION EAB1(NUMO,NUMO,6),EA1(NUMO,6)
C
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 B1(MBS*NUMO,8),B2(MBS*NUMO,8)
      COMPLEX*16 DB(MB2,NUMO*NUMO,4)
      COMPLEX*16 ADB1(MBS,NUMO*NUMO*NUMO,2),ADB2(MBS,NUMO*NUMO*NUMO,2)
      COMPLEX*16 CADB((NUMO+1)*NUMO*NUMO*NUMO/2)
      COMPLEX*16 OVAP(MDM,MDM),HNUC(MDM,MDM),HKIN(MDM,MDM),
     &           GDIR(MDM,MDM),GXCH(MDM,MDM),QDIR(MDM,MDM),
     &           QXCH(MDM,MDM),BDIR(MDM,MDM),BXCH(MDM,MDM),
     &           VUEH(MDM,MDM),FOCK(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/MTRX/OVAP,HNUC,HKIN,VUEH,GDIR,GXCH,QDIR,QXCH,BDIR,BXCH,FOCK
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
C
C     ISCF TELLS WHICH INTEGRALS TO INCLUDE BASED ON OVERLAP COMBINATION
      DATA ISCF/1,1,1,1,1,1,1,1,0,0,0,
     &          1,1,0,0,1,1,1,0,0,0,0,
     &          1,0,1,1,1,0,1,0,0,0,0,
     &          1,1,1,0,1,1,0,0,0,0,0,
     &          1,0,1,0,1,0,0,0,0,0,0,
     &          1,0,0,0,1,0,0,0,0,0,0/
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      IERC = 0
C
C     WARNINGS BASED ON INVALID HMLT VS. G2INT COMBINATIONS
      IF(G2INT.EQ.'COULM') THEN
        IF(HMLT.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT1: HMLT = BARE but G2INT = COULM.'
          WRITE(7, *) 'In MBPT1: HMLT = BARE but G2INT = COULM.'
        ENDIF
      ELSEIF(G2INT.EQ.'BREIT') THEN
        IF(HMLT.EQ.'NORL') THEN
          WRITE(6, *) 'In MBPT1: HMLT = NORL but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLT = NORL but G2INT = BREIT.'
          RETURN
        ELSEIF(HMLT.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT1: HMLT = BARE but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLT = BARE but G2INT = BREIT.'
        ELSEIF(HMLT.EQ.'DHFR') THEN
          WRITE(6, *) 'In MBPT1: HMLT = DHFR but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLT = DHFR but G2INT = BREIT.'
        ELSEIF(HMLT.EQ.'DHFP') THEN
          WRITE(6, *) 'In MBPT1: HMLT = DHFP but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT1: HMLT = DHFP but G2INT = BREIT.'
        ENDIF
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 1
          ITSTOP = 1
          ITSKIP = 1
        ENDIF
      ELSE
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 4
          ITSTOP = 1
          ITSKIP =-3
        ELSEIF(G2INT.EQ.'BREIT') THEN
          ITSTRT = 2
          ITSTOP = 3
          ITSKIP = 1        
        ENDIF
      ENDIF
C
C     INITIALISE TIME COUNTERS
      T1EL = 0.0D0
      TERI = 0.0D0
      TCN1 = 0.0D0
      TCN2 = 0.0D0
      TCN3 = 0.0D0
      TCN4 = 0.0D0
      TSUM = 0.0D0
C
      CALL CPU_TIME(TBEG)
C
C     CLEAR ENERGY COUNTERS
      DO N=1,6
        DO IOCCB=1,NUMO
          EA1(IOCCB,N) = 0.0D0
          DO IOCCA=1,NUMO
            EAB1(IOCCA,IOCCB,N) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     CLEAR THE ARRAY FOR (AR|BS) VALUES
      M = 0
      DO IOCCC=1,NUMO
        DO IOCCA=1,NUMO
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
              M = M+1
              CADB(M) = DCMPLX(0.0D0,0.0D0)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ONE-BODY ENERGIES (INSIGNIFICANT COMPUTATIONAL COST)             C
C**********************************************************************C
C
C     RECORD TIME AT THE START OF THIS PROCESS
      CALL CPU_TIME(T1)
C
C     CALCULATE ONE-BODY MATRIX REPS
      CALL ONEEL
C
C     LOOP OVER ALL OCCUPIED ORBITAL PAIRS AND CONTRACT
      E1H = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         FOCK MATRIX ADDRESS FOR IOCCA AND IOCCB
          IA = MINO-1+IOCCA+NSKP
          IB = MINO-1+IOCCB+NSKP
C
C         ONE-BODY ENERGY
          TMP1 = 0.0D0
          TMP2 = 0.0D0
          IF(IOCCA.EQ.IOCCB) THEN
            DO J=1,NDIM
              DO I=1,NDIM
                TMP1=TMP1+DREAL(HNUC(I,J)*DCONJG(COEF(I,IA))*COEF(J,IA))
                TMP2=TMP2+DREAL(HKIN(I,J)*DCONJG(COEF(I,IA))*COEF(J,IA))
              ENDDO
            ENDDO
          ENDIF
          EAB1(IOCCA,IOCCB,1) = TMP1
          EAB1(IOCCA,IOCCB,2) = TMP2
          EAB1(IOCCA,IOCCB,3) = TMP1+TMP2
          E1H = E1H + EAB1(IOCCA,IOCCB,3)
C
        ENDDO
      ENDDO
C
C     RECORD TIME AT THE END OF THIS PROCESS
      CALL CPU_TIME(T2)
      T1EL = T1EL+T2-T1
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPES A AND B (USE INDEX 2000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1, NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER |MQN| PROJECTIONS A AND B (INDEX 3000)                 C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     INDEX ASSIGNMENT
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ1.LT.IQ2) GOTO 3001
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS A AND B (INDEX 4000)          C
C**********************************************************************C
C
C     COMPONENT LABEL FOR A AND B: TT = LL(1) or SS(4) <- COULM
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C**********************************************************************C
C     FOCK MATRIX STARTING ADDRESSES                                   C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDAB
C
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDAB
C
C     CLEAR ARRAY FOR THE COMPLETED CONTRACTION OVER BLOCKS C AND D
      DO MDB=1,NUMO*NUMO
        DO MIJ=1,NBAS(1)*NBAS(2)
          DO IJSPIN=1,4
            DB(MIJ,MDB,IJSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES C AND D (USE INDEX 5000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE C
      DO 5000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER CENTRE D
      DO 5000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C**********************************************************************C
C     LOOP OVER KQN SYMMETRY TYPES C AND D (USE INDEX 6000)            C
C**********************************************************************C
C
C     LOOP OVER KQN(C) VALUES
      DO 6000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = BSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 6000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = BSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER |MQN| PROJECTIONS C AND D (INDEX 7000)                 C
C**********************************************************************C
C
C     LOOP OVER |MQN(C)| VALUES
      DO 7000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     LOOP OVER |MQN(D)| VALUES
      DO 7000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     INDEX ASSIGNMENT
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ3.LT.IQ4) GOTO 7001
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS C AND D (INDEX 8000)          C
C**********************************************************************C
C
C     COMPONENT LABEL FOR C AND D: TT = LL(1) or SS(4) <- COULM
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 8000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C**********************************************************************C
C     FOCK MATRIX STARTING ADDRESSES                                   C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDCD
      ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDCD
C
      NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDCD
      ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B (INDEX 9000)         C
C**********************************************************************C
C
      DO 9000 IBAS=1,NBAS(1)
      DO 9000 JBAS=1,NBAS(2)
C
C     LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
      MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C     RESET SCREENING COUNTERS
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
      ENDDO
C
C     BATCH OF ELECTRON INTERACTION INTEGRALS (IJ|KL) FOR FIXED (IJ)
      CALL CPU_TIME(T1)
      IF(G2INT.EQ.'COULM') THEN
        CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
      ELSEIF(G2INT.EQ.'BREIT') THEN
        CALL BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
      ENDIF
      CALL CPU_TIME(T2)
      TERI = TERI + T2 - T1
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (DIRECT)
      DO MKB=1,NBAS(3)*NUMO
        DO IJKSPIN=1,8
          B1(MKB,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (SWAP)
      DO MLB=1,NBAS(4)*NUMO
        DO IJLSPIN=1,8
          B2(MLB,IJLSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FIRST CONTRACTION:                                               C
C     (IJ;T|KL;T') -> (IJ;T|KB;T')  AND  (IJ;T|LK;T') -> (IJ;T|LB;T')  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FIRST CONTRACTION (DIRECT): (IJ;T|KL;T') -> (IJ;T|KB;T')
C
C     LOOP OVER BASIS FUNCTIONS IN BLOCK C AND OCCUPIED STATES IOCCB
      DO KBAS=1,NBAS(3)
        DO IOCCB=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCB
          IB = MINO-1+IOCCB+NSKP
C
C         LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
          MKB = (KBAS-1)*NUMO + IOCCB
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK D AND CONTRACT OVER ERI
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|-B) = (--|--) + (--|-+)
            B1(MKB,1) = B1(MKB,1) +      RR(M, 1)*COEF(ND1+LBAS,IB)
     &                            +      RR(M, 2)*COEF(ND2+LBAS,IB)
C           (+-|-B) = (+-|--) + (+-|-+)
            B1(MKB,2) = B1(MKB,2) +      RR(M, 9)*COEF(ND1+LBAS,IB)
     &                            +      RR(M,10)*COEF(ND2+LBAS,IB)
C           (-+|-B) = (-+|--) + (-+|-+)
            B1(MKB,3) = B1(MKB,3) +      RR(M, 5)*COEF(ND1+LBAS,IB)
     &                            +      RR(M, 6)*COEF(ND2+LBAS,IB)
C           (++|-B) = (++|--) + (++|-+)
            B1(MKB,4) = B1(MKB,4) +      RR(M,13)*COEF(ND1+LBAS,IB)
     &                            +      RR(M,14)*COEF(ND2+LBAS,IB)
C           (--|+B) = (--|+-) + (--|++)
            B1(MKB,5) = B1(MKB,5) +      RR(M, 3)*COEF(ND1+LBAS,IB)
     &                            +      RR(M, 4)*COEF(ND2+LBAS,IB)
C           (+-|+B) = (+-|+-) + (+-|++)
            B1(MKB,6) = B1(MKB,6) +      RR(M,11)*COEF(ND1+LBAS,IB)
     &                            +      RR(M,12)*COEF(ND2+LBAS,IB)
C           (-+|+B) = (-+|+-) + (-+|++)
            B1(MKB,7) = B1(MKB,7) +      RR(M, 7)*COEF(ND1+LBAS,IB)
     &                            +      RR(M, 8)*COEF(ND2+LBAS,IB)
C           (++|+B) = (++|+-) + (++|++)
            B1(MKB,8) = B1(MKB,8) +      RR(M,15)*COEF(ND1+LBAS,IB)
     &                            +      RR(M,16)*COEF(ND2+LBAS,IB)
C
          ENDDO
        ENDDO
      ENDDO
C
C     FIRST CONTRACTION (SWAP): (IJ;T|LK;T') -> (IJ;T|LB;T')
      IF(IQ3.EQ.IQ4) GOTO 9100
C
C     LOOP OVER BASIS FUNCTIONS IN BLOCK D AND OCCUPIED STATES IOCCB
      DO LBAS=1,NBAS(4)
        DO IOCCB=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCB
          IB = MINO-1+IOCCB+NSKP
C
C         LIST ADDRESS FOR THIS LBAS,IOCCB COMBINATION
          MLB = (LBAS-1)*NUMO + IOCCB
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK C AND CONTRACT OVER ERI
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|+B) = PAB*{(--|B+)} = PAB*{(--|++) + ((--|-+))}
            B2(MLB,1) = B2(MLB,1) + PCD1*RR(M, 4)*COEF(NC1+KBAS,IB)
     &                            + PCD2*RR(M, 2)*COEF(NC2+KBAS,IB)
C
C           (+-|+B) = PAB*{(+-|B+)} = PAB*{(+-|++) + ((+-|-+))}
            B2(MLB,2) = B2(MLB,2) + PCD1*RR(M,12)*COEF(NC1+KBAS,IB)
     &                            + PCD2*RR(M,10)*COEF(NC2+KBAS,IB)
C
C           (-+|+B) = PAB*{(-+|B+)} = PAB*{(-+|++) + ((-+|-+))}
            B2(MLB,3) = B2(MLB,3) + PCD1*RR(M, 8)*COEF(NC1+KBAS,IB)
     &                            + PCD2*RR(M, 6)*COEF(NC2+KBAS,IB)
C
C           (++|+B) = PAB*{(++|B+)} = PAB*{(++|++) + ((++|-+))}
            B2(MLB,4) = B2(MLB,4) + PCD1*RR(M,16)*COEF(NC1+KBAS,IB)
     &                            + PCD2*RR(M,14)*COEF(NC2+KBAS,IB)
C
C           (--|-B) = PAB*{(--|B-)} = PAB*{(--|+-) + ((--|--))}
            B2(MLB,5) = B2(MLB,5) + PCD2*RR(M, 3)*COEF(NC1+KBAS,IB)
     &                            + PCD1*RR(M, 1)*COEF(NC2+KBAS,IB)
C
C           (+-|-B) = PAB*{(+-|B-)} = PAB*{(+-|+-) + ((+-|--))}
            B2(MLB,6) = B2(MLB,6) + PCD2*RR(M,11)*COEF(NC1+KBAS,IB)
     &                            + PCD1*RR(M, 9)*COEF(NC2+KBAS,IB)
C
C           (-+|-B) = PAB*{(-+|B-)} = PAB*{(-+|+-) + ((-+|--))}
            B2(MLB,7) = B2(MLB,7) + PCD2*RR(M, 7)*COEF(NC1+KBAS,IB)
     &                            + PCD1*RR(M, 5)*COEF(NC2+KBAS,IB)
C
C           (++|-B) = PAB*{(++|B-)} = PAB*{(++|+-) + ((++|--))}
            B2(MLB,8) = B2(MLB,8) + PCD2*RR(M,15)*COEF(NC1+KBAS,IB)
     &                            + PCD1*RR(M,13)*COEF(NC2+KBAS,IB)
C
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ3 = IQ4
9100  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN1 = TCN1 + T2 - T1
C
C**********************************************************************C
C     SECOND CONTRACTION:                                   ~          C
C     (IJ;T|KB;T') -> (IJ;T|DB)  AND  (IJ;T|LB;T') -> (IJ;T|DB)        C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     SECOND CONTRACTION (DIRECT): (IJ;T|KB) -> (IJ;T|DB)
C
C     LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
      DO IOCCB=1,NUMO
        DO IOCCD=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCD
          ID = MINO-1+IOCCD+NSKP
C
C         LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION IN B1
          MDB = (IOCCB-1)*NUMO + IOCCD
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK C AND CONTRACT OVER B1
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
            MKB = (KBAS-1)*NUMO + IOCCB
C
C           (--|DB) = (--|-B) + (--|+B)
            DB(MIJ,MDB,1) = DB(MIJ,MDB,1)
     &                    + B1(MKB,1)*DCONJG(COEF(NC1+KBAS,ID))
     &                    + B1(MKB,5)*DCONJG(COEF(NC2+KBAS,ID))
C
C           (-+|DB) = (-+|-B) + (-+|+B)
            DB(MIJ,MDB,2) = DB(MIJ,MDB,2)
     &                    + B1(MKB,3)*DCONJG(COEF(NC1+KBAS,ID))
     &                    + B1(MKB,7)*DCONJG(COEF(NC2+KBAS,ID))
C
C           (+-|DB) = (+-|-B) + (+-|+B)
            DB(MIJ,MDB,3) = DB(MIJ,MDB,3)
     &                    + B1(MKB,2)*DCONJG(COEF(NC1+KBAS,ID))
     &                    + B1(MKB,6)*DCONJG(COEF(NC2+KBAS,ID))
C
C           (++|DB) = (++|-B) + (++|+B)
            DB(MIJ,MDB,4) = DB(MIJ,MDB,4)
     &                    + B1(MKB,4)*DCONJG(COEF(NC1+KBAS,ID))
     &                    + B1(MKB,8)*DCONJG(COEF(NC2+KBAS,ID))
C
          ENDDO
        ENDDO
      ENDDO
C
C
C     SECOND CONTRACTION (SWAP): (IJ;T|LB) -> (IJ;T|DB)
      IF(IQ3.EQ.IQ4) GOTO 9200
C
C     LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
      DO IOCCB=1,NUMO
        DO IOCCD=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCD
          ID = MINO-1+IOCCD+NSKP
C
C         LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION IN B1
          MDB = (IOCCB-1)*NUMO + IOCCD
C
C         LOOP OVER BASIS FUNCTIONS IN BLOCK D AND CONTRACT OVER B2
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS LBAS,IOCCB COMBINATION
            MLB = (LBAS-1)*NUMO + IOCCB
C
C           (--|DB) = (--|+B) + (--|-B)
            DB(MIJ,MDB,1) = DB(MIJ,MDB,1)
     &                    + B2(MLB,1)*DCONJG(COEF(ND1+LBAS,ID))
     &                    + B2(MLB,5)*DCONJG(COEF(ND2+LBAS,ID))
C
C           (-+|DB) = (-+|+B) + (-+|-B)
            DB(MIJ,MDB,2) = DB(MIJ,MDB,2)
     &                    + B2(MLB,3)*DCONJG(COEF(ND1+LBAS,ID))
     &                    + B2(MLB,7)*DCONJG(COEF(ND2+LBAS,ID))
C
C           (+-|DB) = (+-|+B) + (+-|-B)
            DB(MIJ,MDB,3) = DB(MIJ,MDB,3)
     &                    + B2(MLB,2)*DCONJG(COEF(ND1+LBAS,ID))
     &                    + B2(MLB,6)*DCONJG(COEF(ND2+LBAS,ID))
C
C           (++|DB) = (++|+B) + (++|-B)
            DB(MIJ,MDB,4) = DB(MIJ,MDB,4)
     &                    + B2(MLB,4)*DCONJG(COEF(ND1+LBAS,ID))
     &                    + B2(MLB,8)*DCONJG(COEF(ND2+LBAS,ID))
C
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ3 = IQ4
9200  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN2 = TCN2 + T2 - T1
C
C     END LOOP OVER BASIS PAIR (IBAS,JBAS)
9000  CONTINUE
C
C     DB ARRAY NOW CONTAINS THE PARTIALLY-TRANSFORMED LIST: (IJ,DB)
8000  CONTINUE
7001  CONTINUE
7000  CONTINUE
6000  CONTINUE
5000  CONTINUE
C
C**********************************************************************C
C     THIRD CONTRACTION:                                               C
C     (IJ;T|DB) -> (IA;T|DB)  AND  (JI;T|DB) -> (JA;T|DB)              C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     THIRD CONTRACTION (DIRECT): (IJ;T|DB) -> (IA;T|DB)
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (DIRECT)
      DO MADB=1,NUMO*NUMO*NUMO
        DO IBAS=1,NBAS(1)
          DO ISPIN=1,2
            ADB1(IBAS,MADB,ISPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
        DO IOCCB=1,IOCCA
          DO IOCCD=1,NUMO
C
C           LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
            MDB = (IOCCB-1)*NUMO+IOCCD
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
            MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C           LOOP OVER BASIS FUNCTIONS IN A AND B, CONTRACT OVER DB
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-A|DB) = (--|DB) + (-+|DB)
                ADB1(IBAS,MADB,1) = ADB1(IBAS,MADB,1)
     &                      +      DB(MIJ,MDB,1)*COEF(NB1+JBAS,IA)
     &                      +      DB(MIJ,MDB,2)*COEF(NB2+JBAS,IA)
C               (+A|DB) = (+-|DB) + (++|DB)
                ADB1(IBAS,MADB,2) = ADB1(IBAS,MADB,2)
     &                      +      DB(MIJ,MDB,3)*COEF(NB1+JBAS,IA)
     &                      +      DB(MIJ,MDB,4)*COEF(NB2+JBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     THIRD CONTRACTION (SWAP): (JI;T|DB) -> (JA;T|DB)
      IF(IQ1.EQ.IQ2) GOTO 4100
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (SWAP)
      DO MADB=1,NUMO*NUMO*NUMO
        DO JBAS=1,NBAS(2)
          DO JSPIN=1,2
            ADB2(JBAS,MADB,JSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
        DO IOCCB=1,IOCCA
          DO IOCCD=1,NUMO
C
C           LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
            MDB = (IOCCB-1)*NUMO+IOCCD
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
            MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C           LOOP OVER BASIS FUNCTIONS IN A AND B, CONTRACT OVER DB
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (+A|DB) = PCD*{(+A|DB)} = PCD*{(++|DB) + (-+|DB)}
                ADB2(JBAS,MADB,1) = ADB2(JBAS,MADB,1)
     &                      + PAB1*DB(MIJ,MDB,4)*COEF(NA1+IBAS,IA)
     &                      + PAB2*DB(MIJ,MDB,2)*COEF(NA2+IBAS,IA)
C               (-A|DB) = PCD*{(-A|DB)} = PCD*{(+-|DB) + (--|DB)}
                ADB2(JBAS,MADB,2) = ADB2(JBAS,MADB,2)
     &                      + PAB2*DB(MIJ,MDB,3)*COEF(NA1+IBAS,IA)
     &                      + PAB1*DB(MIJ,MDB,1)*COEF(NA2+IBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ1 = IQ2
4100  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN3 = TCN3 + T2 - T1
C
C**********************************************************************C
C     FOURTH CONTRACTION:                      ~                       C
C     (IA;T|DB) -> (CA|DB)  AND  (JA;T|DB) -> (CA|DB)                  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOURTH CONTRACTION (DIRECT): (IA;T|DB) -> (CA|DB)
C
C     LOOP OVER OCCUPIED STATES IOCCA AND IOCCC
      DO IOCCA=1,NUMO
        DO IOCCC=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCC
          IC = MINO-1+IOCCC+NSKP
C
C         LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
C
C             LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
              MDB = (IOCCB-1)*NUMO + IOCCD
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
              MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C             LIST ADDRESS FOR THIS IOCCC,IOCCA AND THE ABOVE MDB
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + MDB
C
C             LOOP OVER BASIS FUNCTIONS IN BLOCK A, CONTRACT OVER ADB1
              DO IBAS=1,NBAS(1)
C
C               (CA|DB) = (-A|DB) + (+A|DB)
                CADB(MCADB) = CADB(MCADB)
     &                    + ADB1(IBAS,MADB,1)*DCONJG(COEF(NA1+IBAS,IC))
     &                    + ADB1(IBAS,MADB,2)*DCONJG(COEF(NA2+IBAS,IC))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C                                              ~
C     FOURTH CONTRACTION (SWAP): (JA;T|DB) -> (CA|DB)
      IF(IQ1.EQ.IQ2) GOTO 4200
C
C     LOOP OVER OCCUPIED STATES IOCCA AND IOCCC
      DO IOCCA=1,NUMO
        DO IOCCC=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCC
          IC = MINO-1+IOCCC+NSKP
C
C         LOOP OVER OCCUPIED STATES IOCCB AND IOCCD
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
C
C             LIST ADDRESS FOR THIS IOCCD,IOCCB COMBINATION
              MDB = (IOCCB-1)*NUMO + IOCCD
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MDB
              MADB = (IOCCA-1)*NUMO*NUMO + MDB
C
C             LIST ADDRESS FOR THIS IOCCC,IOCCA AND THE ABOVE MDB
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + MDB
C
C             LOOP OVER BASIS FUNCTIONS IN BLOCK B, CONTRACT OVER ACB2
              DO JBAS=1,NBAS(2)
C
C               (CA|DB) = (+A|DB) + (-A|DB)
                CADB(MCADB) = CADB(MCADB)
     &                    + ADB2(JBAS,MADB,1)*DCONJG(COEF(NB1+JBAS,IC))
     &                    + ADB2(JBAS,MADB,2)*DCONJG(COEF(NB2+JBAS,IC))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
4200  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN4 = TCN4 + T2 - T1
C
C     ALL CONTRIBUTIONS FROM THIS CLASS (A,B,C,D) NOW ACCOUNTED FOR
4000  CONTINUE
3001  CONTINUE
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER PAIR CORRELATION ENERGY FROM (CA|DB)      C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOR EACH IOCCA,IOCCB PAIR, SUM OVER IVRTR AND IVRTS CONTRIBUTIONS
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCA=1,NUMO
        DO IOCCC=1,NUMO
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCB=1,IOCCA
            DO IOCCD=1,NUMO
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTR,IOCCB,IVRTS
              MCADB = (IOCCA-1)*NUMO*IOCCA*NUMO/2
     &              + (IOCCC-1)*NUMO*IOCCA + (IOCCB-1)*NUMO + IOCCD
C
              IF(IOCCA.EQ.IOCCC.AND.IOCCB.EQ.IOCCD) THEN
                EAB1(IOCCA,IOCCB,4) = DREAL(CADB(MCADB))
              ENDIF
              
              IF(IOCCB.EQ.IOCCC.AND.IOCCA.EQ.IOCCD) THEN
                EAB1(IOCCA,IOCCB,5) =-DREAL(CADB(MCADB))
              ENDIF
C
C             ADD TO DIRECT AND EXCHANGE BINS
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     FILL IN THE OTHER HALF OF THE ARRAY AND CALCULATE TOTALS
      E1D = 0.0D0
      E1X = 0.0D0
      E1S = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         INTERMEDIATE VALUES
          EAB1DIR = EAB1(IOCCA,IOCCB,4)
          EAB1XCH = EAB1(IOCCA,IOCCB,5)
          EAB1SUM = EAB1DIR + EAB1XCH
C
C         PUT THESE INTO EAB1 AND ADD CONTRIBUTION TO E1
          EAB1(IOCCA,IOCCB,6) = EAB1SUM
          IF(IOCCA.NE.IOCCB) THEN
            EAB1(IOCCB,IOCCA,4) = EAB1DIR
            EAB1(IOCCB,IOCCA,5) = EAB1XCH
            EAB1(IOCCB,IOCCA,6) = EAB1SUM
            E1D = E1D +       EAB1DIR
            E1X = E1X +       EAB1XCH
            E1S = E1S +       EAB1SUM
          ELSE
            E1D = E1D + 0.5D0*EAB1DIR
            E1X = E1X + 0.5D0*EAB1XCH
            E1S = E1S + 0.5D0*EAB1SUM
          ENDIF
        ENDDO
      ENDDO
C
C     WRITE RESULTS OF EAB ENERGIES TO AN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT1.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NUMO
        DO IOCCB=1,NUMO
          WRITE(8, *) (EAB1(IOCCA,IOCCB,N),N=1,6)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER SINGLE ORBITAL ENERGY                     C
C**********************************************************************C
C
C     FOR EACH IOCCA, SUM OVER THE IOCCB CONTRIBUTIONS
      DO IOCCA=1,NUMO
        DO N=1,6
          EA1(IOCCA,N) = 0.0D0
          DO IOCCB=1,NUMO
            EA1(IOCCA,N) = EA1(IOCCA,N) + EAB1(IOCCA,IOCCB,N)
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TSUM = TSUM + T2 - T1
C
C**********************************************************************C
C     TERMINAL OUTPUT SUMMARY                                          C
C**********************************************************************C
C
C     MBPT1 PAIRWISE SUMMARY
20    FORMAT(1X,A,9X,A,9X,A,9X,A,10X,A)
21    FORMAT(' (',I2,',',I2,')',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'MBPT1 pairwise summary'
      WRITE(7, *) REPEAT(' ',25),'MBPT1 pairwise summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) '( a, b)','E1H(ab)','E1J(ab)','E1K(ab)','E1G(ab)'
      WRITE(7,20) '( a, b)','E1H(ab)','E1J(ab)','E1K(ab)','E1G(ab)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        DO IOCCB=1,IOCCA
          IBNUM = IOCCB+MINO-1
          WRITE(6,21) IANUM,IBNUM,(EAB1(IOCCA,IOCCB,N),N=3,6)
          WRITE(7,21) IANUM,IBNUM,(EAB1(IOCCA,IOCCB,N),N=3,6)
        ENDDO
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 SINGLE-PARTICLE SUMMARY
30    FORMAT(1X,A,10X,A,10X,A,10X,A,10X,A)
31    FORMAT('  ',I2,'    ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',21),'MBPT1 single particle summary'
      WRITE(7, *) REPEAT(' ',21),'MBPT1 single particle summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) '  a    ','E1H(a)','E1J(a)','E1K(a)',' E1G(a)'
      WRITE(7,30) '  a    ','E1H(a)','E1J(a)','E1K(a)',' E1G(a)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        WRITE(6,31) IANUM,(EA1(IOCCA,N),N=3,6)
        WRITE(7,31) IANUM,(EA1(IOCCA,N),N=3,6)
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 TOTAL FIRST-ORDER INTERACTION
32    FORMAT(' total  ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',19),'MBPT1 first order molecular energy'
      WRITE(7, *) REPEAT(' ',19),'MBPT1 first order molecular energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,32) E1H,E1D,E1X,E1S
      WRITE(7,32) E1H,E1D,E1X,E1S
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT1 LABOUR ANALYSIS
      CALL CPU_TIME(TFIN)
      TTOT = TFIN - TBEG
      TOTH = TTOT - (T1EL + TERI + TCN1 + TCN2 + TSUM)

40    FORMAT(1X,A,15X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',26),'MBPT1 labour analysis'
      WRITE(7, *) REPEAT(' ',26),'MBPT1 labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6,40) 'One-body terms - EH(A,B)                 ',HMS(T1EL)
      WRITE(7,40) 'One-body terms - EH(A,B)                 ',HMS(T1EL)
      WRITE(6,40) 'ERI construction - (IJ|KL)               ',HMS(TERI)
      WRITE(7,40) 'ERI construction - (IJ|KL)               ',HMS(TERI)
      WRITE(6,40) '1st contraction  - (IJ|KB)               ',HMS(TCN1)
      WRITE(7,40) '1st contraction  - (IJ|KB)               ',HMS(TCN1)
      WRITE(6,40) '2nd contraction  - (IJ|BB) and (IJ|AB)   ',HMS(TCN2)
      WRITE(7,40) '2nd contraction  - (IJ|BB) and (IJ|AB)   ',HMS(TCN2)
      WRITE(6,40) '3rd contraction  - (IA|BB) and (IA|AB)   ',HMS(TCN3)
      WRITE(7,40) '3rd contraction  - (IA|BB) and (IA|AB)   ',HMS(TCN3)
      WRITE(6,40) '4th contraction  - (AA|BB) and (BA|AB)   ',HMS(TCN4)
      WRITE(7,40) '4th contraction  - (AA|BB) and (BA|AB)   ',HMS(TCN4)
      WRITE(6,40) 'Other                                    ',HMS(TOTH)
      WRITE(7,40) 'Other                                    ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,40) 'Total MBPT1 time                         ',HMS(TTOT)
      WRITE(7,40) 'Total MBPT1 time                         ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE MBPT2(MINO,NUMO,MINV,NUMV,G2INT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            MM       MM BBBBBBB  PPPPPPP TTTTTTTT 222222              C
C            MMM     MMM BB    BB PP    PP   TT   22    22             C
C            MMMM   MMMM BB    BB PP    PP   TT         22             C
C            MM MM MM MM BBBBBBB  PP    PP   TT       22               C
C            MM  MMM  MM BB    BB PPPPPPP    TT     22                 C
C            MM   M   MM BB    BB PP         TT   22                   C
C            MM       MM BBBBBBB  PP         TT   22222222             C
C                                                                      C
C -------------------------------------------------------------------- C
C  MBPT2 CALCULATES SECOND-ORDER PAIR CORRELATION CORRECTIONS OVER A   C
C  USER-SPECIFIED TWO-BODY OPERATOR. IT USES A RELATIVISTIC ADAPTION   C
C  OF THE DIRECT MP2 ALGORITHM OF HEAD-GORDON, POPLE AND FRISCH (1988).C
C  THIS IS NOT MOLLER-PLESSET PERTURBATION THEORY, SO CALL IT MBPT2.   C
C  ELECTRON REPULATION INTEGRALS ARE GENERATED ONCE, AT THE EXPENSE OF C
C  ADDITIONAL MEMORY STORAGE -- THEY ARE CONTRACTED IN FOUR STEPS.     C
C  THIS ALGORITHM EXPLOITS SYMMETRIES BETWEEN (A,B) AND (C,D) IN THE   C
C  INTEGRALS (AB|CD), BUT NOT THE SWAP (AB|CD)<->(CD|AB). STRUCTURE    C
C  MIMICS THAT OF 'COULOMB', BUT DOES NOT IMPLEMENT SELECTION RULES.   C
C  CONTRACTION ADDRESSES ARE CALCULATED EXPLICITLY RATHER THAN JUST    C
C  WITH UPDATING COUNTERS -- THIS IS TO GUIDE THE USER IN TRACKING.    C
C -------------------------------------------------------------------- C
C INPUT:                                                               C
C  MINO  - LOWEST OCCUPIED STATE TO ACCOUNT FOR. (FULL: 1)             C
C  NUMO  - NUMBER OF OCCUPIED STATES TO ACCOUNT FOR. (FULL: NOCC)      C
C  MINV  - LOWEST VIRTUAL STATE TO ACCOUNT FOR. (FULL: NOCC+1)         C
C  NUMV  - NUMBER OF VIRTUAL STATES TO ACCOUNT FOR. (FULL: NVRT)       C
C  G2INT - NAME OF TWO-BODY OPERATOR ('COULM' OR 'BREIT').             C
C -------------------------------------------------------------------- C
C NOTE: LOOP STRUCTURE NOT LIKE COULOMB -- MUST CONTRACT C AND D ASAP. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000)
C
      CHARACTER*4 HMLT
      CHARACTER*5 G2INT
      CHARACTER*16 HMS
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION ISCF(11,6),IFLG(11)
      DIMENSION INDEX(MCT,-(MKP+1)/2:(MKP+1)/2,MKP)
      DIMENSION EAB2(NUMO,NUMO,6),EA2(NUMO,6)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 RR(MB2,16)
      COMPLEX*16 B(MBS*NUMO,8),SB(MB2,NUMO*NUMV,4)
      COMPLEX*16 ASB1(MBS,NUMO*NUMO*NUMV,2),ASB2(MBS,NUMO*NUMO*NUMV,2)
      COMPLEX*16 RASB((NUMO+1)*NUMO*NUMV*NUMV/2)
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      IERC = 0
C
C     WARNINGS BASED ON INVALID HMLT VS. G2INT COMBINATIONS
      IF(G2INT.EQ.'COULM') THEN
        IF(HMLT.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT2: HMLT = BARE but G2INT = COULM.'
          WRITE(7, *) 'In MBPT2: HMLT = BARE but G2INT = COULM.'
        ENDIF
      ELSEIF(G2INT.EQ.'BREIT') THEN
        IF(HMLT.EQ.'NORL') THEN
          WRITE(6, *) 'In MBPT2: HMLT = NORL but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLT = NORL but G2INT = BREIT.'
          RETURN
        ELSEIF(HMLT.EQ.'BARE') THEN
          WRITE(6, *) 'In MBPT2: HMLT = BARE but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLT = BARE but G2INT = BREIT.'
        ELSEIF(HMLT.EQ.'DHFR') THEN
          WRITE(6, *) 'In MBPT2: HMLT = DHFR but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLT = DHFR but G2INT = BREIT.'
        ELSEIF(HMLT.EQ.'DHFP') THEN
          WRITE(6, *) 'In MBPT2: HMLT = DHFP but G2INT = BREIT.'
          WRITE(7, *) 'In MBPT2: HMLT = DHFP but G2INT = BREIT.'
        ENDIF
      ENDIF
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 1
          ITSTOP = 1
          ITSKIP = 1
        ENDIF
      ELSE
        IF(G2INT.EQ.'COULM') THEN
          ITSTRT = 4
          ITSTOP = 1
          ITSKIP =-3
        ELSEIF(G2INT.EQ.'BREIT') THEN
          ITSTRT = 2
          ITSTOP = 3
          ITSKIP = 1        
        ENDIF
      ENDIF
C
C     INITIALISE TIME COUNTERS
      TERI = 0.0D0
      TCN1 = 0.0D0
      TCN2 = 0.0D0
      TCN3 = 0.0D0
      TCN4 = 0.0D0
      TSUM = 0.0D0
C
      CALL CPU_TIME(TBEG)
C
C     IMPORT MBPT1 PAIR RESULTS FOR E1(ab)
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT1.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NUMO
        DO IOCCB=1,NUMO
          READ(8, *) Q1,Q2,Q3,(EAB2(IOCCA,IOCCB,N),N=1,3)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C     CLEAR THE REMAINDER OF THE CORRELATION PAIR ENERGY VALUES
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
          DO N=4,6
            EAB2(IOCCA,IOCCB,N) = 0.0D0
          ENDDO
        ENDDO
      ENDDO
C
C     CLEAR THE ARRAY FOR (AR|BS) VALUES
      M = 0
      DO IVRTR=1,NUMV
        DO IOCCA=1,NUMO
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
              M = M+1
              RASB(M) = DCMPLX(0.0D0,0.0D0)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORDERED INDEX OF (ICNT,KQN,MQN) COMBINATIONS                     C
C**********************************************************************C
C
      ICOUNT = 0
C
C     LOOP OVER NUCLEAR CENTRES
      DO ICT=1,NCNT
C
C       LOOP OVER KAPPA VALUES FOR THIS NUCLEAR CENTRE
        DO KN=1,NKAP(ICT)
C
C         IMPORT KAPPA, MAXIMUM MQN
          KAPPA = KAPA(KN,ICT)
          MJMAX = 2*IABS(KAPPA)-1
C
C         LOOP OVER MQN VALUES AND RECORD INDEX
          DO MJ=1,MJMAX,2
            ICOUNT              = ICOUNT+1
            INDEX(ICT,KAPPA,MJ) = ICOUNT
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS TT(AB) (USE INDEX 1000)       C
C**********************************************************************C
C
C     COMPONENT LABEL FOR A AND B: TT = LL(1) or SS(4) <- COULM
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 1000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF A (USE INDEX 2000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     INDEX ASSIGNMENT
      IQ1 = INDEX(ICNTA,KQN(1),MQN(1))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON A
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF B (USE INDEX 3000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE B
      DO 3000 ICNTB=1,ICNTA
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(B) VALUES
      DO 3000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1, NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     INDEX ASSIGNMENT
      IQ2 = INDEX(ICNTB,KQN(2),MQN(2))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON B
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDAB
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
      IEAB = 1
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PAB1 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**((-MQN(1)+MQN(2))/2))
      PAB2 = ISIGN(1,KQN(1)*KQN(2))*DFLOAT((-1)**(( MQN(1)+MQN(2))/2))
C
C     SKIP CONTRIBUTIONS THAT ARISE BY PERMUTATION OF INTEGRALS
      IF(IQ1.LT.IQ2) GOTO 3001
C
C     CLEAR ARRAY FOR SECOND CONTRACTION (KL->SB)
      DO MSB=1,NUMO*NUMV
        DO MIJ=1,NBAS(1)*NBAS(2)
          DO IJSPIN=1,4
            SB(MIJ,MSB,IJSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS (IBAS,JBAS) (INDEX 4000)               C
C**********************************************************************C
C
      DO 4000 IBAS=1,NBAS(1)
      DO 4000 JBAS=1,NBAS(2)
C
C     LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
      MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP LABELS TT(CD) (USE INDEX 5000)       C
C**********************************************************************C
C
C     COMPONENT LABEL FOR C AND D: TT = LL(1) or SS(4) <- COULM
C                                  TT = LS(2) or SL(3) <- BREIT
      DO 5000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF C (USE INDEX 6000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE C
      DO 6000 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE C
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
C     LOOP OVER KQN(C) VALUES
      DO 6000 KC=1,NKAP(ICNTC)
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = BSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER |MQN(C)| VALUES
      DO 6000 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
C     INDEX ASSIGNMENT
      IQ3 = INDEX(ICNTC,KQN(3),MQN(3))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON C
      NC1 = LRGE(ICNTC,KC,2*MC-1) + NADDCD
      NC2 = LRGE(ICNTC,KC,2*MC  ) + NADDCD
C
C     CLEAR ARRAY FOR FIRST CONTRACTION (L->B)
      DO MKB=1,NBAS(3)*NUMO
        DO IJKSPIN=1,8
          B(MKB,IJKSPIN) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER BLOCKS OF D (USE INDEX 7000)                           C
C**********************************************************************C
C
C     LOOP OVER CENTRE D
      DO 7000 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE D
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
C     LOOP OVER KQN(D) VALUES
      DO 7000 KD=1,NKAP(ICNTD)
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = BSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C     LOOP OVER |MQN(D)| VALUES
      DO 7000 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
C     INDEX ASSIGNMENT
      IQ4 = INDEX(ICNTD,KQN(4),MQN(4))
C
C     STARTING FOCK ADDRESS FOR BASIS FUNCTIONS ON D
      ND1 = LRGE(ICNTD,KD,2*MD-1) + NADDCD
      ND2 = LRGE(ICNTD,KD,2*MD  ) + NADDCD
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C     FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
      IECD = 1
C
C     EQ-COEFFICIENT PHASE FACTORS FOR PERMUTATION OF R-INTEGRALS
      PCD1 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**((-MQN(3)+MQN(4))/2))
      PCD2 = ISIGN(1,KQN(3)*KQN(4))*DFLOAT((-1)**(( MQN(3)+MQN(4))/2))
C
C**********************************************************************C
C     ALL LOOPS NOW COMPLETE -- GENERATE BATCH OF ERIs AND CONTRACT    C
C**********************************************************************C
C
C     RESET SCREENING COUNTERS
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
      ENDDO

C     BATCH OF ELECTRON INTERACTION INTEGRALS (IJ|KL) FOR FIXED (IJ)
      CALL CPU_TIME(T1)
      IF(G2INT.EQ.'COULM') THEN
        CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
      ELSEIF(G2INT.EQ.'BREIT') THEN
        CALL BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
      ENDIF
      CALL CPU_TIME(T2)
      TERI = TERI + T2 - T1
C
C**********************************************************************C
C     FIRST CONTRACTION:                                               C
C     (IJ;T|KL;T') -> (IJ;T|KB;T')  AND  (IJ;T|LK;T') -> (IJ;T|LB;T')  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FIRST CONTRACTION (DIRECT): (IJ;T|KL;T') -> (IJ;T|KB;T')
C
C     LOOP OVER BASIS FUNCTIONS IN BLOCK C AND OCCUPIED STATES IOCCB
      DO KBAS=1,NBAS(3)
        DO IOCCB=1,NUMO
C
C         FOCK MATRIX ADDRESS FOR IOCCB
          IB = MINO-1+IOCCB+NSKP
C
C         LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
          MKB = (KBAS-1)*NUMO + IOCCB
C
C         CONTRACT OVER ALL LBAS IN BLOCK D
          DO LBAS=1,NBAS(4)
C
C           LIST ADDRESS FOR THIS KBAS,LBAS COMBINATION
            M = (KBAS-1)*NBAS(4) + LBAS
C
C           (--|-B) = (--|--) + (--|-+)
            B(MKB,1) = B(MKB,1) + RR(M, 1)*COEF(ND1+LBAS,IB)
     &                          + RR(M, 2)*COEF(ND2+LBAS,IB)
C
C           (+-|-B) = (+-|--) + (+-|-+)
            B(MKB,2) = B(MKB,2) + RR(M, 9)*COEF(ND1+LBAS,IB)
     &                          + RR(M,10)*COEF(ND2+LBAS,IB)
C
C           (-+|-B) = (-+|--) + (-+|-+)
            B(MKB,3) = B(MKB,3) + RR(M, 5)*COEF(ND1+LBAS,IB)
     &                          + RR(M, 6)*COEF(ND2+LBAS,IB)
C
C           (++|-B) = (++|--) + (++|-+)
            B(MKB,4) = B(MKB,4) + RR(M,13)*COEF(ND1+LBAS,IB)
     &                          + RR(M,14)*COEF(ND2+LBAS,IB)
C
C           (--|+B) = (--|+-) + (--|++)
            B(MKB,5) = B(MKB,5) + RR(M, 3)*COEF(ND1+LBAS,IB)
     &                          + RR(M, 4)*COEF(ND2+LBAS,IB)
C
C           (+-|+B) = (+-|+-) + (+-|++)
            B(MKB,6) = B(MKB,6) + RR(M,11)*COEF(ND1+LBAS,IB)
     &                          + RR(M,12)*COEF(ND2+LBAS,IB)
C
C           (-+|+B) = (-+|+-) + (-+|++)
            B(MKB,7) = B(MKB,7) + RR(M, 7)*COEF(ND1+LBAS,IB)
     &                          + RR(M, 8)*COEF(ND2+LBAS,IB)
C
C           (++|+B) = (++|+-) + (++|++)
            B(MKB,8) = B(MKB,8) + RR(M,15)*COEF(ND1+LBAS,IB)
     &                          + RR(M,16)*COEF(ND2+LBAS,IB)
C
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TCN1 = TCN1 + T2 - T1
C
C     FIRST CONTRACTION COMPLETE FOR THIS (IBAS,JBAS) - END LOOP OVER D
7000  CONTINUE
C
C**********************************************************************C
C     SECOND CONTRACTION:                                              C
C     (IJ;T|KB;T') -> (IJ;T|SB)                                        C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     SECOND CONTRACTION (DIRECT): (IJ;T|KB;T') -> (IJ;T|SB;T')
C
C     LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
      DO IOCCB=1,NUMO
        DO IVRTS=1,NUMV
C
C         FOCK MATRIX ADDRESS FOR IVRTS
          IS = MINV-1+IVRTS+NSKP
C
C         LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION IN B1
          MSB = (IOCCB-1)*NUMV + IVRTS
C
C         CONTRACT OVER ALL KBAS IN BLOCK C
          DO KBAS=1,NBAS(3)
C
C           LIST ADDRESS FOR THIS KBAS,IOCCB COMBINATION
            MKB = (KBAS-1)*NUMO + IOCCB
C
C           (--|SB) = (--|-B) + (--|+B)
            SB(MIJ,MSB,1) = SB(MIJ,MSB,1)
     &                             + B(MKB,1)*DCONJG(COEF(NC1+KBAS,IS))
     &                             + B(MKB,5)*DCONJG(COEF(NC2+KBAS,IS))
C
C           (-+|SB) = (-+|-B) + (-+|+B)
            SB(MIJ,MSB,2) = SB(MIJ,MSB,2)
     &                             + B(MKB,3)*DCONJG(COEF(NC1+KBAS,IS))
     &                             + B(MKB,7)*DCONJG(COEF(NC2+KBAS,IS))
C
C           (+-|SB) = (+-|-B) + (+-|+B)
            SB(MIJ,MSB,3) = SB(MIJ,MSB,3)
     &                             + B(MKB,2)*DCONJG(COEF(NC1+KBAS,IS))
     &                             + B(MKB,6)*DCONJG(COEF(NC2+KBAS,IS))
C
C           (++|SB) = (++|-B) + (++|+B)
            SB(MIJ,MSB,4) = SB(MIJ,MSB,4)
     &                             + B(MKB,4)*DCONJG(COEF(NC1+KBAS,IS))
     &                             + B(MKB,8)*DCONJG(COEF(NC2+KBAS,IS))
C
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TCN2 = TCN2 + T2 - T1
C
C     SECOND CONTRACTION COMPLETE FOR THIS (IBAS,JBAS) - END LOOP OVER C
6000  CONTINUE
5000  CONTINUE
C
C     SECOND CONTRACTION COMPLETE FOR ALL (IBAS,JBAS)
4000  CONTINUE
C
C**********************************************************************C
C     THIRD CONTRACTION:                                               C
C     (IJ;T|SB) -> (IA;T|SB)  AND  (JI;T|SB) -> (JA;T|SB)              C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     THIRD CONTRACTION (DIRECT): (IJ;T|SB) -> (IA;T|SB)
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (DIRECT)
      DO MASB=1,NUMV*NUMO*NUMO
        DO IBAS=1,NBAS(1)
          DO ISPIN=1,2
            ASB1(IBAS,MASB,ISPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
        DO IOCCB=1,IOCCA
          DO IVRTS=1,NUMV
C
C           LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
            MSB = (IOCCB-1)*NUMV+IVRTS
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
            MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C           CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (-A|SB) = (--|SB) + (-+|SB)
                ASB1(IBAS,MASB,1) = ASB1(IBAS,MASB,1)
     &                           +      SB(MIJ,MSB,1)*COEF(NB1+JBAS,IA)
     &                           +      SB(MIJ,MSB,2)*COEF(NB2+JBAS,IA)
C
C               (+A|SB) = (+-|SB) + (++|SB)
                ASB1(IBAS,MASB,2) = ASB1(IBAS,MASB,2)
     &                           +      SB(MIJ,MSB,3)*COEF(NB1+JBAS,IA)
     &                           +      SB(MIJ,MSB,4)*COEF(NB2+JBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     THIRD CONTRACTION (SWAP): (JI;T|SB) -> (JA;T|SB)
      IF(IQ1.EQ.IQ2) GOTO 4100
C
C     CLEAR ARRAY FOR THIRD CONTRACTION (SWAP)
      DO MASB=1,NUMV*NUMO*NUMO
        DO JBAS=1,NBAS(2)
          DO JSPIN=1,2
            ASB2(JBAS,MASB,JSPIN) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     LOOP OVER OCCUPIED STATES IOCCA
      DO IOCCA=1,NUMO
C
C       FOCK MATRIX ADDRESS FOR IOCCA
        IA = MINO-1+IOCCA+NSKP
C
C       LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
        DO IOCCB=1,IOCCA
          DO IVRTS=1,NUMV
C
C           LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
            MSB = (IOCCB-1)*NUMV+IVRTS
C
C           LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
            MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C           CONTRACT OVER ALL (IBAS,JBAS) IN BLOCKS A AND B
            DO IBAS=1,NBAS(1)
              DO JBAS=1,NBAS(2)
C
C               LIST ADDRESS FOR THIS IBAS,JBAS COMBINATION
                MIJ = (IBAS-1)*NBAS(2)+JBAS
C
C               (+A|SB) = PCD*{(+A|SB)} = PCD*{(++|SB) + (-+|SB)}
                ASB2(JBAS,MASB,1) = ASB2(JBAS,MASB,1)
     &                           + PAB1*SB(MIJ,MSB,4)*COEF(NA1+IBAS,IA)
     &                           + PAB2*SB(MIJ,MSB,2)*COEF(NA2+IBAS,IA)
C
C               (-A|SB) = PCD*{(-A|SB)} = PCD*{(+-|SB) + (--|SB)}
                ASB2(JBAS,MASB,2) = ASB2(JBAS,MASB,2)
     &                           + PAB2*SB(MIJ,MSB,3)*COEF(NA1+IBAS,IA)
     &                           + PAB1*SB(MIJ,MSB,1)*COEF(NA2+IBAS,IA)
C
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SKIP POINT FOR IQ1 = IQ2
4100  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN3 = TCN3 + T2 - T1
C
C**********************************************************************C
C     FOURTH CONTRACTION:                      ~                       C
C     (IA;T|SB) -> (RA|SB)  AND  (JA;T|SB) -> (RA|SB)                  C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOURTH CONTRACTION (DIRECT): (IA;T|SB) -> (RA|SB)
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESS FOR IVRTR
          IR = MINV-1+IVRTR+NSKP
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
C
C             LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
              MSB = (IOCCB-1)*NUMV + IVRTS
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
              MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C             LIST ADDRESS FOR THIS IVRTR,IOCCA AND THE ABOVE MSB
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTR-1)*NUMV*IOCCA + MSB
C
C             CONTRACT OVER ALL IBAS IN BLOCK A
              DO IBAS=1,NBAS(1)
C
C               (RA|SB) = (-A|SB) + (+A|SB)
                RASB(MRASB) = RASB(MRASB)
     &                    + ASB1(IBAS,MASB,1)*DCONJG(COEF(NA1+IBAS,IR))
     &                    + ASB1(IBAS,MASB,2)*DCONJG(COEF(NA2+IBAS,IR))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C                                              ~
C     FOURTH CONTRACTION (SWAP): (JA;T|SB) -> (RA|SB)
      IF(IQ1.EQ.IQ2) GOTO 4200
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESS FOR IVRTR
          IR = MINV-1+IVRTR+NSKP
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
C
C             LIST ADDRESS FOR THIS IVRTS,IOCCB COMBINATION
              MSB = (IOCCB-1)*NUMV+IVRTS
C
C             LIST ADDRESS FOR THIS IOCCA AND THE ABOVE MSB
              MASB = (IOCCA-1)*NUMV*NUMO + MSB
C
C             LIST ADDRESS FOR THIS IVRTR,IOCCA AND THE ABOVE MSB
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTR-1)*NUMV*IOCCA + MSB
C
C             CONTRACT OVER ALL JBAS IN BLOCK B
              DO JBAS=1,NBAS(2)
C
C               (PA|SB) = (+A|SB) + (-A|SB)
                RASB(MRASB) = RASB(MRASB)
     &                    + ASB2(JBAS,MASB,1)*DCONJG(COEF(NB1+JBAS,IR))
     &                    + ASB2(JBAS,MASB,2)*DCONJG(COEF(NB2+JBAS,IR))
C
              ENDDO
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
4200  CONTINUE
C
      CALL CPU_TIME(T2)
      TCN4 = TCN4 + T2 - T1
C
C     ALL CONTRIBUTIONS FROM THIS CLASS (A,B,C,D) NOW ACCOUNTED FOR
3001  CONTINUE
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER PAIR CORRELATION ENERGY                   C
C**********************************************************************C
C
      CALL CPU_TIME(T1)
C
C     FOR EACH IOCCA,IOCCB PAIR, SUM OVER IVRTR AND IVRTS CONTRIBUTIONS
C
C     LOOP OVER OCCUPIED STATES IOCCA AND VIRTUAL STATES IVRTR
      DO IOCCA=1,NUMO
        DO IVRTR=1,NUMV
C
C         FOCK MATRIX ADDRESSES
          IA = MINO-1+IOCCA+NSKP
          IR = MINV-1+IVRTR+NSKP
C
C         LOOP OVER OCCUPIED STATES IOCCB AND VIRTUAL STATES IVRTS
          DO IOCCB=1,IOCCA
            DO IVRTS=1,NUMV
C
C             FOCK MATRIX ADDRESSES
              IB = MINO-1+IOCCB+NSKP
              IS = MINV-1+IVRTS+NSKP
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTR,IOCCB,IVRTS
              MRASB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTR-1)*NUMV*IOCCA + (IOCCB-1)*NUMV + IVRTS
C
C             MAIN LIST ADDRESS FOR THIS IOCCA,IVRTS,IOCCB,IVRTR
              MSARB = (IOCCA-1)*NUMV*IOCCA*NUMV/2
     &              + (IVRTS-1)*NUMV*IOCCA + (IOCCB-1)*NUMV + IVRTR
C
C             NUMERATOR FOR DIRECT AND EXCHANGE CONTRIBUTIONS
              RNUMD = DREAL(RASB(MRASB)*DCONJG(RASB(MRASB)))
              RNUMX =-DREAL(RASB(MRASB)*DCONJG(RASB(MSARB)))
C
C             DENOMINATOR FOR BOTH CONTRIBUTIONS
              EABRS = EIGN(IA) + EIGN(IB) - EIGN(IR) - EIGN(IS)
C
C             ADD TO DIRECT AND EXCHANGE BINS
              EAB2(IOCCA,IOCCB,4) = EAB2(IOCCA,IOCCB,4) + RNUMD/EABRS
              EAB2(IOCCA,IOCCB,5) = EAB2(IOCCA,IOCCB,5) + RNUMX/EABRS
C
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     FILL IN THE OTHER HALF OF THE ARRAY AND CALCULATE TOTALS
      E1S = 0.0D0
      E2D = 0.0D0
      E2X = 0.0D0
      E2S = 0.0D0
      DO IOCCA=1,NUMO
        DO IOCCB=1,IOCCA
C
C         INTERMEDIATE VALUES
          EAB1TOT = EAB2(IOCCA,IOCCB,3)
          EAB2DIR = EAB2(IOCCA,IOCCB,4)
          EAB2XCH = EAB2(IOCCA,IOCCB,5)
          EAB2SUM = EAB2DIR + EAB2XCH
C
C         PUT THESE INTO EAB2 AND ADD CONTRIBUTION TO E2
          EAB2(IOCCA,IOCCB,6) = EAB2SUM
          IF(IOCCA.NE.IOCCB) THEN
            EAB2(IOCCB,IOCCA,3) = EAB1TOT
            EAB2(IOCCB,IOCCA,4) = EAB2DIR
            EAB2(IOCCB,IOCCA,5) = EAB2XCH
            EAB2(IOCCB,IOCCA,6) = EAB2SUM
            E1S = E1S +       EAB1TOT
            E2D = E2D +       EAB2DIR
            E2X = E2X +       EAB2XCH
            E2S = E2S +       EAB2SUM
          ELSE
            E1S = E1S + 0.5D0*EAB1TOT
            E2D = E2D + 0.5D0*EAB2DIR
            E2X = E2X + 0.5D0*EAB2XCH
            E2S = E2S + 0.5D0*EAB2SUM
          ENDIF
        ENDDO
      ENDDO
C
C     WRITE RESULTS OF EAB ENERGIES TO AN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MBPT2.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO IOCCA=1,NOCC
        DO IOCCB=1,NOCC
          WRITE(8, *) (EAB2(IOCCA,IOCCB,N),N=1,6)
        ENDDO
      ENDDO
      CLOSE(UNIT=8)
C
C**********************************************************************C
C     CALCULATE SECOND-ORDER SINGLE ORBITAL ENERGY                     C
C**********************************************************************C
C
C     FOR EACH IOCCA, SUM OVER THE IOCCB CONTRIBUTIONS
      DO IOCCA=1,NUMO
        DO N=1,6
          EA2(IOCCA,N) = 0.0D0
          DO IOCCB=1,NUMO
            EA2(IOCCA,N) = EA2(IOCCA,N) + EAB2(IOCCA,IOCCB,N)
          ENDDO
        ENDDO
      ENDDO
C
      CALL CPU_TIME(T2)
      TSUM = TSUM + T2 - T1
C
C**********************************************************************C
C     TERMINAL OUTPUT SUMMARY                                          C
C**********************************************************************C
C
C     MBPT2 PAIRWISE SUMMARY
20    FORMAT(1X,A,9X,A,9X,A,9X,A,9X,A)
21    FORMAT(' (',I2,',',I2,')',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',25),'MBPT2 pairwise summary'
      WRITE(7, *) REPEAT(' ',25),'MBPT2 pairwise summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20) '( a, b)','E1G(ab)','E2J(ab)','E2K(ab)','E2G(ab)'
      WRITE(7,20) '( a, b)','E1G(ab)','E2J(ab)','E2K(ab)','E2G(ab)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        DO IOCCB=1,IOCCA
          IBNUM = IOCCB+MINO-1
          WRITE(6,21) IANUM,IBNUM,(EAB2(IOCCA,IOCCB,N),N=3,6)
          WRITE(7,21) IANUM,IBNUM,(EAB2(IOCCA,IOCCB,N),N=3,6)
        ENDDO
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 SINGLE-PARTICLE SUMMARY
30    FORMAT(1X,A,10X,A,10X,A,10X,A,10X,A)
31    FORMAT('  ',I2,'    ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',21),'MBPT2 single particle summary'
      WRITE(7, *) REPEAT(' ',21),'MBPT2 single particle summary'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) '  a    ','E1G(a)','E2J(a)','E2K(a)',' E2G(a)'
      WRITE(7,30) '  a    ','E1G(a)','E2J(a)','E2K(a)',' E2G(a)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      DO IOCCA=1,NUMO
        IANUM = IOCCA+MINO-1
        WRITE(6,31) IANUM,(EA2(IOCCA,N),N=3,6)
        WRITE(7,31) IANUM,(EA2(IOCCA,N),N=3,6)
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 TOTAL SECOND ORDER CORRELATION ENERGY
32    FORMAT(' total  ',3X,F13.7,5X,F11.7,5X,F11.7,4X,F13.7)

      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT(' ',17),'MBPT2 second order correlation energy'
      WRITE(7, *) REPEAT(' ',17),'MBPT2 second order correlation energy'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,32) E1S,E2D,E2X,E2S
      WRITE(7,32) E1S,E2D,E2X,E2S
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     MBPT2 LABOUR ANALYSIS
      CALL CPU_TIME(TFIN)
      TTOT = TFIN - TBEG
      TOTH = TTOT - (TERI + TCN1 + TCN2 + TCN3 + TCN4 + TSUM)

40    FORMAT(1X,A,24X,A)
      WRITE(6, *) REPEAT(' ',72)
      WRITE(7, *) REPEAT(' ',72)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',26),'MBPT2 labour analysis'
      WRITE(7, *) REPEAT(' ',26),'MBPT2 labour analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6,40) 'ERI construction - (IJ|KL)      ',HMS(TERI)
      WRITE(7,40) 'ERI construction - (IJ|KL)      ',HMS(TERI)
      WRITE(6,40) '1st contraction  - (IJ|KB)      ',HMS(TCN1)
      WRITE(7,40) '1st contraction  - (IJ|KB)      ',HMS(TCN1)
      WRITE(6,40) '2nd contraction  - (IJ|SB)      ',HMS(TCN2)
      WRITE(7,40) '2nd contraction  - (IJ|SB)      ',HMS(TCN2)
      WRITE(6,40) '3rd contraction  - (IA|SB)      ',HMS(TCN3)
      WRITE(7,40) '3rd contraction  - (IA|SB)      ',HMS(TCN3)
      WRITE(6,40) '4th contraction  - (RA|SB)      ',HMS(TCN4)
      WRITE(7,40) '4th contraction  - (RA|SB)      ',HMS(TCN4)
      WRITE(6,40) 'Virtual orbital sum - E2(A,B)   ',HMS(TSUM)
      WRITE(7,40) 'Virtual orbital sum - E2(A,B)   ',HMS(TSUM)
      WRITE(6,40) 'Other                           ',HMS(TOTH)
      WRITE(7,40) 'Other                           ',HMS(TOTH)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,40) 'Total MBPT2 time                ',HMS(TTOT)
      WRITE(7,40) 'Total MBPT2 time                ',HMS(TTOT)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [10] EXPECTATION VALUES: OBSERVABLES FROM A CONVERGED SOLUTION.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] PT1BODY: MAIN ROUTINE FOR MOLECULAR EXPECTATION VALUES.        C
C   [B] PROPRTY: MOLECULAR EXPECTATION VALUE FROM DENSITY MATRIX.      C
C   [C] RSPT1: SET OF 1ST ORDER MOLECULAR MATRIX ELEMENTS AND E(2).    C
C   [D] DIAGRMTC: SET OF GOLDSTONE DIAGRAM CONTRIBUTIONS FOR ORBITAL.  C
C -------------------------------------------------------------------- C
C   [A] MULLIKN: MULLIKEN POPULATION ANALYSIS ON CONVERGED SOLUTION.   C
C   [B] ORTHGNL: ORBITAL ORTHOGONALITY ANALYSIS.                       C
C   [C] ELCDIPL: PERMANENT ELECTRIC DIPOLE MOMENT ANALYSIS.            C
C   [D] ELCQDPL: PERMANENT ELECTRIC QUADRUPOLE MOMENT ANALYSIS.        C
C   [E] MAGDIPL: PERMANENT MAGNETIC DIPOLE MOMENT ANALYSIS.            C
C   [F] MAGQDPL: PERMANENT MAGNETIC QUADRUPOLE MOMENT ANALYSIS.        C
C   [G] STRKEFF: STARK EFFECT ANALYSIS, GIVEN ELECTRIC FIELD E.        C
C   [H] ZMANEFF: ZEEMAN EFFECT ANALYSIS, GIVEN MAGNETIC FIELD B.       C
C   [I] HYPFINE: HYPERFINE INTERACTION ANALYSIS, GIVEN NUCLEAR MOMENT. C
C   [J] GTENSOR: MAGNETIC G-TENSOR CALCULATION.                        C
C   [K] EEDMSML: ATOM-CENTREED PT-ODD EDM OPERATOR (WITH E-FIELD).     C
C   [L] EEDMEFF: ONE-BODY EFFECTIVE PT-ODD EDM OPERATOR.               C
C   [M] ENHANFC: MOLECULAR EEDM ENHANCEMENT FACTOR CALCULATION.        C
C   [N] SCLPTEN: SCALAR PT-ODD ELECTRON-NUCLEAR INTERACTION ANALYSIS.  C
C   [O] VECPTEN: VECTOR PT-ODD ELECTRON-NUCLEAR INTERACTION ANALYSIS.  C
C   [P] PVIOLTN: P-ODD EFFECTIVE OPERATOR ANALYSIS.                    C
C   [Q] BETADCY: CORRECTIONS DUE TO THE NUCLEAR DECAY OF A CENTRE.     C
C   [R] NUCOLAP: GAUSSIAN NUCLEAR OVERLAP WITH ELECTRON CHARGE DENSITY.C
C -------------------------------------------------------------------- C
C   [A] VMOMNT0: ZEROTH MOMENT INTEGRALS OVER SIGMA_Q AND TT'.         C
C   [B] VMOMNT1: FIRST MOMENT INTEGRALS OVER SIGMA_Q, TT' AND IX.      C
C   [C] VMOMNT2: SECOND MOMENT INTEGRALS OVER SIGMA_Q, TT', IX AND JX. C
C   [D] VMNPOLE: FIELD MONOPOLE INTEGRALS OVER SIGMA_Q AND TT'.        C
C   [E] VDIPOLE: FIELD DIPOLE INTEGRALS OVER SIGMA_Q, TT' AND IX.      C
C   [F] VQDPOLE: FIELD QUADRUPOLE INT'S OVER SIGMA_Q, TT', IX AND IX'. C
C   [G] VNCATRC: NUCLEAR ATTRACTION INTEGRALS.                         C
C   [H] VNCOLAP: NUCLEAR CHARGE INTEGRALS OVER SIGMA_Q, TT' AND IZ.    C
C   [I] VKNETIC: RELATIVISTIC KINETIC OVERLAP INTEGRALS.               C
C   [J] VLPLACE: NON-RELATIVISTIC KINETIC INTEGRALS.                   C
C   [K] VPLNWAV: PLANE WAVE MATRIX ELEMENT INTEGRALS FOR WAVE VECTOR K.C
C**********************************************************************C
C
C
      SUBROUTINE PT1BODY
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       PPPPPPP TTTTTTTT 11  BBBBBBB   OOOOOO  DDDDDDD  YY    YY       C
C       PP    PP   TT   111  BB    BB OO    OO DD    DD YY    YY       C
C       PP    PP   TT    11  BB    BB OO    OO DD    DD  YY  YY        C
C       PP    PP   TT    11  BBBBBBB  OO    OO DD    DD   YYYY         C
C       PPPPPPP    TT    11  BB    BB OO    OO DD    DD    YY          C
C       PP         TT    11  BB    BB OO    OO DD    DD    YY          C
C       PP         TT   1111 BBBBBBB   OOOOOO  DDDDDDD     YY          C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  PT1BODY CALCULATES MATRIX ELEMENTS AND ENERGY CORRECTIONS GIVEN A   C
C  HARTREE-FOCK CALCULATION AND SET OF COEFFICIENTS AND ENERGIES.      C
C -------------------------------------------------------------------- C
C  EQFILE ONLY GENERATES ELL0, ESS0 AND MAYBE ELSI, AND IN GENERAL     C
C  THESE CALCULATIONS REQUIRE ETT'Q, SO GENERATE AS NEEDED INSTEAD.    C
C -------------------------------------------------------------------- C
C  BASIS OVERLAP MATRIX ELEMENTS AVAILABLE:                            C
C  (u,T|s_q|v,T')          - VMOMNT0(VIJ,IQ)      - ZEROTH MOMENT      C
C  (u,T|s_q.x|v,T')        - VMOMNT1(VIJ,IQ,IX)   - FIRST MOMENT       C
C  (u,T|s_q.x.x'|v,T')     - VMOMNT2(VIJ,IQ,IX,JX)- SECOND MOMENT      C
C  (u,T|s_q.x/r^3|v,T')    - VMNPOLE(VIJ,IQ,IX)   - FIELD MONOPOLE     C
C  (u,T|s_q.x.y/r^3|v,T')  - VDIPOLE(VIJ,IQ,IX'S) - FIELD DIPOLE       C
C  (u,T|s_q.x.y.z/r^3|v,T')- VQDPOLE(VIJ,IQ,IX'S) - FIELD QUADRUPOLE   C
C  (u,T|s_q.Vnc|v,T')      - VNCATRC(VIJ)         - NUCLEAR ATTRACTION C
C  (u,T|s_q.pnc|v,T')      - VNCOLAP(VIJ)         - NUCLEAR OVERLAP    C
C  (u,T|s_q.p|v,T')        - VKNETIC(VIJ)         - REL'VISTIC KINETIC C
C  (u,T|s_q.lap|v,T')      - VLPLACE(VIJ)         - NON-REL KINETIC    C
C  (u,T|exp(ik.x)|v,T')    - VPLNWAV(VIJ)         - PLANE WAVE         C
C**********************************************************************C
C
      CHARACTER*4  HMLT
      CHARACTER*7  HMINT(10)
      CHARACTER*16 HMS
C
      DIMENSION EFIELD(3),BFIELD(3),GAUGE(3)
C
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/PT1B/NHMINT,HMINT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
      COMMON/TPRP/EMTY
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
      CALL FACTRLS
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     IF READING IN PREVIOUS SOLUTION, CALCULATE MOLECULAR DENSITY
      IF(INEW.EQ.1) THEN
        CALL DENSTY
      ENDIF
C
C     EQ-COEFF AND R-INT TIME INITIALISATION
      TELL = 0.0D0
      TESS = 0.0D0
      TELS = 0.0D0
      TESL = 0.0D0
      TRLL = 0.0D0
      TRSS = 0.0D0
      TRLS = 0.0D0
      TRSL = 0.0D0
C
C     LOOP OVER ALL REQUESTED INTERACTION HAMILTONIANS
      DO N=1,NHMINT

C       PRINT A TITLE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) 'One-body H_{int} = ',HMINT(N)
        WRITE(7, *) 'One-body H_{int} = ',HMINT(N)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
        IF(HMINT(N).EQ.'MULLIKN') THEN
          CALL MULLIKN(2)
        ELSEIF(HMINT(N).EQ.'ORTHGNL') THEN
          CALL ORTHGNL
        ELSEIF(HMINT(N).EQ.'ELCDIPL') THEN
          CALL ELCDIPL
        ELSEIF(HMINT(N).EQ.'ELCQDPL') THEN
          CALL ELCQDPL
        ELSEIF(HMINT(N).EQ.'MAGDIPL') THEN
          CALL MAGDIPL
        ELSEIF(HMINT(N).EQ.'MAGQDPL') THEN
          CALL MAGQDPL
        ELSEIF(HMINT(N).EQ.'STRKEFF') THEN
C         UNIFORM ELECTRIC FIELD VECTOR
          EFIELD(1) = 0.0D0
          EFIELD(2) = 0.0D0
          EFIELD(3) = 1.0D0
C         GAUGE ORIGIN
          GAUGE(1) = 0.0D0
          GAUGE(2) = 0.0D0
          GAUGE(3) = 0.0D0
          CALL STRKEFF(EFIELD,GAUGE)
        ELSEIF(HMINT(N).EQ.'ZMANEFF') THEN
C         UNIFORM MAGNETIC FIELD VECTOR
          BFIELD(1) = 0.0D0
          BFIELD(2) = 0.0D0
          BFIELD(3) = 1.0D0
C         GAUGE ORIGIN
          GAUGE(1) = 0.0D0
          GAUGE(2) = 0.0D0
          GAUGE(3) = 0.0D0
          CALL ZMANEFF(BFIELD,GAUGE)
        ELSEIF(HMINT(N).EQ.'HYPFINE') THEN
C         CENTRE WITH NUCLEAR MAGENTIC MOMENT AND GI*|I|
          ICNT = 1
          GIIM = 3.25644D0
          CALL HYPFINE(ICNT,GIIM)
        ELSEIF(HMINT(N).EQ.'GTENSOR') THEN
C         GAUGE ORIGIN
          ICNT = 1
          GAUGE(1) = 0.0D0
          GAUGE(2) = 0.0D0
          GAUGE(3) = 0.0D0
          CALL GTENSOR(ICNT,GAUGE)
        ELSEIF(HMINT(N).EQ.'EEDMSML') THEN
C         CENTRE WHICH FACILITATES PT-ODD ELECTRON-ELECTRON INTERACTION
          ICNT = 1
          IOCC = 79
          CALL EEDMSML(ICNT,IOCC)
        ELSEIF(HMINT(N).EQ.'EEDMEFF') THEN
          IOCC = 79
          CALL EEDMEFF(IOCC)
        ELSEIF(HMINT(N).EQ.'ENHANFC') THEN
C         NUMBER OF ORBITALS FROM VIRTUAL SPECTRUM (IN ORDER) TO INCLUDE
          IOCC = 0
          CALL ENHANFC(IOCC)
        ELSEIF(HMINT(N).EQ.'SCLPTEN') THEN
          CALL SCLPTEN
        ELSEIF(HMINT(N).EQ.'VECPTEN') THEN
          CALL VECPTEN
        ELSEIF(HMINT(N).EQ.'PVIOLTN') THEN
          CALL PVIOLTN
        ELSEIF(HMINT(N).EQ.'BETADCY') THEN
C         CENTRE UNDERGOING DECAY AND EMITTED CHARGE
          ICNT = 1
          ZDCY = 2.0D0
          CALL BETADCY(ICNT,ZDCY)
        ELSEIF(HMINT(N).EQ.'NUCOLAP') THEN
C         CENTRE WHOSE DENSITY OVERLAP IS DESIRED
          ICNT = 1
          CALL NUCOLAP(ICNT)
        ELSE
          WRITE(6, *) 'In PT1BODY: this operator is not available.'
          WRITE(7, *) 'In PT1BODY: this operator is not available.'
        ENDIF
C
C     END LOOP OVER INTERACTION HAMILTONIANS
      ENDDO
C
C     CALL SPECTRM(8,0)

C     TOTAL TIME TAKEN
      CALL CPU_TIME(TPRP)
      TPRP = TPRP-TDUM
C
20    FORMAT(1X,A,37X,A)
      IF(TELL.GT.0.30D0) THEN
        WRITE(6,20) 'Time in EMAKE (LL):',HMS(TELL)
        WRITE(7,20) 'Time in EMAKE (LL):',HMS(TELL)
      ENDIF
      IF(TELS.GT.0.30D0) THEN
        WRITE(6,20) 'Time in EMAKE (LS):',HMS(TELS)
        WRITE(7,20) 'Time in EMAKE (LS):',HMS(TELS)
      ENDIF
      IF(TESL.GT.0.30D0) THEN
        WRITE(6,20) 'Time in EMAKE (SL):',HMS(TESL)
        WRITE(7,20) 'Time in EMAKE (SL):',HMS(TESL)
      ENDIF
      IF(TESS.GT.0.30D0) THEN
        WRITE(6,20) 'Time in EMAKE (SS):',HMS(TESS)
        WRITE(7,20) 'Time in EMAKE (SS):',HMS(TESS)
      ENDIF
      IF(TRLL.GT.0.30D0) THEN
        WRITE(6,20) 'Time in RMAKE (LL):',HMS(TRLL)
        WRITE(7,20) 'Time in RMAKE (LL):',HMS(TRLL)
      ENDIF
      IF(TRLS.GT.0.30D0) THEN
        WRITE(6,20) 'Time in RMAKE (LS):',HMS(TRLS)
        WRITE(7,20) 'Time in RMAKE (LS):',HMS(TRLS)
      ENDIF
      IF(TRSL.GT.0.30D0) THEN
        WRITE(6,20) 'Time in RMAKE (SL):',HMS(TRSL)
        WRITE(7,20) 'Time in RMAKE (SL):',HMS(TRSL)
      ENDIF
      IF(TRSS.GT.0.30D0) THEN
        WRITE(6,20) 'Time in RMAKE (SS):',HMS(TRSS)
        WRITE(7,20) 'Time in RMAKE (SS):',HMS(TRSS)
      ENDIF
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE PROPRTY(E1,BLL,BLS,BSL,BSS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP  RRRRRRR   OOOOOO  PPPPPPP  RRRRRRR TTTTTTTT YY    YY    C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT    YY    YY    C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT     YY  YY     C
C     PP    PP RR    RR OO    OO PP    PP RR    RR   TT      YYYY      C
C     PPPPPPP  RRRRRRR  OO    OO PPPPPPP  RRRRRRR    TT       YY       C
C     PP       RR    RR OO    OO PP       RR    RR   TT       YY       C
C     PP       RR    RR  OOOOOO  PP       RR    RR   TT       YY       C
C                                                                      C
C -------------------------------------------------------------------- C
C  PROPRTY CALCULATES A MOLECULAR EXPECTATION VALUE OVER THE DENSITY   C
C  MATRIX AND BASIS PAIR INTEGRALS IN THE B MATRICES.                  C
C -------------------------------------------------------------------- C
C  OUTPUT:                                                             C
C    E1: COMPLEX-VALUED MOLECULAR EXPECTATION VALUE RESULTS FOR EACH   C
C        COMPONENT TYPE OVERLAP ITT, WITH ITT=5 FOR TOTAL VALUE.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      COMPLEX*16 E1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 BLL(MDM,MDM),BSS(MDM,MDM),BLS(MDM,MDM),BSL(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE COUNTER ARRAYS FOR BASIS OVERLAP CONTRIBUTIONS
      DO ITT=1,4
        E1(ITT) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     LOOP OVER ALL BASIS FUNCTIONS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          E1(1) = E1(1) + BLL(I,J)*DENT(I     ,J     )
          IF(HMLT.EQ.'NORL') GOTO 100
          E1(2) = E1(2) + BLS(I,J)*DENT(I     ,J+NSKP)
          E1(3) = E1(3) + BSL(I,J)*DENT(I+NSKP,J     )
          E1(4) = E1(4) + BSS(I,J)*DENT(I+NSKP,J+NSKP)
100       CONTINUE
        ENDDO
      ENDDO
C
C     MOLECULAR EXPECTATION VALUE
      E1(5) = E1(1)+E1(2)+E1(3)+E1(4)
C
      RETURN
      END
C
C
      SUBROUTINE RSPT1(V1,BLL,BLS,BSL,BSS,NORD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                RRRRRRR   SSSSSS  PPPPPPP TTTTTTTT 11                 C
C                RR    RR SS    SS PP    PP   TT   111                 C
C                RR    RR SS       PP    PP   TT    11                 C
C                RR    RR  SSSSSS  PP    PP   TT    11                 C
C                RRRRRRR        SS PPPPPPP    TT    11                 C
C                RR    RR SS    SS PP         TT    11                 C
C                RR    RR  SSSSSS  PP         TT   1111                C
C                                                                      C
C -------------------------------------------------------------------- C
C  RSPT1 ASSEMBLES AN ARRAY OF MOLECULAR MATRIX ELEMENTS FROM BASIS    C
C  FUNCTION OVERLAPS IN BTT BY FIRST-ORDER RAYLEIGH-SCHRODINGER P.T.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    BTT  - ARRAY OF COMPONENT OVERLAPS FOR INTEGRALS OVER BASIS FNS.  C
C    NORD - MAXIMUM ORDER IN PERTURBATIVE EXPANSION TO FOLLOW.         C
C  OUTPUT:                                                             C
C    V1   - ARRAY OF MATRIX ELEMENTS FOR ZERO-ORDER SOLUTION.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      COMPLEX*16 SUMLL,SUMSS,SUMLS,SUMSL,TMP
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 BLL(MDM,MDM),BSS(MDM,MDM),BLS(MDM,MDM),BSL(MDM,MDM)
      COMPLEX*16 V1(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     TOLERANCE VALUE FOR VANISHING MATRIX ELEMENTS
      TOL = 1.0D-10
C
C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
      DO IOCC=1,NDIM
        DO JOCC=1,NDIM
C
          IF(NORD.EQ.1.AND.IOCC.NE.JOCC) GOTO 150
C
C         INITIALISE COUNTER ARRAYS FOR BASIS OVERLAP CONTRIBUTIONS
          SUMLL = DCMPLX(0.0D0,0.0D0)
          SUMSS = DCMPLX(0.0D0,0.0D0)
          SUMLS = DCMPLX(0.0D0,0.0D0)
          SUMSL = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FOCK MATRIX ADDRESSES
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
C
              K = I+NSKP
              L = J+NSKP
C
C             LARGE AND SMALL CONTRIBUTIONS
              SUMLL = SUMLL + DCONJG(COEF(I,IOCC))*COEF(J,JOCC)*BLL(I,J)
              IF(HMLT.EQ.'NORL') GOTO 100
              SUMSS = SUMSS + DCONJG(COEF(K,IOCC))*COEF(L,JOCC)*BSS(I,J)
              SUMLS = SUMLS + DCONJG(COEF(I,IOCC))*COEF(L,JOCC)*BLS(I,J)
              SUMSL = SUMSL + DCONJG(COEF(K,IOCC))*COEF(J,JOCC)*BSL(I,J)
100           CONTINUE
C
            ENDDO
          ENDDO
C
C         SAVE SUMS TO MATRIX
          V1(IOCC,JOCC) = SUMLL + SUMSS + SUMLS + SUMSL
C
C         VANISHING MATRIX ELEMENTS
          TMP1 = DREAL(V1(IOCC,JOCC))
          TMP2 = DIMAG(V1(IOCC,JOCC))
          IF(DABS(TMP1).LT.TOL) THEN
            TMP1 = 0.0D0
          ENDIF
          IF(DABS(TMP2).LT.TOL) THEN
            TMP2 = 0.0D0
          ENDIF
          V1(IOCC,JOCC) = DCMPLX(TMP1,TMP2)
C
150       CONTINUE
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,IOCC,IWRT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C DDDDDDD IIII    AA     GGGGGG  RRRRRRR  MM       MM TTTTTTTT CCCCCC  C
C DD    DD II    AAAA   GG    GG RR    RR MMM     MMM    TT   CC    CC C
C DD    DD II   AA  AA  GG       RR    RR MMMM   MMMM    TT   CC       C
C DD    DD II  AA    AA GG       RR    RR MM MM MM MM    TT   CC       C
C DD    DD II  AAAAAAAA GG   GGG RRRRRRR  MM  MMM  MM    TT   CC       C
C DD    DD II  AA    AA GG    GG RR    RR MM   M   MM    TT   CC    CC C
C DDDDDDD IIII AA    AA  GGGGGG  RR    RR MM       MM    TT    CCCCCC  C
C                                                                      C
C -------------------------------------------------------------------- C
C  DIAGRMTC CALCULATES ALL GOLDSTONE DIAGRAMS UP TO ORDER NORD ARISING C
C  FROM INTERACTION MATRIX V1 FOR AN OCCUPIED STATE IOCC, SEPARATING   C
C  RESULTS INTO POSITIVE/NEGATIVE ENERGY SPECTRUM CONTRIBUTIONS.       C
C -------------------------------------------------------------------- C
C  DFNOTE: THIS DOES NOT COMPLEX CONJUGATE AT ALL AND COMPLEX GOES     C
C          TO DOUBLE. PROBABLY WON'T AFFECT ANYTHING BUT CHECK ANYWAY. C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    V1   - ARRAY OF ALL MATRIX ELEMENTS BETWEEN SOLUTION STATES.      C
C    NORD - MAXIMUM ORDER TO BE CALCULATED IN PERTURBATIVE EXPANSION.  C
C    IOCC - SOLUTION STATE OF INTEREST.                                C
C    IWRT - PARAMETER THAT DETERMINES WHETHER TO WRITE RESULTS.        C
C  OUTPUT:                                                             C
C    EPOS - POSITIVE-ENERGY SPECTRUM COMPONENT OF GOLDSTONE DIAGRAMS.  C
C    ENEG - PART OF GOLDSTONE DIAGRAMS THAT INVOLVE NEGATIVE CONTRIB'N.C
C    ETOT - TOTAL GOLDSTONE DIAGRAM EXPECTATION VALUE -- SEE THE END   C
C           OF THIS SUBROUTINE FOR IDENTIFICATION OF DIAGRAMS (0:21).  C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 V2,V3P,V3H,V4PP,V4PH,V4HH,V4RR,V5PPP,V5PPH,V5C,V5PHH,
     &           V5A,V5B,V5D,V5HHH,V5E
C
      COMMON/EIGE/E0(MDM)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE ENERGY COUNTERS
      DO I=0,21
        EPOS(I) = 0.0D0
        ENEG(I) = 0.0D0
        ETOT(I) = 0.0D0
      ENDDO
C
C**********************************************************************C
C     E^(0) ZERO-ORDER CORRECTION                                      C
C**********************************************************************C
C
C     PERTURBATION ENERGY E^(0) -- DIRECTLY FROM EIGENVALUE PROBLEM
      ETOT(0) = E0(IOCC)
      EPOS(0) = E0(IOCC)
C
      IF(NORD.EQ.0) GOTO 100
C
C**********************************************************************C
C     E^(1) FIRST-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     PERTURBATION ENERGY E^(1) -- DIAGONAL ELEMENTS OF V1
      ETOT(1) = V1(IOCC,IOCC)
      EPOS(1) = V1(IOCC,IOCC)
C
      IF(NORD.EQ.1) GOTO 100
C
C**********************************************************************C
C     E^(2) SECOND-ORDER CORRECTION                                    C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 102
        IF(E0(IOCC).EQ.E0(JOCC)) GOTO 102
C
C       E^(2) SECOND-ORDER TOTAL
        V2 = V1(IOCC,JOCC)*V1(JOCC,IOCC)
        E2 = E0(IOCC)-E0(JOCC)
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(2) = ETOT(2) + V2/E2
C
        IF(JOCC.GT.NSKP) THEN
          EPOS(2) = EPOS(2) + V2/E2
        ENDIF
C
102     CONTINUE
C
      ENDDO
C
      IF(NORD.EQ.2) GOTO 100
C
C**********************************************************************C
C     E^(3) THIRD-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 103
        IF(E0(IOCC).EQ.E0(JOCC)) GOTO 103
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 203
          IF(E0(IOCC).EQ.E0(KOCC)) GOTO 203
C
C         E^(3) [P] THIRD-ORDER PAIR TERM
          V3P = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E3P = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(3) = ETOT(3) + V3P/E3P
C
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(3) = EPOS(3) + V3P/E3P
          ENDIF
C
203       CONTINUE
C          
        ENDDO
C       
C       E^(3) [H] THIRD-ORDER HOLE TERM
        V3H = (V1(IOCC,JOCC)**2)
        E3H = (E0(IOCC)-E0(JOCC))**2
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(4) = ETOT(4) - ETOT(1)*V3H/E3H
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(4) = EPOS(4) - EPOS(1)*V3H/E3H
        ENDIF
C
103     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(3)
      ETOT(5) = ETOT(3)+ETOT(4)
      EPOS(5) = EPOS(3)+EPOS(4)
C
      IF(NORD.EQ.3) GOTO 100
C
C**********************************************************************C
C     E^(4) FOURTH-ORDER CORRECTION                                    C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 104
        IF(E0(IOCC).EQ.E0(JOCC)) GOTO 104
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 204
          IF(E0(IOCC).EQ.E0(KOCC)) GOTO 204
C
C         LOOP OVER STATES
          DO LOCC=1,NDIM
C
C           SELF-ENERGIES NOT INCLUDED
            IF(IOCC.EQ.LOCC) GOTO 304
            IF(E0(IOCC).EQ.E0(LOCC)) GOTO 304
C
C           E^(4) [PP] FOURTH-ORDER PAIR-PAIR TERM
            V4PP = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,LOCC)
     &                                        *V1(LOCC,IOCC)
            E4PP = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &                                *(E0(IOCC)-E0(LOCC))
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(6) = ETOT(6) + V4PP/E4PP
C
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(6) = EPOS(6) + V4PP/E4PP
            ENDIF
C
304         CONTINUE
C
          ENDDO
C
C         E^(4) [PH] FOURTH-ORDER PAIR-HOLE TERM
          V4PH = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E4PH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(7) = ETOT(7) - 2.0D0*ETOT(1)*V4PH/E4PH
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(7) = EPOS(7) - 2.0D0*EPOS(1)*V4PH/E4PH
          ENDIF
C
204       CONTINUE
C          
        ENDDO
C       
C       E^(4) [HH] FOURTH-ORDER HOLE-HOLE TERM
        V4HH = V1(IOCC,JOCC)*V1(JOCC,IOCC)
        E4HH = (E0(IOCC)-E0(JOCC))**3
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(8) = ETOT(8) + (ETOT(1)**2)*V4HH/E4HH
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(8) = EPOS(8) + (EPOS(1)**2)*V4HH/E4HH
        ENDIF
C       
C       E^(4) [R1+R2] FOURTH-ORDER RESOLVANT-RESOLVANT TERM
        V4RR = V1(IOCC,JOCC)**2
        E4RR = (E0(IOCC)-E0(JOCC))**2
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(9) = ETOT(9) - ETOT(2)*V4RR/E4RR
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(9) = EPOS(9) - EPOS(2)*V4RR/E4RR
        ENDIF
C
104     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(4)
      ETOT(10) = ETOT(6)+ETOT(7)+ETOT(8)+ETOT(9)
      EPOS(10) = EPOS(6)+EPOS(7)+EPOS(8)+EPOS(9)
C
      IF(NORD.EQ.4) GOTO 100
C
C**********************************************************************C
C     E^(5) FIFTH-ORDER CORRECTION                                     C
C**********************************************************************C
C
C     LOOP OVER STATES
      DO JOCC=1,NDIM
C
C       SELF-ENERGIES NOT INCLUDED
        IF(IOCC.EQ.JOCC) GOTO 105
        IF(E0(IOCC).EQ.E0(JOCC)) GOTO 105
C
C       LOOP OVER STATES
        DO KOCC=1,NDIM
C
C         SELF-ENERGIES NOT INCLUDED
          IF(IOCC.EQ.KOCC) GOTO 205
          IF(E0(IOCC).EQ.E0(KOCC)) GOTO 205
C
C         LOOP OVER STATES
          DO LOCC=1,NDIM
C
C           SELF-ENERGIES NOT INCLUDED
            IF(IOCC.EQ.LOCC) GOTO 305
            IF(E0(IOCC).EQ.E0(LOCC)) GOTO 305
C
C           LOOP OVER STATES
            DO MOCC=1,NDIM
C
C             SELF-ENERGIES NOT INCLUDED
              IF(IOCC.EQ.MOCC) GOTO 405
              IF(E0(IOCC).EQ.E0(MOCC)) GOTO 405
C
C             E^(5) [PPP] FIFTH-ORDER PAIR-PAIR-PAIR TERM
              V5PPP = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,LOCC)
     &                             *V1(LOCC,MOCC)*V1(MOCC,IOCC)
              E5PPP = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &               *(E0(IOCC)-E0(LOCC))*(E0(IOCC)-E0(MOCC))
C
C             CONTRIBUTIONS TO ENERGY TERM
              ETOT(11) = ETOT(11) + V5PPP/E5PPP
C
              IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP
     &                                        .AND.MOCC.GT.NSKP) THEN
                EPOS(11) = EPOS(11) + V5PPP/E5PPP
              ENDIF
C
405           CONTINUE
C
            ENDDO
C
C           E^(5) [PPH] FIFTH-ORDER PAIR-PAIR-HOLE TERM
            V5PPH = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,LOCC)
     &                                         *V1(LOCC,IOCC)
            E5PPH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(LOCC))
     &                                 *(E0(IOCC)-E0(JOCC))**2
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(12) = ETOT(12) - 3.0D0*ETOT(1)*V5PPH/E5PPH
C          
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(12) = EPOS(12) - 3.0D0*EPOS(1)*V5PPH/E5PPH
            ENDIF
C
C           E^(5) [??C] FIFTH-ORDER TERM
            V5C = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,LOCC)
     &                                      *(V1(LOCC,IOCC)**2)
            E5C = (E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC))
     &                               *(E0(IOCC)-E0(LOCC))**2
C
C           CONTRIBUTIONS TO ENERGY TERM
            ETOT(17) = ETOT(17) - V5C/E5C
C          
            IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP.AND.LOCC.GT.NSKP) THEN
              EPOS(17) = EPOS(17) - V5C/E5C
            ENDIF
C
305         CONTINUE
C
          ENDDO
C
C         E^(5) [PHH] FIFTH-ORDER PAIR-HOLE-HOLE TERM
          V5PHH = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E5PHH = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**3
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(13) = ETOT(13) + 2.0D0*(ETOT(1)**2)*V5PHH/E5PHH
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(13) = EPOS(13) + 2.0D0*(EPOS(1)**2)*V5PHH/E5PHH
          ENDIF
C       
C         E^(5) [??A] FIFTH-ORDER FIRST EXCHANGE TERM
          V5A = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E5A = (E0(IOCC)-E0(KOCC))*(E0(IOCC)-E0(JOCC))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(15) = ETOT(15) - 2.0D0*ETOT(2)*V5A/E5A
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(15) = EPOS(15) - 2.0D0*EPOS(2)*V5A/E5A
          ENDIF
C       
C         E^(5) [??B] FIFTH-ORDER SECOND EXCHANGE TERM
          V5B = V1(IOCC,JOCC)*V1(JOCC,KOCC)*V1(KOCC,IOCC)
          E5B = ((E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC)))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(16) = ETOT(16) + (ETOT(1)**2)*V5B/E5B
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(16) = EPOS(16) + (EPOS(1)**2)*V5B/E5B
          ENDIF
C       
C         E^(5) [??D] FIFTH-ORDER TERM
          V5D = (V1(IOCC,JOCC)*V1(KOCC,IOCC))**2
          E5D = ((E0(IOCC)-E0(JOCC))*(E0(IOCC)-E0(KOCC)))**2
C
C         CONTRIBUTIONS TO ENERGY TERM
          ETOT(18) = ETOT(18) - 2.0D0*ETOT(1)*V5D/E5D
C          
          IF(JOCC.GT.NSKP.AND.KOCC.GT.NSKP) THEN
            EPOS(18) = EPOS(18) - 2.0D0*EPOS(1)*V5D/E5D
          ENDIF
C
205       CONTINUE
C          
        ENDDO
C       
C       E^(5) [HHH] FIFTH-ORDER HOLE-HOLE-HOLE TERM
        V5HHH = V1(IOCC,JOCC)**2
        E5HHH = (E0(IOCC)-E0(JOCC))**4
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(14) = ETOT(14) - (ETOT(1)**3)*V5HHH/E5HHH
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(14) = EPOS(14) - (EPOS(1)**3)*V5HHH/E5HHH
        ENDIF
C       
C       E^(5) [??E] FIFTH-ORDER TERM
        V5E = V1(IOCC,JOCC)**2
        E5E = (E0(IOCC)-E0(JOCC))**3
C
C       CONTRIBUTIONS TO ENERGY TERM
        ETOT(19) = ETOT(19) - 4.0D0*ETOT(1)*ETOT(2)*V5E/E5E
C          
        IF(JOCC.GT.NSKP) THEN
          EPOS(19) = EPOS(19) - 4.0D0*EPOS(1)*EPOS(2)*V5E/E5E
        ENDIF
C
105     CONTINUE
C
      ENDDO
C
C     TOTAL PERTURBATION ENERGY E^(5)
      ETOT(20) = ETOT(11)+ETOT(12)+ETOT(13)+ETOT(14)+ETOT(15)
     &                   +ETOT(16)+ETOT(17)+ETOT(18)+ETOT(19)
      EPOS(20) = EPOS(11)+EPOS(12)+EPOS(13)+EPOS(14)+EPOS(15)
     &                   +EPOS(16)+EPOS(17)+EPOS(18)+EPOS(19)
C
      IF(NORD.EQ.5) GOTO 100
C
C**********************************************************************C
C     END OF CORRECTION CALCULATION                                    C
C**********************************************************************C
C
100   CONTINUE
C
C     ADD TOTAL ENERGIES TO THE FINAL ENTRY
      EPOS(21) = EPOS(0)+EPOS(1)+EPOS(2)+EPOS(5)+EPOS(10)+EPOS(20)
      ETOT(21) = ETOT(0)+ETOT(1)+ETOT(2)+ETOT(5)+ETOT(10)+ETOT(20)
C
C     NEGATIVE-ENERGY CONTRIBUTIONS ARE SIMPLY A DIFFERENCE
      DO I=0,21
        ENEG(I) = ETOT(I)-EPOS(I)
      ENDDO
C
C**********************************************************************C
C     WRITE RESULTS                                                    C
C**********************************************************************C
C
      IF(IWRT.EQ.0) GOTO 70
C
41    FORMAT(1X,A,15X,A,14X,A,14X,A)
42    FORMAT(1X,A,3X,F18.12,2X,F18.12,2X,F18.12)
      WRITE(6,41) 'E^(N)     |','E[pos]','E[neg]','E[tot]'
      WRITE(7,41) 'E^(N)     |','E[pos]','E[neg]','E[tot]'
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      WRITE(7,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      IF(NORD.EQ.0) GOTO 50
      WRITE(6,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      WRITE(7,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      IF(NORD.EQ.1) GOTO 50
      WRITE(6,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      WRITE(7,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      IF(NORD.EQ.2) GOTO 50
      WRITE(6,42) 'E^(3)[P]  |',EPOS( 3),ENEG( 3),ETOT( 3)
      WRITE(7,42) 'E^(3)[P]  |',EPOS( 3),ENEG( 3),ETOT( 3)
      WRITE(6,42) 'E^(3)[H]  |',EPOS( 4),ENEG( 4),ETOT( 4)
      WRITE(7,42) 'E^(3)[H]  |',EPOS( 4),ENEG( 4),ETOT( 4)
      IF(NORD.EQ.3) GOTO 50
      WRITE(6,42) 'E^(4)[PP] |',EPOS( 6),ENEG( 6),ETOT( 6)
      WRITE(7,42) 'E^(4)[PP] |',EPOS( 6),ENEG( 6),ETOT( 6)
      WRITE(6,42) 'E^(4)[PH] |',EPOS( 7),ENEG( 7),ETOT( 7)
      WRITE(7,42) 'E^(4)[PH] |',EPOS( 7),ENEG( 7),ETOT( 7)
      WRITE(6,42) 'E^(4)[HH] |',EPOS( 8),ENEG( 8),ETOT( 8)
      WRITE(7,42) 'E^(4)[HH] |',EPOS( 8),ENEG( 8),ETOT( 8)
      WRITE(6,42) 'E^(4)[RR] |',EPOS( 9),ENEG( 9),ETOT( 9)
      WRITE(7,42) 'E^(4)[RR] |',EPOS( 9),ENEG( 9),ETOT( 9)
      IF(NORD.EQ.4) GOTO 50
      WRITE(6,42) 'E^(5)[PPP]|',EPOS(11),ENEG(11),ETOT(11)
      WRITE(7,42) 'E^(5)[PPP]|',EPOS(11),ENEG(11),ETOT(11)
      WRITE(6,42) 'E^(5)[PPH]|',EPOS(12),ENEG(12),ETOT(12)
      WRITE(7,42) 'E^(5)[PPH]|',EPOS(12),ENEG(12),ETOT(12)
      WRITE(6,42) 'E^(5)[PHH]|',EPOS(13),ENEG(13),ETOT(13)
      WRITE(7,42) 'E^(5)[PHH]|',EPOS(13),ENEG(13),ETOT(13)
      WRITE(6,42) 'E^(5)[HHH]|',EPOS(14),ENEG(14),ETOT(14)
      WRITE(7,42) 'E^(5)[HHH]|',EPOS(14),ENEG(14),ETOT(14)
      WRITE(6,42) 'E^(5)[??A]|',EPOS(15),ENEG(15),ETOT(15)
      WRITE(7,42) 'E^(5)[??A]|',EPOS(15),ENEG(15),ETOT(15)
      WRITE(6,42) 'E^(5)[??B]|',EPOS(16),ENEG(16),ETOT(16)
      WRITE(7,42) 'E^(5)[??B]|',EPOS(16),ENEG(16),ETOT(16)
      WRITE(6,42) 'E^(5)[??C]|',EPOS(17),ENEG(17),ETOT(17)
      WRITE(7,42) 'E^(5)[??C]|',EPOS(17),ENEG(17),ETOT(17)
      WRITE(6,42) 'E^(5)[??D]|',EPOS(18),ENEG(18),ETOT(18)
      WRITE(7,42) 'E^(5)[??D]|',EPOS(18),ENEG(18),ETOT(18)
      WRITE(6,42) 'E^(5)[??E]|',EPOS(19),ENEG(19),ETOT(19)
      WRITE(7,42) 'E^(5)[??E]|',EPOS(19),ENEG(19),ETOT(19)
      IF(NORD.EQ.5) GOTO 50
50    CONTINUE
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      WRITE(7,42) 'E^(0)     |',EPOS( 0),ENEG( 0),ETOT( 0)
      IF(NORD.EQ.0) GOTO 60
      WRITE(6,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      WRITE(7,42) 'E^(1)     |',EPOS( 1),ENEG( 1),ETOT( 1)
      IF(NORD.EQ.1) GOTO 60
      WRITE(6,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      WRITE(7,42) 'E^(2)     |',EPOS( 2),ENEG( 2),ETOT( 2)
      IF(NORD.EQ.2) GOTO 60
      WRITE(6,42) 'E^(3)     |',EPOS( 5),ENEG( 5),ETOT( 5)
      WRITE(7,42) 'E^(3)     |',EPOS( 5),ENEG( 5),ETOT( 5)
      IF(NORD.EQ.3) GOTO 60
      WRITE(6,42) 'E^(4)     |',EPOS(10),ENEG(10),ETOT(10)
      WRITE(7,42) 'E^(4)     |',EPOS(10),ENEG(10),ETOT(10)
      IF(NORD.EQ.4) GOTO 60
      WRITE(6,42) 'E^(5)     |',EPOS(20),ENEG(20),ETOT(20)
      WRITE(7,42) 'E^(5)     |',EPOS(20),ENEG(20),ETOT(20)
      IF(NORD.EQ.5) GOTO 60
60    CONTINUE
      WRITE(6, *)  REPEAT('-',72)
      WRITE(7, *)  REPEAT('-',72)
      WRITE(6,42) 'Energy    |',EPOS(21),ENEG(21),ETOT(21)
      WRITE(7,42) 'Energy    |',EPOS(21),ENEG(21),ETOT(21)
C
70    CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE MULLIKN(IVIR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM UU    UU LL       LL       IIII KK    KK NN    NN    C
C     MMM     MMM UU    UU LL       LL        II  KK   KK  NNN   NN    C
C     MMMM   MMMM UU    UU LL       LL        II  KK  KK   NNNN  NN    C
C     MM MM MM MM UU    UU LL       LL        II  KKKKK    NN NN NN    C
C     MM  MMM  MM UU    UU LL       LL        II  KK  KK   NN  NNNN    C
C     MM   M   MM UU    UU LL       LL        II  KK   KK  NN   NNN    C
C     MM       MM  UUUUUU  LLLLLLLL LLLLLLLL IIII KK    KK NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  MULLIKN CALCULATES A MULLIKEN POPULATION ANALYSIS ON A DIATOMIC     C
C  SYSTEM, AS DESCRIBED IN:                                            C
C  (*) J.Chem.Phys., 23: 1833, 1841, 2338, 2343 (1955).                C
C  (*) J.Chem.Phys., 36: 3428 (1962).                                  C
C -------------------------------------------------------------------- C
C  CONTRIBUTIONS FOR EACH ORBITAL ARE GROUPED BY ATOMIC CENTRE, KQN    C
C  SYMMETRY AND MQN. ANY CHARGE DENSITY OTHER THAN THIS IS IN 'BRD'.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    IVIR - NUMBER OF VIRTUAL ORBITALS TO INCLUDE IN LIST.             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*2 ELMT(120),ELA
      CHARACTER*4 HMLT
C
      DIMENSION FRC(MDM,MCT,MKP,(MKP+1)/2,3)
      DIMENSION BRD(MDM,3),TOT(MDM,3),RHO(MCT,3)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/MDLV/ELMT
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/QNMS/LABICN(MDM),LABKQN(MDM),LABMQN(MDM)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE COUNTER MATRICES
      DO IOCC=1,NOCC+IVIR
        DO ICNT=1,NCNT
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            NMV  = IABS(IKQN)
            DO IMV=1,NMV
              DO IT=1,3
                FRC(IOCC,ICNT,IKAP,IMV,IT) = 0.0D0
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        DO IT=1,3
          BRD(IOCC,IT) = 0.0D0
          TOT(IOCC,IT) = 0.0D0
        ENDDO
      ENDDO
      DO ICNT=1,NCNT
        DO IT=1,3
          RHO(ICNT,IT) = 0.0D0
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRICES (ZEROTH MOMENT)
      CALL VMOMNT0(OLAPLL,1,0,1,2)
      CALL VMOMNT0(OLAPSS,4,0,1,2)
C
C     LOOP OVER OCCUPIED ORBITALS
      DO IOCC=1,NOCC+IVIR
C
C       IGNORE NEGATIVE SPECTRUM
        MOCC = IOCC+NSKP
C
C       LOOP OVER FOCK MATRIX ADDRESS BLOCKS
        DO I=1,NDIM-NSKP
          K    = I+NSKP
          ICNT = LABICN(I)
          IKQN = LABKQN(I)
          IMQN = IABS(LABMQN(I))
          IF(IKQN.LT.0) THEN
            IKAP =-2*IKQN-1
          ELSE
            IKAP = 2*IKQN
          ENDIF
          IMV = (IMQN+1)/2
          DO J=1,NDIM-NSKP
            L    = J+NSKP
            JCNT = LABICN(J)
            JKQN = LABKQN(J)
            JMQN = IABS(LABMQN(J))
C
C           LARGE AND SMALL CONTRIBUTIONS
            EL = DREAL(DCONJG(COEF(I,MOCC))*COEF(J,MOCC)*OLAPLL(I,J))
            IF(HMLT.NE.'NORL') THEN
              ES = DREAL(DCONJG(COEF(K,MOCC))*COEF(L,MOCC)*OLAPSS(I,J))
            ELSE
              ES = 0.0D0
            ENDIF
C
C           UPDATE CHARGE ON CENTRE ICNT (OCCUPIED ORBITALS ONLY)
            IF(IOCC.LE.NOCC) THEN
              RHO(ICNT,1) = RHO(ICNT,1) + EL
              RHO(ICNT,2) = RHO(ICNT,2) + ES
              RHO(ICNT,3) = RHO(ICNT,3) + EL + ES
            ENDIF

C           DECIDE WHERE TO PUT CONTRIBUTION
            IF(ICNT.EQ.JCNT.AND.IKQN.EQ.JKQN.AND.IMQN.EQ.JMQN) THEN
              FRC(IOCC,ICNT,IKAP,IMV,1) = FRC(IOCC,ICNT,IKAP,IMV,1)+EL
              FRC(IOCC,ICNT,IKAP,IMV,2) = FRC(IOCC,ICNT,IKAP,IMV,2)+ES
              FRC(IOCC,ICNT,IKAP,IMV,3) = FRC(IOCC,ICNT,IKAP,IMV,1)
     &                                  + FRC(IOCC,ICNT,IKAP,IMV,2)
            ELSE
              BRD(IOCC,1) = BRD(IOCC,1) + EL
              BRD(IOCC,2) = BRD(IOCC,2) + ES
              BRD(IOCC,3) = BRD(IOCC,3) + EL + ES
            ENDIF
C
          ENDDO
C
        ENDDO
C
C       TOTAL OCCUPANCIES
        DO ICNT=1,NCNT
            DO IKAP=1,NKAP(ICNT)
              IKQN = KAPA(IKAP,ICNT)
              NMV  = IABS(IKQN)
              DO IMV=1,NMV
                TOT(IOCC,1) = TOT(IOCC,1) + FRC(IOCC,ICNT,IKAP,IMV,1)
                TOT(IOCC,2) = TOT(IOCC,2) + FRC(IOCC,ICNT,IKAP,IMV,2)
                TOT(IOCC,3) = TOT(IOCC,3) + FRC(IOCC,ICNT,IKAP,IMV,3)
              ENDDO
            ENDDO
        ENDDO
        TOT(IOCC,1) = TOT(IOCC,1) + BRD(IOCC,1)
        TOT(IOCC,2) = TOT(IOCC,2) + BRD(IOCC,2)
        TOT(IOCC,3) = TOT(IOCC,3) + BRD(IOCC,3)
C
C     END LOOP OVER OCCUPIED ORBITALS
      ENDDO
C
C     RESULTS: CHARGES ON EACH CENTRE
20    FORMAT(1X,'Total charge on centre ',I2,' = ',F15.10)
21    FORMAT(1X,'Total charge on molecule  = ',F15.10)
      WRITE(6, *) 'Mulliken population analysis:'
      WRITE(7, *) 'Mulliken population analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      SUM = 0.0D0
      DO ICNT=1,NCNT
        WRITE(6,20) ICNT,ZNUC(ICNT)-RHO(ICNT,3)
        WRITE(7,20) ICNT,ZNUC(ICNT)-RHO(ICNT,3)
        SUM = SUM + ZNUC(ICNT)-RHO(ICNT,3)
      ENDDO
      WRITE(6,21) SUM
      WRITE(7,21) SUM
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     RESULTS: DIRAC BASIS DECOMPOSITION FOR EACH ORBITAL
22    FORMAT(' Orb.',2X,'Cent.',2X,'KQN',3X,'|MQN|',10X,
     &                                   'Q(L)',13X,'Q(S)',11X,'Q(TOT)')
23    FORMAT(1X,I3,2X,I2,'(',A,')',3X,I2,3X,I2,'/2',4X,F11.8,6X,
     &                                                   F11.8,6X,F11.8)
24    FORMAT(1X,I3,3X,I2,'(',A,')',2X,I2,3X,I2,'/2',4X,F11.8,6X,
     &                                                   F11.8,6X,F11.8)
25    FORMAT(1X,I3,3X,A ,15X,F11.8,6X,F11.8,6X,F11.8)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6,22)
      WRITE(7,22)
      DO IOCC=1,NOCC+IVIR
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        IF(IOCC.EQ.NOCC+1) THEN
          WRITE(6, *) 'Virtual orbitals (not actually occupied):'
          WRITE(7, *) 'Virtual orbitals (not actually occupied):'
          WRITE(6, *) REPEAT('-',72)
          WRITE(7, *) REPEAT('-',72)
        ENDIF
        DO ICNT=1,NCNT
          ELA = ELMT(IZNC(ICNT))
          DO IKAP=1,NKAP(ICNT)
            IKQN = KAPA(IKAP,ICNT)
            NMV  = IABS(IKQN)
            DO IMV=1,NMV
              IF(FRC(IOCC,ICNT,IKAP,IMV,3).GT.1.0D-9) THEN
                IF(NCNT.LT.10) THEN
                  WRITE(6,23) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                  WRITE(7,23) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                ELSE
                  WRITE(6,24) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                  WRITE(7,24) IOCC,ICNT,ELA,KAPA(IKAP,ICNT),2*IMV-1,
     &                               (FRC(IOCC,ICNT,IKAP,IMV,IT),IT=1,3)
                ENDIF
              ENDIF
            ENDDO
          ENDDO
        ENDDO
        WRITE(6,25) IOCC,'Polar.',(BRD(IOCC,IT),IT=1,3)
        WRITE(7,25) IOCC,'Polar.',(BRD(IOCC,IT),IT=1,3)
        WRITE(6, *) REPEAT('-',72)
        WRITE(7, *) REPEAT('-',72)
        WRITE(6,25) IOCC,'Total ',(TOT(IOCC,IT),IT=1,3)
        WRITE(7,25) IOCC,'Total ',(TOT(IOCC,IT),IT=1,3)
      ENDDO
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ORTHGNL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     OOOOOO  RRRRRRR TTTTTTTT HH    HH  GGGGGG  NN    NN LL           C
C    OO    OO RR    RR   TT    HH    HH GG    GG NNN   NN LL           C
C    OO    OO RR    RR   TT    HH    HH GG       NNNN  NN LL           C
C    OO    OO RR    RR   TT    HHHHHHHH GG       NN NN NN LL           C
C    OO    OO RRRRRRR    TT    HH    HH GG   GGG NN  NNNN LL           C
C    OO    OO RR    RR   TT    HH    HH GG    GG NN   NNN LL           C
C     OOOOOO  RR    RR   TT    HH    HH  GGGGGG  NN    NN LLLLLLLL     C
C                                                                      C
C -------------------------------------------------------------------- C
C  ORTHGNL PERFORMS A MOLECULAR ORTHOGONALITY ANALYSIS.                C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VMOMNT0(OLAPLL,1,0,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT0(OLAPSS,4,0,1,2)
      ENDIF
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
      WRITE(6, *) 'Direct overlap analysis:'
      WRITE(7, *) 'Direct overlap analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Occupation number = ',DREAL(E1(5))
      WRITE(7,20) 'Occupation number = ',DREAL(E1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCMNPL_V1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCMNPL_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON V1
          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 4
C
40    FORMAT(1X,A,I3)
      WRITE(6,40) 'Goldstone diagram values for IOCC = ',IOCC
      WRITE(7,40) 'Goldstone diagram values for IOCC = ',IOCC
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO V1
      CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ELCDIPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       EEEEEEEE LL       CCCCCC  DDDDDDD IIII PPPPPPP  LL             C
C       EE       LL      CC    CC DD    DD II  PP    PP LL             C
C       EE       LL      CC       DD    DD II  PP    PP LL             C
C       EEEEEE   LL      CC       DD    DD II  PP    PP LL             C
C       EE       LL      CC       DD    DD II  PPPPPPP  LL             C
C       EE       LL      CC    CC DD    DD II  PP       LL             C
C       EEEEEEEE LLLLLLLL CCCCCC  DDDDDDD IIII PP       LLLLLLLL       C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCDIPL CALCULATES THE PERMANENT ELECTRIC DIPOLE MOMENT OF THE      C
C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION ZCNT(3),ECNT(3),QCNT(3),ORIG(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 SUMLL,SUMSS
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM),
     &           EMPTY(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     DEFINE ORIGIN VECTOR
      DO IX=1,3
        ORIG(IX) = 0.0D0
      ENDDO
C
C**********************************************************************C
C     CENTRE OF CHARGE COORDINATES                                     C
C**********************************************************************C
C
C     NET NUCLEAR CHARGE
      ZTOT = 0.0D0
      DO ICNT=1,NCNT
        ZTOT = ZTOT + ZNUC(ICNT)
      ENDDO
C
C     CENTRE OF NUCLEAR CHARGE
      DO IX=1,3
        ZCNT(IX) = 0.0D0
        DO ICNT=1,NCNT
          ZCNT(IX) = ZCNT(IX)+ZNUC(ICNT)*BXYZ(IX,ICNT)
        ENDDO
        ZCNT(IX) = ZCNT(IX)/ZTOT
      ENDDO
C
C     FIRST MOMENT INTEGRALS: X DIRECTION
      CALL VMOMNT1(DXLL,ORIG,1,0,1,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DXSS,ORIG,4,0,1,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: X DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DXLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DXSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(1) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     FIRST MOMENT INTEGRALS: Y DIRECTION
      CALL VMOMNT1(DYLL,ORIG,1,0,2,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DYSS,ORIG,4,0,2,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: Y DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DYLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DYSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(2) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     FIRST MOMENT INTEGRALS: Z DIRECTION
      CALL VMOMNT1(DZLL,ORIG,1,0,3,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DZSS,ORIG,4,0,3,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: Z DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DZLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DZSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(3) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     MOLECULAR CENTRE OF CHARGE (<X>,<Y>,<Z>)
      QTOT = ZTOT+DFLOAT(NOCC)
      DO IX=1,3
        QCNT(IX) = (ZTOT*ZCNT(IX)+NOCC*ECNT(IX))/QTOT
      ENDDO
C
C     PRINT CENTRE OF NUCLEAR CHARGE TO TERMINAL
      WRITE(6, *) 'Centre of nuclear/electron/total mass:'
      WRITE(7, *) 'Centre of nuclear/electron/total mass:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
10    FORMAT(1X,A,' = (',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
      WRITE(7,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
      WRITE(6,10) 'E(IX)',(ECNT(IX),IX=1,3)
      WRITE(7,10) 'E(IX)',(ECNT(IX),IX=1,3)
      WRITE(6,10) 'Q(IX)',(QCNT(IX),IX=1,3)
      WRITE(7,10) 'Q(IX)',(QCNT(IX),IX=1,3)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,DXLL,EMPTY,EMPTY,DXSS)
      CALL PROPRTY(EY1,DYLL,EMPTY,EMPTY,DYSS)
      CALL PROPRTY(EZ1,DZLL,EMPTY,EMPTY,DZSS)
C
      WRITE(6, *) 'Molecular electric dipole moment (e.a_{0}):'
      WRITE(7, *) 'Molecular electric dipole moment (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'd_{e} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'd_{e} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     ATOMIC UNITS TO DEBYE CONVERSION: 1 DEBYE = 0.393430307 e.a_0
      DEBYE = 1.0D0/0.393430307D0
      WRITE(6, *) 'Molecular electric dipole moment (debye):'
      WRITE(7, *) 'Molecular electric dipole moment (debye):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      DX1R = DEBYE*DREAL(EX1(5))
      DY1R = DEBYE*DREAL(EY1(5))
      DZ1R = DEBYE*DREAL(EZ1(5))
C
      WRITE(6,20) 'd_{e} = ',DX1R,DY1R,DZ1R
      WRITE(7,20) 'd_{e} = ',DX1R,DY1R,DZ1R
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(7X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,DXLL,EMPTY,EMPTY,DXSS,NORD)
      CALL RSPT1(VY1,DYLL,EMPTY,EMPTY,DYSS,NORD)
      CALL RSPT1(VZ1,DZLL,EMPTY,EMPTY,DZSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_ELCDIPL_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_ELCDIPL_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_ELCDIPL_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ELCDIPL_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      
C      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 4
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     X-COMPONENT
      WRITE(6,40) IOCC,'X'
      WRITE(7,40) IOCC,'X'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VX1
      CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END X-COMPONENT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     Y-COMPONENT
      WRITE(6,40) IOCC,'Y'
      WRITE(7,40) IOCC,'Y'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VY1
      CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Y-COMPONENT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ELCQDPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    EEEEEEEE LL       CCCCCC   QQQQQQ   DDDDDDD  PPPPPPP  LL          C
C    EE       LL      CC    CC QQ    QQ  DD    DD PP    PP LL          C
C    EE       LL      CC       QQ    QQ  DD    DD PP    PP LL          C
C    EEEEEE   LL      CC       QQ    QQ  DD    DD PP    PP LL          C
C    EE       LL      CC       QQ   QQQ  DD    DD PPPPPPP  LL          C
C    EE       LL      CC    CC QQ    QQ  DD    DD PP       LL          C
C    EEEEEEEE LLLLLLLL CCCCCC   QQQQQQ Q DDDDDDD  PP       LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCQDPL CALCULATES THE PERMANENT ELECTRIC QUADRUPOLE MOMENT OF THE  C
C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
C
      DIMENSION ZCNT(3),ECNT(3),QCNT(3),ORIG(3)
C
      COMPLEX*16 EXX1(5),EYY1(5),EZZ1(5),EXY1(5),EYZ1(5),EXZ1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXLL(MDM,MDM),DYLL(MDM,MDM),DZLL(MDM,MDM),
     &           DXSS(MDM,MDM),DYSS(MDM,MDM),DZSS(MDM,MDM)
      COMPLEX*16 QXXLL(MDM,MDM),QYYLL(MDM,MDM),QZZLL(MDM,MDM),
     &           QXYLL(MDM,MDM),QYZLL(MDM,MDM),QXZLL(MDM,MDM),
     &           QXXSS(MDM,MDM),QYYSS(MDM,MDM),QZZSS(MDM,MDM),
     &           QXYSS(MDM,MDM),QYZSS(MDM,MDM),QXZSS(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     DEFINE ORIGIN VECTOR
      DO IX=1,3
        ORIG(IX) = 0.0D0
      ENDDO
C
C**********************************************************************C
C     CENTRE OF CHARGE COORDINATES                                     C
C**********************************************************************C
C
C     NET NUCLEAR CHARGE
      ZTOT = 0.0D0
      DO ICNT=1,NCNT
        ZTOT = ZTOT + ZNUC(ICNT)
      ENDDO
C
C     CENTRE OF NUCLEAR CHARGE
      DO IX=1,3
        ZCNT(IX) = 0.0D0
        DO ICNT=1,NCNT
          ZCNT(IX) = ZCNT(IX)+ZNUC(ICNT)*BXYZ(IX,ICNT)
        ENDDO
        ZCNT(IX) = ZCNT(IX)/ZTOT
      ENDDO
C
C     FIRST MOMENT INTEGRALS: X DIRECTION
      CALL VMOMNT1(DXLL,ORIG,1,0,1,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DXSS,ORIG,4,0,1,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: X DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DXLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DXSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(1) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     FIRST MOMENT INTEGRALS: Y DIRECTION
      CALL VMOMNT1(DYLL,ORIG,1,0,2,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DYSS,ORIG,4,0,2,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: Y DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DYLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DYSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(2) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     FIRST MOMENT INTEGRALS: Z DIRECTION
      CALL VMOMNT1(DZLL,ORIG,1,0,3,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT1(DZSS,ORIG,4,0,3,1,2)
      ENDIF
C
C     CENTRE OF ELECRON MASS: Z DIRECTION
      SUMLL = DCMPLX(0.0D0,0.0D0)
      SUMSS = DCMPLX(0.0D0,0.0D0)
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SUMLL = SUMLL + DZLL(I,J)*DENT(I,J)
          IF(HMLT.NE.'NORL') THEN
            K = I+NSKP
            L = J+NSKP
            SUMSS = SUMSS + DZSS(I,J)*DENT(K,L)
          ENDIF
        ENDDO
      ENDDO
      ECNT(3) = (SUMLL+SUMSS)/DFLOAT(NOCC)
C
C     MOLECULAR CENTRE OF CHARGE (<X>,<Y>,<Z>)
      QTOT = ZTOT+DFLOAT(NOCC)
      DO IX=1,3
        QCNT(IX) = (ZTOT*ZCNT(IX)+NOCC*ECNT(IX))/QTOT
      ENDDO
C
C     PRINT CENTRE OF NUCLEAR CHARGE TO TERMINAL
      WRITE(6, *) 'Centre of nuclear/electron/total mass:'
      WRITE(7, *) 'Centre of nuclear/electron/total mass:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
10    FORMAT(1X,A,' = (',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
      WRITE(7,10) 'Z(IX)',(ZCNT(IX),IX=1,3)
      WRITE(6,10) 'E(IX)',(ECNT(IX),IX=1,3)
      WRITE(7,10) 'E(IX)',(ECNT(IX),IX=1,3)
      WRITE(6,10) 'Q(IX)',(QCNT(IX),IX=1,3)
      WRITE(7,10) 'Q(IX)',(QCNT(IX),IX=1,3)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     GENERATE SECOND MOMENT OVERLAP INTEGRALS (USE ORIG, NOT ZCNT)
      CALL VMOMNT2(QXXLL,ORIG,ORIG,1,0,1,1,1,2)
      CALL VMOMNT2(QYYLL,ORIG,ORIG,1,0,2,2,1,2)
      CALL VMOMNT2(QZZLL,ORIG,ORIG,1,0,3,3,1,2)
      CALL VMOMNT2(QXYLL,ORIG,ORIG,1,0,1,2,1,2)
      CALL VMOMNT2(QYZLL,ORIG,ORIG,1,0,2,3,1,2)
      CALL VMOMNT2(QXZLL,ORIG,ORIG,1,0,1,3,1,2)
C
      IF(HMLT.NE.'NORL') THEN
        CALL VMOMNT2(QXXSS,ORIG,ORIG,4,0,1,1,1,2)
        CALL VMOMNT2(QYYSS,ORIG,ORIG,4,0,2,2,1,2)
        CALL VMOMNT2(QZZSS,ORIG,ORIG,4,0,3,3,1,2)
        CALL VMOMNT2(QXYSS,ORIG,ORIG,4,0,1,2,1,2)
        CALL VMOMNT2(QYZSS,ORIG,ORIG,4,0,2,3,1,2)
        CALL VMOMNT2(QXZSS,ORIG,ORIG,4,0,1,3,1,2)
      ENDIF
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EXX1,QXXLL,EMPTY,EMPTY,QXXSS)
      CALL PROPRTY(EYY1,QYYLL,EMPTY,EMPTY,QYYSS)
      CALL PROPRTY(EZZ1,QZZLL,EMPTY,EMPTY,QZZSS)
      CALL PROPRTY(EXY1,QXYLL,EMPTY,EMPTY,QXYSS)
      CALL PROPRTY(EYZ1,QYZLL,EMPTY,EMPTY,QYZSS)
      CALL PROPRTY(EXZ1,QXZLL,EMPTY,EMPTY,QXZSS)
C
      WRITE(6, *) 'Molecular electric quadrupole moment (e.a_{0}):'
      WRITE(7, *) 'Molecular electric quadrupole moment (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,' (',F20.14,',',F20.14,',',F20.14,')')
21    FORMAT(9X,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'q_{e} =',DREAL(EXX1(5)),DREAL(EXY1(5)),DREAL(EXZ1(5))
      WRITE(7,20) 'q_{e} =',DREAL(EXX1(5)),DREAL(EXY1(5)),DREAL(EXZ1(5))
      WRITE(6,21)           DREAL(EXY1(5)),DREAL(EYY1(5)),DREAL(EYZ1(5))
      WRITE(7,21)           DREAL(EXY1(5)),DREAL(EYY1(5)),DREAL(EYZ1(5))
      WRITE(6,21)           DREAL(EXZ1(5)),DREAL(EYZ1(5)),DREAL(EZZ1(5))
      WRITE(7,21)           DREAL(EXZ1(5)),DREAL(EYZ1(5)),DREAL(EZZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
C
      RETURN
      END
C
C
      SUBROUTINE MAGDIPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     MM       MM    AA     GGGGGG  DDDDDDD IIII PPPPPPP  LL           C
C     MMM     MMM   AAAA   GG    GG DD    DD II  PP    PP LL           C
C     MMMM   MMMM  AA  AA  GG       DD    DD II  PP    PP LL           C
C     MM MM MM MM AA    AA GG       DD    DD II  PP    PP LL           C
C     MM  MMM  MM AAAAAAAA GG   GGG DD    DD II  PPPPPPP  LL           C
C     MM   M   MM AA    AA GG    GG DD    DD II  PP       LL           C
C     MM       MM AA    AA  GGGGGG  DDDDDDD IIII PP       LLLLLLLL     C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGDIPL CALCULATES THE PERMANENT MAGNETIC DIPOLE MOMENT OF THE      C
C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      DIMENSION ORIG(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
     &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In MAGDIPL: not possible for this Hamiltonian!'
        WRITE(7, *) 'In MAGDIPL: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE FIRST MOMENT BASIS OVERLAP INTEGRALS
      CALL VMOMNT1(DXYLS,ORIG,2,1,2,1,2)
      CALL VMOMNT1(DXZLS,ORIG,2,1,3,1,2)
      CALL VMOMNT1(DYXLS,ORIG,2,2,1,1,2)
      CALL VMOMNT1(DYZLS,ORIG,2,2,3,1,2)
      CALL VMOMNT1(DZXLS,ORIG,2,3,1,1,2)
      CALL VMOMNT1(DZYLS,ORIG,2,3,2,1,2)
C
      CALL VMOMNT1(DXYSL,ORIG,3,1,2,1,2)
      CALL VMOMNT1(DXZSL,ORIG,3,1,3,1,2)
      CALL VMOMNT1(DYXSL,ORIG,3,2,1,1,2)
      CALL VMOMNT1(DYZSL,ORIG,3,2,3,1,2)
      CALL VMOMNT1(DZXSL,ORIG,3,3,1,1,2)
      CALL VMOMNT1(DZYSL,ORIG,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          WXLS(I,J) = 0.5D0*CV*(DZYLS(I,J)-DYZLS(I,J))
          WYLS(I,J) = 0.5D0*CV*(DXZLS(I,J)-DZXLS(I,J))
          WZLS(I,J) = 0.5D0*CV*(DYXLS(I,J)-DXYLS(I,J))
C
C         COMPONENT OVERLAP SL
          WXSL(I,J) = 0.5D0*CV*(DZYSL(I,J)-DYZSL(I,J))
          WYSL(I,J) = 0.5D0*CV*(DXZSL(I,J)-DZXSL(I,J))
          WZSL(I,J) = 0.5D0*CV*(DYXSL(I,J)-DXYSL(I,J))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,EMPTY,WXLS,WXSL,EMPTY)
      CALL PROPRTY(EY1,EMPTY,WYLS,WYSL,EMPTY)
      CALL PROPRTY(EZ1,EMPTY,WZLS,WZSL,EMPTY)
C
      WRITE(6, *) 'Molecular magnetic dipole moment (e.a_{0}):'
      WRITE(7, *) 'Molecular magnetic dipole moment (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'd_{m} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'd_{m} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(7X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,EMPTY,WXLS,WXSL,EMPTY,NORD)
      CALL RSPT1(VY1,EMPTY,WYLS,WYSL,EMPTY,NORD)
      CALL RSPT1(VZ1,EMPTY,WZLS,WZSL,EMPTY,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_MAGDIPL_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_MAGDIPL_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_MAGDIPL_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_MAGDIPL_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,31) IOCC,'X',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) 'Y',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) 'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      
C      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 4
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     X-COMPONENT
      WRITE(6,40) IOCC,'X'
      WRITE(7,40) IOCC,'X'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VX1
      CALL DIAGRMTC(VX1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END X-COMPONENT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     Y-COMPONENT
      WRITE(6,40) IOCC,'Y'
      WRITE(7,40) IOCC,'Y'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VY1
      CALL DIAGRMTC(VY1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Y-COMPONENT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE MAGQDPL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  MM       MM    AA     GGGGGG   QQQQQQ   DDDDDDD  PPPPPPP  LL        C
C  MMM     MMM   AAAA   GG    GG QQ    QQ  DD    DD PP    PP LL        C
C  MMMM   MMMM  AA  AA  GG       QQ    QQ  DD    DD PP    PP LL        C
C  MM MM MM MM AA    AA GG       QQ    QQ  DD    DD PP    PP LL        C
C  MM  MMM  MM AAAAAAAA GG   GGG QQ   QQQ  DD    DD PPPPPPP  LL        C
C  MM   M   MM AA    AA GG    GG QQ    QQ  DD    DD PP       LL        C
C  MM       MM AA    AA  GGGGGG   QQQQQQ Q DDDDDDD  PP       LLLLLLLL  C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGQDPL CALCULATES THE PERMANENT MAGNETIC QUADRUPOLE MOMENT OF THE  C
C  ORBITALS IN A MOLECULE, AS WELL AS THE SYSTEM TOTAL.                C
C -------------------------------------------------------------------- C
C  DFNOTE: THIS IS UNFINISHED, BECAUSE I CAN'T SEEM TO FIND A FORMULA. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
c
      DIMENSION ORIG(3)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 QXYLS(MDM,MDM),QXZLS(MDM,MDM),QYXLS(MDM,MDM),
     &           QYZLS(MDM,MDM),QZXLS(MDM,MDM),QZYLS(MDM,MDM),
     &           QXYSL(MDM,MDM),QXZSL(MDM,MDM),QYXSL(MDM,MDM),
     &           QYZSL(MDM,MDM),QZXSL(MDM,MDM),QZYSL(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/EIGC/COEF
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In MAGQDPL: not possible for this Hamiltonian!'
        WRITE(7, *) 'In MAGQDPL: not possible for this Hamiltonian!'
      ENDIF
C
C     DEFINE ORIGIN VECTOR
      DO IX=1,3
        ORIG(IX) = 0.0D0
      ENDDO
C
C     GENERATE SECOND MOMENT OVERELAP INTEGRALS
      CALL VMOMNT2(QXYLS,ORIG,ORIG,2,1,2,3,1,2)
      CALL VMOMNT2(QXZLS,ORIG,ORIG,2,1,3,2,1,2)
      CALL VMOMNT2(QYXLS,ORIG,ORIG,2,2,1,3,1,2)
      CALL VMOMNT2(QYZLS,ORIG,ORIG,2,2,3,1,1,2)
      CALL VMOMNT2(QZXLS,ORIG,ORIG,2,3,1,2,1,2)
      CALL VMOMNT2(QZYLS,ORIG,ORIG,2,3,2,1,1,2)
C
      CALL VMOMNT2(QXYSL,ORIG,ORIG,3,1,2,3,1,2)
      CALL VMOMNT2(QXZSL,ORIG,ORIG,3,1,3,2,1,2)
      CALL VMOMNT2(QYXSL,ORIG,ORIG,3,2,1,3,1,2)
      CALL VMOMNT2(QYZSL,ORIG,ORIG,3,2,3,1,1,2)
      CALL VMOMNT2(QZXSL,ORIG,ORIG,3,3,1,2,1,2)
      CALL VMOMNT2(QZYSL,ORIG,ORIG,3,3,2,1,1,2)
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) 'MAGQDPL is unfinished.'
      WRITE(7, *) 'MAGQDPL is unfinished.'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE STRKEFF(EFIELD,GAUGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS TTTTTTTT RRRRRRR  KK    KK EEEEEEEE FFFFFFFF FFFFFFFF    C
C     SS    SS   TT    RR    RR KK   KK  EE       FF       FF          C
C     SS         TT    RR    RR KK  KK   EE       FF       FF          C
C      SSSSSS    TT    RR    RR KKKKK    EEEEEE   FFFFFF   FFFFFF      C
C           SS   TT    RRRRRRR  KK  KK   EE       FF       FF          C
C     SS    SS   TT    RR    RR KK   KK  EE       FF       FF          C
C      SSSSSS    TT    RR    RR KK    KK EEEEEEEE FF       FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  STRKEFF PERFORMS A STARK EFFECT ANALYSIS, GIVEN APPLIED ELECTRIC    C
C  FIELD (EX,EY,EZ).                                                   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    EFIELD - UNIFORM ELECTRIC FIELD VECTOR (EX,EY,EZ).                C
C    GAUGE  - GAUGE ORIGIN COORDINATES.                                C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EFIELD(3),GAUGE(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 D0XLL(MDM,MDM),D0YLL(MDM,MDM),D0ZLL(MDM,MDM),
     &           D0XSS(MDM,MDM),D0YSS(MDM,MDM),D0ZSS(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     MATRIX ELEMENT INTEGRALS
      CALL VMOMNT1(D0XLL,GAUGE,1,0,1,1,2)
      CALL VMOMNT1(D0YLL,GAUGE,1,0,2,1,2)
      CALL VMOMNT1(D0ZLL,GAUGE,1,0,3,1,2)
C
      IF(HMLT.EQ.'NORL') THEN
        CALL VMOMNT1(D0XSS,GAUGE,4,0,1,1,2)
        CALL VMOMNT1(D0YSS,GAUGE,4,0,2,1,2)
        CALL VMOMNT1(D0ZSS,GAUGE,4,0,3,1,2)
      ENDIF
C
C     CONSTRUCT ELECTRIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LL
          D0XLL(I,J) =-EFIELD(1)*D0XLL(I,J)
          D0YLL(I,J) =-EFIELD(2)*D0YLL(I,J)
          D0ZLL(I,J) =-EFIELD(3)*D0ZLL(I,J)
C
C         COMPONENT OVERLAP SS
          D0XSS(I,J) =-EFIELD(1)*D0XSS(I,J)
          D0YSS(I,J) =-EFIELD(2)*D0YSS(I,J)
          D0ZSS(I,J) =-EFIELD(3)*D0ZSS(I,J)
C
        ENDDO
      ENDDO
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,D0XLL,EMPTY,EMPTY,D0XSS)
      CALL PROPRTY(EY1,D0YLL,EMPTY,EMPTY,D0YSS)
      CALL PROPRTY(EZ1,D0ZLL,EMPTY,EMPTY,D0ZSS)
C
      WRITE(6, *) 'Stark effect interaction energy (e.a_{0}):'
      WRITE(7, *) 'Stark effect interaction energy (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'E_{S} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'E_{S} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C      GOTO 400
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 2
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,D0XLL,EMPTY,EMPTY,D0XSS,NORD)
      CALL RSPT1(VY1,D0YLL,EMPTY,EMPTY,D0YSS,NORD)
      CALL RSPT1(VZ1,D0ZLL,EMPTY,EMPTY,D0ZSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_STRKEFF_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_STRKEFF_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_STRKEFF_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_STRKEFF_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
400   CONTINUE
C
      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 2
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ZMANEFF(BFIELD,GAUGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   ZZZZZZZZ MM       MM    AA    NN    NN EEEEEEEE FFFFFFFF FFFFFFFF  C
C        ZZ  MMM     MMM   AAAA   NNN   NN EE       FF       FF        C
C       ZZ   MMMM   MMMM  AA  AA  NNNN  NN EE       FF       FF        C
C      ZZ    MM MM MM MM AA    AA NN NN NN EEEEEE   FFFFFF   FFFFFF    C
C     ZZ     MM  MMM  MM AAAAAAAA NN  NNNN EE       FF       FF        C
C    ZZ      MM   M   MM AA    AA NN   NNN EE       FF       FF        C
C   ZZZZZZZZ MM       MM AA    AA NN    NN EEEEEEEE FF       FF        C
C                                                                      C
C -------------------------------------------------------------------- C
C  ZMANEFF PERFORMS A ZEEMAN EFFECT ANALYSIS, GIVEN APPLIED MAGNETIC   C
C  FIELD (BX,BY,BZ).                                                   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    BFIELD - UNIFORM MAGNETIC FIELD VECTOR (BX,BY,BZ).                C
C    GAUGE  - GAUGE ORIGIN COORDINATES.                                C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION BFIELD(3),GAUGE(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
     &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In ZMANEFF: not possible for this Hamiltonian!'
        WRITE(7, *) 'In ZMANEFF: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     MATRIX ELEMENT INTEGRALS
      CALL VMOMNT1(DXYLS,GAUGE,2,1,2,1,2)
      CALL VMOMNT1(DXZLS,GAUGE,2,1,3,1,2)
      CALL VMOMNT1(DYXLS,GAUGE,2,2,1,1,2)
      CALL VMOMNT1(DYZLS,GAUGE,2,2,3,1,2)
      CALL VMOMNT1(DZXLS,GAUGE,2,3,1,1,2)
      CALL VMOMNT1(DZYLS,GAUGE,2,3,2,1,2)
C
      CALL VMOMNT1(DXYSL,GAUGE,3,1,2,1,2)
      CALL VMOMNT1(DXZSL,GAUGE,3,1,3,1,2)
      CALL VMOMNT1(DYXSL,GAUGE,3,2,1,1,2)
      CALL VMOMNT1(DYZSL,GAUGE,3,2,3,1,2)
      CALL VMOMNT1(DZXSL,GAUGE,3,3,1,1,2)
      CALL VMOMNT1(DZYSL,GAUGE,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          WXLS(I,J) =-0.5D0*CV*BFIELD(1)*(DYZLS(I,J)-DZYLS(I,J))
          WYLS(I,J) =-0.5D0*CV*BFIELD(2)*(DZXLS(I,J)-DXZLS(I,J))
          WZLS(I,J) =-0.5D0*CV*BFIELD(3)*(DXYLS(I,J)-DYXLS(I,J))
C
C         COMPONENT OVERLAP SL
          WXSL(I,J) =-0.5D0*CV*BFIELD(1)*(DYZSL(I,J)-DZYSL(I,J))
          WYSL(I,J) =-0.5D0*CV*BFIELD(2)*(DZXSL(I,J)-DXZSL(I,J))
          WZSL(I,J) =-0.5D0*CV*BFIELD(3)*(DXYSL(I,J)-DYXSL(I,J))
C
        ENDDO
      ENDDO
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,EMPTY,WXLS,WXSL,EMPTY)
      CALL PROPRTY(EY1,EMPTY,WYLS,WYSL,EMPTY)
      CALL PROPRTY(EZ1,EMPTY,WZLS,WZSL,EMPTY)
C
      WRITE(6, *) 'Zeeman effect interaction energy (e.a_{0}):'
      WRITE(7, *) 'Zeeman effect interaction energy (e.a_{0}):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'E_{Z} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'E_{Z} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C      GOTO 400
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 2
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,EMPTY,WXLS,WXSL,EMPTY,NORD)
      CALL RSPT1(VY1,EMPTY,WYLS,WYSL,EMPTY,NORD)
      CALL RSPT1(VZ1,EMPTY,WZLS,WZSL,EMPTY,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_ZMANEFF_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_ZMANEFF_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_ZMANEFF_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_ZMANEFF_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
400   CONTINUE
C
      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
C     MAXIMUM PERTURBATIVE ORDER
      NORD = 1
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE HYPFINE(ICNT,GIIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      HH    HH YY    YY PPPPPPP  FFFFFFFF IIII NN    NN EEEEEEEE      C
C      HH    HH YY    YY PP    PP FF        II  NNN   NN EE            C
C      HH    HH YY    YY PP    PP FF        II  NNNN  NN EE            C
C      HHHHHHHH  YY  YY  PP    PP FFFFFF    II  NN NN NN EEEEEE        C
C      HH    HH   YYYY   PPPPPPP  FF        II  NN  NNNN EE            C
C      HH    HH    YY    PP       FF        II  NN   NNN EE            C
C      HH    HH    YY    PP       FF       IIII NN    NN EEEEEEEE      C
C                                                                      C
C -------------------------------------------------------------------- C
C  HYPFINE PERFORMS A HYPERFINE EFFECT ANALYSIS, GIVEN A MAGNETIC      C
C  NUCLEAR MOMENT (ASSUME IT IS ALIGNED IN THE Z-DIRECTION).           C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT - THE NUCLEAR CENTRE WITH A MAGNETIC MOMENT.                 C
C    GIIM - THE MAGNITUDE OF THE NUCLEAR MOMENT, GI*|I|.               C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION RNLOC(3),GII(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 EX1(5),EY1(5),EZ1(5)
      COMPLEX*16 VX1(MDM,MDM),VY1(MDM,MDM),VZ1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 WXLS(MDM,MDM),WYLS(MDM,MDM),WZLS(MDM,MDM),
     &           WXSL(MDM,MDM),WYSL(MDM,MDM),WZSL(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In HYPFINE: not possible for this Hamiltonian!'
        WRITE(7, *) 'In HYPFINE: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOCATION OF NUCLEUS WITH MAGNETIC MOMENT
      DO IX=1,3
        RNLOC(IX) = BXYZ(IX,ICNT)
      ENDDO
C
C     PRE-FACTOR ELEMENTS
      MPR = 1836.153D0
      PRE =-0.5D0/(MPR*CV)
C
C     NUCLEAR MOMENT AS A VECTOR (ORIENTATION OF MOMENT)
      GII(1) = 0.0D0
      GII(2) = 0.0D0
      GII(3) = GIIM
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
C     MATRIX ELEMENT INTEGRALS
      CALL VMNPOLE(DXYLS,RNLOC,2,1,2,1,2)
      CALL VMNPOLE(DXZLS,RNLOC,2,1,3,1,2)
      CALL VMNPOLE(DYXLS,RNLOC,2,2,1,1,2)
      CALL VMNPOLE(DYZLS,RNLOC,2,2,3,1,2)
      CALL VMNPOLE(DZXLS,RNLOC,2,3,1,1,2)
      CALL VMNPOLE(DZYLS,RNLOC,2,3,2,1,2)
C
      CALL VMNPOLE(DXYSL,RNLOC,3,1,2,1,2)
      CALL VMNPOLE(DXZSL,RNLOC,3,1,3,1,2)
      CALL VMNPOLE(DYXSL,RNLOC,3,2,1,1,2)
      CALL VMNPOLE(DYZSL,RNLOC,3,2,3,1,2)
      CALL VMNPOLE(DZXSL,RNLOC,3,3,1,1,2)
      CALL VMNPOLE(DZYSL,RNLOC,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC MOMENT DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          WXLS(I,J) = PRE*GII(1)*(DYZLS(I,J)-DZYLS(I,J))
          WYLS(I,J) = PRE*GII(2)*(DZXLS(I,J)-DXZLS(I,J))
          WZLS(I,J) = PRE*GII(3)*(DXYLS(I,J)-DYXLS(I,J))
C
C         COMPONENT OVERLAP SL
          WXSL(I,J) = PRE*GII(1)*(DYZSL(I,J)-DZYSL(I,J))
          WYSL(I,J) = PRE*GII(2)*(DZXSL(I,J)-DXZSL(I,J))
          WZSL(I,J) = PRE*GII(3)*(DXYSL(I,J)-DYXSL(I,J))
C
        ENDDO
      ENDDO
C
C     CALCULATE MOLECULAR EXPECTATION VALUES -- (X,Y,Z)
      CALL PROPRTY(EX1,EMPTY,WXLS,WXSL,EMPTY)
      CALL PROPRTY(EY1,EMPTY,WYLS,WYSL,EMPTY)
      CALL PROPRTY(EZ1,EMPTY,WZLS,WZSL,EMPTY)
C
      WRITE(6, *) 'Hyperfine effect interaction energy:'
      WRITE(7, *) 'Hyperfine effect interaction energy:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
20    FORMAT(1X,A,'(',F20.14,',',F20.14,',',F20.14,')')
      WRITE(6,20) 'E_{H} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
      WRITE(7,20) 'E_{H} = ',DREAL(EX1(5)),DREAL(EY1(5)),DREAL(EZ1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C      GOTO 400
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,1X,A,11X,A,I1,A,12X,A,I1,A,12X,A,I1,A)
31    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','IX','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                            'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(VX1,EMPTY,WXLS,WXSL,EMPTY,NORD)
      CALL RSPT1(VY1,EMPTY,WYLS,WYSL,EMPTY,NORD)
      CALL RSPT1(VZ1,EMPTY,WZLS,WZSL,EMPTY,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_HYPFINE_VX.dat',STATUS='UNKNOWN')
      OPEN(UNIT=12,FILE=TRIM(OUTFL)//'_HYPFINE_VY.dat',STATUS='UNKNOWN')
      OPEN(UNIT=13,FILE=TRIM(OUTFL)//'_HYPFINE_VZ.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(11, *) (VX1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(12, *) (VY1(IOCC,JOCC),JOCC=1,NDIM)
          WRITE(13, *) (VZ1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=13)
      CLOSE(UNIT=12)
      CLOSE(UNIT=11)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_HYPFINE_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC+2
C
C         DIAGRAMATIC PERTURBATION THEORY ON VX1
          CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,32) IOCC,'Z',EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
400   CONTINUE
C
C      RETURN
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3,
     &                                                 ' with IX = ',A)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC,'Z'
      WRITE(7,40) IOCC,'Z'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(VZ1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
C     END Z-COMPONENT AND SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
500   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE GTENSOR(ICNT,GAUGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     GGGGGG TTTTTTTT EEEEEEEE NN    NN  SSSSSS   OOOOOO  RRRRRRR      C
C    GG    GG   TT    EE       NNN   NN SS    SS OO    OO RR    RR     C
C    GG         TT    EE       NNNN  NN SS       OO    OO RR    RR     C
C    GG         TT    EEEEEE   NN NN NN  SSSSSS  OO    OO RR    RR     C
C    GG   GGG   TT    EE       NN  NNNN       SS OO    OO RRRRRRR      C
C    GG    GG   TT    EE       NN   NNN SS    SS OO    OO RR    RR     C
C     GGGGGG    TT    EEEEEEEE NN    NN  SSSSSS   OOOOOO  RR    RR     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GTENSOR CALCULATES THE MAGNETIC G-TENSOR OF A MOLECULE.             C
C  NOTE: SINCE THE G-TENSOR IS A CROSSING TERM IN SECOND ORDER P.T.    C
C        WITH INTERPRETATIONS FOR THE POSITIVE- AND NEGATIVE-ENERGY    C
C        UNOCCUPIED SPECTRUM, CALCULATIONS HERE ARE DONE EXPLICITLY.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT  - THE NUCLEAR CENTRE WITH A MAGNETIC MOMENT.                C
C    GAUGE - GAUGE ORIGIN COORDINATES - TRY BXYZ(ICNT) TO START.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 BC,HC
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 DXYLS(MDM,MDM),DXZLS(MDM,MDM),DYXLS(MDM,MDM),
     &           DYZLS(MDM,MDM),DZXLS(MDM,MDM),DZYLS(MDM,MDM),
     &           DXYSL(MDM,MDM),DXZSL(MDM,MDM),DYXSL(MDM,MDM),
     &           DYZSL(MDM,MDM),DZXSL(MDM,MDM),DZYSL(MDM,MDM)
      COMPLEX*16 BLS(MDM,MDM,3),BSL(MDM,MDM,3),
     &           HLS(MDM,MDM,3),HSL(MDM,MDM,3)
      COMPLEX*16 VB(MDM,MDM,3),VH(MDM,MDM,3)
      COMPLEX*16 SIGNEG(3,3),SIGPOS(3,3),SIGTOT(3,3)
C
      DIMENSION GAUGE(3),RNLOC(3)
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     LOCATION OF NUCLEUS WITH MAGNETIC MOMENT
      DO IX=1,3
        RNLOC(IX) = BXYZ(IX,ICNT)
      ENDDO
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In GTENSOR: not possible for this Hamiltonian!'
        WRITE(7, *) 'In GTENSOR: not possible for this Hamiltonian!'
      ENDIF
C
C**********************************************************************C
C     PREPARATION OF MATRIX ELEMENTS                                   C
C**********************************************************************C
C
C     FIRST MOMENT MATRIX ELEMENTS
      CALL VMOMNT1(DXYLS,GAUGE,2,1,2,1,2)
      CALL VMOMNT1(DXZLS,GAUGE,2,1,3,1,2)
      CALL VMOMNT1(DYXLS,GAUGE,2,2,1,1,2)
      CALL VMOMNT1(DYZLS,GAUGE,2,2,3,1,2)
      CALL VMOMNT1(DZXLS,GAUGE,2,3,1,1,2)
      CALL VMOMNT1(DZYLS,GAUGE,2,3,2,1,2)
C
      CALL VMOMNT1(DXYSL,GAUGE,3,1,2,1,2)
      CALL VMOMNT1(DXZSL,GAUGE,3,1,3,1,2)
      CALL VMOMNT1(DYXSL,GAUGE,3,2,1,1,2)
      CALL VMOMNT1(DYZSL,GAUGE,3,2,3,1,2)
      CALL VMOMNT1(DZXSL,GAUGE,3,3,1,1,2)
      CALL VMOMNT1(DZYSL,GAUGE,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          BLS(I,J,1) = DYZLS(I,J)-DZYLS(I,J)
          BLS(I,J,2) = DZXLS(I,J)-DXZLS(I,J)
          BLS(I,J,3) = DXYLS(I,J)-DYXLS(I,J)
C
C         COMPONENT OVERLAP SL
          BSL(I,J,1) = DYZSL(I,J)-DZYSL(I,J)
          BSL(I,J,2) = DZXSL(I,J)-DXZSL(I,J)
          BSL(I,J,3) = DXYSL(I,J)-DYXSL(I,J)
C
        ENDDO
      ENDDO
C
C     ELECTRIC MONOPOLE MOMENT MATRIX ELEMENTS
      CALL VMNPOLE(DXYLS,RNLOC,2,1,2,1,2)
      CALL VMNPOLE(DXZLS,RNLOC,2,1,3,1,2)
      CALL VMNPOLE(DYXLS,RNLOC,2,2,1,1,2)
      CALL VMNPOLE(DYZLS,RNLOC,2,2,3,1,2)
      CALL VMNPOLE(DZXLS,RNLOC,2,3,1,1,2)
      CALL VMNPOLE(DZYLS,RNLOC,2,3,2,1,2)
C
      CALL VMNPOLE(DXYSL,RNLOC,3,1,2,1,2)
      CALL VMNPOLE(DXZSL,RNLOC,3,1,3,1,2)
      CALL VMNPOLE(DYXSL,RNLOC,3,2,1,1,2)
      CALL VMNPOLE(DYZSL,RNLOC,3,2,3,1,2)
      CALL VMNPOLE(DZXSL,RNLOC,3,3,1,1,2)
      CALL VMNPOLE(DZYSL,RNLOC,3,3,2,1,2)
C
C     CONSTRUCT MAGNETIC MOMENT DIPOLE MATRIX ELEMENTS
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
C
C         COMPONENT OVERLAP LS
          HLS(I,J,1) = DYZLS(I,J)-DZYLS(I,J)
          HLS(I,J,2) = DZXLS(I,J)-DXZLS(I,J)
          HLS(I,J,3) = DXYLS(I,J)-DYXLS(I,J)
C
C         COMPONENT OVERLAP SL
          HSL(I,J,1) = DYZSL(I,J)-DZYSL(I,J)
          HSL(I,J,2) = DZXSL(I,J)-DXZSL(I,J)
          HSL(I,J,3) = DXYSL(I,J)-DYXSL(I,J)
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     FULL LIST OF FIRST-ORDER TERMS                                   C
C**********************************************************************C
C
C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
      DO IA=1,NDIM
        DO IK=1,NDIM
C
C         MATRIX ELEMENTS REQUIRE (OCC,UNOCC) COMBINATIONS ONLY
          IF(IA.GT.NSKP.AND.IA.LE.(NSKP+NOCC)) THEN
            IAOCC = 1
          ELSE
            IAOCC = 0
          ENDIF
          IF(IK.GT.NSKP.AND.IK.LE.(NSKP+NOCC)) THEN
            IKOCC = 1
          ELSE
            IKOCC = 0
          ENDIF
C
          IF(IAOCC.EQ.IKOCC) GOTO 150
C
C         LOOP OVER CARTESIAN INDEX IX
          DO IX=1,3
C
C           INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
            BC = DCMPLX(0.0D0,0.0D0)
            HC = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER FOCK MATRIX ADDRESSES
            DO I=1,NDIM-NSKP
              DO J=1,NDIM-NSKP
C
                K = I+NSKP
                L = J+NSKP
C
C               ACCOUNT ONLY FOR LS AND SL COMPONENT OVERLAPS
                BC = BC + DCONJG(COEF(I,IA))*COEF(L,IK)*BLS(I,J,IX)
     &                  + DCONJG(COEF(K,IA))*COEF(J,IK)*BSL(I,J,IX)
                HC = HC + DCONJG(COEF(I,IA))*COEF(L,IK)*HLS(I,J,IX)
     &                  + DCONJG(COEF(K,IA))*COEF(J,IK)*HSL(I,J,IX)
C
              ENDDO
            ENDDO
C
C           SAVE COUNTERS TO MATRICES
            VB(IA,IK,IX) = BC
            VH(IA,IK,IX) = HC
C
          ENDDO
C
150       CONTINUE
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF SECOND-ORDER CROSSING TERM, E^(2)_CROSS.          C
C**********************************************************************C
C
C     INITIALISE SIGMA MATRICES
      DO IX=1,3
        DO JX=1,3
          SIGPOS(IX,JX) = DCMPLX(0.0D0,0.0D0)
          SIGNEG(IX,JX) = DCMPLX(0.0D0,0.0D0)
          SIGTOT(IX,JX) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER ALL OCCUPIED ORBITALS IA
      DO IA=NSKP+1,NSKP+NOCC
C
C       EIGENVALUE ENERGY FOR THIS ORBITAL
        EA = EIGN(IA)
C
C       POSITIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E+ STATES
        DO IK=NSKP+NOCC+1,NDIM
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EA-EIGN(IK)
C
C         LOOP OVER CARTESIAN INDICES IX AND JX
          DO IX=1,3
            DO JX=1,3
C
C             CONTRIBUTIONS TO EACH PART OF THE G-TENSOR
              SIGPOS(IX,JX) = SIGPOS(IX,JX)
     &                      +        VB(IA,IK,IX)*VH(IK,IA,JX)/EAK
     &                      + DCONJG(VB(IA,IK,IX)*VH(IK,IA,JX)/EAK)
C
            ENDDO
          ENDDO
C
C       END POSITIVE-ENERGY LOOP
        ENDDO
C
C       NEGATIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E- STATES
        DO IK=1,NSKP
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EA-EIGN(IK)
C
C         LOOP OVER CARTESIAN INDICES IX AND JX
          DO IX=1,3
            DO JX=1,3
C
C             CONTRIBUTIONS TO EACH PART OF THE G-TENSOR
              SIGNEG(IX,JX) = SIGNEG(IX,JX)
     &                      +        VB(IA,IK,IX)*VH(IK,IA,JX)/EAK
     &                      + DCONJG(VB(IA,IK,IX)*VH(IK,IA,JX)/EAK)
C
            ENDDO
          ENDDO
C
C       END NEGATIVE-ENERGY LOOP
        ENDDO
C
C     END LOOP OVER OCCUPIED ORBITALS
      ENDDO
C
C     CONVERT TO NMR TMS REFERENCE FORM (PPM)
      DO IX=1,3
        DO JX=1,3
          SIGPOS(IX,JX) = 0.5D0*1.0D6*SIGPOS(IX,JX)
          SIGNEG(IX,JX) = 0.5D0*1.0D6*SIGNEG(IX,JX)
          SIGTOT(IX,JX) = SIGPOS(IX,JX) + SIGNEG(IX,JX)
        ENDDO
      ENDDO
C
C     SPHERICAL AVERAGE
      DPOS = 0.0D0
      DNEG = 0.0D0
      DTOT = 0.0D0
      DO IX=1,3
        DPOS = DPOS + DREAL(SIGPOS(IX,IX))/3.0D0
        DNEG = DNEG + DREAL(SIGNEG(IX,IX))/3.0D0
        DTOT = DTOT + DREAL(SIGTOT(IX,IX))/3.0D0
      ENDDO
C
20    FORMAT(21X,'(',F16.10,',',F16.10,',',F16.10,')')
21    FORMAT(10X,A,1X,'(',F16.10,',',F16.10,',',F16.10,')')
C
      WRITE(6, *) 'G-tensor analysis:'
      WRITE(7, *) 'G-tensor analysis:'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     SUMMARISE THE TENSOR ELEMENTS
      WRITE(6, *) 'Paramagnetic shielding tensor (ppm au):'
      WRITE(7, *) 'Paramagnetic shielding tensor (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20)              (DREAL(SIGPOS(1,JX)),JX=1,3)
      WRITE(7,20)              (DREAL(SIGPOS(1,JX)),JX=1,3)
      WRITE(6,21) 'sigma(+) =',(DREAL(SIGPOS(2,JX)),JX=1,3)
      WRITE(7,21) 'sigma(+) =',(DREAL(SIGPOS(2,JX)),JX=1,3)
      WRITE(6,20)              (DREAL(SIGPOS(3,JX)),JX=1,3)
      WRITE(7,20)              (DREAL(SIGPOS(3,JX)),JX=1,3)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6, *) 'Diamagnetic shielding tensor (ppm au):'
      WRITE(7, *) 'Diamagnetic shielding tensor (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20)              (DREAL(SIGNEG(1,JX)),JX=1,3)
      WRITE(7,20)              (DREAL(SIGNEG(1,JX)),JX=1,3)
      WRITE(6,21) 'sigma(-) =',(DREAL(SIGNEG(2,JX)),JX=1,3)
      WRITE(7,21) 'sigma(-) =',(DREAL(SIGNEG(2,JX)),JX=1,3)
      WRITE(6,20)              (DREAL(SIGNEG(3,JX)),JX=1,3)
      WRITE(7,20)              (DREAL(SIGNEG(3,JX)),JX=1,3)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      WRITE(6, *) 'Total nuclear magnetic shielding tensor (ppm au):'
      WRITE(7, *) 'Total nuclear magnetic shielding tensor (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,20)              (DREAL(SIGTOT(1,JX)),JX=1,3)
      WRITE(7,20)              (DREAL(SIGTOT(1,JX)),JX=1,3)
      WRITE(6,21) 'sigma(t) =',(DREAL(SIGTOT(2,JX)),JX=1,3)
      WRITE(7,21) 'sigma(t) =',(DREAL(SIGTOT(2,JX)),JX=1,3)
      WRITE(6,20)              (DREAL(SIGTOT(3,JX)),JX=1,3)
      WRITE(7,20)              (DREAL(SIGTOT(3,JX)),JX=1,3)
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
22    FORMAT(8X,'|',6X,A,8X,A,8X,A,2X,'|',7X,A)
23    FORMAT(1X,A,' |',F14.8,2X,F14.8,2X,F14.8,2X,'|',1X,F14.8)
      WRITE(6, *) 'Spherical averages (ppm au):'
      WRITE(7, *) 'Spherical averages (ppm au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'sig_(xx)','sig_(yy)','sig_(zz)','sig(tot)'
      WRITE(7,22) 'sig_(xx)','sig_(yy)','sig_(zz)','sig(tot)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'sig(+)',(DREAL(SIGPOS(IX,IX)),IX=1,3),DPOS
      WRITE(7,23) 'sig(+)',(DREAL(SIGPOS(IX,IX)),IX=1,3),DPOS
      WRITE(6,23) 'sig(-)',(DREAL(SIGNEG(IX,IX)),IX=1,3),DNEG
      WRITE(7,23) 'sig(-)',(DREAL(SIGNEG(IX,IX)),IX=1,3),DNEG
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'sig(t)',(DREAL(SIGTOT(IX,IX)),IX=1,3),DTOT
      WRITE(7,23) 'sig(t)',(DREAL(SIGTOT(IX,IX)),IX=1,3),DTOT
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE EEDMSML(ICNT,IOCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C EEEEEEEE EEEEEEEE DDDDDDD  MM       MM  SSSSSS  MM       MM LL       C
C EE       EE       DD    DD MMM     MMM SS    SS MMM     MMM LL       C
C EE       EE       DD    DD MMMM   MMMM SS       MMMM   MMMM LL       C
C EEEEEE   EEEEEE   DD    DD MM MM MM MM  SSSSSS  MM MM MM MM LL       C
C EE       EE       DD    DD MM  MMM  MM       SS MM  MMM  MM LL       C
C EE       EE       DD    DD MM   M   MM SS    SS MM   M   MM LL       C
C EEEEEEEE EEEEEEEE DDDDDDD  MM       MM  SSSSSS  MM       MM LLLLLLLL C
C                                                                      C
C -------------------------------------------------------------------- C
C  EEDMSML PERFORMS AN ATOM-CENTRED PT-ODD ELECTRON EDM ANALYSIS,      C
C  USING THE SMALL-SMALL OVERLAP AND ELECTRIC FIELD OPERATOR.          C
C  THE DIPOLE MOMENT STRENGTH 'DE' HAS BEEN FACTORED AWAY FROM THIS.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT - THE NUCLEAR CENTRE OF INTEREST.                            C
C    IOCC - THE ORBITAL OF INTEREST.                                   C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION XYZ(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 EFLDX(MDM,MDM),EFLDY(MDM,MDM),EFLDZ(MDM,MDM)
      COMPLEX*16 EFLD(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In EEDMSML: not possible for this Hamiltonian!'
        WRITE(7, *) 'In EEDMSML: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     ADJUST NUCLEAR CHARGE OF CENTRE ICNT
      DO IX=1,3
        XYZ(IX) = BXYZ(IX,ICNT)
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VMNPOLE(EFLDX,XYZ,4,1,1,1,2)
      CALL VMNPOLE(EFLDY,XYZ,4,2,2,1,2)
      CALL VMNPOLE(EFLDZ,XYZ,4,3,3,1,2)
C
C     MULTIPLY RESULTS BY APPROPRIATE FACTOR
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EFLD(I,J) = EFLDX(I,J)+EFLDY(I,J)+EFLDZ(I,J)
          EFLD(I,J) = 2.0D0*ZNUC(ICNT)*EFLD(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,EMPTY,EMPTY,EMPTY,EFLD,NORD)
C
C     MATRIX ELEMENT (WITH |DE| FACTORED OUT) IN HARTEE
      WDAU = V1(NSKP+IOCC,NSKP+IOCC)
C
C     MATRIX ELEMENT IN HERTZ
      WDHZ = WDAU*6.579684D+15 
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_EEDMSML_V.dat',STATUS='UNKNOWN')
      WRITE(11, *) V1(IOCC,IOCC)
      CLOSE(UNIT=11)
C
29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
30    FORMAT(24X,ES17.10,1X,A)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
      WRITE(7,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
      WRITE(6,30)                                WDHZ,'Hz'
      WRITE(7,30)                                WDHZ,'Hz'
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE EEDMEFF(IOCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE EEEEEEEE DDDDDDD  MM       MM EEEEEEEE FFFFFFFF FFFFFFFF  C
C   EE       EE       DD    DD MMM     MMM EE       FF       FF        C
C   EE       EE       DD    DD MMMM   MMMM EE       FF       FF        C
C   EEEEEE   EEEEEE   DD    DD MM MM MM MM EEEEEE   FFFFFF   FFFFFF    C
C   EE       EE       DD    DD MM  MMM  MM EE       FF       FF        C
C   EE       EE       DD    DD MM   M   MM EE       FF       FF        C
C   EEEEEEEE EEEEEEEE DDDDDDD  MM       MM EEEEEEEE FF       FF        C
C                                                                      C
C -------------------------------------------------------------------- C
C  EEDMEFF PERFORMS ONE-BODY EFFECTIVE ELECTRON EDM ANALYSIS.          C
C  THE DIPOLE MOMENT STRENGTH 'DE' HAS BEEN FACTORED AWAY FROM THIS.   C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    IOCC - THE ORBITAL OF INTEREST.                                   C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 CONE
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 EMPTY(MDM,MDM)
      COMPLEX*16 PLS(MDM,MDM),PSL(MDM,MDM)
      COMPLEX*16 EFLD(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In EEDMEFF: not possible for this Hamiltonian!'
        WRITE(7, *) 'In EEDMEFF: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VLPLACE(PLS,2,0,1,2)
      CALL VLPLACE(PSL,3,0,1,2)
C
C     MULTIPLY RESULTS BY APPROPRIATE FACTOR
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          PLS(I,J) = 2.0D0*CV*CONE*PLS(I,J)
          PSL(I,J) =-2.0D0*CV*CONE*PSL(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,EMPTY,PLS,PSL,EMPTY,NORD)
C
C     MATRIX ELEMENT (WITH |DE| FACTORED OUT) IN HARTEE
      WDAU = V1(NSKP+IOCC,NSKP+IOCC)
C
C     MATRIX ELEMENT IN HERTZ
      WDHZ = WDAU*6.579684D+15 
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=11,FILE=TRIM(OUTFL)//'_EEDMEFF_V.dat',STATUS='UNKNOWN')
      WRITE(11, *) V1(IOCC,IOCC)
      CLOSE(UNIT=11)
C
29    FORMAT(1X,A,I3,A,ES17.10,1X,A)
30    FORMAT(24X,ES17.10,1X,A)
32    FORMAT(1X,I3,3X,A,1X,F20.14,2X,F20.14,2X,F20.14)
      WRITE(6,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
      WRITE(7,29) 'For IOCC =',IOCC,', W_{d} = ',WDAU,'au'
      WRITE(6,30)                                WDHZ,'Hz'
      WRITE(7,30)                                WDHZ,'Hz'
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE ENHANFC(IOCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    EEEEEEEE NN    NN HH    HH    AA    NN    NN FFFFFFFF CCCCCC      C
C    EE       NNN   NN HH    HH   AAAA   NNN   NN FF      CC    CC     C
C    EE       NNNN  NN HH    HH  AA  AA  NNNN  NN FF      CC           C
C    EEEEEE   NN NN NN HHHHHHHH AA    AA NN NN NN FFFFFF  CC           C
C    EE       NN  NNNN HH    HH AAAAAAAA NN  NNNN FF      CC           C
C    EE       NN   NNN HH    HH AA    AA NN   NNN FF      CC    CC     C
C    EEEEEEEE NN    NN HH    HH AA    AA NN    NN FF       CCCCCC      C
C                                                                      C
C -------------------------------------------------------------------- C
C  ENHANFC CALCULATES THE ELECTRON EDM ENHANCEMENT FACTOR VALUE        C
C  AS GIVEN IN (10.10) OF HAAKON SKAANE'S PHD THESIS.                  C
C -------------------------------------------------------------------- C
C  NOTE: SINCE THE R-VECTOR IS A CROSSING TERM IN SECOND ORDER P.T.,   C
C        CALCULATIONS HERE ARE DONE EXPLICITLY.                        C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION GAUGE(3)
C
      COMPLEX*16 CONE
      COMPLEX*16 SC,PC
      COMPLEX*16 COEF(MDM,MDM)
      COMPLEX*16 VLL0X(MDM,MDM),VLL0Y(MDM,MDM),VLL0Z(MDM,MDM),
     &           VSS0X(MDM,MDM),VSS0Y(MDM,MDM),VSS0Z(MDM,MDM),
     &           VLS0(MDM,MDM),VSL0(MDM,MDM)
      COMPLEX*16 SLL(MDM,MDM,3),SSS(MDM,MDM,3),
     &           PLS(MDM,MDM),PSL(MDM,MDM)
      COMPLEX*16 VS(MDM,MDM,3),VP(MDM,MDM)
      COMPLEX*16 RNEG(3),RPOS(3),RTOT(3)
C
      COMMON/EIGC/COEF
      COMMON/EIGE/EIGN(MDM)
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In ENHANFC: not possible for this Hamiltonian!'
        WRITE(7, *) 'In ENHANFC: not possible for this Hamiltonian!'
      ENDIF
C
C**********************************************************************C
C     PREPARATION OF MATRIX ELEMENTS                                   C
C**********************************************************************C

      WRITE(*,*) 'STEP 1'
C
C     DEFINE 'GAUGE' AS THE ORIGIN
      DO IX=1,3
        GAUGE(IX) = 0.0D0
      ENDDO
C
C     FIRST MOMENT MATRIX ELEMENTS
c      CALL VMOMNT1(VLL0X,GAUGE,1,0,1,1,2)
c      CALL VMOMNT1(VLL0Y,GAUGE,1,0,2,1,2)
      CALL VMOMNT1(VLL0Z,GAUGE,1,0,3,1,2)
C
c      CALL VMOMNT1(VSS0X,GAUGE,4,0,1,1,2)
c      CALL VMOMNT1(VSS0Y,GAUGE,4,0,2,1,2)
      CALL VMOMNT1(VSS0Z,GAUGE,4,0,3,1,2)
C
C     CONSTRUCT STARK SPLITTING MATRIX
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          SLL(I,J,1) = VLL0X(I,J)
          SLL(I,J,2) = VLL0Y(I,J)
          SLL(I,J,3) = VLL0Z(I,J)
          SSS(I,J,1) = VSS0X(I,J)
          SSS(I,J,2) = VSS0Y(I,J)
          SSS(I,J,3) = VSS0Z(I,J)
        ENDDO
      ENDDO
C
C     LAPLACIAN MATRIX ELEMENTS
      CALL VLPLACE(VLS0,2,0,1,2)
      CALL VLPLACE(VSL0,3,0,1,2)
C
C     CONSTRUCT EFFECTIVE EDM OPERATOR BY MULTIPLICATION
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VLS0(I,J) = 2.0D0*CV*CONE*VLS0(I,J)
          VSL0(I,J) =-2.0D0*CV*CONE*VSL0(I,J)
        ENDDO
      ENDDO
      
      WRITE(*,*) VLS0(1,1),VSL0(1,1)
      WRITE(*,*) SLL(1,1,3),SSS(1,1,3)
C
C**********************************************************************C
C     FULL LIST OF FIRST-ORDER TERMS                                   C
C**********************************************************************C
C
      WRITE(*,*) 'STEP 2'

C     LOOP OVER ALL ORBITAL COMBINATIONS (NEGATIVE AND POSITIVE ENERGY)
      DO IA=1,NDIM
        DO IK=1,NDIM
C
C         MATRIX ELEMENTS REQUIRE (OCC,UNOCC) COMBINATIONS ONLY
          IF(IA.GT.NSKP.AND.IA.LE.(NSKP+NOCC+IOCC)) THEN
            IAOCC = 1
          ELSE
            IAOCC = 0
          ENDIF
          IF(IK.GT.NSKP.AND.IK.LE.(NSKP+NOCC+IOCC)) THEN
            IKOCC = 1
          ELSE
            IKOCC = 0
          ENDIF
C
          IF(IAOCC.EQ.IKOCC) GOTO 150
C
C         LOOP OVER CARTESIAN INDEX IX
          DO IX=3,3
C
C           INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
            SC = DCMPLX(0.0D0,0.0D0)
C
C           LOOP OVER FOCK MATRIX ADDRESSES
            DO I=1,NDIM-NSKP
              DO J=1,NDIM-NSKP
C
                K = I+NSKP
                L = J+NSKP
C
C               ACCOUNT ONLY FOR LL AND SS COMPONENT OVERLAPS
                SC = SC + DCONJG(COEF(I,IA))*COEF(J,IK)*SLL(I,J,IX)
     &                  + DCONJG(COEF(K,IA))*COEF(L,IK)*SSS(I,J,IX)
C
              ENDDO
            ENDDO
C
C           SAVE COUNTERS TO MATRICES
            VS(IA,IK,IX) = SC
C
          ENDDO
C
C         INITIALISE COUNTERS FOR BASIS OVERLAP CONTRIBUTIONS
          PC = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FOCK MATRIX ADDRESSES
          DO I=1,NDIM-NSKP
            DO J=1,NDIM-NSKP
C
              K = I+NSKP
              L = J+NSKP
C
C             ACCOUNT ONLY FOR LS AND SL COMPONENT OVERLAPS
              PC = PC + DCONJG(COEF(I,IA))*COEF(L,IK)*VLS0(I,J)
     &                + DCONJG(COEF(K,IA))*COEF(J,IK)*VSL0(I,J)
C
            ENDDO
          ENDDO
C
C         SAVE COUNTERS TO MATRICES
          VP(IA,IK) = PC
C
150       CONTINUE
C
        ENDDO
      ENDDO

      WRITE(*,*) '-----'
      WRITE(*,*) VP(1,1),VP(NOCC+1,1),VP(1,NOCC+1),
     &                                       VP(NOCC+1,NOCC+1)
      WRITE(*,*) VS(1,1,3),VS(NOCC+1,1,3),VS(1,NOCC+1,3),
     &                                     VS(NOCC+1,NOCC+1,3)
      WRITE(*,*) '-----'
      WRITE(*,*) VP(NSKP+1,1),VP(NSKP+NOCC+1,1),
     &                   VP(NSKP+1,NOCC+1),VP(NSKP+NOCC+1,NOCC+1)
      WRITE(*,*) VS(NSKP+1,1,3),VS(NSKP+NOCC+1,1,3),
     &               VS(NSKP+1,NOCC+1,3),VS(NSKP+NOCC+1,NOCC+1,3)
      WRITE(*,*) '-----'
      WRITE(*,*) VP(1,NSKP+1),VP(NOCC+1,NSKP+1),
     &                   VP(1,NSKP+NOCC+1),VP(NOCC+1,NSKP+NOCC+1)
      WRITE(*,*) VS(1,NSKP+1,3),VS(NOCC+1,NSKP+1,3),
     &               VS(1,NSKP+NOCC+1,3),VS(NOCC+1,NSKP+NOCC+1,3)
      WRITE(*,*) '-----'
      WRITE(*,*) VP(NSKP+1,NSKP+1),VP(NSKP+NOCC+1,NSKP+1),
     &         VP(NSKP+1,NSKP+NOCC+1),VP(NSKP+NOCC+1,NSKP+NOCC+1)
      WRITE(*,*) VS(NSKP+1,NSKP+1,3),VS(NSKP+NOCC+1,NSKP+1,3),
     &     VS(NSKP+1,NSKP+NOCC+1,3),VS(NSKP+NOCC+1,NSKP+NOCC+1,3)

C
C**********************************************************************C
C     CALCULATION OF SECOND-ORDER CROSSING TERM, E^(2)_CROSS.          C
C**********************************************************************C
C
      WRITE(*,*) 'STEP 3'

C     INITIALISE R VECTOR
      DO IX=1,3
        RPOS(IX) = DCMPLX(0.0D0,0.0D0)
        RNEG(IX) = DCMPLX(0.0D0,0.0D0)
        RTOT(IX) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C     LOOP OVER ALL OCCUPIED ORBITALS IA
      DO IA=NSKP+1,NSKP+NOCC+IOCC
C
C       EIGENVALUE ENERGY FOR THIS ORBITAL
        EA = EIGN(IA)
C
C       POSITIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E+ STATES
        DO IK=NSKP+NOCC+IOCC+1,NDIM
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EA-EIGN(IK)
C
C         LOOP OVER CARTESIAN INDICES IX
          DO IX=1,3
C
C           CONTRIBUTIONS TO EACH PART OF THE G-TENSOR
            RPOS(IX) = RPOS(IX)    +        VS(IA,IK,IX)*VP(IK,IA)/EAK
     &                             + DCONJG(VS(IA,IK,IX)*VP(IK,IA)/EAK)
          ENDDO
C
C       END POSITIVE-ENERGY LOOP
        ENDDO
C
C       NEGATIVE-ENERGY CONTRIBUTION: LOOP OVER ALL UNOCCUPIED E- STATES
        DO IK=1,NSKP
C
C         ENERGY DIFFERENCE FOR THIS (EA,EK)
          EAK = EA-EIGN(IK)
C
C         LOOP OVER CARTESIAN INDICES IX
          DO IX=1,3
C
C           CONTRIBUTIONS TO EACH PART OF THE G-TENSOR
            RNEG(IX) = RNEG(IX)    +        VS(IA,IK,IX)*VP(IK,IA)/EAK
     &                             + DCONJG(VS(IA,IK,IX)*VP(IK,IA)/EAK)
C
          ENDDO
C
C       END NEGATIVE-ENERGY LOOP
        ENDDO
C                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
C     END LOOP OVER OCCUPIED ORBITALS
      ENDDO
C
C     TOTAL CONTRIBUTION
      DO IX=1,3
        RTOT(IX) = RPOS(IX) + RNEG(IX)
      ENDDO
C
C     SPHERICAL AVERAGE
      DPOS = 0.0D0
      DNEG = 0.0D0
      DTOT = 0.0D0
      DO IX=1,3
        DPOS = DPOS + DREAL(RPOS(IX))/3.0D0
        DNEG = DNEG + DREAL(RNEG(IX))/3.0D0
        DTOT = DTOT + DREAL(RTOT(IX))/3.0D0
      ENDDO
C
21    FORMAT(10X,A,1X,'(',F16.10,',',F16.10,',',F16.10,')')
C
      WRITE(6, *) 'eEDM analysis:'
      WRITE(7, *) 'eEDM analysis:'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
22    FORMAT(8X,'|',9X,A,11X,A,11X,A,2X,'|',9X,A)
23    FORMAT(1X,A,2X,' |',F14.8,2X,F14.8,2X,F14.8,2X,'|',1X,F14.8)
      WRITE(6, *) 'eEDM enhancement factor components (au):'
      WRITE(7, *) 'eEDM enhancement factor components (au):'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,22) 'R_(x)','R_(y)','R_(z)','R(tot)'
      WRITE(7,22) 'R_(x)','R_(y)','R_(z)','R(tot)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'R(+)',(DREAL(RPOS(IX)),IX=1,3),DPOS
      WRITE(7,23) 'R(+)',(DREAL(RPOS(IX)),IX=1,3),DPOS
      WRITE(6,23) 'R(-)',(DREAL(RNEG(IX)),IX=1,3),DNEG
      WRITE(7,23) 'R(-)',(DREAL(RNEG(IX)),IX=1,3),DNEG
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,23) 'R(t)',(DREAL(RTOT(IX)),IX=1,3),DTOT
      WRITE(7,23) 'R(t)',(DREAL(RTOT(IX)),IX=1,3),DTOT
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE SCLPTEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS   CCCCCC  LL       PPPPPPP TTTTTTTT EEEEEEEE NN    NN    C
C     SS    SS CC    CC LL       PP    PP   TT    EE       NNN   NN    C
C     SS       CC       LL       PP    PP   TT    EE       NNNN  NN    C
C      SSSSSS  CC       LL       PP    PP   TT    EEEEEE   NN NN NN    C
C           SS CC       LL       PPPPPPP    TT    EE       NN  NNNN    C
C     SS    SS CC    CC LL       PP         TT    EE       NN   NNN    C
C      SSSSSS   CCCCCC  LLLLLLLL PP         TT    EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  SCLPTEN GIVE A SCALAR PT-ODD ELECTRON-NUCLEUS INTERACTION ANALYSIS. C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In SCLPTEN: not possible for this Hamiltonian!'
        WRITE(7, *) 'In SCLPTEN: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VMOMNT0(OLAPLL,1,0,1,2)
      CALL VMOMNT0(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
C
      WRITE(6, *) 'Scalar PT-odd electron-nuclear operator analysis:'
      WRITE(7, *) 'Scalar PT-odd electron-nuclear operator analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1(5))
      WRITE(7,20) 'Molecular property = ',DREAL(E1(5))
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,2)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_SCLPTEN_V.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE VECPTEN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     VV    VV EEEEEEEE CCCCCC  PPPPPPP TTTTTTTT EEEEEEEE NN    NN     C
C     VV    VV EE      CC    CC PP    PP   TT    EE       NNN   NN     C
C     VV    VV EE      CC       PP    PP   TT    EE       NNNN  NN     C
C     VV    VV EEEEEE  CC       PP    PP   TT    EEEEEE   NN NN NN     C
C      VV  VV  EE      CC       PPPPPPP    TT    EE       NN  NNNN     C
C       VVVV   EE      CC    CC PP         TT    EE       NN   NNN     C
C        VV    EEEEEEEE CCCCCC  PP         TT    EEEEEEEE NN    NN     C
C                                                                      C
C -------------------------------------------------------------------- C
C  VECPTEN GIVES A VECTOR PT-ODD ELECTRON-NUCLEUS INTERACTION ANALYSIS.C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In VECPTEN: not possible for this Hamiltonian!'
        WRITE(7, *) 'In VECPTEN: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VMOMNT0(OLAPLL,1,0,1,2)
      CALL VMOMNT0(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
C
      WRITE(6, *) 'Vector PT-odd electron-nuclear operator analysis:'
      WRITE(7, *) 'Vector PT-odd electron-nuclear operator analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1(5))
      WRITE(7,20) 'Molecular property = ',DREAL(E1(5))
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,2)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_VECPTEN_V.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE PVIOLTN
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       PPPPPPP  VV    VV IIII OOOOOO  LL      TTTTTTTT NN    NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NNN   NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NNNN  NN       C
C       PP    PP VV    VV  II OO    OO LL         TT    NN NN NN       C
C       PPPPPPP   VV  VV   II OO    OO LL         TT    NN  NNNN       C
C       PP         VVVV    II OO    OO LL         TT    NN   NNN       C
C       PP          VV    IIII OOOOOO  LLLLLLLL   TT    NN    NN       C
C                                                                      C
C -------------------------------------------------------------------- C
C  PVIOLTN PERFORMS A P-PODD EFFECTIVE OPERATOR ANALYSIS.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     THIS IS STRICTLY A RELATIVISTIC PHENOMENON
      IF(HMLT.EQ.'NORL') THEN
        WRITE(6, *) 'In PVIOLTN: not possible for this Hamiltonian!'
        WRITE(7, *) 'In PVIOLTN: not possible for this Hamiltonian!'
      ENDIF
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VMOMNT0(OLAPLL,1,0,1,2)
      CALL VMOMNT0(OLAPSS,4,0,1,2)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
C
      WRITE(6, *) 'P-odd effective operator analysis:'
      WRITE(7, *) 'P-odd effective operator analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Molecular property = ',DREAL(E1(5))
      WRITE(7,20) 'Molecular property = ',DREAL(E1(5))
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,2)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_PVIOLTN_V.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE BETADCY(ICNT,ZDCY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     BBBBBBB  EEEEEEEE TTTTTTTT   AA    DDDDDDD   CCCCCC  YY    YY    C
C     BB    BB EE          TT     AAAA   DD    DD CC    CC YY    YY    C
C     BB    BB EE          TT    AA  AA  DD    DD CC        YY  YY     C
C     BBBBBBB  EEEEEE      TT   AA    AA DD    DD CC         YYYY      C
C     BB    BB EE          TT   AAAAAAAA DD    DD CC          YY       C
C     BB    BB EE          TT   AA    AA DD    DD CC    CC    YY       C
C     BBBBBBB  EEEEEEEE    TT   AA    AA DDDDDDD   CCCCCC     YY       C
C                                                                      C
C -------------------------------------------------------------------- C
C  BETADCY TAKES THE RADIOACTIVE DECAY PROCESS IN WHICH ATOMIC CENTRE  C
C  ICNT LOSES AN AMOUNT OF CHARGE ZDCY, AND PERFORMS AN ANALYSIS.      C
C -------------------------------------------------------------------- C
C  NOTES: NUCLEAR RADII REMAIN UNCHANGED IN THIS ANALYSIS.             C
C         RESULTS MAKE MOST SENSE FOR A ONE-ELECTRON PROBLEM.          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION XYZ(3)
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 VNUCLL(MDM,MDM),VNUCSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     ADJUST NUCLEAR CHARGE OF CENTRE ICNT
      DO IX=1,3
        XYZ(IX) = BXYZ(IX,ICNT)
      ENDDO
C
C     NEW NUCLEAR CHARGE OF DECAYED CENTRE
      ZNEW = ZNUC(ICNT)-ZDCY
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX
      CALL VNCATRC(VNUCLL,ZDCY,ICNT,1,0,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VNCATRC(VNUCSS,ZDCY,ICNT,4,0,1,2)
      ENDIF
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,VNUCLL,EMPTY,EMPTY,VNUCSS)
C
      WRITE(6, *) 'Beta decay analysis:'
      WRITE(7, *) 'Beta decay analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     WRITE ENERGY DIFFERENCE EXPECTATION VALUE
20    FORMAT(1X,A,F15.10)
      WRITE(6,20) 'Energy difference = ',DREAL(E1(5))
      WRITE(7,20) 'Energy difference = ',DREAL(E1(5))
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 4
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,VNUCLL,EMPTY,EMPTY,VNUCSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_BETADCY_V.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C**********************************************************************C
C     SET OF GOLDSTONE DIAGRAMS FOR ONE ORBITAL                        C
C**********************************************************************C
C
C     SPECIFY THE ORBITAL
      IOCC = 1
C
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
40    FORMAT(1X,'Goldstone diagram values for IOCC = ',I3)
C
C     Z-COMPONENT
      WRITE(6,40) IOCC
      WRITE(7,40) IOCC
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     DIAGRAMATIC PERTURBATION THEORY ON IOCC DUE TO VZ1
      CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,1)
C
      RETURN
      END
C
C
      SUBROUTINE NUCOLAP(ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    NN    NN UU    UU  CCCCCC   OOOOOO  LL          AA    PPPPPPP     C
C    NNN   NN UU    UU CC    CC OO    OO LL         AAAA   PP    PP    C
C    NNNN  NN UU    UU CC       OO    OO LL        AA  AA  PP    PP    C
C    NN NN NN UU    UU CC       OO    OO LL       AA    AA PP    PP    C
C    NN  NNNN UU    UU CC       OO    OO LL       AAAAAAAA PPPPPPP     C
C    NN   NNN UU    UU CC    CC OO    OO LL       AA    AA PP          C
C    NN    NN  UUUUUU   CCCCCC   OOOOOO  LLLLLLLL AA    AA PP          C
C                                                                      C
C -------------------------------------------------------------------- C
C  NUCOLAP CALCULATES THE INTEGRAL OF THE NUCLEAR DENSITY FUNCTION AND C
C  OCCUPIED ORBITAL DENSITY (GAUSSIAN NUCLEAR MODEL.)                  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT - NUCLEAR CENTRE OF INTEREST.                                C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4 HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
C
      DIMENSION EPOS(0:21),ENEG(0:21),ETOT(0:21)
C
      COMPLEX*16 E1(5)
      COMPLEX*16 V1(MDM,MDM)
      COMPLEX*16 OLAPLL(MDM,MDM),OLAPSS(MDM,MDM),EMPTY(MDM,MDM)
C
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     INITIALISE DUMMY ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          EMPTY(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     GENERATE DIRECT OVERLAP MATRIX (ZEROTH MOMENT)
      CALL VNCOLAP(OLAPLL,ICNT,1,0,1,2)
      IF(HMLT.NE.'NORL') THEN
        CALL VNCOLAP(OLAPSS,ICNT,4,0,1,2)
      ENDIF
C
C**********************************************************************C
C     MOLECULAR EXPECTATION VALUE                                      C
C**********************************************************************C
C
      WRITE(6, *) 'Direct overlap analysis:'
      WRITE(7, *) 'Direct overlap analysis:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     CALCULATE MOLECULAR EXPECTATION VALUE OVER THE DENSITY MATRIX
      CALL PROPRTY(E1,OLAPLL,EMPTY,EMPTY,OLAPSS)
C
C     WRITE OCCUPATION NUMBER EXPECTATION VALUE
20    FORMAT(1X,'Component ',A,' charge density overlap with centre',
     &                                              I2,3X,' = ',F15.10)
21    FORMAT(' Total electron density overlap with centre',
     &                                             I2,10X,' = ',F15.10)
      IF(HMLT.EQ.'NORL') GOTO 22
      WRITE(6,20) '{LL}',ICNT,DREAL(E1(1))
      WRITE(7,20) '{LL}',ICNT,DREAL(E1(1))
      WRITE(6,20) '{LS}',ICNT,DREAL(E1(2))
      WRITE(7,20) '{LS}',ICNT,DREAL(E1(2))
      WRITE(6,20) '{SL}',ICNT,DREAL(E1(3))
      WRITE(7,20) '{SL}',ICNT,DREAL(E1(3))
      WRITE(6,20) '{SS}',ICNT,DREAL(E1(4))
      WRITE(7,20) '{SS}',ICNT,DREAL(E1(4))
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
22    CONTINUE
      WRITE(6,21) ICNT,DREAL(E1(5))
      WRITE(7,21) ICNT,DREAL(E1(5))
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C**********************************************************************C
C     ORBITAL EXPECTATION VALUES                                       C
C**********************************************************************C
C
C     MAXIMUM ORDER IN PERTURBATIVE EXPANSION
      NORD = 1
C
30    FORMAT(1X,A,12X,A,I1,A,13X,A,I1,A,13X,A,I1,A)
31    FORMAT(1X,I3,2X,F21.14,2X,F21.14,2X,F21.14)
      WRITE(6, *) 'Expectation value for each orbital IOCC:'
      WRITE(7, *) 'Expectation value for each orbital IOCC:'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      WRITE(6,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(7,30) 'Orb.','E^(',NORD,')[pos]','E^{',NORD,'}[neg]',
     &                                       'E^{',NORD,'}[tot]'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     GENERATE ARRAY OF FIRST ORDER MATRIX ELEMENTS
      CALL RSPT1(V1,OLAPLL,EMPTY,EMPTY,OLAPSS,NORD)
C
C     PRINT MATRIX ELEMENTS TO FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCOLAP_V1.dat',STATUS='UNKNOWN')
        DO IOCC=1,NDIM
          WRITE(8, *) (V1(IOCC,JOCC),JOCC=1,NDIM)
        ENDDO
      CLOSE(UNIT=8)
C
C     MAPPING BETWEEN NORD AND TOTAL ENERGY AT THAT ORDER
      IF(NORD.EQ.0) THEN
        NAD = 0
      ELSEIF(NORD.EQ.1) THEN
        NAD = 1
      ELSEIF(NORD.EQ.2) THEN
        NAD = 2
      ELSEIF(NORD.EQ.3) THEN
        NAD = 5
      ELSEIF(NORD.EQ.4) THEN
        NAD = 10
      ELSEIF(NORD.EQ.5) THEN
        NAD = 20
      ENDIF
C
C     OPEN EXTERNAL FILE
      OPEN(UNIT=8,FILE=TRIM(OUTFL)//'_NUCOLAP_EN.dat',STATUS='UNKNOWN')
C
C       LOOP OVER ALL OCCUPIED ORBITALS
        DO IOCC=1,NOCC
C
C         DIAGRAMATIC PERTURBATION THEORY ON V1
          CALL DIAGRMTC(V1,EPOS,ENEG,ETOT,NORD,NSKP+IOCC,0)
C
C         WRITE RESULTS TO FILE
          WRITE(6,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(7,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
          WRITE(8,31) IOCC,EPOS(NAD),ENEG(NAD),ETOT(NAD)
C
C       END LOOP OVER OCCUPIED ORBITALS
        ENDDO
C
C     CLOSE EXTERNAL FILE
      CLOSE(UNIT=8)
C
C     END SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE VMOMNT0(VIJ,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 000000   C
C VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   00   000  C
C VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT   00  0000  C
C VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT   00 00 00  C
C  VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT   0000  00  C
C   VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT   000   00  C
C    VV    MM       MM  OOOOOO  MM       MM NN    NN    TT    000000   C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMOMNT0 CONSTRUCTS A MATRIX OF (u,T|SIG_Q|v,T') ZEROTH MOMENT       C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS.                            C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE
      COMPLEX*16 TMP(MBS,MBS,4)
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     GENERATE ELLQ COEFFICIENTS (IPHS = +1)
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMOMNT0: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMOMNT0: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
          ERT = DSQRT(PI/EIJ)**3
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*E11(M,1)
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*E21(M,1)
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VMOMNT1(VIJ,CLOC,ITT,IQ,IX,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 11     C
C   VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   111     C
C   VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT    11     C
C   VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT    11     C
C    VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT    11     C
C     VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT    11     C
C      VV    MM       MM  OOOOOO  MM       MM NN    NN    TT   1111    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMOMNT1 CONSTRUCTS A MATRIX OF (u,T|SIG_Q.X|v,T') FIRST MOMENT      C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATE X.          C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    CLOC  = LOCAL ORIGIN OVER WHICH MOMENT IX IS TO BE EVALUATED.     C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    IX    = {1,2,3}   -> {X,Y,Z} CARTESIAN WEIGHTING FACTOR.          C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION CLOC(3),IVCT(3)
      DIMENSION APH(MB2),CP(MB2,3)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX INTO A VECTOR
      CALL NCART(IVCT,IX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMOMNT1: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMOMNT1: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX  = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY  = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ  = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          CP(M,1) = PX-CLOC(1)
          CP(M,2) = PY-CLOC(2)
          CP(M,3) = PZ-CLOC(3)
C
C         FACTORS
          ERT = DSQRT(PI/EIJ)**3
C
C         INTEGRALS FOR THIS BLOCK
          TA1 = CP(M,IX)*E11(M,1)
          TA2 = CP(M,IX)*E21(M,1)
          IF(NTUV.GE.1) THEN
            TA1 = TA1 + E11(M,INABCD(IVCT(1),IVCT(2),IVCT(3)))
            TA2 = TA2 + E21(M,INABCD(IVCT(1),IVCT(2),IVCT(3)))
          ENDIF
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VMOMNT2(VIJ,CLOC,DLOC,ITT,IQ,IX,JX,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C VV    VV MM       MM  OOOOOO  MM       MM NN    NN TTTTTTTT 222222   C
C VV    VV MMM     MMM OO    OO MMM     MMM NNN   NN    TT   22    22  C
C VV    VV MMMM   MMMM OO    OO MMMM   MMMM NNNN  NN    TT         22  C
C VV    VV MM MM MM MM OO    OO MM MM MM MM NN NN NN    TT       22    C
C  VV  VV  MM  MMM  MM OO    OO MM  MMM  MM NN  NNNN    TT     22      C
C   VVVV   MM   M   MM OO    OO MM   M   MM NN   NNN    TT   22        C
C    VV    MM       MM  OOOOOO  MM       MM NN    NN    TT   22222222  C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMOMNT2 CONSTRUCTS A MATRIX OF (u,T|SIG_Q.X.X'|v,T') SECOND MOMENT  C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATES X AND X'.  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    CLOC  = LOCAL ORIGIN OVER WHICH MOMENT IX IS TO BE EVALUATED.     C
C    DLOC  = LOCAL ORIGIN OVER WHICH MOMENT JX IS TO BE EVALUATED.     C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    IX    = {1,2,3}   -> {X,Y,Z} FIRST CARTESIAN WEIGHTING FACTOR.    C
C    JX    = {1,2,3}   -> {X,Y,Z} SECOND CARTESIAN WEIGHTING FACTOR.   C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION CLOC(3),DLOC(3),IVCT(3),JVCT(3)
      DIMENSION CP(MB2,3),DP(MB2,3)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX AND JX INTO VECTORS
      CALL NCART(IVCT,IX)
      CALL NCART(JVCT,JX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMOMNT2: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMOMNT2: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     FINITE SUM ADDRESSES FOR CARTESIAN OVERLAPS OF INTEREST
      IAD00 = INABCD(             0 ,             0 ,             0 )
      IAD10 = INABCD(IVCT(1)        ,IVCT(2)        ,IVCT(3)        )
      IAD01 = INABCD(        JVCT(1),        JVCT(2),        JVCT(3))
      IAD11 = INABCD(IVCT(1)+JVCT(1),IVCT(2)+JVCT(2),IVCT(3)+JVCT(3))
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          CP(M,1) = PX-CLOC(1)
          CP(M,2) = PY-CLOC(2)
          CP(M,3) = PZ-CLOC(3)
          DP(M,1) = PX-DLOC(1)
          DP(M,2) = PY-DLOC(2)
          DP(M,3) = PZ-DLOC(3)
C
C         FACTORS
          ERT = DSQRT(PI/EIJ)**3
C
C         INTEGRALS FOR THIS BLOCK
          IF(IX.EQ.JX) THEN
            TA1 = 2.0D0*CP(M,IX)*DP(M,JX)*E11(M,IAD00)
            TA2 = 2.0D0*CP(M,IX)*DP(M,JX)*E21(M,IAD00)
          ELSE
            TA1 =       CP(M,IX)*DP(M,JX)*E11(M,IAD00)
            TA2 =       CP(M,IX)*DP(M,JX)*E21(M,IAD00)
          ENDIF
          IF(NTUV.GT.1) THEN
            TA1 = TA1 + DP(M,JX)*E11(M,IAD10) + CP(M,IX)*E11(M,IAD01)
            TA2 = TA2 + DP(M,JX)*E21(M,IAD10) + CP(M,IX)*E21(M,IAD01)
          ENDIF
          IF(NTUV.GT.2) THEN
            TA1 = TA1 + E11(M,IAD11)
            TA2 = TA2 + E21(M,IAD11)
          ENDIF
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOPS OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VMNPOLE(VIJ,CLOC,ITT,IQ,IX,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  VV    VV MM       MM NN    NN PPPPPPP   OOOOOO  LL       EEEEEEEE   C
C  VV    VV MMM     MMM NNN   NN PP    PP OO    OO LL       EE         C
C  VV    VV MMMM   MMMM NNNN  NN PP    PP OO    OO LL       EE         C
C  VV    VV MM MM MM MM NN NN NN PP    PP OO    OO LL       EEEEEE     C
C   VV  VV  MM  MMM  MM NN  NNNN PPPPPPP  OO    OO LL       EE         C
C    VVVV   MM   M   MM NN   NNN PP       OO    OO LL       EE         C
C     VV    MM       MM NN    NN PP        OOOOOO  LLLLLLLL EEEEEEEE   C
C                                                                      C
C -------------------------------------------------------------------- C
C  VMNPOLE CONSTRUCTS A MATRIX OF (u,T|SIG_Q.X/R^3|v,T') FIELD         C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATE X.          C
C  EXAMPLE: VALUE OF THE ELECTRIC FIELD AT COORDINATE CVEC.            C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    CLOC  = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                    C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    IX    = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC.            C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION CLOC(3),IVCT(3)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX INTO A VECTOR
      CALL NCART(IVCT,IX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VMNPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VMNPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT C_LOC
          CP(M,1) = CLOC(1)-PX
          CP(M,2) = CLOC(2)-PY
          CP(M,3) = CLOC(3)-PZ
C
C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
          APH(M) = EIJ
          PNC(M) = 2.0D0*PI/EIJ
C
        ENDDO
      ENDDO
C
C     GENERATE A BATCH OF R-INTEGRALS (ADD ONE TO USUAL SUM ORDER)
      CALL CPU_TIME(TDM1)
      CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+1)
      CALL CPU_TIME(TDM2)
C
C     ADD TO RELEVANT TIME COUNTER
      IF(ITT.EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITT.EQ.2) THEN
        TRLS = TRLS+TDM2-TDM1
      ELSEIF(ITT.EQ.3) THEN
        TRSL = TRSL+TDM2-TDM1
      ELSEIF(ITT.EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FINITE EXPANSION ADDRESSES
          DO ITUV=1,NTUV
C
C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
            IA = IVEC(ITUV)
            IB = JVEC(ITUV)
            IC = KVEC(ITUV)
C
C           ADD CARTESTIAN COMPONENT IX TO OVERALL ADDRESS (R-INTS)
            ITV1 = INABCD(IA+IVCT(1),IB+IVCT(2),IC+IVCT(3))
C
C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
            TA1 = TA1 - E11(M,ITUV)*RC(M,ITV1)
            TA2 = TA2 - E21(M,ITUV)*RC(M,ITV1)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VDIPOLE(VIJ,CLOC,DLOC,ITT,IQ,IX,JX,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       VV    VV DDDDDDD IIII PPPPPPP   OOOOOO  LL      EEEEEEEE       C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EE             C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EE             C
C       VV    VV DD    DD II  PP    PP OO    OO LL      EEEEEE         C
C        VV  VV  DD    DD II  PPPPPPP  OO    OO LL      EE             C
C         VVVV   DD    DD II  PP       OO    OO LL      EE             C
C          VV    DDDDDDD IIII PP        OOOOOO  LLLLLLL EEEEEEEE       C
C                                                                      C
C -------------------------------------------------------------------- C
C  VDIPOLE CONSTRUCTS A MATRIX OF (u,T|SIG_Q.X.X'/R^3|v,T') FIELD      C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH COORDINATES X AND X'.  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    CLOC  = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                    C
C    DLOC  = LOCAL ORIGIN FOR FIRST MOMENT FIELD POINT.                C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    IX    = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC.            C
C    JX    = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR DLOC.            C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION CLOC(3),DLOC(3),IVCT(3),JVCT(3)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),PD(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX AND JX INTO VECTORS
      CALL NCART(IVCT,IX)
      CALL NCART(JVCT,JX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VDIPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VDIPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT CLOC
          CP(M,1) = CLOC(1)-PX
          CP(M,2) = CLOC(2)-PY
          CP(M,3) = CLOC(3)-PZ
C
C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
          PD(M,1) = PX-DLOC(1)
          PD(M,2) = PY-DLOC(2)
          PD(M,3) = PZ-DLOC(3)
C
C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
          APH(M) = EIJ
          PNC(M) = 2.0D0*PI/EIJ
C
        ENDDO
      ENDDO
C
C     GENERATE A BATCH OF R-INTEGRALS (ADD TWO TO SUM ORDER)
      CALL CPU_TIME(TDM1)
      CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+2)
      CALL CPU_TIME(TDM2)
C
C     ADD TO RELEVANT TIME COUNTER
      IF(ITT.EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITT.EQ.2) THEN
        TRLS = TRLS+TDM2-TDM1
      ELSEIF(ITT.EQ.3) THEN
        TRSL = TRSL+TDM2-TDM1
      ELSEIF(ITT.EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ENDIF
C
C     ELECTRIC FIELD MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FINITE EXPANSION ADDRESSES
          DO ITUV=1,NTUV
C
C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
            IA = IVEC(ITUV)
            IB = JVEC(ITUV)
            IC = KVEC(ITUV)
C
C           FIRST TERM
            IT = IA+IVCT(1)+JVCT(1)
            IU = IB+IVCT(2)+JVCT(2)
            IV = IC+IVCT(3)+JVCT(3)
            R1 = 0.5D0*RC(M,INABCD(IT,IU,IV))/APH(M)
C
C           SECOND TERM
            IT = IA+IVCT(1)
            IU = IB+IVCT(2)
            IV = IC+IVCT(3)
            R2 = PD(M,JX)*RC(M,INABCD(IT,IU,IV))
C
C           THIRD TERM
            IT = IA+IVCT(1)-JVCT(1)
            IU = IB+IVCT(2)-JVCT(2)
            IV = IC+IVCT(3)-JVCT(3)
            IF(IT.GT.0.AND.IU.GT.0.AND.IV.GT.0) THEN
              ID3 = IA*JVCT(1)+IB*JVCT(2)+IC*JVCT(3)
              R3  = ID3*RC(M,INABCD(IT,IU,IV))
            ELSE
              R3  = 0.0D0
            ENDIF
C
C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
            TA1 = TA1 - E11(M,ITUV)*(R1+R2+R3)
            TA2 = TA2 - E21(M,ITUV)*(R1+R2+R3)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VQDPOLE(VIJ,CLOC,DLOC,ELOC,ITT,IQ,IX,JX,KX,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV  QQQQQQ   DDDDDDD  PPPPPPP   OOOOOO  LL      EEEEEEEE    C
C    VV    VV QQ    QQ  DD    DD PP    PP OO    OO LL      EE          C
C    VV    VV QQ    QQ  DD    DD PP    PP OO    OO LL      EE          C
C    VV    VV QQ    QQ  DD    DD PP    PP OO    OO LL      EEEEEE      C
C     VV  VV  QQ   QQQ  DD    DD PPPPPPP  OO    OO LL      EE          C
C      VVVV   QQ    QQ  DD    DD PP       OO    OO LL      EE          C
C       VV     QQQQQQ Q DDDDDDD  PP        OOOOOO  LLLLLLL EEEEEEEE    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VQDPOLE CONSTRUCTS A MATRIX OF (u,T|SIG_Q.X.X'.X''/R^3|v,T') FIELD  C
C  INTEGRALS OVER ALL BASIS FUNCTION PAIRS WITH BXYZS X, X' AND X''.  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    CLOC  = LOCAL ORIGIN FOR ELECTRIC FIELD POINT.                    C
C    DLOC  = LOCAL ORIGIN FOR SECOND MOMENT FIELD POINT (PART 1).      C
C    ELOC  = LOCAL ORIGIN FOR SECOND MOMENT FIELD POINT (PART 2).      C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    IX    = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR CLOC.            C
C    JX    = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR DLOC.            C
C    KX    = {1,2,3}   -> {X,Y,Z} CARTESIAN INDEX FOR ELOC.            C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION CLOC(3),DLOC(3),ELOC(3),IVCT(3),JVCT(3),KVCT(3)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),PD(MB2,3),PE(MB2,3)
      DIMENSION APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     TURN IX, JX AND KX INTO VECTORS
      CALL NCART(IVCT,IX)
      CALL NCART(JVCT,JX)
      CALL NCART(KVCT,KX)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VQDPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VQDPOLE: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT CLOC
          CP(M,1) = CLOC(1)-PX
          CP(M,2) = CLOC(2)-PY
          CP(M,3) = CLOC(3)-PZ
C
C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
          PD(M,1) = PX-DLOC(1)
          PD(M,2) = PY-DLOC(2)
          PD(M,3) = PZ-DLOC(3)
C
C         RELATIVE COORDINATES OF MOMENT ORIGIN DLOC FROM (PX,PY,PZ)
          PE(M,1) = PX-ELOC(1)
          PE(M,2) = PY-ELOC(2)
          PE(M,3) = PZ-ELOC(3)
C
C         BOYS EXPONENT AND MULTIPLIER FOR HERMITE POTENTIAL INTEGRALS
          APH(M) = EIJ
          PNC(M) = 2.0D0*PI/EIJ
C
        ENDDO
      ENDDO
C
C     GENERATE A BATCH OF R-INTEGRALS (ADD THREE TO SUM ORDER)
      CALL CPU_TIME(TDM1)
      CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM+3)
      CALL CPU_TIME(TDM2)
C
C     ADD TO RELEVANT TIME COUNTER
      IF(ITT.EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITT.EQ.2) THEN
        TRLS = TRLS+TDM2-TDM1
      ELSEIF(ITT.EQ.3) THEN
        TRSL = TRSL+TDM2-TDM1
      ELSEIF(ITT.EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         INITIALISE SUM COUNTERS FOR FINITE EXPANSION
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER FINITE EXPANSION ADDRESSES
          DO ITUV=1,NTUV
C
C           PICK OUT (A,B,C) FINITE EXPANSION ADDRESS
            IA = IVEC(ITUV)
            IB = JVEC(ITUV)
            IC = KVEC(ITUV)
C
C           FIRST TERM
            IT = IA+IVCT(1)+JVCT(1)+KVCT(1)
            IU = IB+IVCT(2)+JVCT(2)+KVCT(2)
            IV = IC+IVCT(3)+JVCT(3)+KVCT(3)
            R1 = 0.25D0*RC(M,INABCD(IT,IU,IV))/(APH(M)*APH(M))
C
C           SECOND TERM
            IT = IA+IVCT(1)+JVCT(1)
            IU = IB+IVCT(2)+JVCT(2)
            IV = IC+IVCT(3)+JVCT(3)
            R2 = 0.5D0*PE(M,KX)*RC(M,INABCD(IT,IU,IV))/APH(M)
C
C           THIRD TERM
            IT = IA+IVCT(1)+JVCT(1)-KVCT(1)
            IU = IB+IVCT(2)+JVCT(2)-KVCT(2)
            IV = IC+IVCT(3)+JVCT(3)-KVCT(3)
            IF(IT.GT.0.AND.IU.GT.0.AND.IV.GT.0) THEN
              ID3 = (IA+JVCT(1))*KVCT(1)+(IB+JVCT(2))*KVCT(2)
     &                                  +(IC+JVCT(3))*KVCT(3)
              R3  = 0.5D0*ID3*RC(M,INABCD(IT,IU,IV))/APH(M)
            ELSE
              R3  = 0.0D0
            ENDIF
C
C           FOURTH TERM
            IT = IA+IVCT(1)        +KVCT(1)
            IU = IB+IVCT(2)        +KVCT(2)
            IV = IC+IVCT(3)        +KVCT(3)
            R4 = 0.5D0*PD(M,JX)*RC(M,INABCD(IT,IU,IV))/APH(M)
C
C           FIFTH TERM
            IT = IA+IVCT(1)
            IU = IB+IVCT(2)
            IV = IC+IVCT(3)
            R5 = PD(M,JX)*PE(M,KX)*RC(M,INABCD(IT,IU,IV))
C
C           SIXTH TERM
            IT = IA+IVCT(1)-KVCT(1)
            IU = IB+IVCT(2)-KVCT(2)
            IV = IC+IVCT(3)-KVCT(3)
            IF(IT.GT.0.AND.IU.GT.0.AND.IV.GT.0) THEN
              ID6 = IA*KVCT(1)+IB*KVCT(2)+IC*KVCT(3)
              R6  = ID6*PD(M,JX)*RC(M,INABCD(IT,IU,IV))
            ELSE
              R6  = 0.0D0
            ENDIF
C
C           SEVENTH TERM
            IT = IA+IVCT(1)-JVCT(1)+KVCT(1)
            IU = IB+IVCT(2)-JVCT(2)+KVCT(2)
            IV = IC+IVCT(3)-JVCT(3)+KVCT(3)
            IF(IT.GT.0.AND.IU.GT.0.AND.IV.GT.0) THEN
              ID7 = IA*JVCT(1)+IB*JVCT(2)+IC*JVCT(3)
              R7  = 0.5D0*ID7*RC(M,INABCD(IT,IU,IV))/APH(M)
            ELSE
              R7  = 0.0D0
            ENDIF
C
C           EIGHTH TERM
            IT = IA+IVCT(1)-JVCT(1)
            IU = IB+IVCT(2)-JVCT(2)
            IV = IC+IVCT(3)-JVCT(3)
            IF(IT.GT.0.AND.IU.GT.0.AND.IV.GT.0) THEN
              ID8 = IA*JVCT(1)+IB*JVCT(2)+IC*JVCT(3)
              R8  = ID8*PE(M,KX)*RC(M,INABCD(IT,IU,IV))
            ELSE
              R8  = 0.0D0
            ENDIF
C
C           NINTH TERM
            IT = IA+IVCT(1)-JVCT(1)-KVCT(1)
            IU = IB+IVCT(2)-JVCT(2)-KVCT(2)
            IV = IC+IVCT(3)-JVCT(3)-KVCT(3)
            IF(IT.GT.0.AND.IU.GT.0.AND.IV.GT.0) THEN
              ID9 = IA*JVCT(1)+IB*JVCT(2)+IC*JVCT(3)
              JD9 = (IA-JVCT(1))*KVCT(1)+(IB-JVCT(2))*KVCT(2)
     &                                  +(IC-JVCT(3))*KVCT(3)
              R9  = ID9*JD9*PE(M,KX)*RC(M,INABCD(IT,IU,IV))
            ELSE
              R9  = 0.0D0
            ENDIF
C
C           DETERMINE FINITE SUM FOR THIS (IBAS,JBAS) MATRIX ELEMENT
            TA1 = TA1 - E11(M,ITUV)*(R1+R2+R3+R4+R5+R6+R7+R8+R9)
            TA2 = TA2 - E21(M,ITUV)*(R1+R2+R3+R4+R5+R6+R7+R8+R9)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VNCATRC(VIJ,ZEFF,ICNT,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC     AA   TTTTTTTT RRRRRRR   CCCCCC      C
C    VV    VV NNN   NN CC    CC   AAAA     TT    RR    RR CC    CC     C
C    VV    VV NNNN  NN CC        AA  AA    TT    RR    RR CC           C
C    VV    VV NN NN NN CC       AA    AA   TT    RR    RR CC           C
C     VV  VV  NN  NNNN CC       AAAAAAAA   TT    RRRRRRR  CC           C
C      VVVV   NN   NNN CC    CC AA    AA   TT    RR    RR CC    CC     C
C       VV    NN    NN  CCCCCC  AA    AA   TT    RR    RR  CCCCCC      C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCATRC CONSTRUCTS A MATRIX OF (u,T|V_nuc|v,T') OVERLAP             C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C  NOTE: DOES NOT INCLUDE NUCLEAR CHARGE OF ICNT -- APPLY EXTERNALLY.  C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT  = NUCLEAR CENTRE OF INTEREST, AS LISTED IN INPUT FILE.      C
C    ZEFF  = EFFECTIVE CHARGE OF NUCLEAR CENTRE ICNT.                  C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCATRC: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     PREPARE DATA FOR BATCH OF R-INTEGRALS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         RELATIVE COORDINATES OF FIELD POINT C_LOC
          CP(M,1) = BXYZ(1,ICNT)-PX
          CP(M,2) = BXYZ(2,ICNT)-PY
          CP(M,3) = BXYZ(3,ICNT)-PZ
C
C         FINITE-NUCLEUS BOYS EXPONENT AND MULTIPLIER (EXCLUDE ZNUC)
          ESM    = CNUC(ICNT)+EIJ
          APH(M) = EIJ*CNUC(ICNT)/ESM
          PNC(M) = 2.0D0*PI*ZEFF*DSQRT(CNUC(ICNT)/ESM)/EIJ
C
        ENDDO
      ENDDO
C
C     GENERATE A BATCH OF R-INTEGRALS
      CALL CPU_TIME(TDM1)
      CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAM)
      CALL CPU_TIME(TDM2)
C
C     ADD TO RELEVANT TIME COUNTER
      IF(ITT.EQ.1) THEN
        TRLL = TRLL+TDM2-TDM1
      ELSEIF(ITT.EQ.2) THEN
        TRLS = TRLS+TDM2-TDM1
      ELSEIF(ITT.EQ.3) THEN
        TRSL = TRSL+TDM2-TDM1
      ELSEIF(ITT.EQ.4) THEN
        TRSS = TRSS+TDM2-TDM1
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OVER FINITE EXPANSION FOR EQ-COEFFS AND R-INTS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
          DO ITUV=1,NTUV
            TA1 = TA1 + E11(M,ITUV)*RC(M,ITUV)
            TA2 = TA2 + E21(M,ITUV)*RC(M,ITUV)
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = PNC(M)*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = PNC(M)*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VNCOLAP(VIJ,ICNT,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV NN    NN  CCCCCC   OOOOOO  LL          AA    PPPPPPP     C
C    VV    VV NNN   NN CC    CC OO    OO LL         AAAA   PP    PP    C
C    VV    VV NNNN  NN CC       OO    OO LL        AA  AA  PP    PP    C
C    VV    VV NN NN NN CC       OO    OO LL       AA    AA PP    PP    C
C     VV  VV  NN  NNNN CC       OO    OO LL       AAAAAAAA PPPPPPP     C
C      VVVV   NN   NNN CC    CC OO    OO LL       AA    AA PP          C
C       VV    NN    NN  CCCCCC   OOOOOO  LLLLLLLL AA    AA PP          C
C                                                                      C
C -------------------------------------------------------------------- C
C  VNCOLAP CONSTRUCTS A MATRIX OF (u,T|rho_nuc|v,T') OVERLAP           C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ICNT              -> NUCLEAR CENTRE OF INTEREST.                  C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE OVERLAP ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     FINITE SUM TERMINATING ORDERS
      IF(ITT.EQ.1) THEN
        LAM = LQN(1)+LQN(2)
      ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
        LAM = LQN(1)+LQN(2)+1
      ELSEIF(ITT.EQ.4) THEN
        LAM = LQN(1)+LQN(2)+2
      ENDIF
C
C     NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VNCOLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VNCOLAP: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         INCLUDE NUCLEAR EXPONENT
          ESM = CNUC(ICNT)+EIJ
          ECP = EIJ*CNUC(ICNT)/ESM
          E32 = DSQRT(CNUC(ICNT)/ESM)
          E32 = E32*E32*E32
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RPX = BXYZ(1,ICNT)-PX
          RPY = BXYZ(2,ICNT)-PY
          RPZ = BXYZ(3,ICNT)-PZ
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS = DEXP(-ECP*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C         INITIALISE TEMPORARY STORAGE ARRAYS
          TA1 = DCMPLX(0.0D0,0.0D0)
          TA2 = DCMPLX(0.0D0,0.0D0)
C
C         LOOP OVER ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           CARTESIAN HERMITE POLYNOMIAL VALUES
            HALPH = HERMITE(ECP,RPX,IVEC(ITUV))
            HBETA = HERMITE(ECP,RPY,JVEC(ITUV))
            HGAMA = HERMITE(ECP,RPZ,KVEC(ITUV))
C
C           HGTF IS A PRODUCT OF THESE
            HABC = HALPH*HBETA*HGAMA*GSS
C
C           MULTIPLY BY E-COEFF AND ADD TO TOTAL
            TA1 = TA1 + E11(M,ITUV)*HABC
            TA2 = TA2 + E21(M,ITUV)*HABC
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = E32*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = E32*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VKNETIC(VIJ,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      VV    VV KK    KK NN    NN EEEEEEEE TTTTTTTT IIII CCCCCC        C
C      VV    VV KK   KK  NNN   NN EE          TT     II CC    CC       C
C      VV    VV KK  KK   NNNN  NN EE          TT     II CC             C
C      VV    VV KKKKK    NN NN NN EEEEEE      TT     II CC             C
C       VV  VV  KK  KK   NN  NNNN EE          TT     II CC             C
C        VVVV   KK   KK  NN   NNN EE          TT     II CC    CC       C
C         VV    KK    KK NN    NN EEEEEEEE    TT    IIII CCCCCC        C
C                                                                      C
C -------------------------------------------------------------------- C
C  VKNETIC CONSTRUCTS A MATRIX OF (u,T|SIG_Q(SIG.P)|v,T') OVERLAP      C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION APH(MB2),CP(MB2,3)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELSQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELLQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VKNETIC: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VKNETIC: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RPX = PX-XYZ(1,2)
          RPY = PY-XYZ(2,2)
          RPZ = PZ-XYZ(3,2)
          RP2 = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C         FACTORS
          ERT = (DSQRT(PI/EIJ)**3)
          PRE = 8.0D0*DSQRT(EJ*EJ*EJ/(DFLOAT(2*LQN(2))+3.0D0))
C
C         INTEGRALS FOR THIS BLOCK
          IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
            X10 = 0.125D0*(2*LQN(2)+3.0D0)/EJ
          ELSE
            X10 = 0.250D0*(2*LQN(2)+3.0D0)/EJ - 0.5D0*RP2 - 0.75D0/EIJ
          ENDIF
          TA1 = X10*E11(M,1)
          TA2 = X10*E21(M,1)
          IF(ITT.EQ.2.OR.ITT.EQ.4) THEN
            IF(LQN(1)+LQN(2).GT.0) THEN
              TA1 = TA1 - RPX*E11(M,4) - RPY*E11(M,3) - RPZ*E11(M,2)
              TA2 = TA2 - RPX*E21(M,4) - RPY*E21(M,3) - RPZ*E21(M,2)
            ENDIF
            IF(LQN(1)+LQN(2).GT.1) THEN
              TA1 = TA1 - E11(M,10) - E11(M, 7) - E11(M, 5)
              TA2 = TA2 - E21(M,10) - E21(M, 7) - E21(M, 5)
            ENDIF
          ENDIF
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*PRE*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*PRE*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER CENTRES A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.1) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.4) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE VLPLACE(VIJ,ITT,IQ,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    VV    VV LL       PPPPPPP  LL          AA     CCCCCC  EEEEEEEE    C
C    VV    VV LL       PP    PP LL         AAAA   CC    CC EE          C
C    VV    VV LL       PP    PP LL        AA  AA  CC       EE          C
C    VV    VV LL       PP    PP LL       AA    AA CC       EEEEEE      C
C     VV  VV  LL       PPPPPPP  LL       AAAAAAAA CC       EE          C
C      VVVV   LL       PP       LL       AA    AA CC    CC EE          C
C       VV    LLLLLLLL PP       LLLLLLLL AA    AA  CCCCCC  EEEEEEEE    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VLPLACE CONSTRUCTS A MATRIX OF (u,T|SIG_Q GRAD^2|v,T') OVERLAP      C
C  INTEGRALS OVER ALL BASIS FUNCTIONS, AND SAVES THE RESULT TO VIJ.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION APH(MB2),CP(MB2,3)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 CONE,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 VIJ(MDM,MDM),VTEMP(MDM,MDM)
C
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J)   = DCMPLX(0.0D0,0.0D0)
          VTEMP(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VLPLACE: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VLPLACE: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX  = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY  = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ  = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          RPX = PX-XYZ(1,2)
          RPY = PY-XYZ(2,2)
          RPZ = PZ-XYZ(3,2)
          RP2 = RPX*RPX + RPY*RPY + RPZ*RPZ
C
C         FACTORS
          ERT = DSQRT(PI/EIJ)**3
          PRE = 8.0D0*EJ*EJ
C
C         INTEGRALS FOR THIS BLOCK
          IF(ITT.EQ.1.OR.ITT.EQ.3) THEN
            X10 = 0.5D0*RP2 + 0.75D0/EIJ - 0.25D0*(2*LQN(2)+3.0D0)/EJ
          ELSE
            X10 = 0.5D0*RP2 + 0.75D0/EIJ - 0.25D0*(2*LQN(2)+5.0D0)/EJ
          ENDIF
          TA1 = X10*E11(M,1)
          TA2 = X10*E21(M,1)
          IF(LQN(1)+LQN(2).GT.0) THEN
            TA1 = TA1 + RPX*E11(M,4) + RPY*E11(M,3) + RPZ*E11(M,2)
            TA2 = TA2 + RPX*E21(M,4) + RPY*E21(M,3) + RPZ*E21(M,2)
          ENDIF
          IF(LQN(1)+LQN(2).GT.1) THEN
            TA1 = TA1 + E11(M,10) + E11(M, 7) + E11(M, 5)
            TA2 = TA2 + E21(M,10) + E21(M, 7) + E21(M, 5)
          ENDIF
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*PRE*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*PRE*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
C     END LOOP OVER MQNS
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     MODIFIED SPECIAL CODE FOR VTS ELEMENTS WITH KQN(2)>0.            C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1500 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1500 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2500 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2500 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
        IF(MOD(KB,2).EQ.0.AND.(ITT.EQ.2.OR.ITT.EQ.4)) THEN
C
C         QUANTUM NUMBERS FOR BLOCK B (KQN(2)' = -KQN(2))
          KQN(2) = KAPA(KB-1,ICNTB)
          IF(KQN(2).LT.0) THEN
            LQN(2) =-KQN(2)-1
          ELSE
            LQN(2) = KQN(2)
          ENDIF
C
C         BASIS EXPONENTS FOR BLOCK B
          NBAS(2) = NFNC(LQN(2)+1,ICNTB)
          DO JBAS=1,NBAS(2)
            EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
          ENDDO
C
C         LOOP OVER |MQN(A)| VALUES
          DO 3500 MA=1,IABS(KQN(1))
            MJA    = 2*MA-1
            MQN(1) = MJA
C
C         LOOP OVER |MQN(B)| VALUES
          DO 3500 MB=1,IABS(KQN(2))
            MJB    = 2*MB-1
            MQN(2) = MJB
C
C         CALCULATE COMPONENT OFFSETS (KQN(2)' = -KQN(2))
          NA1 = LRGE(ICNTA,KA  ,2*MA-1)
          NA2 = LRGE(ICNTA,KA  ,2*MA  )
          NB1 = LRGE(ICNTB,KB-1,2*MB-1)
          NB2 = LRGE(ICNTB,KB-1,2*MB  )
C
C         THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
          PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C         OVERLAP TYPE {LS} --> GENERATE ELLQ COEFFICIENTS
          IF(ITT.EQ.2) THEN
            CALL CPU_TIME(TDM1)
            CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
            CALL CPU_TIME(TDM2)
            TELL = TELL+TDM2-TDM1
C         OVERLAP TYPE {SS} --> GENERATE ESLQ COEFFICIENTS
          ELSEIF(ITT.EQ.4) THEN
            CALL CPU_TIME(TDM1)
            CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
            CALL CPU_TIME(TDM2)
            TESL = TESL+TDM2-TDM1
          ENDIF
C
C         CALCULATE OVERLAP MATRIX ELEMENTS
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             EXPONENT COMBINATIONS
              EI  = EXPT(IBAS,1)
              EJ  = EXPT(JBAS,2)
              EIJ = EI+EJ
C
C             FACTORS
              PRE = 8.0D0*EJ*EJ*DSQRT(PI/EIJ)**3
C
C             INTEGRALS FOR THIS BLOCK
              X10 = CONE*DSQRT((2*LQN(2)+1.0D0)/(2*LQN(2)+3.0D0))/EJ
              TA1 = X10*E11(M,1)
              TA2 = X10*E21(M,1)
C
C             MATRIX ELEMENTS
              VTEMP(NA1+IBAS,NB1+JBAS) = PRE*TA1
              VTEMP(NA2+IBAS,NB1+JBAS) = PRE*TA2
              VTEMP(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(PRE*TA2)
              VTEMP(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(PRE*TA1)
C
            ENDDO
          ENDDO
C
C       END LOOP OVER BLOCKS IN SPECIAL CASE
3500    CONTINUE
C
C     END OF CONDITIONAL FOR SPECIAL CASE
      ENDIF
C
2500  CONTINUE
1500  CONTINUE
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.4) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VTEMP(I,J) =-CONE*VTEMP(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     ADD THESE TO THE VIJ ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = VIJ(I,J) + VTEMP(I,J)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     END OF MODIFIED SPECIAL CODE.                                    C
C**********************************************************************C
C
      RETURN
      END
C
C
      SUBROUTINE VPLNWAV(VIJ,ITT,IQ,GLOC,WAVK,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  VV    VV PPPPPPP  LL       NN    NN WW         WW    AA    VV    VV C
C  VV    VV PP    PP LL       NNN   NN WW         WW   AAAA   VV    VV C
C  VV    VV PP    PP LL       NNNN  NN WW         WW  AA  AA  VV    VV C
C  VV    VV PP    PP LL       NN NN NN WW    W    WW AA    AA VV    VV C
C   VV  VV  PPPPPPP  LL       NN  NNNN  WW  WWW  WW  AAAAAAAA  VV  VV  C
C    VVVV   PP       LL       NN   NNN   WWWW WWWW   AA    AA   VVVV   C
C     VV    PP       LLLLLLLL NN    NN    WW   WW    AA    AA    VV    C
C                                                                      C
C -------------------------------------------------------------------- C
C  VPLNWAV CONSTRUCTS A MATRIX OF (u,T|SIG_Q exp(i.K.RG)|v,T')         C
C  OVERLAP INTEGRALS OVER ALL BASIS FUNCTIONS.                         C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITT   = {1,2,3,4} -> {LL,LS,SL,SS} COMPONENT COMBINATION.         C
C    IQ    = {0,1,2,3} -> {0,X,Y,Z} THE COUPLING SIGMA MATRIX.         C
C    GLOC  = (GX,GY,GZ) -> FIXED GAUGE ORIGIN.                         C
C    WAVK  = (KX,KY,KZ) -> PHOTON WAVE THREE-VECTOR.                   C
C    I1,I2 = {1,2,3,4} -> BASIS FUNCTION OVERLAPS FOR EQ-COEFFS.       C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION GLOC(3),WAVK(3)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,EKP,TA1,TA2
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
      COMPLEX*16 TMP(MBS,MBS,4)
      COMPLEX*16 VIJ(MDM,MDM)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     INITIALISE THE MOLECULAR ARRAY
      DO I=1,NDIM-NSKP
        DO J=1,NDIM-NSKP
          VIJ(I,J) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     SQUARE OF WAVK
      WK2 = WAVK(1)*WAVK(1) + WAVK(2)*WAVK(2) + WAVK(3)*WAVK(3)
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES A AND B (USE INDEX 1000)                C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C**********************************************************************C
C     LOOP OVER KQNS FOR CENTRES A AND B (USE INDEX 2000)              C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C       FINITE SUM TERMINATING ORDERS
        IF(ITT.EQ.1) THEN
          LAM = LQN(1)+LQN(2)
        ELSEIF(ITT.EQ.2.OR.ITT.EQ.3) THEN
          LAM = LQN(1)+LQN(2)+1
        ELSEIF(ITT.EQ.4) THEN
          LAM = LQN(1)+LQN(2)+2
        ENDIF
C
C       NUMBER OF UNIQUE ADDRESSES IN THIS EXPANSION
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CALCULATE COMPONENT OFFSETS
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     GENERATE OVERLAP MATRICES                                        C
C**********************************************************************C
C
C     OVERLAP TYPE {LL} --> GENERATE ELLQ COEFFICIENTS
      IF(ITT.EQ.1) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELL = TELL+TDM2-TDM1
C     OVERLAP TYPE {LS} --> GENERATE ELSQ COEFFICIENTS
      ELSEIF(ITT.EQ.2) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TELS = TELS+TDM2-TDM1
C     OVERLAP TYPE {SL} --> GENERATE ESLQ COEFFICIENTS
      ELSEIF(ITT.EQ.3) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESL = TESL+TDM2-TDM1
C     OVERLAP TYPE {SS} --> GENERATE ESSQ COEFFICIENTS
      ELSEIF(ITT.EQ.4) THEN
        CALL CPU_TIME(TDM1)
        CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,I1,I2,IQ)
        CALL CPU_TIME(TDM2)
        TESS = TESS+TDM2-TDM1
      ELSE
        WRITE(6, *) 'In VPLNWAV: allowed values are ITT = {1,2,3,4}'
        WRITE(7, *) 'In VPLNWAV: allowed values are ITT = {1,2,3,4}'
        WRITE(6, *) 'ITT = ',ITT
        WRITE(7, *) 'ITT = ',ITT
        STOP
      ENDIF
C
C     CALCULATE OVERLAP MATRIX ELEMENTS
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         EXPONENT COMBINATIONS
          EI  = EXPT(IBAS,1)
          EJ  = EXPT(JBAS,2)
          EIJ = EI+EJ
C
C         GAUSSIAN PRODUCT THEOREM CENTRE OF BASIS FUNCTIONS
          PX = (EI*XYZ(1,1) + EJ*XYZ(1,2))/EIJ
          PY = (EI*XYZ(2,1) + EJ*XYZ(2,2))/EIJ
          PZ = (EI*XYZ(3,1) + EJ*XYZ(3,2))/EIJ
C
C         COORDINATES OF EVALUATION
          PGX = PX-GLOC(1)
          PGY = PY-GLOC(2)
          PGZ = PZ-GLOC(3)
C
C         FACTORS
          ERT = DSQRT(PI/EIJ)**3
          DKP = WAVK(1)*PGX + WAVK(2)*PGY + WAVK(3)*PGZ
          EKP = DCOS(DKP) + CONE*DSIN(DKP)
          EKL = DEXP(-0.25D0*WK2/EIJ)
C
C         LOOP OVER TERMS (A,B,C) IN FINITE EXPANSION
          DO ITUV=1,NTUV
C
C           EXPANSION ADDRESSES
            IA = IVEC(ITUV)
            IB = JVEC(ITUV)
            IC = KVEC(ITUV)
            IL = LAMVEC(ITUV)
C
C           PRODUCT (KX)^A*(KY)^B*(KZ)^C
            EKA = (WAVK(1)**IA)*(WAVK(2)**IB)*(WAVK(3)**IC)
C
C           CONTRIBUTION INVOLVES EKA, CONE**IL AND AN EQ-COEFFICIENT
            TA1 = TA1 + (CONE**IL)*EKA*E11(M,ITUV)
            TA2 = TA2 + (CONE**IL)*EKA*E21(M,ITUV)
C
          ENDDO
C
C         MATRIX ELEMENTS
          VIJ(NA1+IBAS,NB1+JBAS) = ERT*EKP*EKL*TA1
          VIJ(NA2+IBAS,NB1+JBAS) = ERT*EKP*EKL*TA2
          VIJ(NA1+IBAS,NB2+JBAS) =-PHS*DCONJG(VIJ(NA2+IBAS,NB1+JBAS))
          VIJ(NA2+IBAS,NB2+JBAS) = PHS*DCONJG(VIJ(NA1+IBAS,NB1+JBAS))
C
        ENDDO
      ENDDO
C
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     IF EQLS COEFFICIENTS WERE USED, MULTIPLY BY +i
      IF(ITT.EQ.2) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) = CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
C     IF EQSL COEFFICIENTS WERE USED, MULTIPLY BY -i
      IF(ITT.EQ.3) THEN
        DO I=1,NDIM-NSKP
          DO J=1,NDIM-NSKP
            VIJ(I,J) =-CONE*VIJ(I,J)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [11] PLOTS: AMPLITUDES AND FIELDS/POTENTIALS IN DATA FILES.         C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] FIELDS: CALCULATE AMPLITUDES, FIELDS AND POTENTIALS.           C
C   [B] GNUMTRX: EXPORT A MATRIX TO AN EXTERNAL DATA FILE AND PLOT IT. C
C   [C] ORBCOEF: PRINT LIST OF EXPANSION COEFFICIENTS FOR AN ORBITAL.  C
C   [D] AMPLTDE: PLOT A DIRAC SPINOR AMPLITUDE ALONG ONE DIRECTION.    C
C   [E] DENSMAP: HEAT MAP OF ELECTRONIC CHARGE DENSITY (ON A 2D GRID). C
C   [F] J4CRRNT: PLOT 4-CURRENT ALONG ONE DIRECTION.                   C
C   [G] POTENTL: PLOT 4-POTENTIAL ALONG ONE DIRECTION.                 C
C   [H] ELCTRCF: PLOT E FIELD ALONG ONE DIRECTION.                     C
C   [I] MAGNTCF: PLOT B FIELD ALONG ONE DIRECTION.                     C
C   [J] FRMFCTR: PLOT THE ELECTRON SCATTERING FORM FACTOR.             C
C   [K] GNULINE: GENERATE A GNUPLOT LINE PLOT MAKE FILE FOR DATA SET.  C
C   [L] GNUDENS: GENERATE A GNUPLOT MATRIX PLOT MAKE FILE FOR DENSITY. C
C   [M] CLEBSCH: CLEBSCH-GORDAN COEFFICIENT FOR KQN,MQN.               C
C   [N] SPHHRM: VALUE OF Y_L^M AT TWO GIVEN ANGLES.                    C
C   [O] PLGNDR: RETURNS AN ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).    C
C   [P] NFACT: INTEGER RESULT OF FACTORIAL N!                          C
C**********************************************************************C
C
C
      SUBROUTINE FIELDS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          FFFFFFFF IIII EEEEEEEE LL       DDDDDDD   SSSSSS            C
C          FF        II  EE       LL       DD    DD SS    SS           C
C          FF        II  EE       LL       DD    DD SS                 C
C          FFFFFF    II  EEEEEE   LL       DD    DD  SSSSSS            C
C          FF        II  EE       LL       DD    DD       SS           C
C          FF        II  EE       LL       DD    DD SS    SS           C
C          FF       IIII EEEEEEEE LLLLLLLL DDDDDDD   SSSSSS            C
C                                                                      C
C                       CONTROLLING ROUTINE FOR                        C
C                          ** B E R T H A **                           C
C -------------------------------------------------------------------- C
C  FIELDS CALCULATES AMPLITUDES, EM FIELDS AND POTENTIALS, STORES IN   C
C  EXTERNAL DATA FILES AND PLOTS WHEN CALLED.                          C
C -------------------------------------------------------------------- C
C  FOR NOW PLOTS ARE GENERATED ALONG ONE DIRECTION ONLY FOR ELECTRONIC C
C  CONTRIBUTIONS OVER THE WHOLE MOLECULE. THIS CAN BE EXTENDED TO      C
C  SURFACE AND DENSITY PLOTS.                                          C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=4,MKP=9)
C
      CHARACTER*7  PTYPE(10)
      CHARACTER*16 HMS
C
      DIMENSION XYZI(3),XYZF(3),XYZEDGE(3,3)
C
      COMMON/PLOT/NPTYPE,PTYPE
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
      COMMON/TPLT/EMTY
C
C     CALCULATE GAMMA FUNCTION VALUES FOR LATER USE
      CALL GAMGEN
      CALL FACTRLS
C
C     RECORD TIME
      CALL CPU_TIME(TDUM)
C
C     EQ-COEFF AND R-INT TIME INITIALISATION
      TELL = 0.0D0
      TESS = 0.0D0
      TELS = 0.0D0
      TESL = 0.0D0
C
C     CALCULATE MOLECULAR DENSITY
      CALL DENSTY
C
C     LOOP OVER NUMBER OF REQUESTED FIELD PLOTS
      DO N=1,NPTYPE
C
C       PRINT A TITLE
        WRITE(6, *) ' '
        WRITE(7, *) ' '
        WRITE(6, *) 'Plot for PTYPE = ',PTYPE(N)
        WRITE(7, *) 'Plot for PTYPE = ',PTYPE(N)
        WRITE(6, *) REPEAT('=',72)
        WRITE(7, *) REPEAT('=',72)
C
C       NUMBER OF DATA POINTS
        NPTS = 500
C
C       INITIAL AND FINAL COORDINATES
        DO IX=1,3
          XYZI(IX) = 0.0D0
          XYZF(IX) = 0.0D0
        ENDDO
        XYZI(3) =-1.00D0
        XYZF(3) = 2.40D0
C
        IF(PTYPE(N).EQ.'ORBCOEF') THEN
          CALL ORBCOEF(NSKP+5)
        ELSEIF(PTYPE(N).EQ.'AMPLTDE') THEN
          CALL AMPLTDE(XYZI,XYZF,NPTS,NSKP+9)
        ELSEIF(PTYPE(N).EQ.'DENSMAP') THEN
          NHRZ = 400
          NVRT = 600
          DO IX=1,3
            DO IEDGE=1,3
              XYZEDGE(IX,IEDGE) = 0.0D0
            ENDDO
          ENDDO
          XYZEDGE(1,1) =-0.7D0
          XYZEDGE(3,1) =-0.7D0
          XYZEDGE(1,2) =-0.7D0
          XYZEDGE(3,2) = 0.7D0
          XYZEDGE(1,3) =-0.7D0
          XYZEDGE(3,3) = 2.1D0
          CALL DENSMAP(XYZEDGE,NHRZ,NVRT)
        ELSEIF(PTYPE(N).EQ.'J4CRRNT') THEN
          CALL J4CRRNT(XYZI,XYZF,NPTS)
        ELSEIF(PTYPE(N).EQ.'POTENTL') THEN
          CALL POTENTL(XYZI,XYZF,NPTS)
        ELSEIF(PTYPE(N).EQ.'ELCTRCF') THEN
          CALL ELCTRCF(XYZI,XYZF,NPTS)
        ELSEIF(PTYPE(N).EQ.'MAGNTCF') THEN
          CALL MAGNTCF(XYZI,XYZF,NPTS)
        ELSEIF(PTYPE(N).EQ.'FRMFCTR') THEN
          CALL FRMFCTR(XYZI,XYZF,NPTS)
        ELSE
          WRITE(6, *) 'In FIELDS: plotting option is not available.'
          WRITE(7, *) 'In FIELDS: plotting option is not available.'
        ENDIF
C
C     END LOOP OVER FIELD PLOTS
      ENDDO
C
C     TOTAL TIME TAKEN
      CALL CPU_TIME(TPLT)
      TPLT = TPLT-TDUM
C
20    FORMAT(1X,A,37X,A)
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
      IF(TELL.LT.0.3D0) THEN
        WRITE(6,20) 'Time in EMAKE (LL):',HMS(TELL)
        WRITE(7,20) 'Time in EMAKE (LL):',HMS(TELL)
      ENDIF
      IF(TELS.LT.0.3D0) THEN
        WRITE(6,20) 'Time in EMAKE (LS):',HMS(TELS)
        WRITE(7,20) 'Time in EMAKE (LS):',HMS(TELS)
      ENDIF
      IF(TESL.LT.0.3D0) THEN
        WRITE(6,20) 'Time in EMAKE (SL):',HMS(TESL)
        WRITE(7,20) 'Time in EMAKE (SL):',HMS(TESL)
      ENDIF
      IF(TESS.LT.0.3D0) THEN
        WRITE(6,20) 'Time in EMAKE (SS):',HMS(TESS)
        WRITE(7,20) 'Time in EMAKE (SS):',HMS(TESS)
      ENDIF
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
      RETURN
      END
C
C
      SUBROUTINE GNUMTRX(ARRAY,TITLE,NDIM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   GGGGGG  NN    NN UU    UU MM       MM TTTTTTTT RRRRRRR  XX     XX  C
C  GG    GG NNN   NN UU    UU MMM     MMM    TT    RR    RR  XX   XX   C
C  GG       NNNN  NN UU    UU MMMM   MMMM    TT    RR    RR   XX XX    C
C  GG       NN NN NN UU    UU MM MM MM MM    TT    RR    RR    XXX     C
C  GG   GGG NN  NNNN UU    UU MM  MMM  MM    TT    RRRRRRR    XX XX    C
C  GG    GG NN   NNN UU    UU MM   M   MM    TT    RR    RR  XX   XX   C
C   GGGGGG  NN    NN  UUUUUU  MM       MM    TT    RR    RR XX     XX  C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNUMTRX EXPORTS AN ARRAY TO AN EXTERNAL DATA FILE AND PLOTS IT.     C
C**********************************************************************C
      PARAMETER(MDM=1200)
C
      CHARACTER*80 TITLE
C
      DIMENSION ARRAY(MDM,MDM)
C
C     PRINT TO EXTERNAL DATA FILE
      OPEN(UNIT=8,FILE="plots/"//TRIM(TITLE)//".dat",STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO I=1,NDIM
        WRITE(8, *) (ARRAY(I,J),J=1,NDIM)
      ENDDO
      CLOSE(UNIT=8)
C
      XEND = DFLOAT(NDIM)-0.5D0
      YEND = DFLOAT(NDIM)-0.5D0
C
C     WRITE GNUPLOT MAKE FILE
      OPEN(UNIT=9,FILE='plots/'//TRIM(TITLE)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(TITLE)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(TITLE)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf size 4,4'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(TITLE)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') 'load "plots/pals/rdylgn.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A,F6.1,A)') 'set xrange [-0.5:',XEND,']'
      WRITE(9,'(A,F6.1,A)') 'set yrange [',YEND,':-0.5] reverse'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(TITLE)//'.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(TITLE)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(TITLE)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE ORBCOEF(IORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      OOOOOO  RRRRRRR  BBBBBBB   CCCCCC   OOOOOO  EEEEEEE FFFFFFF     C
C     OO    OO RR    RR BB    BB CC    CC OO    OO EE      FF          C
C     OO    OO RR    RR BB    BB CC       OO    OO EE      FF          C
C     OO    OO RR    RR BBBBBBB  CC       OO    OO EEEEE   FFFFF       C
C     OO    OO RRRRRRR  BB    BB CC       OO    OO EE      FF          C
C     OO    OO RR    RR BB    BB CC    CC OO    OO EE      FF          C
C      OOOOOO  RR    RR BBBBBBB   CCCCCC   OOOOOO  EEEEEEE FF          C
C                                                                      C
C -------------------------------------------------------------------- C
C  ORBCOEF PRINTS OUT THE EXPANSION COEFFICIENTS FOR IORB, GROUPED     C
C  BY QUANTUM NUMBERS OF BASIS FUNCTIONS.                              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*2 ELMT(120),ELA
C
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/MDLV/ELMT
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C     HEADER FOR COEFFICIENT LIST
20    FORMAT(1X,'****************',A,I3,'  ****************')
21    FORMAT(1X,'Centre ',I2,4X,'(',A,')',5X,'#fns = ',I2,6X,'KQN =',
     &                           I2,6X,'LQN = ',I1,6X,'MQN =',A,I1,'/2')
22    FORMAT(1X,'IADD',9X,'Exponent',10X,A,7X,A)
23    FORMAT(1X,I4,4X,ES13.6,10X,ES17.10,7X,ES17.10)
      WRITE(6,20) '  Expansion coefficients for IORB =',IORB
      WRITE(7,20) '  Expansion coefficients for IORB =',IORB
C
      I = IORB
C
C     LOOP OVER ATOMIC CENTRES
      DO ICNT=1,NCNT
C
C       SAVE ELEMENT LABEL
        ELA = ELMT(IZNC(ICNT))
C
C       LOOP OVER ALL MQNS FOR THIS CENTRE
        MMAX = LMAX(ICNT)+1
        DO IM=1,MMAX
C
C         MAGNITUDE OF THIS MQN
          MQN = 2*IM-1
C
C         MQN < 0: LOOP OVER ALL KQN WITH THIS |MQN|
          DO IK=MQN,NKAP(ICNT)
C
C           LARGE-COMPONENT ADDRESS OFFSET
            IAD = LRGE(ICNT,IK,MQN  )
C
C           LQN AND KQN VALUES
            IF(MOD(IK,2).EQ.0) THEN
              KQN = IK/2
              LQN = KQN
            ELSE
              KQN =-(IK+1)/2
              LQN =-KQN-1
            ENDIF
C
C           NUMBER OF BASIS FUNCTIONS FOR THIS LQN
            NBAS = NFNC(LQN+1,ICNT)
C
C           ATOMIC ADDRESS DETAILS
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,21) ICNT,ELA,NBAS,KQN,LQN,'-',MQN
            WRITE(7,21) ICNT,ELA,NBAS,KQN,LQN,'-',MQN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(7,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
C
C           LIST THE EXPONENTS AND CORRESPONDING EXP. COEFFS
            DO IBAS=1,NBAS
              CL = DREAL(COEF(IAD+IBAS     ,IORB))
              CS = DREAL(COEF(IAD+IBAS+NSKP,IORB))
              WRITE(6,23) IAD+IBAS,BSET(IBAS,LQN+1,ICNT),CL,CS
              WRITE(7,23) IAD+IBAS,BSET(IBAS,LQN+1,ICNT),CL,CS
            ENDDO
          ENDDO
C
C         MQN > 0: LOOP OVER ALL KQN WITH THIS |MQN|
          DO IK=MQN,NKAP(ICNT)
C
C           LARGE-COMPONENT ADDRESS OFFSET
            IAD = LRGE(ICNT,IK,MQN+1)
C
C           LQN AND KQN VALUES
            IF(MOD(IK,2).EQ.0) THEN
              KQN = IK/2
              LQN = KQN
            ELSE
              KQN =-(IK+1)/2
              LQN =-KQN-1
            ENDIF
C
C           NUMBER OF BASIS FUNCTIONS FOR THIS LQN
            NBAS = NFNC(LQN+1,ICNT)
C
C           ATOMIC ADDRESS DETAILS
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,21) ICNT,ELA,NBAS,KQN,LQN,'+',MQN
            WRITE(7,21) ICNT,ELA,NBAS,KQN,LQN,'+',MQN
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
            WRITE(6,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(7,22) 'Re(CL(IADD,IORB))','Re(CS(IADD,IORB))'
            WRITE(6, *) REPEAT('-',72)
            WRITE(7, *) REPEAT('-',72)
C
C           LIST THE EXPONENTS AND CORRESPONDING EXP. COEFFS
            DO IBAS=1,NBAS
              CL = DREAL(COEF(IAD+IBAS     ,IORB))
              CS = DREAL(COEF(IAD+IBAS+NSKP,IORB))
              WRITE(6,23) IAD+IBAS,BSET(IBAS,LQN+1,ICNT),CL,CS
              WRITE(7,23) IAD+IBAS,BSET(IBAS,LQN+1,ICNT),CL,CS
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE AMPLTDE(XYZI,XYZF,NPTS,IORB)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      AA    MM       MM PPPPPPP  LL      TTTTTTTT DDDDDDD  EEEEEEEE   C
C     AAAA   MMM     MMM PP    PP LL         TT    DD    DD EE         C
C    AA  AA  MMMM   MMMM PP    PP LL         TT    DD    DD EE         C
C   AA    AA MM MM MM MM PP    PP LL         TT    DD    DD EEEEEE     C
C   AAAAAAAA MM  MMM  MM PPPPPPP  LL         TT    DD    DD EE         C
C   AA    AA MM   M   MM PP       LL         TT    DD    DD EE         C
C   AA    AA MM       MM PP       LLLLLLLL   TT    DDDDDDD  EEEEEEEE   C
C                                                                      C
C -------------------------------------------------------------------- C
C  AMPLTDE GENERATES A DATA SET AND GNUPLOT MAKE FILE FOR THE DIRAC    C
C  SPINOR AMPLITUDE OF ORBITAL IORB, ALONG THE Z-AXIS.                 C
C -------------------------------------------------------------------- C
C  DFNOTE: NOT FINISHED.                                               C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      DIMENSION EXPT(MBS),XYZ(3)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
C
      COMPLEX*16 CONE,SPHHRM,CHI1,CHI2,CHI3,CHI4
      COMPLEX*16 PSI(4,0:NPTS)
      COMPLEX*16 COEF(MDM,MDM)
C
      COMMON/EIGC/COEF
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/GAMA/GAMLOG(50),GAMHLF(50)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
      DATA PI,TWOLOG/3.1415926535897932D0,6.93147180559945309D-1/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     GENERATE GAMMA FUNCTION VALUES
      CALL GAMGEN
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO MU=1,4
          PSI(MU,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER NUCLEAR CENTRES
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE
        XYZ(1) = BXYZ(1,ICNTA)
        XYZ(2) = BXYZ(2,ICNTA)
        XYZ(3) = BXYZ(3,ICNTA)
C
C     LOOP OVER KQN VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       ORBITAL QUANTUM NUMBERS
        KQN = KAPA(KA,ICNTA)
        JQN = 2*IABS(KQN)-1
        IF(KQN.LT.0) THEN
          LQN =-KQN-1
        ELSE
          LQN = KQN
        ENDIF
C
C       BASIS EXPONENTS
        NBAS = NFNC(LQN+1,ICNTA)
        DO IBAS=1,NBAS
          EXPT(IBAS) = BSET(IBAS,LQN+1,ICNTA)
        ENDDO
C
C     LOOP OVER |MQN| VALUES
      DO 3000 MA=1,IABS(KQN)
        MJA = 2*MA-1
        MQN = MJA
C
C     EXPANSION COEFFICIENT MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       LOCAL CARTESIAN COORDINATES FOR THIS NUCLEAR CENTRE
        X = XYZEVAL(1)-XYZ(1)
        Y = XYZEVAL(2)-XYZ(2)
        Z = XYZEVAL(3)-XYZ(3)
C
C       LOCAL SPHERICAL COORDINATES FOR THIS NUCLEAR CENTRE
        RAD = DSQRT(X*X+Y*Y+Z*Z)
        THE = DACOS(Z/RAD)
        PHI = DATAN(Y/X)
C
C       PRE-FACTORS FOR NORMALISATION CONSTANTS
        RL = DFLOAT(LQN)
        G1 = TWOLOG-GAMLOG(2*LQN+3)
        G2 = TWOLOG-GAMLOG(2*LQN+5)
        R1 = RL+1.5D0
        R2 = RL+0.5D0
C
C       LOOP OVER BASIS FUNCTIONS
        DO IBAS=1,NBAS
C
C         NORMALISATION CONSTANTS
          ELOG = DLOG(2.0D0*EXPT(IBAS))
          RNL  = DEXP(0.5D0*(G1+R1*ELOG))
          RNS  = DEXP(0.5D0*(G2+R2*ELOG))
C
C         LARGE AND SMALL RADIAL AMPLITUDES
          FL = RNL*(RAD**(LQN+1))*DEXP(-EXPT(IBAS)*RAD*RAD)
          FS = RNS*(KQN+LQN+1.0D0-2.0D0*EXPT(IBAS)*RAD*RAD)
     &                          *(RAD**(LQN))*DEXP(-EXPT(IBAS)*RAD*RAD)
C
C         CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
          IF(KQN.LT.0) THEN
            CLU  = DSQRT(DFLOAT(JQN+MQN  )/DFLOAT(2*JQN  ))
            CLL  = DSQRT(DFLOAT(JQN-MQN  )/DFLOAT(2*JQN  ))
            CSU  =-DSQRT(DFLOAT(JQN-MQN+2)/DFLOAT(2*JQN+4))
            CSL  = DSQRT(DFLOAT(JQN+MQN+2)/DFLOAT(2*JQN+4))
            CHI1 = CLU*SPHHRM(THE,PHI,(JQN+1)/2,(MQN-1)/2)
            CHI2 = CLL*SPHHRM(THE,PHI,(JQN+1)/2,(MQN+1)/2)
c            CHI3 = CSU*SPHHRM(THE,PHI,(JQN+1)/2,(MQN-1)/2)
c            CHI4 = CSL*SPHHRM(THE,PHI,(JQN+1)/2,(MQN+1)/2)
            CHI3 = CONE
            CHI4 = CONE
          ELSE
            CLU  =-DSQRT(DFLOAT(JQN-MQN+2)/DFLOAT(2*JQN+4))
            CLL  = DSQRT(DFLOAT(JQN+MQN+2)/DFLOAT(2*JQN+4))
            CSU  = DSQRT(DFLOAT(JQN+MQN  )/DFLOAT(2*JQN  ))
            CSL  = DSQRT(DFLOAT(JQN-MQN  )/DFLOAT(2*JQN  ))
            CHI1 = CLU*SPHHRM(THE,PHI,(JQN+1)/2,(MQN-1)/2)
            CHI2 = CLL*SPHHRM(THE,PHI,(JQN+1)/2,(MQN+1)/2)
C            CHI1 = CLU*SPHHRM(THE,PHI,(JQN-1)/2,(MQN-1)/2)
C            CHI2 = CLL*SPHHRM(THE,PHI,(JQN-1)/2,(MQN+1)/2)
c            CHI3 = CSU*SPHHRM(THE,PHI,(JQN-1)/2,(MQN-1)/2)
c            CHI4 = CSL*SPHHRM(THE,PHI,(JQN-1)/2,(MQN+1)/2)
            CHI3 = CONE
            CHI4 = CONE
          ENDIF
C
C         ADDRESS OFFSETS FOR SMALL-COMPONENTS
          KBAS = IBAS+NSKP
C
C         MULTIPLY BY CORRESPONDING EXPANSION COEFFICIENT ELEMENTS
          PSI(1,IPTS) = PSI(1,IPTS) + COEF(NA1+IBAS,IORB)*FL*CHI1/RAD
          PSI(2,IPTS) = PSI(2,IPTS) + COEF(NA2+IBAS,IORB)*FL*CHI2/RAD
C
          IF(HMLT.EQ.'NORL') GOTO 100
C
          PSI(3,IPTS) = PSI(3,IPTS) + COEF(NA1+KBAS,IORB)*FS*CHI3/RAD
          PSI(4,IPTS) = PSI(4,IPTS) + COEF(NA2+KBAS,IORB)*FS*CHI4/RAD
C          
100       CONTINUE
C
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS QUANTUM NUMBERS
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'AMPLTDE'
      TITLE  = 'Amplitude for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{/Symbol y}(z)'
      KEY(1) = '{/Symbol y}^{L}_{u}(z)'
      KEY(2) = '{/Symbol y}^{L}_{d}(z)'
      KEY(3) = '{/Symbol y}^{S}_{u}(z)'
      KEY(4) = '{/Symbol y}^{S}_{d}(z)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(ABS(PSI(MU,IPTS)),MU=1,4)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE DENSMAP(XYZEDGE,NHRZ,NVTC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  DDDDDDD  EEEEEEEE NN    NN  SSSSSS  MM       MM    AA    PPPPPPP    C
C  DD    DD EE       NNN   NN SS    SS MMM     MMM   AAAA   PP    PP   C
C  DD    DD EE       NNNN  NN SS       MMMM   MMMM  AA  AA  PP    PP   C
C  DD    DD EEEEEE   NN NN NN  SSSSSS  MM MM MM MM AA    AA PP    PP   C
C  DD    DD EE       NN  NNNN       SS MM  MMM  MM AAAAAAAA PPPPPPP    C
C  DD    DD EE       NN   NNN SS    SS MM   M   MM AA    AA PP         C
C  DDDDDDD  EEEEEEEE NN    NN  SSSSSS  MM       MM AA    AA PP         C
C                                                                      C
C -------------------------------------------------------------------- C
C  DENSMAP GENERATES AND PLOTS A RECTANGULAR ARRAY OF VALUES FOR THE   C
C  ELECTRON CHARGE DENSITY FROM AN SCF SOLUTION. (CHARGE DENSITY IS    C
C  SAVED ON A LOG SCALE TO MAKE VALENCE REGION MORE VISIBLE.)          C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9,MB2=MBS*MBS,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZEDGE(3,3),XYZD(3),XYZEVAL(3),STPHRZ(3),STPVTC(3)
      DIMENSION CART(3,0:NHRZ,0:NVTC)
C
      COMPLEX*16 T11,T12,T21,T22,S11,S12,S21,S22
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ)
      COMPLEX*16 DMAP(0:NHRZ,0:NVTC)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       SELECT AN APPROPRIATE HORIZONAL STEP VALUE (EQUALLY-SPACED GRID)
        IF(NHRZ.EQ.0) THEN
          STPHRZ(IX) = 0.0D0
        ELSE
          STPHRZ(IX) = (XYZEDGE(IX,2)-XYZEDGE(IX,1))/DFLOAT(NHRZ)
        ENDIF
C
C       SELECT AN APPROPRIATE VERTICAL STEP VALUE (EQUALLY-SPACED GRID)
        IF(NVTC.EQ.0) THEN
          STPVTC(IX) = 0.0D0
        ELSE
          STPVTC(IX) = (XYZEDGE(IX,3)-XYZEDGE(IX,1))/DFLOAT(NVTC)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NHRZ
          DO JPTS=0,NVTC
            CART(IX,IPTS,JPTS) = XYZEDGE(IX,1) + IPTS*STPHRZ(IX)
     &                                         + JPTS*STPVTC(IX)
          ENDDO
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NHRZ
        DO JPTS=0,NVTC
          DMAP(IPTS,JPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKELL(ELL011,ELL021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKESS(ESS011,ESS021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NHRZ
        DO JPTS=0,NVTC
C
C         SPECIFY CARTESIAN COORDINATES
          DO IX=1,3
            XYZEVAL(IX) = CART(IX,IPTS,JPTS)
          ENDDO
C
C         GENERATE A BATCH OF HGTFS FOR THIS LOCATION
          IF(HMLT.EQ.'NORL') THEN
            CALL HGTFS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAMLL)
          ELSE
            CALL HGTFS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAMSS)
          ENDIF
C
C         LOOP OVER BASIS FUNCTION PAIRS
          M = 0
          DO IBAS=1,NBAS(1)
            DO JBAS=1,NBAS(2)
              M = M+1
C
C             INITIALISE THE CARTESIAN EXPANSION COUNTERS
              T11 = DCMPLX(0.0D0,0.0D0)
              T12 = DCMPLX(0.0D0,0.0D0)
              T21 = DCMPLX(0.0D0,0.0D0)
              T22 = DCMPLX(0.0D0,0.0D0)
              S11 = DCMPLX(0.0D0,0.0D0)
              S12 = DCMPLX(0.0D0,0.0D0)
              S21 = DCMPLX(0.0D0,0.0D0)
              S22 = DCMPLX(0.0D0,0.0D0)
C
C             ADDRESS OFFSETS FOR SMALL-COMPONENTS
              KBAS = IBAS+NSKP
              LBAS = JBAS+NSKP
C
C             ELL0
              DO ITUV=1,NTUVLL
                T11 = T11 +            ELL011(M,ITUV)*HABC(M,ITUV)
                T12 = T12 - PHS*DCONJG(ELL021(M,ITUV)*HABC(M,ITUV))
                T21 = T21 +            ELL021(M,ITUV)*HABC(M,ITUV)
                T22 = T22 + PHS*DCONJG(ELL011(M,ITUV)*HABC(M,ITUV))
              ENDDO
C
C             MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
              DMAP(IPTS,JPTS) = DMAP(IPTS,JPTS)
     &                                   + DENT(NA1+IBAS,NB1+JBAS)*T11
     &                                   + DENT(NA1+IBAS,NB2+JBAS)*T12
     &                                   + DENT(NA2+IBAS,NB1+JBAS)*T21
     &                                   + DENT(NA2+IBAS,NB2+JBAS)*T22
C
              IF(HMLT.EQ.'NORL') GOTO 100
C
C             ESS0
              DO ITUV=1,NTUVSS
                S11 = S11 +            ESS011(M,ITUV)*HABC(M,ITUV)
                S12 = S12 - PHS*DCONJG(ESS021(M,ITUV)*HABC(M,ITUV))
                S21 = S21 +            ESS021(M,ITUV)*HABC(M,ITUV)
                S22 = S22 + PHS*DCONJG(ESS011(M,ITUV)*HABC(M,ITUV))
              ENDDO
C
C             MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
              DMAP(IPTS,JPTS) = DMAP(IPTS,JPTS)
     &                                   + DENT(NA1+KBAS,NB1+LBAS)*S11
     &                                   + DENT(NA1+KBAS,NB2+LBAS)*S12
     &                                   + DENT(NA2+KBAS,NB1+LBAS)*S21
     &                                   + DENT(NA2+KBAS,NB2+LBAS)*S22
C          
100           CONTINUE
C
            ENDDO
          ENDDO
C
C       CLOSE LOOP OVER GRID COORDINATES
        ENDDO
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'DENSMAP'
      TITLE  = 'DENSMAP'//' for '//TRIM(MOLCL)//' of type '//HMLT
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NHRZ
C
C         SAVE MATRIX ELEMENTS
          WRITE(8,*) (DLOG(DREAL(DMAP(IPTS,JPTS))),JPTS=0,NVTC)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NHRZ.EQ.0.OR.NVTC.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNUDENS(XOUT,TITLE,NHRZ,NVTC)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE J4CRRNT(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        JJJJJ    44    CCCCCC  RRRRRRR  RRRRRRR  NN    NN TTTTTTTT    C
C          JJ    44    CC    CC RR    RR RR    RR NNN   NN    TT       C
C          JJ   44     CC       RR    RR RR    RR NNNN  NN    TT       C
C          JJ  44 44   CC       RR    RR RR    RR NN NN NN    TT       C
C          JJ 44444444 CC       RRRRRRR  RRRRRRR  NN  NNNN    TT       C
C    JJ    JJ     44   CC    CC RR    RR RR    RR NN   NNN    TT       C
C     JJJJJJ      44    CCCCCC  RR    RR RR    RR NN    NN    TT       C
C                                                                      C
C -------------------------------------------------------------------- C
C  J4CRRNT CREATES A PLOT OF THE ELECTRONIC 4-CURRENT BETWEEN BXYZS   C
C  XYZI(3) AND XYZF(3), IN A STRAIGHT LINE, WITH NPTS DATA POINTS.     C
C  THIS METHOD USES EQ-COEFFICIENTS AND THE GAUSSIAN PRODUCT THEOREM.  C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9,MB2=MBS*MBS,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
C
      COMPLEX*16 CONE,T11(8),T12(8),T21(8),T22(8)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ),
     &           ELSX11(MB2,MEQ),ELSX21(MB2,MEQ),
     &           ELSY11(MB2,MEQ),ELSY21(MB2,MEQ),
     &           ELSZ11(MB2,MEQ),ELSZ21(MB2,MEQ),
     &           ESLX11(MB2,MEQ),ESLX21(MB2,MEQ),
     &           ESLY11(MB2,MEQ),ESLY21(MB2,MEQ),
     &           ESLZ11(MB2,MEQ),ESLZ21(MB2,MEQ)
      COMPLEX*16 CURRNT(0:3,0:NPTS)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     SET THIS TO ZERO IF YOU ONLY WANT THE CHARGE DENSITY
      JTOG = 0
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO MU=0,3
          CURRNT(MU,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMLS = LQN(1)+LQN(2)+1
      LAMSL = LQN(1)+LQN(2)+1
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKELL(ELL011,ELL021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKESS(ESS011,ESS021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
      IF(JTOG.EQ.0) GOTO 50
C
C     ELSX, ELSY AND ELSZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKELS(ELSX11,ELSX21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EMAKELS(ELSY11,ELSY21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EMAKELS(ELSZ11,ELSZ21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     ESLX, ESLY AND ESLZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKESL(ESLX11,ESLX21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EMAKESL(ESLY11,ESLY21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EMAKESL(ESLZ11,ESLZ21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TESL = TESL+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       GENERATE A BATCH OF HGTFS FOR THIS LOCATION
        IF(HMLT.EQ.'NORL') THEN
          CALL HGTFS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAMLL)
        ELSE
          CALL HGTFS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAMSS)
        ENDIF
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,8
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C     CHARGE DENSITY RHO(X,Y,Z)                                        C
C**********************************************************************C
C
C           ELL0
            DO ITUV=1,NTUVLL
              T11(1) = T11(1) +            ELL011(M,ITUV)*HABC(M,ITUV)
              T12(1) = T12(1) - PHS*DCONJG(ELL021(M,ITUV)*HABC(M,ITUV))
              T21(1) = T21(1) +            ELL021(M,ITUV)*HABC(M,ITUV)
              T22(1) = T22(1) + PHS*DCONJG(ELL011(M,ITUV)*HABC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            CURRNT(0,IPTS) = CURRNT(0,IPTS)
     &                      - DENT(NA1+IBAS,NB1+JBAS)*T11(1)
     &                      - DENT(NA1+IBAS,NB2+JBAS)*T12(1)
     &                      - DENT(NA2+IBAS,NB1+JBAS)*T21(1)
     &                      - DENT(NA2+IBAS,NB2+JBAS)*T22(1)
C
            IF(HMLT.EQ.'NORL') GOTO 100
C
C           ESS0
            DO ITUV=1,NTUVSS
              T11(2) = T11(2) +            ESS011(M,ITUV)*HABC(M,ITUV)
              T12(2) = T12(2) - PHS*DCONJG(ESS021(M,ITUV)*HABC(M,ITUV))
              T21(2) = T21(2) +            ESS021(M,ITUV)*HABC(M,ITUV)
              T22(2) = T22(2) + PHS*DCONJG(ESS011(M,ITUV)*HABC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            CURRNT(0,IPTS) = CURRNT(0,IPTS)
     &                      - DENT(NA1+KBAS,NB1+LBAS)*T11(2)
     &                      - DENT(NA1+KBAS,NB2+LBAS)*T12(2)
     &                      - DENT(NA2+KBAS,NB1+LBAS)*T21(2)
     &                      - DENT(NA2+KBAS,NB2+LBAS)*T22(2)
C
            IF(JTOG.EQ.0) GOTO 100
C
C**********************************************************************C
C     CURRENT DENSITY VECTOR J_X(X,Y,Z)                                C
C**********************************************************************C
C
C           ELSX, ELSY AND ELSZ
            DO ITUV=1,NTUVLS
              T11(3) = T11(3) +            ELSX11(M,ITUV)*HABC(M,ITUV)
              T12(3) = T12(3) - PHS*DCONJG(ELSX21(M,ITUV)*HABC(M,ITUV))
              T21(3) = T21(3) +            ELSX21(M,ITUV)*HABC(M,ITUV)
              T22(3) = T22(3) + PHS*DCONJG(ELSX11(M,ITUV)*HABC(M,ITUV))
              T11(4) = T11(4) +            ELSY11(M,ITUV)*HABC(M,ITUV)
              T12(4) = T12(4) - PHS*DCONJG(ELSY21(M,ITUV)*HABC(M,ITUV))
              T21(4) = T21(4) +            ELSY21(M,ITUV)*HABC(M,ITUV)
              T22(4) = T22(4) + PHS*DCONJG(ELSY11(M,ITUV)*HABC(M,ITUV))
              T11(5) = T11(5) +            ELSZ11(M,ITUV)*HABC(M,ITUV)
              T12(5) = T12(5) - PHS*DCONJG(ELSZ21(M,ITUV)*HABC(M,ITUV))
              T21(5) = T21(5) +            ELSZ21(M,ITUV)*HABC(M,ITUV)
              T22(5) = T22(5) + PHS*DCONJG(ELSZ11(M,ITUV)*HABC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (+i FOR EQLS)
            CURRNT(1,IPTS) = CURRNT(1,IPTS)
     &                      - CONE*DENT(NA1+IBAS,NB1+LBAS)*T11(3)
     &                      - CONE*DENT(NA1+IBAS,NB2+LBAS)*T12(3)
     &                      - CONE*DENT(NA2+IBAS,NB1+LBAS)*T21(3)
     &                      - CONE*DENT(NA2+IBAS,NB2+LBAS)*T22(3)
            CURRNT(2,IPTS) = CURRNT(2,IPTS)
     &                      - CONE*DENT(NA1+IBAS,NB1+LBAS)*T11(4)
     &                      - CONE*DENT(NA1+IBAS,NB2+LBAS)*T12(4)
     &                      - CONE*DENT(NA2+IBAS,NB1+LBAS)*T21(4)
     &                      - CONE*DENT(NA2+IBAS,NB2+LBAS)*T22(4)
            CURRNT(3,IPTS) = CURRNT(3,IPTS)
     &                      - CONE*DENT(NA1+IBAS,NB1+LBAS)*T11(5)
     &                      - CONE*DENT(NA1+IBAS,NB2+LBAS)*T12(5)
     &                      - CONE*DENT(NA2+IBAS,NB1+LBAS)*T21(5)
     &                      - CONE*DENT(NA2+IBAS,NB2+LBAS)*T22(5)
C
C           ESLX, ESLY AND ESLZ
            DO ITUV=1,NTUVSL
              T11(6) = T11(6) +            ESLX11(M,ITUV)*HABC(M,ITUV)
              T12(6) = T12(6) - PHS*DCONJG(ESLX21(M,ITUV)*HABC(M,ITUV))
              T21(6) = T21(6) +            ESLX21(M,ITUV)*HABC(M,ITUV)
              T22(6) = T22(6) + PHS*DCONJG(ESLX11(M,ITUV)*HABC(M,ITUV))
              T11(7) = T11(7) +            ESLY11(M,ITUV)*HABC(M,ITUV)
              T12(7) = T12(7) - PHS*DCONJG(ESLY21(M,ITUV)*HABC(M,ITUV))
              T21(7) = T21(7) +            ESLY21(M,ITUV)*HABC(M,ITUV)
              T22(7) = T22(7) + PHS*DCONJG(ESLY11(M,ITUV)*HABC(M,ITUV))
              T11(8) = T11(8) +            ESLZ11(M,ITUV)*HABC(M,ITUV)
              T12(8) = T12(8) - PHS*DCONJG(ESLZ21(M,ITUV)*HABC(M,ITUV))
              T21(8) = T21(8) +            ESLZ21(M,ITUV)*HABC(M,ITUV)
              T22(8) = T22(8) + PHS*DCONJG(ESLZ11(M,ITUV)*HABC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (-i FOR EQSL)
            CURRNT(1,IPTS) = CURRNT(1,IPTS)
     &                      + CONE*DENT(NA1+KBAS,NB1+JBAS)*T11(6)
     &                      + CONE*DENT(NA1+KBAS,NB2+JBAS)*T12(6)
     &                      + CONE*DENT(NA2+KBAS,NB1+JBAS)*T21(6)
     &                      + CONE*DENT(NA2+KBAS,NB2+JBAS)*T22(6)
            CURRNT(2,IPTS) = CURRNT(2,IPTS)
     &                      + CONE*DENT(NA1+KBAS,NB1+JBAS)*T11(7)
     &                      + CONE*DENT(NA1+KBAS,NB2+JBAS)*T12(7)
     &                      + CONE*DENT(NA2+KBAS,NB1+JBAS)*T21(7)
     &                      + CONE*DENT(NA2+KBAS,NB2+JBAS)*T22(7)
            CURRNT(3,IPTS) = CURRNT(3,IPTS)
     &                      + CONE*DENT(NA1+KBAS,NB1+JBAS)*T11(8)
     &                      + CONE*DENT(NA1+KBAS,NB2+JBAS)*T12(8)
     &                      + CONE*DENT(NA2+KBAS,NB1+JBAS)*T21(8)
     &                      + CONE*DENT(NA2+KBAS,NB2+JBAS)*T22(8)
C          
100         CONTINUE
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     CURRENT-DENSITY ENTRIES MUST BE MULTIPLIED BY CONE*CV
      DO IX=1,3
        DO IPTS=1,NPTS
          CURRNT(IX,IPTS) = CV*CONE*CURRNT(IX,IPTS)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     NUCLEAR CENTRE CONTRIBUTIONS (CAN SKIP THIS PART)                C
C**********************************************************************C
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       BEGIN LOOP OVER ALL NUCLEAR CENTRES UP TO NCNT
        DO ICNT=1,NCNT
C
C         NUCLEAR WIDTH EXPONENTS
          EXPT(1,1) = CNUC(ICNT)
          EXPT(1,2) = 0.0D0
C
C         LIST DIMENSION
          NBAS(1) = 1
          NBAS(2) = 1
C
C         CARTESIAN COORDINATES OF CENTRE A
          XYZ(1,1) = BXYZ(1,ICNT)
          XYZ(2,1) = BXYZ(2,ICNT)
          XYZ(3,1) = BXYZ(3,ICNT)
C
C         CARTESIAN COORDINATES OF CENTRE B
          XYZ(1,2) = 0.0D0
          XYZ(2,2) = 0.0D0
          XYZ(3,2) = 0.0D0
C
C         GENERATE A BATCH OF HGTFS FOR THIS LOCATION
          CALL HGTFS(HABC,XYZEVAL,EXPT,XYZ,NBAS,0)
C
C         PRE-FACTOR FOR NUCLEAR CHARGE AND WIDTH
          GSFC = DSQRT(CNUC(ICNT)/PI)
          GSFC = ZNUC(ICNT)*(GSFC**3)
C
C         ADD VALUE OF DENSITY AT THESE COORDINATES TO DATA BIN
          CURRNT(0,IPTS) = CURRNT(0,IPTS) + GSFC*HABC(1,1)
C
C       END LOOP OVER NUCLEAR CENTRES
        ENDDO
C
C     END LOOP OVER ALL GRID COORDINATES
      ENDDO
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'J4CRRNT'
      TITLE  = 'J4CRRNT'//' for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'd (a.u.)'
      YAXIS  = '{j}_{/Symbol u}(d)'
      KEY(1) = '{/Symbol r}(d)'
      KEY(2) = 'j_{x}(d)'
      KEY(3) = 'j_{y}(d)'
      KEY(4) = 'j_{z}(d)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(DREAL(CURRNT(MU,IPTS)),MU=0,3)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE POTENTL(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     PPPPPPP   OOOOOO TTTTTTTT EEEEEEEE NN    NN TTTTTTTT LL          C
C     PP    PP OO    OO   TT    EE       NNN   NN    TT    LL          C
C     PP    PP OO    OO   TT    EE       NNNN  NN    TT    LL          C
C     PP    PP OO    OO   TT    EEEEEE   NN NN NN    TT    LL          C
C     PPPPPPP  OO    OO   TT    EE       NN  NNNN    TT    LL          C
C     PP       OO    OO   TT    EE       NN   NNN    TT    LL          C
C     PP        OOOOOO    TT    EEEEEEEE NN    NN    TT    LLLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  POTENTL CREATES A PLOT OF THE 4-POTENTIAL OVERLAP BETWEEN BXYZS    C
C  XYZI(3) AND XYZF(3), IN A STRAIGHT LINE, WITH NPTS DATA POINTS.     C
C  THIS METHOD USES EQ-COEFFICIENTS AND THE GAUSSIAN PRODUCT THEOREM.  C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9,MB2=MBS*MBS,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(4)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,T11(8),T12(8),T21(8),T22(8)
      COMPLEX*16 A4(0:3,0:NPTS)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ),
     &           ELSX11(MB2,MEQ),ELSX21(MB2,MEQ),
     &           ELSY11(MB2,MEQ),ELSY21(MB2,MEQ),
     &           ELSZ11(MB2,MEQ),ELSZ21(MB2,MEQ),
     &           ESLX11(MB2,MEQ),ESLX21(MB2,MEQ),
     &           ESLY11(MB2,MEQ),ESLY21(MB2,MEQ),
     &           ESLZ11(MB2,MEQ),ESLZ21(MB2,MEQ)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     SET THIS TO ZERO IF YOU ONLY WANT THE CHARGE DENSITY
      JTOG = 0
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO MU=0,3
          A4(MU,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMLS = LQN(1)+LQN(2)+1
      LAMSL = LQN(1)+LQN(2)+1
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKELL(ELL011,ELL021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKESS(ESS011,ESS021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
      IF(JTOG.EQ.0) GOTO 50
C
C     ELSX, ELSY AND ELSZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKELS(ELSX11,ELSX21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EMAKELS(ELSY11,ELSY21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EMAKELS(ELSZ11,ELSZ21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     ESLX, ESLY AND ESLZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKESL(ESLX11,ESLX21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EMAKESL(ESLY11,ESLY21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EMAKESL(ESLZ11,ESLZ21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TESL = TESL+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       PREPARE DATA FOR BATCH OF R-INTEGRALS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            PX  = (XYZ(1,1)*EXPT(IBAS,1)+XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1)+XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1)+XYZ(3,2)*EXPT(JBAS,2))/EIJ
            CP(M,1) = XYZEVAL(1)-PX
            CP(M,2) = XYZEVAL(2)-PY
            CP(M,3) = XYZEVAL(3)-PZ
C
C           POINT-NUCLEUS OPTIONS
            APH(M) = EIJ
            PNC(M) = 2.0D0*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        IF(HMLT.EQ.'NORL') THEN
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMLL)
        ELSE
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMSS)
        ENDIF
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,8
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C     SCALAR POTENTIAL PHI(X,Y,Z)                                      C
C**********************************************************************C
C
C           ELL0
            DO ITUV=1,NTUVLL
              T11(1) = T11(1) +            ELL011(M,ITUV)*RC(M,ITUV)
              T12(1) = T12(1) - PHS*DCONJG(ELL021(M,ITUV)*RC(M,ITUV))
              T21(1) = T21(1) +            ELL021(M,ITUV)*RC(M,ITUV)
              T22(1) = T22(1) + PHS*DCONJG(ELL011(M,ITUV)*RC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            A4(0,IPTS) = A4(0,IPTS)
     &                          - DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(1)
     &                          - DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(1)
     &                          - DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(1)
     &                          - DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(1)
C
            IF(HMLT.EQ.'NORL') GOTO 100
C
C           ESS0
            DO ITUV=1,NTUVSS
              T11(2) = T11(2) +            ESS011(M,ITUV)*RC(M,ITUV)
              T12(2) = T12(2) - PHS*DCONJG(ESS021(M,ITUV)*RC(M,ITUV))
              T21(2) = T21(2) +            ESS021(M,ITUV)*RC(M,ITUV)
              T22(2) = T22(2) + PHS*DCONJG(ESS011(M,ITUV)*RC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            A4(0,IPTS) = A4(0,IPTS) 
     &                          - DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(2)
     &                          - DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(2)
     &                          - DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(2)
     &                          - DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(2)
C
            IF(JTOG.EQ.0) GOTO 100
C
C**********************************************************************C
C     VECTOR POTENTIAL A(X,Y,Z)                                        C
C**********************************************************************C
C
C           ELSX, ELSY AND ELSZ
            DO ITUV=1,NTUVLS
              T11(3) = T11(3) +            ELSX11(M,ITUV)*RC(M,ITUV)
              T12(3) = T12(3) - PHS*DCONJG(ELSX21(M,ITUV)*RC(M,ITUV))
              T21(3) = T21(3) +            ELSX21(M,ITUV)*RC(M,ITUV)
              T22(3) = T22(3) + PHS*DCONJG(ELSX11(M,ITUV)*RC(M,ITUV))
              T11(4) = T11(4) +            ELSY11(M,ITUV)*RC(M,ITUV)
              T12(4) = T12(4) - PHS*DCONJG(ELSY21(M,ITUV)*RC(M,ITUV))
              T21(4) = T21(4) +            ELSY21(M,ITUV)*RC(M,ITUV)
              T22(4) = T22(4) + PHS*DCONJG(ELSY11(M,ITUV)*RC(M,ITUV))
              T11(5) = T11(5) +            ELSZ11(M,ITUV)*RC(M,ITUV)
              T12(5) = T12(5) - PHS*DCONJG(ELSZ21(M,ITUV)*RC(M,ITUV))
              T21(5) = T21(5) +            ELSZ21(M,ITUV)*RC(M,ITUV)
              T22(5) = T22(5) + PHS*DCONJG(ELSZ11(M,ITUV)*RC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (+i FOR EQLS)
            A4(1,IPTS) = A4(1,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+LBAS)*PNC(M)*T11(3)
     &                     - CONE*DENT(NA1+IBAS,NB2+LBAS)*PNC(M)*T12(3)
     &                     - CONE*DENT(NA2+IBAS,NB1+LBAS)*PNC(M)*T21(3)
     &                     - CONE*DENT(NA2+IBAS,NB2+LBAS)*PNC(M)*T22(3)
            A4(2,IPTS) = A4(2,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+LBAS)*PNC(M)*T11(4)
     &                     - CONE*DENT(NA1+IBAS,NB2+LBAS)*PNC(M)*T12(4)
     &                     - CONE*DENT(NA2+IBAS,NB1+LBAS)*PNC(M)*T21(4)
     &                     - CONE*DENT(NA2+IBAS,NB2+LBAS)*PNC(M)*T22(4)
            A4(3,IPTS) = A4(3,IPTS) 
     &                     - CONE*DENT(NA1+IBAS,NB1+LBAS)*PNC(M)*T11(5)
     &                     - CONE*DENT(NA1+IBAS,NB2+LBAS)*PNC(M)*T12(5)
     &                     - CONE*DENT(NA2+IBAS,NB1+LBAS)*PNC(M)*T21(5)
     &                     - CONE*DENT(NA2+IBAS,NB2+LBAS)*PNC(M)*T22(5)
C
C           ESLX, ESLY AND ESLZ
            DO ITUV=1,NTUVSL
              T11(6) = T11(6) +            ESLX11(M,ITUV)*RC(M,ITUV)
              T12(6) = T12(6) - PHS*DCONJG(ESLX21(M,ITUV)*RC(M,ITUV))
              T21(6) = T21(6) +            ESLX21(M,ITUV)*RC(M,ITUV)
              T22(6) = T22(6) + PHS*DCONJG(ESLX11(M,ITUV)*RC(M,ITUV))
              T11(7) = T11(7) +            ESLY11(M,ITUV)*RC(M,ITUV)
              T12(7) = T12(7) - PHS*DCONJG(ESLY21(M,ITUV)*RC(M,ITUV))
              T21(7) = T21(7) +            ESLY21(M,ITUV)*RC(M,ITUV)
              T22(7) = T22(7) + PHS*DCONJG(ESLY11(M,ITUV)*RC(M,ITUV))
              T11(8) = T11(8) +            ESLZ11(M,ITUV)*RC(M,ITUV)
              T12(8) = T12(8) - PHS*DCONJG(ESLZ21(M,ITUV)*RC(M,ITUV))
              T21(8) = T21(8) +            ESLZ21(M,ITUV)*RC(M,ITUV)
              T22(8) = T22(8) + PHS*DCONJG(ESLZ11(M,ITUV)*RC(M,ITUV))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (-i FOR EQSL)
            A4(1,IPTS) = A4(1,IPTS)
     &                     + CONE*DENT(NA1+KBAS,NB1+JBAS)*PNC(M)*T11(6)
     &                     + CONE*DENT(NA1+KBAS,NB2+JBAS)*PNC(M)*T12(6)
     &                     + CONE*DENT(NA2+KBAS,NB1+JBAS)*PNC(M)*T21(6)
     &                     + CONE*DENT(NA2+KBAS,NB2+JBAS)*PNC(M)*T22(6)
            A4(2,IPTS) = A4(2,IPTS)
     &                     + CONE*DENT(NA1+KBAS,NB1+JBAS)*PNC(M)*T11(7)
     &                     + CONE*DENT(NA1+KBAS,NB2+JBAS)*PNC(M)*T12(7)
     &                     + CONE*DENT(NA2+KBAS,NB1+JBAS)*PNC(M)*T21(7)
     &                     + CONE*DENT(NA2+KBAS,NB2+JBAS)*PNC(M)*T22(7)
            A4(3,IPTS) = A4(3,IPTS)
     &                     + CONE*DENT(NA1+KBAS,NB1+JBAS)*PNC(M)*T11(8)
     &                     + CONE*DENT(NA1+KBAS,NB2+JBAS)*PNC(M)*T12(8)
     &                     + CONE*DENT(NA2+KBAS,NB1+JBAS)*PNC(M)*T21(8)
     &                     + CONE*DENT(NA2+KBAS,NB2+JBAS)*PNC(M)*T22(8)
C
100         CONTINUE
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     FOUR-POTENTIAL ENTRIES MUST BE MULTIPLIED BY CONE*CV
      DO IX=1,3
        DO IPTS=1,NPTS
          A4(IX,IPTS) = CV*CONE*A4(IX,IPTS)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     NUCLEAR CENTRE CONTRIBUTIONS (CAN SKIP THIS PART)                C
C**********************************************************************C
C
      GOTO 300
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       BEGIN LOOP OVER ALL NUCLEAR CENTRES UP TO NCNT
        DO ICNT=1,NCNT
C
C         NUCLEAR WIDTH EXPONENTS
          EXPT(1,1) = CNUC(ICNT)
          EXPT(1,2) = 0.0D0
C
C         LIST DIMENSION
          NBAS(1) = 1
          NBAS(2) = 1
C
C         CARTESIAN COORDINATES OF CENTRE A
          XYZ(1,1) = BXYZ(1,ICNT)
          XYZ(2,1) = BXYZ(2,ICNT)
          XYZ(3,1) = BXYZ(3,ICNT)
C
C         CARTESIAN COORDINATES OF CENTRE B
          XYZ(1,2) = 0.0D0
          XYZ(2,2) = 0.0D0
          XYZ(3,2) = 0.0D0
C
C         PREPARE DATA FOR BATCH OF R-INTEGRALS
          EIJ = EXPT(1,1)+EXPT(1,2)
          PX  = (XYZ(1,1)*EXPT(1,1)+XYZ(1,2)*EXPT(2,2))/EIJ
          PY  = (XYZ(2,1)*EXPT(1,1)+XYZ(2,2)*EXPT(2,2))/EIJ
          PZ  = (XYZ(3,1)*EXPT(1,1)+XYZ(3,2)*EXPT(2,2))/EIJ
          CP(1,1) = XYZEVAL(1)-PX
          CP(1,2) = XYZEVAL(2)-PY
          CP(1,3) = XYZEVAL(3)-PZ
C
C         POINT-NUCLEUS OPTIONS
          APH(1) = EIJ
          PNC(1) = 2.0D0*PI/EIJ
C
C         GENERATE A BATCH OF R-INTEGRALS
          CALL CPU_TIME(TDM1)
          CALL RMAKE(RC,CP,APH,1,0)
          CALL CPU_TIME(TDM2)
          TRLL = TRLL+TDM2-TDM1
C
C         PRE-FACTOR FOR NUCLEAR CHARGE AND WIDTH
          GSFC = DSQRT(CNUC(ICNT)/PI)
          GSFC = ZNUC(ICNT)*(GSFC**3)
C
C         ADD VALUE OF DENSITY AT THESE COORDINATES TO DATA BIN
          A4(0,IPTS) = A4(0,IPTS) + GSFC*PNC(1)*RC(1,1)
C
C       END LOOP OVER NUCLEAR CENTRES
        ENDDO
C
C     END LOOP OVER ALL GRID COORDINATES
      ENDDO
C
300   CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'A4EQSUM'
      TITLE  = 'POTENTL'//' for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{A}_{/Symbol u}(z)'
      KEY(1) = '{/Symbol f}(z)'
      KEY(2) = 'A_{x}(z)'
      KEY(3) = 'A_{y}(z)'
      KEY(4) = 'A_{z}(z)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(DREAL(A4(MU,IPTS)),MU=0,3)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,4,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE ELCTRCF(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     EEEEEEEE LL       CCCCCC TTTTTTTT RRRRRRR   CCCCCC  FFFFFFFF     C
C     EE       LL      CC    CC   TT    RR    RR CC    CC FF           C
C     EE       LL      CC         TT    RR    RR CC       FF           C
C     EEEEEE   LL      CC         TT    RR    RR CC       FFFFFF       C
C     EE       LL      CC         TT    RRRRRRR  CC       FF           C
C     EE       LL      CC    CC   TT    RR    RR CC    CC FF           C
C     EEEEEEEE LLLLLLLL CCCCCC    TT    RR    RR  CCCCCC  FF           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ELCTRCF CREATES A PLOT OF THE MOLECULAR ELECTRIC FIELD VECTOR BY    C
C  USE OF THE EQ-COEFFICIENTS AND BOYS INTEGRALS.                      C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9,MB2=MBS*MBS,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(3)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,T11(6),T12(6),T21(6),T22(6)
      COMPLEX*16 EFIELD(3,0:NPTS)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO IJK=1,3
          EFIELD(IJK,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKELL(ELL011,ELL021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKESS(ESS011,ESS021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       PREPARE DATA FOR BATCH OF R-INTEGRALS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            PX  = (XYZ(1,1)*EXPT(IBAS,1)+XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1)+XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1)+XYZ(3,2)*EXPT(JBAS,2))/EIJ
            CP(M,1) = XYZEVAL(1)-PX
            CP(M,2) = XYZEVAL(2)-PY
            CP(M,3) = XYZEVAL(3)-PZ
C
C           POINT-NUCLEUS OPTIONS
            APH(M) = EIJ
            PNC(M) = 2.0D0*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        IF(HMLT.EQ.'NORL') THEN
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMLL+1)
        ELSE
          CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMSS+1)
        ENDIF
        CALL CPU_TIME(TDM2)
        TRLL = TRLL + TDM2 - TDM1
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,6
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C     ELECTRIC FIELD VECTOR E(X,Y,Z)                                   C
C**********************************************************************C
C
C           ELL0
            DO ITUV=1,NTUVLL
              IXDR = INABCD(IVEC(ITUV)+1,JVEC(ITUV)  ,KVEC(ITUV)  )
              IYDR = INABCD(IVEC(ITUV)  ,JVEC(ITUV)+1,KVEC(ITUV)  )
              IZDR = INABCD(IVEC(ITUV)  ,JVEC(ITUV)  ,KVEC(ITUV)+1)
              T11(1) = T11(1) +            ELL011(M,ITUV)*RC(M,IXDR)
              T12(1) = T12(1) - PHS*DCONJG(ELL021(M,ITUV)*RC(M,IXDR))
              T21(1) = T21(1) +            ELL021(M,ITUV)*RC(M,IXDR)
              T22(1) = T22(1) + PHS*DCONJG(ELL011(M,ITUV)*RC(M,IXDR))
              T11(2) = T11(2) +            ELL011(M,ITUV)*RC(M,IYDR)
              T12(2) = T12(2) - PHS*DCONJG(ELL021(M,ITUV)*RC(M,IYDR))
              T21(2) = T21(2) +            ELL021(M,ITUV)*RC(M,IYDR)
              T22(2) = T22(2) + PHS*DCONJG(ELL011(M,ITUV)*RC(M,IYDR))
              T11(3) = T11(3) +            ELL011(M,ITUV)*RC(M,IZDR)
              T12(3) = T12(3) - PHS*DCONJG(ELL021(M,ITUV)*RC(M,IZDR))
              T21(3) = T21(3) +            ELL021(M,ITUV)*RC(M,IZDR)
              T22(3) = T22(3) + PHS*DCONJG(ELL011(M,ITUV)*RC(M,IZDR))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            EFIELD(1,IPTS) = EFIELD(1,IPTS)
     &                          - DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(1)
     &                          - DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(1)
     &                          - DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(1)
     &                          - DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(1)
            EFIELD(2,IPTS) = EFIELD(2,IPTS)
     &                          - DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(2)
     &                          - DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(2)
     &                          - DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(2)
     &                          - DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(2)
            EFIELD(3,IPTS) = EFIELD(3,IPTS)
     &                          - DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(3)
     &                          - DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(3)
     &                          - DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(3)
     &                          - DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(3)
C
            IF(HMLT.EQ.'NORL') GOTO 100
C
C           ESS0
            DO ITUV=1,NTUVSS
              IXDR = INABCD(IVEC(ITUV)+1,JVEC(ITUV)  ,KVEC(ITUV)  )
              IYDR = INABCD(IVEC(ITUV)  ,JVEC(ITUV)+1,KVEC(ITUV)  )
              IZDR = INABCD(IVEC(ITUV)  ,JVEC(ITUV)  ,KVEC(ITUV)+1)
              T11(4) = T11(4) +            ESS011(M,ITUV)*RC(M,IXDR)
              T12(4) = T12(4) - PHS*DCONJG(ESS021(M,ITUV)*RC(M,IXDR))
              T21(4) = T21(4) +            ESS021(M,ITUV)*RC(M,IXDR)
              T22(4) = T22(4) + PHS*DCONJG(ESS011(M,ITUV)*RC(M,IXDR))
              T11(5) = T11(5) +            ESS011(M,ITUV)*RC(M,IYDR)
              T12(5) = T12(5) - PHS*DCONJG(ESS021(M,ITUV)*RC(M,IYDR))
              T21(5) = T21(5) +            ESS021(M,ITUV)*RC(M,IYDR)
              T22(5) = T22(5) + PHS*DCONJG(ESS011(M,ITUV)*RC(M,IYDR))
              T11(6) = T11(6) +            ESS011(M,ITUV)*RC(M,IZDR)
              T12(6) = T12(6) - PHS*DCONJG(ESS021(M,ITUV)*RC(M,IZDR))
              T21(6) = T21(6) +            ESS021(M,ITUV)*RC(M,IZDR)
              T22(6) = T22(6) + PHS*DCONJG(ESS011(M,ITUV)*RC(M,IZDR))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            EFIELD(1,IPTS) = EFIELD(1,IPTS) 
     &                          - DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(4)
     &                          - DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(4)
     &                          - DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(4)
     &                          - DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(4)
            EFIELD(2,IPTS) = EFIELD(2,IPTS) 
     &                          - DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(5)
     &                          - DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(5)
     &                          - DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(5)
     &                          - DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(5)
            EFIELD(3,IPTS) = EFIELD(3,IPTS) 
     &                          - DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(6)
     &                          - DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(6)
     &                          - DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(6)
     &                          - DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(6)
C
100         CONTINUE
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     NUCLEAR CENTRE CONTRIBUTIONS (CAN SKIP THIS PART)                C
C**********************************************************************C
C
      GOTO 300
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       BEGIN LOOP OVER ALL NUCLEAR CENTRES UP TO NCNT
        DO ICNT=1,NCNT
C
C         NUCLEAR WIDTH EXPONENTS
          EXPT(1,1) = CNUC(ICNT)
          EXPT(1,2) = 0.0D0
C
C         LIST DIMENSION
          NBAS(1) = 1
          NBAS(2) = 1
C
C         CARTESIAN COORDINATES OF CENTRE A
          XYZ(1,1) = BXYZ(1,ICNT)
          XYZ(2,1) = BXYZ(2,ICNT)
          XYZ(3,1) = BXYZ(3,ICNT)
C
C         CARTESIAN COORDINATES OF CENTRE B
          XYZ(1,2) = 0.0D0
          XYZ(2,2) = 0.0D0
          XYZ(3,2) = 0.0D0
C
C         PREPARE DATA FOR BATCH OF R-INTEGRALS
          EIJ = EXPT(1,1)+EXPT(1,2)
          PX  = (XYZ(1,1)*EXPT(1,1)+XYZ(1,2)*EXPT(2,2))/EIJ
          PY  = (XYZ(2,1)*EXPT(1,1)+XYZ(2,2)*EXPT(2,2))/EIJ
          PZ  = (XYZ(3,1)*EXPT(1,1)+XYZ(3,2)*EXPT(2,2))/EIJ
          CP(1,1) = XYZEVAL(1)-PX
          CP(1,2) = XYZEVAL(2)-PY
          CP(1,3) = XYZEVAL(3)-PZ
C
C         POINT-NUCLEUS OPTIONS
          APH(1) = EIJ
          PNC(1) = 2.0D0*PI/EIJ
C
C         GENERATE A BATCH OF R-INTEGRALS
          CALL CPU_TIME(TDM1)
          CALL RMAKE(RC,CP,APH,1,1)
          CALL CPU_TIME(TDM2)
          TRLL = TRLL+TDM2-TDM1
C
C         PRE-FACTOR FOR NUCLEAR CHARGE AND WIDTH
          GSFC = DSQRT(CNUC(ICNT)/PI)
          GSFC = ZNUC(ICNT)*(GSFC**3)
C
C         ADD VALUE OF DENSITY AT THESE COORDINATES TO DATA BIN
          IXDR = INABCD(1,0,0)
          IYDR = INABCD(0,1,0)
          IZDR = INABCD(0,0,1)
          EFIELD(1,IPTS) = EFIELD(1,IPTS) + GSFC*PNC(1)*RC(1,IXDR)
          EFIELD(2,IPTS) = EFIELD(2,IPTS) + GSFC*PNC(1)*RC(1,IYDR)
          EFIELD(3,IPTS) = EFIELD(3,IPTS) + GSFC*PNC(1)*RC(1,IZDR)
C
C       END LOOP OVER NUCLEAR CENTRES
        ENDDO
C
C     END LOOP OVER ALL GRID COORDINATES
      ENDDO
C
300   CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'ELCTRCF'
      TITLE  = 'Electric field for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{E}_{i}(z)'
      KEY(1) = 'E_{x}(z)'
      KEY(2) = 'E_{y}(z)'
      KEY(3) = 'E_{z}(z)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(DREAL(EFIELD(IJK,IPTS)),IJK=1,3)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,3,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE MAGNTCF(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   MM       MM    AA     GGGGGG  NN    NN TTTTTTTT CCCCCC  FFFFFFFF   C
C   MMM     MMM   AAAA   GG    GG NNN   NN    TT   CC    CC FF         C
C   MMMM   MMMM  AA  AA  GG       NNNN  NN    TT   CC       FF         C
C   MM MM MM MM AA    AA GG       NN NN NN    TT   CC       FFFFFF     C
C   MM  MMM  MM AAAAAAAA GG   GGG NN  NNNN    TT   CC       FF         C
C   MM   M   MM AA    AA GG    GG NN   NNN    TT   CC    CC FF         C
C   MM       MM AA    AA  GGGGGG  NN    NN    TT    CCCCCC  FF         C
C                                                                      C
C -------------------------------------------------------------------- C
C  MAGNTCF CREATES A PLOT OF THE MOLECULAR MAGNETIC FIELD VECTOR BY    C
C  USE OF THE EQ-COEFFICIENTS AND BOYS INTEGRALS.                      C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9,MB2=MBS*MBS,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(3)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
      DIMENSION RC(MB2,MRC),CP(MB2,3),APH(MB2),PNC(MB2)
C
      COMPLEX*16 CONE,T11(6),T12(6),T21(6),T22(6)
      COMPLEX*16 BFIELD(3,0:NPTS)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELSX11(MB2,MEQ),ELSX21(MB2,MEQ),
     &           ELSY11(MB2,MEQ),ELSY21(MB2,MEQ),
     &           ELSZ11(MB2,MEQ),ELSZ21(MB2,MEQ),
     &           ESLX11(MB2,MEQ),ESLX21(MB2,MEQ),
     &           ESLY11(MB2,MEQ),ESLY21(MB2,MEQ),
     &           ESLZ11(MB2,MEQ),ESLZ21(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
      DATA PI/3.1415926535897932D0/
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = IPTS*RS
      ENDDO
C
C**********************************************************************C
C     CALCULATION OF CONTRIBUTIONS TO THE FOUR-CURRENT                 C
C**********************************************************************C
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        DO IJK=1,3
          BFIELD(IJK,IPTS) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER MQNS FOR CENTRES A AND B (USE INDEX 3000)              C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLS = LQN(1)+LQN(2)+1
      LAMSL = LQN(1)+LQN(2)+1
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C     ELSX, ELSY AND ELSZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKELS(ELSX11,ELSX21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EMAKELS(ELSY11,ELSY21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EMAKELS(ELSZ11,ELSZ21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TELS = TELS+TDM2-TDM1
C
C     ESLX, ESLY AND ESLZ COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKESL(ESLX11,ESLX21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,1)
      CALL EMAKESL(ESLY11,ESLY21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,2)
      CALL EMAKESL(ESLZ11,ESLZ21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,3)
      CALL CPU_TIME(TDM2)
      TESL = TESL+TDM2-TDM1
C
C**********************************************************************C
C     BATCHES OF HGTFS FOR EACH GRID COORDINATES                       C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       PREPARE DATA FOR BATCH OF R-INTEGRALS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
            EIJ = EXPT(IBAS,1)+EXPT(JBAS,2)
            PX  = (XYZ(1,1)*EXPT(IBAS,1)+XYZ(1,2)*EXPT(JBAS,2))/EIJ
            PY  = (XYZ(2,1)*EXPT(IBAS,1)+XYZ(2,2)*EXPT(JBAS,2))/EIJ
            PZ  = (XYZ(3,1)*EXPT(IBAS,1)+XYZ(3,2)*EXPT(JBAS,2))/EIJ
            CP(M,1) = XYZEVAL(1)-PX
            CP(M,2) = XYZEVAL(2)-PY
            CP(M,3) = XYZEVAL(3)-PZ
C
C           POINT-NUCLEUS OPTIONS
            APH(M) = EIJ
            PNC(M) = 2.0D0*PI/EIJ
C
          ENDDO
        ENDDO
C
C       GENERATE A BATCH OF R-INTEGRALS
        CALL CPU_TIME(TDM1)
        CALL RMAKE(RC,CP,APH,NBAS(1)*NBAS(2),LAMLS+1)
        CALL CPU_TIME(TDM2)
        TRLS = TRLS + TDM2 - TDM1
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,6
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C     MAGNETIC FIELD VECTOR B(X,Y,Z)                                   C
C**********************************************************************C
C
C           ELSI
            DO ITUV=1,NTUVLS
              IXDR = INABCD(IVEC(ITUV)+1,JVEC(ITUV)  ,KVEC(ITUV)  )
              IYDR = INABCD(IVEC(ITUV)  ,JVEC(ITUV)+1,KVEC(ITUV)  )
              IZDR = INABCD(IVEC(ITUV)  ,JVEC(ITUV)  ,KVEC(ITUV)+1)
              T11(1) = T11(1) +            ELSZ11(M,ITUV)*RC(M,IYDR)
     &                                   - ELSY11(M,ITUV)*RC(M,IZDR)
              T12(1) = T12(1) - PHS*DCONJG(ELSZ21(M,ITUV)*RC(M,IYDR)
     &                                   - ELSY11(M,ITUV)*RC(M,IZDR))
              T21(1) = T21(1) +            ELSZ21(M,ITUV)*RC(M,IYDR)
     &                                   - ELSY21(M,ITUV)*RC(M,IZDR)
              T22(1) = T22(1) + PHS*DCONJG(ELSZ11(M,ITUV)*RC(M,IYDR)
     &                                   - ELSY11(M,ITUV)*RC(M,IZDR))
              T11(2) = T11(2) +            ELSX11(M,ITUV)*RC(M,IZDR)
     &                                   - ELSZ11(M,ITUV)*RC(M,IXDR)
              T12(2) = T12(2) - PHS*DCONJG(ELSX21(M,ITUV)*RC(M,IZDR)
     &                                   - ELSZ21(M,ITUV)*RC(M,IXDR))
              T21(2) = T21(2) +            ELSX21(M,ITUV)*RC(M,IZDR)
     &                                   - ELSZ21(M,ITUV)*RC(M,IXDR)
              T22(2) = T22(2) + PHS*DCONJG(ELSX11(M,ITUV)*RC(M,IZDR)
     &                                   - ELSZ11(M,ITUV)*RC(M,IXDR))
              T11(3) = T11(3) +            ELSY11(M,ITUV)*RC(M,IXDR)
     &                                   - ELSX11(M,ITUV)*RC(M,IYDR)
              T12(3) = T12(3) - PHS*DCONJG(ELSY21(M,ITUV)*RC(M,IXDR)
     &                                   - ELSX21(M,ITUV)*RC(M,IYDR))
              T21(3) = T21(3) +            ELSY21(M,ITUV)*RC(M,IXDR)
     &                                   - ELSX21(M,ITUV)*RC(M,IYDR)
              T22(3) = T22(3) + PHS*DCONJG(ELSY11(M,ITUV)*RC(M,IXDR)
     &                                   - ELSX11(M,ITUV)*RC(M,IYDR))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (+i FOR EQLS)
            BFIELD(1,IPTS) = BFIELD(1,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(1)
     &                     - CONE*DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(1)
     &                     - CONE*DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(1)
     &                     - CONE*DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(1)
            BFIELD(2,IPTS) = BFIELD(2,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(2)
     &                     - CONE*DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(2)
     &                     - CONE*DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(2)
     &                     - CONE*DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(2)
            BFIELD(3,IPTS) = BFIELD(3,IPTS)
     &                     - CONE*DENT(NA1+IBAS,NB1+JBAS)*PNC(M)*T11(3)
     &                     - CONE*DENT(NA1+IBAS,NB2+JBAS)*PNC(M)*T12(3)
     &                     - CONE*DENT(NA2+IBAS,NB1+JBAS)*PNC(M)*T21(3)
     &                     - CONE*DENT(NA2+IBAS,NB2+JBAS)*PNC(M)*T22(3)
C
C           ESLI
            DO ITUV=1,NTUVSL
              IXDR = INABCD(IVEC(ITUV)+1,JVEC(ITUV)  ,KVEC(ITUV)  )
              IYDR = INABCD(IVEC(ITUV)  ,JVEC(ITUV)+1,KVEC(ITUV)  )
              IZDR = INABCD(IVEC(ITUV)  ,JVEC(ITUV)  ,KVEC(ITUV)+1)
              T11(4) = T11(4) +            ESLZ11(M,ITUV)*RC(M,IYDR)
     &                                   - ESLY11(M,ITUV)*RC(M,IZDR)
              T12(4) = T12(4) - PHS*DCONJG(ESLZ21(M,ITUV)*RC(M,IYDR)
     &                                   - ESLY11(M,ITUV)*RC(M,IZDR))
              T21(4) = T21(4) +            ESLZ21(M,ITUV)*RC(M,IYDR)
     &                                   - ESLY21(M,ITUV)*RC(M,IZDR)
              T22(4) = T22(4) + PHS*DCONJG(ESLZ11(M,ITUV)*RC(M,IYDR)
     &                                   - ESLY11(M,ITUV)*RC(M,IZDR))
              T11(5) = T11(5) +            ESLX11(M,ITUV)*RC(M,IZDR)
     &                                   - ESLZ11(M,ITUV)*RC(M,IXDR)
              T12(5) = T12(5) - PHS*DCONJG(ESLX21(M,ITUV)*RC(M,IZDR)
     &                                   - ESLZ21(M,ITUV)*RC(M,IXDR))
              T21(5) = T21(5) +            ESLX21(M,ITUV)*RC(M,IZDR)
     &                                   - ESLZ21(M,ITUV)*RC(M,IXDR)
              T22(5) = T22(5) + PHS*DCONJG(ESLX11(M,ITUV)*RC(M,IZDR)
     &                                   - ESLZ11(M,ITUV)*RC(M,IXDR))
              T11(6) = T11(6) +            ESLY11(M,ITUV)*RC(M,IXDR)
     &                                   - ESLX11(M,ITUV)*RC(M,IYDR)
              T12(6) = T12(6) - PHS*DCONJG(ESLY21(M,ITUV)*RC(M,IXDR)
     &                                   - ESLX21(M,ITUV)*RC(M,IYDR))
              T21(6) = T21(6) +            ESLY21(M,ITUV)*RC(M,IXDR)
     &                                   - ESLX21(M,ITUV)*RC(M,IYDR)
              T22(6) = T22(6) + PHS*DCONJG(ESLY11(M,ITUV)*RC(M,IXDR)
     &                                   - ESLX11(M,ITUV)*RC(M,IYDR))
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS (-i FOR EQSL)
            BFIELD(1,IPTS) = BFIELD(1,IPTS) 
     &                     + CONE*DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(4)
     &                     + CONE*DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(4)
     &                     + CONE*DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(4)
     &                     + CONE*DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(4)
            BFIELD(2,IPTS) = BFIELD(2,IPTS) 
     &                     + CONE*DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(5)
     &                     + CONE*DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(5)
     &                     + CONE*DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(5)
     &                     + CONE*DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(5)
            BFIELD(3,IPTS) = BFIELD(3,IPTS) 
     &                     + CONE*DENT(NA1+KBAS,NB1+LBAS)*PNC(M)*T11(6)
     &                     + CONE*DENT(NA1+KBAS,NB2+LBAS)*PNC(M)*T12(6)
     &                     + CONE*DENT(NA2+KBAS,NB1+LBAS)*PNC(M)*T21(6)
     &                     + CONE*DENT(NA2+KBAS,NB2+LBAS)*PNC(M)*T22(6)
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C     MULTIPLY BY CONE
      DO IX=1,3
        DO IPTS=1,NPTS
          BFIELD(IX,IPTS) = CONE*BFIELD(IX,IPTS)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'MAGNTCF'
      TITLE  = 'Magnetic field for '//TRIM(MOLCL)//' of type '//HMLT
      XAXIS  = 'z (a.u.)'
      YAXIS  = '{B}_{i}(z)'
      KEY(1) = 'B_{x}(z)'
      KEY(2) = 'B_{y}(z)'
      KEY(3) = 'B_{z}(z)'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       BEGIN LOOP OVER ALL POINTS
        DO IPTS=0,NPTS
C
C         PRINT DISTANCE ALONG PATH AND FOUR-CURRENT
          WRITE(8, *) D(IPTS),(ABS(BFIELD(IJK,IPTS)),IJK=1,3)
C
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,3,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE FRMFCTR(XYZI,XYZF,NPTS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   FFFFFFFF RRRRRRR  MM       MM FFFFFFFF CCCCCC TTTTTTTT RRRRRRR     C
C   FF       RR    RR MMM     MMM FF      CC    CC   TT    RR    RR    C
C   FF       RR    RR MMMM   MMMM FF      CC         TT    RR    RR    C
C   FFFFFF   RR    RR MM MM MM MM FFFFFF  CC         TT    RR    RR    C
C   FF       RRRRRRR  MM  MMM  MM FF      CC         TT    RRRRRRR     C
C   FF       RR    RR MM   M   MM FF      CC    CC   TT    RR    RR    C
C   FF       RR    RR MM       MM FF       CCCCCC    TT    RR    RR    C
C                                                                      C
C -------------------------------------------------------------------- C
C  FRMFCTR CREATES A PLOT OF THE ELECTRON SCATTERING FORM FACTOR FOR   C
C  A MOLECULAR CHARGE DENSITY BY USE OF THE EQ-COEFFICIENTS AND A      C
C  FOURIER TRANSFORM OVER THE HGTFS.                             C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MCT=4,MKP=9,MB2=MBS*MBS,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4  HMLT
      CHARACTER*40 MOLCL,WFNFL,OUTFL
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(2)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
      DIMENSION XYZI(3),XYZF(3),XYZD(3),XYZEVAL(3),STP(3)
      DIMENSION D(0:NPTS),CART(3,0:NPTS)
C
      COMPLEX*16 CONE,T11(2),T12(2),T21(2),T22(2)
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
      COMPLEX*16 ELL011(MB2,MEQ),ELL021(MB2,MEQ),
     &           ESS011(MB2,MEQ),ESS021(MB2,MEQ)
      COMPLEX*16 HABC(MB2,MEQ)
      COMPLEX*16 GE(0:NPTS)
C
      COMMON/DENS/DENC,DENO,DENT
      COMMON/FLNM/MOLCL,WFNFL,OUTFL
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
C     UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C**********************************************************************C
C     GRID OF CARTESIAN COORDINATES AND PLOTTING LINE                  C
C**********************************************************************C
C
C     COMPUTE PLOTTING DETAILS FOR EACH CARTESIAN COMPONENT
      DO IX=1,3
C
C       DISTANCE BETWEEN FINAL AND INITAL COORDINATE
        XYZD(IX) = XYZF(IX)-XYZI(IX)
C
C       SELECT AN APPROPRIATE STEP VALUE (EQUALLY-SPACED GRID)
        IF(NPTS.EQ.0) THEN
          STP(IX) = 0.0D0
        ELSE
          STP(IX) = XYZD(IX)/DFLOAT(NPTS)
        ENDIF
C
C       EVALUATE CARTESIAN COORDINATES ALONG THE GRID
        DO IPTS=0,NPTS
          CART(IX,IPTS) = XYZI(IX) + IPTS*STP(IX)
        ENDDO
c
C     CLOSE LOOP OVER CARTESIAN INDICES
      ENDDO
C
C     EUCLIDIAN DISTANCE OVER THE PLOTTING LINE
      RD = DSQRT(XYZD(1)*XYZD(1)+XYZD(2)*XYZD(2)+XYZD(3)*XYZD(3))
C
C     SELECT AN APPROPRIATE STEP VALUE
      IF(NPTS.EQ.0) THEN
        RS = 0.0D0
      ELSE
        RS = RD/DFLOAT(NPTS)
      ENDIF
C
C     EVALUATE GRID DISTANCES FROM START TO FINISH
      DO IPTS=0,NPTS
        D(IPTS) = XYZI(3) + IPTS*RS
      ENDDO
C
C     INITIALISE THE FOUR-CURRENT COUNTER GRID
      DO IPTS=0,NPTS
        GE(IPTS) = DCMPLX(0.0D0,0.0D0)
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL BLOCKS (INDICES 1000-3000)                         C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     CONSTRUCTION OF ONE-ELECTRON OVERLAP MATRIX BY TT' BLOCKS...
C
C     THE PHASE GENERATES E022 AND E012 COEFFS FROM E011 AND E021
      PHS = DFLOAT((-1)**((MQN(1)-MQN(2))/2))
     &                    *DFLOAT((KQN(1)*KQN(2))/IABS(KQN(1)*KQN(2)))
C
C**********************************************************************C
C     BATCHES OF EQ-COEFFICIENTS                                       C
C**********************************************************************C
C
C     FINITE SUM TERMINATING ORDERS
      LAMLL = LQN(1)+LQN(2)
      LAMSS = LQN(1)+LQN(2)+2
C
C     NUMBER OF UNIQUE ADDRESSES IN EACH EXPANSION
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C     ELL0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKELL(ELL011,ELL021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 50
C
C     ESS0 COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL EMAKESS(ESS011,ESS021,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
      CALL CPU_TIME(TDM2)
      TESS = TESS+TDM2-TDM1
C
50    CONTINUE
C
C**********************************************************************C
C     LOOP OVER EACH GRID COORDINATE                                   C
C**********************************************************************C
C
C     DENSITY MATRIX STARTING ADDRESSES
      NA1 = LRGE(ICNTA,KA,2*MA-1)
      NA2 = LRGE(ICNTA,KA,2*MA  )
      NB1 = LRGE(ICNTB,KB,2*MB-1)
      NB2 = LRGE(ICNTB,KB,2*MB  )
C
C     BEGIN LOOP OVER ALL GRID COORDINATES
      DO IPTS=0,NPTS
C
C       SPECIFY CARTESIAN COORDINATES
        DO IX=1,3
          XYZEVAL(IX) = CART(IX,IPTS)
        ENDDO
C
C       GENERATE A BATCH OF HGTF TRANSFORMS FOR THIS LOCATION
        IF(HMLT.EQ.'NORL') THEN
C         CALL HGTFS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAMLL)
          CALL HTFRMS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAMLL)
        ELSE
C         CALL HGTFS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAMSS)
          CALL HTFRMS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAMSS)
        ENDIF
C
C       LOOP OVER BASIS FUNCTION PAIRS
        M = 0
        DO IBAS=1,NBAS(1)
          DO JBAS=1,NBAS(2)
            M = M+1
C
C           INITIALISE THE CARTESIAN EXPANSION COUNTERS
            DO N=1,2
              T11(N) = DCMPLX(0.0D0,0.0D0)
              T12(N) = DCMPLX(0.0D0,0.0D0)
              T21(N) = DCMPLX(0.0D0,0.0D0)
              T22(N) = DCMPLX(0.0D0,0.0D0)
            ENDDO
C
C           ADDRESS OFFSETS FOR SMALL-COMPONENTS
            KBAS = IBAS+NSKP
            LBAS = JBAS+NSKP
C
C**********************************************************************C
C           CHARGE DENSITY RHO(X,Y,Z)                                  C
C**********************************************************************C
C
C           ELL0: BASIS FUNCTION OVERLAP PRODUCT
            DO ITUV=1,NTUVLL
              T11(1) = T11(1) +            ELL011(M,ITUV) *HABC(M,ITUV)
              T12(1) = T12(1) - PHS*DCONJG(ELL021(M,ITUV))*HABC(M,ITUV)
              T21(1) = T21(1) +            ELL021(M,ITUV) *HABC(M,ITUV)
              T22(1) = T22(1) + PHS*DCONJG(ELL011(M,ITUV))*HABC(M,ITUV)
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            GE(IPTS) = GE(IPTS) + DENT(NA1+IBAS,NB1+JBAS)*T11(1)
     &                          + DENT(NA1+IBAS,NB2+JBAS)*T12(1)
     &                          + DENT(NA2+IBAS,NB1+JBAS)*T21(1)
     &                          + DENT(NA2+IBAS,NB2+JBAS)*T22(1)
C
            IF(HMLT.EQ.'NORL') GOTO 100
C
C           ESS0: BASIS FUNCTION OVERLAP PRODUCT
            DO ITUV=1,NTUVSS
              T11(2) = T11(2) +            ESS011(M,ITUV) *HABC(M,ITUV)
              T12(2) = T12(2) - PHS*DCONJG(ESS021(M,ITUV))*HABC(M,ITUV)
              T21(2) = T21(2) +            ESS021(M,ITUV) *HABC(M,ITUV)
              T22(2) = T22(2) + PHS*DCONJG(ESS011(M,ITUV))*HABC(M,ITUV)
            ENDDO
C
C           MULTIPLY BY CORRESPONDING DENSITY ELEMENTS
            GE(IPTS) = GE(IPTS) + DENT(NA1+KBAS,NB1+LBAS)*T11(2)
     &                          + DENT(NA1+KBAS,NB2+LBAS)*T12(2)
     &                          + DENT(NA2+KBAS,NB1+LBAS)*T21(2)
     &                          + DENT(NA2+KBAS,NB2+LBAS)*T22(2)
C          
100         CONTINUE
C
          ENDDO
        ENDDO
C
C     CLOSE LOOP OVER GRID COORDINATES
      ENDDO
C
C     END LOOP OVER BASIS BLOCKS A AND B
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     EXTERNAL FILE AND PLOTTING OPTIONS                               C
C**********************************************************************C
C
C     FILE NAME AND TITLES
      XOUT   = TRIM(MOLCL)//'_'//HMLT//'_'//'FRMFCTR'
      TITLE  = 'Form factor for '//TRIM(MOLCL)//
     &                                   ' under HMLT = '//HMLT
      XAXIS  = 'q_{z} (a.u.)'
      YAXIS  = '{G}_{E}(q_{z})'
      KEY(1) = 'Re [{G}_{E}(q_{z})]'
      KEY(2) = 'Im [{G}_{E}(q_{z})]'
C
C     OPEN DATA FILE
      OPEN(UNIT=8,FILE='plots/'//TRIM(XOUT)//'.dat',STATUS='REPLACE')
C
C       PRINT DISTANCE ALONG PATH AND FORM FACTOR
        DO IPTS=0,NPTS
          WRITE(8, *) D(IPTS),DREAL(GE(IPTS)),IMAG(GE(IPTS))
        ENDDO
C
C     CLOSE DATA FILE
      CLOSE(UNIT=8)
C
C     DO NOT PLOT IF THERE IS ONLY ONE POINT
      IF(NPTS.EQ.0) RETURN
C
C     GENERATE A GNUPLOT MAKE FILE
      CALL GNULINE(XOUT,TITLE,XAXIS,YAXIS,2,KEY)
C
C     EXECUTE GNUPLOT COMMAND IN TERMINAL
      CALL SYSTEM('gnuplot plots/'//TRIM(XOUT)//'.gnuplot')
      CALL SYSTEM('xdg-open plots/'//TRIM(XOUT)//'.pdf')
C
      RETURN
      END
C
C
      SUBROUTINE GNULINE(XOUT,TITLE,XAXIS,YAXIS,NDAT,KEY)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       GGGGGG  NN    NN UU    UU LL       IIII NN    NN EEEEEEEE      C
C      GG    GG NNN   NN UU    UU LL        II  NNN   NN EE            C
C      GG       NNNN  NN UU    UU LL        II  NNNN  NN EE            C
C      GG       NN NN NN UU    UU LL        II  NN NN NN EEEEEE        C
C      GG   GGG NN  NNNN UU    UU LL        II  NN  NNNN EE            C
C      GG    GG NN   NNN UU    UU LL        II  NN   NNN EE            C
C       GGGGGG  NN    NN  UUUUUU  LLLLLLLL IIII NN    NN EEEEEEEE      C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNULINE IS A CONTROLLING ROUTINE THAT GENERATES A GNUPLOT MAKE FILE C
C  FOR A SET OF DATA POINTS.                                           C
C**********************************************************************C
C
      CHARACTER*80 XOUT,TITLE,XAXIS,YAXIS,KEY(NDAT)
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(XOUT)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot raw data'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines,\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines'
        ENDIF
      ENDDO
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A)') 'set terminal pdf enhance font "palatino,10"'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(XOUT)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Load line style definitions'
      WRITE(9,'(A)') 'load "plots/plotstyles.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A)') 'set xlabel "'//TRIM(XAXIS)//'"'
      WRITE(9,'(A)') 'set ylabel "'//TRIM(YAXIS)//'"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plotting range'
      WRITE(9,'(A)') 'xmin = GPVAL_X_MIN'
      WRITE(9,'(A)') 'xmax = GPVAL_X_MAX'
      WRITE(9,'(A)') 'ymin = GPVAL_Y_MIN'
      WRITE(9,'(A)') 'ymax = GPVAL_Y_MAX'
      WRITE(9,'(A)') 'set xrange [xmin:xmax] noreverse nowriteback'
      WRITE(9,'(A)') 'set yrange [ymin:ymax] noreverse nowriteback'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Grid style'
      WRITE(9,'(A)') 'set style line 102 lc rgb"#808080" lt 0 lw 1'
      WRITE(9,'(A)') 'set grid back ls 102'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      DO N=1,NDAT
        IF(NDAT.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ELSEIF(NDAT.GT.1.AND.N.EQ.1) THEN
          WRITE(9,'(A,I2,A,I2,A)') 'plot "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.GT.1.AND.N.LT.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'",\'
        ELSEIF(NDAT.GT.1.AND.N.EQ.NDAT) THEN
          WRITE(9,'(A,I2,A,I2,A)') '     "plots/'//TRIM(XOUT)//'.dat"'
     &                        //' using 1:',N+1,' with lines ls ',N+1,
     &                                 ' title "'//TRIM(KEY(N))//'"'
        ENDIF
      ENDDO
      CLOSE(UNIT=9)
C
      WRITE(6, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
      WRITE(7, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
C
      RETURN
      END
C
C
      SUBROUTINE GNUDENS(XOUT,TITLE,NHRZ,NVTC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     GGGGGG  NN    NN UU    UU DDDDDDD  EEEEEEEE NN    NN  SSSSSS     C
C    GG    GG NNN   NN UU    UU DD    DD EE       NNN   NN SS    SS    C
C    GG       NNNN  NN UU    UU DD    DD EE       NNNN  NN SS          C
C    GG       NN NN NN UU    UU DD    DD EEEEEE   NN NN NN  SSSSSS     C
C    GG   GGG NN  NNNN UU    UU DD    DD EE       NN  NNNN       SS    C
C    GG    GG NN   NNN UU    UU DD    DD EE       NN   NNN SS    SS    C
C     GGGGGG  NN    NN  UUUUUU  DDDDDDD  EEEEEEEE NN    NN  SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  GNUDENS IS A CONTROLLING ROUTINE THAT GENERATES A GNUPLOT MAKE FILE C
C  FOR A DENSITY MAP.                                                  C
C**********************************************************************C
C
      CHARACTER*80 XOUT,TITLE
C
      RATIO = DFLOAT(NVTC)/DFLOAT(NHRZ)
      SZHRZ = 10.0D0
      SZVTC = 10.0D0*RATIO
C
      OPEN(UNIT=9,FILE='plots/'//TRIM(XOUT)//'.gnuplot',
     &                                                 STATUS='REPLACE')
      WRITE(9,'(A)') '#'//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '#  Usage:'
      WRITE(9,'(A)') '#  gnuplot < '//TRIM(XOUT)//'.gnuplot'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Terminal output specs'
      WRITE(9,'(A,F5.2)') 'set size ratio ',RATIO
      WRITE(9,'(A,F5.2,A,F5.2,A)') 'set terminal pdf size ',SZHRZ,'cm,',
     &                                     SZVTC,'cm font "palatino,10"'
      WRITE(9,'(A)') 'set output "plots/'//TRIM(XOUT)//'.pdf"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Load line style definitions'
      WRITE(9,'(A)') 'load "plots/pals/jet.pal"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Axes and title'
      WRITE(9,'(A)') 'set title sprintf("'//TRIM(TITLE)//'")'
      WRITE(9,'(A)') 'set xlabel "NHRZ"'
      WRITE(9,'(A)') 'set ylabel "NVTC"'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Grid style'
      WRITE(9,'(A)') 'set style line 102 lc rgb"#808080" lt 0 lw 1'
      WRITE(9,'(A)') 'set grid back ls 102'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plotting options'
      WRITE(9,'(A)') 'set view map'
      WRITE(9,'(A)') 'set palette model RGB'
      WRITE(9,'(A)') 'set palette defined'
      WRITE(9,'(A)') '#'
      WRITE(9,'(A)') '# Plot data to file'
      WRITE(9,'(A,I2,A,I2)') 'splot "plots/'//TRIM(XOUT)//'.dat"'
     &                                    //' matrix with image notitle'
      CLOSE(UNIT=9)
C
      WRITE(6, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
      WRITE(7, *) 'Created command file "'//TRIM(XOUT)//'.gnuplot".'
C
      RETURN
      END
C
C
      FUNCTION CLEBSCH(KQN,MQN,NSGN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C     CCCCCC  LL       EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C    CC       LL       EE       BB    BB SS       CC       HH    HH    C
C    CC       LL       EEEEEE   BBBBBBB   SSSSSS  CC       HHHHHHHH    C
C    CC       LL       EE       BB    BB       SS CC       HH    HH    C
C    CC    CC LL       EE       BB    BB SS    SS CC    CC HH    HH    C
C     CCCCCC  LLLLLLLL EEEEEEEE BBBBBBB   SSSSSS   CCCCCC  HH    HH    C
C                                                                      C
C -------------------------------------------------------------------- C
C  CLEBSCH DETERMINES A CLEBSCH-GORDAN COEFFICIENT FOR KQN AND MQN.    C
C -------------------------------------------------------------------- C
C  KQN IS FINE BUT MQN IS DOUBLE THE ACTUAL VALUE, AND NSGN IS THE     C
C  PARITY NUMBER.                                                      C
C**********************************************************************C
C
      IF(KQN.LT.0) THEN
        LQN =-KQN-1
      ELSE
        LQN = KQN
      ENDIF
C
      T1 = 2.0D0*LQN + 1.0D0 + MQN*NSGN
      T2 = 4.0D0*LQN + 2.0D0
C
      CLEBSCH = DSQRT(T1/T2)
C
      RETURN
      END
C
C
      FUNCTION SPHHRM(THETA,PHI,L,M)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        SSSSSS  PPPPPPP  HH    HH HH    HH RRRRRRR  MM       MM       C
C       SS    SS PP    PP HH    HH HH    HH RR    RR MMM     MMM       C
C       SS       PP    PP HH    HH HH    HH RR    RR MMMM   MMMM       C
C        SSSSSS  PP    PP HHHHHHHH HHHHHHHH RR    RR MM MM MM MM       C
C             SS PPPPPPP  HH    HH HH    HH RRRRRRR  MM  MMM  MM       C
C       SS    SS PP       HH    HH HH    HH RR    RR MM   M   MM       C
C        SSSSSS  PP       HH    HH HH    HH RR    RR MM       MM       C
C                                                                      C
C -------------------------------------------------------------------- C
C  SPHHRM RETURNS A COMPLEX*16 SPHERICAL HARMONIC Y_L^M (THETA,PHI).   C
C -------------------------------------------------------------------- C
C  PARAMETERS:                                                         C
C   INPUT  THETA - ZENITH ANGLE (FROM POSITIVE Z DOWN).                C
C          PHI   - AZIMUTH ANGLE (FROM POSITIVE X TOWARD POSITIVE Y).  C
C          L     - ORBITAL QUANTUM NUMBER (0,1,...).                   C
C          M     - MAGNETIC QUANTUM NUMBER (-L,...,0,...,+L).          C
C  OUTPUT  SPHHRM - DOUBLE COMPLEX NUMBER.                             C
C**********************************************************************C
C
      COMPLEX*16 SPHHRM
C
      DATA PI/3.1415926535897932D0/
C
C     FOR CONDON-SHORTLEY PHASE CONVENTION
      MTEMP = M
      IF(M.LT.0) THEN
        M  =-M
        IP =(-1)**M
      ENDIF
C
      DEN = 4.0D0*PI*NFACT(L+M)
      FCT = NFACT(L-M)*(2.0D0*L+1.0D0)/DEN
      FCT = DSQRT(FCT)
      AZR = DCOS(M*PHI)
      AZI = DSIN(M*PHI)
      ARG = DCOS(THETA)
      PLM = PLGNDR(L,M,ARG)
C
      IF(M.GE.0) THEN
        SPHHRM = DCMPLX(   FCT*PLM*AZR,    FCT*PLM*AZI)
      ELSEIF(M.LT.0) THEN
        SPHHRM = DCMPLX(IP*FCT*PLM*AZR,-IP*FCT*PLM*AZI)
      ENDIF

      M = MTEMP
C
      RETURN
      END
C
C
      FUNCTION PLGNDR(L,M,X)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        PPPPPPP  LL       GGGGGG  NN    NN DDDDDDD  RRRRRRR           C
C        PP    PP LL      GG    GG NNN   NN DD    DD RR    RR          C
C        PP    PP LL      GG    GG NNNN  NN DD    DD RR    RR          C
C        PP    PP LL      GG       NN NN NN DD    DD RR    RR          C
C        PPPPPPP  LL      GG   GGG NN  NNNN DD    DD RRRRRRR           C
C        PP       LL      GG    GG NN   NNN DD    DD RR    RR          C
C        PP       LLLLLLLL GGGGGG  NN    NN DDDDDDD  RR    RR          C
C                                                                      C
C -------------------------------------------------------------------- C
C  PLGNDR RETURNS AN ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).          C
C -------------------------------------------------------------------- C
C  PARAMETERS:                                                         C
C   INPUT  X - ARGUMENT WITH -1 <= X <= 1.                             C
C          L - ORBITAL QUANTUM NUMBER (0,1,...).                       C
C          M - MAGNETIC QUANTUM NUMBER (0,...,+L).                     C
C  OUTPUT  PLGNDR - ASSOCIATED LEGENDRE POLYNOMIAL P_L^M(X).           C
C**********************************************************************C
C
C     CHECK VALIDITY OF ARGUMENTS
      IF(M.LT.0) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - M < 0.'
        WRITE(7, *) 'In PLGNDR: bad argument - M < 0.'
        STOP
      ELSEIF(M.GT.L) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - L < M: ',L,'<',M
        WRITE(7, *) 'In PLGNDR: bad argument - L < M: ',L,'<',M
        STOP
      ELSEIF(DABS(X).GT.1) THEN
        WRITE(6, *) 'In PLGNDR: bad argument - X NOTIN [-1,+1].'
        WRITE(7, *) 'In PLGNDR: bad argument - X NOTIN [-1,+1].'
        STOP
      ENDIF
C
C     COMPUTE P^M_M (X)
      PMM = 1.0D0
      IF(M.GT.0) THEN
        SOMX2 = DSQRT((1.0D0-X)*(1.0D0+X))
        FACT  = 1.0D0
        DO I=1,M
          PMM  =-PMM*FACT*SOMX2
          FACT = FACT + 2.0D0
        ENDDO
      ENDIF
C
C     APPLY RECURRENCE RELATION UNTIL WE HAVE P^M_L
      IF(L.EQ.M) THEN
        PLGNDR = PMM
      ELSE
        PMMP1 = X*PMM*(2*M+1)
        IF(L.EQ.M+1) THEN
C         COMPUTE P^M_M+1
          PLGNDR = PMMP1
        ELSE
C         COMPUTE P^M_L, L>M+1
          DO LL=M+2,L
            LLM   = LL-M
            PLL   = (X*(2*LL-1)*PMMP1-(LL+M-1)*PMM)/LLM
            PMM   = PMMP1
            PMMP1 = PLL
          ENDDO
          PLGNDR = PLL
        ENDIF
      ENDIF
C
      RETURN
      END
C
C
      FUNCTION NFACT(N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              NN    NN FFFFFFFF   AA     CCCCCC TTTTTTTT              C
C              NNN   NN FF        AAAA   CC    CC   TT                 C
C              NNNN  NN FF       AA  AA  CC         TT                 C
C              NN NN NN FFFFFF  AA    AA CC         TT                 C
C              NN  NNNN FF      AAAAAAAA CC         TT                 C
C              NN   NNN FF      AA    AA CC    CC   TT                 C
C              NN    NN FF      AA    AA  CCCCCC    TT                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  NFACT(N) RETURNS THE INTEGER RESTULT OF THE FACTORIAL N!.           C
C**********************************************************************C
      PARAMETER(NMAX=30)
C
C     CHECK THAT ARGUMENT IS VALID
      IF(N.LT.0) THEN
        WRITE(6, *) 'In NFACT: negative input number.',N
        WRITE(7, *) 'In NFACT: negative input number.',N
        STOP
      ELSEIF(N.GT.NMAX) THEN
        WRITE(6, *) 'In NFACT: N too large. N = ',N
        WRITE(7, *) 'In NFACT: N too large. N = ',N
        STOP
      ENDIF
C
C     FACTORIAL AS A PRODUCT OF INTEGERS
      NFACT = 1
      DO M=1,N
        NFACT = M*NFACT
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [12] R-INTS: BOYS INTEGRALS R-INTEGRALS AND RELATED QUANTITIES.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] RMAKE: BATCH OF R-INTEGRALS FOR BASIS FUNCTION OVERLAPS.       C
C   [B] FUNFM: LIST OF BOYS INTEGRALS FOR USE IN RMAKE.                C
C   [C] BOYSGEN: OUTPUT DATA FILE WITH FAMILY OF BOYS FUNCTIONS.       C
C   [D] HGTFS: BATCH OF HGTF AMPLITUDES EVALUATED AT (X,Y,Z).          C
C   [E] HERMITE: EVALUATION OF H_I (P,X) BY RECURRENCE.                C
C   [F] HTFRMS: BATCH OF HGTF FOURIER TRANSFORMS AT (QX,QY,QZ).        C
C**********************************************************************C
C
C
      SUBROUTINE RMAKE(RC,QP,APH,MAXM,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           RRRRRRR  MM       MM    AA    KK    KK EEEEEEEE            C
C           RR    RR MMM     MMM   AAAA   KK   KK  EE                  C
C           RR    RR MMMM   MMMM  AA  AA  KK  KK   EE                  C
C           RR    RR MM MM MM MM AA    AA KKKKK    EEEEEE              C
C           RRRRRRR  MM  MMM  MM AAAAAAAA KK  KK   EE                  C
C           RR    RR MM   M   MM AA    AA KK   KK  EE                  C
C           RR    RR MM       MM AA    AA KK    KK EEEEEEEE            C
C                                                                      C
C -------------------------------------------------------------------- C
C  RMAKE GENERATES A COMPLETE SET OF R-INTEGRALS REQUIRED IN THE       C
C  FINITE SUM REPRESENTATION OF A MULTI-CENTRE GAUSSIAN OVERLAP.       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION FS(MB2,ML4),APH(MB2),QP(MB2,3),RC(MB2,MRC),RC2(MB2,MRC)
      DIMENSION F1(MB2,ML4),F2(MB2,ML4),F3(MB2,ML4),F4(MB2,ML4)
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2),
     &          I1(MB2),I2(MB2),I3(MB2),I4(MB2)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C**********************************************************************C
C     THE FIRST STEP OF THIS ROUTINE IS TO EVALUATE THE REQUIRED       C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAM.            C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
      N1 = 0
      N2 = 0
      N3 = 0
      N4 = 0
C
C     FOR EACH PAIR OF BASIS FUNCTIONS (EXPONENTS EI AND EJ IN 'M'),
C     DETERMINE THE BEST WAY TO EVALUATE THE BOYS FUNCTION
      DO M=1,MAXM
C
        X = APH(M)*(QP(M,1)*QP(M,1)+QP(M,2)*QP(M,2)+QP(M,3)*QP(M,3))
C
C       CASE 1: IF X IS ALMOST ZERO (SO WHEN Q=P OR EIJ<<1)
        IF(X.LE.1.0D-11) THEN
          N1     = N1+1
          X1(N1) = X
          I1(N1) = M
C
C       CASE 2: IF X IS SMALLER THAN 17.0D0
        ELSEIF(X.GT.1.0D-11.AND.X.LE.17.0D0) THEN
          N2     = N2+1
          X2(N2) = X
          I2(N2) = M
C
C       CASE 3: IF X IS SMALLER THAN 30.0D0
        ELSEIF(X.GT.17.0D0.AND.X.LE.30.0D0) THEN
          N3     = N3+1
          X3(N3) = X
          I3(N3) = M
C
C       CASE 4: IF X IS LARGER THAN 30.0D0
        ELSE
          N4     = N4+1
          X4(N4) = X
          I4(N4) = M
        ENDIF
C
      ENDDO
C
C     EVALUATE THE BOYS INTEGRALS -- A BATCH FOR EACH ITYPE
C
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS X=0.0D0.
C     THE VALUE OF THIS FUNCTION IS 2N+1 (DONE IN FUNFM).
      IF(N1.GT.0) THEN
        CALL FUNFM(F1,X1,N1,LAM,1)
        DO K=1,LAM+1
          DO M=1,N1
            FS(I1(M),K) = F1(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=17.0D0.
C     EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C     AND RECURRENCE IN DIRECTION OF DECREASING M.
      IF(N2.GT.0) THEN
        CALL FUNFM(F2,X2,N2,LAM,2)
        DO K=1,LAM+1
          DO M=1,N2
            FS(I2(M),K) = F2(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=30.0D0.
C     EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
      IF(N3.GT.0) THEN
        CALL FUNFM(F3,X3,N3,LAM,3)
        DO K=1,LAM+1
          DO M=1,N3
            FS(I3(M),K) = F3(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C     CASE 4: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=30.0D0.
C     EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
      IF(N4.GT.0) THEN
        CALL FUNFM(F4,X4,N4,LAM,4)
        DO K=1,LAM+1
          DO M=1,N4
            FS(I4(M),K) = F4(M,K)
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     WITH THE FULL SET OF BOYS' INTEGRALS WE NOW APPLY RECURRENCE     C
C     RELATIONS TO F_N (X) AND EVALUATE THE R-INTEGRALS.               C
C**********************************************************************C
C
C     CONSTRUCT TOP LEVEL (FOR MAXIMUM LAM VALUE)
      DO M=1,MAXM
        RC(M,1)=((-2.0D0*APH(M))**(LAM))*FS(M,LAM+1)
      ENDDO
C
C     MINIMUM LEVEL ILEV BASED ON LAM VALUE
      IF(MOD(LAM,2).EQ.0) THEN
       ITUVMIN = 1
      ELSE
       ITUVMIN = 2
      ENDIF
C
C     INITIALISE ITUV COUNTER (RELATES TO # CARTESIAN INDICES FOR lam)
      ITUV=-1
C
C     MAIN LOOP: LEVEL 'ILEV' STARTING AT LAM-1 AND WORKING BACKWARDS
      DO ILEV=LAM-1,ITUVMIN,-2
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT = DFLOAT(IT)
C
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
C
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = INABCD(IT+1,IU  ,IV  )
              N2 = INABCD(IT  ,IU+1,IV  )
              N3 = INABCD(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILEV
            ENDDO
          ENDDO
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
        DO M=1,MAXM
          RC2(M,1) = ((-2.0D0*APH(M))**(ILEV))*FS(M,ILEV+1)
        ENDDO
C
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT=DFLOAT(IT)
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = INABCD(IT+1,IU  ,IV  )
              N2 = INABCD(IT  ,IU+1,IV  )
              N3 = INABCD(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                DO M=1,MAXM
                 RC(M,N1) =-QP(M,1)*RC2(M,K1) + RIT*RC2(M,M1)
                 RC(M,N2) =-QP(M,2)*RC2(M,K1)
                 RC(M,N3) =-QP(M,3)*RC2(M,K1)
               ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1) + RIU*RC2(M,M2)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1) + RIV*RC2(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC(M,N1) =-QP(M,1)*RC2(M,K1)
                  RC(M,N2) =-QP(M,2)*RC2(M,K1)
                  RC(M,N3) =-QP(M,3)*RC2(M,K1)
                ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILEV
            ENDDO
          ENDDO
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXM
          RC(M,1) = ((-2.0D0*APH(M))**(ILEV-1))*FS(M,ILEV)
        ENDDO
C
      ENDDO
C
C
C     AN ADDITIONAL LOOP OVER ADDRESSES (WHEN LAM IS ODD)
      IF(MOD(LAM,2).EQ.1) THEN
C
C       UPDATE ITUV COUNTER
        ITUV = ITUV+1
C
C       LOOP OVER ALL UNIQUE (IT,IU,IV)
        DO IT=0,ITUV
          RIT=DFLOAT(IT)
          DO IU=0,ITUV-IT
            RIU=DFLOAT(IU)
            DO IV=0,ITUV-IT-IU
              RIV=DFLOAT(IV)
C
C             R-INTEGRAL CARTESIAN DESTINATION ADDRESSES
              N1 = INABCD(IT+1,IU  ,IV  )
              N2 = INABCD(IT  ,IU+1,IV  )
              N3 = INABCD(IT  ,IU  ,IV+1)
C
C             RECURRENCE RELATIONS DIFFERENT IF ANY (IT,IU,IV) ARE ZERO

C             CASE (IT,IU,IV)
              IF(IT.NE.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT,IU, 0)
              ELSEIF(IT.NE.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE (IT, 0,IV)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE (IT, 0, 0)
              ELSEIF(IT.NE.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M1 = INABCD(IT-1,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1) + RIT*RC(M,M1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0,IU,IV)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0,IU, 0)
              ELSEIF(IT.EQ.0.AND.IU.NE.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M2 = INABCD(IT  ,IU-1,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1) + RIU*RC(M,M2)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
                ENDDO
C
C             CASE ( 0, 0,IV)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.NE.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                M3 = INABCD(IT  ,IU  ,IV-1)
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1) + RIV*RC(M,M3)
                ENDDO
C
C             CASE ( 0, 0, 0)
              ELSEIF(IT.EQ.0.AND.IU.EQ.0.AND.IV.EQ.0) THEN
                K1 = INABCD(IT  ,IU  ,IV  )
                DO M=1,MAXM
                  RC2(M,N1) =-QP(M,1)*RC(M,K1)
                  RC2(M,N2) =-QP(M,2)*RC(M,K1)
                  RC2(M,N3) =-QP(M,3)*RC(M,K1)
               ENDDO
C
C             ALL POSSIBILITIES ACCOUNTED FOR -- END LOOP
              ENDIF
C
C           END LOOPS OVER (IT,IU,IV) ADDRESSES FOR THIS ILEV
            ENDDO
          ENDDO
        ENDDO
C
C       ADD IN (IT=0,IU=0,IV=0) CASE
C
        DO M=1,MAXM
          RC2(M,1) = FS(M,1)
        ENDDO
C
C       MOVE THE RC2 ARRAY INTO RC
C
        ITMAX = (LAM+1)*(LAM+2)*(LAM+3)/6
        DO IT=1,ITMAX
          DO M=1,MAXM
            RC(M,IT) = RC2(M,IT)
          ENDDO
        ENDDO
C
C     END IF STATEMENT FOR THE ODD LAM CASE
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE FUNFM(FM,T,N,LAM,ITYPE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           FFFFFFFF UU    UU NN    NN FFFFFFFF MM       MM            C
C           FF       UU    UU NNN   NN FF       MMM     MMM            C
C           FF       UU    UU NNNN  NN FF       MMMM   MMMM            C
C           FFFFFF   UU    UU NN NN NN FFFFFF   MM MM MM MM            C
C           FF       UU    UU NN  NNNN FF       MM  MMM  MM            C
C           FF       UU    UU NN   NNN FF       MM   M   MM            C
C           FF        UUUUUU  NN    NN FF       MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  FUNFM EVALUATES INTEGRAL [INT_{0}^{1} U^{2M} EXP(-T*U^{2}) dU]      C
C  FOR VARIABLE T > 0 FOR ALL ORDERS 0 < M < LAM.                      C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    ITYPE = 1 - SPECIAL CASE X = 0.0D0.                               C
C    ITYPE = 2 - POWER SERIES AND REVERSE RECURRENCE.                  C
C                (60 TERMS WILL BE USED, SO USE MUST SUPPLY A VALUE    C
C                 APPROPRIATE TO THE MAX VALUE OF X IN BATCH).         C
C    ITYPE = 3 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C    ITYPE = 4 - ASYMPTOTIC EXPANSION AND FORWARD RECURRENCE.          C
C                ALL TERMS DEPENDING ON EXP(-X) ARE OMITTED TO AVOID   C
C                NUMERICAL UNDERFLOW PROBLEMS.                         C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION FM(MB2,ML4),T(MB2),TLAM(MB2),TT2(MB2),
     &          TXP(MB2),TRT(MB2)
C
      DATA PIROOT,A0,B0/8.862269254527580D-1,4.994501191201870D-1,
     &                                       4.551838436668326D-1/
C
C**********************************************************************C
C     ITYPE = 1: SPECIAL CASE FOR T = 0.0D0                            C
C**********************************************************************C
C
      IF(ITYPE.EQ.1) THEN
        DO K=1,LAM+1
          MVAL  = K-1
          VALUE = 1.0D0/DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,K) = VALUE
          ENDDO
        ENDDO
        RETURN
C
C**********************************************************************C
C     ITYPE = 2: POWER SERIES EVALUATION                               C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.2) THEN
C
C       INITIALISE THE POWER SERIES FOR M = LAM
        DO M=1,N
          TXP(M)      = DEXP(-T(M))
          TT2(M)      = 2.0D0*T(M)
          TLAM(M)     = 1.0D0
          FM(M,LAM+1) = 1.0D0
        ENDDO
C
C       LOOP OVER TERMS IN THE POWER SERIES
        DO K=1,60
          DLAM = DFLOAT(2*(LAM+K)+1)
          DO M=1,N
            TLAM(M)     = TLAM(M)*(TT2(M)/DLAM)
            FM(M,LAM+1) = FM(M,LAM+1) + TLAM(M)
          ENDDO
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DEN = DFLOAT((2*LAM)+1)
        DO M=1,N
          FM(M,LAM+1) = FM(M,LAM+1)*TXP(M)/DEN
        ENDDO
C
C       NOW COMPLETE TABLE BY BACKWARDS RECURRENCE
        DO I=1,LAM
          MIND  = LAM-I+1
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND) = (TT2(M)*FM(M,MIND+1) + TXP(M))/COEFF
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 3: ASYMPTOTIC EXPANSION WITH VERY LARGE ARGUMENT.        C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.3) THEN
C
C       INITIALISE THE ASYMPTOTIC EXPANSION
        DO M=1,N
          TXP(M) = DEXP(-T(M))
          TT2(M) = 2.0D0*T(M)
          TRT(M) = DSQRT(T(M))
        ENDDO
C
C       SEED VALUES
        DO M=1,N
          FM(M,1) = A0/(B0+T(M))
        ENDDO
C
C       RESCALE BY THE PREFACTOR
        DO M=1,N
          FM(M,1) = (PIROOT/TRT(M)) - (TXP(M)*FM(M,1))
        ENDDO
C
C       NOW COMPLETE TABLE BY FORWARD RECURRENCE
        DO MIND=1,LAM
          MVAL  = MIND-1
          COEFF = DFLOAT(MVAL+MVAL+1)
          DO M=1,N
            FM(M,MIND+1) = (COEFF*FM(M,MIND) - TXP(M))/TT2(M)
          ENDDO
        ENDDO
C
C**********************************************************************C
C     ITYPE = 4: ASYMPTOTIC EXPANSION WITH VERY LARGE ARGUMENT         C
C**********************************************************************C
C
      ELSEIF(ITYPE.EQ.4) THEN
C
C     INITIALISE THE ASYMPTOTIC EXPANSION
      DO M=1,N
        TT2(M)  = 2.0D0*T(M)
        FM(M,1) = PIROOT/DSQRT(T(M))
      ENDDO
C
C     NOW COMPLETE TABLE BY FORWARD RECURRENCE
      DO MIND=1,LAM
        MVAL  = MIND-1
        COEFF = DFLOAT(MVAL+MVAL+1)
        DO M=1,N
          FM(M,MIND+1) = (COEFF*FM(M,MIND))/TT2(M)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     ITYPE OUT OF RANGE: INVALID INPUT TO FUNFM                       C
C**********************************************************************C
C
      ELSE
91      FORMAT(2X,'In FUNFM: invalid type (must be 1-4)',I4)
        WRITE(6,91) ITYPE
        WRITE(7,91) ITYPE
        STOP
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE BOYSGEN(LAMBDA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    BBBBBBB   OOOOOO  YY    YY  SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C    BB    BB OO    OO YY    YY SS    SS GG    GG EE       NNN   NN    C
C    BB    BB OO    OO  YY  YY  SS       GG       EE       NNNN  NN    C
C    BBBBBBB  OO    OO   YYYY    SSSSSS  GG       EEEEEE   NN NN NN    C
C    BB    BB OO    OO    YY          SS GG   GGG EE       NN  NNNN    C
C    BB    BB OO    OO    YY    SS    SS GG    GG EE       NN   NNN    C
C    BBBBBBB   OOOOOO     YY     SSSSSS   GGGGGG  EEEEEEEE NN    NN    C
C                                                                      C
C -------------------------------------------------------------------- C
C  BOYSGEN PRODUCES A DATA FILE WHICH CONTAINS A FAMILY OF BOYS        C
C  FUNCTIONS OVER A SPECIFIED REGION, GIVEN A MAXIMUM FAMILY           C
C  PARAMETER DETERMINED BY LAMBDA.                                     C
C**********************************************************************C
      PARAMETER (MBS=26,MB2=MBS*MBS,MKP=9,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION X1(MB2),X2(MB2),X3(MB2),X4(MB2)
      DIMENSION F1(MB2,ML4),F2(MB2,ML4),F3(MB2,ML4),
     &          F4(MB2,ML4),FS(MB2,ML4)
C
C     EVALUATION PARAMETERS
      NTOT = 400
      XMIN = 0.00D0
      XMAX = 4.00D1
      HSTP = (XMAX-XMIN)/NTOT
C
C**********************************************************************C
C     THE FIRST STEP OF THIS SUBROUTINE IS TO EVALUATE THE REQUIRED    C
C     BOYS INTEGRALS. THIS IS DIVIDED INTO CASES, DEPENDING ON THE     C
C     MAGNITUDE OF THE ARGUMENT.                                       C
C -------------------------------------------------------------------- C
C        FS_M (X) = INT_{0}^{1} T^{2M} EXP(-X*T^{2}) DT                C
C -------------------------------------------------------------------- C
C   EVALUATED FOR ALL VALUES OF M IN THE RANGE 0 < M < LAMBDA.         C
C             FOR ALL VALUES OF X IN THE RANGE X > 0.                  C
C**********************************************************************C
C
      OPEN(UNIT=8,FILE='plots/boysfunction.dat',STATUS='UNKNOWN')
      REWIND(UNIT=8)
      DO NX=0,NTOT
C
      X = XMIN + HSTP*NX
C
C     DETERMINE THE BEST WAY TO EVALUATE THE BOYS FUNCTION
      IF(X.LE.1.00D-11) THEN
C     CASE 0: ARGUMENT OF THE BOYS FUNCTION IS X = 0.
C             THE VALUE OF THIS FUNCTION IS (2N+1).
        N1     = 1
        X1(N1) = X
        CALL FUNFM(F1,X1,N1,LAMBDA,1)
        DO JJ=1,LAMBDA+1
          FS(N1,JJ) = F1(N1,JJ)
        ENDDO
      ELSEIF(X.GT.1.00D-11.AND.X.LE.1.70D+01) THEN
C     CASE 1: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=17.
C             EVALUATE WITH LOCAL POLYNOMIAL EXPANSION OF ORDER 5,
C             AND RECURRENCE IN DIRECTION OF DECREASING M.
        N2     = 1
        X2(N2) = X
        CALL FUNFM(F2,X2,N2,LAMBDA,2)
        DO JJ=1,LAMBDA+1
          FS(N2,JJ) = F2(N2,JJ)
        ENDDO
      ELSEIF(X.GT.1.70D+01.AND.X.LE.3.00D+01) THEN
C     CASE 2: ARGUMENT OF THE BOYS FUNCTION IS SMALLER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITH EXPONENTIAL.
        N3     = 1
        X3(N3) = X
        CALL FUNFM(F3,X3,N3,LAMBDA,3)
        DO JJ=1,LAMBDA+1
          FS(N3,JJ) = F3(N3,JJ)
        ENDDO
      ELSE
C     CASE 3: ARGUMENT OF THE BOYS FUNCTION IS LARGER THAN X=30.
C             EVALUATE USING ASYMPTOTIC FORMULA WITHOUT EXPONENTIAL.
        N4     = 1
        X4(N4) = X
        CALL FUNFM(F4,X4,N4,LAMBDA,4)
        DO JJ=1,LAMBDA+1
          FS(N4,JJ) = F4(N4,JJ)
        ENDDO
      ENDIF
C
      WRITE(8, *) X,(FS(1,L),L=1,LAMBDA+1)
C
      ENDDO
      CLOSE(UNIT=8)
C
      RETURN
      END
C
C
      SUBROUTINE HGTFS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              HH    HH  GGGGGG TTTTTTTT FFFFFFFF SSSSSS               C
C              HH    HH GG    GG   TT    FF      SS    SS              C
C              HH    HH GG         TT    FF      SS                    C
C              HHHHHHHH GG         TT    FFFFFF   SSSSSS               C
C              HH    HH GG   GGG   TT    FF            SS              C
C              HH    HH GG    GG   TT    FF      SS    SS              C
C              HH    HH  GGGGGG    TT    FF       SSSSSS               C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTFS GENERATES AN ARRAY OF HGTF FUNCTIONS EVALUATED AT A SET OF    C
C  COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM TO       C
C  TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A        C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTRE, RP.     C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION HABC(MB2,MEQ)
      DIMENSION EXPT(MBS,2),NBAS(2)
      DIMENSION XYZEVAL(3),XYZ(3,2)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C     CALCULATE NUMBER OF UNIQUE CONTRIBUTIONS TO FINITE EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OF EXPONENTS
          PAB  = EXPT(IBAS,1)+EXPT(JBAS,2)
C
C         HGTF CENTRE COORDINATES
          PX = (EXPT(IBAS,1)*XYZ(1,1)+EXPT(JBAS,2)*XYZ(1,2))/PAB
          PY = (EXPT(IBAS,1)*XYZ(2,1)+EXPT(JBAS,2)*XYZ(2,2))/PAB
          PZ = (EXPT(IBAS,1)*XYZ(3,1)+EXPT(JBAS,2)*XYZ(3,2))/PAB
C
C         COORDINATES WRT LOCAL ORIGIN
          RPX = XYZEVAL(1)-PX
          RPY = XYZEVAL(2)-PY
          RPZ = XYZEVAL(3)-PZ
C
C         GAUSSIAN COMPONENT OF HGTF
          GSS  = DEXP(-PAB*(RPX*RPX+RPY*RPY+RPZ*RPZ))
C
C         CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            HALPH = HERMITE(PAB,RPX,IVEC(ITUV))
            HBETA = HERMITE(PAB,RPY,JVEC(ITUV))
            HGAMA = HERMITE(PAB,RPZ,KVEC(ITUV))
C
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = HALPH*HBETA*HGAMA*GSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      FUNCTION HERMITE(P,X,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    HH    HH EEEEEEEE RRRRRRR  MM       MM IIII TTTTTTTT EEEEEEEE     C
C    HH    HH EE       RR    RR MMM     MMM  II     TT    EE           C
C    HH    HH EE       RR    RR MMMM   MMMM  II     TT    EE           C
C    HHHHHHHH EEEEEE   RR    RR MM MM MM MM  II     TT    EEEEEE       C
C    HH    HH EE       RRRRRRR  MM  MMM  MM  II     TT    EE           C
C    HH    HH EE       RR    RR MM   M   MM  II     TT    EE           C
C    HH    HH EEEEEEEE RR    RR MM       MM IIII    TT    EEEEEEEE     C
C                                                                      C
C -------------------------------------------------------------------- C
C  HERMITE EVALUATES HERMITE POLYNOMIAL H_I (P,X) BY RECURRENCE.       C
C**********************************************************************C
      PARAMETER (IMAX=40)
C
      IF(I.LT.0) THEN
        WRITE(6, *) 'In HERMITE: index less than zero. I = ',I
        WRITE(7, *) 'In HERMITE: index less than zero. I = ',I
        STOP
      ENDIF
C
      IF(I.GT.IMAX) THEN
        WRITE(6, *) 'In HERMITE: index greater than max. I = ',I
        WRITE(7, *) 'In HERMITE: index greater than max. I = ',I
        STOP
      ENDIF
C
C     NEED FIRST TWO VALUES TO ESTABLISH RECURRENCE RELATION
      TEMP1 = 1.0D0
      TEMP2 = 2.0D0*P*X
C
      IF(I.EQ.0) THEN
        HERMITE = TEMP1
      ELSEIF(I.EQ.1) THEN
        HERMITE = TEMP2
      ELSEIF(I.GT.1) THEN
        DO N=2,I
          TEMP3 = 2.0D0*P*(X*TEMP2 - (N-1)*TEMP1)
          TEMP1 = TEMP2
          TEMP2 = TEMP3
        ENDDO
        HERMITE = TEMP2
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE HTFRMS(HABC,XYZEVAL,EXPT,XYZ,NBAS,LAM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C       HH    HH TTTTTTTT FFFFFFFF RRRRRRR  MM       MM  SSSSSS        C
C       HH    HH    TT    FF       RR    RR MMM     MMM SS    SS       C
C       HH    HH    TT    FF       RR    RR MMMM   MMMM SS             C
C       HHHHHHHH    TT    FFFFFF   RR    RR MM MM MM MM  SSSSSS        C
C       HH    HH    TT    FF       RRRRRRR  MM  MMM  MM       SS       C
C       HH    HH    TT    FF       RR    RR MM   M   MM SS    SS       C
C       HH    HH    TT    FF       RR    RR MM       MM  SSSSSS        C
C                                                                      C
C -------------------------------------------------------------------- C
C  HGTFS GENERATES AN ARRAY OF HGTF FOURIER TRANSFORMS EVALUATED AT A  C
C  SET OF COORDINATES XYZEVAL(3), USING THE GAUSSIAN PRODUCT THEOREM   C
C  TO TRANSFORM AN ARBITRARY PRODUCT OF TWO BASIS FUNCTIONS INTO A     C
C  FINITE SUM OF EQ-COEFFICIENTS AND HGTFS ON A SINGLE CENTRE, RP.     C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION EXPT(MBS,2),KQN(2),NBAS(2)
      DIMENSION XYZEVAL(3),XYZ(3,2)
C
      COMPLEX*16 CONE,PHS,PHSQP
      COMPLEX*16 HABC(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
      DATA PI,ROOTPI/3.1415926535897932D0,1.7724538509055160D0/
C
C     UNIT COMPLEX NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     CALCULATE NUMBER OF UNIQUE CONTRIBUTIONS TO FINITE EXPANSION
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
C         SUM OF EXPONENTS
          PAB  = EXPT(IBAS,1)+EXPT(JBAS,2)
C
C         HGTF CENTRE COORDINATES
          PX = (EXPT(IBAS,1)*XYZ(1,1)+EXPT(JBAS,2)*XYZ(1,2))/PAB
          PY = (EXPT(IBAS,1)*XYZ(2,1)+EXPT(JBAS,2)*XYZ(2,2))/PAB
          PZ = (EXPT(IBAS,1)*XYZ(3,1)+EXPT(JBAS,2)*XYZ(3,2))/PAB
C
C         COORDINATES WRT LOCAL ORIGIN
          QPX = XYZEVAL(1)*PX
          QPY = XYZEVAL(2)*PY
          QPZ = XYZEVAL(3)*PZ
C
C         DOT PRODUCT FACTOR (COMPLEX WITH UNIT MAGNITUDE)
          QPVEC = QPX+QPY+QPZ
C         PHSQP = DEXP(-CONE*QPVEC)
          PHSQP = DCOS(QPVEC) + CONE*DSIN(QPVEC)
C
C         GAUSSIAN COMPONENT OF HTFRM
          QX2 = XYZEVAL(1)*XYZEVAL(1)
          QY2 = XYZEVAL(2)*XYZEVAL(2)
          QZ2 = XYZEVAL(3)*XYZEVAL(3)
          GSS = DEXP(-0.75D0*(QX2*QX2+QY2*QY2+QZ2*QZ2)/PAB)
C
C         INTEGRAL TRANSFORM TERM
          PRT = PAB*DSQRT(PAB)
          SCL = PI*ROOTPI/PRT
C
C         CALCULATE HERMITE POLYNOMIAL PRODUCTS FOR ALL {A,B,C}
          DO ITUV=1,NTUV
C
C           TEST TO DETERMINE MULTIPLICATIVE FACTOR
            IF(MOD(LAMVEC(ITUV),4).EQ.0) THEN
              PHS = DCMPLX(1.0D0,0.0D0)
            ELSEIF(MOD(LAMVEC(ITUV),4).EQ.1) THEN
              PHS =-DCMPLX(0.0D0,1.0D0)
            ELSEIF(MOD(LAMVEC(ITUV),4).EQ.2) THEN
              PHS =-DCMPLX(1.0D0,0.0D0)
            ELSEIF(MOD(LAMVEC(ITUV),4).EQ.3) THEN
              PHS = DCMPLX(0.0D0,1.0D0)
            ENDIF
C
C           HERMITE POLYNOMIALS FOR THIS BASIS PAIR OVER ALL ITUV
            QXA = XYZEVAL(1)**(IVEC(ITUV))
            QXB = XYZEVAL(2)**(JVEC(ITUV))
            QXC = XYZEVAL(3)**(KVEC(ITUV))
C
C           ADD TO BASIS FUNCTION PRODUCT
            HABC(M,ITUV) = SCL*PHS*QXA*QXB*QXC*PHSQP*GSS
C
          ENDDO
C
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [13] EQ-COEFFS: FINITE BASIS OVERLAP SPIN STRUCTURE FACTORS.        C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] EQFILE: MAIN ROUTINE FOR BUILDING A GLOBAL FILE OF EQ-COEFFS.  C
C   [B] ESETLL: CONSTRUCT AND SAVE ALL ELL0 COEFFICIENTS EXTERNALLY.   C
C   [C] ESETSS: CONSTRUCT AND SAVE ALL ESS0 COEFFICIENTS EXTERNALLY.   C
C   [D] ESETLS: CONSTRUCT AND SAVE ALL ELSQ COEFFICIENTS EXTERNALLY.   C
C   [E] EMAKELL: GENERATE A COMPLETE BLOCK OF EQLL COEFFICIENTS.       C
C   [F] EMAKESS: GENERATE A COMPLETE BLOCK OF EQSS COEFFICIENTS.       C
C   [G] EMAKELS: GENERATE A COMPLETE BLOCK OF EQLS COEFFICIENTS.       C
C   [H] EMAKESL: GENERATE A COMPLETE BLOCK OF EQSL COEFFICIENTS.       C
C   [I] EQLL: A RAW BLOCK OF EQLL COEFFICIENTS FOR EMAKELL.            C
C   [J] EQSS: A RAW BLOCK OF EQSS COEFFICIENTS FOR EMAKESS.            C
C   [K] EQLS: A RAW BLOCK OF EQLS COEFFICIENTS FOR EMAKELS.            C
C   [L] EQSL: A RAW BLOCK OF EQSL COEFFICIENTS FOR EMAKELS.            C
C   [M] ESGTF: SET OF ES-COEFFS OVER SPHERICAL HARMONICS AND HGTFS.    C
C   [N] VRS: EXPANSION COEFFS IN HGTF OVERLAPS, CALLED IN ESGTF.       C
C   [O] STEPLM: SIMULTANEOUS INCREASE IN (L,M) FOR USE IN VRS.         C
C   [P] STEPL: INCREMENT IN L FOR USE IN VRS.                          C
C   [Q] STEPN: INCREMENT IN N FOR USE IN VRS.                          C
C   [R] RNLL: A BLOCK OF LL NORMALISATION COEFFS.                      C
C   [S] RNSS: A BLOCK OF SS NORMALISATION COEFFS.                      C
C   [T] RNLS: A BLOCK OF LS NORMALISATION COEFFS.                      C
C   [U] DNORM: NORM FOR A REAL OR COMPLEX PART OF EQ-COEFF LIST.       C
C**********************************************************************C
C
C
      SUBROUTINE EQFILE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C          EEEEEEEE  QQQQQQ   FFFFFFFF IIII LL       EEEEEEEE          C
C          EE       QQ    QQ  FF        II  LL       EE                C
C          EE       QQ    QQ  FF        II  LL       EE                C
C          EEEEEE   QQ    QQ  FFFFFF    II  LL       EEEEEE            C
C          EE       QQ   QQQ  FF        II  LL       EE                C
C          EE       QQ    QQ  FF        II  LL       EE                C
C          EEEEEEEE  QQQQQQ Q FF       IIII LLLLLLLL EEEEEEEE          C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQFILE CONSTRUCTS A SET OF COMMON ARRAYS FOR ALL REQUIRED EQTT      C
C  COEFFICIENTS IN A CALCULATION THAT RESTS WITHIN QED.                C
C**********************************************************************C
      PARAMETER(MBS=26,MCT=4,MKP=9,MFL=15000000)
C
      CHARACTER*4 HMLT
C
      DIMENSION NLL(0:MKP),NSS(0:MKP),NLS(0:MKP)
C
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/TMMD/TELL,TESS,TELS,TESL,TRLL,TRSS,TRLS,TRBR
C
C**********************************************************************C
C     LOOP OVER FOCK BLOCK AND COUNT ALL REQUIRED EQ-WORDS.            C
C**********************************************************************C
C
C     INITIALISE MAXIMUM LAMBDA
      LAMMX = 0
C
C     INITIALISE TOTAL COEFFICIENT COUNTERS
      NADE0LL =  0
      NADE0SS =  0
      NADEILS =  0
C
C     INITIALISE COEFFICIENT COUNTERS FOR LAMBDA CLASS
      DO ILAM=0,MKP
        NLL(ILAM) = 0
        NSS(ILAM) = 0
        NLS(ILAM) = 0
      ENDDO
C
C     LOOP OVER CENTRES A AND B
      DO ICNTA=1,NCNT
        DO ICNTB=1,NCNT
C
C         LOOP OVER KQNA VALUES
          DO KA=1,NKAP(ICNTA)
C
C           QUANTUM NUMBERS FOR BLOCK A
            IF(KAPA(KA,ICNTA).LT.0) THEN
              LQNA =-KAPA(KA,ICNTA)-1
            ELSE
              LQNA = KAPA(KA,ICNTA)
            ENDIF
            NBASA = NFNC(LQNA+1,ICNTA)
C
C           LOOP OVER KQNB VALUES
            DO KB=1,NKAP(ICNTB)
C
C             QUANTUM NUMBERS FOR BLOCK B
              IF(KAPA(KB,ICNTB).LT.0) THEN
                LQNB =-KAPA(KB,ICNTB)-1
              ELSE
                LQNB = KAPA(KB,ICNTB)
              ENDIF
              NBASB = NFNC(LQNB+1,ICNTB)
C
C             LOOP OVER |MQNA| VALUES
              DO MA=1,IABS(KAPA(KA,ICNTA))
                MJA = 2*MA-1
C
C               LOOP OVER |MQNB| VALUES
                DO MB=1,IABS(KAPA(KB,ICNTB))
                  MJB = 2*MB-1
C
C                 NUMBER OF BASIS FUNCTION OVERLAPS
                  MAXAB = NBASA*NBASB
C
C                 CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
                  LAMAB  = LQNA+LQNB
                  NTUVLL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
                  NTUVSS = (LAMAB+3)*(LAMAB+4)*(LAMAB+5)/6
                  NTUVLS = (LAMAB+2)*(LAMAB+3)*(LAMAB+4)/6
C
C                 UPDATE LARGEST LAMBDA VALUE
                  IF(LAMAB.GT.LAMMX) THEN
                    LAMMX = LAMAB
                  ENDIF
C
C                 INCREASE NUMBER OF WORDS FOR THIS LAMBDA VALUE
                  NLL(LAMAB  ) = NLL(LAMAB  ) + NTUVLL*MAXAB
                  NSS(LAMAB+2) = NSS(LAMAB+2) + NTUVSS*MAXAB
                  NLS(LAMAB+1) = NLS(LAMAB+1) + NTUVLS*MAXAB*3
C
C                 INCREASE TOTAL NUMBER OF WORDS
                  NADE0LL =  NADE0LL + NTUVLL*MAXAB
                  NADE0SS =  NADE0SS + NTUVSS*MAXAB
                  NADEILS =  NADEILS + NTUVLS*MAXAB*3
C
C               END LOOPS OVER |MQNA| AND |MQNB|
                ENDDO
              ENDDO
C
C           END LOOPS OVER KQNA AND KQNB
            ENDDO
          ENDDO
C
C       END LOOPS OVER ICNTA AND ICNTB
        ENDDO
      ENDDO
C
C     DOUBLE LOOP OVER FOCK BLOCK COMPLETE
C
C**********************************************************************C
C     SUMMARY OF WORD ANALYSIS                                         C
C**********************************************************************C
C
C     SECTION TITLE
20    FORMAT(1X,A,4X,A,4X,A,6X,A,4X,A,8X,A,6X,A)
21    FORMAT(1X,A,8X,I2,4X,I5,3X,I9,7X,I2,3X,I10,5X,F10.3)
22    FORMAT(1X,A,20X,I10,12X,I10,5X,F10.3)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) REPEAT(' ',22),'E-coefficient word analysis'
      WRITE(7, *) REPEAT(' ',22),'E-coefficient word analysis'
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6,20) 'Type','Lambda','Terms','Length','Mult.',
     &            'Words','Size (MB)'
      WRITE(7,20) 'Type','Lambda','Terms','Length','Mult.',
     &            'Words','Size (MB)'
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     INITIALISE OVERALL WORD COUNTER AND SIZE COUNTER
      NADETOT = 0
      NWRDTOT = 0
      SPCETOT = 0.0D0
C
C     E0LL ANALYSIS
      DO ILAM=0,LAMMX
        IF(NLL(ILAM).EQ.0) GOTO 200
        NTUVLL = (ILAM+1)*(ILAM+2)*(ILAM+3)/6
        SPCELL = NLL(ILAM)*8*8.0D-6
        WRITE(6,21) 'E0LL',ILAM,NTUVLL,NLL(ILAM),8,NLL(ILAM)*8,SPCELL
        WRITE(7,21) 'E0LL',ILAM,NTUVLL,NLL(ILAM),8,NLL(ILAM)*8,SPCELL
        NADETOT = NADETOT + NLL(ILAM)
        NWRDTOT = NWRDTOT + NLL(ILAM)*8
        SPCETOT = SPCETOT + SPCELL
200     CONTINUE
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      IF(HMLT.EQ.'NORL') GOTO 100
C
C     E0SS ANALYSIS
      DO ILAM=2,LAMMX+2
        IF(NSS(ILAM).EQ.0) GOTO 210
        NTUVSS = (ILAM+1)*(ILAM+2)*(ILAM+3)/6
        SPCESS = NSS(ILAM)*8*8.0D-6
        WRITE(6,21) 'E0SS',ILAM,NTUVSS,NSS(ILAM),8,NSS(ILAM)*8,SPCESS
        WRITE(7,21) 'E0SS',ILAM,NTUVSS,NSS(ILAM),8,NSS(ILAM)*8,SPCESS
        NADETOT = NADETOT + NSS(ILAM)
        NWRDTOT = NWRDTOT + NSS(ILAM)*8
        SPCETOT = SPCETOT + SPCESS
210     CONTINUE
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 100
C
C     EILS ANALYSIS
      DO ILAM=1,LAMMX+1
        IF(NLS(ILAM).EQ.0) GOTO 220
        NTUVLS = (ILAM+1)*(ILAM+2)*(ILAM+3)/6
        SPCELS = NSS(ILAM)*24*8.0D-6
        WRITE(6,21) 'EILS',ILAM,NTUVLS,NLS(ILAM),24,NLS(ILAM)*24,SPCELS
        WRITE(7,21) 'EILS',ILAM,NTUVLS,NLS(ILAM),24,NLS(ILAM)*24,SPCELS
        NADETOT = NADETOT + NLS(ILAM)
        NWRDTOT = NWRDTOT + NLS(ILAM)*24
        SPCETOT = SPCETOT + SPCELS
220     CONTINUE
      ENDDO
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
100   CONTINUE
C
C     SUMMARY OF TOTALS
      WRITE(6,22) 'Total',NADETOT,NWRDTOT,SPCETOT
      WRITE(7,22) 'Total',NADETOT,NWRDTOT,SPCETOT
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
C
C     OPTION WHEN NUMBER OF WORDS EXCEEDS ALLOCATED SIZE LIMIT
      IF(NADE0LL.GT.MFL) THEN
        WRITE(6, *) 'In EQFILE: E0LL words exceed allocated limit.'
        WRITE(7, *) 'In EQFILE: E0LL words exceed allocated limit.'
        GOTO 150
      ENDIF
C
      IF(HMLT.NE.'NORL') THEN
        IF(NADE0SS.GT.MFL) THEN
          WRITE(6, *) 'In EQFILE: E0SS words exceed allocated limit.'
          WRITE(7, *) 'In EQFILE: E0SS words exceed allocated limit.'
          GOTO 150
        ENDIF
      ENDIF
C
      IF(HMLT.EQ.'DHFB'.OR.HMLT.EQ.'DHFP'.OR.HMLT.EQ.'DHFQ') THEN
        IF(NADEILS.GT.MFL) THEN
          WRITE(6, *) 'In EQFILE: EILS words exceed allocated limit.'
          WRITE(7, *) 'In EQFILE: EILS words exceed allocated limit.'
          GOTO 150
        ENDIF
      ENDIF

C     SIZE LIMITS ARE ALL OK -- SKIP TO BATCH GENERATION
      GOTO 250
C
C     ONE OF THE CLASSES EXCEEDS WORD LIMIT
150   CONTINUE
      WRITE(6, *) REPEAT('-',72)
      WRITE(7, *) REPEAT('-',72)
C
C     HAVE TO GENERATE E COEFFICIENTS BY BATCH
      WRITE(6, *) 'In EQFILE: E-coefficients to be generated by batch.'
      WRITE(7, *) 'In EQFILE: E-coefficients to be generated by batch.'
C
C     FLIP THE EQ-GENERATION TOGGLE AND EXIT
      IEQS = 0
      GOTO 300
C
250   CONTINUE
C
C**********************************************************************C
C     GENERATE COMPLETE BATCH OF EQ-COEFFS                             C
C**********************************************************************C
C
C     SECTION TITLE
      WRITE(6, *) REPEAT(' ',18),'Generating E-coefficient data files'
      WRITE(7, *) REPEAT(' ',18),'Generating E-coefficient data files'
C
C     E0LL COEFFICIENTS
      CALL CPU_TIME(TDM1)
      CALL ESETLL
      CALL CPU_TIME(TDM2)
      TELL = TELL+TDM2-TDM1
C
      IF(HMLT.EQ.'NORL') GOTO 300
C
C     E0SS COEFFICIENTS
      CALL ESETSS
      CALL CPU_TIME(TDM3)
      TESS = TELL+TDM3-TDM2
C
      IF(HMLT.EQ.'BARE'.OR.HMLT.EQ.'DHFR') GOTO 300
C
C     EILS COEFFICIENTS
      CALL ESETLS
      CALL CPU_TIME(TDM4)
      TELS = TELS+TDM4-TDM3
C
300   CONTINUE
C
C     END OF SECTION
      WRITE(6, *) REPEAT('=',72)
      WRITE(7, *) REPEAT('=',72)
      WRITE(6, *) ' '
      WRITE(7, *) ' '
C
      RETURN
      END
C
C
      SUBROUTINE ESETLL
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS  EEEEEEEE TTTTTTTT LL       LL               C
C         EE      SS    SS EE          TT    LL       LL               C
C         EE      SS       EE          TT    LL       LL               C
C         EEEEEE   SSSSSS  EEEEEE      TT    LL       LL               C
C         EE            SS EE          TT    LL       LL               C
C         EE      SS    SS EE          TT    LL       LL               C
C         EEEEEEEE SSSSSS  EEEEEEEE    TT    LLLLLLLL LLLLLLLL         C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESETLL CONSTRUCTS ALL ELL0 COEFFICIENTS FOR A SYSTEM WITH CALLS TO  C
C  EMAKELL AND SAVES THEM TO AN EXTERNAL DATA FILE.                    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)
      NTUVLL = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ELL0(AB) COEFFICIENTS
      CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ELL0(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLL
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0LLFL(IAD+M,1) = DREAL(E11(M,ITUV))
          E0LLFL(IAD+M,2) = DIMAG(E11(M,ITUV))
          E0LLFL(IAD+M,3) = DREAL(E21(M,ITUV))
          E0LLFL(IAD+M,4) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     GENERATE ELL0(CD) COEFFICIENTS
      CALL EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,-1,1,2,0)
C
C     WRITE ELL0(CD) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLL
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0LLFL(IAD+M,5) = DREAL(E11(M,ITUV))
          E0LLFL(IAD+M,6) = DIMAG(E11(M,ITUV))
          E0LLFL(IAD+M,7) = DREAL(E21(M,ITUV))
          E0LLFL(IAD+M,8) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLL*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ESETSS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS  EEEEEEEE TTTTTTTT SSSSSS   SSSSSS           C
C         EE      SS    SS EE          TT   SS    SS SS    SS          C
C         EE      SS       EE          TT   SS       SS                C
C         EEEEEE   SSSSSS  EEEEEE      TT    SSSSSS   SSSSSS           C
C         EE            SS EE          TT         SS       SS          C
C         EE      SS    SS EE          TT   SS    SS SS    SS          C
C         EEEEEEEE SSSSSS  EEEEEEEE    TT    SSSSSS   SSSSSS           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESETSS CONSTRUCTS ALL ESS0 COEFFICIENTS FOR A SYSTEM WITH CALLS TO  C
C  EMAKESS AND SAVES THEM TO AN EXTERNAL DATA FILE.                    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+2
      NTUVSS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ESS0(AB) COEFFICIENTS
      CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2,0)
C
C     WRITE ESS0(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVSS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0SSFL(IAD+M,1) = DREAL(E11(M,ITUV))
          E0SSFL(IAD+M,2) = DIMAG(E11(M,ITUV))
          E0SSFL(IAD+M,3) = DREAL(E21(M,ITUV))
          E0SSFL(IAD+M,4) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     GENERATE ESS0(CD) COEFFICIENTS
      CALL EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,-1,1,2,0)
C
C     WRITE ESS0(CD) TO THE MAIN ARRAY
      DO ITUV=1,NTUVSS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          E0SSFL(IAD+M,5) = DREAL(E11(M,ITUV))
          E0SSFL(IAD+M,6) = DIMAG(E11(M,ITUV))
          E0SSFL(IAD+M,7) = DREAL(E21(M,ITUV))
          E0SSFL(IAD+M,8) = DIMAG(E21(M,ITUV))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVSS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE ESETLS
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C         EEEEEEEE SSSSSS  EEEEEEEE TTTTTTTT LL       SSSSSS           C
C         EE      SS    SS EE          TT    LL      SS    SS          C
C         EE      SS       EE          TT    LL      SS                C
C         EEEEEE   SSSSSS  EEEEEE      TT    LL       SSSSSS           C
C         EE            SS EE          TT    LL            SS          C
C         EE      SS    SS EE          TT    LL      SS    SS          C
C         EEEEEEEE SSSSSS  EEEEEEEE    TT    LLLLLLLL SSSSSS           C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESETLS CONSTRUCTS ALL ESS0 COEFFICIENTS FOR A SYSTEM WITH CALLS TO  C
C  EMAKELS AND SAVES THEM TO AN EXTERNAL DATA FILE.                    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),LQN(4),MQN(4),NBAS(4)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
C
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
C
C**********************************************************************C
C     FIRST LAYER OF LOOPS, OVER CENTRES A AND B (USE INDEX 2000)      C
C**********************************************************************C
C
C     INITIALISE COUNT INDEX
      ICOUNT = 0
C
C     LOOP OVER CENTRE A
      DO 2000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 2000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER |MQN(A)| VALUES
      DO 2000 MA=1,IABS(KQN(1))
        MJA    = 2*MA-1
        MQN(1) = MJA
C
C     LOOP OVER |MQN(B)| VALUES
      DO 2000 MB=1,IABS(KQN(2))
        MJB    = 2*MB-1
        MQN(2) = MJB
C
C**********************************************************************C
C     AT THIS POINT, WE ARE WITHIN A BLOCK OF 4 COMBINATIONS (MA,MB).  C
C     FOR GIVEN (|MA|,|MB|), THE COMBINATIONS ARE ORDERED:             C
C -------------------------------------------------------------------- C
C  11: = (-|MQN(A)|,-|MQN(B)|) -> 1  12: = (-|MQN(A)|,+|MQN(B)|) -> 2  C
C  21: = (+|MQN(A)|,-|MQN(B)|) -> 3  22: = (+|MQN(A)|,+|MQN(B)|) -> 4  C
C**********************************************************************C
C
C     NUMBER OF BASIS FUNCTION OVERLAPS
      MAXAB = NBAS(1)*NBAS(2)
C
C     CALCULATE LAM VALUES FOR THIS OVERLAP CHOICE
      LAMAB  = LQN(1)+LQN(2)+1
      NTUVLS = (LAMAB+1)*(LAMAB+2)*(LAMAB+3)/6
C
C     INDEX TO TRACK START OF THIS BLOCK OF COEFFICIENTS
      IADILS(ICNTA,ICNTB,KA,KB,MA,MB) = ICOUNT
C
C     GENERATE ELSI(AB) COEFFICIENTS
      CALL EMAKEB3(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,+1,1,2)
C
C     WRITE ELSI(AB) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          EILSFL(IAD+M, 1) = DREAL(E11(M,ITUV,1))
          EILSFL(IAD+M, 2) = DIMAG(E11(M,ITUV,1))
          EILSFL(IAD+M, 3) = DREAL(E21(M,ITUV,1))
          EILSFL(IAD+M, 4) = DIMAG(E21(M,ITUV,1))
          EILSFL(IAD+M, 5) = DREAL(E11(M,ITUV,2))
          EILSFL(IAD+M, 6) = DIMAG(E11(M,ITUV,2))
          EILSFL(IAD+M, 7) = DREAL(E21(M,ITUV,2))
          EILSFL(IAD+M, 8) = DIMAG(E21(M,ITUV,2))
          EILSFL(IAD+M, 9) = DREAL(E11(M,ITUV,3))
          EILSFL(IAD+M,10) = DIMAG(E11(M,ITUV,3))
          EILSFL(IAD+M,11) = DREAL(E21(M,ITUV,3))
          EILSFL(IAD+M,12) = DIMAG(E21(M,ITUV,3))
        ENDDO
      ENDDO
C
C     GENERATE ELSI(CD) COEFFICIENTS
      CALL EMAKEB3(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,-1,1,2)
C
C     WRITE ELSI(CD) TO THE MAIN ARRAY
      DO ITUV=1,NTUVLS
        IAD = ICOUNT + (ITUV-1)*MAXAB
        DO M=1,MAXAB
          EILSFL(IAD+M,13) = DREAL(E11(M,ITUV,1))
          EILSFL(IAD+M,14) = DIMAG(E11(M,ITUV,1))
          EILSFL(IAD+M,15) = DREAL(E21(M,ITUV,1))
          EILSFL(IAD+M,16) = DIMAG(E21(M,ITUV,1))
          EILSFL(IAD+M,17) = DREAL(E11(M,ITUV,2))
          EILSFL(IAD+M,18) = DIMAG(E11(M,ITUV,2))
          EILSFL(IAD+M,19) = DREAL(E21(M,ITUV,2))
          EILSFL(IAD+M,20) = DIMAG(E21(M,ITUV,2))
          EILSFL(IAD+M,21) = DREAL(E11(M,ITUV,3))
          EILSFL(IAD+M,22) = DIMAG(E11(M,ITUV,3))
          EILSFL(IAD+M,23) = DREAL(E21(M,ITUV,3))
          EILSFL(IAD+M,24) = DIMAG(E21(M,ITUV,3))
        ENDDO
      ENDDO
C
C     INCREASE COUNT INDEX
      ICOUNT = ICOUNT + NTUVLS*MAXAB
C
C     END LOOPS OVER FOCK BLOCK
2000  CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE EMAKELL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE LL      LL         C
C   EE       MMM     MMM   AAAA   KK   KK  EE       LL      LL         C
C   EE       MMMM   MMMM  AA  AA  KK  KK   EE       LL      LL         C
C   EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   LL      LL         C
C   EE       MM  MMM  MM AAAAAAAA KK  KK   EE       LL      LL         C
C   EE       MM   M   MM AA    AA KK   KK  EE       LL      LL         C
C   EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE LLLLLLL LLLLLLL    C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKELL GENERATES BLOCKS OF SPHERICAL SPINOR E-COEFFICIENTS BY      C
C  CONTRACTING ON THE E-COEFFICIENTS FOR SCALAR SGTFS, USING A         C
C  DEVELOPMENT OF THE ALGORITHM OF V.R. SAUNDERS.                      C
C -------------------------------------------------------------------- C
C  H.M.QUINEY THE UNIVERSITY OF MELBOURNE (2008).                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
      DIMENSION EXL(MBS,2),BXYZ(3,2),KAP(2),MAG(2),NBS(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        BXYZ(IX,1) = XYZ(IX,I1)
        BXYZ(IX,2) = XYZ(IX,I2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KAP(1) = KQN(I1)
      KAP(2) = KQN(I2)
C
C     CALCULATE LQN VALUES
      IF(KAP(1).LT.0) THEN
        LA =-KAP(1)-1
      ELSE
        LA = KAP(1)
      ENDIF
      IF(KAP(2).LT.0) THEN
        LB =-KAP(2)-1
      ELSE
        LB = KAP(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NBS(1) = NBAS(I1)
      DO IBAS=1,NBS(1)
        EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
      NBS(2) = NBAS(I2)
      DO JBAS=1,NBS(2)
        EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLL  = LA+LB
      NTUVLL = (LAMLL+1)*(LAMLL+2)*(LAMLL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) =-MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E11,EXL,BXYZ,KAP,MAG,NBS,IQ)
C
C     MULTIPLY ELL0 BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) = MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLL(E21,EXL,BXYZ,KAP,MAG,NBS,IQ)
C
C     MULTIPLY ELL0 BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVLL
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EMAKESS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE SSSSSS   SSSSSS    C
C   EE       MMM     MMM   AAAA   KK   KK  EE      SS    SS SS    SS   C
C   EE       MMMM   MMMM  AA  AA  KK  KK   EE      SS       SS         C
C   EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   SSSSSS   SSSSSS    C
C   EE       MM  MMM  MM AAAAAAAA KK  KK   EE            SS       SS   C
C   EE       MM   M   MM AA    AA KK   KK  EE      SS    SS SS    SS   C
C   EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE SSSSSS   SSSSSS    C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKESS GENERATES BLOCKS OF SPHERICAL SPINOR E-COEFFICIENTS BY      C
C  CONTRACTING ON THE E-COEFFICIENTS FOR SCALAR SGTFS, USING A         C
C  DEVELOPMENT OF THE ALGORITHM OF V.R. SAUNDERS.                      C
C -------------------------------------------------------------------- C
C  H.M.QUINEY THE UNIVERSITY OF MELBOURNE (2008).                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
      DIMENSION EXL(MBS,2),BXYZ(3,2),KAP(2),MAG(2),NBS(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        BXYZ(IX,1) = XYZ(IX,I1)
        BXYZ(IX,2) = XYZ(IX,I2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KAP(1) = KQN(I1)
      KAP(2) = KQN(I2)
C
C     CALCULATE LQN VALUES
      IF(KAP(1).LT.0) THEN
        LA =-KAP(1)-1
      ELSE
        LA = KAP(1)
      ENDIF
      IF(KAP(2).LT.0) THEN
        LB =-KAP(2)-1
      ELSE
        LB = KAP(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NBS(1) = NBAS(I1)
      DO IBAS=1,NBS(1)
        EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
      NBS(2) = NBAS(I2)
      DO JBAS=1,NBS(2)
        EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSS  = LA+LB+2
      NTUVSS = (LAMSS+1)*(LAMSS+2)*(LAMSS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) =-MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E11,EXL,BXYZ,KAP,MAG,NBS,IQ)
C
C     MULTIPLY ESS0 BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) = MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSS(E21,EXL,BXYZ,KAP,MAG,NBS,IQ)
C
C     MULTIPLY ESS0 BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVSS
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY SIMPLE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EMAKELS(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE LL      SSSSSS     C
C   EE       MMM     MMM   AAAA   KK   KK  EE       LL     SS    SS    C
C   EE       MMMM   MMMM  AA  AA  KK  KK   EE       LL     SS          C
C   EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   LL      SSSSSS     C
C   EE       MM  MMM  MM AAAAAAAA KK  KK   EE       LL           SS    C
C   EE       MM   M   MM AA    AA KK   KK  EE       LL     SS    SS    C
C   EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE LLLLLLL SSSSSS     C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKELS GENERATES BLOCKS OF SPHERICAL SPINOR E-COEFFICIENTS BY      C
C  CONTRACTING ON THE E-COEFFICIENTS FOR VECTOR SGTFS, USING A         C
C  DEVELOPMENT OF THE ALGORITHM OF V.R. SAUNDERS.                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
      DIMENSION EXL(MBS,2),BXYZ(3,2),KAP(2),MAG(2),NBS(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        BXYZ(IX,1) = XYZ(IX,I1)
        BXYZ(IX,2) = XYZ(IX,I2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KAP(1) = KQN(I1)
      KAP(2) = KQN(I2)
C
C     CALCULATE LQN VALUES
      IF(KAP(1).LT.0) THEN
        LA =-KAP(1)-1
      ELSE
        LA = KAP(1)
      ENDIF
      IF(KAP(2).LT.0) THEN
        LB =-KAP(2)-1
      ELSE
        LB = KAP(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NBS(1) = NBAS(I1)
      DO IBAS=1,NBS(1)
        EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
      NBS(2) = NBAS(I2)
      DO JBAS=1,NBS(2)
        EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+1
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) =-MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E11,EXL,BXYZ,KAP,MAG,NBS,IQ)
C
C     MULTIPLY ELSQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) = MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS(E21,EXL,BXYZ,KAP,MAG,NBS,IQ)
C
C     MULTIPLY ELSQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EMAKESL(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE SSSSSS  LL         C
C   EE       MMM     MMM   AAAA   KK   KK  EE      SS    SS LL         C
C   EE       MMMM   MMMM  AA  AA  KK  KK   EE      SS       LL         C
C   EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   SSSSSS  LL         C
C   EE       MM  MMM  MM AAAAAAAA KK  KK   EE            SS LL         C
C   EE       MM   M   MM AA    AA KK   KK  EE      SS    SS LL         C
C   EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE SSSSSS  LLLLLLLL   C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKESL GENERATES BLOCKS OF SPHERICAL SPINOR E-COEFFICIENTS BY      C
C  CONTRACTING ON THE E-COEFFICIENTS FOR VECTOR SGTFS, USING A         C
C  DEVELOPMENT OF THE ALGORITHM OF V.R. SAUNDERS.                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
      DIMENSION EXL(MBS,2),BXYZ(3,2),KAP(2),MAG(2),NBS(2)
C
      COMPLEX*16 E11(MB2,MEQ),E21(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        BXYZ(IX,1) = XYZ(IX,I1)
        BXYZ(IX,2) = XYZ(IX,I2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KAP(1) = KQN(I1)
      KAP(2) = KQN(I2)
C
C     CALCULATE LQN VALUES
      IF(KAP(1).LT.0) THEN
        LA =-KAP(1)-1
      ELSE
        LA = KAP(1)
      ENDIF
      IF(KAP(2).LT.0) THEN
        LB =-KAP(2)-1
      ELSE
        LB = KAP(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NBS(1) = NBAS(I1)
      DO IBAS=1,NBS(1)
        EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
      NBS(2) = NBAS(I2)
      DO JBAS=1,NBS(2)
        EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMSL  = LA+LB+1
      NTUVSL = (LAMSL+1)*(LAMSL+2)*(LAMSL+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) =-MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E11,EXL,BXYZ,KAP,MAG,NBS,IQ)
C
C     MULTIPLY ESLQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          E11(M,ITUV) = PHS*E11(M,ITUV)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) = MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQSL(E21,EXL,BXYZ,KAP,MAG,NBS,IQ)
C
C     MULTIPLY ESLQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVSL
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          E21(M,ITUV) = PHS*E21(M,ITUV)
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C
      RETURN
      END
C
C
      SUBROUTINE EMAKEB3(E11,E21,EXPT,XYZ,KQN,MQN,NBAS,IPHS,I1,I2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C  EEEEEEEE MM       MM    AA    KK    KK EEEEEEEE BBBBBBB   333333    C
C  EE       MMM     MMM   AAAA   KK   KK  EE       BB    BB 33    33   C
C  EE       MMMM   MMMM  AA  AA  KK  KK   EE       BB    BB       33   C
C  EEEEEE   MM MM MM MM AA    AA KKKKK    EEEEEE   BBBBBBB    33333    C
C  EE       MM  MMM  MM AAAAAAAA KK  KK   EE       BB    BB       33   C
C  EE       MM   M   MM AA    AA KK   KK  EE       BB    BB 33    33   C
C  EEEEEEEE MM       MM AA    AA KK    KK EEEEEEEE BBBBBBB   333333    C
C                                                                      C
C -------------------------------------------------------------------- C
C  EMAKEB3 GENERATES A VECTOR LIST OF ELSQ-COEFFICIENTS FOR A BATCH OF C
C  BREIT INTERACTION INTEGRALS USING A DEVELOPMENT OF THE ALGORITHM OF C
C  V.R.SAUNDERS.                                                       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4)
      DIMENSION EXL(MBS,2),BXYZ(3,2),KAP(2),MAG(2),NBS(2)
C
      COMPLEX*16 E11(MB2,MEQ,3),E21(MB2,MEQ,3)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &             IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
C
C     TRANSFER NUCLEAR CENTRE COORDINATES TO LOCAL ARRAY
      DO IX=1,3
        BXYZ(IX,1) = XYZ(IX,I1)
        BXYZ(IX,2) = XYZ(IX,I2)
      ENDDO
C
C     TRANSFER KQN ENTRIES TO LOCAL ARRAY
      KAP(1) = KQN(I1)
      KAP(2) = KQN(I2)
C
C     CALCULATE LQN VALUES
      IF(KAP(1).LT.0) THEN
        LA =-KAP(1)-1
      ELSE
        LA = KAP(1)
      ENDIF
      IF(KAP(2).LT.0) THEN
        LB =-KAP(2)-1
      ELSE
        LB = KAP(2)
      ENDIF
C
C     TRANSFER BASIS BLOCKS TO LOCAL ARRAY
      NBS(1) = NBAS(I1)
      DO IBAS=1,NBS(1)
        EXL(IBAS,1) = EXPT(IBAS,I1)
      ENDDO
C
      NBS(2) = NBAS(I2)
      DO JBAS=1,NBS(2)
        EXL(JBAS,2) = EXPT(JBAS,I2)
      ENDDO
C
C     MAXIMUM POLYNOMIAL DEGREE IN FINITE EXPANSION
      LAMLS  = LA+LB+1
      NTUVLS = (LAMLS+1)*(LAMLS+2)*(LAMLS+3)/6
C
C**********************************************************************C
C     1: GENERATE AND STORE E11, FOR M PAIRS (-|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) =-MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS3(E11,EXL,BXYZ,KAP,MAG,NBS)
C
C     MULTIPLY ELSQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          DO IQ=1,3
            E11(M,ITUV,IQ) = PHS*E11(M,ITUV,IQ)
          ENDDO
        ENDDO
      ENDDO
C
C**********************************************************************C
C     2: GENERATE AND STORE E21, FOR M PAIRS (+|MA|,-|MB|)             C
C**********************************************************************C
C
C     BASIS PAIR MQNS
      MAG(1) = MQN(I1)
      MAG(2) =-MQN(I2)
C
C     GENERATE THE RAW COEFFICIENTS
      CALL EQLS3(E21,EXL,BXYZ,KAP,MAG,NBS)
C
C     MULTIPLY ELSQ BY PHASE TERM FOR R-INTEGRALS (SAVES COMP. TIME)
      DO ITUV=1,NTUVLS
        PHS = DFLOAT((IPHS)**(LAMVEC(ITUV)))
        DO M=1,NBS(1)*NBS(2)
          DO IQ=1,3
            E21(M,ITUV,IQ) = PHS*E21(M,ITUV,IQ)
          ENDDO
        ENDDO
      ENDDO
C
C     NOTE THAT E22 AND E12 ARE RELATED TO THESE BY PHASE FACTORS.
C     THERE IS ALSO A RELATION WHICH ALLOWS US TO OBTAIN ESLQ FROM ELSQ.
C
      RETURN
      END
C
C
      SUBROUTINE EQLL(ELL,EXL,XYZ,KQN,MQN,NBAS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                EEEEEEEE  QQQQQQ    LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EEEEEE  QQ      QQ  LL       LL                       C
C                EE      QQ      QQ  LL       LL                       C
C                EE       QQ    QQ   LL       LL                       C
C                EEEEEEEE  QQQQQQ QQ LLLLLLLL LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLL EVALUATES THE EQ-COEFFICIENTS FOR LARGE-LARGE BASIS FUNCTION   C
C  BLOCK OVERLAPS OF G-SPINOR FUNCTIONS FOR ANY CHOICE IQ = {0,1,2,3}. C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION LLAB(2),MLAB(2)
      DIMENSION KQN(2),LQN(2),JQN(2),MQN(2),NBAS(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),XYZ(3,2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELL(MB2,MEQ),ESG(MB2,MEQ)
C
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THRESHOLD FOR CLEBSCH-GORDAN COEFFICIENT MAGNITUDES
      SENS = 1.0D-10
C
C     SIGN MULITPLIER FOR SIGMA COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO ITUV=1,MEQ
        DO M=1,MB2
          ELL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     BASIS FUNCTION OVERLAP LIST LENGTH
      MAXM = NBAS(1)*NBAS(2)
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRICAL INFORMATION                        C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: ALL KQN(1) AND KQN(2) TYPES.                             C
C**********************************************************************C
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)
      LLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELL0 AND ELLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELL0 OR ELLZ: UPPER-UPPER
          DO ITUV=1,NTUV0
            DO M=1,MAXM
              ELL(M,ITUV) = ELL(M,ITUV) +    CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELL0 OR ELLZ: LOWER-LOWER
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELLX AND ELLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELLX OR ELLY: UPPER-LOWER
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) + SIG*CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELLX OR ELLY: LOWER-UPPER
          DO M=1,MAXM
            DO ITUV=1,NTUV0
              ELL(M,ITUV) = ELL(M,ITUV) +    CAB*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM0  = LLAB(1)+LLAB(2)
      NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C     GENERATE RNLL NORMALISATION CONSTANTS
      CALL RNLL(RNORM,EXL,LQN,NBAS)
C
C     NORMALISE THE ELLQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M   = M+1
          RLL = RNORM(IBAS,1)*RNORM(JBAS,2)
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = RLL*ELL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     SIGMA_Y SPECIAL CASE: MULTIPLY ELLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV0
            ELL(M,ITUV) = CONE*ELL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQSS(ESS,EXL,XYZ,KQN,MQN,NBAS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS   SSSSSS                  C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EE      QQ      QQ SS       SS                       C
C                 EEEEEE  QQ      QQ  SSSSSS   SSSSSS                  C
C                 EE      QQ      QQ       SS       SS                 C
C                 EE       QQ    QQ  SS    SS SS    SS                 C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS   SSSSSS                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSS EVALUATES THE EQ-COEFFICIENTS FOR SMALL-SMALL BASIS FUNCTION   C
C  BLOCK OVERLAPS OF G-SPINOR FUNCTIONS FOR ANY CHOICE IQ = {0,1,2,3}. C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION LLAB(2),MLAB(2)
      DIMENSION KQN(2),LQN(2),JQN(2),MQN(2),NBAS(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),XYZ(3,2)
      DIMENSION T22(MB2),T20(MB2),T02(MB2),T00(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THRESHOLD FOR CLEBSCH-GORDAN COEFFICIENT MAGNITUDES
      SENS = 1.0D-14
C
C     SIGN MULITPLIER FOR SIGMA COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBAS(1)*NBAS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      RL1 = DFLOAT(2*LQN(1)+1)
      RL2 = DFLOAT(2*LQN(2)+1)
C
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          T22(M) = 4.0D0*EXL(IBAS,1)*EXL(JBAS,2)
          T20(M) =-2.0D0*RL2*EXL(IBAS,1)
          T02(M) =-2.0D0*RL1*EXL(JBAS,2)
          T00(M) = RL1*RL2
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRICAL INFORMATION                        C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(1).LT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)+1
      LLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF

      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +    TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).LT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0.OR.KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)+1
      LLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +    TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
200   CONTINUE
C
C**********************************************************************C
C     CASE 3: KQN(1).GT.0 AND KQN(2).LT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).GT.0) GOTO 300
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)-1
      LLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

300   CONTINUE      
C
C**********************************************************************C
C     CASE 4: KQN(1).GT.0 AND KQN(2).GT.0                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0.OR.KQN(2).LT.0) GOTO 400
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)-1
      LLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESS0 AND ESSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION (DFNOTE: CHECK)
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL STEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM4  = LLAB(1)+LLAB(2)+4
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: UPPER-UPPER FOR [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL STEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM4  = LLAB(1)+LLAB(2)+4
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         CONTRIBUTION TO ESS0 OR ESSZ: LOWER-LOWER FOR [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESSX AND ESSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL STEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM4  = LLAB(1)+LLAB(2)+4
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: UPPER-LOWER FOR [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T00(M)
            DO ITUV=1,NTUV0
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=1,NB=0]
          DO M=1,MAXM
            TK = CAB*T20(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T02(M)
            DO ITUV=1,NTUV2
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ESG)
          CALL STEPN(ENSG,ESG,LAM2,MAXM,1)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM4  = LLAB(1)+LLAB(2)+4
          NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C         CONTRIBUTION TO ESSX OR ESSY: LOWER-UPPER FOR [NA=1,NB=1]
          DO M=1,MAXM
            TK = CAB*T22(M)
            DO ITUV=1,NTUV4
              ESS(M,ITUV) = ESS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
400   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     GENERATE RNSS NORMALISATION CONSTANTS
      CALL RNSS(RNORM,EXL,LQN,NBAS)
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM4  = LQN(1)+LQN(2)+2
      NTUV4 = (LAM4+1)*(LAM4+2)*(LAM4+3)/6
C
C     NORMALISE THE ESSQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M   = M+1
          RSS = RNORM(IBAS,1)*RNORM(JBAS,2)
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = RSS*ESS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     SIGMA_Y SPECIAL CASE: MULTIPLY ESSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV4
            ESS(M,ITUV) = CONE*ESS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQLS(ELS,EXL,XYZ,KQN,MQN,NBAS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                EEEEEEEE  QQQQQQ    LL       SSSSSS                   C
C                EE       QQ    QQ   LL      SS    SS                  C
C                EE      QQ      QQ  LL      SS                        C
C                EEEEEE  QQ      QQ  LL       SSSSSS                   C
C                EE      QQ      QQ  LL            SS                  C
C                EE       QQ    QQ   LL      SS    SS                  C
C                EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLS EVALUATES THE EQ-COEFFICIENTS FOR LARGE-SMALL CHARGE OVERLAP   C
C  OF G-SPINOR FUNCTIONS FOR ALL PAULI MATRICES IQ = {0,1,2,3}.        C
C -------------------------------------------------------------------- C
C  THIS DOES *NOT* INCLUDE FACTORS OF i BECAUSE THEY GET IN THE WAY OF C
C  MATRIX HERMITICITY RELATIONS. ALL LS COEFFS REQUIRE i LATER ON.     C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION NBAS(2),KQN(2),JQN(2),LQN(2),MQN(2),LLAB(2),MLAB(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),XYZ(3,2)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELS(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THRESHOLD FOR CLEBSCH-GORDAN COEFFICIENT MAGNITUDES
      SENS = 1.0D-10
C
C     SIGN MULITPLIER FOR SIGMA COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ELS(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBAS(1)*NBAS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(JBAS,2)
          T0(M) = DFLOAT(2*LQN(2)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRICAL INFORMATION                        C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-EXL(IBAS,1)*EXL(JBAS,2)*AB2/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)
      LLAB(2) = LQN(2)+1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: UPPER-UPPER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: LOWER-LOWER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: UPPER-LOWER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: LOWER-UPPER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(2).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)
      LLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: UPPER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ELS0 OR ELSZ: LOWER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: UPPER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ELSX OR ELSY: LOWER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ELS(M,ITUV) = ELS(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+1
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNLS NORMALISATION CONSTANTS
      CALL RNLS(RNORM,EXL,LQN,NBAS)
C
C     NORMALISE THE ELSQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M   = M+1
          RLS = RNORM(IBAS,1)*RNORM(JBAS,2)
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = RLS*ELS(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     SIGMA_Y SPECIAL CASE: MULTIPLY ELSY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV2
            ELS(M,ITUV) = CONE*ELS(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQSL(ESL,EXL,XYZ,KQN,MQN,NBAS,IQ)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 EEEEEEEE  QQQQQQ    SSSSSS  LL                       C
C                 EE       QQ    QQ  SS    SS LL                       C
C                 EE      QQ      QQ SS       LL                       C
C                 EEEEEE  QQ      QQ  SSSSSS  LL                       C
C                 EE      QQ      QQ       SS LL                       C
C                 EE       QQ    QQ  SS    SS LL                       C
C                 EEEEEEEE  QQQQQQ QQ SSSSSS  LLLLLLLL                 C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQSL EVALUATES THE EQ-COEFFICIENTS FOR LARGE-SMALL CHARGE OVERLAP   C
C  OF G-SPINOR FUNCTIONS FOR ALL PAULI MATRICES IQ = {0,1,2,3}.        C
C -------------------------------------------------------------------- C
C  THIS DOES *NOT* INCLUDE FACTORS OF i BECAUSE THEY GET IN THE WAY OF C
C  MATRIX HERMITICITY RELATIONS. ALL SL COEFFS REQUIRE -i LATER ON.    C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION NBAS(2),KQN(2),JQN(2),LQN(2),MQN(2),LLAB(2),MLAB(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),XYZ(3,2)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ESL(MB2,MEQ),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THRESHOLD FOR CLEBSCH-GORDAN COEFFICIENT MAGNITUDES
      SENS = 1.0D-10
C
C     SIGN MULITPLIER FOR SIGMA COUPLING MATRICES
      IF(IQ.EQ.0.OR.IQ.EQ.1) THEN
        SIG = 1.0D0
      ELSEIF(IQ.EQ.2.OR.IQ.EQ.3) THEN
        SIG =-1.0D0
      ENDIF
C
C     INITIALISE COEFFICIENT STORAGE ARRAY TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          ESL(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CLEBSCH-GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ELSE
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ELSE
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ENDIF
C
C     DETERMINE THE NUMBER OF FUNCTIONS ON EACH CENTRE
      MAXM = NBAS(1)*NBAS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(IBAS,1)
          T0(M) = DFLOAT(2*LQN(1)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRICAL INFORMATION                        C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M) + PAY(M)*PAY(M) + PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M) + PBY(M)*PBY(M) + PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)+1
      LLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESL0 AND ESLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: UPPER-UPPER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: LOWER-LOWER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESLX AND ESLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: UPPER-LOWER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: LOWER-UPPER
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(1).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(1).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)-1
      LLAB(2) = LQN(2)
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ESL0 AND ESLZ
      IF(IQ.EQ.0.OR.IQ.EQ.3) THEN
C
C >>    TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
        CAB = CAU*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: UPPER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: UPPER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
        CAB = CAL*CBL
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: LOWER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESL0 OR ESLZ: LOWER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ESLX AND ESLY
      IF(IQ.EQ.1.OR.IQ.EQ.2) THEN
C
C >>    TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)-1)/2
        MLAB(2) = (MQN(2)+1)/2
C
C       CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
        CAB = CAU*CBL
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: UPPER-LOWER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: UPPER-LOWER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) + SIG*TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
C
C >>    TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C       BASIS PAIR MQN LABELS
        MLAB(1) = (MQN(1)+1)/2
        MLAB(2) = (MQN(2)-1)/2
C
C       CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
        CAB = CAL*CBU
C
C       SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
        IF(DABS(CAB).GE.SENS) THEN
C
C         GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
          CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM0  = LLAB(1)+LLAB(2)
          NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: LOWER-UPPER FOR [NA=0,NB=0]
          DO M=1,MAXM
            TK = CAB*T0(M)
            DO ITUV=1,NTUV0
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ESG(M,ITUV)
            ENDDO
          ENDDO
C
C         INCREASE THE INDEX N BY ONE ON CENTRE A (WRITE TO ENSG)
          CALL STEPN(ESG,ENSG,LAM0,MAXM,1)
C
C         INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
          LAM2  = LLAB(1)+LLAB(2)+2
          NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C         CONTRIBUTION TO ESLX OR ESLY: LOWER-UPPER FOR [NA=0,NB=1]
          DO M=1,MAXM
            TK = CAB*T2(M)
            DO ITUV=1,NTUV2
              ESL(M,ITUV) = ESL(M,ITUV) +     TK*ENSG(M,ITUV)
            ENDDO
          ENDDO
C
        ENDIF
      ENDIF

200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+1
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNSL NORMALISATION CONSTANTS
      CALL RNSL(RNORM,EXL,LQN,NBAS)
C
C     NORMALISE THE ESLQ COEFFICIENT BLOCK AND MULTIPLY BY -i
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M   = M+1
          RSL = RNORM(IBAS,1)*RNORM(JBAS,2)
          DO ITUV=1,NTUV2
            ESL(M,ITUV) = RSL*ESL(M,ITUV)
          ENDDO
        ENDDO
      ENDDO
C
C     SIGMA_Y SPECIAL CASE: MULTIPLY ESLY RESULTS BY i.
      IF(IQ.EQ.2) THEN
        DO M=1,MAXM
          DO ITUV=1,NTUV2
            ESL(M,ITUV) = CONE*ESL(M,ITUV)
          ENDDO
        ENDDO
      ENDIF
C
      RETURN
      END
C
C
      SUBROUTINE EQLS3(ELS,EXL,XYZ,KQN,MQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C            EEEEEEEE  QQQQQQ    LL       SSSSSS   333333              C
C            EE       QQ    QQ   LL      SS    SS 33    33             C
C            EE      QQ      QQ  LL      SS             33             C
C            EEEEEE  QQ      QQ  LL       SSSSSS    33333              C
C            EE      QQ      QQ  LL            SS       33             C
C            EE       QQ    QQ   LL      SS    SS 33    33             C
C            EEEEEEEE  QQQQQQ QQ LLLLLLLL SSSSSS   333333              C
C                                                                      C
C -------------------------------------------------------------------- C
C  EQLS EVALUATES THE EQ-COEFFICIENTS FOR LARGE-SMALL CHARGE OVERLAP   C
C  OF G-SPINOR FUNCTIONS FOR A SET OF 3 PAULI MATRICES IQ = {1,2,3}.   C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION NBAS(2),KQN(2),JQN(2),LQN(2),MQN(2),LLAB(2),MLAB(2)
      DIMENSION EXL(MBS,2),RNORM(MBS,2),XYZ(3,2)
      DIMENSION T2(MB2),T0(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ELS(MB2,MEQ,3),ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     THRESHOLD FOR CLEBSCH-GORDAN COEFFICIENT MAGNITUDES
      SENS = 1.0D-10
C
C     INITIALISE THE COEFFICIENTS TO ZERO
      DO M=1,MB2
        DO ITUV=1,MEQ
          DO IQ=1,3
            ELS(M,ITUV,IQ) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
      ENDDO
C
C     CALCULATE LQN VALUES
      IF(KQN(1).LT.0) THEN
        LQN(1) =-KQN(1)-1
      ELSE
        LQN(1) = KQN(1)
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        LQN(2) =-KQN(2)-1
      ELSE
        LQN(2) = KQN(2)
      ENDIF
C
C     CALCULATE JQN VALUES
      JQN(1) = 2*IABS(KQN(1))-1
      JQN(2) = 2*IABS(KQN(2))-1
C
C     CALCULATE THE APPROPRIATE CAB GORDAN FACTORS
      IF(KQN(1).LT.0) THEN
        CAU = DSQRT(DFLOAT(JQN(1)+MQN(1)  )/DFLOAT(2*JQN(1)  ))
        CAL = DSQRT(DFLOAT(JQN(1)-MQN(1)  )/DFLOAT(2*JQN(1)  ))
      ELSE
        CAU =-DSQRT(DFLOAT(JQN(1)-MQN(1)+2)/DFLOAT(2*JQN(1)+4))
        CAL = DSQRT(DFLOAT(JQN(1)+MQN(1)+2)/DFLOAT(2*JQN(1)+4))
      ENDIF
C
      IF(KQN(2).LT.0) THEN
        CBU =-DSQRT(DFLOAT(JQN(2)-MQN(2)+2)/DFLOAT(2*JQN(2)+4))
        CBL = DSQRT(DFLOAT(JQN(2)+MQN(2)+2)/DFLOAT(2*JQN(2)+4))
      ELSE
        CBU = DSQRT(DFLOAT(JQN(2)+MQN(2)  )/DFLOAT(2*JQN(2)  ))
        CBL = DSQRT(DFLOAT(JQN(2)-MQN(2)  )/DFLOAT(2*JQN(2)  ))
      ENDIF
C
C     DETERMINE THE NUMBER OF PAIRS IN THIS BLOCK
      MAXM  = NBAS(1)*NBAS(2)
C
C     KINETIC PRE-FACTORS FOR THIS BLOCK
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
          T2(M) =-2.0D0*EXL(JBAS,2)
          T0(M) = DFLOAT(2*LQN(2)+1)
        ENDDO
      ENDDO
C
C**********************************************************************C
C     INITIALISE COMMON GEOMETRICAL INFORMATION                        C
C**********************************************************************C
C
C     EUCLIDIAN DISTANCE BETWEEN CENTRES A AND B
      DX  = (XYZ(1,1)-XYZ(1,2))**2
      DY  = (XYZ(2,1)-XYZ(2,2))**2
      DZ  = (XYZ(3,1)-XYZ(3,2))**2
      AB2 = DX+DY+DZ
C
C     GAUSSIAN PRODUCT THEOREM IMPLEMENTATION
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M = M+1
C
          P(M)    = EXL(IBAS,1)+EXL(JBAS,2)
          P2(M)   = 2.0D0*P(M)
          P22(M)  = P2(M)*P2(M)
          PX      = (EXL(IBAS,1)*XYZ(1,1)+EXL(JBAS,2)*XYZ(1,2))/P(M)
          PY      = (EXL(IBAS,1)*XYZ(2,1)+EXL(JBAS,2)*XYZ(2,2))/P(M)
          PZ      = (EXL(IBAS,1)*XYZ(3,1)+EXL(JBAS,2)*XYZ(3,2))/P(M)
          PAX(M)  = PX-XYZ(1,1)
          PAY(M)  = PY-XYZ(2,1)
          PAZ(M)  = PZ-XYZ(3,1)
          PBX(M)  = PX-XYZ(1,2)
          PBY(M)  = PY-XYZ(2,2)
          PBZ(M)  = PZ-XYZ(3,2)
          PA2(M)  = PAX(M)*PAX(M)+PAY(M)*PAY(M)+PAZ(M)*PAZ(M)
          PB2(M)  = PBX(M)*PBX(M)+PBY(M)*PBY(M)+PBZ(M)*PBZ(M)
          RKAB(M) = DEXP(-(EXL(IBAS,1)*EXL(JBAS,2)*AB2)/P(M))
C
        ENDDO
      ENDDO
C
C**********************************************************************C
C     CASE 1: KQN(2).LT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).GT.0) GOTO 100
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)
      LLAB(2) = LQN(2)+1
C
C >>  TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C     BASIS PAIR MQN LABELS
      MLAB(1) = (MQN(1)-1)/2
      MLAB(2) = (MQN(2)-1)/2
C
C     CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
      CAB = CAU*CBU
C
C     SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
      IF(DABS(CAB).GE.SENS) THEN
C
C       GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
        CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C       MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
        LAM0  = LLAB(1)+LLAB(2)
        NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C       CONTRIBUTION TO ELSZ: UPPER-UPPER
        DO M=1,MAXM
          TK = CAB*T2(M)
          DO ITUV=1,NTUV0
            ELS(M,ITUV,3) = ELS(M,ITUV,3) + TK*ESG(M,ITUV)
          ENDDO
        ENDDO
C
      ENDIF
C
C >>  TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C     BASIS PAIR MQN LABELS
      MLAB(1) = (MQN(1)+1)/2
      MLAB(2) = (MQN(2)+1)/2
C
C     CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
      CAB = CAL*CBL
C
C     SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
      IF(DABS(CAB).GE.SENS) THEN
C
C       GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
        CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C       MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
        LAM0  = LLAB(1)+LLAB(2)
        NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C       CONTRIBUTION TO ELSZ: LOWER-LOWER
        DO M=1,MAXM
          TK = CAB*T2(M)
          DO ITUV=1,NTUV0
            ELS(M,ITUV,3) = ELS(M,ITUV,3) - TK*ESG(M,ITUV)
          ENDDO
        ENDDO
C
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
C
C >>  TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C     BASIS PAIR MQN LABELS
      MLAB(1) = (MQN(1)-1)/2
      MLAB(2) = (MQN(2)+1)/2
C
C     CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
      CAB = CAU*CBL
C
C     SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
      IF(DABS(CAB).GE.SENS) THEN
C
C       GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
        CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C       MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
        LAM0  = LLAB(1)+LLAB(2)
        NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C       CONTRIBUTION TO ELSX AND ELSY: UPPER-LOWER
        DO M=1,MAXM
          TK = CAB*T2(M)
          DO ITUV=1,NTUV0
            ELS(M,ITUV,1) = ELS(M,ITUV,1) + TK*ESG(M,ITUV)
            ELS(M,ITUV,2) = ELS(M,ITUV,2) - TK*ESG(M,ITUV)
          ENDDO
        ENDDO
C
      ENDIF
C
C >>  TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C     BASIS PAIR MQN LABELS
      MLAB(1) = (MQN(1)+1)/2
      MLAB(2) = (MQN(2)-1)/2
C
C     CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
      CAB = CAL*CBU
C
C     SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
      IF(DABS(CAB).GE.SENS) THEN
C
C       GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
        CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C       MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
        LAM0  = LLAB(1)+LLAB(2)
        NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C       CONTRIBUTION TO ELSX AND ELSY: LOWER-UPPER
        DO M=1,MAXM
          TK = CAB*T2(M)
          DO ITUV=1,NTUV0
            ELS(M,ITUV,1) = ELS(M,ITUV,1) + TK*ESG(M,ITUV)
            ELS(M,ITUV,2) = ELS(M,ITUV,2) + TK*ESG(M,ITUV)
          ENDDO
        ENDDO
C
      ENDIF
C
100   CONTINUE
C
C**********************************************************************C
C     CASE 2: KQN(2).GT.0                                              C
C**********************************************************************C
C
      IF(KQN(2).LT.0) GOTO 200
C
C     GENERATING LQN LABELS
      LLAB(1) = LQN(1)
      LLAB(2) = LQN(2)-1
C
C     TERMS 11 AND 22 ARE ONLY NECESSARY FOR ELS0 AND ELSZ
C
C >>  TERM 11: (MA-1/2, MB-1/2) CONTRIBUTIONS
C
C     BASIS PAIR MQN LABELS
      MLAB(1) = (MQN(1)-1)/2
      MLAB(2) = (MQN(2)-1)/2
C
C     CLEBSCH-GORDAN PRODUCT: UPPER-UPPER
      CAB = CAU*CBU
C
C     SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
      IF(DABS(CAB).GE.SENS) THEN
C
C       GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
        CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C       MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
        LAM0  = LLAB(1)+LLAB(2)
        NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C       CONTRIBUTION TO ELSZ: UPPER-UPPER FOR [N=0,N'=0]
        DO M=1,MAXM
          TK = CAB*T0(M)
          DO ITUV=1,NTUV0
            ELS(M,ITUV,3) = ELS(M,ITUV,3) + TK*ESG(M,ITUV)
          ENDDO
        ENDDO
C
C       INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
        CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C       INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
        LAM2  = LLAB(1)+LLAB(2)+2
        NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C       CONTRIBUTION TO ELSZ: UPPER-UPPER FOR [N=0,N'=1]
        DO M=1,MAXM
          TK = CAB*T2(M)
          DO ITUV=1,NTUV2
            ELS(M,ITUV,3) = ELS(M,ITUV,3) + TK*ENSG(M,ITUV)
          ENDDO
        ENDDO
C
      ENDIF
C
C >>  TERM 22: (MA+1/2, MB+1/2) CONTRIBUTIONS
C
C     BASIS PAIR MQN LABELS
      MLAB(1) = (MQN(1)+1)/2
      MLAB(2) = (MQN(2)+1)/2
C
C     CLEBSCH-GORDAN PRODUCT: LOWER-LOWER
      CAB = CAL*CBL
C
C     SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
      IF(DABS(CAB).GE.SENS) THEN
C
C       GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
        CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C       MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
        LAM0  = LLAB(1)+LLAB(2)
        NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C       CONTRIBUTION TO ELSZ: LOWER-LOWER FOR [N=0,N'=0]
        DO M=1,MAXM
          TK = CAB*T0(M)
          DO ITUV=1,NTUV0
            ELS(M,ITUV,3) = ELS(M,ITUV,3) - TK*ESG(M,ITUV)
          ENDDO
        ENDDO
C
C       INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
        CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C       INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
        LAM2  = LLAB(1)+LLAB(2)+2
        NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C       CONTRIBUTION TO ELSZ: LOWER-LOWER FOR [N=0,N'=1]
        DO M=1,MAXM
          TK = CAB*T2(M)
          DO ITUV=1,NTUV2
            ELS(M,ITUV,3) = ELS(M,ITUV,3) - TK*ENSG(M,ITUV)
          ENDDO
        ENDDO
C
      ENDIF
C
C     TERMS 12 AND 21 ARE ONLY NECESSARY FOR ELSX AND ELSY
C
C >>  TERM 12: (MA-1/2, MB+1/2) CONTRIBUTIONS
C
C     BASIS PAIR MQN LABELS
      MLAB(1) = (MQN(1)-1)/2
      MLAB(2) = (MQN(2)+1)/2
C
C     CLEBSCH-GORDAN PRODUCT: UPPER-LOWER
      CAB = CAU*CBL
C
C     SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
      IF(DABS(CAB).GE.SENS) THEN
C
C       GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
        CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C       MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
        LAM0  = LLAB(1)+LLAB(2)
        NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C       CONTRIBUTION TO ELSX AND ELSY: UPPER-LOWER FOR [N=0,N'=0]
        DO M=1,MAXM
          TK = CAB*T0(M)
          DO ITUV=1,NTUV0
            ELS(M,ITUV,1) = ELS(M,ITUV,1) + TK*ESG(M,ITUV)
            ELS(M,ITUV,2) = ELS(M,ITUV,2) - TK*ESG(M,ITUV)
          ENDDO
        ENDDO
C
C       INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
        CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C       INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
        LAM2  = LLAB(1)+LLAB(2)+2
        NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C       CONTRIBUTION TO ELSX AND ELSY: UPPER-LOWER FOR [N=0,N'=1]
        DO M=1,MAXM
          TK = CAB*T2(M)
          DO ITUV=1,NTUV2
            ELS(M,ITUV,1) = ELS(M,ITUV,1) + TK*ENSG(M,ITUV)
            ELS(M,ITUV,2) = ELS(M,ITUV,2) - TK*ENSG(M,ITUV)
          ENDDO
        ENDDO
C
      ENDIF
C
C >>  TERM 21: (MA+1/2, MB-1/2) CONTRIBUTIONS
C
C     BASIS PAIR MQN LABELS
      MLAB(1) = (MQN(1)+1)/2
      MLAB(2) = (MQN(2)-1)/2
C
C     CLEBSCH-GORDAN PRODUCT: LOWER-UPPER
      CAB = CAL*CBU
C
C     SCREEN CONTRIBUTION BY ANGULAR PRODUCT PAIR
      IF(DABS(CAB).GE.SENS) THEN
C
C       GENERATE RAW SPHERICAL GAUSSIAN (ES) COEFFICIENTS
        CALL ESGTF(ESG,LLAB,MLAB,MAXM)
C
C       MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
        LAM0  = LLAB(1)+LLAB(2)
        NTUV0 = (LAM0+1)*(LAM0+2)*(LAM0+3)/6
C
C       CONTRIBUTION TO ELSX AND ELSY: LOWER-UPPER FOR [N=0,N'=0]
        DO M=1,MAXM
          TK = CAB*T0(M)
          DO ITUV=1,NTUV0
            ELS(M,ITUV,1) = ELS(M,ITUV,1) + TK*ESG(M,ITUV)
            ELS(M,ITUV,2) = ELS(M,ITUV,2) + TK*ESG(M,ITUV)
          ENDDO
        ENDDO
C
C       INCREASE THE INDEX N BY ONE ON CENTRE B (WRITE TO ENSG)
        CALL STEPN(ESG,ENSG,LAM0,MAXM,2)
C
C       INDEX SUMMATION TERMINAL BASED ON MAX DEGREE OF HGTF
        LAM2  = LLAB(1)+LLAB(2)+2
        NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C       CONTRIBUTION TO ELSX AND ELSY: LOWER-UPPER FOR [N=0,N'=1]
        DO M=1,MAXM
          TK = CAB*T2(M)
          DO ITUV=1,NTUV2
            ELS(M,ITUV,1) = ELS(M,ITUV,1) + TK*ENSG(M,ITUV)
            ELS(M,ITUV,2) = ELS(M,ITUV,2) + TK*ENSG(M,ITUV)
          ENDDO
        ENDDO
C
      ENDIF
C
200   CONTINUE
C
C**********************************************************************C
C     GAUSSIAN NORMALISATION FACTORS                                   C
C**********************************************************************C
C
C     MAX POLYNOMIAL DEGREE OF HGTFS IN FINITE EXPANSION
      LAM2  = LQN(1)+LQN(2)+1
      NTUV2 = (LAM2+1)*(LAM2+2)*(LAM2+3)/6
C
C     GENERATE RNLS NORMALISATION CONSTANTS
      CALL RNLS(RNORM,EXL,LQN,NBAS)
C
C     NORMALISE THE ELLQ COEFFICIENT BLOCK
      M = 0
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
          M   = M+1
          RLS = RNORM(IBAS,1)*RNORM(JBAS,2)
          DO ITUV=1,NTUV2
            DO IQ=1,3
              ELS(M,ITUV,IQ) = RLS*ELS(M,ITUV,IQ)
            ENDDO
          ENDDO
        ENDDO
      ENDDO
C
C     SIGMA_Y SPECIAL CASE: MULTIPLY ELSY RESULTS BY i.
      DO M=1,MAXM
        DO ITUV=1,NTUV2
          ELS(M,ITUV,2) = CONE*ELS(M,ITUV,2)
        ENDDO
      ENDDO
CC
CC     BRING THESE COEFFICIENTS INTO THE ELSQ VALUES AND ALSO FACTOR i
C      DO IQ=1,3
CC       DO M=1,MAXM
C          DO ITUV=1,NTUV2
C            ELS(M,ITUV,IQ) = CONE*ELS(M,ITUV,IQ)
C          ENDDO
C        ENDDO
C      ENDDO
CC
      RETURN
      END
C
C
      SUBROUTINE ESGTF(ESG,LQN,MQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              EEEEEEEE SSSSSS   GGGGGG TTTTTTTT FFFFFFFF              C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EE      SS       GG         TT    FF                    C
C              EEEEEE   SSSSSS  GG         TT    FFFFFF                C
C              EE            SS GG   GGG   TT    FF                    C
C              EE      SS    SS GG    GG   TT    FF                    C
C              EEEEEEEE SSSSSS   GGGGGG    TT    FF                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  ESGTF CONSTRUCTS THE EXPANSION COEFFICIENTS OF THE OVERLAP DENSITY  C
C  OF TWO SPHERICAL HARMONIC FUNCTIONS IN AN AUXILIARY HGTF BASIS.     C
C                                                                      C
C  THE OVERLAP DENSITY IS DEFINED BY Y*[L,M]Y[L',M'], WHERE Y[L,M] ARE C
C  SPHERICAL HARMONICS FOLLOWING THE CONDON-SHORTLEY PHASE CONVENTION. C
C                                                                      C
C  THE REQUIRED COEFFICIENTS ARE GENERATED BY A CALL TO VRS, WHICH IS  C
C  CONSTRUCTED ACCORDING TO THE RECURRENCE RELATIONS DEFINED BY        C
C  V.R.SAUNDERS. THE OUTPUT OF VRS IS THEN ADJUSTED TO INCLUDE THE     C
C  ANGULAR NORMALISATION CONSTANTS, AS WELL AS A PHASE FACTOR TO       C
C  CONVERT FROM THE SCHIFF TO THE CONDON-SHORTLEY PHASE CONVENTION.    C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C     LQN(I) - TARGET LQN VALUES ON CENTRES A AND B.                   C
C     MQN(I) - TARGET MQN VALUES ON CENTRES A AND B.                   C
C -------------------------------------------------------------------- C
C  H.M.QUINEY THE UNIVERSITY OF MELBOURNE (2008).                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      DIMENSION FACT(MKP),LQN(2),MQN(2),MQNLAB(2)
C
      COMPLEX*16 ESG(MB2,MEQ)
C
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
      DATA PI/3.1415926535897932D0/
C
C     CALCULATE THE FACTORIAL FUNCTIONS
      LMAX = MAX(LQN(1),LQN(2))
      FACT(1) = 1.0D0
      DO M=1,2*LMAX
        FACT(M+1) = FACT(M)*DFLOAT(M)
      ENDDO
C
C     VRS IS CALLED WITH THE SIGN OF MQN(1) REVERSED
C     TO AFFECT COMPLEX CONJUGATION, ALONG WITH THE REQUISITE
C     PHASE, WHICH IS CALCULATED LATER.
      MQNLAB(1) =-MQN(1)
      MQNLAB(2) = MQN(2)
C
C     TRAP CASES FOR WHICH |MQN| EXCEEDS LQN (COULD BE CALLED BUT
C     WITH A ZERO MULTIPLICATIVE CONSTANT)
      IF(IABS(MQN(1)).GT.LQN(1).OR.IABS(MQN(2)).GT.LQN(2)) THEN
        LAM  = LQN(1)+LQN(2)
        NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
        DO ITUV=1,NTUV
          DO M=1,MAXM
            ESG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
          ENDDO
        ENDDO
        RETURN
      ELSE
        CALL VRS(ESG,LQN,MQNLAB,MAXM)
      ENDIF
C
C     IMPORT L AND BASIS PAIR MQNS
      L1 = LQN(1)
      L2 = LQN(2)
      M1 = IABS(MQN(1))
      M2 = IABS(MQN(2))
C
C     SPECIFY THE UPPER TERMINAL ON SUMMATION, AND CG COEFFICIENTS
      LAM    = LQN(1)+LQN(2)
      PREFAC = DFLOAT((2*L1+1)*(2*L2+1))
      PREFAC = PREFAC*FACT(L1-M1+1)/FACT(L1+M1+1)
      PREFAC = PREFAC*FACT(L2-M2+1)/FACT(L2+M2+1)
      PREFAC = DSQRT(PREFAC)
C     PHASE  = (-1.0D0)**(M1+M2+MQN(2))
      PHASE  = (-1.0D0)**((MQN(1)+MQN(2)+M1+M2)/2)
      PREFAC = 0.25D0*PREFAC*PHASE/PI
C
C     THERE ARE NTUV TOTAL TERMS IN THE SUM OVER A,B,C
      NTUV = (LAM+1)*(LAM+2)*(LAM+3)/6
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ESG(M,ITUV) = PREFAC*ESG(M,ITUV)
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE VRS(ESG,LQN,MQN,MAXM)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                      VV    VV RRRRRRR   SSSSSS                       C
C                      VV    VV RR    RR SS    SS                      C
C                      VV    VV RR    RR SS                            C
C                      VV    VV RR    RR  SSSSSS                       C
C                       VV  VV  RRRRRRR        SS                      C
C                        VVVV   RR    RR SS    SS                      C
C                         VV    RR    RR  SSSSSS                       C
C                                                                      C
C -------------------------------------------------------------------- C
C  VRS EVALUATES THE EXPANSION COEFFICIENTS OF THE OVERLAP CHARGE      C
C  DENSITY OF SGTFS IN AN AUXILIARY HGTF. COEFFICIENTS ARE EVALUATED   C
C  USING THE RECURRENCE RELATIONS DEFINED BY VIC SAUNDERS IN:          C
C                                                                      C
C  V.R.SAUNDERS,"MOLECULAR INTEGRALS FOR GAUSSIAN-TYPE FUNCTIONS",     C
C  METHODS OF COMPUTATIONAL MOLECULAR PHYSICS, ED G.H.F.DIERCKSEN AND  C
C  S.WILSON, pp 1-26, REIDEL PUBLISHING, DORDRECHT (1983).             C
C                                                                      C
C  THE E-COEFFS IN THIS PROCEDURE ARE FOR AN UN-NORMALISED SGTF.       C
C  THE COEFFICIENTS ARE DETERMINED ACCORDING TO THE SAME RULES AS      C
C  DEFINED IN THE ABOVE ARTICLE. CONSEQUENTLY, IT SHOULD BE NOTED THAT C
C  THE COEFFICIENTS ARE THOSE OF SPHERICAL HARMONIC FUNCTIONS THAT ARE C
C    (*) UN-NORMALISED                                                 C
C    (*) SATISFY THE SCHIFF PHASE CONVENTION                           C
C                                                                      C
C  THE OUTLINE FOR THE GENERATION OF E-COEFFICIENTS IS TAKEN FROM p16  C
C  OF THE ABOVE ARTICLE. EQUATION NUMBERS ARE GIVEN IN COMMENTS.       C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C     LQN(I) - TARGET LQN VALUES ON CENTRES A AND B.                   C
C     MQN(I) - TARGET MQN VALUES ON CENTRES A AND B.                   C
C -------------------------------------------------------------------- C
C  H.M.QUINEY THE UNIVERSITY OF MELBOURNE (2008).                      C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=ML2*2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION NBAS(2),LQN(2),MQN(2)
C
      COMPLEX*16 ESG(MB2,MEQ),ETEMP(MB2*MRC)
C
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     IMPORT LQN AND BASIS PAIR MQNS FOR LOCAL USE
      LQNA = LQN(1)
      LQNB = LQN(2)
      MQNA = MQN(1)
      MQNB = MQN(2)
      LMAX = LQNA+LQNB
C
C     CHECK THAT LMAX IS WITHIN THE BOUNDS OF MKP
      IF(LMAX.GT.MKP-1) THEN
        WRITE(6,20) LMAX,MKP-1
        WRITE(7,20) LMAX,MKP-1
        STOP
      ENDIF
20    FORMAT(2X,'Required value of LAMBDA = ',I3/
     &       2X,'Maximum allowed value of LAMBDA = ',I3//
     &       2X,'Reset MKP and recompile: terminating...'/)
C
C      SET INITIAL VALUES TO E[0,0;0,0;0,0,0,0] = RKAB
       DO M=1,MB2*MRC
         ETEMP(M) = DCMPLX(0.0D0,0.0D0)
       ENDDO
C
       DO M=1,MAXM
         ETEMP(M) = DCMPLX(RKAB(M),0.0D0)
       ENDDO
C
C      STEP 1:
C      GENERATE E[|MQNA|,MQNA;0,0] FROM E[0,0;0,0] USING
C      SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE A
       ISTART = 0
       LAM    = 0
       IF(IABS(MQNA).NE.0) THEN
         CALL STEPLM(ETEMP,LAM,ISTART,MQNA,MAXM,1)
       ENDIF
C
C      STEP 2:
C      GENERATE E[LQNA,MQNA;0,0] FROM E[|MQNA|,MQNA;0,0]
C      USING THE STEP OF LQN ONLY ON CENTRE A
       IF(LQNA.GT.IABS(MQNA)) THEN
         CALL STEPL(ETEMP,LAM,ISTART,LQNA,MQNA,MAXM,1)
       ENDIF
C
C      STEP 3:
C      GENERATE E[LQNA,MQNA;|MQNB|,MQNB] FROM E[LQNA,MQNA;0,0]
C      USING SIMULTANEOUS STEP OF LQN AND MQN ON CENTRE B
       IF(IABS(MQNB).GT.0) THEN
         CALL STEPLM(ETEMP,LAM,ISTART,MQNB,MAXM,2)
       ENDIF
C
C      STEP 4:
C      GENERATE E[LQNA,MQNA;LQNB,MQNB] FROM E[LQNA,MQNA;|MQNB|,MQNB]
C      USING THE STEP OF LQN ONLY ON CENTRE B
       IF(LQNB.GT.IABS(MQNB)) THEN
         CALL STEPL(ETEMP,LAM,ISTART,LQNB,MQNB,MAXM,2)
       ENDIF
C
C      STEP 5:
C      COPY FINAL BLOCK OF ENTRIES AS THE REQUIRED OUTPUT
       ISTART0 = ISTART
       NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
C
       K = 0
       DO ITUV=1,NTUV
         DO M=1,MAXM
           K = K+1
           ESG(M,ITUV) = ETEMP(ISTART0+K)
         ENDDO
       ENDDO
C
       RETURN
       END
C
C
      SUBROUTINE STEPLM(ETEMP,LAM,ISTART,MQN,MAXM,ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C        SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL       MM       MM        C
C       SS    SS   TT    EE       PP    PP LL       MMM     MMM        C
C       SS         TT    EE       PP    PP LL       MMMM   MMMM        C
C        SSSSSS    TT    EEEEEE   PP    PP LL       MM MM MM MM        C
C             SS   TT    EE       PPPPPPP  LL       MM  MMM  MM        C
C       SS    SS   TT    EE       PP       LL       MM   M   MM        C
C        SSSSSS    TT    EEEEEEEE PP       LLLLLLLL MM       MM        C
C                                                                      C
C -------------------------------------------------------------------- C
C   SIMULTANEOUSLY INCREMENT/DECREMENT QUANTUM NUMBERS (LQN,MQN):      C
C               E[L, L;IT,IU,IV] -> E[L+1,L+1;IT,IU,IV]                C
C               E[L,-L;IT,IU,IV] -> E[L+1,L-1;IT,IU,IV]                C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    P2(M) - CONTAINS VALUES OF P*2, P=SUM OF EXPONENTS.               C
C    PX(M) - GEOMETRICAL VALUES OF X(M)-BXYZ(ICNT,X).                 C
C    PY(M) - GEOMETRICAL VALUES OF Y(M)-BXYZ(ICNT,Y).                 C
C    MAXM  - NUMBER OF EXPONENT/DENSITY PAIRS.                         C
C    LAM   - LENGTH OF THE INPUT HGTF EXPANSION.                       C
C    LQN   - L-QUANTUM NUMBER OF THE CENTRE TO BE INCREMENTED.         C
C    ICNT  - CENTRE TO STEP UP.                                        C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION PX(MB2),PY(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(*)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IMPORT GEOMETRICAL VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(ICNT.EQ.1) THEN
          PX(M) = PAX(M)
          PY(M) = PAY(M)
        ELSEIF(ICNT.EQ.2) THEN
          PX(M) = PBX(M)
          PY(M) = PBY(M)
        ENDIF
      ENDDO
C
C     MAIN LOOP: FOR EACH M-QUANTUM NUMBER ON THIS CENTRE
      DO 100 MVAL=0,IABS(MQN)-1
C
C**********************************************************************C
C     COMPUTE THE BLOCK INDICES. THE RECURRENCE WILL RUN OVER          C
C     (LAM+1)*(LAM+2)*(LAM+3)/6 VALUES AND WILL GENERATE               C
C     (LAM+2)*(LAM+3)*(LAM+4)/6 VALUES IN THE NEXT LAYER               C
C**********************************************************************C
C
      RL1     = DFLOAT(2*IABS(MVAL)+1)
      NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
      ISTART1 = ISTART
      ISTART2 = ISTART1+NTUV*MAXM
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C          I0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                            C
C          I1-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                            C
C          I2-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                            C
C          I3-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                            C
C          I4-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                            C
C          I5-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                            C
C**********************************************************************C
C
C     INCREMENT THE M-QUANTUM NUMBER IF MQN > 0
      IF(MQN.GT.0) THEN
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART1 + (INABCD(IT  ,IU  ,IV)-1)*MAXM
              I1 = ISTART2 + (INABCD(IT  ,IU  ,IV)-1)*MAXM
              I2 = ISTART2 + (INABCD(IT+1,IU  ,IV)-1)*MAXM
              I3 = ISTART2 + (INABCD(IT  ,IU+1,IV)-1)*MAXM
C
              DO M=1,MAXM
                 T1 = RL1/P2(M)
                 TX = RL1*PX(M)
                 TY = RL1*PY(M)
                 ETEMP(I1+M) = ETEMP(I1+M) + TX*ETEMP(I0+M)
     &                                     + TY*ETEMP(I0+M)*CONE
                 ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                 ETEMP(I3+M) = ETEMP(I3+M) + T1*ETEMP(I0+M)*CONE
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.NE.0) THEN
                I4 = ISTART2 + (INABCD(IT-1,IU,IV)-1)*MAXM
                RT = DFLOAT(IT)
                FACTOR = RT*RL1
                DO M=1,MAXM
                  ETEMP(I4+M) = ETEMP(I4+M) + FACTOR*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.NE.0) THEN
                I5 = ISTART2 + (INABCD(IT,IU-1,IV)-1)*MAXM
                RU = DFLOAT(IU)
                FACTOR = RL1*RU
                DO M=1,MAXM
                  ETEMP(I5+M) = ETEMP(I5+M) + FACTOR*ETEMP(I0+M)*CONE
                ENDDO
              ENDIF
C
C           END OF LOOPS OVER HGTF INDICES
            ENDDO
          ENDDO
        ENDDO
C
C     DECREMENT THE M-QUANTUM NUMBER IF MQN < 0
      ELSE
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C          ISTART0 LABELS THE PREVIOUS LQN VALUE                       C
C          ISTART1 LABELS THE CURRENT  LQN VALUE                       C
C          ISTART2 LABELS THE NEXT     LQN VALUE                       C
C -------------------------------------------------------------------- C
C          I0-> E[LQN  ,LQN  ;IT  ,IU  ,IV]                            C
C          I1-> E[LQN+1,LQN+1;IT  ,IU  ,IV]                            C
C          I2-> E[LQN+1,LQN+1;IT+1,IU  ,IV]                            C
C          I3-> E[LQN+1,LQN+1;IT  ,IU+1,IV]                            C
C          I4-> E[LQN+1,LQN+1;IT-1,IU  ,IV]                            C
C          I5-> E[LQN+1,LQN+1;IT  ,IU-1,IV]                            C
C**********************************************************************C
C
C       LOOP OVER THE HGTF INDICES OF THE SEED LAYER
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART1 + (INABCD(IT  ,IU  ,IV)-1)*MAXM
              I1 = ISTART2 + (INABCD(IT  ,IU  ,IV)-1)*MAXM
              I2 = ISTART2 + (INABCD(IT+1,IU  ,IV)-1)*MAXM
              I3 = ISTART2 + (INABCD(IT  ,IU+1,IV)-1)*MAXM
C
              DO M=1,MAXM
                T1 = RL1/P2(M)
                TX = RL1*PX(M)
                TY = RL1*PY(M)
                ETEMP(I1+M) = ETEMP(I1+M) + TX*ETEMP(I0+M)
     &                                    - TY*ETEMP(I0+M)*CONE
                ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                ETEMP(I3+M) = ETEMP(I3+M) - T1*ETEMP(I0+M)*CONE
              ENDDO
C
C             SPECIAL CASE EXCLUDES IT=0
              IF(IT.NE.0) THEN
                I4 = ISTART2 + (INABCD(IT-1,IU  ,IV  )-1)*MAXM
                RT = DFLOAT(IT)
                FACTOR = RT*RL1
                DO M=1,MAXM
                  ETEMP(I4+M) = ETEMP(I4+M) + FACTOR*ETEMP(I0+M)
                ENDDO
              ENDIF
C
C             SPECIAL CASE EXCLUDES IU=0
              IF(IU.NE.0) THEN
                I5 = ISTART2 + (INABCD(IT  ,IU-1,IV  )-1)*MAXM
                RU = DFLOAT(IU)
                FACTOR = RL1*RU
                DO M=1,MAXM
                  ETEMP(I5+M) = ETEMP(I5+M) - FACTOR*ETEMP(I0+M)*CONE
                ENDDO
              ENDIF
C
C             END OF LOOPS OVER HGTF INDICES
            ENDDO
          ENDDO
        ENDDO
      ENDIF
C
C**********************************************************************C
C     END OF LOOP OVER MQN COUNTER. UPDATE THE VALUE OF LAM, AND       C
C     THE COUNTER THAT KEEPS TRACK OF THE BLOCKS OF E-COEFFICIENTS     C
C**********************************************************************C
C
      ISTART = ISTART + NTUV*MAXM
      LAM    = LAM + 1
C
100   CONTINUE
C
      RETURN
      END
C
C
      SUBROUTINE STEPL(ETEMP,LAM,ISTART,LQN,MQN,MAXM,ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  LL                    C
C             SS    SS   TT    EE       PP    PP LL                    C
C             SS         TT    EE       PP    PP LL                    C
C              SSSSSS    TT    EEEEEE   PP    PP LL                    C
C                   SS   TT    EE       PPPPPPP  LL                    C
C             SS    SS   TT    EE       PP       LL                    C
C              SSSSSS    TT    EEEEEEEE PP       LLLLLLLL              C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE LQN, STARTING AT E[L, L] OR E[L,-L].                  C
C -------------------------------------------------------------------- C
C  NOTE THAT THE FIRST APPLICATION OF EQ(64a) CAN ONLY MAP             C
C  E[L,L] -> E[L+1,M] OR E[L,-L] -> E[L+1,-L] AND IS TREATED SEP'TLY.  C
C  SUBSEQUENT STEPS MAP {E[L,L], E[L-1,L]} -> E[L+1,L].                C
C  FINAL APPLICATION OF THIS RULE GENERATES E[LMAX,L;0,0;T,U,V].       C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                      ML4=2*(MKP+1),MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 CONE
      COMPLEX*16 ETEMP(*)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     DEFINE THE UNIT IMAGINARY NUMBER
      CONE = DCMPLX(0.0D0,1.0D0)
C
C     IMPORT GEOMETRICAL VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(ICNT.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(ICNT.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C**********************************************************************C
C      THE FIRST STEP IS ALWAYS PERFORMED. IT MAPS THE INDEX SETS      C
C      E[MQN+1,MQN] <- E[MQN1,MQN1] FROM THE DATA OBTAINED IN STEPLM.  C
C**********************************************************************C
C
C     IF STEPL IS ENTERED WITH LQN.LE.|MQN| CONTROL IS RETURNED
C     AND NO COUNTERS ARE UPDATED
      IF(LQN.LE.IABS(MQN)) RETURN
C
      NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
      ISTART1 = ISTART
      ISTART2 = ISTART1 + NTUV*MAXM
      RFACT1  = DFLOAT(2*IABS(MQN)+1)
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C       I0-> E[MQN  ,MQN;IT  ,IU  ,IV  ]                               C
C       I1-> E[MQN+1,MQN;IT  ,IU  ,IV  ]                               C
C       I2-> E[MQN+1,MQN;IT  ,IU  ,IV+1]                               C
C       I3-> E[MQN+1,MQN;IT  ,IU  ,IV-1]                               C
C**********************************************************************C
C
C     LOOP OVER THE HGTF INDICES OF THE SEED LAYER
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
            I0 = ISTART1 + (INABCD(IT  ,IU  ,IV  )-1)*MAXM
            I1 = ISTART2 + (INABCD(IT  ,IU  ,IV  )-1)*MAXM
            I2 = ISTART2 + (INABCD(IT  ,IU  ,IV+1)-1)*MAXM
            DO M=1,MAXM
              TZ = RFACT1*PZ(M)
              TP = RFACT1/P2(M)
              ETEMP(I1+M) = ETEMP(I1+M) + TZ*ETEMP(I0+M)
              ETEMP(I2+M) = ETEMP(I2+M) + TP*ETEMP(I0+M)
            ENDDO
            IF(IV.GE.1) THEN
              I3 = ISTART2 + (INABCD(IT  ,IU  ,IV-1)-1)*MAXM
              FACTOR = RFACT1*DFLOAT(IV)
              DO M=1,MAXM
                ETEMP(I3+M) = ETEMP(I3+M) + ETEMP(I0+M)*FACTOR
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDDO
C
C     UPDATE LAM INDEX AND BLOCK LOCATOR
      ISTART0 = ISTART
      ISTART  = ISTART + NTUV*MAXM
      LAM     = LAM + 1
C
      IF(LQN.EQ.IABS(MQN)+1) RETURN
C
C**********************************************************************C
C     SECOND AND SUBSEQUENT STEPS IN THIS RECURRENCE INVOLVE THREE     C
C     LAYERS OF COEFFICIENTS:                                          C
C     E[LQN1+1,MQN1] <- {E[LQN1,MQN1],E[LQN-1,MQN1]}                   C
C**********************************************************************C
C
      DO LQN1=IABS(MQN)+1,LQN-1
        RL1M1   = DFLOAT(LQN1-IABS(MQN)+1)
        RFACT1  = DFLOAT(2*LQN1+1)/RL1M1
        NTUV    = (LAM+1)*(LAM+2)*(LAM+3)/6
        ISTART1 = ISTART
        ISTART2 = ISTART + MAXM*NTUV
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C     I0-> E[LQN  ,MQN;IT  ,IU  ,IV  ]                                 C
C     I1-> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                 C
C     I2-> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                 C
C     I3-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                 C
C**********************************************************************C
C
C       THE FIRST LOOP OVER ITUV INCLUDES ALL HGTF INDICES ON THE
C       LAYER CORRESPONDING TO THE CURRENT VALUE OF LQN1
        DO IOUTER=0,LAM
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART1 + (INABCD(IT  ,IU  ,IV  )-1)*MAXM
              I1 = ISTART2 + (INABCD(IT  ,IU  ,IV  )-1)*MAXM
              I2 = ISTART2 + (INABCD(IT  ,IU  ,IV+1)-1)*MAXM
              DO M=1,MAXM
                TZ = RFACT1*PZ(M)
                TP = RFACT1/P2(M)
                ETEMP(I1+M) = ETEMP(I1+M) + TZ*ETEMP(I0+M)
                ETEMP(I2+M) = ETEMP(I2+M) + TP*ETEMP(I0+M)
              ENDDO
              IF(IV.GE.1) THEN
                I3 = ISTART2 + (INABCD(IT  ,IU  ,IV-1)-1)*MAXM
                FACTOR = RFACT1*DFLOAT(IV)
                DO M=1,MAXM
                  ETEMP(I3+M) = ETEMP(I3+M) + ETEMP(I0+M)*FACTOR
                ENDDO
              ENDIF
            ENDDO
          ENDDO
        ENDDO
C
C**********************************************************************C
C                          INDEX MAPPINGS:                             C
C -------------------------------------------------------------------- C
C     I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                                C
C     I1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                                C
C     I2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                                C
C     I3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                                C
C     I4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                                C
C     I5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                                C
C     I6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                C
C     I7 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                C
C     I8 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                                C
C     I9 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                                C
C     I10-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                C
C     I11-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                                C
C     I12-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                                C
C     I13-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                                C
C**********************************************************************C
C
C       THE SECOND LOOP OVER ITUV INCLUDES ALL HGTF INDICES ON THE
C       LAYER CORRESPONDING TO (LQN1-1)
        RFACT1 =-DFLOAT(LQN1+IABS(MQN))/DBLE(LQN1-IABS(MQN)+1)
        DO IOUTER=0,LAM-1
          DO IT=0,IOUTER
            DO IU=0,IOUTER-IT
              IV = IOUTER-IT-IU
              I0 = ISTART0+(INABCD(IT  ,IU  ,IV  )-1)*MAXM
              I1 = ISTART2+(INABCD(IT+2,IU  ,IV  )-1)*MAXM
              I2 = ISTART2+(INABCD(IT  ,IU+2,IV  )-1)*MAXM
              I3 = ISTART2+(INABCD(IT  ,IU  ,IV+2)-1)*MAXM
              I4 = ISTART2+(INABCD(IT+1,IU  ,IV  )-1)*MAXM
              I5 = ISTART2+(INABCD(IT  ,IU+1,IV  )-1)*MAXM
              I6 = ISTART2+(INABCD(IT  ,IU  ,IV+1)-1)*MAXM
              I7 = ISTART2+(INABCD(IT  ,IU  ,IV  )-1)*MAXM
              TI = DFLOAT(2*(IT+IU+IV)+3)
              DO M=1,MAXM
                T1 = RFACT1/P22(M)
                T0 = RFACT1/P(M)
                TX = T0*PX(M)
                TY = T0*PY(M)
                TZ = T0*PZ(M)
                TT = RFACT1*(PP(M)+TI/P2(M))
                ETEMP(I1+M) = ETEMP(I1+M) + T1*ETEMP(I0+M)
                ETEMP(I2+M) = ETEMP(I2+M) + T1*ETEMP(I0+M)
                ETEMP(I3+M) = ETEMP(I3+M) + T1*ETEMP(I0+M)
                ETEMP(I4+M) = ETEMP(I4+M) + TX*ETEMP(I0+M)
                ETEMP(I5+M) = ETEMP(I5+M) + TY*ETEMP(I0+M)
                ETEMP(I6+M) = ETEMP(I6+M) + TZ*ETEMP(I0+M)
                ETEMP(I7+M) = ETEMP(I7+M) + TT*ETEMP(I0+M)
              ENDDO
              IF(IT.GE.1) THEN
                I8 = ISTART2 + (INABCD(IT-1,IU  ,IV  )-1)*MAXM
                T1 = RFACT1*DFLOAT(2*IT)
                DO M=1,MAXM
                  TX = T1*PX(M)
                  ETEMP(I8+M) = ETEMP(I8+M) + TX*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IU.GE.1) THEN
                I9 = ISTART2 + (INABCD(IT  ,IU-1,IV  )-1)*MAXM
                T1 = RFACT1*DFLOAT(2*IU)
                DO M=1,MAXM
                  TY = T1*PY(M)
                  ETEMP(I9+M) = ETEMP(I9+M) + TY*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IV.GE.1) THEN
                I10 = ISTART2 + (INABCD(IT  ,IU  ,IV-1)-1)*MAXM
                T1  = RFACT1*DFLOAT(2*IV)
                DO M=1,MAXM
                  TZ = T1*PZ(M)
                  ETEMP(I10+M) = ETEMP(I10+M) + TZ*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IT.GE.2) THEN
                I11 = ISTART2 + (INABCD(IT-2,IU  ,IV  )-1)*MAXM
                T1  = RFACT1*DFLOAT(IT*(IT-1))
                DO M=1,MAXM
                  ETEMP(I11+M) = ETEMP(I11+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IU.GE.2) THEN
                I12 = ISTART2 + (INABCD(IT  ,IU-2,IV  )-1)*MAXM
                T1  = RFACT1*DFLOAT(IU*(IU-1))
                DO M=1,MAXM
                  ETEMP(I12+M) = ETEMP(I12+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
              IF(IV.GE.2) THEN
                I13 = ISTART2 + (INABCD(IT  ,IU  ,IV-2)-1)*MAXM
                T1  = RFACT1*DFLOAT(IV*(IV-1))
                DO M=1,MAXM
                  ETEMP(I13+M) = ETEMP(I13+M) + T1*ETEMP(I0+M)
                ENDDO
              ENDIF
            ENDDO
          ENDDO
        ENDDO
C
C       END OF LOOP OVER LQN1 FOR FIXED MQN
C
        LAM     = LAM+1
        ISTART0 = ISTART
        ISTART  = ISTART + MAXM*NTUV
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE STEPN(ESG,ENSG,LAM,MAXM,ICNT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C              SSSSSS TTTTTTTT EEEEEEEE PPPPPPP  NN    NN              C
C             SS    SS   TT    EE       PP    PP NNN   NN              C
C             SS         TT    EE       PP    PP NNNN  NN              C
C              SSSSSS    TT    EEEEEE   PP    PP NN NN NN              C
C                   SS   TT    EE       PPPPPPP  NN  NNNN              C
C             SS    SS   TT    EE       PP       NN   NNN              C
C              SSSSSS    TT    EEEEEEEE PP       NN    NN              C
C                                                                      C
C -------------------------------------------------------------------- C
C  INCREMENT THE NQN, E[NQN,LQN,MQN] -> E[NQN+1,LQN,MQN].              C
C                                                                      C
C  NOTE THAT STEPN WILL ONLY PERFORM A SINGLE STEP IN NQN. IT USES AS  C
C  INPUT A SET OF PROCESSED E-COEFFICIENTS FROM VRS (ESGTFR,ESGTFI)    C
C  AND OUTPUTS THE INCREMENTED SET (ENSGTFR,ENSGTFI).                  C
C -------------------------------------------------------------------- C
C  LAM IS THE EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE INPUT COEFFS.    C
C  THE EFFECTIVE TOTAL ANGULAR MOMENTUM OF THE OUTPUT COEFFS IS LAM+2. C
C**********************************************************************C
      PARAMETER(MBS=26,MB2=MBS*MBS,MKP=9,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6,
     &                          ML4=2*ML2,MRC=(ML4+1)*(ML4+2)*(ML4+3)/6)
C
      DIMENSION PP(MB2),PX(MB2),PY(MB2),PZ(MB2)
C
      COMPLEX*16 ESG(MB2,MEQ),ENSG(MB2,MEQ)
C
      COMMON/ACSS/INABCD(0:ML4,0:ML4,0:ML4),
     &            IVEC(MRC),JVEC(MRC),KVEC(MRC),LAMVEC(MRC)
      COMMON/CTSN/P(MB2),P2(MB2),P22(MB2),RKAB(MB2),PA2(MB2),PB2(MB2),
     &            PAX(MB2),PAY(MB2),PAZ(MB2),PBX(MB2),PBY(MB2),PBZ(MB2)
C
C     IMPORT GEOMETRICAL VALUES FOR CENTRE OF INTEREST
      DO M=1,MAXM
        IF(ICNT.EQ.1) THEN
          PP(M) = PA2(M)
          PX(M) = PAX(M)
          PY(M) = PAY(M)
          PZ(M) = PAZ(M)
        ELSEIF(ICNT.EQ.2) THEN
          PP(M) = PB2(M)
          PX(M) = PBX(M)
          PY(M) = PBY(M)
          PZ(M) = PBZ(M)
        ENDIF
      ENDDO
C
C     SET THE TARGET COEFFICIENTS TO ZERO, TAKING INTO ACCOUNT THE
C     INCREMENT OF LAM BY TWO UNITS IN THE TARGET
      NTUV = (LAM+3)*(LAM+4)*(LAM+5)/6
      DO ITUV=1,NTUV
        DO M=1,MAXM
          ENSG(M,ITUV) = DCMPLX(0.0D0,0.0D0)
        ENDDO
      ENDDO
C
C**********************************************************************C
C                          INDEX MAPPINGS                              C
C -------------------------------------------------------------------- C
C     I0 -> E[LQN-1,MQN;IT  ,IU  ,IV  ]                                C
C     I1 -> E[LQN+1,MQN;IT+2,IU  ,IV  ]                                C
C     I2 -> E[LQN+1,MQN;IT  ,IU+2,IV  ]                                C
C     I3 -> E[LQN+1,MQN;IT  ,IU  ,IV+2]                                C
C     I4 -> E[LQN+1,MQN;IT+1,IU  ,IV  ]                                C
C     I5 -> E[LQN+1,MQN;IT  ,IU+1,IV  ]                                C
C     I6 -> E[LQN+1,MQN;IT  ,IU  ,IV+1]                                C
C     I7 -> E[LQN+1,MQN;IT  ,IU  ,IV  ]                                C
C     I8 -> E[LQN+1,MQN;IT-1,IU  ,IV  ]                                C
C     I9 -> E[LQN+1,MQN;IT  ,IU-1,IV  ]                                C
C     I10-> E[LQN+1,MQN;IT  ,IU  ,IV-1]                                C
C     I11-> E[LQN+1,MQN;IT-2,IU  ,IV  ]                                C
C     I12-> E[LQN+1,MQN;IT  ,IU-2,IV  ]                                C
C     I13-> E[LQN+1,MQN;IT  ,IU  ,IV-2]                                C
C**********************************************************************C
C
      DO IOUTER=0,LAM
        DO IT=0,IOUTER
          DO IU=0,IOUTER-IT
            IV = IOUTER-IT-IU
C
            I0 = INABCD(IT  ,IU  ,IV  )
            I1 = INABCD(IT+2,IU  ,IV  )
            I2 = INABCD(IT  ,IU+2,IV  )
            I3 = INABCD(IT  ,IU  ,IV+2)
            I4 = INABCD(IT+1,IU  ,IV  )
            I5 = INABCD(IT  ,IU+1,IV  )
            I6 = INABCD(IT  ,IU  ,IV+1)
            I7 = INABCD(IT  ,IU  ,IV  )
C
            TT = DFLOAT((2*(IT+IU+IV))+3)
            DO M=1,MAXM
              T0 = 1.0D0/P22(M)
              TX = PX(M)/P(M)
              TY = PY(M)/P(M)
              TZ = PZ(M)/P(M)
              TP = PP(M) + TT/P2(M)
              ENSG(M,I1) = ENSG(M,I1) + T0*ESG(M,I0)
              ENSG(M,I2) = ENSG(M,I2) + T0*ESG(M,I0)
              ENSG(M,I3) = ENSG(M,I3) + T0*ESG(M,I0)
              ENSG(M,I4) = ENSG(M,I4) + TX*ESG(M,I0)
              ENSG(M,I5) = ENSG(M,I5) + TY*ESG(M,I0)
              ENSG(M,I6) = ENSG(M,I6) + TZ*ESG(M,I0)
              ENSG(M,I7) = ENSG(M,I7) + TP*ESG(M,I0)
            ENDDO
C
            IF(IT.GE.1) THEN
              RT2 = DFLOAT(2*IT)
              I8  = INABCD(IT-1,IU  ,IV  )
              DO M=1,MAXM
                T0 = PX(M)*RT2
                ENSG(M,I8) = ENSG(M,I8) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IU.GE.1) THEN
              RU2 = DFLOAT(2*IU)
              I9   = INABCD(IT  ,IU-1,IV  )
              DO M=1,MAXM
                T0 = PY(M)*RU2
                ENSG(M,I9) = ENSG(M,I9) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IV.GE.1) THEN
              RV2 = DFLOAT(2*IV)
              I10 = INABCD(IT  ,IU  ,IV-1)
              DO M=1,MAXM
                T0 = PZ(M)*RV2
                ENSG(M,I10) = ENSG(M,I10) + T0*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IT.GE.2) THEN
              RT2 = DFLOAT(IT*(IT-1))
              I11 = INABCD(IT-2,IU  ,IV  )
              DO M=1,MAXM
                ENSG(M,I11) = ENSG(M,I11) + RT2*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IU.GE.2) THEN
              RU2 = DFLOAT(IU*(IU-1))
              I12  = INABCD(IT  ,IU-2,IV  )
              DO M=1,MAXM
                ENSG(M,I12) = ENSG(M,I12) + RU2*ESG(M,I0)
              ENDDO
            ENDIF
C
            IF(IV.GE.2) THEN
              RV2 = DFLOAT(IV*(IV-1))
              I13 = INABCD(IT  ,IU  ,IV-2)
              DO M=1,MAXM
                ENSG(M,I13) = ENSG(M,I13) + RV2*ESG(M,I0)
              ENDDO
            ENDIF
          ENDDO
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNLL(RNORM,EXPT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN LL       LL                        C
C                 RR    RR NNN   NN LL       LL                        C
C                 RR    RR NNNN  NN LL       LL                        C
C                 RR    RR NN NN NN LL       LL                        C
C                 RRRRRRR  NN  NNNN LL       LL                        C
C                 RR    RR NN   NNN LL       LL                        C
C                 RR    RR NN    NN LLLLLLLL LLLLLLLL                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNLL GENERATES THE LARGE-LARGE SGTF NORMALISATION CONSTANTS.        C
C**********************************************************************C
      PARAMETER(MBS=26)
C
      DIMENSION RNORM(MBS,2),EXPT(MBS,2),LQN(2),NBAS(2)
      DATA PI,TWOLOG/3.1415926535897932D0,6.93147180559945309D-1/
C
      DO I=1,2
        T1  = DSQRT(PI)
        F1  = 0.5D0
        GML = DLOG(T1)
        DO N=2,LQN(I)+2
          GML = GML+DLOG(F1)
          F1  = F1 + 1.0D0
        ENDDO
        RLA = DFLOAT(LQN(I))
        GA1 = TWOLOG-GML
        RA1 = RLA+1.5D0
        DO IBAS=1,NBAS(I)
          ELOG          = DLOG(2.0D0*EXPT(IBAS,I))
          RNORM(IBAS,I) = DEXP(0.5D0*(GA1+RA1*ELOG))
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNSS(RNORM,EXPT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN  SSSSSS   SSSSSS                   C
C                 RR    RR NNN   NN SS    SS SS    SS                  C
C                 RR    RR NNNN  NN SS       SS                        C
C                 RR    RR NN NN NN  SSSSSS   SSSSSS                   C
C                 RRRRRRR  NN  NNNN       SS       SS                  C
C                 RR    RR NN   NNN SS    SS SS    SS                  C
C                 RR    RR NN    NN  SSSSSS   SSSSSS                   C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNSS GENERATES THE SMALL-SMALL SGTF NORMALISATION CONSTANTS.        C
C**********************************************************************C
      PARAMETER(MBS=26)
C
      DIMENSION RNORM(MBS,2),EXPT(MBS,2),LQN(2),NBAS(2)
      DATA PI,TWOLOG/3.1415926535897932D0,6.93147180559945309D-1/
C
      DO I=1,2
        T1  = DSQRT(PI)
        F1  = 0.5D0
        GML = DLOG(T1)
        DO N=2,LQN(I)+3
          GML = GML+DLOG(F1)
          F1  = F1+1.0D0
        ENDDO
        RLA = DFLOAT(LQN(I))
        GA1 = TWOLOG-GML
        RA1 = RLA+0.5D0
        DO IBAS=1,NBAS(I)
          ELOG          = DLOG(2.0D0*EXPT(IBAS,I))
          RNORM(IBAS,I) = DEXP(0.5D0*(GA1+RA1*ELOG))
        ENDDO
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNLS(RNORMLS,EXPT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN LL       SSSSSS                    C
C                 RR    RR NNN   NN LL      SS    SS                   C
C                 RR    RR NNNN  NN LL      SS                         C
C                 RR    RR NN NN NN LL       SSSSSS                    C
C                 RRRRRRR  NN  NNNN LL            SS                   C
C                 RR    RR NN   NNN LL      SS    SS                   C
C                 RR    RR NN    NN LLLLLLLL SSSSSS                    C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNLS GENERATES THE LARGE-SMALL SGTF NORMALISATION CONSTANTS.        C
C**********************************************************************C
      PARAMETER(MBS=26)
C
      DIMENSION RNORMLS(MBS,2),EXPT(MBS,2),LQN(2),NBAS(2)
      DATA PI,TWOLOG/3.1415926535897932D0,6.93147180559945309D-1/
C
      T1L  = DSQRT(PI)
      F1L  = 0.5D0
      GMLL = DLOG(T1L)
C
      DO N=2,LQN(1)+2
        GMLL = GMLL+DLOG(F1L)
        F1L  = F1L+1.0D0
      ENDDO
C
      RLAL = DFLOAT(LQN(1))
      GA1L = TWOLOG-GMLL
      RA1L = RLAL+1.5D0
C
      DO IBAS=1,NBAS(1)
        ELOGL           = DLOG(2.0D0*EXPT(IBAS,1))
        RNORMLS(IBAS,1) = DEXP(0.5D0*(GA1L+RA1L*ELOGL))
      ENDDO
C
      T1S  = DSQRT(PI)
      F1S  = 0.5D0
      GMLS = DLOG(T1S)
C
      DO N=2,LQN(2)+3
        GMLS = GMLS+DLOG(F1S)
        F1S  = F1S+1.0D0
      ENDDO
C
      RLAS = DFLOAT(LQN(2))
      GA1S = TWOLOG-GMLS
      RA1S = RLAS+0.5D0
C
      DO JBAS=1,NBAS(2)
        ELOGS           = DLOG(2.0D0*EXPT(JBAS,2))
        RNORMLS(JBAS,2) = DEXP(0.5D0*(GA1S+RA1S*ELOGS))
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE RNSL(RNORMSL,EXPT,LQN,NBAS)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C                 RRRRRRR  NN    NN  SSSSSS  LL                        C
C                 RR    RR NNN   NN SS    SS LL                        C
C                 RR    RR NNNN  NN SS       LL                        C
C                 RR    RR NN NN NN  SSSSSS  LL                        C
C                 RRRRRRR  NN  NNNN       SS LL                        C
C                 RR    RR NN   NNN SS    SS LL                        C
C                 RR    RR NN    NN  SSSSSS  LLLLLLLL                  C
C                                                                      C
C -------------------------------------------------------------------- C
C  RNLS GENERATES THE SMALL-LARGE SGTF NORMALISATION CONSTANTS.        C
C**********************************************************************C
      PARAMETER(MBS=26)
C
      DIMENSION RNORMSL(MBS,2),EXPT(MBS,2),LQN(2),NBAS(2)
      DATA PI,TWOLOG/3.1415926535897932D0,6.93147180559945309D-1/
C
      T1S  = DSQRT(PI)
      F1S  = 0.5D0
      GMSL = DLOG(T1S)
C
      DO N=2,LQN(1)+3
        GMSL = GMSL+DLOG(F1S)
        F1S  = F1S+1.0D0
      ENDDO
C
      RLAS = DFLOAT(LQN(1))
      GA1S = TWOLOG-GMSL
      RA1S = RLAS+0.5D0
C
      DO IBAS=1,NBAS(1)
        ELOGS           = DLOG(2.0D0*EXPT(IBAS,1))
        RNORMSL(IBAS,1) = DEXP(0.5D0*(GA1S+RA1S*ELOGS))
      ENDDO
C
      T1L  = DSQRT(PI)
      F1L  = 0.5D0
      GMLL = DLOG(T1L)
C
      DO N=2,LQN(2)+2
        GMLL = GMLL+DLOG(F1L)
        F1L  = F1L+1.0D0
      ENDDO
C
      RLAL = DFLOAT(LQN(2))
      GA1L = TWOLOG-GMLL
      RA1L = RLAL+1.5D0
C
      DO JBAS=1,NBAS(2)
        ELOGL           = DLOG(2.0D0*EXPT(JBAS,2))
        RNORMSL(JBAS,2) = DEXP(0.5D0*(GA1L+RA1L*ELOGL))
      ENDDO
C
      RETURN
      END
C
C
      SUBROUTINE DNORM(NMAX,ECFF,ICMP,SCL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C           DDDDDDD  NN    NN  OOOOOO  RRRRRRR  MM       MM            C
C           DD    DD NNN   NN OO    OO RR    RR MMM     MMM            C
C           DD    DD NNNN  NN OO    OO RR    RR MMMM   MMMM            C
C           DD    DD NN NN NN OO    OO RR    RR MM MM MM MM            C
C           DD    DD NN  NNNN OO    OO RRRRRRR  MM  MMM  MM            C
C           DD    DD NN   NNN OO    OO RR    RR MM   M   MM            C
C           DDDDDDD  NN    NN  OOOOOO  RR    RR MM       MM            C
C                                                                      C
C -------------------------------------------------------------------- C
C  DNORM CALCULATES A SCALE NORM FOR A REAL OR COMPLEX PART OF A LIST  C
C  ECFF OF LENGTH NMAX, AND STORES THE RESULT IN SCL.                  C
C**********************************************************************C
C
      DIMENSION ECMP(NMAX)
C
      COMPLEX*16 ECFF(NMAX)
C
C     IMPORT EITHER THE REAL OR COMPLEX COMPONENT FROM ECFF
      DO N=1,NMAX
        IF(ICMP.EQ.1) THEN
          ECMP(N) = DREAL(ECFF(N))
        ELSEIF(ICMP.EQ.2) THEN
          ECMP(N) = DIMAG(ECFF(N))
        ELSE
          WRITE(6, *) 'In DNORM: choose component 1 or 2.'
          WRITE(7, *) 'In DNORM: choose component 1 or 2.'
        ENDIF
      ENDDO
C
C     INITIATE LOOP OVER ELEMENTS OF ECMP
      SSQ = 1.0D0
      SCL = 0.0D0
      DO N=1,NMAX
        IF(ECMP(N).NE.0.0D0) THEN
          ABN = DABS(ECMP(N))
          IF(SCL.LT.ABN) THEN
            SSQ = 1.0D0 + SSQ*(SCL/ABN)**2
          ELSE
            SSQ = SSQ   +     (ABN/SCL)**2
          ENDIF
        ENDIF
      ENDDO
      SCL = SCL*DSQRT(SSQ)
C
      RETURN
      END
C
C
C**********************************************************************C
C ==================================================================== C
C  [14] SCREENING: ROUTINES TO ESTIMATE FOCK MATRIX CONTRIBUTIONS.     C
C ==================================================================== C
C  ROUTINES AND FUNCTIONS:                                             C
C -------------------------------------------------------------------- C
C   [A] SCHWARZ: APPROXIMATES UPPER BOUND OF BLOCK OF COULOMB INTS.    C
C   [B] SELFCLM: GENERATES ARRAY OF COULOMB SELF-OVERLAPS.             C
C   [C] SELFBRT: GENERATES ARRAY OF BREIT SELF-OVERLAPS.               C
C**********************************************************************C
C
C
      SUBROUTINE SCHWARZ(GDIR,SENS,TADD)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C   SSSSSS   CCCCCC  HH    HH WW         WW    AA    RRRRRRR  ZZZZZZZZ C
C  SS    SS CC    CC HH    HH WW         WW   AAAA   RR    RR      ZZ  C
C  SS       CC       HH    HH WW         WW  AA  AA  RR    RR     ZZ   C
C   SSSSSS  CC       HHHHHHHH WW    W    WW AA    AA RR    RR    ZZ    C
C        SS CC       HH    HH  WW  WWW  WW  AAAAAAAA RRRRRRR    ZZ     C
C  SS    SS CC    CC HH    HH   WWWW WWWW   AA    AA RR    RR  ZZ      C
C   SSSSSS   CCCCCC  HH    HH    WW   WW    AA    AA RR    RR ZZZZZZZZ C
C                                                                      C
C -------------------------------------------------------------------- C
C  SCHWARZ APPROXIMATES THE UPPER BOUND TO A BLOCK OF TWO-ELECTRON     C
C  INTEGRALS AND ITS CONTRIBUTION TO THE GDIR/GXCH MATRIX.             C
C -------------------------------------------------------------------- C
C  INPUT:                                                              C
C    GDIR - FULL ARRAY OF PAIR-WISE MATRIX ELEMENTS.                   C
C    SENS - SENSITIVITY LIMIT FOR MAXIMUM FOCK MATRIX CONTRIBUTION.    C
C    TADD - TIME TAKEN TO RUN THIS ROUTINE.                            C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000,
     &                          ML2=MKP+1,MEQ=(ML2+1)*(ML2+2)*(ML2+3)/6)
C
      CHARACTER*4 HMLT
C
      DIMENSION GDIR(MDM,MDM)
      DIMENSION R(8),D(4)
      DIMENSION NBAS(4)
C
      COMPLEX*16 DENC(MDM,MDM),DENO(MDM,MDM),DENT(MDM,MDM)
C
      COMMON/BLOC/PAB1,PAB2,PCD1,PCD2,NA1,NB1,NC1,ND1,NA2,NB2,NC2,ND2,
     &            IBAS,JBAS,ILIN,NADDAB,NADDCD,NBAS
      COMMON/DENS/DENC,DENO,DENT
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
C
C     TIME AT START OF ROUTINE
      CALL CPU_TIME(T1)
C
C     RESET SCREENING COUNTERS
      IBCH = 1
      DO M=1,NBAS(3)*NBAS(4)
        IMAP(M) = M
        ISCR(M) = 1
        DO ISYM=1,11
          IMTX(M,ISYM) = 1
        ENDDO
      ENDDO
      MAXN = NBAS(3)*NBAS(4)
C
C     IF TOGGLE SWITCHED OFF, DO NOT SCREEN
      IF(ITOG.EQ.0) GOTO 99
C
C     FIND LARGEST UPPER BOUND AND DENSITY PRODUCT FOR EACH M
      M = 0
      N = 0
      DO KBAS=1,NBAS(3)
        DO LBAS=1,NBAS(4)
          M = M+1
C
C         DIRECT INTEGRALS
          R(1) = GDIR(NA1+IBAS,NB1+JBAS)
          R(2) = GDIR(NA1+IBAS,NB2+JBAS)
          R(3) = GDIR(NA2+IBAS,NB1+JBAS)
          R(4) = GDIR(NA2+IBAS,NB2+JBAS)
          R(5) = GDIR(NC1+KBAS,ND1+LBAS)
          R(6) = GDIR(NC1+KBAS,ND2+LBAS)
          R(7) = GDIR(NC2+KBAS,ND1+LBAS)
          R(8) = GDIR(NC2+KBAS,ND2+LBAS)
C
C         LARGEST OF THE DIRECT INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 1 AND IFLG = 2
          D(1) = ABS(DENT(NC1+KBAS,ND1+LBAS))
          D(2) = ABS(DENT(NC1+KBAS,ND2+LBAS))
          D(3) = ABS(DENT(NC2+KBAS,ND1+LBAS))
          D(4) = ABS(DENT(NC2+KBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 1) = 0
            IMTX(M, 2) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 3 AND IFLG = 4
          D(1) = ABS(DENT(NA1+IBAS,NB1+JBAS))
          D(2) = ABS(DENT(NA1+IBAS,NB2+JBAS))
          D(3) = ABS(DENT(NA2+IBAS,NB1+JBAS))
          D(4) = ABS(DENT(NA2+IBAS,NB2+JBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 3) = 0
            IMTX(M, 4) = 0
          ENDIF
C
C         EXCHANGE INTEGRALS (FIRST TYPE)
          R(1) = GDIR(NB1+JBAS,NC1+KBAS)
          R(2) = GDIR(NB1+JBAS,NC2+KBAS)
          R(3) = GDIR(NB2+JBAS,NC1+KBAS)
          R(4) = GDIR(NB2+JBAS,NC2+KBAS)
          R(5) = GDIR(NA1+IBAS,ND1+LBAS)
          R(6) = GDIR(NA1+IBAS,ND2+LBAS)
          R(7) = GDIR(NA2+IBAS,ND1+LBAS)
          R(8) = GDIR(NA2+IBAS,ND2+LBAS)
C
C         LARGEST OF THE EXCHANGE INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 8 AND IFLG = 9
          D(1) = ABS(DENT(NA1+IBAS,ND1+LBAS))
          D(2) = ABS(DENT(NA1+IBAS,ND2+LBAS))
          D(3) = ABS(DENT(NA2+IBAS,ND1+LBAS))
          D(4) = ABS(DENT(NA2+IBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 8) = 0
            IMTX(M, 9) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 5
          D(1) = ABS(DENT(NB1+JBAS,NC1+KBAS))
          D(2) = ABS(DENT(NB1+JBAS,NC2+KBAS))
          D(3) = ABS(DENT(NB2+JBAS,NC1+KBAS))
          D(4) = ABS(DENT(NB2+JBAS,NC2+KBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 5) = 0
          ENDIF
C
C         EXCHANGE INTEGRALS (SECOND TYPE)
          R(1) = GDIR(NB1+JBAS,ND1+LBAS)
          R(2) = GDIR(NB1+JBAS,ND2+LBAS)
          R(3) = GDIR(NB2+JBAS,ND1+LBAS)
          R(4) = GDIR(NB2+JBAS,ND2+LBAS)
          R(5) = GDIR(NA1+IBAS,NC1+KBAS)
          R(6) = GDIR(NA1+IBAS,NC2+KBAS)
          R(7) = GDIR(NA2+IBAS,NC1+KBAS)
          R(8) = GDIR(NA2+IBAS,NC2+KBAS)
C
C         LARGEST OF THE EXCHANGE INTEGRAL PRODUCTS
          GLRG = DMAX1(R(1),R(2),R(3),R(4))*DMAX1(R(5),R(6),R(7),R(8))
C
C         DENSITY ELEMENTS FOR IFLG = 7 AND IFLG = 11
          D(1) = ABS(DENT(NA1+IBAS,NC1+KBAS))
          D(2) = ABS(DENT(NA1+IBAS,NC2+KBAS))
          D(3) = ABS(DENT(NA2+IBAS,NC1+KBAS))
          D(4) = ABS(DENT(NA2+IBAS,NC2+KBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 7) = 0
            IMTX(M,11) = 0
          ENDIF
C
C         DENSITY ELEMENTS FOR IFLG = 6 AND IFLG = 10
          D(1) = ABS(DENT(NB1+JBAS,ND1+LBAS))
          D(2) = ABS(DENT(NB1+JBAS,ND2+LBAS))
          D(3) = ABS(DENT(NB2+JBAS,ND1+LBAS))
          D(4) = ABS(DENT(NB2+JBAS,ND2+LBAS))
C
C         LARGEST OF THE POSSIBLE MATRIX ELEMENTS
          XLRG = GLRG*DMAX1(D(1),D(2),D(3),D(4))
C
C         SCREENING DECISION TREE
          IF(XLRG.GT.SENS) THEN
C           MAX. ELEMENT IS OVER SENSITIVITY LIMIT
            GOTO 1000
          ELSE
C           MAX. ELEMENT IS UNDER SENSITIVITY LIMIT
            IMTX(M, 6) = 0
            IMTX(M,10) = 0
          ENDIF
C
C         SCREEN THIS BATCH M
          ISCR(M) = 0
          GOTO 1001
C
C         SCREENING FAILED FOR THIS BATCH
1000      CONTINUE
          N = N+1
          IMAP(N) = M
          ISCR(M) = 1
C
1001      CONTINUE
C
        ENDDO
      ENDDO
C
C     NUMBER OF INTEGRALS TO CALCULATE
      MAXN = N
C
C     NONE OF THE ELEMENTS WERE ABOVE SENSITIVITY LIMIT
      IF(N.EQ.0) THEN
        IBCH = 0
      ENDIF
C
C     SKIP POINT WHEN SCREENING COUNTER SWITCHED OFF
99    CONTINUE
C
C     TIME AT END OF ROUTINE
      CALL CPU_TIME(T2)
C
C     ADD TO THE LINKED TIME INDEX
      TADD = TADD+T2-T1
C
      RETURN
      END
C
C
      SUBROUTINE SELFCLM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C    SSSSSS  EEEEEEEE LL       FFFFFFFF  CCCCCC  LL       MM       MM  C
C   SS    SS EE       LL       FF       CC    CC LL       MMM     MMM  C
C   SS       EE       LL       FF       CC       LL       MMMM   MMMM  C
C    SSSSSS  EEEEEE   LL       FFFFFF   CC       LL       MM MM MM MM  C
C         SS EE       LL       FF       CC       LL       MM  MMM  MM  C
C   SS    SS EE       LL       FF       CC    CC LL       MM   M   MM  C
C    SSSSSS  EEEEEEEE LLLLLLLL FF        CCCCCC  LLLLLLLL MM       MM  C
C                                                                      C
C -------------------------------------------------------------------- C
C  SELFCLM GENERATES DIAGONAL COULOMB INTERACTION ELEMENTS FOR LATER   C
C  USE IN THE SCHWARZ INEQUALITY IN SCREENING PROCEDURES.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000)
C
      CHARACTER*4 HMLT
      CHARACTER*80 TITLE
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION GDSC(MDM,MDM),BDSC(MDM,MDM)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/E0LL/E0LLFL(MFL,8),IAD0LL(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/E0SS/E0SSFL(MFL,8),IAD0SS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/SWRZ/GDSC,BDSC
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      IERC = 0
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.EQ.'BARE') THEN
        RETURN
      ELSEIF(HMLT.EQ.'NORL') THEN
        ITSTRT = 1
        ITSTOP = 1
        ITSKIP = 1
      ELSE
        ITSTRT = 4
        ITSTOP = 1
        ITSKIP =-3
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          GDSC(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1100 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE C'
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
        IF(ICNTC.NE.ICNTA) GOTO 1101
C
C     LOOP OVER CENTRE D
      DO 1200 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE D'
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
        IF(ICNTD.NE.ICNTB) GOTO 1201
C
C**********************************************************************C
C     LOOP OVER ALL KQNS (INDEX 2000)                                  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2100 KC=1,NKAP(ICNTC)
C
        IF(KC.NE.KA) GOTO 2101
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = BSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2200 KD=1,NKAP(ICNTD)
C
        IF(KD.NE.KB) GOTO 2201
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = BSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| VALUES (INDEX 3000)                          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLL = IAD0LL(ICNTA,ICNTB,KA,KB,MA,MB)
      IABSS = IAD0SS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3100 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      IF(MC.NE.MA) GOTO 3101
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3200 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
      IF(MD.NE.MB) GOTO 3201
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLL = IAD0LL(ICNTC,ICNTD,KC,KD,MC,MD)
      ICDSS = IAD0SS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND C: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.1) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR B AND D: TT = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.1) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1
C
C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = (2*IT1+IT2)/3
C
C**********************************************************************C
C     MATRIX ADDRESS ALLOCATION                                        C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDCD
C
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B.                     C
C     INCLUDE A BATCH OF ELECTRON REPULSION INTEGRALS INTO GMAT/QMAT.  C
C     NO EFFORT HAS BEEN MADE TO UTILISE INTEGRAL SYMMETRY BECAUSE     C
C     ROUTINE TAKES ALMOST NO TIME TO RUN AND IS NEEDED ONLY ONCE.     C
C**********************************************************************C
C
C     LOOP OVER ELEMENTS OF FOCK MATRIX BLOCK
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         RESET SCREENING COUNTERS
          DO M=1,NBAS(3)*NBAS(4)
            IMAP(M) = M
            ISCR(M) = 1
          ENDDO
C
C         GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
          CALL ERI(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS,ITN)
C
C         MOST OF THIS ERI WORK IS WASTED -- WANT IBAS=KBAS, JBAS=LBAS.
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
C
C             NOTE THAT (--|--) = (++|++) AND (-+|-+) = (+-|+-)
              IF(IBAS.EQ.KBAS.AND.JBAS.EQ.LBAS) THEN
                GDSC(NA1+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M, 1)))
                GDSC(NA1+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M, 6)))
                GDSC(NA2+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M,11)))
                GDSC(NA2+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M,16)))
              ENDIF
C
C           END LOOP OVER KBAS AND LBAS
            ENDDO
          ENDDO
C
C         END LOOP OVER IBAS AND JBAS
        ENDDO
      ENDDO
C
C     END LOOP OVER COMPONENT OVERLAPS
4000  CONTINUE
C     END LOOP OVER |MQN| VALUES
3201  CONTINUE
3200  CONTINUE
3101  CONTINUE
3100  CONTINUE
3000  CONTINUE
C     END LOOP OVER KQNS
2201  CONTINUE
2200  CONTINUE
2101  CONTINUE
2100  CONTINUE
2000  CONTINUE
C     END LOOP OVER CENTRES
1201  CONTINUE
1200  CONTINUE
1101  CONTINUE
1100  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     SELF-COULOMB MATRIX COMPLETE.                                    C
C**********************************************************************C
C
      TITLE = 'GDSC_ARRAY'
C     CALL GNUMTRX(GDSC,TITLE,NDIM)

      RETURN
      END
C
C
      SUBROUTINE SELFBRT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C**********************************************************************C
C                                                                      C
C      SSSSSS  EEEEEEEE LL       FFFFFFFF BBBBBBB  RRRRRRR TTTTTTTT    C
C     SS    SS EE       LL       FF       BB    BB RR    RR   TT       C
C     SS       EE       LL       FF       BB    BB RR    RR   TT       C
C      SSSSSS  EEEEEE   LL       FFFFFF   BBBBBBB  RR    RR   TT       C
C           SS EE       LL       FF       BB    BB RRRRRRR    TT       C
C     SS    SS EE       LL       FF       BB    BB RR    RR   TT       C
C      SSSSSS  EEEEEEEE LLLLLLLL FF       BBBBBBB  RR    RR   TT       C
C                                                                      C
C -------------------------------------------------------------------- C
C  SELFBRT GENERATES DIAGONAL BREIT INTERACTION ELEMENTS FOR LATER     C
C  USE IN THE SCHWARZ INEQUALITY IN SCREENING PROCEDURES.              C
C**********************************************************************C
      PARAMETER(MDM=1200,MBS=26,MB2=MBS*MBS,MCT=4,MKP=9,MFL=15000000)
C
      CHARACTER*4 HMLT
      CHARACTER*80 TITLE
C
      DIMENSION EXPT(MBS,4),XYZ(3,4),KQN(4),MQN(4),NBAS(4),LQN(4),ITN(2)
      DIMENSION GDSC(MDM,MDM),BDSC(MDM,MDM)
C
      COMPLEX*16 RR(MB2,16)
C
      COMMON/EILS/EILSFL(MFL,24),IADILS(MCT,MCT,MKP,MKP,MKP,MKP)
      COMMON/IQTT/IABLL,ICDLL,IABSS,ICDSS,IABLS,ICDLS
      COMMON/MAKE/IEAB,IECD,IRIJ(MBS,MBS)
      COMMON/PRMS/CV,HMLT,IOPT,IMOL,INEW,ILEV,ISWZ,IEQS,IERC,IPAR,ICOR
      COMMON/SCRN/IMTX(MB2,11),ISCR(MB2),IMAP(MB2),IBCH,ITOG,MAXN
      COMMON/SPEC/BSET(MBS,MKP,MCT),BXYZ(3,MCT),ZNUC(MCT),AMSS(MCT),
     &            CNUC(MCT),PNUC,LRGE(MCT,MKP,MKP+1),NFNC(MKP,MCT),
     &            KAPA(MKP,MCT),IZNC(MCT),IQNC(MCT),LMAX(MCT),
     &            NKAP(MCT),NCNT,NDIM,NSKP,NOCC,NVRT
      COMMON/SWRZ/GDSC,BDSC
C
C     TURN OFF RC(AB|CD) LOCAL FILE PROCESS
      IERC = 0
C
C     COMPONENT OVERLAP LABELS TO LOOP OVER
      IF(HMLT.NE.'DHFP'.AND.HMLT.NE.'DHFB'.AND.HMLT.NE.'DHFQ') THEN
        RETURN
      ELSE
        ITSTRT = 2
        ITSTOP = 3
        ITSKIP = 1
      ENDIF
C
C     INITIALISE STORAGE MATRICES
      DO I=1,NDIM
        DO J=1,NDIM
          BDSC(I,J) = 0.0D0
        ENDDO
      ENDDO
C
C**********************************************************************C
C     LOOP OVER ATOMIC CENTRES (USE INDEX 1000)                        C
C**********************************************************************C
C
C     LOOP OVER CENTRE A
      DO 1000 ICNTA=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE A
        XYZ(1,1) = BXYZ(1,ICNTA)
        XYZ(2,1) = BXYZ(2,ICNTA)
        XYZ(3,1) = BXYZ(3,ICNTA)
C
C     LOOP OVER CENTRE B
      DO 1000 ICNTB=1,NCNT
C
C       CARTESIAN COORDINATES OF CENTRE B
        XYZ(1,2) = BXYZ(1,ICNTB)
        XYZ(2,2) = BXYZ(2,ICNTB)
        XYZ(3,2) = BXYZ(3,ICNTB)
C
C     LOOP OVER CENTRE C
      DO 1100 ICNTC=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE C'
        XYZ(1,3) = BXYZ(1,ICNTC)
        XYZ(2,3) = BXYZ(2,ICNTC)
        XYZ(3,3) = BXYZ(3,ICNTC)
C
        IF(ICNTC.NE.ICNTA) GOTO 1101
C
C     LOOP OVER CENTRE D
      DO 1200 ICNTD=1,NCNT
C
C       CARTESIAN COORDINATES OF 'CENTRE D'
        XYZ(1,4) = BXYZ(1,ICNTD)
        XYZ(2,4) = BXYZ(2,ICNTD)
        XYZ(3,4) = BXYZ(3,ICNTD)
C
        IF(ICNTD.NE.ICNTB) GOTO 1201
C
C**********************************************************************C
C     LOOP OVER ALL KQNS (INDEX 2000)                                  C
C**********************************************************************C
C
C     LOOP OVER KQN(A) VALUES
      DO 2000 KA=1,NKAP(ICNTA)
C
C       QUANTUM NUMBERS FOR BLOCK A
        KQN(1) = KAPA(KA,ICNTA)
        IF(KQN(1).LT.0) THEN
          LQN(1) =-KQN(1)-1
        ELSE
          LQN(1) = KQN(1)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK A
        NBAS(1) = NFNC(LQN(1)+1,ICNTA)
        DO IBAS=1,NBAS(1)
          EXPT(IBAS,1) = BSET(IBAS,LQN(1)+1,ICNTA)
        ENDDO
C
C     LOOP OVER KQN(B) VALUES
      DO 2000 KB=1,NKAP(ICNTB)
C
C       QUANTUM NUMBERS FOR BLOCK B
        KQN(2) = KAPA(KB,ICNTB)
        IF(KQN(2).LT.0) THEN
          LQN(2) =-KQN(2)-1
        ELSE
          LQN(2) = KQN(2)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK B
        NBAS(2) = NFNC(LQN(2)+1,ICNTB)
        DO JBAS=1,NBAS(2)
          EXPT(JBAS,2) = BSET(JBAS,LQN(2)+1,ICNTB)
        ENDDO
C
C     LOOP OVER KQN(C) VALUES
      DO 2100 KC=1,NKAP(ICNTC)
C
        IF(KC.NE.KA) GOTO 2101
C
C       QUANTUM NUMBERS FOR BLOCK C
        KQN(3) = KAPA(KC,ICNTC)
        IF(KQN(3).LT.0) THEN
          LQN(3) =-KQN(3)-1
        ELSE
          LQN(3) = KQN(3)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK C
        NBAS(3) = NFNC(LQN(3)+1,ICNTC)
        DO KBAS=1,NBAS(3)
          EXPT(KBAS,3) = BSET(KBAS,LQN(3)+1,ICNTC)
        ENDDO
C
C     LOOP OVER KQN(D) VALUES
      DO 2200 KD=1,NKAP(ICNTD)
C
        IF(KD.NE.KB) GOTO 2201
C
C       QUANTUM NUMBERS FOR BLOCK D
        KQN(4) = KAPA(KD,ICNTD)
        IF(KQN(4).LT.0) THEN
          LQN(4) =-KQN(4)-1
        ELSE
          LQN(4) = KQN(4)
        ENDIF
C
C       BASIS EXPONENTS FOR BLOCK D
        NBAS(4) = NFNC(LQN(4)+1,ICNTD)
        DO LBAS=1,NBAS(4)
          EXPT(LBAS,4) = BSET(LBAS,LQN(4)+1,ICNTD)
        ENDDO
C
C**********************************************************************C
C     LOOP OVER ALL |MQN| VALUES (INDEX 3000)                          C
C**********************************************************************C
C
C     LOOP OVER |MQN(A)| VALUES
      DO 3000 MA=1,IABS(KQN(1))
        MQN(1) = 2*MA-1
C
C     LOOP OVER |MQN(B)| VALUES
      DO 3000 MB=1,IABS(KQN(2))
        MQN(2) = 2*MB-1
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (AB) PAIR
      IABLS = IADILS(ICNTA,ICNTB,KA,KB,MA,MB)
C
C     LOOP OVER |MQN(C)| VALUES
      DO 3100 MC=1,IABS(KQN(3))
        MQN(3) = 2*MC-1
C
      IF(MC.NE.MA) GOTO 3101
C
C     LOOP OVER |MQN(D)| VALUES
      DO 3200 MD=1,IABS(KQN(4))
        MQN(4) = 2*MD-1
C
      IF(MD.NE.MB) GOTO 3201
C
C     EQ-COEFFICIENT STARTING ADDRESSES FOR (CD) PAIR
      ICDLS = IADILS(ICNTC,ICNTD,KC,KD,MC,MD)
C
C**********************************************************************C
C     LOOP OVER COMPONENT OVERLAP OPTIONS (INDEX 4000)                 C
C**********************************************************************C
C
C     LOOP OVER COMPONENT LABEL FOR A AND C: TT = LL (1) or SS (4)
      DO 4000 IT1=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(1) = IT1
C
C       CALCULATE STARTING ADDRESS
        IF(IT1.EQ.2) THEN
          NADDAB = 0
        ELSE
          NADDAB = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(AB) COEFFICIENTS FOR THIS COMPONENT LABEL
        IEAB = 1
C
C     LOOP OVER COMPONENT LABEL FOR B AND D: TT = LL (1) or SS (4)
      DO 4000 IT2=ITSTRT,ITSTOP,ITSKIP
C
C       PUT BLOCK VALUES INTO AN ARRAY FOR ERI ROUTINE LATER
        ITN(2) = IT2
C
C       CALCULATE STARTING ADDRESS
        IF(IT2.EQ.2) THEN
          NADDCD = 0
        ELSE
          NADDCD = NSKP
        ENDIF
C
C       FLAG READ-IN OF E0(CD) COEFFICIENTS FOR THIS COMPONENT LABEL
        IECD = 1

C     COMPONENT OVERLAP INDEX {(LL|LL)=1,(LL|SS)=2,(SS|LL)=3,(SS|SS)=4}
      ITT = (2*IT1+IT2)/3
C
C**********************************************************************C
C     MATRIX ADDRESS ALLOCATION                                        C
C**********************************************************************C
C
C     FOCK ADDRESS FOR EACH BASIS FUNCTION (WITH SPIN PROJECTION)
      NA1 = LRGE(ICNTA,KA,2*MA-1) + NADDAB
      NB1 = LRGE(ICNTB,KB,2*MB-1) + NADDCD
C
      NA2 = LRGE(ICNTA,KA,2*MA  ) + NADDAB
      NB2 = LRGE(ICNTB,KB,2*MB  ) + NADDCD
C
C**********************************************************************C
C     LOOP OVER BASIS FUNCTIONS IN BLOCKS A AND B.                     C
C     INCLUDE A BATCH OF ELECTRON REPULSION INTEGRALS INTO BMAT.       C
C     NO EFFORT HAS BEEN MADE TO UTILISE INTEGRAL SYMMETRY BECAUSE     C
C     ROUTINE TAKES ALMOST NO TIME TO RUN AND IS NEEDED ONLY ONCE.     C
C**********************************************************************C
C
C     LOOP OVER ELEMENTS OF FOCK MATRIX BLOCK
      DO IBAS=1,NBAS(1)
        DO JBAS=1,NBAS(2)
C
C         RESET SCREENING COUNTERS
          DO M=1,NBAS(3)*NBAS(4)
            IMAP(M) = M
            ISCR(M) = 1
          ENDDO
C
C         GENERATE BATCH OF ELECTRON REPULSION INTEGRALS
          CALL BII(RR,XYZ,KQN,MQN,NBAS,EXPT,IBAS,JBAS)
C
C         MOST OF THIS ERI WORK IS WASTED -- WANT IBAS=KBAS, JBAS=LBAS.
          M = 0
          DO KBAS=1,NBAS(3)
            DO LBAS=1,NBAS(4)
              M = M+1
C
C             NOTE THAT (--|++) = (++|--) AND (-+|+-) = (+-|-+)
              IF(IBAS.EQ.KBAS.AND.JBAS.EQ.LBAS) THEN
                BDSC(NA1+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M, 4)))
                BDSC(NA1+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M, 7)))
                BDSC(NA2+IBAS,NB1+JBAS) = DSQRT(ABS(RR(M,10)))
                BDSC(NA2+IBAS,NB2+JBAS) = DSQRT(ABS(RR(M,13)))
              ENDIF
C
C           END LOOP OVER KBAS AND LBAS
            ENDDO
          ENDDO
C
C         END LOOP OVER IBAS AND JBAS
        ENDDO
      ENDDO
C
C     END LOOP OVER COMPONENT OVERLAPS
4000  CONTINUE
C     END LOOP OVER |MQN| VALUES
3201  CONTINUE
3200  CONTINUE
3101  CONTINUE
3100  CONTINUE
3000  CONTINUE
C     END LOOP OVER KQNS
2201  CONTINUE
2200  CONTINUE
2101  CONTINUE
2100  CONTINUE
2000  CONTINUE
C     END LOOP OVER CENTRES
1201  CONTINUE
1200  CONTINUE
1101  CONTINUE
1100  CONTINUE
1000  CONTINUE
C
C**********************************************************************C
C     SELF-BREIT MATRIX COMPLETE.                                      C
C**********************************************************************C
C
      DO I=1,NSKP
        DO J=1,I
          BDSC(J,I) = BDSC(I,J)
        ENDDO
      ENDDO
C
      TITLE = 'BDSC_ARRAY'
C      CALL GNUMTRX(BDSC,TITLE,NDIM)
C
      RETURN
      END
